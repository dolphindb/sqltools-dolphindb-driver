{
    "abs": {
        "url": "https://docs.dolphindb.com/en/Functions/a/abs.html",
        "signatures": [
            {
                "full": "abs(X)",
                "name": "abs",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [abs](https://docs.dolphindb.com/en/Functions/a/abs.html)\n\n\n\n#### Syntax\n\nabs(X)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix.\n\n#### Details\n\nReturn the element-by-element absolute value(s) of *X*.\n\n#### Examples\n\n```\nabs(-2.0);\n// output: 2\n\nabs(-2 -3 4);\n// output: [2, 3, 4]\n```\n"
    },
    "acf": {
        "url": "https://docs.dolphindb.com/en/Functions/a/acf.html",
        "signatures": [
            {
                "full": "acf(X, maxLag)",
                "name": "acf",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "maxLag",
                        "name": "maxLag"
                    }
                ]
            }
        ],
        "markdown": "### [acf](https://docs.dolphindb.com/en/Functions/a/acf.html)\n\n\n\n#### Syntax\n\nacf(X, maxLag)\n\n#### Arguments\n\n**X** is a vector.\n\n**maxLag** is a positive integer.\n\n#### Details\n\nCalculate the autocorrelation of *X* from lag=1 to lag=*maxLag*. Note that the means of the two time series used in the calculation is the mean of *X* instead of the means of the two time series.\n\n#### Examples\n\n```\nn=10000\nx=array(double, n, n, NULL)\nx[0]=1\nr=rand(0.05, n)-0.025\nfor(i in 0:(n-1)){\n   x[i+1]=-0.8*x[i]+r[i]\n}\n\nacf = acf(x, 20)\nplot(acf,chartType=BAR)\n```\n"
    },
    "acos": {
        "url": "https://docs.dolphindb.com/en/Functions/a/acos.html",
        "signatures": [
            {
                "full": "acos(X)",
                "name": "acos",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [acos](https://docs.dolphindb.com/en/Functions/a/acos.html)\n\n\n\n#### Syntax\n\nacos(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nThe inverse cosine function.\n\n#### Examples\n\n```\nacos(1.000000 0.540302 -0.416147);\n// output\n[0,1,2]\n```\n\nRelated functions: [asin](https://docs.dolphindb.com/en/Functions/a/asin.html), [atan](https://docs.dolphindb.com/en/Functions/a/atan.html), [sin](https://docs.dolphindb.com/en/Functions/s/sin.html), [cos](https://docs.dolphindb.com/en/Functions/c/cos.html), [tan](https://docs.dolphindb.com/en/Functions/t/tan.html), [asinh](https://docs.dolphindb.com/en/Functions/a/asinh.html), [acosh](https://docs.dolphindb.com/en/Functions/a/acosh.html), [atanh](https://docs.dolphindb.com/en/Functions/a/atanh.html), [sinh](https://docs.dolphindb.com/en/Functions/s/sinh.html), [cosh](https://docs.dolphindb.com/en/Functions/c/cosh.html), [tanh](https://docs.dolphindb.com/en/Functions/t/tanh.html)\n"
    },
    "acosh": {
        "url": "https://docs.dolphindb.com/en/Functions/a/acosh.html",
        "signatures": [
            {
                "full": "acosh(X)",
                "name": "acosh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [acosh](https://docs.dolphindb.com/en/Functions/a/acosh.html)\n\n\n\n#### Syntax\n\nacosh(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nThe inverse hyperbolic cosine function.\n\n#### Examples\n\n```\nacosh(1 2 3);\n// output\n[0,1.316958,1.762747]\n```\n\nRelated functions: [asin](https://docs.dolphindb.com/en/Functions/a/asin.html), [acos](https://docs.dolphindb.com/en/Functions/a/acos.html), [atan](https://docs.dolphindb.com/en/Functions/a/atan.html), [sin](https://docs.dolphindb.com/en/Functions/s/sin.html), [cos](https://docs.dolphindb.com/en/Functions/c/cos.html), [tan](https://docs.dolphindb.com/en/Functions/t/tan.html), [asinh](https://docs.dolphindb.com/en/Functions/a/asinh.html), [atanh](https://docs.dolphindb.com/en/Functions/a/atanh.html), [sinh](https://docs.dolphindb.com/en/Functions/s/sinh.html), [cosh](https://docs.dolphindb.com/en/Functions/c/cosh.html), [tanh](https://docs.dolphindb.com/en/Functions/t/tanh.html)\n"
    },
    "adaBoostClassifier": {
        "url": "https://docs.dolphindb.com/en/Functions/a/adaBoostClassifier.html",
        "signatures": [
            {
                "full": "adaBoostClassifier(ds, yColName, xColNames, numClasses, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=10], [minImpurityDecrease=0.0], [learningRate=0.1], [algorithm='SAMME.R'], [randomSeed])",
                "name": "adaBoostClassifier",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "numClasses",
                        "name": "numClasses"
                    },
                    {
                        "full": "[maxFeatures=0]",
                        "name": "maxFeatures",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[numTrees=10]",
                        "name": "numTrees",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[numBins=32]",
                        "name": "numBins",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[maxDepth=10]",
                        "name": "maxDepth",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[minImpurityDecrease=0.0]",
                        "name": "minImpurityDecrease",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[learningRate=0.1]",
                        "name": "learningRate",
                        "optional": true,
                        "default": "0.1"
                    },
                    {
                        "full": "[algorithm='SAMME.R']",
                        "name": "algorithm",
                        "optional": true,
                        "default": "'SAMME.R'"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [adaBoostClassifier](https://docs.dolphindb.com/en/Functions/a/adaBoostClassifier.html)\n\n\n\n#### Syntax\n\nadaBoostClassifier(ds, yColName, xColNames, numClasses, \\[maxFeatures=0], \\[numTrees=10], \\[numBins=32], \\[maxDepth=10], \\[minImpurityDecrease=0.0], \\[learningRate=0.1], \\[algorithm='SAMME.R'], \\[randomSeed])\n\n#### Arguments\n\n**ds** is the data sources to be trained. It can be generated with function [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html).\n\n**yColName** is a string indicating the name of the category column in the data sources.\n\n**xColNames** is a string scalar/vector indicating the names of the feature columns in the data sources.\n\n**numClasses** is a positive integer indicating the number of categories in the category column. The value of the category column must be integers in \\[0, *numClasses*).\n\n**maxFeatures** (optional) is an integer or a floating number indicating the number of features to consider when looking for the best split. The default value is 0.\n\n* If *maxFeatures* is a positive integer, then consider *maxFeatures* features at each split.\n* If *maxFeatures* is 0, then `sqrt(the number of feature columns)` features are considered at each split.\n* If *maxFeatures* is a floating number between 0 and 1, then `int(maxFeatures * the number of feature columns)` features are considered at each split.\n\n**numTrees** (optional) is a positive integer indicating the number of trees. The default value is 10.\n\n**numBins** (optional) is a positive integer indicating the number of bins used when discretizing continuous features. The default value is 32. Increasing *numBins* allows the algorithm to consider more split candidates and make fine-grained split decisions. However, it also increases computation and communication time.\n\n**maxDepth** (optional) is a positive integer indicating the maximum depth of a tree. The default value is 10.\n\n**minImpurityDecrease** (optional) a node will be split if this split induces a decrease of the Gini impurity greater than or equal to this value. The default value is 0.\n\n**learningRate** (optional) is a positive floating number indicating the contribution of a regressor to the next regressor.\n\n**algorithm** (optional) is a string indicating the algorithm used. It can take the value of either \"SAMME.R\" or \"SAMME\". The default value is \"SAMME.R\".\n\n**randomSeed** (optional) is the seed used by the random number generator.\n\n#### Details\n\nFit an AdaBoost classification model. The result is a dictionary with the following keys: numClasses, minImpurityDecrease, maxDepth, numBins, numTress, maxFeatures, model, modelName, xColNames, learningRate and algorithm. model is a tuple with the result of the trained trees; modelName is \"AdaBoost Classifier\".\n\nThe fitted model can be used as an input for function [predict](https://docs.dolphindb.com/en/Functions/p/predict.html).\n\n#### Examples\n\nFit an AdaBoost classification model with simulated data:\n\n```\nt = table(100:0, `cls`x0`x1, [INT,DOUBLE,DOUBLE])\nn=5\ncls = take(0, n)\nx0 = norm(0, 10, n)\nx1 = norm(0, 10, n)\ninsert into t values (cls, x0, x1)\ncls = take(1, n)\nx0 = norm(1, 10, n)\nx1 = norm(1, 10, n)\ninsert into t values (cls, x0, x1)\nmodel = adaBoostClassifier(sqlDS(<select * from t>), `cls, `x0`x1, 2);\n```\n\nUse the fitted model in forecasting:\n\n```\nt1 = table(-0.5 0 1 2 as x0, -2 0 1 3 as x1)\npredict(model, t1);\n```\n\nSave the fitted model to disk:\n\n```\nsaveModel(model, \"C:/DolphinDB/data/classifierModel.bin\");\nloadModel(\"C:/DolphinDB/data/classifierModel.bin\");\n```\n\nRelated functions: [adaBoostRegressor](https://docs.dolphindb.com/en/Functions/a/adaBoostRegressor.html), [randomForestClassifier](https://docs.dolphindb.com/en/Functions/r/randomForestClassifier.html), [randomForestRegressor](https://docs.dolphindb.com/en/Functions/r/randomForestRegressor.html)\n"
    },
    "adaBoostRegressor": {
        "url": "https://docs.dolphindb.com/en/Functions/a/adaBoostRegressor.html",
        "signatures": [
            {
                "full": "adaBoostRegressor(ds, yColName, xColNames, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=10], [minImpurityDecrease=0.0], [learningRate=0.1], [loss='linear'], [randomSeed])",
                "name": "adaBoostRegressor",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[maxFeatures=0]",
                        "name": "maxFeatures",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[numTrees=10]",
                        "name": "numTrees",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[numBins=32]",
                        "name": "numBins",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[maxDepth=10]",
                        "name": "maxDepth",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[minImpurityDecrease=0.0]",
                        "name": "minImpurityDecrease",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[learningRate=0.1]",
                        "name": "learningRate",
                        "optional": true,
                        "default": "0.1"
                    },
                    {
                        "full": "[loss='linear']",
                        "name": "loss",
                        "optional": true,
                        "default": "'linear'"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [adaBoostRegressor](https://docs.dolphindb.com/en/Functions/a/adaBoostRegressor.html)\n\n\n\n#### Syntax\n\nadaBoostRegressor(ds, yColName, xColNames, \\[maxFeatures=0], \\[numTrees=10], \\[numBins=32], \\[maxDepth=10], \\[minImpurityDecrease=0.0], \\[learningRate=0.1], \\[loss='linear'], \\[randomSeed])\n\n#### Arguments\n\n**ds** is the data sources to be trained. It can be generated with function `sqlDS`.\n\n**yColName** is a string indicating the name of the dependent variable column in the data sources.\n\n**xColNames** is a string scalar/vector indicating the names of the feature columns in the data sources.\n\n**maxFeatures** (optional) is an integer or a floating number indicating the number of features to consider when looking for the best split. The default value is 0.\n\n* If *maxFeatures* is a positive integer, then consider maxFeatures features at each split.\n* If *maxFeatures* is 0, then sqrt(the number of feature columns) features are considered at each split.\n* If *maxFeatures* is a floating number between 0 and 1, then int(maxFeatures \\* the number of feature columns) features are considered at each split.\n\n**numTrees** (optional) is a positive integer indicating the number of trees. The default value is 10.\n\n**numBins** (optional) is a positive integer indicating the number of bins used when discretizing continuous features. The default value is 32. Increasing *numBins* allows the algorithm to consider more split candidates and make fine-grained split decisions. However, it also increases computation and communication time.\n\n**maxDepth** (optional) is a positive integer indicating the maximum depth of a tree. The default value is 10.\n\n**minImpurityDecrease** (optional) a node will be split if this split induces a decrease of impurity greater than or equal to this value. The default value is 0.\n\n**loss** (optional) is a string indicating the loss function to use when updating the weights after each boosting iteration. It can take the value of \"linear\", \"square\" or \"exponential\". The default value is \"linear\".\n\n**randomSeed** (optional) is the seed used by the random number generator.\n\n#### Details\n\nFit an AdaBoost regression model. The result is a dictionary with the following keys: minImpurityDecrease, maxDepth, numBins, numTress, maxFeatures, model, modelName, xColNames, learningRate and loss. model is a tuple with the result of the trained trees; modelName is \"AdaBoost Regressor\".\n\nThe fitted model can be used as an input for function [predict](https://docs.dolphindb.com/en/Functions/p/predict.html).\n\n#### Examples\n\nFit an AdaBoost regression model with simulated data:\n\n```\nn=10\nx1 = rand(1.0, n)\nx2 = rand(1.0, n)\nb0 = 1\nb1 = 1\nb2 = -2\nerr = norm(0, 0.2, n)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(y, x1, x2)\nmodel = adaBoostRegressor(sqlDS(<select * from t>), `y, `x1`x2);\n```\n\nUse the fitted model in forecasting:\n\n```\nt1 = table(0 0.4 0.7 1 as x1, 0.9 0.2 0.1 0 as x2)\npredict(model, t1);\n```\n\nSave the trained model to disk:\n\n```\nsaveModel(model, \"C:/DolphinDB/data/regressionModel.bin\")\n```\n\nLoad a saved model:\n\n```\nloadModel(\"C:/DolphinDB/data/regressionModel.bin\");\n```\n\nRelated functions: [adaBoostClassifier](https://docs.dolphindb.com/en/Functions/a/adaBoostClassifier.html), [randomForestClassifier](https://docs.dolphindb.com/en/Functions/r/randomForestClassifier.html), [randomForestRegressor](https://docs.dolphindb.com/en/Functions/r/randomForestRegressor.html)\n"
    },
    "add": {
        "url": "https://docs.dolphindb.com/en/Functions/a/add.html",
        "signatures": [
            {
                "full": "add(X, Y)",
                "name": "add",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [add](https://docs.dolphindb.com/en/Functions/a/add.html)\n\n\n\n#### Syntax\n\nadd(X, Y)\n\n#### Arguments\n\n**X** and **Y** is a scalar/pair/vector/matrix. If *X* or *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nReturn the element-by-element sum of X and Y.\n\n#### Examples\n\n```\nadd(3,2)\n// output\n5\n\n1:2+6\n// output\n7:8\n\n1:2+3:4\n// output\n4:6\n\n3+1..3\n// output\n[4,5,6]\n\nadd(1..3, 4..6)\n// output\n[5,7,9]\n\n(1..3).add(4..6)\n// output\n[5,7,9]\n\nx=reshape(1..6, 3:2)\nx\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\nx+1.5\n```\n\n| 0   | 1   |\n| --- | --- |\n| 2.5 | 5.5 |\n| 3.5 | 6.5 |\n| 4.5 | 7.5 |\n\n```\ny=reshape(5..10, 3:2)\ny\n```\n\n| 0 | 1  |\n| - | -- |\n| 5 | 8  |\n| 6 | 9  |\n| 7 | 10 |\n\n```\nx+y\n```\n\n| 0  | 1  |\n| -- | -- |\n| 6  | 12 |\n| 8  | 14 |\n| 10 | 16 |\n\nRefer to [\"+\" operator](https://docs.dolphindb.com/en/Programming/Operators/OperatorReferences/add.html)\n\nRelated function: [sub](https://docs.dolphindb.com/en/Functions/s/sub.html)\n"
    },
    "addAccessControl": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addAccessControl.html",
        "signatures": [
            {
                "full": "addAccessControl(table)",
                "name": "addAccessControl",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [addAccessControl](https://docs.dolphindb.com/en/Functions/a/addAccessControl.html)\n\n\n\n#### Syntax\n\naddAccessControl(table)\n\n#### Arguments\n\n**table** is a shared table or a streaming engine.\n\n#### Details\n\nAdd access control to the table created by the current user. Other users can access this table only after the administrator grants the privilege.\n\nNote:\n\n1. It can only be executed by administrators or the table creator.\n\n2. If the administrator has set access privileges to the table for other users by `grant`/`deny`/`revoke`, access control will be automatically added without calling `addAccessControl`. Users that are not granted privileges by the administrator cannot access the table.\n\n#### Examples\n\nCreate a user group for access management.\n\n```\nlogin(`admin, `123456)\ncreateUser(`u1, \"111111\");\ncreateUser(`u2, \"222222\");\ncreateUser(`u3, \"333333\");\n```\n\nFor streaming engines:\n\n```\n// user u1 create streaming engine agg1\nlogin(`u1, \"111111\")\nshare streamTable(1000:0, `time`sym`volume, [TIMESTAMP, SYMBOL, INT]) as trades\noutput1 = table(10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT])\nagg1 = createTimeSeriesEngine(name=\"agg1\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"agg1\", offset=0, handler=append!{agg1}, msgAsTable=true);\n// add access control for agg1\naddAccessControl(agg1)\n\n// user u2 logs in\nlogin(`u2, \"222222\")\n\n// insert data\ninsert into trades values(2018.10.08T01:01:01.785,`A,10) // \ninsert into agg1 values(2018.10.08T01:01:01.785,`A,10) // ERROR: No access to table [agg1]\n\n// drop stream engine\ndropStreamEngine(\"agg1\") // No access to drop stream engine agg1\n```\n\nFor shared in-memory tables:\n\n```\nlogin(`u1, \"111111\")\nt = table(take(`a`b`c`, 10) as sym, 1..10 as val)\nshare t as st;\naddAccessControl(`st)\n\nlogin(`u3, \"333333\")\nselect * from st // ERROR: No access to shared table [st]\ninsert into st values(`a, 4) // ERROR: No access to shared table [st]\n```\n"
    },
    "addColumn": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addColumn.html",
        "signatures": [
            {
                "full": "addColumn(table, colNames, colTypes)",
                "name": "addColumn",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            }
        ],
        "markdown": "### [addColumn](https://docs.dolphindb.com/en/Functions/a/addColumn.html)\n\n\n\n#### Syntax\n\naddColumn(table, colNames, colTypes)\n\n#### Arguments\n\n**table** can be a table of any type, including an in-memory table, a stream table, a DFS table, or a dimension table.\n\n**colNames** is a STRING scalar/vector indicating the name(s) of the column(s) to be added.\n\n**colTypes** is a scalar/vector indicating the data type(s) of the column(s) to be added.\n\n#### Details\n\nAdd a column or columns to a table. It is the only way to add a column to a stream table, a DFS table, or a dimension table. SQL `update` statement is not supported for these cases.\n\nNote that the table should be updated by function `loadTable` after adding a new column into a DFS table or dimension table with `addColumn`.\n\n#### Examples\n\nExample 1. Add columns to a DFS table.\n\n```\nID=1..6\nx=1..6\\5\nt1=table(ID, x)\ndb=database(\"dfs://rangedb\",RANGE,  1 4 7)\npt = db.createPartitionedTable(t1, `pt, `ID)\npt.append!(t1);\naddColumn(pt,[\"price\", \"qty\"],[DOUBLE, INT]);\n```\n\nAfter using `addColumn` and before data with the new schema is inserted, we can still insert data with the old schema.\n\n```\nt2=table(1 as ID, 1.2 as x)\npt.append!(t2)\nselect * from pt;\n```\n\n| ID | x   | price | qty |\n| -- | --- | ----- | --- |\n| 1  | 0.2 |       |     |\n| 2  | 0.4 |       |     |\n| 3  | 0.6 |       |     |\n| 1  | 1.2 |       |     |\n| 4  | 0.8 |       |     |\n| 5  | 1   |       |     |\n| 6  | 1.2 |       |     |\n\nAfter data with the new schema is inserted, however, data with the old schema can no longer be inserted.\n\n```\nt3=table(1 as ID, 1.6 as x, 10.0 as price, 6 as qty)\npt.append!(t3)\nselect * from pt;\n```\n\n| ID | x   | price | qty |\n| -- | --- | ----- | --- |\n| 1  | 0.2 |       |     |\n| 2  | 0.4 |       |     |\n| 3  | 0.6 |       |     |\n| 1  | 1.2 |       |     |\n| 1  | 1.6 | 10    | 6   |\n| 4  | 0.8 |       |     |\n| 5  | 1   |       |     |\n| 6  | 1.2 |       |     |\n\n```\nt4=table(2 as ID, 2.2 as x)\npt.append!(t4); // The data to append contains fewer columns than the schema.\n```\n\nExample 2. Add columns to a stream table.\n\n```\nn=10\nticker = rand(`MSFT`GOOG`FB`ORCL`IBM,n)\nx=rand(1.0, n)\nt=streamTable(ticker, x)\nshare t as st\naddColumn(st,[\"price\", \"qty\"],[DOUBLE, INT])\ninsert into st values(\"MSFT\",12.0,25.46,256)\nselect * from st;\n```\n\n| ticker | x                 | price | qty |\n| ------ | ----------------- | ----- | --- |\n| MSFT   | 0.743241031421349 |       |     |\n| FB     | 0.254624255700037 |       |     |\n| FB     | 0.947473830310628 |       |     |\n| FB     | 0.904140035156161 |       |     |\n| MSFT   | 0.193251194199547 |       |     |\n| MSFT   | 0.416090324753895 |       |     |\n| MSFT   | 0.479371337918565 |       |     |\n| ORCL   | 0.69910929678008  |       |     |\n| GOOG   | 0.131539688445628 |       |     |\n| MSFT   | 0.472390263108537 |       |     |\n| MSFT   | 12                | 25.46 | 256 |\n"
    },
    "addFunctionView": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addFunctionView.html",
        "signatures": [
            {
                "full": "addFunctionView(udf|moduleName)",
                "name": "addFunctionView",
                "parameters": [
                    {
                        "full": "udf|moduleName",
                        "name": "udf|moduleName"
                    }
                ]
            }
        ],
        "markdown": "### [addFunctionView](https://docs.dolphindb.com/en/Functions/a/addFunctionView.html)\n\n\n\n#### Syntax\n\naddFunctionView(udf|moduleName)\n\n#### Arguments\n\n**udf** is either a user-defined function or a tuple containing multiple user-defined functions.\n\n**moduleName** is a STRING scalar indicating a module name.\n\nNote:\n\n* Anonymous functions are not supported.\n* A user-defined function can only take scalars, pairs or regular vectors as default parameters.\n* The module specified by*moduleName*must be placed in the modules directory of the current node.\n* When module files have both *.dos* and *.dom* versions, *.dos* is loaded first.\n* When a module is loaded with `use <moduleName>` on the current node, and functions under a namespace with the same name are added as function views, the loaded module takes precedence if the function definitions are different.\n\n#### Details\n\nFunction view provides a flexible way to control user access to databases and tables. A function view is a user-defined function that encapsulates statements that access databases. Even if a user does not have the privilege to read the data of a database, the user can execute the function view to obtain the desired calculation result.\n\nSpecify user defined functions that can be executed by certain users although these users may not have TABLE\\_READ access to the datasets that these functions operate on. For example, a user who cannot see individual patient names or ages may nevertheless calculate the number of patients and the average age of patients.\n\nThe specified user defined functions can be used as the value of the parameter *objs* if the parameter *accessType* is set to VIEW\\_EXEC in command [grant](https://docs.dolphindb.com/en/Functions/g/grant.html), [deny](https://docs.dolphindb.com/en/Functions/d/deny.html) or [revoke](https://docs.dolphindb.com/en/Functions/r/revoke.html).\n\nUnlike other user-defined functions that are session isolated, the function view can be shared between sessions. The definition of the function view is persisted to the controller node, so if the DolphinDB cluster is restarted, the previously defined function view can still be used.\n\n`addFunctionView` can only be executed by administrators or users with VIEW\\_OWNER permission.\n\n#### Examples\n\nIn the following example, the user-defined function `getSpread` calculates the average bid-ask spread for a specified stock in the table *dfs\\://TAQ/quotes*. A user (user1) does not have the privilege to read table *dfs\\://TAQ/quotes*. Now define function `getSpread` to be a function view, and grant user1 the privilege to execute the function view. Although user1 cannot read the raw data of table *dfs\\://TAQ/quotes*, now she can execute the function view to calculate the average bid-ask spread of any stock in the table.\n\nPlease note that as table *dfs\\://TAQ/quotes* is a distributed database, the following script needs to be executed by a system administrator. User1 can execute function `getSpread` on any data node/compute node.\n\n```\ndef getSpread(s, d){\n    return select avg((ofr-bid)/(ofr+bid)*2) as spread from loadTable(\"dfs://TAQ\",\"quotes\") where symbol=s, date=d\n}\n```\n\n```\naddFunctionView(getSpread)\n\n// grant privileges on a controller\ngrant(\"user1\", VIEW_EXEC, \"getSpread\")\n```\n\nA module test.dos which defines functions `f1` and `f2` is placed under the modules directory:\n\n```\naddFunctionView(\"test\")\n\n// Grant user1 the execution privilege of f1\ngrant(\"user1\", VIEW_EXEC, \"test::f1\")\n// Grant user1 the execution privilege of all functions under test\ngrant(`user1, VIEW_EXEC, \"test::*\")\n\n// A granted user can use the fully qualified name to call a function\ntest::f1()\n```\n\nRelated functions: [dropFunctionView](https://docs.dolphindb.com/en/Functions/d/dropFunctionView.html)\n"
    },
    "addGpFunction": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addGpFunction.html",
        "signatures": [
            {
                "full": "addGpFunction(engine, func)",
                "name": "addGpFunction",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    }
                ]
            }
        ],
        "markdown": "### [addGpFunction](https://docs.dolphindb.com/en/Functions/a/addGpFunction.html)\n\n**Note:** This function is not supported by Community Edition. You can [get a trial](https://dolphindb.com/product#downloads-down) of Shark from DolphinDB official website.\n\n#### Syntax\n\naddGpFunction(engine, func)\n\n#### Arguments\n\n**engine** is the engine object returned by `createGPLearnEngine`.\n\n**func**is a user-defined function. Currently it does not support complex assignment, `if` or `for` statement. Only `return` statement can be used to return a combination of the training functions (see Appendix for supported functions). For example:\n\n```\ndef f(x, y){\n  return cos(x+y)\n}\n```\n\n#### Details\n\nAdd a user-defined training function to the GPLearn engine.\n\n#### Examples\n\n```\ndef f(x, y){\n  return cos(x+y)\n}\naddGpFunction(engine,f)\n```\n\n\n\n#### Appendix\n\nThe following table lists available functions for building and evolving programs. The parameter *n* indicates the sliding window size taken from *windowRange*. For all m-functions, if the current window is smaller than *n*, 0 is returned.\n\n| Function        | Number of Inputs | Description                                                                                    |\n| --------------- | ---------------- | ---------------------------------------------------------------------------------------------- |\n| add(x,y)        | 2                | Addition                                                                                       |\n| sub(x,y)        | 2                | Subtraction                                                                                    |\n| mul(x,y)        | 2                | Multiplication                                                                                 |\n| div(x,y)        | 2                | Division, returns 1 if the absolute value of the divisor is less than 0.001                    |\n| max(x,y)        | 2                | Maximum value                                                                                  |\n| min(x,y)        | 2                | Minimum value                                                                                  |\n| sqrt(x)         | 1                | Square root based on absolute value                                                            |\n| log(x)          | 1                | If x < 0.001, returns 0, otherwise returns log(abs(x))                                         |\n| neg(x)          | 1                | Negation                                                                                       |\n| reciprocal(x)   | 1                | Reciprocal, returns 0 if the absolute value of x is less than 0.001                            |\n| abs(x)          | 1                | Absolute value                                                                                 |\n| sin(x)          | 1                | Sine function                                                                                  |\n| cos(x)          | 1                | Cosine function                                                                                |\n| tan(x)          | 1                | Tangent function                                                                               |\n| sig(x)          | 1                | Sigmoid function                                                                               |\n| mdiff(x, n)     | 1                | n-th order difference of x                                                                     |\n| mcovar(x, y, n) | 2                | Covariance of x and y with a sliding window of size n                                          |\n| mcorr(x, y, n)  | 2                | Correlation of x and y with a sliding window of size n                                         |\n| mstd(x, n)      | 1                | Sample standard deviation of x with a sliding window of size n                                 |\n| mmax(x, n)      | 1                | Maximum value of x with a sliding window of size n                                             |\n| mmin(x, n)      | 1                | Minimum value of x with a sliding window of size n                                             |\n| msum(x, n)      | 1                | Sum of x with a sliding window of size n                                                       |\n| mavg(x, n)      | 1                | Average of x with a sliding window of size n                                                   |\n| mprod(x, n)     | 1                | Product of x with a sliding window of size n                                                   |\n| mvar(x, n)      | 1                | Sample variance of x with a sliding window of size n                                           |\n| mvarp(x, n)     | 1                | Population variance of x with a sliding window of size n                                       |\n| mstdp(x, n)     | 1                | Population standard deviation of x with a sliding window of size n                             |\n| mimin(x, n)     | 1                | Index of the minimum value of x with a sliding window of size n                                |\n| mimax(x, n)     | 1                | Index of the maximum value of x with a sliding window of size n                                |\n| mbeta(x, y, n)  | 2                | Least squares estimate of the regression coefficient of x on y with a sliding window of size n |\n| mwsum(x, y, n)  | 2                | Inner product of x and y with a sliding window of size n                                       |\n| mwavg(x, y, n)  | 2                | Weighted average of x using y as weights with a sliding window of size n                       |\n"
    },
    "addGroupMember": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addGroupMember.html",
        "signatures": [
            {
                "full": "addGroupMember(userIds, groupIds)",
                "name": "addGroupMember",
                "parameters": [
                    {
                        "full": "userIds",
                        "name": "userIds"
                    },
                    {
                        "full": "groupIds",
                        "name": "groupIds"
                    }
                ]
            }
        ],
        "markdown": "### [addGroupMember](https://docs.dolphindb.com/en/Functions/a/addGroupMember.html)\n\n\n\n#### Syntax\n\naddGroupMember(userIds, groupIds)\n\n#### Arguments\n\n**userIds** is a STRING scalar/vector indicating a user name or multiple user names.\n\n**groupIds** is a STRING scalar/vector indicating a group name or multiple group names.\n\n*userIds* and *groupIds* cannot both be vectors.\n\n#### Details\n\nAdd a user to a group or multiple groups, or add multiple users to a group.\n\nIt can only be executed by an administrator.\n\n#### Examples\n\n```\naddGroupMember(`AlexSmith`JoshAllen, `production);\n```\n"
    },
    "addMarketHoliday": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addMarketHoliday.html",
        "signatures": [
            {
                "full": "addMarketHoliday(marketName, holiday)",
                "name": "addMarketHoliday",
                "parameters": [
                    {
                        "full": "marketName",
                        "name": "marketName"
                    },
                    {
                        "full": "holiday",
                        "name": "holiday"
                    }
                ]
            },
            {
                "full": "addMarketHoliday(marketName, holiday, [dateType = 'holidayDate'])",
                "name": "addMarketHoliday",
                "parameters": [
                    {
                        "full": "marketName",
                        "name": "marketName"
                    },
                    {
                        "full": "holiday",
                        "name": "holiday"
                    },
                    {
                        "full": "[dateType = 'holidayDate']",
                        "name": "[dateType = 'holidayDate']"
                    }
                ]
            }
        ],
        "markdown": "### [addMarketHoliday](https://docs.dolphindb.com/en/Functions/a/addMarketHoliday.html)\n\n\n\n#### Syntax\n\naddMarketHoliday(marketName, holiday)\n\naddMarketHoliday(marketName, holiday, \\[dateType = 'holidayDate'])\n\n#### Arguments\n\n**marketName** is a STRING scalar, indicating the identifier of the trading calendar, e.g., the Market Identifier Code of an exchange, or a user-defined calendar name.\n\n**holiday** is a vector of DATE type, indicating weekday holidays.\n\n**holiday** is a vector of DATE type, indicating holiday dates or trading dates.\n\n* When *dateType*='holidayDate', *holiday* should be specified as the dates of weekday holidays.\n\n* When *dateType*='tradingDate', *holiday* should be specified as trading dates.\n\n**dateType** (optional) is a string, indicating the type of the added file from which the trading calendar is generated. It can take one of the following values: 'holidayDate' (default) and 'tradingDate'.\n\n#### Details\n\nAdds a holiday calendar online to generate a trading calendar.Adds a file of holiday dates or trading dates to generate a trading calendar. A CSV file named *marketName* will be generated in the directory specified by *marketHolidayDir*.\n\nNote:\n\n* It can only be executed by an administrator.\n\n* It only takes effect on the current node. In a cluster, `pnodeRun` can be used to call this function on all data/compute nodes.\n\n* *marketName*must consist of four uppercase letters and cannot be the same as the file name in *marketHolidayDir*.\n\n#### Examples\n\n```\naddMarketHoliday(\"DCBA\",2022.01.03 2022.01.05)\ntemporalAdd(2022.01.01,1,\"DCBA\")\n\n//Output: 2022.01.04\n```\n\n```\nindex = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.04]\ns = indexedSeries(index, 1..4)\ns.resample(\"DCBA\", sum);\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2021.12.31 | 6    |\n| 2022.01.04 | 4    |\n\nCreate a trading calendar containing trading dates:\n\n```\ntradingDates=[2024.02.08, 2024.02.09, 2024.02.18, 2024.02.19, 2024.02.20, 2024.02.21]\naddMarketHoliday(marketName=\"AAAA\", holiday=tradingDates, dateType='tradingDate')\n```\n\nA file named *AAAA.csv* will be generated in */server/marketHoliday/*. In the file is a column named \"tradingDate\", which contains data from the vector *tradingDates*.\n\n```\ntemporalAdd(2024.02.09, 1, \"AAAA\") \n\n// Output: 2024.02.18\n```\n\n```\ntemporalAdd(2024.02.21, 1, \"AAAA\")\n// Dates not included in AAAA.csv will throw an error: The returned date does not exist in trading calendar [AAAA].\n```\n\nRelated functions: [updateMarketHoliday](https://docs.dolphindb.com/en/Functions/u/updateMarketHoliday.html), [getMarketCalendar](https://docs.dolphindb.com/en/Functions/g/getMarketCalendar.html), [getTradingCalendarType](https://docs.dolphindb.com/en/Functions/g/getTradingCalendarType.html).\n"
    },
    "addMetrics": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addMetrics.html",
        "signatures": [
            {
                "full": "addMetrics(engine, newMetrics, newMetricsSchema, [windowSize], [fill])",
                "name": "addMetrics",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "newMetrics",
                        "name": "newMetrics"
                    },
                    {
                        "full": "newMetricsSchema",
                        "name": "newMetricsSchema"
                    },
                    {
                        "full": "[windowSize]",
                        "name": "windowSize",
                        "optional": true
                    },
                    {
                        "full": "[fill]",
                        "name": "fill",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [addMetrics](https://docs.dolphindb.com/en/Functions/a/addMetrics.html)\n\n\n\n#### Syntax\n\naddMetrics(engine, newMetrics, newMetricsSchema, \\[windowSize], \\[fill])\n\nAlias: extendMetrics\n\n#### Arguments\n\n**engine** is the abstract table object returned by a streaming engine function such as [createTimeSeriesEngine](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html). Note that `addMetrics` cannot be used in [createAnomalyDetectionEngine](https://docs.dolphindb.com/en/Functions/c/createAnomalyDetectionEngine.html) and [createReactiveStateEngine](https://docs.dolphindb.com/en/Functions/c/createReactiveStateEngine.html).\n\n**newMetrics** is metacode indicating the new metrics to be calculated by the streaming engine. The metacode can include one or more expressions, built-in or user-defined functions, or a constant scalar/vector. Note that the output column for a constant vector must be in array vector form.\n\n**newMetricsSchema** is a table object specifying the column names and data types of the new metrics in the output table.\n\n**windowSize** (optional) is a positive integer indicating the length of the windows for calculation for the new metrics. It is only used for the time-series engine. It must be one of the values of *windowSize* in the existing time-series engine. The default value is the first value of *windowSize* in the existing time-series engine.\n\n**fill** (optional) is a vector/scalar indicating the filling method to deal with an empty window (in a group). It can be:\n\n* 'none': no result\n\n* 'null': output a NULL value.\n\n* 'ffill': output the result in the last window.\n\n* specific value: output the specified value. Its type should be the same as metrics output's type.\n\n*fill* could be a vector to specify different filling method for each metric. The size of the vector must be consistent with the number of elements specified in *metrics*. The element in vector cannot be 'none'.\n\n#### Details\n\nDynamically add new measures to a streaming engine.\n\n#### Examples\n\nCalculate the sum of column x with a streaming engine:\n\n```\nshare streamTable(10000:0,`time`id`x, [TIMESTAMP,SYMBOL,INT]) as t\noutput1 = table(10000:0, `time`sum_x, [TIMESTAMP,INT])\nagg1 = createTimeSeriesEngine(name=`agg1, windowSize=100, step=50, metrics=<sum(x)>, dummyTable=t, outputTable=output1, timeColumn=`time)\nsubscribeTable(tableName=\"t\", actionName=\"agg1\", offset=0, handler=append!{agg1}, msgAsTable=true)\nn=500\ntime=2019.01.01T00:00:00.000+(1..n)\nid=take(`ABC`DEF, n)\nx=1..n\ninsert into t values(time, id, x);\nselect * from output1;\n```\n\n| time                    | sum\\_x |\n| ----------------------- | ------ |\n| 2019.01.01T00:00:00.050 | 1,225  |\n| 2019.01.01T00:00:00.100 | 4,950  |\n| 2019.01.01T00:00:00.150 | 9,950  |\n| 2019.01.01T00:00:00.200 | 14,950 |\n| 2019.01.01T00:00:00.300 | 24,950 |\n| 2019.01.01T00:00:00.350 | 29,950 |\n| 2019.01.01T00:00:00.400 | 34,950 |\n| 2019.01.01T00:00:00.450 | 39,950 |\n| 2019.01.01T00:00:00.500 | 44,950 |\n\nNow add a new measure `avg(x)` to the streaming engine. The new measure's column name is avg\\_x and the data type is DOUBLE in the output table.\n\n```\nnewMetricsSchema= table(1:0, [`avg_x], [DOUBLE])\naddMetrics(agg1, <avg(x)>, newMetricsSchema);\nn=300\ntime=2019.01.01T00:00:00.500+(1..n)\nid=take(`ABC`DEF, n)\nx=500+1..n\ninsert into t values(time, id, x);\nselect * from output1;\n```\n\n| time                    | sum\\_x | avg\\_x |\n| ----------------------- | ------ | ------ |\n| 2019.01.01T00:00:00.050 | 1,225  |        |\n| 2019.01.01T00:00:00.100 | 4,950  |        |\n| 2019.01.01T00:00:00.150 | 9,950  |        |\n| 2019.01.01T00:00:00.200 | 14,950 |        |\n| 2019.01.01T00:00:00.250 | 19,950 |        |\n| 2019.01.01T00:00:00.300 | 24,950 |        |\n| 2019.01.01T00:00:00.350 | 29,950 |        |\n| 2019.01.01T00:00:00.400 | 34,950 |        |\n| 2019.01.01T00:00:00.450 | 39,950 |        |\n| 2019.01.01T00:00:00.500 | 44,950 |        |\n| 2019.01.01T00:00:00.550 | 49,950 | 525    |\n| 2019.01.01T00:00:00.600 | 54,950 | 550    |\n| 2019.01.01T00:00:00.650 | 59,950 | 599.5  |\n| 2019.01.01T00:00:00.700 | 64,950 | 649.5  |\n| 2019.01.01T00:00:00.750 | 69,950 | 699.5  |\n| 2019.01.01T00:00:00.800 | 74,950 | 749.5  |\n"
    },
    "addNode": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addNode.html",
        "signatures": [
            {
                "full": "addNode(host, port, alias, [saveConfig=true],[nodeType='datanode'])",
                "name": "addNode",
                "parameters": [
                    {
                        "full": "host",
                        "name": "host"
                    },
                    {
                        "full": "port",
                        "name": "port"
                    },
                    {
                        "full": "alias",
                        "name": "alias"
                    },
                    {
                        "full": "[saveConfig=true]",
                        "name": "saveConfig",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[nodeType='datanode']",
                        "name": "nodeType",
                        "optional": true,
                        "default": "'datanode'"
                    }
                ]
            }
        ],
        "markdown": "### [addNode](https://docs.dolphindb.com/en/Functions/a/addNode.html)\n\n\n\n#### Syntax\n\naddNode(host, port, alias, \\[saveConfig=true],\\[nodeType='datanode'])\n\n#### Arguments\n\n**host** is a STRING scalar or vector indicating the IP address of the node(s).\n\n**port** is a positive integral scalar or vector indicating the port number of the node(s).\n\n**alias** is a STRING scalar or vector indicating the node alias(es).\n\n**saveConfig** (optional) is a Boolean value indicating whether to save the information of the node in the configuration file `cluster.nodes` when adding the node. The default value is true.\n\n**nodeType** (optional) is a STRING scalar or vector indicating the node type(s), which can be 'datanode' or 'computenode'.\n\nNote that the length of *host*, *port*, *alias*, *nodeType* must be consistent.\n\n#### Details\n\nAdd node(s) to a cluster. It can only be executed by administrator. The added nodes are not started. You can start the nodes in the cluster management web interface or in the command line.\n\nNote that you need to deploy an agent before adding a node on a new machine.\n\n#### Examples\n\n```\naddNode(\"192.168.1.103\",8900,\"node1\");\n```\n"
    },
    "addRangePartitions": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addRangePartitions.html",
        "signatures": [
            {
                "full": "addRangePartitions(dbHandle, newRanges, [level=0], [locations])",
                "name": "addRangePartitions",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "newRanges",
                        "name": "newRanges"
                    },
                    {
                        "full": "[level=0]",
                        "name": "level",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[locations]",
                        "name": "locations",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [addRangePartitions](https://docs.dolphindb.com/en/Functions/a/addRangePartitions.html)\n\n\n\n#### Syntax\n\naddRangePartitions(dbHandle, newRanges, \\[level=0], \\[locations])\n\n#### Arguments\n\n**dbHandle** is a database handle.\n\n**newRanges** is a vector indicating new partitions. The elements in the vector must be in ascending order. The first element must be the same as the last element or the original partition scheme.\n\n**level** (optional) is a non-negative integer. For a partitioned database with COMPO domain, we need to specify the level of the partitions that `addRangePartitions` applies if it is not for the first level of partitions. This level must be of a RANGE domain. The default value is 0.\n\n**locations** (optional) is a STRING scalar/vector. If the paramater *locations* was specified when the database was created, we can use *locations* to specify where the new partitions located.\n\n#### Details\n\nAppend new values to the partition scheme of a database. This database must be of RANGE domain or of COMPO domain with at least one level of RANGE domain. Note that the new partition can only be added after the last existing partition.\n\n#### Examples\n\nIn the following example, we add 3 new ID partitions \\[100,150), \\[150,200) and \\[200,250) to the partition scheme of a database of COMPO domain.\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(date, ID, x);\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID=database(, RANGE, 0 50 101);\ndb = database(\"dfs://compoDB\", COMPO, [dbDate,dbID]);\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n\naddRangePartitions(db,101 150 200 250,1)\n// output\n3\n```\n\nBefore appending data to the new partitions, we need to reload the table.\n\n```\ndb=database(\"dfs://compoDB\")\npt=loadTable(db,\"pt\")\n\nt1=table(rand(101..249,n) as ID,rand(2017.08.07..2017.08.11,n) as date,rand(10.0,n) as x)\npt.append!(t1);\n\nselect count(*) from loadTable(\"dfs://compoDB\",\"pt\");\n// output\n2000000\n```\n\nTo add new partitions consecutively without appending new data, we need to reload the database before each `addRangePartitions` operation.\n\n```\ndb=database(\"dfs://compoDB\")\npt=loadTable(db,\"pt\")\n\nt1=table(rand(2017.08.07..2017.08.11,n) as date, rand(101..249,n) as ID, rand(10.0,n) as x)\npt.append!(t1);\n\nselect count(*) from loadTable(\"dfs://compoDB\",\"pt\");\n//output\n2000000\n```\n"
    },
    "addReactiveMetrics": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addReactiveMetrics.html",
        "signatures": [
            {
                "full": "addReactiveMetrics(name, metricNames, metrics)",
                "name": "addReactiveMetrics",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metricNames",
                        "name": "metricNames"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    }
                ]
            }
        ],
        "markdown": "### [addReactiveMetrics](https://docs.dolphindb.com/en/Functions/a/addReactiveMetrics.html)\n\n\n\n#### Syntax\n\naddReactiveMetrics(name, metricNames, metrics)\n\n#### Details\n\nDynamically add new factors to a reactive state engine generated by `createNarrowReactiveStateEngine`. The added factors take effect on subsequent incoming data.\n\n#### Arguments\n\n**name**is a string indicating the engine name.\n\n**metricNames** is a STRING scalar or vector, indicating the name of the new factor. The number and order of names must align to that of factors specified in *metrics*.\n\n**metrics** is metacode or a tuple of metacode containing new factors.\n\n#### Examples\n\n```\ndummy = streamTable(1:0, [\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"upToDatePrice\",\"qty\",\"value\"], [STRING,STRING,STRING,TIMESTAMP,TIMESTAMP,DOUBLE,DOUBLE,INT]) \noutputTable = streamTable(1:0,[\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"metricNames\",\"factorValue\"], [STRING,STRING,STRING, TIMESTAMP,TIMESTAMP,STRING,DOUBLE])\nfactor = [<createTime>, <updateTime>,<cumsum(qty)>]\nNarrowtest = createNarrowReactiveStateEngine(name=\"narrowtest1\",metrics=factor,metricNames=\"factor1\",dummyTable=dummy,outputTable=outputTable,keyColumn=[\"securityID1\",\"securityID2\",\"securityID3\"])\nnum = 5\ntmp = table(take(\"A\" + lpad(string(1..4),4,\"0\"),num) as securityID1,take(\"CC.HH\" + lpad(string(21..34),4,\"0\"),num) as securityID2,take(\"FFICE\" + lpad(string(13..34),4,\"0\"),num) as securityID3, 2023.09.01 00:00:00+(1..num) as createTime, 2023.09.01 00:00:00+(1..num) as updateTime,100.0+(1..num) as upToDatePrice, 130.0+(1..num) as qty,take(1..3,num) as value)\nNarrowtest.append!(tmp)\n\nselect * from outputTable\n\nsecurityID1\tsecurityID2\tsecurityID3\tcreateTime\tupdateTime\tmetricNames\tfactorValue\nA0001\tCC.HH0021\tFFICE0013\t2023.09.01T00:00:01.000\t2023.09.01T00:00:01.000\tfactor1\t131\nA0002\tCC.HH0022\tFFICE0014\t2023.09.01T00:00:02.000\t2023.09.01T00:00:02.000\tfactor1\t132\nA0003\tCC.HH0023\tFFICE0015\t2023.09.01T00:00:03.000\t2023.09.01T00:00:03.000\tfactor1\t133\nA0004\tCC.HH0024\tFFICE0016\t2023.09.01T00:00:04.000\t2023.09.01T00:00:04.000\tfactor1\t134\nA0001\tCC.HH0025\tFFICE0017\t2023.09.01T00:00:05.000\t2023.09.01T00:00:05.000\tfactor1\t135\n\n\nmetrics = [<cumavg(upToDatePrice)>]\naddReactiveMetrics(\"narrowtest1\", \"factor2\", metrics)\n\n// After adding a new factor, the arrival of the new data to the engine will output the results of updated metrics\ntmp1 = table(\"A5\" as securityID1,\"CC.HH0033\" as securityID2,\"FFICE0034\" as securityID3, 2023.09.01 00:00:11 as createTime, 2023.09.01 00:00:09 as updateTime,59 as upToDatePrice,100 as qty,13 as value)\nNarrowtest.append!(tmp1)\nselect * from outputTable where securityID1=\"A5\"\n\nsecurityID1\tsecurityID2\tsecurityID3\tcreateTime\tupdateTime\tmetricNames\tfactorValue\nA5\tCC.HH0033\tFFICE0034\t2023.09.01T00:00:11.000\t2023.09.01T00:00:09.000\tfactor1\t100\nA5\tCC.HH0033\tFFICE0034\t2023.09.01T00:00:11.000\t2023.09.01T00:00:09.000\tfactor2\t59\n\n```\n\nRelated functions: [createNarrowReactiveStateEngine](https://docs.dolphindb.com/en/Functions/c/createNarrowReactiveStateEngine.html),[getReactiveMetrics](https://docs.dolphindb.com/en/Functions/g/getReactiveMetrics.html)\n"
    },
    "addValuePartitions": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addValuePartitions.html",
        "signatures": [
            {
                "full": "addValuePartitions(dbHandle, newValues, [level=0], [locations])",
                "name": "addValuePartitions",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "newValues",
                        "name": "newValues"
                    },
                    {
                        "full": "[level=0]",
                        "name": "level",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[locations]",
                        "name": "locations",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [addValuePartitions](https://docs.dolphindb.com/en/Functions/a/addValuePartitions.html)\n\n\n\n#### Syntax\n\naddValuePartitions(dbHandle, newValues, \\[level=0], \\[locations])\n\n#### Arguments\n\n**dbHandle** is a database handle.\n\n**newValues** is a scalar or vector indicating new partitions.\n\n**level** (optional) is a non-negative integer. For a partitioned database with COMPO domain, we need to specify the level of the partitions that `addValuePartitions` applies if it is not for the first level of partitions. This level must be of a VALUE domain. The default value is 0.\n\n**locations** (optional) is a STRING scalar/vector. If the paramater *locations* was specified when the database was created, we can use *locations* to specify where the new partitions located.\n\n#### Details\n\nAppend new values to the partition scheme of a database.\n\nThis database must be of VALUE domain or of COMPO domain with at least one level of VALUE domain.\n\n#### Examples\n\nIn the following example, we append (2017.08.12..2017.08.20) to the partition scheme of a database of COMPO domain.\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndbID=database(, RANGE, 0 50 100);\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndb = database(\"dfs://compoDB\", COMPO, [dbID, dbDate]);\npt = db.createPartitionedTable(t, `pt, `ID`date)\npt.append!(t)\n\naddValuePartitions(db,2017.08.12..2017.08.20,1)\n// output\n9\n```\n\nTo add new partitions consecutively without appending new data, we need to reload the database before each `addValuePartitions` operation.\n\n```\ndb=database(\"dfs://compoDB\")\npt=loadTable(db,\"pt\")\n\nt1=table(0..99 as ID,take(2017.08.12,100) as date,rand(10.0,100) as x)\npt.append!(t1)\n\nselect count(*) from loadTable(\"dfs://compoDB\",\"pt\")\n// output\n1000100\n```\n"
    },
    "addVolumes": {
        "url": "https://docs.dolphindb.com/en/Functions/a/addVolumes.html",
        "signatures": [
            {
                "full": "addVolumes(volumes)",
                "name": "addVolumes",
                "parameters": [
                    {
                        "full": "volumes",
                        "name": "volumes"
                    }
                ]
            }
        ],
        "markdown": "### [addVolumes](https://docs.dolphindb.com/en/Functions/a/addVolumes.html)\n\n\n\n#### Syntax\n\naddVolumes(volumes)\n\n#### Arguments\n\n**volumes** is a STRING scalar or vector indicating the volume path(s).\n\n#### Details\n\nDynamically add volume(s) without rebooting the cluster.\n\nNote: This command does not modify the cluster configuration file. Please manually update the configuration file before the next cluster reboot, or data cannot be written to the new volume(s) after reboot.\n\n#### Examples\n\n```\naddVolumes(\"/home/dolphindb/data\")\n```\n"
    },
    "adfuller": {
        "url": "https://docs.dolphindb.com/en/Functions/a/adfuller.html",
        "signatures": [
            {
                "full": "adfuller(X, [maxLag], [regression=\"c\"], [autoLag=\"aic\"], [store=false], [regResults=false])",
                "name": "adfuller",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[maxLag]",
                        "name": "maxLag",
                        "optional": true
                    },
                    {
                        "full": "[regression=\"c\"]",
                        "name": "regression",
                        "optional": true,
                        "default": "\"c\""
                    },
                    {
                        "full": "[autoLag=\"aic\"]",
                        "name": "autoLag",
                        "optional": true,
                        "default": "\"aic\""
                    },
                    {
                        "full": "[store=false]",
                        "name": "store",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[regResults=false]",
                        "name": "regResults",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [adfuller](https://docs.dolphindb.com/en/Functions/a/adfuller.html)\n\n\n\n#### Syntax\n\nadfuller(X, \\[maxLag], \\[regression=\"c\"], \\[autoLag=\"aic\"], \\[store=false], \\[regResults=false])\n\n#### Arguments\n\n**X** is a numeric vector indicating the time series data to test. The elements in X cannot be all identical, and NULL values are not supported.\n\n**maxlag** (optional) is a non-negative integer indicating the maximum lag which is included in test. The default value is `12*(nobs/100)^{1/4}` where nobs is the number of observations.\n\n**regression** (optional) is a string indicating the constant and trend order to include in regression. It can be:\n\n* \"c\" : constant only (default).\n\n* \"ct\" : constant and trend.\n\n* \"ctt\" : constant, and linear and quadratic trend.\n\n* \"n\" : no constant, no trend.\n\n**autoLag** (optional) is a string indicating the method to use when automatically determining the lag length among the values 0, 1, …, *maxlag*. It can be:\n\n* \"aic\": The number of lags is chosen to minimize the Akaike information criterion.\n\n* \"bic\": The number of lags is chosen to minimize the Bayesian information criterion.\n\n* \"tstat\": Start with *maxLag* and drops a lag until the t-statistic on the last lag length is significant using a 5%-sized test.\n\n* \"max\": The number of included lags is set to *maxLag*.\n\n**store** (optional) is a Boolean value. If set to true, the regression result is returned additionally to the adf statistic. The default value is false.\n\n**regResults** (optional) is a Boolean value. If set to true, the full regression results are returned. The default value is false.\n\n#### Details\n\nPerform Augmented Dickey-Fuller unit root test. It can be used to test for a unit root in a univariate process in the presence of serial correlation.\n\n**Return value**: A dictionary containing the following keys\n\n* adfStat: A floating-point scalar indicating the test statistic.\n\n* pValue: A floating-point scalar indicating the MacKinnon's approximate p-value based on MacKinnon (1994, 2010).\n\n* usedLag: An integer indicating the number of lags used.\n\n* nobs: An integer indicating the number of observations used for the ADF regression and calculation of the critical values.\n\n* criticalValues: A dictionary containing the critical values for the test statistic at the 1 %, 5 %, and 10 % levels.\n\n* icBest: A floating-point scalar indicating the maximized information criterion if *autoLag*is not max.\n\n* resultStore: A dictionary with results when *regResults*or *store*is set to true.\n\n#### Examples\n\n```\ndata = 234 267 289 301 312 323 334 345 356 367\nadfuller(data);\n```\n\nA dictionary is returned:\n\n```\nadfStat->-4.34190584894534\npValue->0.00037562619202430314\ncriticalValues->[-4.473135048010974,-3.2898806035665293,-2.772382345679012]\nusedLag->0\nnobs->9\nicBest->-195.23465793624445\n```\n"
    },
    "align": {
        "url": "https://docs.dolphindb.com/en/Functions/a/align.html",
        "signatures": [
            {
                "full": "align(left, right, [how='outer'], [byRow], [view=true])",
                "name": "align",
                "parameters": [
                    {
                        "full": "left",
                        "name": "left"
                    },
                    {
                        "full": "right",
                        "name": "right"
                    },
                    {
                        "full": "[how='outer']",
                        "name": "how",
                        "optional": true,
                        "default": "'outer'"
                    },
                    {
                        "full": "[byRow]",
                        "name": "byRow",
                        "optional": true
                    },
                    {
                        "full": "[view=true]",
                        "name": "view",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [align](https://docs.dolphindb.com/en/Functions/a/align.html)\n\n\n\n#### Syntax\n\nalign(left, right, \\[how='outer'], \\[byRow], \\[view=true])\n\n#### Arguments\n\n**left** and **right** are both matrices with column and/or row labels.\n\n**how** (optional) indicates the join method with which the two matrices are aligned. The matrices are aligned on the column labels and/or row labels. It can be 'outer' (or 'fj'), 'inner' (or 'ej'), 'left' (or 'lj') or 'asof ('aj')'. The default value is 'outer', indicating outer join.\n\n**byRow** (optional) is a Boolean or NULL value.\n\n* true: align the matrices on row labels.\n\n* false: align the matrices on the column labels.\n\n* NULL (default): align on the row labels and the column labels. Specify how in the format of \"\\<row\\_alignment>,\\<column alignment>\", e.g., `how=\"outer,inner\"`. Do not add a space or special character before or after the comma. If the same alignment method is used on rows and columns, it only needs to be specified once, e.g., `how=\"inner\"`.\n\nNote: The *left* and *right* matrices must both have the required labels (based on the value of *byRow*). The columns with the same label in both tables must have compatible data type. The supported data types and compatibility rules are as follows:\n\n* Integral (INT, SHORT, LONG and CHAR are compatible data types)\n\n* Floating (FLOAT and DOUBLE are compatible )\n\n* Temporal\n\n* STRING and SYMBOL (compatible data types)\n\n**view** (optional) is a Boolean value. The default value is true, indicating the result will be a view of the original matrix (shallow copy) and changes made to the original matrix will be reflected in the view. If set to false, the result will be a new matrix (deep copy).\n\n#### Details\n\nAlign the *left* and *right* matrices based on row labels and/or column labels (specified by *byRow*) using the join method specified by *how*. Return a tuple with 2 aligned matrices.\n\nNote:\n\n* The aligned matrices do not keep the attributes of the original matrices. For instance, an indexed matrix will no longer have index after the alignment.\n\n* To add column/row labels to a matrix, call `rename!`. Use the SQL keywords `exec` and `pivot by` to create a matrix with the columns specified in the `pivot by` clause as the matrix labels (see [pivotBy](https://docs.dolphindb.com/en/Programming/SQLStatements/pivotBy.html)).\n\n#### Context\n\nPrior to version 1.30.20/2.00.8, matrices must be converted to indexed matrices/series for binary operations. As the matrix/series will be aligned on index (with \"outer\" join), they must be monotonically increasing.\n\nWith the `align` function, alignment between matrices are more flexible in the following aspects:\n\n* Alignment between non-indexed matrices are supported. The matrices can be aligned on column/row labels which do not have to be monotonically increasing.\n\n* More options for the alignment methods.\n\n#### Examples\n\n```\n// align matrices with overlapping labels\nx1 = [09:00:00, 09:00:01, 09:00:03]\nx2 = [09:00:00, 09:00:03, 09:00:03, 09:00:04]\nm1 = matrix(1 2 3, 2 3 4, 3 4 5).rename!(x1)\nm2 = matrix(11 12 13, 12 13 14, 13 14 15, 14 15 16).rename!(x2)\na, b = align(m1, m2, 'fj', false);\na;\n```\n\n| 09:00:00 | 09:00:01 | 09:00:03 | 09:00:03 | 09:00:04 |\n| -------- | -------- | -------- | -------- | -------- |\n| 1        | 2        | 3        | 3        |          |\n| 2        | 3        | 4        | 4        |          |\n| 3        | 4        | 5        | 5        |          |\n\n```\nb;\n```\n\n| 09:00:00 | 09:00:01 | 09:00:03 | 09:00:03 | 09:00:04 |\n| -------- | -------- | -------- | -------- | -------- |\n| 11       |          | 12       | 13       | 14       |\n| 12       |          | 13       | 14       | 15       |\n| 13       |          | 14       | 15       | 16       |\n\n```\na+b;\n```\n\n| 09:00:00 | 09:00:01 | 09:00:03 | 09:00:03 | 09:00:04 |\n| -------- | -------- | -------- | -------- | -------- |\n| 12       |          | 15       | 16       |          |\n| 14       |          | 17       | 18       |          |\n| 16       |          | 19       | 20       |          |\n\n```\nm = align(m1, m2, 'aj', false);\nm[0];\n```\n\n| 09:00:00 | 09:00:01 | 09:00:03 |\n| -------- | -------- | -------- |\n| 1        | 2        | 3        |\n| 2        | 3        | 4        |\n| 3        | 4        | 5        |\n\n```\nm[1];\n```\n\n| 09:00:00 | 09:00:01 | 09:00:03 |\n| -------- | -------- | -------- |\n| 11       | 11       | 13       |\n| 12       | 12       | 14       |\n| 13       | 13       | 15       |\n\n```\n//create table pt for prices and vt for trading volumes\ntimestamp = [09:00:00, 09:00:02, 09:00:03, 09:00:06, 09:00:08]\nid= ['st1', 'st2', 'st1', 'st1', 'st2']\nprice = [197.8, 197.5, 198.4, 198.6, 198.6]\npt = table(timestamp, id, price)\n\ntimestamp = [09:00:00, 09:00:01, 09:00:02, 09:00:05, 09:00:08]\nid = ['st1', 'st2', 'st2', 'st3', 'st2']\nvol = [200, 300, 150, 200, 180]\nvt = table(timestamp, id, vol)\n\n// convert vt and pt to matrices. Use the columns specified by \"pivot by\" as labels for the matrices\nm1 = exec vol from vt pivot by timestamp, id\nm2 = exec price from pt pivot by timestamp, id\n\n// align the matrices using the full join method\nm = align(m1, m2, how='aj,fj')\n\n// get the matrix of the total trading value\nre = m[0] * m[1]\nre;\n```\n\n| label    | st1   | st2   | st3 |\n| -------- | ----- | ----- | --- |\n| 09:00:00 | 39560 |       |     |\n| 09:00:01 |       |       |     |\n| 09:00:02 |       | 29625 |     |\n| 09:00:03 |       |       |     |\n| 09:00:05 |       |       |     |\n| 09:00:08 |       | 35748 |     |\n"
    },
    "all": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/all.html",
        "signatures": [
            {
                "full": "all(func, args...)",
                "name": "all",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [all](https://docs.dolphindb.com/en/Functions/Templates/all.html)\n\n\n\n#### Syntax\n\nall(func, args...)\n\n#### Arguments\n\n**func** is a function.\n\n**args** are the required parameters of *func*. They can be vectors/matrices/tables. They do not need to have the same data form, but they must have the same size. Data size is the number of elements for a vector, the number of columns for a matrix, and the number of rows for a table.\n\n#### Details\n\nApply a function on each element of all arguments. The template runs through each element of a vector, each column of a matrix, and each row of a table. It stops execution and returns a false value as soon as one function call returns a false value. It returns a true value if all function calls return true values.\n\n#### Examples\n\nTemplate `all` on a vector:\n\n```\nx = 1 2 NULL 11 NULL 13 NULL 102 103;\ny = x cut 3;\ny;\n// output\n([1,2,],[11,,13],[,102,103])\n\nall(hasNull, y);\n// output\n1\n// check if all of [1,2,],[11,,13],[,102,103] has NULL values\n\nx = 1 25 7 15 11 197 16 18 23;\ny = x cut 3;\ny;\n// output\n([1,25,7],[15,11,197],[16,18,23])\n\nall(in, 7 11 23, y);\n// output\n1\n// check if 7 in [1,25,7], 11 in [15,11,197], and 23 in [16,18,23]\n\nall(in, 7 8 23, y);\n// output\n0\n// return false as 8 is not in [15,11,197]\n\nall(lt, 1 2 3, 4 5 6);\n// output\n1\n// check if 1<4, 2<5 and 3<6\n\nall(lt, 1 2 7, 4 5 6);\n// output\n0\n// return false as 7<6 is false\n```\n\nTemplate `all` on a matrix. For a matrix, the template runs through each column.\n\n```\nx=1..6$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nall(in, 1 4 5, x);\n// output\n1\n\nall(in, 1 2 5, x);\n// output\n0\n// return false as 2 is not in the second column of matrix x\n```\n\nTemplate `all` on a table. For a table, the template runs through each row. In the following example, we define a function `varscompare` to compare the values of 2 variables in a table.\n\n```\nx=table(1 2 3 as a, 4 5 6 as b);\nx;\n```\n\n| a | b |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\ndef varscompare(t):t.a<t.b;\nall(varscompare, x);\n// output\n1\n\ny=table(1 7 3 as a, 4 5 6 as b);\n// output\ny;\n```\n\n| a | b |\n| - | - |\n| 1 | 4 |\n| 7 | 5 |\n| 3 | 6 |\n\n```\nall(varscompare, y);\n// output\n0\n// return false as 7<5 is false\n```\n"
    },
    "and": {
        "url": "https://docs.dolphindb.com/en/Functions/a/and.html",
        "signatures": [
            {
                "full": "and(X, Y)",
                "name": "and",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [and](https://docs.dolphindb.com/en/Functions/a/and.html)\n\n\n\n#### Syntax\n\nand(X, Y)\n\nor\n\nX && Y\n\n#### Arguments\n\n**X** / **Y** is a scalar/pair/vector/matrix. If *X* or *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nReturn the element-by-element logical X AND Y.\n\n#### Examples\n\n```\n1 && 3;\n// output\n1\n\nx=1 2 3\nx && 0\n// output\n[0,0,0]\n\nx=1 2 3\ny=0 1 0\nx && y\n// output\n[0,1,0]\n\nt=table(1 2 2 3 as id, 4 5 6 5 as value)\nt\n```\n\n| id | value |\n| -- | ----- |\n| 1  | 4     |\n| 2  | 5     |\n| 2  | 6     |\n| 3  | 5     |\n\n```\nselect id, value from t where id=2 and value=5;\n```\n\n| id | value |\n| -- | ----- |\n| 2  | 5     |\n\nRelated functions: [or](https://docs.dolphindb.com/en/Programming/Operators/OperatorReferences/or.html), [not](https://docs.dolphindb.com/en/Functions/n/not.html)\n"
    },
    "anova": {
        "url": "https://docs.dolphindb.com/en/Functions/a/anova.html",
        "signatures": [
            {
                "full": "anova(X)",
                "name": "anova",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [anova](https://docs.dolphindb.com/en/Functions/a/anova.html)\n\n\n\n#### Syntax\n\nanova(X)\n\n#### Arguments\n\n**X** is a matrix or a table with numeric columns.\n\n#### Details\n\nConduct one-way analysis of variance (ANOVA). Each column in *X* is a group.\n\nReturn a dictionary with the following keys:\n\n* pValue: p-value of the F-statistic\n* fValue: F-statistic\n* ssBetween: sum of squares between groups\n* dfBetween: degrees of freedom between groups\n* ssWithin: sum of squares within groups\n* dfWithin: degrees of freedom for each group\n\n#### Examples\n\n```\na=300 287 301 400 211 399 412 312 390 412\nb=240 259 302 311 210 402 390 298 347 380\nc=210 230 213 210 220 208 290 300 201 201\nm=matrix(a,b,c)\nanova(m);\n\n// output\npValue->0.000515\nfValue->10.15459\nssBetween->70528.066667\ndfBetween->2\nssWithin->93763.4\ndfWithin->27\n```\n"
    },
    "any": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/any.html",
        "signatures": [
            {
                "full": "any(func, args...)",
                "name": "any",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [any](https://docs.dolphindb.com/en/Functions/Templates/any.html)\n\n\n\n#### Syntax\n\nany(func, args...)\n\n#### Arguments\n\n**func** is a function.\n\n**args** are the required parameters of *func*. They can be vectors/matrices/tables. They do not need to have the same data form, but they must have the same size. Data size is the number of elements for a vector, the number of columns for a matrix, and the number of rows for a table.\n\n#### Details\n\nApply a function on each element of all arguments. The template runs through each element of a vector, each column of a matrix, and each row of a table. It stops execution and returns a true value as soon as one function call returns a true value. It returns a false value if all function calls return false values.\n\n#### Examples\n\nTemplate `any` on a vector:\n\n```\nx = 1 2 3 11 12 13 NULL 102 103;\ny = x cut 3;\ny;\n// output\n([1,2,3],[11,12,13],[,102,103])\n\nany(hasNull, y);\n// output\n1\n// check if any of [1,2,3],[11,12,13],[,102,103] has NULL values;\n\nx=1 25 7 15 11 197 16 18 23;\ny=x cut 3;\ny;\n// output\n([1,25,7],[15,11,197],[16,18,23])\n\nany(in, 7 8 23, y);\n// output\n1\n// return true since 7 is in [1, 25, 7], although 8 is not in [15,11,197]\n\nany(in, 8 20 19, y);\n// output\n0\n// 8 is not in [1,25,7], 20 is not in [15,11,197], and 19 is not in [16,18,23]\n\nany(lt, 4 5 6, 1 2 3);\n// output\n0\n// check if 4<1, 5<2 and 6<3\n\nany(<, 4 5 6, 1 7 3);\n// output\n1\n// return true as 5<7 is true\n```\n\nTemplate `any` on a matrix. For a matrix, the template runs through each column.\n\n```\nx=1..6$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nany(in, 6 1 4, x);\n// output\n0\n\nany(in, 3 4 2, x);\n// output\n1\n// return true as 4 is in the second column of matrix x\n```\n\nTemplate `any` on a table. For a table, the template runs through each row. In the following example, we define a function `varscompare` to compare the values of 2 variables in a table.\n\n```\nx=table(1 2 3 as a, 4 5 6 as b);\nx;\n```\n\n| a | b |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\ndef varscompare(t): t.a>t.b;\nany(varscompare, x);\n// output\n0\n\ny=table(1 7 3 as a, 4 5 6 as b);\ny;\n```\n\n| a | b |\n| - | - |\n| 1 | 4 |\n| 7 | 5 |\n| 3 | 6 |\n\n```\nany(varscompare, y);\n// output\n1\n//return true as 7>5 is true\n```\n"
    },
    "append!": {
        "url": "https://docs.dolphindb.com/en/Functions/a/append!.html",
        "signatures": [
            {
                "full": "append!(obj, newData)",
                "name": "append!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "newData",
                        "name": "newData"
                    }
                ]
            }
        ],
        "markdown": "### [append!](https://docs.dolphindb.com/en/Functions/a/append!.html)\n\n\n\n#### Syntax\n\nappend!(obj, newData)\n\nAlias: push!\n\n#### Arguments\n\n**obj** is a local variable, and it must be a vector/tuple/matrix/table/set.\n\n**newData** is a scalar/vector/tuple/table/set.\n\n* If *obj* is a vector, *newData* is a scalar, vector, or tuple whose elements are of the same type as *obj*. The result is a vector longer than *obj*.\n\n* If *obj* is a tuple, *newData* is a scalar, vector or tuple:\n  * If *newData* is a vector, it is appended to *obj* as one tuple element;\n\n  * If *newData* is a tuple, the *appendTupleAsAWhole* configuration parameter controls whether it is appended to *obj* as one tuple element (true) or each of its elements is appended independently (false).\n\n* If *obj* is a matrix, *newData* is a vector whose length must be a multiple of the number of rows of *obj*. The result is a matrix with the same number of rows as *obj* but with more columns.\n\n* If *obj* is a table, *newData* is a table with the same number of columns as *obj*. The result is a table with the same number and name of columns as *obj* but with more rows.\n\n* If *newData* and *obj* are of different data forms, `append!` will attempt to convert *newData* to the same data form as *obj*. If it is not possible, return an error message.\n\n#### Details\n\nAppend *newData* to *obj*. The exclamation mark (!) means in-place change in DolphinDB.\n\nNote: In most cases, the column names and orders in the tables should be consistent. Please first check whether the corresponding columns in *obj* and *newData* have the same names and are arranged in the same order before executing `append!`. The function does not check the consistency of column names or align the columns if they are not arranged in the same order. It is executed as long as the corresponding columns are of the same data types.\n\n#### Examples\n\n```\nx = 1 2 3\nx.append!(4)\nx\n// output\n[1,2,3,4]\n\nappend!(x, 5 6)\nx\n//output\n[1,2,3,4,5,6]\n\nx.append!(7.2)\nx\n//output\n[1,2,3,4,5,6,7]\n// converted DOUBLE 7.2 to INT 7\n\nx.append!(`XOM)\n// Error: Incompatible type. Expected: INT, Actual: STRING\n\nx=array(int, 0, 10) // x is an empty vector\nx\n//output\n[]\n\nx.append!(1)\nx\n//output\n[]\n\nx=array(symbol, 0, 100)\nappend!(x, `TEST)\nx\n//output\n[\"TEST\"]\n\nx=1..6$3:2\nx\n\nx = (1,\"X\")\ny = (2,\"Y\")\nx.append!(y)\nprint(x)\n// when appendTupleAsAWhole = true\n(1,\"X\",(2,\"Y\"))\n// when appendTupleAsAWhole = false\n(1,\"X\",2,\"Y\")\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\nx.append!(7..12)\nx\n```\n\n| 0 | 1 | 2 | 3  |\n| - | - | - | -- |\n| 1 | 4 | 7 | 10 |\n| 2 | 5 | 8 | 11 |\n| 3 | 6 | 9 | 12 |\n\n```\nx=set(1 2 3 4)\nx.append!(6)\nx\n// output\nset(6,1,2,3,4)\n\nt1=table(1 2 3 as x, 4 5 6 as y)\nt2=table(1.1 2.2 3.3 as a, 4.4 5.5 6.6 as b)\nt1.append!(t2)\nt1\n```\n\n| x | y |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n| 1 | 4 |\n| 2 | 6 |\n| 3 | 7 |\n\nUse `append!` to add data to a DFS table. The following example should be executed in a DFS cluster.\n\n```\nn=1000000\nt=table(rand(`IBM`MS`APPL`AMZN,n) as symbol, rand(10.0, n) as value)\ndb = database(\"dfs://rangedb_tradedata\", RANGE, `A`F`M`S`ZZZZ)\nTrades = db.createPartitionedTable(t, \"Trades\", \"symbol\")\n```\n\nWe have created an empty table Trades with the schema of t. Next, we append the empty table Trades with data from table t.\n\n```\nTrades.append!(t)\nselect count(*) from Trades;\n// output\n1000000\n```\n\nTo append table Trades with another table:\n\n```\nn=500000\nt1=table(rand(`FB`GE`MSFT,n) as symbol, rand(100.0, n) as value)\nTrades.append!(t1)\nselect count(*) from Trades\n// output\n1500000\n```\n"
    },
    "appendForJoin": {
        "url": "https://docs.dolphindb.com/en/Functions/a/appendForJoin.html",
        "signatures": [
            {
                "full": "appendForJoin(engine, isLeftTable, data)",
                "name": "appendForJoin",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "isLeftTable",
                        "name": "isLeftTable"
                    },
                    {
                        "full": "data",
                        "name": "data"
                    }
                ]
            }
        ],
        "markdown": "### [appendForJoin](https://docs.dolphindb.com/en/Functions/a/appendForJoin.html)\n\n\n\n#### Syntax\n\nappendForJoin(engine, isLeftTable, data)\n\n#### Arguments\n\n**engine** is a streaming join engine, which is the abstract table object returned by function `createAsofJoinEngine`, `createEquiJoinEngine`, `createWindowJoinEngine`, `createLeftSemiJoinEngine`, or `createLookupJoinEngine`.\n\n**isLeftTable** is a Boolean value indicating whether to insert into the left table or right table.\n\n**data** is the data to be ingested into the streaming engine.\n\n#### Details\n\nInsert data into a streaming join engine.\n\nPlease note that the parameter *handler* of function [subscribeTable](https://docs.dolphindb.com/en/Functions/s/subscribeTable.html) must be `appendForJoin`, [getLeftStream](https://docs.dolphindb.com/en/Functions/g/getLeftStream.html), or [getRightStream](https://docs.dolphindb.com/en/Functions/g/getRightStream.html) while subscribing to a stream table of a streaming join engine.\n\n#### Examples\n\n```\nleftTable=table(1:0, `timestamp`sym`price, [TIMESTAMP, SYMBOL, DOUBLE])\nrightTable=table(1:0, `timestamp`sym`val, [TIMESTAMP, SYMBOL, DOUBLE])\noutput=table(100:0, `timestamp`sym`price`val`total, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE])\najEngine=createAsofJoinEngine(\"test1\", leftTable, rightTable, output, <[price, val, price*val]>, `sym, `timestamp, false, 7)\n\ntmp1=table(take(2012.01.01T00:00:00.000+[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) as timestamp, take(`AAPL, 10) join take(`IBM, 10) as sym, double(1..20) as price)\ntmp2=table(take(2012.01.01T00:00:00.000+[1, 2, 3, 4, 4, 4, 4, 4, 4, 4], 20) as timestamp, take(`AAPL, 10) join take(`IBM, 10) as sym, double(1..20) as val)\n\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.001))\nappendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.001))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.002))\nappendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.002))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.003))\nappendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.003))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.004))\nappendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.004))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.005))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.006))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.007))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.008))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.009))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.010))\n\nsleep(5000)\n```\n"
    },
    "appendMsg": {
        "url": "https://docs.dolphindb.com/en/Functions/a/appendMsg.html",
        "signatures": [
            {
                "full": "appendMsg(engine, msgBody, msgId)",
                "name": "appendMsg",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "msgBody",
                        "name": "msgBody"
                    },
                    {
                        "full": "msgId",
                        "name": "msgId"
                    }
                ]
            }
        ],
        "markdown": "### [appendMsg](https://docs.dolphindb.com/en/Functions/a/appendMsg.html)\n\n\n\n#### Syntax\n\nappendMsg(engine, msgBody, msgId)\n\n#### Arguments\n\n**engine** is a built-in streaming engine, i.e., the abstract table object return by functions such as [createReactiveStateEngine](https://docs.dolphindb.com/en/Functions/c/createReactiveStateEngine.html)\n\n**msgBody** is the messages to be ingested into the streaming engine.\n\n**msgId** is the ID of the last message that has been ingested into the streaming engine. The ID starts from the beginning of the subscription.\n\n#### Details\n\nIf *snapshot* is enabled and *RaftGroup* is disabled for a streaming engine, the *handler* parameter of function [subscribeTable](https://docs.dolphindb.com/en/Functions/s/subscribeTable.html) must be `appendMsg` to inject the data into the engine.\n\n#### Examples\n\n```\nshare streamTable(10000:0,`time`sym`price, [TIMESTAMP,SYMBOL,DOUBLE]) as trades\noutput1 =table(10000:0, `time`sym`avgPrice, [TIMESTAMP,SYMBOL,DOUBLE]);\n\nengine1 = createTimeSeriesEngine(name=`engine1, windowSize=100, step=50, metrics=<avg(price)>, dummyTable=trades, outputTable=output1, timeColumn=`time, keyColumn=`sym, snapshotDir=\"C:/DolphinDB/Data/snapshotDir\", snapshotIntervalInMsgCount=100)\nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=appendMsg{engine1}, msgAsTable=true, handlerNeedMsgId=true)\n\nn=500\ntimev=2021.03.12T15:00:00.000 + (1..n join 1..n)\nsymv = take(`A, n) join take(`B, n)\npricev = (100+cumsum(rand(1.0,n)-0.5)) join (200+cumsum(rand(1.0,n)-0.5))\nt=table(timev as time, symv as sym, pricev as price).sortBy!(`time)\ntrades.append!(t)\n\nselect * from output1\n```\n"
    },
    "appendTuple!": {
        "url": "https://docs.dolphindb.com/en/Functions/a/appendtuple.html",
        "signatures": [
            {
                "full": "appendTuple!(X, Y, [wholistic=false])",
                "name": "appendTuple!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[wholistic=false]",
                        "name": "wholistic",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [appendTuple!](https://docs.dolphindb.com/en/Functions/a/appendtuple.html)\n\n\n\n#### Syntax\n\nappendTuple!(X, Y, \\[wholistic=false])\n\n#### Arguments\n\n**X** is a tuple.\n\n**Y** is a tuple.\n\n**wholistic** is a Boolean. The default value is false.\n\n#### Details\n\nAppend *Y* to *X*:\n\n* If *wholistic* = true, *Y* is appended as one tuple element;\n\n* If *wholistic*= false, each element of *Y* is appended independently.\n\nIf *X* is a columnar tuple, *wholistic* must be set to false, and the elements of *Y* must have the same data type as those of *X*.\n\n#### Examples\n\n```language-python\n$ x = (1,\"X\")\n$ y = ([2,3],\"Y\")\n$ x.appendTuple!(y,true)\n$ print(x)\n(1,\"X\",([2,3],\"Y\"))\n\n$ x.appendTuple!(y,false)\n$ print(x)\n(1,\"X\",([2,3],\"Y\"),[2,3],\"Y\")\n\n$ x = [[1,2,3],4]\n$ x.setColumnarTuple!()\n$ x.appendTuple!((5,6),false)\n$ print(x)\n([1,2,3],4,5,6)\n```\n"
    },
    "array": {
        "url": "https://docs.dolphindb.com/en/Functions/a/array.html",
        "signatures": [
            {
                "full": "array(dataType|template, [initialSize], [capacity], [defaultValue])",
                "name": "array",
                "parameters": [
                    {
                        "full": "dataType|template",
                        "name": "dataType|template"
                    },
                    {
                        "full": "[initialSize]",
                        "name": "initialSize",
                        "optional": true
                    },
                    {
                        "full": "[capacity]",
                        "name": "capacity",
                        "optional": true
                    },
                    {
                        "full": "[defaultValue]",
                        "name": "defaultValue",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [array](https://docs.dolphindb.com/en/Functions/a/array.html)\n\n\n\n#### Syntax\n\narray(dataType|template, \\[initialSize], \\[capacity], \\[defaultValue])\n\n#### Arguments\n\n**dataType** is the data type for the vector.\n\n**template** is an existing vector. The existing vector serves as a template and its data type determines the new vector's data type.\n\n**initialSize** (optional) is the initial size (in terms of the number of elements) of the vector.\n\n**capacity** (optional) is the amount of memory (in terms of the number of elements) allocated to the array. When the number of elements exceeds capacity, the system will first allocate memory of 1.2\\~2 times of capacity, copy the data to the new memory space, and release the original memory.\n\n**defaultValue** (optional) is the default value of the vector. It must be a scalar. If *defaultValue* is not specified, it defaults to NULL for STRING and SYMBOL values, and 0 for other data types.\n\n#### Details\n\nReturn a vector.\n\n#### Examples\n\n```\nx=array(int, 10, 100, 1) // initial size is 10; capacity is 100; default value is 1\nx\n// output\n[1,1,1,1,1,1,1,1,1,1]\n\nx=array(int, 0) // initialize an empty vector\nx\n// output\n[]\n\nx.append!(1..10)\n// output\n[1,2,3,4,5,6,7,8,9,10]\n\ny=array(x)\ny\n// output\n[0,0,0,0,0,0,0,0,0,0]\n\nsyms=array(symbol, 0, 100) // an empty symbol vector with capacity of 100\ntypestr syms\n// output\nFAST SYMBOL VECTOR\n```\n"
    },
    "arrayVector": {
        "url": "https://docs.dolphindb.com/en/Functions/a/arrayVector.html",
        "signatures": [
            {
                "full": "arrayVector(index, value)",
                "name": "arrayVector",
                "parameters": [
                    {
                        "full": "index",
                        "name": "index"
                    },
                    {
                        "full": "value",
                        "name": "value"
                    }
                ]
            }
        ],
        "markdown": "### [arrayVector](https://docs.dolphindb.com/en/Functions/a/arrayVector.html)\n\n\n\n#### Syntax\n\narrayVector(index, value)\n\n#### Arguments\n\n**index** is a vector of positive integers, which must be strictly monotonically increasing.\n\n**value** is a vector. Its data type must be supported by [arrayVector](https://docs.dolphindb.com/en/Programming/DataTypesandStructures/DataForms/Vector/arrayVector.html)\n\n#### Details\n\nConvert *value* into an array vector by spliting it based on the elements in *index*. The number of elements in *index* indicates the number of rows of array vector. Each element in *index* corresponds to the position in *value* (starting from 1), which is the last element of each new vector. See how an array vector is converted in the following figure:\n\n![](https://docs.dolphindb.com/en/images/arrayVector01.png)\n\nNote: The maximum value in *index* can be no greater than the length of *value*.\n\n#### Examples\n\n```\narrayVector(2 3 4, [1,2,3,4])\n// output\n[[1,2],[3],[4]]\n\narrayVector(1 4 7, [1.0,2.1,4.1,6.8,0.5,2.2,2])\n// output\n[[1],[2.1,4.1,6.8],[0.5,2.2,2]]\n\nvalue = 2022.01.01 + 0..20\nindex = 7 14 21\narrayVector(index, value)\n// output\n[[2022.01.01,2022.01.02,2022.01.03,2022.01.04,2022.01.05,2022.01.06,2022.01.07],[2022.01.08,2022.01.09,2022.01.10,2022.01.11,2022.01.12,2022.01.13,2022.01.14],[2022.01.15,2022.01.16,2022.01.17,2022.01.18,2022.01.19,2022.01.20,2022.01.21]]\n```\n\nRelated function: [fixedLengthArrayVector](https://docs.dolphindb.com/en/Functions/f/fixedLengthArrayVector.html)\n"
    },
    "asFreq": {
        "url": "https://docs.dolphindb.com/en/Functions/a/asFreq.html",
        "signatures": [
            {
                "full": "asFreq(X, rule, [closed], [label], [origin='start_day'])",
                "name": "asFreq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "rule",
                        "name": "rule"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    },
                    {
                        "full": "[label]",
                        "name": "label",
                        "optional": true
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    }
                ]
            }
        ],
        "markdown": "### [asFreq](https://docs.dolphindb.com/en/Functions/a/asFreq.html)\n\n\n\n#### Syntax\n\nasFreq(X, rule, \\[closed], \\[label], \\[origin='start\\_day'])\n\nAlias: asfreq\n\n#### Arguments\n\n**X** is an indexed matrix or indexed series. The index must be of temporal type.\n\n**rule** is a string that can take the following values:\n\n| Value of *rule* | Corresponding DolphinDB function |\n| --------------- | -------------------------------- |\n| \"B\"             | businessDay                      |\n| \"W\"             | weekEnd                          |\n| \"WOM\"           | weekOfMonth                      |\n| \"LWOM\"          | lastWeekOfMonth                  |\n| \"M\"             | monthEnd                         |\n| \"MS\"            | monthBegin                       |\n| \"BM\"            | businessMonthEnd                 |\n| \"BMS\"           | businessMonthBegin               |\n| \"SM\"            | semiMonthEnd                     |\n| \"SMS\"           | semiMonthBegin                   |\n| \"Q\"             | quarterEnd                       |\n| \"QS\"            | quarterBegin                     |\n| \"BQ\"            | businessQuarterEnd               |\n| \"BQS\"           | businessQuarterBegin             |\n| \"REQ\"           | FY5253Quarter                    |\n| \"A\"             | yearEnd                          |\n| \"AS\"            | yearBegin                        |\n| \"BA\"            | businessYearEnd                  |\n| \"BAS\"           | businessYearBegin                |\n| \"RE\"            | FY5253                           |\n| \"D\"             | date                             |\n| \"H\"             | hourOfDay                        |\n| \"min\"           | minuteOfHour                     |\n| \"S\"             | secondOfMinute                   |\n| \"L\"             | millisecond                      |\n| \"U\"             | microsecond                      |\n| \"N\"             | nanosecond                       |\n\nThe strings above can also be used with positive integers for parameter *rule*. For example, \"2M\" means the end of every two months. In addition, *rule* can also be set as the identifier of the trading calendar, e.g., the Market Identifier Code of an exchange, or a user-defined calendar name. Positive integers can also be used with identifiers. For example, \"2XNYS\" means every two trading days of New York Stock Exchange.\n\n*rule* can also be a vector of temporal type.\n\n**closed** is a string indicating which boundary of the interval is closed.\n\n* The default value is 'left' for all values of *rule* except for 'M', 'A', 'Q', 'BM', 'BA', 'BQ', and 'W' which all have a default of 'right'.\n\n* The default is 'right' if *origin* is 'end' or 'end\\_day'.\n\n**label** is a string indicating which boundary is used to label the interval.\n\n* The default value is 'left' for all values of *rule* except for 'M', 'A', 'Q', 'BM', 'BA', 'BQ', and 'W' which all have a default of 'right'.\n\n* The default is 'right' if *origin* is 'end' or 'end\\_day'.\n\n**origin** is a string or a scalar of the same data type as *X*, indicating the timestamp where the intervals start. It can be 'epoch', start', 'start\\_day', 'end', 'end\\_day' or a user-defined time object. The default value is 'start\\_day'.\n\n* 'epoch': *origin* is 1970-01-01\n\n* 'start': *origin* is the first value of the timeseries\n\n* 'start\\_day': *origin* is 00:00 of the first day of the timeseries\n\n* 'end': *origin* is the last value of the timeseries\n\n* 'end\\_day': *origin* is 24:00 of the last day of the timeseries\n\n#### Details\n\nConvert *X* to specified frequency. Different from [resample](https://docs.dolphindb.com/en/Functions/r/resample.html), aggregate functions cannot be used in `asfreq`.\n\n#### Examples\n\n```\nindex = [2000.01.01, 2000.01.31, 2000.02.15, 2000.02.20, 2000.03.31, 2000.04.16, 2000.05.06, 2000.08.31]\ns = indexedSeries(index, 1..8)\ns\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.01 | 1 |\n| 2000.01.31 | 2 |\n| 2000.02.15 | 3 |\n| 2000.02.20 | 4 |\n| 2000.03.31 | 5 |\n| 2000.04.16 | 6 |\n| 2000.05.06 | 7 |\n| 2000.08.31 | 8 |\n\n```\ns.asfreq(\"M\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.31 | 2 |\n| 2000.02.29 |   |\n| 2000.03.31 | 5 |\n| 2000.04.30 |   |\n| 2000.05.31 |   |\n| 2000.06.30 |   |\n| 2000.07.31 |   |\n| 2000.08.31 | 8 |\n\n```\ns.asfreq(\"2M\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.31 | 2 |\n| 2000.03.31 | 5 |\n| 2000.05.31 |   |\n| 2000.07.31 |   |\n\n```\nindex = [2020.01.01, 2020.01.03, 2020.01.06]\ns = indexedSeries(index, 1..3)\ns\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.03 | 2 |\n| 2020.01.06 | 3 |\n\n```\ns.asfreq(\"D\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.02 |   |\n| 2020.01.03 | 2 |\n| 2020.01.04 |   |\n| 2020.01.05 |   |\n| 2020.01.06 | 3 |\n\n```\ns.asfreq(\"2D\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.03 | 2 |\n| 2020.01.05 |   |\n\n```\nindex = temporalAdd(2022.10.01 23:30:00,7*(0..8),`m)\ns = indexedSeries(index, 3*(0..8))\ns.asfreq(\"8min\")\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:28:00 |      |\n| 2022.10.01T23:36:00 |      |\n| 2022.10.01T23:44:00 | 6    |\n| 2022.10.01T23:52:00 |      |\n| 2022.10.02T00:00:00 |      |\n| 2022.10.02T00:08:00 |      |\n| 2022.10.02T00:16:00 |      |\n| 2022.10.02T00:24:00 |      |\n\n```\ns.asfreq(rule=`8min,closed=`right)\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:36:00 |      |\n| 2022.10.01T23:44:00 | 6    |\n| 2022.10.01T23:52:00 |      |\n| 2022.10.02T00:00:00 |      |\n| 2022.10.02T00:08:00 |      |\n| 2022.10.02T00:16:00 |      |\n| 2022.10.02T00:24:00 |      |\n| 2022.10.02T00:32:00 |      |\n\n```\ns.asfreq(rule=`8min,closed=`right,origin=`end)\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:30:00 | 0    |\n| 2022.10.01T23:38:00 |      |\n| 2022.10.01T23:46:00 |      |\n| 2022.10.01T23:54:00 |      |\n| 2022.10.02T00:02:00 |      |\n| 2022.10.02T00:10:00 |      |\n| 2022.10.02T00:18:00 |      |\n| 2022.10.02T00:26:00 | 24   |\n"
    },
    "asfreq": {
        "url": "https://docs.dolphindb.com/en/Functions/a/asfreq1.html",
        "signatures": [
            {
                "full": "asFreq(X, rule, [closed], [label], [origin='start_day'])",
                "name": "asFreq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "rule",
                        "name": "rule"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    },
                    {
                        "full": "[label]",
                        "name": "label",
                        "optional": true
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    }
                ]
            }
        ],
        "markdown": "### [asfreq](https://docs.dolphindb.com/en/Functions/a/asfreq1.html)\n\nAlias for [asFreq](https://docs.dolphindb.com/en/Functions/a/asFreq.html)\n\n\nDocumentation for the `asFreq` function:\n### [asFreq](https://docs.dolphindb.com/en/Functions/a/asFreq.html)\n\n\n\n#### Syntax\n\nasFreq(X, rule, \\[closed], \\[label], \\[origin='start\\_day'])\n\nAlias: asfreq\n\n#### Arguments\n\n**X** is an indexed matrix or indexed series. The index must be of temporal type.\n\n**rule** is a string that can take the following values:\n\n| Value of *rule* | Corresponding DolphinDB function |\n| --------------- | -------------------------------- |\n| \"B\"             | businessDay                      |\n| \"W\"             | weekEnd                          |\n| \"WOM\"           | weekOfMonth                      |\n| \"LWOM\"          | lastWeekOfMonth                  |\n| \"M\"             | monthEnd                         |\n| \"MS\"            | monthBegin                       |\n| \"BM\"            | businessMonthEnd                 |\n| \"BMS\"           | businessMonthBegin               |\n| \"SM\"            | semiMonthEnd                     |\n| \"SMS\"           | semiMonthBegin                   |\n| \"Q\"             | quarterEnd                       |\n| \"QS\"            | quarterBegin                     |\n| \"BQ\"            | businessQuarterEnd               |\n| \"BQS\"           | businessQuarterBegin             |\n| \"REQ\"           | FY5253Quarter                    |\n| \"A\"             | yearEnd                          |\n| \"AS\"            | yearBegin                        |\n| \"BA\"            | businessYearEnd                  |\n| \"BAS\"           | businessYearBegin                |\n| \"RE\"            | FY5253                           |\n| \"D\"             | date                             |\n| \"H\"             | hourOfDay                        |\n| \"min\"           | minuteOfHour                     |\n| \"S\"             | secondOfMinute                   |\n| \"L\"             | millisecond                      |\n| \"U\"             | microsecond                      |\n| \"N\"             | nanosecond                       |\n\nThe strings above can also be used with positive integers for parameter *rule*. For example, \"2M\" means the end of every two months. In addition, *rule* can also be set as the identifier of the trading calendar, e.g., the Market Identifier Code of an exchange, or a user-defined calendar name. Positive integers can also be used with identifiers. For example, \"2XNYS\" means every two trading days of New York Stock Exchange.\n\n*rule* can also be a vector of temporal type.\n\n**closed** is a string indicating which boundary of the interval is closed.\n\n* The default value is 'left' for all values of *rule* except for 'M', 'A', 'Q', 'BM', 'BA', 'BQ', and 'W' which all have a default of 'right'.\n\n* The default is 'right' if *origin* is 'end' or 'end\\_day'.\n\n**label** is a string indicating which boundary is used to label the interval.\n\n* The default value is 'left' for all values of *rule* except for 'M', 'A', 'Q', 'BM', 'BA', 'BQ', and 'W' which all have a default of 'right'.\n\n* The default is 'right' if *origin* is 'end' or 'end\\_day'.\n\n**origin** is a string or a scalar of the same data type as *X*, indicating the timestamp where the intervals start. It can be 'epoch', start', 'start\\_day', 'end', 'end\\_day' or a user-defined time object. The default value is 'start\\_day'.\n\n* 'epoch': *origin* is 1970-01-01\n\n* 'start': *origin* is the first value of the timeseries\n\n* 'start\\_day': *origin* is 00:00 of the first day of the timeseries\n\n* 'end': *origin* is the last value of the timeseries\n\n* 'end\\_day': *origin* is 24:00 of the last day of the timeseries\n\n#### Details\n\nConvert *X* to specified frequency. Different from [resample](https://docs.dolphindb.com/en/Functions/r/resample.html), aggregate functions cannot be used in `asfreq`.\n\n#### Examples\n\n```\nindex = [2000.01.01, 2000.01.31, 2000.02.15, 2000.02.20, 2000.03.31, 2000.04.16, 2000.05.06, 2000.08.31]\ns = indexedSeries(index, 1..8)\ns\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.01 | 1 |\n| 2000.01.31 | 2 |\n| 2000.02.15 | 3 |\n| 2000.02.20 | 4 |\n| 2000.03.31 | 5 |\n| 2000.04.16 | 6 |\n| 2000.05.06 | 7 |\n| 2000.08.31 | 8 |\n\n```\ns.asfreq(\"M\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.31 | 2 |\n| 2000.02.29 |   |\n| 2000.03.31 | 5 |\n| 2000.04.30 |   |\n| 2000.05.31 |   |\n| 2000.06.30 |   |\n| 2000.07.31 |   |\n| 2000.08.31 | 8 |\n\n```\ns.asfreq(\"2M\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.31 | 2 |\n| 2000.03.31 | 5 |\n| 2000.05.31 |   |\n| 2000.07.31 |   |\n\n```\nindex = [2020.01.01, 2020.01.03, 2020.01.06]\ns = indexedSeries(index, 1..3)\ns\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.03 | 2 |\n| 2020.01.06 | 3 |\n\n```\ns.asfreq(\"D\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.02 |   |\n| 2020.01.03 | 2 |\n| 2020.01.04 |   |\n| 2020.01.05 |   |\n| 2020.01.06 | 3 |\n\n```\ns.asfreq(\"2D\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.03 | 2 |\n| 2020.01.05 |   |\n\n```\nindex = temporalAdd(2022.10.01 23:30:00,7*(0..8),`m)\ns = indexedSeries(index, 3*(0..8))\ns.asfreq(\"8min\")\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:28:00 |      |\n| 2022.10.01T23:36:00 |      |\n| 2022.10.01T23:44:00 | 6    |\n| 2022.10.01T23:52:00 |      |\n| 2022.10.02T00:00:00 |      |\n| 2022.10.02T00:08:00 |      |\n| 2022.10.02T00:16:00 |      |\n| 2022.10.02T00:24:00 |      |\n\n```\ns.asfreq(rule=`8min,closed=`right)\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:36:00 |      |\n| 2022.10.01T23:44:00 | 6    |\n| 2022.10.01T23:52:00 |      |\n| 2022.10.02T00:00:00 |      |\n| 2022.10.02T00:08:00 |      |\n| 2022.10.02T00:16:00 |      |\n| 2022.10.02T00:24:00 |      |\n| 2022.10.02T00:32:00 |      |\n\n```\ns.asfreq(rule=`8min,closed=`right,origin=`end)\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:30:00 | 0    |\n| 2022.10.01T23:38:00 |      |\n| 2022.10.01T23:46:00 |      |\n| 2022.10.01T23:54:00 |      |\n| 2022.10.02T00:02:00 |      |\n| 2022.10.02T00:10:00 |      |\n| 2022.10.02T00:18:00 |      |\n| 2022.10.02T00:26:00 | 24   |\n"
    },
    "asin": {
        "url": "https://docs.dolphindb.com/en/Functions/a/asin.html",
        "signatures": [
            {
                "full": "asin(X)",
                "name": "asin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [asin](https://docs.dolphindb.com/en/Functions/a/asin.html)\n\n\n\n#### Syntax\n\nasin(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nThe inverse sine (arcsine) function.\n\n#### Examples\n\n```\nasin(0 0.5 1);\n// output\n[0,0.523599,1.570796]\n```\n\nRelated functions: [acos](https://docs.dolphindb.com/en/Functions/a/acos.html), [atan](https://docs.dolphindb.com/en/Functions/a/atan.html), [sin](https://docs.dolphindb.com/en/Functions/s/sin.html), [cos](https://docs.dolphindb.com/en/Functions/c/cos.html), [tan](https://docs.dolphindb.com/en/Functions/t/tan.html), [asinh](https://docs.dolphindb.com/en/Functions/a/asinh.html), [acosh](https://docs.dolphindb.com/en/Functions/a/acosh.html), [atanh](https://docs.dolphindb.com/en/Functions/a/atanh.html), [sinh](https://docs.dolphindb.com/en/Functions/s/sinh.html), [cosh](https://docs.dolphindb.com/en/Functions/c/cosh.html), [tanh](https://docs.dolphindb.com/en/Functions/t/tanh.html)\n"
    },
    "asinh": {
        "url": "https://docs.dolphindb.com/en/Functions/a/asinh.html",
        "signatures": [
            {
                "full": "asinh(X)",
                "name": "asinh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [asinh](https://docs.dolphindb.com/en/Functions/a/asinh.html)\n\n\n\n#### Syntax\n\nasinh(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nThe inverse hyperbolic sine function.\n\n#### Examples\n\n```\nasinh(0.841471 0.909297 0.141120);\n// output\n[0.764725,0.815761,0.140656]\n```\n\nRelated functions: [asin](https://docs.dolphindb.com/en/Functions/a/asin.html), [acos](https://docs.dolphindb.com/en/Functions/a/acos.html), [atan](https://docs.dolphindb.com/en/Functions/a/atan.html), [sin](https://docs.dolphindb.com/en/Functions/s/sin.html), [cos](https://docs.dolphindb.com/en/Functions/c/cos.html), [tan](https://docs.dolphindb.com/en/Functions/t/tan.html), [acosh](https://docs.dolphindb.com/en/Functions/a/acosh.html), [atanh](https://docs.dolphindb.com/en/Functions/a/atanh.html), [sinh](https://docs.dolphindb.com/en/Functions/s/sinh.html), [cosh](https://docs.dolphindb.com/en/Functions/c/cosh.html), [tanh](https://docs.dolphindb.com/en/Functions/t/tanh.html)\n"
    },
    "asis": {
        "url": "https://docs.dolphindb.com/en/Functions/a/asis.html",
        "signatures": [
            {
                "full": "asis(X)",
                "name": "asis",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [asis](https://docs.dolphindb.com/en/Functions/a/asis.html)\n\n\n\n#### Syntax\n\nasis(X)\n\n#### Arguments\n\n**X** can be of any data type.\n\n#### Details\n\nReturn a shallow copy of *X*.\n\n#### Examples\n\n```\na = 1 2 3\nb = asis(a)\na[0] = 0\nb\n// output\n[0, 2, 3]\n\nb[1] = 4\na;\n// output\n[0, 4, 3]\n```\n\nRelated Functions: [copy](https://docs.dolphindb.com/en/Functions/c/copy.html)\n"
    },
    "asof": {
        "url": "https://docs.dolphindb.com/en/Functions/a/asof.html",
        "signatures": [
            {
                "full": "asof(X, Y)",
                "name": "asof",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [asof](https://docs.dolphindb.com/en/Functions/a/asof.html)\n\n\n\n#### Syntax\n\nasof(X, Y)\n\n#### Arguments\n\n**X** must be a vector/indexed series/indexed matrix sorted in ascending order.\n\n**Y** is a scalar/vector/tuple/matrix/dictionary/table/array vector.\n\n#### Details\n\nFor each element y in *Y*, return the index of the last element in *X* that is no greater than y. If nothing is found, return -1.\n\n#### Examples\n\n```\nasof(1..100, 60 200 -10)\n// output\n[59,99,-1]\n\n0 0 0 1 1 1 1 2 2 3 asof 1\n// output\n6\n```\n"
    },
    "at": {
        "url": "https://docs.dolphindb.com/en/Functions/a/at.html",
        "signatures": [
            {
                "full": "at(X, [index])",
                "name": "at",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[index]",
                        "name": "index",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [at](https://docs.dolphindb.com/en/Functions/a/at.html)\n\n\n\n#### Syntax\n\nat(X, \\[index])\n\n#### Arguments\n\nIf only one parameter is specified:\n\n* **X** is a Boolean expression or a vector.\n\nIf both parameters are specified:\n\n* **X** is a scalar/vector (including tuplesand array vectors)/matrix/table/dictionary/pair/function;\n* **index** is a Boolean expression/Boolean value/scalar/vector (including tuplesand array vectors)/pair.\n\n#### Details\n\nIn the first case, return the indexes of the elements of *X* that are true.\n\nIn the second case:\n\n* If *index* is a Boolean expression, `at` returns the elements in *X* that correspond to the elements in *Y* that are true. Function `at` is equivalent to brackets operator `[]`. For example, `X.at(X>3)` is equivalent to `X[X>3]`.\n\n* If *index* is a vector, `at` retrieves the elements from *X* at the positions as specified by each element of *index*.\n\n* If *index* is a tuple, each element in the tuple specifies an index into the corresponding dimension of *X*. `at` retrieves the element(s) at the specified position as specified by the indices. For example, when *X* is a matrix, *index* must be a tuple of two elements - the first element indicates the row index, and the second element indicates the column index.\n\n* If *index* is a pair like a:b, `at` returns the elements from *X* in the range \\[a,b).\n\n* If *index* is an array vector, each row of index specifies indices to retrieve from *X*. The result is an array vector with the same dimension as *index*.\n\nNote: When *index* refers to column/row index, or an index range, for elements outside the bounds of the *X* (i.e. outside of \\[0, size(X)-1]), the corresponding positions in *X* will return NULL values.\n\nIf *X* is a function, *index* specifies the arguments of *X*. When*index* is a tuple, each element of the tuple is passed as an argument to *X*.\n\n#### Examples\n\n```\nx=5 7 0 4 2 3\nat(x>3)\n// output: [0,1,3] \n// at position 0, 1, and 3, x>3 is true.\n\n// compare with x>3:\nx>3;\n// output: [1,1,0,1,0,0]\n\nx[x>3]\n// output: [5,7,4]\n\nx at x>3\n// output: [5,7,4]\n\nx=5 7 0 0 0 3\nat(x==0)\n// output: [2,3,4]\n\nx[x==0]\n// output: [0,0,0]\n\nshares=500 1000 1000 600 2000\nprices=25.5 97.5  19.2 38.4 101.5\nprices[shares>800]\n// output: [97.5,19.2,101.5]\n\nprices at shares>800\n// output: [97.5,19.2,101.5]\n\nm=(1..6).reshape(2:3)\nm;\n```\n\n| 0 | 1 | 2 |\n| - | - | - |\n| 1 | 3 | 5 |\n| 2 | 4 | 6 |\n\n```\nat(m>3)\n// output: [3,4,5]\n\nm[m>3] // equal to m at m>3\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n|      |      | 5    |\n|      | 4    | 6    |\n\nNote the difference between using a vector versus a tuple for *index*:\n\n```\nm at [0,2]  // locate column 0 and 2\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 5 |\n| 2 | 6 |\n\n```\nm at (0,2) // locate element at a specific column and a specific row\n// output: 5\n```\n\n```\nm at 0:2  // locate column 0 and 1\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 3 |\n| 2 | 4 |\n\nWhen *index* is an array vector:\n\n```\na = array\\(INT\\[\\], 0, 10\\).append!\\(\\[0 2 3, 0 5, 0 8 8, 9 10\\]\\)\nb =\\[1, 2, 3\\]\n\nat\\(b, a\\)\n// output: \\[\\[1,3, \\], \\[1, \\], \\[1, , \\], \\[ , \\]\\]\n\nat\\(a,a&gt;3\\)\n// output: \\[,\\[5\\],\\[8,8\\],\\[9,10\\]\\]\n```\n\nWhen *X*is a function, and *index* is a tuple to be passed as an argument:\n\n```\nscore = (60, 70);\nat(add,score)\n//output: 130\n```\n"
    },
    "atan": {
        "url": "https://docs.dolphindb.com/en/Functions/a/atan.html",
        "signatures": [
            {
                "full": "atan(X)",
                "name": "atan",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [atan](https://docs.dolphindb.com/en/Functions/a/atan.html)\n\n\n\n#### Syntax\n\natan(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nThe inverse tangent (arctan) function.\n\n#### Examples\n\n```\natan 0.000000 1.557408 -2.185040;\n// output\n[0,1,-1.141593]\n```\n\nRelated functions: [asin](https://docs.dolphindb.com/en/Functions/a/asin.html), [acos](https://docs.dolphindb.com/en/Functions/a/acos.html), [sin](https://docs.dolphindb.com/en/Functions/s/sin.html), [cos](https://docs.dolphindb.com/en/Functions/c/cos.html), [tan](https://docs.dolphindb.com/en/Functions/t/tan.html), [asinh](https://docs.dolphindb.com/en/Functions/a/asinh.html), [acosh](https://docs.dolphindb.com/en/Functions/a/acosh.html), [atanh](https://docs.dolphindb.com/en/Functions/a/atanh.html), [sinh](https://docs.dolphindb.com/en/Functions/s/sinh.html), [cosh](https://docs.dolphindb.com/en/Functions/c/cosh.html), [tanh](https://docs.dolphindb.com/en/Functions/t/tanh.html)\n"
    },
    "atanh": {
        "url": "https://docs.dolphindb.com/en/Functions/a/atanh.html",
        "signatures": [
            {
                "full": "atanh(X)",
                "name": "atanh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [atanh](https://docs.dolphindb.com/en/Functions/a/atanh.html)\n\n\n\n#### Syntax\n\natanh(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nThe inverse hyperbolic tangent function.\n\n#### Examples\n\n```\natanh 0.000000 0.557408 -0.185040;\n// output\n[0,0.629065,-0.187196]\n```\n\nRelated functions: [asin](https://docs.dolphindb.com/en/Functions/a/asin.html), [acos](https://docs.dolphindb.com/en/Functions/a/acos.html), [atan](https://docs.dolphindb.com/en/Functions/a/atan.html), [sin](https://docs.dolphindb.com/en/Functions/s/sin.html), [cos](https://docs.dolphindb.com/en/Functions/c/cos.html), [tan](https://docs.dolphindb.com/en/Functions/t/tan.html), [asinh](https://docs.dolphindb.com/en/Functions/a/asinh.html), [acosh](https://docs.dolphindb.com/en/Functions/a/acosh.html), [sinh](https://docs.dolphindb.com/en/Functions/s/sinh.html), [cosh](https://docs.dolphindb.com/en/Functions/c/cosh.html), [tanh](https://docs.dolphindb.com/en/Functions/t/tanh.html)\n"
    },
    "atImax": {
        "url": "https://docs.dolphindb.com/en/Functions/a/atImax.html",
        "signatures": [
            {
                "full": "atImax(location, value)",
                "name": "atImax",
                "parameters": [
                    {
                        "full": "location",
                        "name": "location"
                    },
                    {
                        "full": "value",
                        "name": "value"
                    }
                ]
            }
        ],
        "markdown": "### [atImax](https://docs.dolphindb.com/en/Functions/a/atImax.html)\n\n\n\n#### Syntax\n\natImax(location, value)\n\n#### Arguments\n\n**location** and **value** are vectors/matrices/tables of the same dimensions.\n\n#### Details\n\nFind the position of the element with the largest value in *location*, and return the value of the element in the same position in *value*. If there are multiple identical maximums in *location*, return the position of the first maximum.\n\nIf *location* and *value* are matrices, conduct the aforementioned calculation with each column of *location* and the corresponding column of *value*.\n\n`atImax(location, value)` is equivalent to `value[imax(location)]`.\n\n#### Examples\n\n```\natImax(3 5 1 2, 9 7 5 3)\n// output\n7\n\nm1=matrix(9 2 1 5 6 9, 3 1 3 NULL 5 2, 2 8 1 2 3 4)\nm2=matrix(1..6, 1..6, 1..6)\natImax(m1,m2)\n// output\n[1,5,2]\n```\n\nRelated functions: [imax](https://docs.dolphindb.com/en/Functions/i/imax.html), [atImin](https://docs.dolphindb.com/en/Functions/a/atImin.html)\n"
    },
    "atImin": {
        "url": "https://docs.dolphindb.com/en/Functions/a/atImin.html",
        "signatures": [
            {
                "full": "atImin(location, value)",
                "name": "atImin",
                "parameters": [
                    {
                        "full": "location",
                        "name": "location"
                    },
                    {
                        "full": "value",
                        "name": "value"
                    }
                ]
            }
        ],
        "markdown": "### [atImin](https://docs.dolphindb.com/en/Functions/a/atImin.html)\n\n\n\n#### Syntax\n\natImin(location, value)\n\n#### Arguments\n\n**location** and **value** are vectors/matrices/tables of the same dimensions.\n\n#### Details\n\nFind the position of the element with the smallest value in *location*, and return the value of the element in the same position in *value*. If there are multiple identical minimums in *location*, return the position of the first minimum.\n\nIf *location* and *value* are matrices, conduct the aforementioned calculation with each column of *location* and the corresponding column of *value*.\n\n`atImin(location, value)` is equivalent to `value[imin(location)]`.\n\n#### Examples\n\n```\natImin(3 5 1 2, 9 7 5 3)\n// output\n5\n\nm1=matrix(9 2 1 5 6 9, 3 1 3 NULL 5 2, 2 8 1 2 3 4)\nm2=matrix(1..6, 1..6, 1..6)\natImin(m1,m2)\n// output\n[3,2,3]\n```\n\nRelated functions: [imin](https://docs.dolphindb.com/en/Functions/i/imin.html), [atImax](https://docs.dolphindb.com/en/Functions/a/atImax.html)\n"
    },
    "autocorr": {
        "url": "https://docs.dolphindb.com/en/Functions/a/autocorr.html",
        "signatures": [
            {
                "full": "autocorr(X, lag)",
                "name": "autocorr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "lag",
                        "name": "lag"
                    }
                ]
            }
        ],
        "markdown": "### [autocorr](https://docs.dolphindb.com/en/Functions/a/autocorr.html)\n\n\n\n#### Syntax\n\nautocorr(X, lag)\n\n#### Arguments\n\n**location** is a vector.\n\n**lag** is a positive integer.\n\n#### Details\n\nCalculate the autocorrelation of *X*. Note that the means of the two time series used in the calculation is the mean of *X* instead of the means of the two time series.\n\n#### Examples\n\n```\nn=10000\nx=array(double, n, n, NULL)\nx[0]=1\nr=rand(0.05, n)-0.025\nfor(i in 0:(n-1)){\n    x[i+1]=-0.8*x[i]+r[i]\n}\n\nautocorr(x, 1)\n// output\n-0.808343\n\nautocorr(x, 2)\n// output\n0.661018\n```\n"
    },
    "avg": {
        "url": "https://docs.dolphindb.com/en/Functions/a/avg.html",
        "signatures": [
            {
                "full": "avg(X)",
                "name": "avg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [avg](https://docs.dolphindb.com/en/Functions/a/avg.html)\n\n\n\n#### Syntax\n\navg(X)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix/table.\n\n#### Details\n\nCalculate the average of *X*.\n\n* If *X* is a vector, calculate the average of *X*.\n* If *X* is a matrix, calculate the average of each column and return a vector.\n* If *X* is a table, calculate the average of each column and return a table.\n\nThe calculation skips NULL values.\n\n#### Examples\n\n```\navg(1 2 3 NULL)\n// output\n2\n\nm=matrix(1 2 3, 4 5 6)\nm\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\navg(m)\n// output\n[2,5]\n```\n"
    },
    "backup": {
        "url": "https://docs.dolphindb.com/en/Functions/b/backup.html",
        "signatures": [
            {
                "full": "backup(backupDir, dbPath|sqlObj, [force=false], [parallel=false], [snapshot=true], [tableName], [partition])",
                "name": "backup",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath|sqlObj",
                        "name": "dbPath|sqlObj"
                    },
                    {
                        "full": "[force=false]",
                        "name": "force",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[parallel=false]",
                        "name": "parallel",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[snapshot=true]",
                        "name": "snapshot",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    },
                    {
                        "full": "[partition]",
                        "name": "partition",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [backup](https://docs.dolphindb.com/en/Functions/b/backup.html)\n\n\n\n#### Syntax\n\nbackup(backupDir, dbPath|sqlObj, \\[force=false], \\[parallel=false], \\[snapshot=true], \\[tableName], \\[partition])\n\n#### Arguments\n\n**backupDir** is a string indicating the directory to save the backup. For an AWS S3 directory, it must begin with `s3://`.\n\n**dbPath** is a string indicating the database path. If specified, back up the database by copying partitions. If *backupDir*is an AWS S3 directory, only *dbPath*can be specified.\n\n**sqlObj** is metacode of SQL statements indicating the data to be backed up. If specified, only the queried data is backed up.\n\n**force** (optional) is a Boolean value. True means to perform a full backup, otherwise to perform an incremental backup.\n\n**parallel** (optional) is a Boolean value indicating whether to back up partitions in parallel. The default value is false.\n\nThe following parameters only take effect when *dbPath* is specified:\n\n**snapshot** (optional) is a Boolean value indicating whether to synchronize the deletion of tables/partitions to the backup database. It only takes effect when the parameter partition is empty. The default value is true, indicating the system will remove the deleted table/partitions from the backup files.\n\n**tableName** (optional) is a STRING scalar or vector indicating the name of table to be backed up. If unspecified, all tables of the database are backed up.\n\n**partition** (optional) indicates the partitions to be backed up. It can be:\n\n* a STRING scalar or vector indicating the path(s) to one or multiple partitions of a database, and each path starts with \"/\". Note that for a compo-partitioned database, the path must include all partition levels.\n\n* filter condition(s). A filter condition can be a scalar or vector where each element represents a partition.\n\n  * For a single-level partitioning database, it is a scalar.\n\n  * For a compo-partitioned database, it is a tuple composed of filter conditions with each element for a partition level. If a partition level has no filter condition, the corresponding element in the tuple is empty.\n\n* unspecified to indicate all partitions.\n\n#### Details\n\nBack up all or specified partitions of a distributed table. Return an integer indicating the number of partitions that have been backed up successfully. It must be executed by a logged-in user.\n\nNote:\n\n* For a database created with *chunkGranularity*='DATABASE', it can only be backed up with SQL statements.\n\n* If backup files already exist under the *backupDir*, the next backup must adopt the same method (by specifying *dbPath* or *sqlObj*). Otherwise the backup would fail.\n\n* If *backupDir*is an AWS S3 directory, the configuration file of the data node must specify *preloadModules*=plugins::awss3, and configure *s3AccessKeyId*, *s3SecretAccessKey*and *s3Region*.\n\nThe following table compares the 2 types of backup:\n\n| Feature                                             | copying files (specifying parameter *dbPath*) | SQL statements (specifying parameter *sqlObj*) |\n| --------------------------------------------------- | --------------------------------------------- | ---------------------------------------------- |\n| back up an entire database                          | √                                             | ×                                              |\n| data consistency                                    | fully guaranteed                              | partially guaranteed                           |\n| incremental backup of modified and added partitions | √                                             | √                                              |\n| incremental backup of deleted partitions            | √                                             | ×                                              |\n| resume data transmission from a breakpoint          | √                                             | ×                                              |\n| back up data with filter conditions                 | ×                                             | √                                              |\n| performance                                         | lower memory usage                            | higher memory usage                            |\n\n#### Examples\n\nCreate a DFS database *dfs\\://compoDB*\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID=database(, RANGE, 0 50 100);\ndb = database(\"dfs://compoDB\", COMPO, [dbDate, dbID])\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t)\n```\n\nExample 1. Back up the table pt.\n\n```\nbackup(\"/home/DolphinDB/backup\",<select * from loadTable(\"dfs://compoDB\",\"pt\")>,true);\n// output\n10\n```\n\nExample 2. Back up the partitions of table pt with date>2017.08.09.\n\n```\nbackup(\"/home/DolphinDB/backup\",<select * from loadTable(\"dfs://compoDB\",\"pt\") where date>2017.08.10>,true);\n// output\n2\n```\n\nExample 3. Back up tables in a database.\n\n(1) Back up tables\n\n```\n// create table pt1 under database dfs://compoDB\npt1 = db.createPartitionedTable(t, `pt1, `date`ID)\npt1.append!(t)\n\n// back up 2 tables\nbackup(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",force=true);\n// output\n20\n```\n\n(2) Back up specified partitions\n\n```\n// back up 5 partitions of table pt\npartitions=[\"/20170807/0_50\",\"/20170808/0_50\",\"/20170809/0_50\",\"/20170810/0_50\",\"/20170811/0_50\"]\nbackup(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",force=true,tableName=`pt,partition=partitions);\n5\n```\n\n(3) Back up partitions with filter conditions. Note that for a range domain, any value within the range can be specified to indicate the entire partition.\n\n```\n// back up the second-level partition 50_100 under the first-level partition 20170807\npartitions=[2017.08.07,50]\nbackup(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",force=true,tableName=`pt,partition=partitions);\n// output\n1\n\n// back up the second-level partition 50_100 under all first-level partitions\npartitions=[,[0]]\nbackup(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",force=true,tableName=`pt,partition=partitions);\n// output\n5  \n```\n\nExample 4. The following examples explains how to use the parameter *snapshot*\n\n```\n// delete partition \"/20170811/0_50\" form table pt\ndb.dropPartition(\"/20170811/0_50\",`pt)\n\n// back up again and set snapshot=false\nbackup(backupDir=\"/home/DolphinDB/backup1\",dbPath=\"dfs://compoDB\",force=true,snapshot=false,tableName=`pt);\n// output\n9\n\n// restore from the backup and you can see that partition \"/20170811/0_50\" was not deleted\nrestore(backupDir=\"/home/DolphinDB/backup1\",dbPath=\"dfs://compoDB\",tableName=`pt,partition=\"%\",force=true)\n[\"dfs://compoDB/20170807/0_50/9m9\",\"dfs://compoDB/20170807/50_100/9m9\",\"dfs://compoDB/20170808/0_50/9m9\",\"dfs://compoDB/20170808/50_100/9m9\",\"dfs://compoDB/20170809/0_50/9m9\",\"dfs://compoDB/20170809/50_100/9m9\",\"dfs://compoDB/20170810/0_50/9m9\",\"dfs://compoDB/20170810/50_100/9m9\",\"dfs://compoDB/20170811/0_50/9m9\",\"dfs://compoDB/20170811/50_100/9m9\"]\n\n//delete partition \"/20170811/0_50\" form table pt\ndb.dropPartition(\"/20170811/0_50\",`pt)\n\n// back up again and set snapshot=true\nbackup(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",force=true,snapshot=true,tableName=`pt);\n// output\n9\n    \n// restore from the backup and you can see that partition \"/20170811/0_50\" was deleted\nrestore(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",tableName=`pt,partition=\"%\",force=true)\n// output\n[\"dfs://compoDB/20170807/0_50/9m9\",\"dfs://compoDB/20170807/50_100/9m9\",\"dfs://compoDB/20170808/0_50/9m9\",\"dfs://compoDB/20170808/50_100/9m9\",\"dfs://compoDB/20170809/0_50/9m9\",\"dfs://compoDB/20170809/50_100/9m9\",\"dfs://compoDB/20170810/0_50/9m9\",\"dfs://compoDB/20170810/50_100/9m9\",\"dfs://compoDB/20170811/50_100/9m9\"]\n```\n\nRelated functions: [backupDB](https://docs.dolphindb.com/en/Functions/b/backupDB.html), [backupTable](https://docs.dolphindb.com/en/Functions/b/backupTable.html), [restore](https://docs.dolphindb.com/en/Functions/r/restore.html), [migrate](https://docs.dolphindb.com/en/Functions/m/migrate.html)\n"
    },
    "backupDB": {
        "url": "https://docs.dolphindb.com/en/Functions/b/backupDB.html",
        "signatures": [
            {
                "full": "backupDB(backupDir, dbPath)",
                "name": "backupDB",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    }
                ]
            }
        ],
        "markdown": "### [backupDB](https://docs.dolphindb.com/en/Functions/b/backupDB.html)\n\n\n\n#### Syntax\n\nbackupDB(backupDir, dbPath)\n\n#### Arguments\n\n**backupDir** is a string indicating the directory to save the backup.\n\n**dbPath** is a string indicating the database path.\n\n#### Details\n\nBack up the specific database to the specified directory.\n\nThe function is equivalent to `backup(backupDir, dbPath, force=false, sparallel=true, snapshot=true)`.\n\n#### Examples\n\n```\ndbName = \"dfs://compoDB2\"\nn=1000\nID=rand(\"a\"+string(1..10), n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10, n)\nt=table(ID, date, x)\ndb1 = database(, VALUE, 2017.08.07..2017.08.11)\ndb2 = database(, HASH,[INT, 20])\nif(existsDatabase(dbName)){\n  dropDatabase(dbName)\n}\ndb = database(dbName, COMPO,[ db1,db2])\n\n//create 2 tables\npt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\npt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\nbackupDB(backupDir, dbName)\n```\n\nRelated functions: [backup](https://docs.dolphindb.com/en/Functions/b/backup.html), [backupTable](https://docs.dolphindb.com/en/Functions/b/backupTable.html), [restore](https://docs.dolphindb.com/en/Functions/r/restore.html), [restoreDB](https://docs.dolphindb.com/en/Functions/r/restoreDB.html), [restoreTable](https://docs.dolphindb.com/en/Functions/r/restoreTable.html), [migrate](https://docs.dolphindb.com/en/Functions/m/migrate.html)\n"
    },
    "backupSettings": {
        "url": "https://docs.dolphindb.com/en/Functions/b/backupSettings.html",
        "signatures": [
            {
                "full": "backupSettings(fileName, [userPermission=true], [functionView=true])",
                "name": "backupSettings",
                "parameters": [
                    {
                        "full": "fileName",
                        "name": "fileName"
                    },
                    {
                        "full": "[userPermission=true]",
                        "name": "userPermission",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[functionView=true]",
                        "name": "functionView",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [backupSettings](https://docs.dolphindb.com/en/Functions/b/backupSettings.html)\n\n#### Syntax\n\nbackupSettings(fileName, \\[userPermission=true], \\[functionView=true])\n\n#### Arguments\n\n**fileName**is a STRING scalar specifying the backup file path. It can be an absolute path or relative path to *\\<HomeDir>*.\n\n**userPermission** (optional) is a Boolean scalar, indicating whether to back up user permissions. The default value is true.\n\n**functionView** (optional) is a Boolean scalar, indicating whether to back up function views. The default value is true.\n\n#### Details\n\nBack up all settings on users, permissions, and function views to specified directory.\n\nThis function can only be executed by an administrator on the controller. It can be used with `restoreSettings` to back up and restore user settings when migrating databases.\n\n**Return value**: A vector containing all backup user names and function views.\n\n#### Examples\n\n```\nbackupSettings(fileName=\"/home/ddb/backup/permission.back\", userPermission=true, functionView=true)\nbackupSettings(fileName=\"/home/ddb/backup/permission.back\", userPermission=true, functionView=false)\nbackupSettings(fileName=\"/home/ddb/backup/permission.back\", userPermission=false, functionView=true)\nbackupSettings(fileName=\"/home/ddb/backup/permission.back\", userPermission=false, functionView=false)\n```\n\n**Related function**: [restoreSettings](https://docs.dolphindb.com/en/Functions/r/restoreSettings.html)\n\n"
    },
    "backupTable": {
        "url": "https://docs.dolphindb.com/en/Functions/b/backupTable.html",
        "signatures": [
            {
                "full": "backupTable(backupDir, dbPath, tableName)",
                "name": "backupTable",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [backupTable](https://docs.dolphindb.com/en/Functions/b/backupTable.html)\n\n\n\n#### Syntax\n\nbackupTable(backupDir, dbPath, tableName)\n\n#### Arguments\n\n**backupDir** is a string indicating the directory to save the backup.\n\n**dbPath** is a string indicating the database path.\n\n**tableName** is a string indicating the table name.\n\n#### Details\n\nBack up a table to the specified directory.\n\nThe function is equivalent to `backup(backupDir, dbPath, force=false, parallel=true, snapshot=true, tableName)`.\n\n#### Examples\n\n```\ndbName = \"dfs://compoDB2\"\nn=1000\nID=rand(\"a\"+string(1..10), n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10, n)\nt=table(ID, date, x)\ndb1 = database(, VALUE, 2017.08.07..2017.08.11)\ndb2 = database(, HASH,[INT, 20])\nif(existsDatabase(dbName)){\n  dropDatabase(dbName)\n}\ndb = database(dbName, COMPO,[ db1,db2])\n\n//create 2 tables\npt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\npt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\nbackupTable(backupDir,dbName,`pt1)\n// output\n50\n```\n\nRelated functions: [backup](https://docs.dolphindb.com/en/Functions/b/backup.html), [backupDB](https://docs.dolphindb.com/en/Functions/b/backupDB.html), [restore](https://docs.dolphindb.com/en/Functions/r/restore.html), [restoreDB](https://docs.dolphindb.com/en/Functions/r/restoreDB.html), [restoreTable](https://docs.dolphindb.com/en/Functions/r/restoreTable.html), [migrate](https://docs.dolphindb.com/en/Functions/m/migrate.html)\n"
    },
    "bar": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bar.html",
        "signatures": [
            {
                "full": "bar(X, interval, [closed='left'])",
                "name": "bar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "interval",
                        "name": "interval"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    }
                ]
            }
        ],
        "markdown": "### [bar](https://docs.dolphindb.com/en/Functions/b/bar.html)\n\n\n\n#### Syntax\n\nbar(X, interval, \\[closed='left'])\n\n#### Arguments\n\n**X** is an integral/temporal scalar or vector.\n\n**interval** is an integral/DURATION type scalar greater than 0 or a vector of the same length as *X*.\n\nWhen *interval* is of type DURATION, the following time units are supported (case-sensitive): w, d, H, m, s, ms, us, ns.\n\nNote: As time units *y* and *M* are not supported in interval, to group *X* by year or month, convert the data format of *X* with function [month](https://docs.dolphindb.com/en/Functions/m/month.html) or [year](https://docs.dolphindb.com/en/Functions/y/year.html). Specify the interval as an integer for calculation. You can refer to Example 2.\n\n**closed** (optional) is a string which can take 'left' (default) or 'right', indicating whether an element of *X* that is divisible by interval is the left boundary (the first element of the group) or the right boundary (the last element of the group) of a group.\n\n* *closed* = 'left': X-(X % interval), indicating that the value with a remainder of 0 is specified as the left boundary of a group.\n\n* *closed* = 'right': iif((X % interval) == 0, X, X + (interval-(X % interval))), indicating that the value with a remainder of 0 is specified as the right boundary of a group.\n\n#### Details\n\n`bar` can group *X* based on the length specified by *interval*. Return a vector with the same length as *X*.\n\n#### Examples\n\n```\nbar(100,3);               // 100-(100%3)=100-1=99\n// output\n99\n\nbar(0..15, 3)\n// output\n[0,0,0,3,3,3,6,6,6,9,9,9,12,12,12,15]\n\nx=[7,4,5,8,9,3,3,5,2,6,12,1,0,-5,32]\nbar(x, 5)\n// output\n[5,0,5,5,5,0,0,5,0,5,10,0,0,-5,30]\n\nt=table(2021.01.01T01:00:00..2021.01.01T01:00:29 as time, rand(1.0, 30) as x)\nselect max(x) from t group by bar(time,5s)\n```\n\n| bar\\_time           | max\\_x   |\n| ------------------- | -------- |\n| 2021.01.01T01:00:00 | 0.539024 |\n| 2021.01.01T01:00:05 | 0.793327 |\n| 2021.01.01T01:00:10 | 0.958522 |\n| 2021.01.01T01:00:15 | 0.96987  |\n| 2021.01.01T01:00:20 | 0.827086 |\n| 2021.01.01T01:00:25 | 0.617353 |\n\nIn the following example, to group data by every 3 months, convert *X* with the `month` function, and specify *duration* as an integer in `bar`.\n\n```\nt=table(take(2018.01.01T01:00:00+1..10,10) join take(2018.02.01T02:00:00+1..10,10) join take(2018.03.01T08:00:00+1..10,10) join take(2018.04.01T08:00:00+1..10,10) join take(2018.05.01T08:00:00+1..10, 10) as time, rand(1.0, 50) as x)\nselect max(x) from t group by bar(month(time), 3);\n```\n\n| bar      | max\\_x |\n| -------- | ------ |\n| 2018.01M | 0.9868 |\n| 2018.04M | 0.9243 |\n\nThe following example groups data by week and calculates the maximum values for each week. Depending on parameter *closed*, the results are different.\n\n```\nt=table(2022.01.01 + 1..20  as time, rand(100, 20) as x)\n```\n\n| time       | x  |\n| ---------- | -- |\n| 2022.01.02 | 6  |\n| 2022.01.03 | 29 |\n| 2022.01.04 | 71 |\n| 2022.01.05 | 56 |\n| 2022.01.06 | 93 |\n| 2022.01.07 | 34 |\n| 2022.01.08 | 77 |\n| 2022.01.09 | 18 |\n| 2022.01.10 | 62 |\n| 2022.01.11 | 33 |\n| 2022.01.12 | 34 |\n| 2022.01.13 | 64 |\n| 2022.01.14 | 80 |\n| 2022.01.15 | 63 |\n| 2022.01.16 | 17 |\n| 2022.01.17 | 66 |\n| 2022.01.18 | 85 |\n| 2022.01.19 | 27 |\n| 2022.01.20 | 77 |\n| 2022.01.21 | 27 |\n\n```\nselect max(x) from t group by bar(time, 7d);\n```\n\n| bar\\_time  | max\\_x |\n| ---------- | ------ |\n| 2021.12.30 | 71     |\n| 2022.01.06 | 93     |\n| 2022.01.13 | 85     |\n| 2022.01.20 | 77     |\n\n```\nprint  select max(x) from t group by bar(time, 7d, closed='right');\n```\n\n| bar\\_time  | max\\_x |\n| ---------- | ------ |\n| 2021.01.06 | 93     |\n| 2022.01.13 | 77     |\n| 2022.01.20 | 85     |\n| 2022.01.27 | 27     |\n\nWhen calculating 1-minute OHLC bars, the data type needs to be converted to LONG if n needs to be converted to NANOTIMESTAMP, otherwise an integer overflow will occur.\n\n```\nn = 1000000\nnano = (09:30:00.000000000 + rand(long(6.5*60*60*1000000000), n)).sort!()\nprice = 100+cumsum(rand(0.02, n)-0.01)\nvolume = rand(1000, n)\nsymbol = rand(`600519`000001`600000`601766, n)\ntradeNano = table(symbol, nano, price, volume).sortBy!(`symbol`nano)\nundef(`nano`price`volume`symbol)\nbarMinutes = 7\nitv = barMinutes*60*long(1000000000)\n\nOHLC_nano=select first(price) as open, max(price) as high, min(price) as low, last(price) as close, sum(volume) as volume from tradeNano group by symbol, bar(nano, itv) as barStart\n```\n\nRelated function: [dailyAlignedBar](https://docs.dolphindb.com/en/Functions/d/dailyAlignedBar.html)\n"
    },
    "base64Decode": {
        "url": "https://docs.dolphindb.com/en/Functions/b/base64Decode.html",
        "signatures": [
            {
                "full": "base64Decode(X)",
                "name": "base64Decode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [base64Decode](https://docs.dolphindb.com/en/Functions/b/base64Decode.html)\n\n\n\n#### Syntax\n\nbase64Decode(X)\n\n#### Arguments\n\n**X** is a STRING scalar or vector.\n\n#### Details\n\nDecode *X* from Base64 format to binary data.\n\n**Return value**: a BLOB scalar or vector.\n\n#### Examples\n\n```\nbase64Decode(base64Encode(`hello))\nhello\n\nbase64Decode(base64Encode(`hello`world))\n[\"hello\",\"world\"]\n```\n\nRelated function: [base64Ebcode](https://docs.dolphindb.com/en/Functions/b/base64Encode.html)\n"
    },
    "base64Encode": {
        "url": "https://docs.dolphindb.com/en/Functions/b/base64Encode.html",
        "signatures": [
            {
                "full": "base64Encode(X)",
                "name": "base64Encode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [base64Encode](https://docs.dolphindb.com/en/Functions/b/base64Encode.html)\n\n\n\n#### Syntax\n\nbase64Encode(X)\n\n#### Arguments\n\n**X** is a STRING scalar or vector.\n\n#### Details\n\nEncode *X* to Base64 format.\n\n**Return Value**: A STRING scalar or vector.\n\n#### Examples\n\n```\nbase64Encode(`hello) \n// output\naGVsbG8=\n\nbase64Encode(`hello`world) \n// output\n[\"aGVsbG8=\",\"d29ybGQ=\"]\n\nbase64Encode(\"\")\n// output\n\"\"\n```\n\nRelated function: [base64Decode](https://docs.dolphindb.com/en/Functions/b/base64Decode.html)\n"
    },
    "beta": {
        "url": "https://docs.dolphindb.com/en/Functions/b/beta.html",
        "signatures": [
            {
                "full": "beta(Y, X)",
                "name": "beta",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [beta](https://docs.dolphindb.com/en/Functions/b/beta.html)\n\n\n\n#### Syntax\n\nbeta(Y, X)\n\n#### Arguments\n\n**Y** and **X** are vectors of the same length.\n\n#### Details\n\nReturn the coefficient estimate of an ordinary-least-squares regression of *Y* on *X* (with intercept).\n\n#### Examples\n\n```\nx=1 3 5 7 11 16 23\ny=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\n\nbeta(y,x);\n// output\n3.378632\n```\n"
    },
    "between": {
        "url": "https://docs.dolphindb.com/en/Functions/b/between.html",
        "signatures": [
            {
                "full": "between(X, Y)",
                "name": "between",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [between](https://docs.dolphindb.com/en/Functions/b/between.html)\n\n\n\n#### Syntax\n\nbetween(X, Y)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix.\n\n**Y** is a pair indicating a range.\n\n#### Details\n\nCheck if each element of *X* is between the pair indicated by *Y* (both boundaries are inclusive). The result is of the same dimension as *X*.\n\n#### Examples\n\n```\nbetween([1, 5.5, 6, 8], 1:6);\n// output\n[1,1,1,0] // 1, 5.5 and 6 are between 1 and 6, but 8 is not.\n\nbetween(1 2.4 3.6 2 3.9, 2.4:3.6);\n// output\n[0,1,1,0,0]\n```\n\n`between` can be used with `select` to filter columns:\n\n```\nt = table(`abb`aac`aaa as sym, 1.8 2.3 3.7 as price);\nselect * from t where price between 1:3;\n```\n\n<table id=\"table_dh4_2pf_dzb\"><tbody><tr><td>\n\nsym\n\n</td><td>\n\nprice\n\n</td></tr><tr><td>\n\nabb\n\n</td><td>\n\n1.8\n\n</td></tr><tr><td>\n\naac\n\n</td><td>\n\n2.3\n\n</td></tr></tbody>\n</table>The following example explains how NULL values of *Y* are handled.\n\nIf the configuration parameter *nullAsMinValueForComparison* is set to true, NULL values are treated as the minimum value of the current data type. Otherwise NULL values are processed as NULL and the comparison returns NULL.\n\n`between` can also be used with template [nullCompare](https://docs.dolphindb.com/en/Functions/Templates/nullCompare.html), and the result of comparison involving NULL is always NULL, regardless of the *nullAsMinValueForComparison* setting.\n\n```\nbetween(10,:10)\n// output\ntrue      // when nullAsMinValueForComparison=true\n\nbetween(10,:10)\n// output\nNULL     // when nullAsMinValueForComparison=false\n\nnullCompare(between, 10, :10)\n// output\nNULL\n```\n"
    },
    "bfill!": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bfill!.html",
        "signatures": [
            {
                "full": "bfill!(obj, [limit])",
                "name": "bfill!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [bfill!](https://docs.dolphindb.com/en/Functions/b/bfill!.html)\n\n\n\n#### Syntax\n\nbfill!(obj, \\[limit])\n\n#### Arguments\n\n**obj** is a vector, matrix, or table.\n\n**limit** (optional) is a positive integer indicating the number of NULL values to be filled.\n\n#### Details\n\n* If *obj* is a vector: back fill the NULL values in *obj* with the next non-NULL value.\n\n* If *obj* is a matrix or a table: back fill the NULL values in each column of *obj* with the next non-NULL value.\n\n#### Examples\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.bfill!()\nx;\n// output\n[1,2,3,4,4,4,4,5,6]\n\nx=1 2 3 NULL NULL NULL 4 5 6\nx.bfill!(1)\nx;\n// output\n[1,2,3,,,4,4,5,6]\n\ndate=[2012.06.12,,2012.06.13,2012.06.14,2012.06.15]\nsym=[\"IBM\",\"MSFT\",\"IBM\",\"MSFT\",\"MSFT\"]\nprice=[40.56,26.56,,,50.76]\nqty=[2200,4500,1200,5600,]\ntimestamp=[09:34:07,,09:36:42,09:36:51,09:36:59]\nt=table(date,timestamp,sym,price,qty)\n\nbfill!(t)\nt\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 40.56 | 2200 |\n| 2012.06.13 | 09:36:42  | MSFT | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  | 50.76 | 1200 |\n| 2012.06.14 | 09:36:51  | MSFT | 50.76 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 |      |\n\nIf only certain columns need to be filled instead of all columns, please use [update](https://docs.dolphindb.com/en/Programming/SQLStatements/update.html) statement and [bfill](https://docs.dolphindb.com/en/Functions/b/bfill.html) function. For details, please refer to [bfill](https://docs.dolphindb.com/en/Functions/b/bfill.html).\n"
    },
    "bfill": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bfill.html",
        "signatures": [
            {
                "full": "bfill(obj, [limit])",
                "name": "bfill",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [bfill](https://docs.dolphindb.com/en/Functions/b/bfill.html)\n\n\n\n#### Syntax\n\nbfill(obj, \\[limit])\n\n#### Arguments\n\n**obj** is a vector/matrix/table.\n\n**limit** (optional) is a positive integer indicating the number of NULL values to be filled.\n\n#### Details\n\nIf *obj* is a vector: back fill the NULL values in *obj* with the next non-NULL value.\n\nIf *obj* is a matrix or a table: back fill the NULL values in each column of *obj* with the next non-NULL value.\n\nThis operation creates a new object and does not change the input *obj*. Function [bfill!](https://docs.dolphindb.com/en/Functions/b/bfill!.html) changes the input *obj*.\n\n#### Examples\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.bfill();\n// output\n[1,2,3,4,4,4,4,5,6]\n\nx=1 2 3 NULL NULL NULL 4 5 6\nx.bfill(1);\n// output\n[1,2,3,,,4,4,5,6]\n\nx.bfill!(2);\nx;\n// output\n[1,2,3,,4,4,4,5,6]\n\ndate=[2012.06.12,2012.06.12,2012.06.13,2012.06.14,2012.06.15]\nsym=[\"IBM\",\"MSFT\",\"IBM\",\"MSFT\",\"MSFT\"]\nprice=[,,26.56,,50.76]\nqty=[,,4500,5600,6800]\ntimestamp=[09:34:07,09:35:26,09:36:42,09:36:51,09:36:59]\nt=table(date,timestamp,sym,price,qty)\nt;\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  |       |      |\n| 2012.06.12 | 09:35:26  | MSFT |       |      |\n| 2012.06.13 | 09:36:42  | IBM  | 26.56 | 4500 |\n| 2012.06.14 | 09:36:51  | MSFT |       | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 6800 |\n\n```\nt.bfill()\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 26.56 | 4500 |\n| 2012.06.12 | 09:35:26  | MSFT | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  | 26.56 | 4500 |\n| 2012.06.14 | 09:36:51  | MSFT | 50.76 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 6800 |\n\n```\nselect date, timestamp, sym, price.bfill() as price, qty.bfill() as qty from t context by sym;\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  | 26.56 | 4500 |\n| 2012.06.12 | 09:35:26  | MSFT | 50.76 | 5600 |\n| 2012.06.14 | 09:36:51  | MSFT | 50.76 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 6800 |\n"
    },
    "bigarray": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bigarray.html",
        "signatures": [
            {
                "full": "bigarray(dataType|template, [initialSize], [capacity], [defaultValue])",
                "name": "bigarray",
                "parameters": [
                    {
                        "full": "dataType|template",
                        "name": "dataType|template"
                    },
                    {
                        "full": "[initialSize]",
                        "name": "initialSize",
                        "optional": true
                    },
                    {
                        "full": "[capacity]",
                        "name": "capacity",
                        "optional": true
                    },
                    {
                        "full": "[defaultValue]",
                        "name": "defaultValue",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [bigarray](https://docs.dolphindb.com/en/Functions/b/bigarray.html)\n\n\n\n#### Syntax\n\nbigarray(dataType|template, \\[initialSize], \\[capacity], \\[defaultValue])\n\n#### Arguments\n\n**dataType** is the data type for the big array.\n\n**template** is an existing big array. The existing big array serves as a template and its data type determines the new big array's data type.\n\n**initialSize** (optional) is the initial size (in terms of the number of elements) of the big array. If the first parameter is a data type, then initialSize is required; if the first parameter is an existing big array, then initialSize is optional;\n\n**capacity** (optional) is the amount of memory (in terms of the number of elements) allocated to the big array. When the number of elements exceeds capacity, the system will first allocate memory of 1.2\\~2 times of capacity, copy the data to the new memory space, and release the original memory.\n\n**defaultValue** (optional) is the default value of the big array. For many data types, the default values are 0. For string and symbol, the default values are NULLs.\n\n#### Details\n\nBig arrays are specially designed for advanced users in big data analysis. Regular arrays use continuous memory. If there is not enough continuous memory, an out of memory exception will occur. A big array consists of many small memory blocks instead of one large block of memory. Therefore big arrays help relieve the memory fragmentation issue. This, however, may come with light performance penalty for certain operations. For most users who don't need to worry about the memory fragmentation issue, they should use regular arrays instead of big arrays.\n\nA big array's minimum size or capacity is 16 MB. Users can declare a big array with the function `bigarray`. Functions and operations on regular arrays also apply to big arrays.\n\nWhen we call the [array](https://docs.dolphindb.com/en/Functions/a/array.html) function, if there are not enough continuous memory blocks available, or if the memory occupied by the array exceeds a certain threshold (the default threshold is 256 MB), the system creates a big array instead.\n\n#### Examples\n\n```language-python\nx=bigarray(int,10,10000000);\nx;\n// output\n[0,0,0,0,0,0,0,0,0,0]\n\n// default value is set to 1\nx=bigarray(int,10,10000000,1);\nx;\n// output\n[1,1,1,1,1,1,1,1,1,1]\n\nx=bigarray(int,0,10000000).append!(1..100);\nx[0];\n// output\n1\n\nsum x;\n// output\n5050\n\nx[x>50&&x<60];\n// output\n[51,52,53,54,55,56,57,58,59]\n\nx=array(double, 40000000);\ntypestr x;\n// output\nHUGE DOUBLE VECTOR\n```\n\nPerformance comparison of arrays and big arrays:\n\n```language-python\n// for sequential operations, the performance of arrays and that of big arrays are nearly identical.     \nn=20000000\nx=rand(10000, n)\ny=rand(1.0, n)\nbx= bigarray(int, 0, n).append!(x)\nby= bigarray(double,0,n).append!(y);\n\ntimer(100) wavg(x,y);\nTime elapsed: 4869.74 ms\ntimer(100) wavg(bx,by);\nTime elapsed: 4762.89 ms\n\ntimer(100) x*y;\nTime elapsed: 7525.22 ms\ntimer(100) bx*by;\nTime elapsed: 7791.83 ms\n\n// for random access, big arrays have light performance penalty.\nindices = shuffle 0..(n-1);\ntimer(10) x[indices];\nTime elapsed: 2942.29 ms\ntimer(10) bx[indices];\nTime elapsed: 3547.22 ms\n```\n"
    },
    "binaryExpr": {
        "url": "https://docs.dolphindb.com/en/Functions/b/binaryExpr.html",
        "signatures": [
            {
                "full": "binaryExpr(X, Y, optr)",
                "name": "binaryExpr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "optr",
                        "name": "optr"
                    }
                ]
            }
        ],
        "markdown": "### [binaryExpr](https://docs.dolphindb.com/en/Functions/b/binaryExpr.html)\n\n\n\n#### Syntax\n\nbinaryExpr(X, Y, optr)\n\n#### Arguments\n\n**X** can be a scalar/vector/matrix.\n\n**Y** is a scalar or a vector of the same type as *X*.\n\n**optr** is a binary operator.\n\n#### Details\n\nConnect *X* and *Y* with the binary operator specified in *optr* to generate metacode of a binary expression. You can execute the metacode with function [eval](https://docs.dolphindb.com/en/Functions/e/eval.html).\n\n#### Examples\n\n```\nbinaryExpr(1, 1, +).eval()\n// output\n2\n\nbinaryExpr(1 2.2 3, 1 2 3, *).eval()\n// output\n[1 4.4 9]\n\nbinaryExpr(`id`st`nm, `fff, +).eval()\n// output\n[\"idfff\",\"stfff\",\"nmfff\"]\n\n\na = matrix(1 2, 3 4)\nb = matrix(4 2, 5 1)\nbinaryExpr(a, b, dot).eval()\n```\n\n| #0 | #1 |\n| -- | -- |\n| 10 | 8  |\n| 16 | 14 |\n\nRelated function: [unifiedExpr](https://docs.dolphindb.com/en/Functions/u/unifiedExpr.html)\n"
    },
    "binsrch": {
        "url": "https://docs.dolphindb.com/en/Functions/b/binsrch.html",
        "signatures": [
            {
                "full": "binsrch(X, Y)",
                "name": "binsrch",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [binsrch](https://docs.dolphindb.com/en/Functions/b/binsrch.html)\n\n\n\n#### Syntax\n\nbinsrch(X, Y)\n\n#### Arguments\n\n**X** must be a vector sorted in ascending order.\n\n**Y** is a scalar/vector/tuple/matrix/array vector/dictionary/table.\n\n#### Details\n\n`binsrch` means binary search. For each element in *Y*, `binsrch` locates its position in *X*. If nothing is found, it returns -1(s).\n\nFor optimal performance, we should use `binsrch` to search a short *Y* within a long sorted vector *X*. To search a large vector against another large unsorted vector, we should use function [find](https://docs.dolphindb.com/en/Functions/f/find.html), which is implemented using a hash table. However, building a hash table takes time and memory. Please also check the related function [in](https://docs.dolphindb.com/en/Functions/i/in.html).\n\n#### Examples\n\n```\n1..100 binsrch 12 6 88 102;\n// output\n[11,5,87,-1]\n```\n"
    },
    "bitAnd": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bitAnd.html",
        "signatures": [
            {
                "full": "bitAnd(X, Y)",
                "name": "bitAnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [bitAnd](https://docs.dolphindb.com/en/Functions/b/bitAnd.html)\n\n\n\n#### Syntax\n\nbitAnd(X, Y)\n\nor\n\nX & Y\n\n#### Arguments\n\n**X** and **Y** are numeric scalar, vectors, matrices or tables.\n\n#### Details\n\nReturn the result of the *bitAnd* operation.\n\n#### Examples\n\n```\nx=1 0 1;\ny=0 1 1;\nx&y;\n// output\n[0,0,1]\n```\n"
    },
    "bitNot": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bitNot.html",
        "signatures": [
            {
                "full": "bitNot(X)",
                "name": "bitNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [bitNot](https://docs.dolphindb.com/en/Functions/b/bitNot.html)\n\n\n\n#### Syntax\n\nbitNot(X)\n\n#### Arguments\n\n**X** is a numeric scalar/vector/matrix/table.\n\n#### Details\n\nReturn the result of a bitwise logical NOT operation.\n\n#### Examples\n\n```\nbitNot(3)\n// output\n-4\n\nav = array(INT[], 0, 10).append!([1 2 3, 4 5])\nbitNot(av)\n// output\n[[-2,-3,-4],[-5,-6]]\n```\n"
    },
    "bitOr": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bitOr.html",
        "signatures": [
            {
                "full": "bitOr(X, Y)",
                "name": "bitOr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [bitOr](https://docs.dolphindb.com/en/Functions/b/bitOr.html)\n\n\n\n#### Syntax\n\nbitOr(X, Y)\n\nor\n\nX | Y\n\n#### Arguments\n\n**X** and **Y** are numeric scalar, vectors, matrices or tables.\n\n#### Details\n\nReturn the result of the *bitOr* operation.\n\n#### Examples\n\n```\nx=1 0 1;\ny=0 1 1;\nx | y;\n// output\n[1,1,1]\n```\n"
    },
    "bitXor": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bitXor.html",
        "signatures": [
            {
                "full": "bitXor(X, Y)",
                "name": "bitXor",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [bitXor](https://docs.dolphindb.com/en/Functions/b/bitXor.html)\n\n\n\n#### Syntax\n\nbitXor(X, Y)\n\nor\n\nX ^ Y\n\n#### Arguments\n\n**X** and **Y** are numeric scalars, vectors, matrices or tables.\n\n#### Details\n\nReturn the result of the *bitXOr* operation.\n\n#### Examples\n\n```\nx=1 0 1;\ny= 0 1 1;\nx^y;\n// output\n[1,1,0]\n```\n"
    },
    "blob": {
        "url": "https://docs.dolphindb.com/en/Functions/b/blob.html",
        "signatures": [
            {
                "full": "blob(X)",
                "name": "blob",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [blob](https://docs.dolphindb.com/en/Functions/b/blob.html)\n\n\n\n#### Syntax\n\nblob(X)\n\n#### Arguments\n\n**X** is a STRING scalar/vector.\n\n#### Details\n\nConvert the data type of *X* to BLOB.\n\n**Note**: Values of BLOB type do not participate in calculations.\n\n#### Examples\n\n```\nstr=\"hello\"\nblob(str)\n// output\nhello\n\nt=table(1..10 as id, \"A\"+string(1..10) as sym, 2012.01.01..2012.01.10 as date, rand(100.0, 10) as val, rand(uuid(), 10) as uid)\nstr=toJson(t)\nblob(str)\n```\n\nAfter a long string is converted to BLOB, it can be used as a column of an in-memory table:\n\n```\nd = dict(1..10000,  rand(1.0, 10000))\nstr=toStdJson(d);\nt=table(blob(str) as jsonStr)\n```\n\nThe BLOB type is also supported by DFS tables.\n\n```\ndbPath=\"dfs://testBlobDB\"\nif(existsDatabase(dbPath)){\ndropDatabase(dbPath)\n}\nn=2000000\nt=table(n:0,`date`id`type`num`blob,[DATETIME,INT,SYMBOL,DOUBLE,BLOB])\ndb1=database(\"\",VALUE,2020.01.01..2020.01.10)\ndb2=database(\"\",HASH,[INT,10])\n\ndb=database(dbPath,COMPO,[db1,db2])\npt1=createPartitionedTable(db,t,`pt1,`date`id)\n\ndate=concatDateTime(take(2020.01.01..2020.01.10,n),take(00:00:00..23:23:59,n))\nid=rand(1..1000,n)\ntype=rand(`A`B`C`D`E,n)\nnum=rand(100.0,n)\n\nblob=take(blob(string(1..10)),n)\n\nt1=table(date,id,type,num,blob)\npt1.append!(t1)\nselect *  from pt1\n```\n"
    },
    "bondAccrInt": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bondAccrInt.html",
        "signatures": [
            {
                "full": "bondAccrInt(settlement, maturity, coupon, frequency, [par=100], [basis=1])",
                "name": "bondAccrInt",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "coupon",
                        "name": "coupon"
                    },
                    {
                        "full": "frequency",
                        "name": "frequency"
                    },
                    {
                        "full": "[par=100]",
                        "name": "par",
                        "optional": true,
                        "default": "100"
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [bondAccrInt](https://docs.dolphindb.com/en/Functions/b/bondAccrInt.html)\n\n#### Syntax\n\nbondAccrInt(settlement, maturity, coupon, frequency, \\[par=100], \\[basis=1])\n\n#### Arguments\n\n**settlement** is a scalar or vector of DATE type, indicating the marketable security's settlement date. The settlement date is the date after the issue date when the security is traded to the buyer.\n\n**maturity** is a scalar or vector of DATE type of the same length as *settlement*, indicating the marketable security's maturity date. The maturity date is the date when the security expires.\n\n**coupon** is a numeric scalar or vector indicating the annual coupon rate of the marketable security.\n\n**frequency** is an integer or a vector of integers indicating the number of coupon payments per year. It can be:\n\n* 1: Annual payments\n\n* 2: Semi-annual payments\n\n* 4: Quarterly payments\n\n* 12: Monthly payments\n\n**par** (optional) is a numeric scalar or vector indicating the par value. The default value is 100.\n\n**basis** (optional) is an integer or a vector of integers indicating the day count basis to use. It can be:\n\n<table id=\"table_m3y_xmr_z1c\"><thead><tr><th>\n\nOption\n\n</th><th>\n\nDescription\n\n</th></tr></thead><tbody><tr><td>\n\n0\n\n</td><td>\n\nUS (NASD) 30/360\n\n</td></tr><tr><td>\n\n1 or omitted\n\n</td><td>\n\nActual/actual\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\nActual/360\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\nActual/365\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nEuropean 30/360\n\n</td></tr></tbody>\n</table>**Note**: Scalar inputs will be automatically expanded to match the length of other vector inputs. All vector inputs must be of equal length.\n\n#### Details\n\n`bondAccrInt` returns the accrued interest of a security. Accrued interest is the interest on a bond or loan that has accumulated since the principal investment, or since the previous coupon payment if there has been one already.\n\nThe clean price is the price of a bond excluding any interest accrued since bond's issuance and the most recent coupon payment. Comparatively, the dirty price is the price of a bond including the accrued interest. Therefore,\n\nClean Price = Dirty Price − Accrued Interest\n\n**Return value**: Scalar or vector of DOUBLE type.\n\n#### Examples\n\nCalculate the price for a bond purchased on January 1, 2024, with a maturity on December 31, 2030. The bond has an annual coupon interest rate of 10%, semi-annual interest payments, and uses the US (NASD) 30/360 count basis.\n\n```\nbondAccrInt(settlement=2024.01.01, maturity=2030.12.31, coupon=0.1, frequency=2, par=1000, basis=0)\n//output: 0.277778\n```\n\nRelated function: [bondDirtyPrice](https://docs.dolphindb.com/en/Functions/b/bondDirtyPrice.html)\n\n"
    },
    "bondCashflow": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bondCashflow.html",
        "signatures": [
            {
                "full": "bondCashflow(settlement, maturity, coupon, [frequency], [basis=1], [bondType=0])",
                "name": "bondCashflow",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "coupon",
                        "name": "coupon"
                    },
                    {
                        "full": "[frequency]",
                        "name": "frequency",
                        "optional": true
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[bondType=0]",
                        "name": "bondType",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [bondCashflow](https://docs.dolphindb.com/en/Functions/b/bondCashflow.html)\n\n\n\n#### Syntax\n\nbondCashflow(settlement, maturity, coupon, \\[frequency], \\[basis=1], \\[bondType=0])\n\n#### Details\n\n`bondCashflow` calculates the cash flow for a bond with a face value of 100. Supports fixed-rate bonds, zero-coupon bonds, and discount bonds.\n\n**Return value**: Vector or array vector of DOUBLE type.\n\n#### Arguments\n\n**Note:** Scalar inputs will be automatically expanded to match the length of other vector inputs. All vector inputs must be of equal length.\n\n**settlement** is a scalar or vector of DATE type, indicating the marketable security's settlement date. The settlement date is the date after the issue date when the security is traded to the buyer.\n\n**maturity** is a scalar or vector of DATE type, indicating the marketable security's maturity date. The maturity date is the date when the security expires.\n\n**coupon** is a numeric scalar or vector indicating the annual coupon rate of the marketable security.\n\n**frequency** (optional) is an integer or a vector of integers indicating the number of coupon payments per year. Required for fixed-rate bonds, not applicable to zero-coupon or discount bonds. It can be:\n\n* 1: Annual payments\n\n* 2: Semi-annual payments\n\n* 4: Quarterly payments\n\n* 12: Monthly payments\n\n**basis** (optional) is an integer or a vector of integers indicating the day count basis to use. Defaults to 1. It can be:\n\n| Option       | Description      |\n| ------------ | ---------------- |\n| 0            | US (NASD) 30/360 |\n| 1 or omitted | Actual/actual    |\n| 2            | Actual/360       |\n| 3            | Actual/365       |\n| 4            | European 30/360  |\n\n**bondType** (optional) is an integral scalar or vector indicating the bond type. It can be:\n\n* 0 (default): Fixed-rate bond, where interest is paid periodically (quarterly, semi-annually, or annually) based on the coupon rate.\n\n* 1: Discount bond, where no interest is paid, and the bond is issued at a discount. FV at maturity = face value.\n\n* 2: Zero-coupon bond, where interest and face value are paid at maturity. FV at maturity = face value + interest.\n\n#### Examples\n\nCalculate the cash flows for two fixed-rate bonds purchased on September 28, 2022, with maturity dates of September 28, 2023, and September 28, 2024, respectively. Both have an annual coupon rate of 0.025, paid quarterly, with an actual/actual day count basis.\n\n```\nsettlement = 2022.09.28\nmaturity = [2023.09.28, 2024.09.28]\ncoupon = 0.025\nfrequency = 4\nbasis = 1\nbondCashflow(settlement, maturity, coupon, frequency, basis)；\n/* output\n[[0.625,0.625,0.625,100.625],[0.625,0.625,0.625,0.625,0.625,0.625,0.625,100.625]]\n*/\n```\n"
    },
    "bondConvexity": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bondConvexity.html",
        "signatures": [
            {
                "full": "bondConvexity(settlement, maturity, coupon, yield, [frequency], [basis=1], [bondType=0])",
                "name": "bondConvexity",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "coupon",
                        "name": "coupon"
                    },
                    {
                        "full": "yield",
                        "name": "yield"
                    },
                    {
                        "full": "[frequency]",
                        "name": "frequency",
                        "optional": true
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[bondType=0]",
                        "name": "bondType",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [bondConvexity](https://docs.dolphindb.com/en/Functions/b/bondConvexity.html)\n\n\n\n#### Syntax\n\nbondConvexity(settlement, maturity, coupon, yield, \\[frequency], \\[basis=1], \\[bondType=0])\n\n#### Arguments\n\n**settlement** is a scalar or vector of DATE type, indicating the marketable security's settlement date. The settlement date is the date after the issue date when the security is traded to the buyer.\n\n**maturity** is a scalar or vector of DATE type of the same length as *settlement*, indicating the marketable security's maturity date. The maturity date is the date when the security expires.\n\n**coupon** is a numeric scalar or vector indicating the annual coupon rate of the marketable security.\n\n**yield** is a numeric scalar or vector indicating the annual yield of the marketable security.\n\n**frequency** (optional) is an integer or a vector of integers indicating the number of coupon payments per year. This parameter is required when *bondType*is 0 or unspecified. It can be:\n\n* 1: Annual payments\n\n* 2: Semi-annual payments\n\n* 4: Quarterly payments\n\n* 12: Monthly payments\n\n**basis** (optional) is an integer or a vector of integers indicating the day count basis to use. It can be:\n\n<table id=\"table_edt_w3k_c1c\"><thead><tr><th align=\"left\">\n\n**Option**\n\n</th><th align=\"left\">\n\n**Description**\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\n0\n\n</td><td align=\"left\">\n\nUS (NASD) 30/360\n\n</td></tr><tr><td align=\"left\">\n\n1 or omitted\n\n</td><td align=\"left\">\n\nActual/actual\n\n</td></tr><tr><td align=\"left\">\n\n2\n\n</td><td align=\"left\">\n\nActual/360\n\n</td></tr><tr><td align=\"left\">\n\n3\n\n</td><td align=\"left\">\n\nActual/365\n\n</td></tr><tr><td align=\"left\">\n\n4\n\n</td><td align=\"left\">\n\nEuropean 30/360\n\n</td></tr></tbody>\n</table>**bondType** \\(optional\\) is an integral scalar or vector indicating the bond type. It can be:\n\n* 0 (default): Fixed-rate bond, where interest is paid periodically (quarterly, semi-annually, or annually) based on the coupon rate.\n\n* 1: Discount bond, where no interest is paid, and the bond is issued at a discount. FV at maturity = face value.\n\n* 2: Zero-coupon bond, where interest and face value are paid at maturity. FV at maturity = face value + interest.\n\n**Note**: Scalar inputs will be automatically expanded to match the length of other vector inputs. All vector inputs must be of equal length.\n\n#### Details\n\n`bondConvexity` returns the bond convexity for each 100 face value of a security with regular interest payments. Bond convexity is a measure of the non-linear relationship of bond prices to changes in interest rates, and is defined as the second derivative of the price of the bond with respect to interest rates.\n\nReturn value: Scalar or vector of type DOUBLE.\n\n#### Examples\n\nCalculate the convexity of a bond purchased on January 1, 2023, with maturity on December 31, 2030. The bond has an annual coupon rate of 0.05, an expected yield of 0.06, an annual interest payment frequency, and uses the actual/actual day count basis.\n\n```\nbondConvexity(settlement=2023.01.01, maturity=2030.12.31, coupon=0.05, yield=0.06, frequency=1, basis=1)\n// output\n50.78238914091385\n```\n"
    },
    "bondDirtyPrice": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bondDirtyPrice.html",
        "signatures": [
            {
                "full": "bondDirtyPrice(settlement, maturity, coupon, yield, [frequency], [basis=1], [bondType=0])",
                "name": "bondDirtyPrice",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "coupon",
                        "name": "coupon"
                    },
                    {
                        "full": "yield",
                        "name": "yield"
                    },
                    {
                        "full": "[frequency]",
                        "name": "frequency",
                        "optional": true
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[bondType=0]",
                        "name": "bondType",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [bondDirtyPrice](https://docs.dolphindb.com/en/Functions/b/bondDirtyPrice.html)\n\n\n\n#### Syntax\n\nbondDirtyPrice(settlement, maturity, coupon, yield, \\[frequency], \\[basis=1], \\[bondType=0])\n\n#### Arguments\n\n**settlement** is a scalar or vector of DATE type, indicating the marketable security's settlement date. The settlement date is the date after the issue date when the security is traded to the buyer.\n\n**maturity** is a scalar or vector of DATE type of the same length as *settlement*, indicating the marketable security's maturity date. The maturity date is the date when the security expires.\n\n**coupon** is a numeric scalar or vector indicating the annual coupon rate of the marketable security.\n\n**yield** is a numeric scalar or vector indicating the annual yield of the marketable security.\n\n**frequency** (optional) is an integer or a vector of integers indicating the number of coupon payments per year. This parameter is required when *bondType*is 0 or unspecified. It can be:\n\n* 1: Annual payments\n\n* 2: Semi-annual payments\n\n* 4: Quarterly payments\n\n* 12: Monthly payments\n\n**basis** (optional) is an integer or a vector of integers indicating the day count basis to use. It can be:\n\n<table id=\"table_vwc_dfc_zzb\"><thead><tr><th align=\"left\">\n\nOption\n\n</th><th align=\"left\">\n\nDescription\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\n0\n\n</td><td align=\"left\">\n\nUS (NASD) 30/360\n\n</td></tr><tr><td align=\"left\">\n\n1 or omitted\n\n</td><td align=\"left\">\n\nActual/actual\n\n</td></tr><tr><td align=\"left\">\n\n2\n\n</td><td align=\"left\">\n\nActual/360\n\n</td></tr><tr><td align=\"left\">\n\n3\n\n</td><td align=\"left\">\n\nActual/365\n\n</td></tr><tr><td align=\"left\">\n\n4\n\n</td><td align=\"left\">\n\nEuropean 30/360\n\n</td></tr></tbody>\n</table>**bondType** \\(optional\\) is an integral scalar or vector indicating the bond type. It can be:\n\n* 0 (default): Fixed-rate bond, where interest is paid periodically (quarterly, semi-annually, or annually) based on the coupon rate.\n\n* 1: Discount bond, where no interest is paid, and the bond is issued at a discount. FV at maturity = face value.\n\n* 2: Zero-coupon bond, where interest and face value are paid at maturity. FV at maturity = face value + interest.\n\n**Note**: Scalar inputs will be automatically expanded to match the length of other vector inputs. All vector inputs must be of equal length.\n\n#### Details\n\n`bondDirtyPrice` returns the price for each 100 face value of a security with regular interest payments.\n\n#### Examples\n\nCalculate the price for a bond issued on January 1, 2023, with a maturity date of December 31, 2030, an annual coupon interest rate of 5%, an expected yield of 6%, semi-annual interest payments, and an actual/actual day count basis.\n\n```\nbondDirtyPrice(settlement=2023.01.01,maturity=2030.12.31,coupon=0.05,yield=0.06,frequency=2,basis=1)\n// output\n93.73475540066079\n```\n"
    },
    "bondDuration": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bondDuration.html",
        "signatures": [
            {
                "full": "bondDuration(settlement, maturity, coupon, yield, [frequency], [basis=1], [bondType=0])",
                "name": "bondDuration",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "coupon",
                        "name": "coupon"
                    },
                    {
                        "full": "yield",
                        "name": "yield"
                    },
                    {
                        "full": "[frequency]",
                        "name": "frequency",
                        "optional": true
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[bondType=0]",
                        "name": "bondType",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [bondDuration](https://docs.dolphindb.com/en/Functions/b/bondDuration.html)\n\n\n\n#### Syntax\n\nbondDuration(settlement, maturity, coupon, yield, \\[frequency], \\[basis=1], \\[bondType=0])\n\n#### Arguments\n\n**settlement** is a scalar or vector of DATE type, indicating the marketable security's settlement date. The settlement date is the date after the issue date when the security is traded to the buyer.\n\n**maturity** is a scalar or vector of DATE type of the same length as *settlement*, indicating the marketable security's maturity date. The maturity date is the date when the security expires.\n\n**coupon** is a numeric scalar or vector indicating the annual coupon rate of the marketable security.\n\n**yield** is a numeric scalar or vector indicating the annual yield of the marketable security.\n\n**frequency** (optional) is an integer or a vector of integers indicating the number of coupon payments per year. This parameter is required when *bondType*is 0 or unspecified. It can be:\n\n* 1: Annual payments\n\n* 2: Semi-annual payments\n\n* 4: Quarterly payments\n\n* 12: Monthly payments\n\n**basis** (optional) is an integer or a vector of integers indicating the day count basis to use. It can be:\n\n<table id=\"table_hwx_h2c_zzb\"><thead><tr><th align=\"left\">\n\nOption\n\n</th><th align=\"left\">\n\nDescription\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\n0\n\n</td><td align=\"left\">\n\nUS (NASD) 30/360\n\n</td></tr><tr><td align=\"left\">\n\n1 or omitted\n\n</td><td align=\"left\">\n\nActual/actual\n\n</td></tr><tr><td align=\"left\">\n\n2\n\n</td><td align=\"left\">\n\nActual/360\n\n</td></tr><tr><td align=\"left\">\n\n3\n\n</td><td align=\"left\">\n\nActual/365\n\n</td></tr><tr><td align=\"left\">\n\n4\n\n</td><td align=\"left\">\n\nEuropean 30/360\n\n</td></tr></tbody>\n</table>**bondType** \\(optional\\) is an integral scalar or vector indicating the bond type. It can be:\n\n* 0 (default): Fixed-rate bond, where interest is paid periodically (quarterly, semi-annually, or annually) based on the coupon rate.\n\n* 1: Discount bond, where no interest is paid, and the bond is issued at a discount. FV at maturity = face value.\n\n* 2: Zero-coupon bond, where interest and face value are paid at maturity. FV at maturity = face value + interest.\n\n**Note**: Scalar inputs will be automatically expanded to match the length of other vector inputs. All vector inputs must be of equal length.\n\n#### Details\n\n`bondDuration` returns the Macaulay duration for an assumed par value of 100. Duration is defined as the weighted average of the present value of cash flows, and serves as a measure of a bond price's response to changes in yield.\n\nReturn type: Scalar or vector of type DOUBLE.\n\n#### Examples\n\nCalculate the duration of a bond purchased on January 1, 2023, with maturity on December 31, 2030. The bond has an annual coupon rate of 0.05, an expected yield of 0.06, an annual interest payment frequency, and uses the actual/actual day count basis.\n\n```\nbondDuration(settlement=2023.01.01, maturity=2030.12.31, coupon=0.05, yield=0.06, frequency=1, basis=1)\n// output\n6.737695071685634\n```\n"
    },
    "bool": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bool.html",
        "signatures": [
            {
                "full": "bool(X)",
                "name": "bool",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [bool](https://docs.dolphindb.com/en/Functions/b/bool.html)\n\n\n\n#### Syntax\n\nbool(X)\n\n#### Arguments\n\n**X** can be of any data type.\n\n#### Details\n\nConvert the input to a Boolean value.\n\n#### Examples\n\n```\nx=bool()\nx;\n// output\n00b\n\ntypestr x\n// output\nBOOL\n\nbool(`true`false)\n// output\n[1,0]\n\nbool(100.2)\n// output\n1\n\nbool(0)\n// output\n0\n```\n"
    },
    "brentq": {
        "url": "https://docs.dolphindb.com/en/Functions/b/brentq.html",
        "signatures": [
            {
                "full": "brentq(f, a, b, [xtol], [rtol], [maxIter], [funcDataParam])",
                "name": "brentq",
                "parameters": [
                    {
                        "full": "f",
                        "name": "f"
                    },
                    {
                        "full": "a",
                        "name": "a"
                    },
                    {
                        "full": "b",
                        "name": "b"
                    },
                    {
                        "full": "[xtol]",
                        "name": "xtol",
                        "optional": true
                    },
                    {
                        "full": "[rtol]",
                        "name": "rtol",
                        "optional": true
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[funcDataParam]",
                        "name": "funcDataParam",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [brentq](https://docs.dolphindb.com/en/Functions/b/brentq.html)\n\n\n\n#### Syntax\n\nbrentq(f, a, b, \\[xtol], \\[rtol], \\[maxIter], \\[funcDataParam])\n\n#### Arguments\n\n**f** is a function which returns a number. The function *f*must be continuous in \\[a,b], and *f(a)* and *f(b)* must have opposite signs.\n\n**a** is a numeric scalar that specifies the left boundary of the bracketing interval \\[a,b].\n\n**b** is a numeric scalar that specifies the right boundary of the bracketing interval \\[a,b].\n\n**xtol** / **rtol** (optional) are numeric scalars that specify the precision of the computed root. The computed root x0 satisfies `|x-x0| <= (xtol + rtol* |x0|)`, where x is the exact root. The default value of *xtol*is 2e-12, and the default value of *rtol*is 4 times the machine epsilon in double precision.\n\n**maxIter** (optional) is an integer indicating the maximum iterations. The default value is 100.\n\n**funcDataParam** (optional) is a vector containing extra arguments for the function *f*.\n\n#### Details\n\nFind a root x0 of a function*f*in a bracketing interval \\[a, b] using Brent's method.\n\n**Return value**: A vector res of length 2.\n\n* res\\[0] is a STRING scalar indicating the convergence information, which can be:\n\n  * CONVERGED: converged.\n\n  * SIGNERR: sign error.\n\n  * CONVERR: convergence error.\n\n* res\\[1] is a number representing the root of *f* between *a* and *b*.\n\n#### Examples\n\nFind the root of f(x) = x^2 - 1 in \\[-2,0] and \\[0,2].\n\n```\ndef f(x) {\n    return (pow(x, 2) - 1)\n}\n\nroot1 = brentq(f, -2, 0)\nroot2 = brentq(f, 0, 2)\nprint(\"root1 : \", root1)\nprint(\"root2 : \", root2)\n\n// output\nroot1 :\n(\"CONVERGED\",-1)\nroot2 :\n(\"CONVERGED\",1)\n```\n\nFind the root of f(x,b) with extra arguments in the \\[0,2].\n\n```\ndef f(x, b) {\n    return (pow(x, 2) - b)\n}\nroot = brentq(f, 0, 2, 2e-12, 1e-9, 100, [2])\nprint(\"root : \", root)\n\n// output\nroot : \n(\"CONVERGED\",1.414213562373136)\n```\n"
    },
    "brute": {
        "url": "https://docs.dolphindb.com/en/Functions/b/brute.html",
        "signatures": [
            {
                "full": "brute(func, ranges, [ns=20], [finish=fmin])",
                "name": "brute",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "ranges",
                        "name": "ranges"
                    },
                    {
                        "full": "[ns=20]",
                        "name": "ns",
                        "optional": true,
                        "default": "20"
                    },
                    {
                        "full": "[finish=fmin]",
                        "name": "finish",
                        "optional": true,
                        "default": "fmin"
                    }
                ]
            }
        ],
        "markdown": "### [brute](https://docs.dolphindb.com/en/Functions/b/brute.html)\n\n\n\n#### Syntax\n\nbrute(func, ranges, \\[ns=20], \\[finish=fmin])\n\n#### Details\n\nMinimize a function over a given range by brute force. Use the \"brute force\" method, i.e., compute the function's value at each point of a multidimensional grid of points, to find the global minimum of the function.\n\n**Note:** The brute force approach is inefficient because the number of grid points increases exponentially. Consequently, even in cases where the grid spacing is coarse, or the problem is only of medium size, it can take a long time to run, and/or run into memory limitations.\n\n#### Arguments\n\n**func** is the name of the function to be minimized. Note that its return value must be a numeric scalar.\n\n**ranges** is a tuple of tuples. Each tuple element can take the following forms:\n\n* (low, high): Specifies the minimum and maximum values for a parameter.\n\n* (low, high, num): Also includes the number of grid points between *low* and *high*.\n\n**ns**(optional) is a positive number indicating the number of grid points along the axes. If *ranges* is specified as *(low, high, num)*, *num* determines the number of points. Otherwise, *ns* is used, defaulting to 20 if not provided.\n\n**finish** (optional) is an optimization function that is called with the result of brute force minimization as initial guess. *finish* should be a function that returns a dictionary that contains keys 'xopt' and 'fopt' and their values should be numeric. The default value is the `fmin` function. If set to NULL, no \"polishing\" function is applied and the result of `brute` is returned directly.\n\n#### Return Values\n\nIt returns a dictionary with the following members:\n\n* xopt: Parameter that minimizes function.\n\n* fopt: Value of function at minimum: `fopt = f(xopt)`.\n\n#### Examples\n\nCalculate the minimum of function `f` within *ranges*.\n\n```\ndef f(z) {\n\ta = 2\n\tb = 3\n\tc = 7\n\td = 8\n\tee = 9\n\tf = 10\n\tg = 44\n\th = -1\n\ti = 2\n\tj = 26\n\tk = 1\n\tl = -2\n\tscale = 0.5\n\tx = z[0]\n\ty = z[1]\n\tf1 = a * square(x) + b * x * y + c * square(y) + d * x + ee* y + f\n\tf2 = -g * exp(-(square(x-h)+square(y-i)) / scale)\n\tf3 =  -j * exp(-(square(x-k)+square(y-l)) / scale)\n\treturn f1+f2+f3\n}\nranges=((-4, 3.75),(-4, 3.75))\nbrute(f, ranges, 32)\n\n/* Ouput:\n\nfopt->-3.408581876799\nxopt->[-1.056651921797,1.808348429512]\n\n*/\n```\n"
    },
    "bucket": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bucket.html",
        "signatures": [
            {
                "full": "bucket(vector, dataRange, bucketNum, [includeOutbound=false])",
                "name": "bucket",
                "parameters": [
                    {
                        "full": "vector",
                        "name": "vector"
                    },
                    {
                        "full": "dataRange",
                        "name": "dataRange"
                    },
                    {
                        "full": "bucketNum",
                        "name": "bucketNum"
                    },
                    {
                        "full": "[includeOutbound=false]",
                        "name": "includeOutbound",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [bucket](https://docs.dolphindb.com/en/Functions/b/bucket.html)\n\n\n\n#### Syntax\n\nbucket(vector, dataRange, bucketNum, \\[includeOutbound=false])\n\n#### Arguments\n\n**vector** is a numeric or temporal vector.\n\n**dataRange** is a pair indicating the data range, which includes the lower bound and excludes the upper bound.\n\n**bucketNum** is the number of buckets. The number of elements of the input vector that belong to *dataRange* must be a multiple of *bucketNum*.\n\n**includeOutbound** (optional) is a Boolean value indicating whether to include the bucket below the lower bound of the data range and the bucket beyond the upper bound of the data range. The default value is false.\n\n#### Details\n\nReturn a vector with the same length as the input *vector*. Each element of the result indicates which bucket each of the elements of the input vector belongs to, based on the bucket classification rules given by *dataRange* and *bucketNum*.\n\nFor example, if *dataRange* is 0:10, *bucketNum* is 2, and *includeOutbound* is unspecified, we have two buckets: \\[0, 5) and \\[5,10). Any value <0 or >=10 will be coded as NULL integer. If *includeOutbound* is set to be true, the example above will generate 4 buckets: <0, \\[0, 5), \\[5,10), >=10.\n\n#### Examples\n\n```\nbucket(9 23 54 36 46 12, 12:54, 2);\n// output\n[,0,,1,1,0]\n\nbucket(9 23 54 36 46 12, 12:54, 2, 1);\n// output\n[0,1,3,2,2,1]\n```\n"
    },
    "bucketCount": {
        "url": "https://docs.dolphindb.com/en/Functions/b/bucketCount.html",
        "signatures": [
            {
                "full": "bucketCount(vector, dataRange, bucketNum, [includeOutbound=false])",
                "name": "bucketCount",
                "parameters": [
                    {
                        "full": "vector",
                        "name": "vector"
                    },
                    {
                        "full": "dataRange",
                        "name": "dataRange"
                    },
                    {
                        "full": "bucketNum",
                        "name": "bucketNum"
                    },
                    {
                        "full": "[includeOutbound=false]",
                        "name": "includeOutbound",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [bucketCount](https://docs.dolphindb.com/en/Functions/b/bucketCount.html)\n\n\n\n#### Syntax\n\nbucketCount(vector, dataRange, bucketNum, \\[includeOutbound=false])\n\n#### Arguments\n\n**vector** is a numeric or temporal vector.\n\n**dataRange** is a pair indicating the data range, which includes the lower bound and excludes the upper bound.\n\n**bucketNum** is the number of buckets. The number of elements of the input vector that belong to dataRange must be a multiple of *bucketNum*.\n\n**includeOutbound** (optional) is a Boolean value indicating whether to include the bucket below the lower bound of the data range and the bucket beyond the upper bound of the data range. The default value is false.\n\n#### Details\n\nAccept the same set of parameters as the function [bucket](https://docs.dolphindb.com/en/Functions/b/bucket.html) and return the count for each bucket.\n\n#### Examples\n\n```\nbucketCount(9 23 54 36 46 12, 12:54, 2);\n// output\n[2,2]\n\nbucketCount(9 23 54 36 46 12, 12:54, 2, 1);\n// output\n[1,2,2,1]\n```\n"
    },
    "businessDay": {
        "url": "https://docs.dolphindb.com/en/Functions/b/businessDay.html",
        "signatures": [
            {
                "full": "businessDay(X, [offset], [n=1])",
                "name": "businessDay",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessDay](https://docs.dolphindb.com/en/Functions/b/businessDay.html)\n\n\n\n#### Syntax\n\nbusinessDay(X, \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**offset** (optional) is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nIf *X* is a business day (Monday to Friday), return date(X). Otherwise, return the most recent business day.\n\nIf parameter *offset* is specified, the result is updated every *n* business days. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nbusinessDay(2019.01.06);\n// output\n2019.01.04\n\nbusinessDay(2019.01.04);\n// output\n2019.01.04\n\ndate=2019.01.06 + 1..10\nbusinessDay = businessDay(date)\nbusinessDay2 = businessDay(date,min(date),2)\ntable(date, businessDay, businessDay2);\n```\n\n| date       | businessDay | businessDay2 |\n| ---------- | ----------- | ------------ |\n| 2019.01.07 | 2019.01.07  | 2019.01.07   |\n| 2019.01.08 | 2019.01.08  | 2019.01.07   |\n| 2019.01.09 | 2019.01.09  | 2019.01.09   |\n| 2019.01.10 | 2019.01.10  | 2019.01.09   |\n| 2019.01.11 | 2019.01.11  | 2019.01.11   |\n| 2019.01.12 | 2019.01.11  | 2019.01.11   |\n| 2019.01.13 | 2019.01.11  | 2019.01.11   |\n| 2019.01.14 | 2019.01.14  | 2019.01.11   |\n| 2019.01.15 | 2019.01.15  | 2019.01.15   |\n| 2019.01.16 | 2019.01.16  | 2019.01.15   |\n"
    },
    "businessMonthBegin": {
        "url": "https://docs.dolphindb.com/en/Functions/b/businessMonthBegin.html",
        "signatures": [
            {
                "full": "businessMonthBegin(X, [offset], [n=1])",
                "name": "businessMonthBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessMonthBegin](https://docs.dolphindb.com/en/Functions/b/businessMonthBegin.html)\n\n\n\n#### Syntax\n\nbusinessMonthBegin(X, \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**offset** (optional) is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the first business day (Monday to Friday) of the month that *X* belongs to.\n\nIf parameter *offset* is specified, the result is updated every *n* months. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nbusinessMonthBegin(2018.09.12);\n// output\n2018.09.03\n\nbusinessMonthBegin(2018.09.12, 2018.07.12, 3);\n// output\n2018.07.02\n\ndate=2016.04.12+(1..10)*30\ntime = take(09:30:00, 10)\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2016.05.12 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2016.06.11 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2016.07.11 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2016.08.10 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.09.09 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2016.10.09 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2016.11.08 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2016.12.08 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2017.01.07 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2017.02.06 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by businessMonthBegin(date,2016.01.01,2);\n```\n\n| businessMonthBegin\\_date | avg\\_price | sum\\_qty |\n| ------------------------ | ---------- | -------- |\n| 2016.05.02               | 39.53      | 4100     |\n| 2016.07.01               | 29.77      | 5300     |\n| 2016.09.01               | 175.1      | 12200    |\n| 2016.11.01               | 50.54      | 3800     |\n| 2017.01.02               | 51.835     | 13300    |\n\nRelated functions: [businessMonthEnd](https://docs.dolphindb.com/en/Functions/b/businessMonthEnd.html), [monthBegin](https://docs.dolphindb.com/en/Functions/m/monthBegin.html), [monthEnd](https://docs.dolphindb.com/en/Functions/m/monthEnd.html), [semiMonthBegin](https://docs.dolphindb.com/en/Functions/s/semiMonthBegin.html), [semiMonthEnd](https://docs.dolphindb.com/en/Functions/s/semiMonthEnd.html)\n"
    },
    "businessMonthEnd": {
        "url": "https://docs.dolphindb.com/en/Functions/b/businessMonthEnd.html",
        "signatures": [
            {
                "full": "businessMonthEnd(X, [offset], [n=1])",
                "name": "businessMonthEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessMonthEnd](https://docs.dolphindb.com/en/Functions/b/businessMonthEnd.html)\n\n\n\n#### Syntax\n\nbusinessMonthEnd(X, \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**offset** (optional) is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the last business day (Monday to Friday) of the month that *X* belongs to.\n\nIf parameter *offset* is specified, the result is updated every *n* months. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nbusinessMonthEnd(2010.10.12);\n// output\n2010.10.29\n\nbusinessMonthEnd(2010.10.12, 2000.03.31, 3);\n// output\n2010.12.31\n\ndate=2016.04.12+(1..10)*30\ntime = take(09:30:00, 10)\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2016.05.12 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2016.06.11 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2016.07.11 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2016.08.10 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.09.09 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2016.10.09 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2016.11.08 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2016.12.08 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2017.01.07 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2017.02.06 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by businessMonthEnd(date,2016.01.31,2);\n```\n\n| businessMonthEnd\\_date | avg\\_price | sum\\_qty |\n| ---------------------- | ---------- | -------- |\n| 2016.06.30             | 39.53      | 4100     |\n| 2016.08.31             | 29.77      | 5300     |\n| 2016.10.31             | 175.1      | 12200    |\n| 2016.12.30             | 50.54      | 3800     |\n| 2017.02.28             | 51.835     | 13300    |\n\nRelated functions: [businessMonthBegin](https://docs.dolphindb.com/en/Functions/b/businessMonthBegin.html), [monthBegin](https://docs.dolphindb.com/en/Functions/m/monthBegin.html), [monthEnd](https://docs.dolphindb.com/en/Functions/m/monthEnd.html), [semiMonthBegin](https://docs.dolphindb.com/en/Functions/s/semiMonthBegin.html), [semiMonthEnd](https://docs.dolphindb.com/en/Functions/s/semiMonthEnd.html)\n"
    },
    "businessQuarterBegin": {
        "url": "https://docs.dolphindb.com/en/Functions/b/businessQuarterBegin.html",
        "signatures": [
            {
                "full": "businessQuarterBegin(X, [startingMonth=1], [offset], [n=1])",
                "name": "businessQuarterBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessQuarterBegin](https://docs.dolphindb.com/en/Functions/b/businessQuarterBegin.html)\n\n\n\n#### Syntax\n\nbusinessQuarterBegin(X, \\[startingMonth=1], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**startingMonth** (optional) is an integer between 1 and 12 indicating a month. The default value is 1.\n\n**offset** (optional) is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the first business day (Monday to Friday) of the quarter that *X* belongs to. The first months of the quarters are determined by *startingMonth*. Note that *startingMonth*=1 is equivalent to *startingMonth*=4, 7 or 10.\n\nIf parameter *offset* is specified, the result is updated every *n* quarters. Parameter offset works only if parameter *n*>1.\n\n#### Examples\n\n```\nbusinessQuarterBegin(2012.06.12);\n// output\n2012.04.02\n\nbusinessQuarterBegin(2012.06.12, 3);\n// output\n2012.06.01\n\nbusinessQuarterBegin(2012.06.12, 8, 2011.08.01, 3);\n// output\n2012.05.01\n\ndate=2011.04.25+(1..10)*90\ntime = take(09:30:00, 10)\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2011.07.24 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2011.10.22 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2012.01.20 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2012.04.19 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2012.07.18 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2012.10.16 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2013.01.14 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2013.04.14 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2013.07.13 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2013.10.11 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by businessQuarterBegin(date, 10, 2010.10.01, 2);\n```\n\n| businessQuarterBegin\\_date | avg\\_price | sum\\_qty |\n| -------------------------- | ---------- | -------- |\n| 2011.04.01                 | 49.6       | 2200     |\n| 2011.10.03                 | 29.49      | 4000     |\n| 2012.04.02                 | 102.495    | 10000    |\n| 2012.10.01                 | 112.995    | 6700     |\n| 2013.04.01                 | 50.805     | 11300    |\n| 2013.10.01                 | 52.38      | 4500     |\n\nRelated functions: [businessQuarterEnd](https://docs.dolphindb.com/en/Functions/b/businessQuarterEnd.html), [quarterBegin](https://docs.dolphindb.com/en/Functions/q/quarterBegin.html), [quarterEnd](https://docs.dolphindb.com/en/Functions/q/quarterEnd.html)\n"
    },
    "businessQuarterEnd": {
        "url": "https://docs.dolphindb.com/en/Functions/b/businessQuarterEnd.html",
        "signatures": [
            {
                "full": "businessQuarterEnd(X, [endingMonth=12], [offset], [n=1])",
                "name": "businessQuarterEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[endingMonth=12]",
                        "name": "endingMonth",
                        "optional": true,
                        "default": "12"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessQuarterEnd](https://docs.dolphindb.com/en/Functions/b/businessQuarterEnd.html)\n\n\n\n#### Syntax\n\nbusinessQuarterEnd(X, \\[endingMonth=12], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**endingMonth** (optional) is an integer between 1 and 12 indicating a month. The default value is 12.\n\n**offset** (optional) is a scalar of the same data type as *X*, It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the last day of the quarter that *X* belongs to. The last months of the quarters are determined by *endingMonth*. Note that *endingMonth*=3 is equivalent to *endingMonth*=6, 9 or 12.\n\nIf parameter *offset* is specified, the result is updated every *n* quarters. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```language-python\nbusinessQuarterEnd(2012.04.12);\n// output\n2012.06.30\n\nbusinessQuarterEnd(2012.04.12, 2);\n// output\n2012.05.31\n\nbusinessQuarterEnd(2012.04.12, 8, 2011.08.01, 3);\n// output\n2012.05.31\n\ndate=2011.04.25+(1..10)*90\ntime = take(09:30:00, 10)\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2011.07.24 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2011.10.22 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2012.01.20 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2012.04.19 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2012.07.18 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2012.10.16 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2013.01.14 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2013.04.14 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2013.07.13 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2013.10.11 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```language-python\nselect avg(price),sum(qty) from t1 group by businessQuarterEnd(date, , 2010.06.01, 2)\n```\n\n| businessQuarterEnd\\_date | avg\\_price | sum\\_qty |\n| ------------------------ | ---------- | -------- |\n| 2011.12.30               | 39.53      | 4100     |\n| 2012.06.29               | 29.77      | 5300     |\n| 2012.12.31               | 175.1      | 12200    |\n| 2013.06.28               | 50.54      | 3800     |\n| 2013.12.31               | 51.835     | 13300    |\n\nRelated functions: [businessQuarterBegin](https://docs.dolphindb.com/en/Functions/b/businessQuarterBegin.html), [quarterBegin](https://docs.dolphindb.com/en/Functions/q/quarterBegin.html), [quarterEnd](https://docs.dolphindb.com/en/Functions/q/quarterEnd.html)\n"
    },
    "businessYearBegin": {
        "url": "https://docs.dolphindb.com/en/Functions/b/businessYearBegin.html",
        "signatures": [
            {
                "full": "businessYearBegin(X, [startingMonth=1], [offset], [n=1])",
                "name": "businessYearBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessYearBegin](https://docs.dolphindb.com/en/Functions/b/businessYearBegin.html)\n\n\n\n#### Syntax\n\nbusinessYearBegin(X, \\[startingMonth=1], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**startingMonth** (optional) is an integer between 1 and 12 indicating a month. The default value is 1.\n\n**offset** (optional) is a scalar of the same data type as *X*, It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the first business day (Monday to Friday) of the year that *X* belongs to and that starts in the month of *startingMonth*.\n\nIf parameter *offset* is specified, the result is updated every *n* years. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nbusinessYearBegin(2012.06.12);\n// output\n2012.01.02\n\nbusinessYearBegin(2012.06.13 10:10:10.008,5);\n// output\n2012.05.01\n\ndate=2011.10.25 2012.10.25 2013.10.25 2014.10.25 2015.10.25 2016.10.25 2017.10.25 2018.10.25 2019.10.25 2020.10.25\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by businessYearBegin(date,1,2011.10.01,2)\n```\n\n| businessYearBegin\\_date | avg\\_price | sum\\_qty |\n| ----------------------- | ---------- | -------- |\n| 2011.01.03              | 39.53      | 4100     |\n| 2013.01.01              | 29.77      | 5300     |\n| 2015.01.01              | 175.1      | 12200    |\n| 2017.01.02              | 50.54      | 3800     |\n| 2019.01.01              | 51.835     | 13300    |\n\nRelated functions: [businessYearEnd](https://docs.dolphindb.com/en/Functions/b/businessYearEnd.html), [yearBegin](https://docs.dolphindb.com/en/Functions/y/yearBegin.html), [yearEnd](https://docs.dolphindb.com/en/Functions/y/yearEnd.html)\n"
    },
    "businessYearEnd": {
        "url": "https://docs.dolphindb.com/en/Functions/b/businessYearEnd.html",
        "signatures": [
            {
                "full": "businessYearEnd(X, [endingMonth=12], [offset], [n=1])",
                "name": "businessYearEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[endingMonth=12]",
                        "name": "endingMonth",
                        "optional": true,
                        "default": "12"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessYearEnd](https://docs.dolphindb.com/en/Functions/b/businessYearEnd.html)\n\n\n\n#### Syntax\n\nbusinessYearEnd(X, \\[endingMonth=12], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**endingMonth** is an integer between 1 and 12 indicating a month. The default value is 12.\n\n**offset** (optional) is a scalar of the same data type as *X*, It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the last business day (Monday to Friday) of the year that *X* belongs to and that ends in the month of *endingMonth*.\n\nIf parameter *offset* is specified, the result is updated every *n* years. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nbusinessYearEnd(2012.06.12, 3);\n// output\n2013.03.29\n\nbusinessYearEnd(2012.06.12, 9);\n// output\n2012.09.28\n\nbusinessYearEnd(2012.06.12);\n// output\n2012.12.31\n\nbusinessYearEnd(2012.06.12, 12, 2009.04.03, 2);\n// output\n2013.12.31\n\ndate=2011.04.25+(1..10)*365\ntime = take(09:30:00, 10)\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2012.04.24 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2013.04.24 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2014.04.24 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2015.04.24 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.04.23 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2017.04.23 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2018.04.23 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2019.04.23 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2020.04.22 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2021.04.22 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by businessYearEnd(date, 4, 2010.04.01, 2);\n```\n\n| businessYearEnd\\_date | avg\\_price | sum\\_qty |\n| --------------------- | ---------- | -------- |\n| 2012.04.30            | 49.6       | 2200     |\n| 2014.04.30            | 29.49      | 4000     |\n| 2016.04.29            | 102.495    | 10000    |\n| 2018.04.30            | 112.995    | 6700     |\n| 2020.04.30            | 50.805     | 11300    |\n| 2022.04.29            | 52.38      | 4500     |\n\nRelated functions: [businessYearBegin](https://docs.dolphindb.com/en/Functions/b/businessYearBegin.html), [yearBegin](https://docs.dolphindb.com/en/Functions/y/yearBegin.html), [yearEnd](https://docs.dolphindb.com/en/Functions/y/yearEnd.html)\n"
    },
    "dailyAlignedBar": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dailyAlignedBar.html",
        "signatures": [
            {
                "full": "dailyAlignedBar(X, timeOffset, n, [timeEnd], [mergeSessionEnd=false])",
                "name": "dailyAlignedBar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "timeOffset",
                        "name": "timeOffset"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    },
                    {
                        "full": "[timeEnd]",
                        "name": "timeEnd",
                        "optional": true
                    },
                    {
                        "full": "[mergeSessionEnd=false]",
                        "name": "mergeSessionEnd",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [dailyAlignedBar](https://docs.dolphindb.com/en/Functions/d/dailyAlignedBar.html)\n\n\n\n#### Syntax\n\ndailyAlignedBar(X, timeOffset, n, \\[timeEnd], \\[mergeSessionEnd=false])\n\n#### Arguments\n\n**X** is a temporal vector of type SECOND, TIME, NANOTIME, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**timeOffset** is a scalar/vector of type SECOND, TIME or NANOTIME with the same accuracy of *X* indicating the left boundary of session(s). If it is a vector, it must be increasing.\n\n**n** is a positive integer or DURATION type data indicating the window length. If *n* is a positive integer, its unit is the minimum accuracy of *timeOffset*. If *n* is a DURATION type data, its unit cannot be y, M, w, d, B.\n\n**timeEnd** (optional) is of the same type and length of *timeOffset* indicating the right boundary of session(s).\n\n**mergeSessionEnd** (optional) is a Boolean value. When the right boundary of a session (as specified in *timeEnd*) is also the right boundary of a window, if *mergeSessionEnd*=true, the right boundary of the session is merged into the previous window.\n\n#### Details\n\nDetermine windows based on the starting time (specified by *timeOffset*), window length (specified by *n*), and possibly ending time (specified by *timeEnd*). For each element of *X*, return the starting time of the window it belongs to. Specifically, return `X-((X-timeOffset)%n)` for each element of *X* and return a vector with the same length as *X*.\n\nGenerally, a window includes the left boundary but not the right boundary. If *mergeSessionEnd*=true and the right boundary of a session is also the right boundary of a window, the right boundary of the session is merged into the previous window.\n\nThe function supports overnight sessions.\n\n#### Examples\n\nPlease note that the examples below use randomly generated data for the column of price. The result is different each time you execute it.\n\nExample 1. The Chinese stock market has 2 sessions each day: from 9:30AM to 11:30AM and from 1PM to 3PM. The script below calculates rolling 1-hour average prices for these sessions.\n\n```\nsessionsBegin = 09:30:00 13:00:00\nts = 2019.11.01T09:30:00..2019.11.01T11:30:00 join 2019.11.01T13:00:00..2019.11.01T15:00:00\nt = table(ts, rand(10.0, size(ts)) as price);\n\nselect avg(price) as price, count(*) as count from t group by dailyAlignedBar(ts, sessionsBegin, 60*60) as k60;\n```\n\n| k60                 | price             | count |\n| ------------------- | ----------------- | ----- |\n| 2019.11.01T09:30:00 | 5.031685383252463 | 3600  |\n| 2019.11.01T10:30:00 | 5.022667285786399 | 3600  |\n| 2019.11.01T11:30:00 | 4.930270051117987 | 1     |\n| 2019.11.01T13:00:00 | 4.931854071494632 | 3600  |\n| 2019.11.01T14:00:00 | 4.979529541734115 | 3600  |\n| 2019.11.01T15:00:00 | 0.961996954865754 | 1     |\n\nAs a window includes the left boundary but not the right boundary, if the right boundary of a session is also the right boundary of a window as in the example above, the right boundary of the session belongs to a window that has no other records if *timeEnd* and *mergeSessionEnd* are not specified. In most cases we would like to merge the right boundary of a session to the previous window. Please refer to the example below.\n\n```\nsessionsEnd = 11:30:00 15:00:00;\nselect avg(price) as price, count(*) as count from t group by dailyAlignedBar(ts, sessionsBegin, 60*60, sessionsEnd, true) as k60;\n```\n\n| k60                 | price             | count |\n| ------------------- | ----------------- | ----- |\n| 2019.11.01T09:30:00 | 5.031685383252463 | 3600  |\n| 2019.11.01T10:30:00 | 5.022641627015316 | 3601  |\n| 2019.11.01T13:00:00 | 4.931854071494632 | 3600  |\n| 2019.11.01T14:00:00 | 4.978413870368697 | 3601  |\n\nExample 2. The futures market has 2 sessions each day: from 1:30PM to 4:30PM and from 10:30PM to 2:30AM the next day. `dailyAlignedBar` is used to calculate 7-minute average prices for these sessions. Please note that we simulate 2 days' data in the example.\n\n```\nsessions = 13:30:00 22:30:00\nts = 2019.11.01T13:30:00..2019.11.01T16:30:00 join 2019.11.01T22:30:00..2019.11.02T02:30:00\nts = ts join (ts+60*60*24)\nt = table(ts, rand(10.0, size(ts)) as price)\nselect avg(price) as price, count(*) as count from t group by dailyAlignedBar(ts, sessions, 7m) as k7;\n```\n\nEx 3. When calculating 1-minute OHLC bars, the data type needs to be converted to LONG if *n* needs to be converted to NANOTIMESTAMP, otherwise an integer overflow will occur.\n\n```\nn = 1000000\nnano=(09:30:00.000000000 + rand(long(6.5*60*60*1000000000), n)).sort!()\nsessionStartNano=09:30:00.000000000\nprice = 100+cumsum(rand(0.02, n)-0.01)\nvolume = rand(1000, n)\nsymbol = rand(`600519`000001`600000`601766, n)\ntradeNano=table(symbol, nano, price, volume).sortBy!(`symbol`nano)\nundef(`nano`price`volume`symbol)\nbarMinutes=7\nitv = barMinutes*60*long(1000000000)\n\nOHLC_nano=select first(price) as open, max(price) as high, min(price) as low, last(price) as close, sum(volume) as volume from tradeNano group by symbol, dailyAlignedBar(nano, sessionStartNano, itv) as barStart\n```\n\nRelated function: [bar](https://docs.dolphindb.com/en/Functions/b/bar.html)\n"
    },
    "database": {
        "url": "https://docs.dolphindb.com/en/Functions/d/database.html",
        "signatures": [
            {
                "full": "database(directory, [partitionType], [partitionScheme], [locations], [engine='OLAP'], [atomic='TRANS'])",
                "name": "database",
                "parameters": [
                    {
                        "full": "directory",
                        "name": "directory"
                    },
                    {
                        "full": "[partitionType]",
                        "name": "partitionType",
                        "optional": true
                    },
                    {
                        "full": "[partitionScheme]",
                        "name": "partitionScheme",
                        "optional": true
                    },
                    {
                        "full": "[locations]",
                        "name": "locations",
                        "optional": true
                    },
                    {
                        "full": "[engine='OLAP']",
                        "name": "engine",
                        "optional": true,
                        "default": "'OLAP'"
                    },
                    {
                        "full": "[atomic='TRANS']",
                        "name": "atomic",
                        "optional": true,
                        "default": "'TRANS'"
                    }
                ]
            },
            {
                "full": "database(directory, [partitionType], [partitionScheme], [locations], [engine='OLAP'], [atomic='TRANS'], [chunkGranularity='TABLE'])",
                "name": "database",
                "parameters": [
                    {
                        "full": "directory",
                        "name": "directory"
                    },
                    {
                        "full": "[partitionType]",
                        "name": "partitionType",
                        "optional": true
                    },
                    {
                        "full": "[partitionScheme]",
                        "name": "partitionScheme",
                        "optional": true
                    },
                    {
                        "full": "[locations]",
                        "name": "locations",
                        "optional": true
                    },
                    {
                        "full": "[engine='OLAP']",
                        "name": "engine",
                        "optional": true,
                        "default": "'OLAP'"
                    },
                    {
                        "full": "[atomic='TRANS']",
                        "name": "atomic",
                        "optional": true,
                        "default": "'TRANS'"
                    },
                    {
                        "full": "[chunkGranularity='TABLE']",
                        "name": "chunkGranularity",
                        "optional": true,
                        "default": "'TABLE'"
                    }
                ]
            }
        ],
        "markdown": "### [database](https://docs.dolphindb.com/en/Functions/d/database.html)\n\n\n\n#### Syntax\n\ndatabase(directory, \\[partitionType], \\[partitionScheme], \\[locations], \\[engine='OLAP'], \\[atomic='TRANS'])\n\nStarting from 1.30.16/2.00.4, if the configuration paramter *enableChunkGranularityConfig* = true, use the following syntax:\n\ndatabase(directory, \\[partitionType], \\[partitionScheme], \\[locations], \\[engine='OLAP'], \\[atomic='TRANS'], \\[chunkGranularity='TABLE'])\n\n#### Arguments\n\n**directory** is the directory where a database is located. To establish a database in the distributed file system, *directory* should start with \"dfs\\://\".To establish an IMOLTP database, directory should start with \"oltp\\://\". Make sure the configuration parameter *enableIMOLTP* is set to true before creating an IMOLTP database.\n\n**partitionType** (optional) specifies the partition type, which can be: sequential (SEQ), range (RANGE), hash (HASH), value (VALUE), list (LIST), and composite (COMPO).\n\n**partitionScheme** (optional) describes how the partitions are created. It is usually a vector, with the exception that it is an integer scalar for the sequential domain. The interpretation of the partition scheme depends on the partition type. *partitionScheme* supports the following data types: CHAR, SHORT, INT, DATE, MONTH, TIME, MINUTE, SECOND, DATETIME, and SYMBOL.\n\n| Partition Type    | Partition Type Symbol | Partition Scheme                                                                                                                                                     |\n| ----------------- | --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| sequential domain | SEQ                   | An integer scalar. It means the number of partitions.                                                                                                                |\n| range domain      | RANGE                 | A vector. Any two adjacent elements of the vector define the range for a partition.                                                                                  |\n| hash domain       | HASH                  | A tuple. The first element is the data type of partitioning column. The second element is the number of partitions.                                                  |\n| value domain      | VALUE                 | A vector. Each element of the vector defines a partition.                                                                                                            |\n| list domain       | LIST                  | A vector. Each element of the vector defines a partition.                                                                                                            |\n| composite domain  | COMPO                 | A vector. Each element of the vector is a database handle. The vector can contain two or three elements and the length of the vector indicates the partition levels. |\n\n**locations** (optional) is a tuple indicating the locations of each partition. The number of elements in the tuple should be the same as that of partitions determined by *partitionType* and *partitionScheme*. When saving partitions on multiple nodes, we can specify the location for each partition by using the DFS (Distributed File System) or the *locations* parameter. If the *locations* parameter is not specified, all partitions reside in the current node. We cannot specify partition *locations* for composite partitions.\n\n**engine** (optional) specifies the storage engine. It can be 'OLAP' (default), 'TSDB', 'IMOLTP' or 'PKEY'. Note that the TSDB and PKEY engines only support creating distributed databases.\n\n**engine** (optional) specifies the storage engine. It can be 'OLAP' (default), 'TSDB' or 'IMOLTP'.\n\n**atomic** (optional) indicates at which level the atomicity is guaranteed for a write transaction, thus determining whether concurrent writes to the same chunk are allowed. It can be 'TRANS' or 'CHUNK' and the default value is 'TRANS'.\n\n* 'TRANS' indicates that the atomicity is guaranteed at the transaction level. If a transaction attempts to write to multiple chunks and one of the chunks is locked by another transaction, a write-write conflict occurs, and all writes of the transaction fail. Therefore, setting *atomic* ='TRANS' means concurrent writes to a chunk are not allowed.\n\n* 'CHUNK' indicates that the atomicity is guaranteed at the chunk level. If a transaction tries to write to multiple chunks and a write-write conflict occurs as a chunk is locked by another transaction, instead of aborting the writes, the transaction will keep writing to the non-locked chunks and keep attempting to write to the chunk in conflict until it is still locked after a few minutes. Therefore, setting *atomic* ='CHUNK' means concurrent writes to a chunk are allowed. As the atomicity at the transaction level is not guaranteed, the write operation may succeed in some chunks but fail in other chunks. Please also note that the write speed may be impacted by the repeated attempts to write to the chunks that are locked.\n\n**chunkGranularity** (optional) is a string indicating the chunk granularity. It determines whether concurrent writes to different tables in the same chunk are allowed. It is only enabled when *enableChunkGranularityConfig* = true is configured. The value can be 'TABLE' or 'DATABASE':\n\n* 'TABLE': the chunk granularity is at the TABLE level. In this case, concurrent writes to different tables in the same partition are allowed.\n\n* 'DATABASE': the chunk granularity is at the DATABASE level. In this case, concurrent writes to different tables in the same partition are not allowed.\n\nThe chunk granularity determines where a DolphinDB transaction locates the lock. For databases created with version 1.30.16/2.00.4 or earlier, the chunk granularity is at the DATABASE level, i.e., each partition of the database is a chunk. Starting from version 1.30.16/2.00.4, the default chunk granularity is at the TABLE level and each table of the partition is a chunk.\n\n#### Details\n\nCreate a database handle.\n\nTo create a DFS database, *partitionType* and *partitionScheme* must be specified. To reopen an existing distributed database, only *directory* is required. It is not allowed to overwrite an existing distributed database with a different *partitionType* or *partitionScheme*.\n\n#### Examples\n\nExample 1. To establish a non-partitioned database on disk:\n\n```\ndb=database(directory=\"C:/DolphinDB/Data/db1/\");\nt=table(take(1..10,1000) as id, rand(10,1000) as x, rand(10.0,1000) as y);\nsaveTable(db, t, `t1);\n```\n\nExample 2. For distributed database, here's an example for each type of partition:\n\n* **Partition Type: SEQ**\n\n  In a sequential domain (SEQ), the partitions are based on the order of rows in the input data file. It can only be used in the local file system, not in the distributed file system.\n\n  ```\n  n=1000000\n  ID=rand(100, n)\n  dates=2017.08.07..2017.08.11\n  date=rand(dates, n)\n  x=rand(10.0, n)\n  t=table(ID, date, x);\n  saveText(t, \"C:/DolphinDB/Data/t.txt\");\n\n  db = database(directory=\"C:/DolphinDB/Data/seqdb\", partitionType=SEQ, partitionScheme=8)\n  pt = loadTextEx(db, `pt, ,\"C:/DolphinDB/Data/t.txt\");\n  ```\n\n  Under the folder *C:/DolphinDB/data/seqdb*, 8 sub folders have been created. Each of them corresponds to a partition of the input data file. If the size of the input data file is larger than the available memory of the computer, we can load the data in partitions.\n\n  ![](https://docs.dolphindb.com/en/images/database01.png)\n\n* **Partition Type: RANGE**\n\n  In a range domain (RANGE), partitions are determined by any two adjacent elements of the partition scheme vector. The starting value is inclusive and the ending value is exclusive.\n\n  ```\n  n=1000000\n  ID=rand(10, n)\n  x=rand(1.0, n)\n  t=table(ID, x);\n  db=database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 5 10)\n  pt = db.createPartitionedTable(t, `pt, `ID);\n  pt.append!(t);\n\n  pt=loadTable(db,`pt)\n  x=select * from pt\n  select count(x) from pt;\n  ```\n\n  | count\\_x |\n  | -------- |\n  | 1000000  |\n\n  In the example above, the database db has two partitions: \\[0,5) and \\[5,10). Table t is saved as a partitioned table pt with the partitioning column of ID in database db.\n\n  ![](https://docs.dolphindb.com/en/images/database02.png)\n\n  To import a data file into a distributed database of range domain in the local file system:\n\n  ```\n  n=1000000\n  ID=rand(10, n)\n  x=rand(1.0, n)\n  t=table(ID, x);\n  saveText(t, \"C:/DolphinDB/Data/t.txt\");\n\n  db=database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 5 10)\n  pt = loadTextEx(db, `pt, `ID, \"C:/DolphinDB/Data/t.txt\");\n  ```\n\n* **Partition Type: HASH**\n\n  In a hash domain (HASH), the data type and numbers of partitions need to be specified.\n\n  ```\n  n=1000000\n  ID=rand(10, n)\n  x=rand(1.0, n)\n  t=table(ID, x)\n  db=database(directory=\"dfs://hashdb\", partitionType=HASH, partitionScheme=[INT, 2])\n\n  pt = db.createPartitionedTable(t, `pt, `ID)\n  pt.append!(t);\n\n  select count(x) from pt;\n  ```\n\n  | count\\_x |\n  | -------- |\n  | 1000000  |\n\n  In example above, database db has two partitions. Table t is saved as pt(a partitioned table) with the partitioning column ID.\n\n  Note: For a database to be imported to a hash domain, if a partitioning column contains NULL value, the record is discarded.\n\n  ```\n  ID = NULL 3 6 NULL 9\n  x = rand(1.0, 5)\n  t1 = table(ID, x)\n  pt.append!(t1)\n  select count(x) from pt;\n  ```\n\n  | count\\_x |\n  | -------- |\n  | 1000003  |\n\n* **Partition Type: VALUE**\n\n  In a value domain (VALUE), each element of the partition scheme vector determines a partition.\n\n  ```\n  n=1000000\n  month=take(2000.01M..2016.12M, n);\n  x=rand(1.0, n);\n  t=table(month, x);\n\n  db=database(directory=\"dfs://valuedb\", partitionType=VALUE, partitionScheme=2000.01M..2016.12M)\n  pt = db.createPartitionedTable(t, `pt, `month);\n  pt.append!(t);\n\n  pt=loadTable(db,`pt)\n  select count(x) from pt;\n  ```\n\n  | count\\_x |\n  | -------- |\n  | 1000000  |\n\n  The example above defines a database db with 204 partitions. Each of these partitions is a month between January 2000 and December 2016. With function `createPartitionedTable` and `append!`, table t is saved as a partitioned table pt in the database db with the partitioning column of month.\n\n  ![](https://docs.dolphindb.com/en/images/database03.png)\n\n* **Partition Type: LIST**\n\n  In a list domain (LIST), each element of the partition scheme vector determines a partition.\n\n  ```\n  n=1000000\n  ticker = rand(`MSFT`GOOG`FB`ORCL`IBM,n);\n  x=rand(1.0, n);\n  t=table(ticker, x);\n\n  db=database(directory=\"dfs://listdb\", partitionType=LIST, partitionScheme=[`IBM`ORCL`MSFT, `GOOG`FB])\n  pt = db.createPartitionedTable(t, `pt, `ticker)\n  pt.append!(t);\n\n  pt=loadTable(db,`pt)\n  select count(x) from pt;\n  ```\n\n  | count\\_x |\n  | -------- |\n  | 1000000  |\n\n  The database above has 2 partitions. The first partition has 3 tickers and the second has 2 tickers.\n\n  ![](https://docs.dolphindb.com/en/images/database04.png)\n\n* **Partition Type: COMPO**\n\n  In a composite domain (COMPO), we can have 2 or 3 partitioning columns. Each column can be of range, value, or list domain.\n\n  ```\n  n=1000000\n  ID=rand(100, n)\n  dates=2017.08.07..2017.08.11\n  date=rand(dates, n)\n  x=rand(10.0, n)\n  t=table(ID, date, x)\n\n  dbDate = database(, partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\n  dbID = database(, partitionType=RANGE, partitionScheme=0 50 100)\n  db = database(directory=\"dfs://compoDB\", partitionType=COMPO, partitionScheme=[dbDate, dbID])\n\n  pt = db.createPartitionedTable(t, `pt, `date`ID)\n  pt.append!(t)\n\n  pt=loadTable(db,`pt)\n  select count(x) from pt;\n  ```\n\n  | count\\_x |\n  | -------- |\n  | 1000000  |\n\n  The value domain has 5 partitions for 5 days:\n\n  ![](https://docs.dolphindb.com/en/images/database05.png)\n\n  The range domain has 2 partitions:\n\n  ![](https://docs.dolphindb.com/en/images/database06.png)\n\n  Please note that the although we have 2 levels of folders here for database files, composite domain only has one level of partition. In comparision, there are 2 levels of partition in dual partition.\n\nExample 3. To establish distributed databases in the distributed file system, we can follow the syntax of the examples above. The only difference is that the *directory* parameter in function `database` should start with \"dfs\\://\".\n\nTo execute the following examples, we need to start a DFS cluster on the web interface, and submit the script on a data node.\n\nSave a partitioned table of composite domain in the distributed file system:\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x);\n\ndbDate = database(, partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\ndbID=database(, partitionType=RANGE, partitionScheme=0 50 100);\ndb = database(directory=\"dfs://compoDB\", partitionType=COMPO, partitionScheme=[dbDate, dbID]);\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n```\n\nThe data are stored at a location specified by the configuration parameter volumes.\n\n![](https://docs.dolphindb.com/en/images/database07.png)\n\nPlease note that DFS\\_NODE1 only has 4 date folders; under DFS\\_NODE1, the folder of 20170807 only has 1 ID folder. This is because here we have 4 data nodes and 2*5=10 partitions based on date and ID. By default each partition has 3 copies in the distributed file system. Therefore, we have 5*2\\*3=30 partitions in total saved on 4 data nodes. Not all data nodes have all the 10 partitions.\n\nImport a data file into a distributed database of range domain in the distributed file system:\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x);\nsaveText(t, \"C:/DolphinDB/Data/t.txt\");\n\ndb=database(\"dfs://rangedb\", RANGE,  0 5 10)\npt = loadTextEx(db, `pt, `ID, \"C:/DolphinDB/Data/t.txt\");\n```\n\nExample 4. Use the parameter *locations*\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x);\n\ndb=database(directory=\"dfs://rangedb5\", partitionType=RANGE, partitionScheme=0 5 10, locations=[`node1`node2, `node3])\npt = db.createPartitionedTable(t, `pt, `ID);\npt.append!(t);\n```\n\nThe example above defines a list domain that has 2 partitions. The first partition resides on 2 sites: node1 and node2, and the second partition resides on site node3. All referred sites must be defined in the sites attribute of *dolphindb.cfg* on all machines where these nodes are located:\n\n```\nsites=111.222.3.4:8080:node1, 111.222.3.5:8080:node2, 111.222.3.6:8080:node3\n```\n\nSites are separated by comma. Each site specification contains 3 parts: host name, port number, and alias. A partition can reside on multiple sites that back up each other. In this example, each node is located on a different machine.\n\nWe can also use the actual host name and the port number to represent a site. The function call can be changed to\n\n```\ndb=database(\"C:/DolphinDB/Data/rangedb6\", RANGE, 0 5 10, [[\"111.222.3.4:8080\", \"111.222.3.5:8080\"], \"111.222.3.6:8080\"])\n```\n\nExample 5. Use the parameter *atomic*:\n\n```\nif(existsDatabase(\"dfs://test\"))\ndropDB(\"dfs://test\")\ndb = database(directory=\"dfs://test\", partitionType=VALUE, partitionScheme=1..20, atomic='CHUNK')\ndummy = table(take(1..20, 100000) as id, rand(1.0, 100000) as value)\npt = db.createPartitionedTable(dummy, \"pt\", `id)\n\ndummy1 = table(take(1..15, 1000000) as id, rand(1.0, 1000000) as value)\ndummy2 = table(take(11..20, 1000000) as id, rand(1.0, 1000000) as value)\nsubmitJob(\"write1\", \"writer1\", append!{pt, dummy1})\nsubmitJob(\"write2\", \"writer2\", append!{pt, dummy2})\nsubmitJob(\"write3\", \"writer3\", append!{pt, dummy1})\nsubmitJob(\"write4\", \"writer4\", append!{pt, dummy2})\nselect count(*) from pt\n// output\n4,000,000\n```\n"
    },
    "date": {
        "url": "https://docs.dolphindb.com/en/Functions/d/date.html",
        "signatures": [
            {
                "full": "date(X)",
                "name": "date",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [date](https://docs.dolphindb.com/en/Functions/d/date.html)\n\n\n\n#### Syntax\n\ndate(X)\n\n#### Arguments\n\n**X** is an integer or temporal scalar/vector.\n\n#### Details\n\nConvert *X* into DATE type.\n\n#### Examples\n\n```\ndate 2012.12.03 01:22:01;\n// output\n2012.12.03\n\ndate(2016.03M);\n// output\n2016.03.01\n\ndate(1);\n// output\n1970.01.02\n```\n\nRelated functions: [second](https://docs.dolphindb.com/en/Functions/s/second.html), [minute](https://docs.dolphindb.com/en/Functions/m/minute.html), [month](https://docs.dolphindb.com/en/Functions/m/month.html), [hour](https://docs.dolphindb.com/en/Functions/h/hour.html), [year](https://docs.dolphindb.com/en/Functions/y/year.html)\n"
    },
    "datehour": {
        "url": "https://docs.dolphindb.com/en/Functions/d/datehour.html",
        "signatures": [
            {
                "full": "datehour(X)",
                "name": "datehour",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [datehour](https://docs.dolphindb.com/en/Functions/d/datehour.html)\n\n\n\n#### Syntax\n\ndatehour(X)\n\n#### Arguments\n\n**X** is a temporal scalar/vector that contains information about dates.\n\n#### Details\n\nConvert *X* into DATEHOUR data type.\n\nSince version 2.00.12, converting MONTH into DATEHOUR is allowed.\n\n#### Examples\n\n```\ndatehour(2012.06.13 13:30:10);\n// output: 2012.06.13T13\n\ndatehour([2012.06.15 15:32:10.158,2012.06.15 17:30:10.008]);\n// output: [2012.06.15T15,2012.06.15T17]\n\ndatehour(2012.01M)\n// output: 2012.01.01T00\n```\n"
    },
    "datetime": {
        "url": "https://docs.dolphindb.com/en/Functions/d/datetime.html",
        "signatures": [
            {
                "full": "datetime(X)",
                "name": "datetime",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [datetime](https://docs.dolphindb.com/en/Functions/d/datetime.html)\n\n\n\n#### Syntax\n\ndatetime(X)\n\n#### Arguments\n\n**X** is a temporal scalar/vector, or an integer.\n\n#### Details\n\nConvert *X* into DATETIME type. Since version 2.00.12, converting MONTH into DATETIME is allowed.\n\n**Note:** The range for data of DATETIME type is \\[1901.12.13T20:45:53, 2038.01.19T03:14:07].\n\n#### Examples\n\n```\ndatetime(2009.11.10);\n// output: 2009.11.10T00:00:00\n\ntypestr datetime(2009.11.10);\n// output: DATETIME\n\ndatetime(now());\n// output: 2016.03.02T20:51:10\n\ndatetime(2012.01M)\n// output: 2012.01.01T00:00:00\n```\n\nRelated functions: [date](https://docs.dolphindb.com/en/Functions/d/date.html), [second](https://docs.dolphindb.com/en/Functions/s/second.html), [minute](https://docs.dolphindb.com/en/Functions/m/minute.html), [month](https://docs.dolphindb.com/en/Functions/m/month.html), [hour](https://docs.dolphindb.com/en/Functions/h/hour.html), [year](https://docs.dolphindb.com/en/Functions/y/year.html)\n"
    },
    "datetimeParse": {
        "url": "https://docs.dolphindb.com/en/Functions/d/datetimeParse.html",
        "signatures": [
            {
                "full": "temporalParse(X, format)",
                "name": "temporalParse",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "format",
                        "name": "format"
                    }
                ]
            }
        ],
        "markdown": "### [datetimeParse](https://docs.dolphindb.com/en/Functions/d/datetimeParse.html)\n\nAlias for [temporalParse](https://docs.dolphindb.com/en/Functions/t/temporalParse.html)\n\n\nDocumentation for the `temporalParse` function:\n### [temporalParse](https://docs.dolphindb.com/en/Functions/t/temporalParse.html)\n\n\n\n#### Syntax\n\ntemporalParse(X, format)\n\nAlias: datetimeParse\n\n#### Arguments\n\n**X** is a string scalar/vector to be converted to temporal data types.\n\n**format** is a string indicating a temporal format.\n\n#### Details\n\nConvert a string with specified format to a DolphinDB temporal data type. Return NULL if it cannot decide on the data type.\n\nDolphinDB has the following temporal formats:\n\n| Format    | Meaning          | Range of value                              |\n| --------- | ---------------- | ------------------------------------------- |\n| yyyy      | year (4 digits)  | 1000-9999                                   |\n| yy        | year (2 digits)  | 00-99. (00-39: 2000-2039; 40-99: 1940-1999) |\n| MM        | month in year    | 1-12                                        |\n| MMM       | month in year    | JAN, FEB, ... DEC (case insensitive)        |\n| dd        | day in month     | 1-31                                        |\n| HH        | hour in day      | 0-23                                        |\n| hh        | hour in AM/PM    | 0-11                                        |\n| mm        | minute in hour   | 0-59                                        |\n| ss        | second in minute | 0-59                                        |\n| aa        | AM/PM marker     | AM, PM. (case-insensitive)                  |\n| SSS       | millisecond      | 0-999                                       |\n| nnnnnn    | microsecond      | 0-999999                                    |\n| nnnnnnnnn | nanosecond       | 0-999999999                                 |\n\nThe parameter format of the *temporalParse* function has 2 types of representation:\n\n* **With deliminator(s)**\n\nAny symbol or character is treated as a deliminator except the characters that are used to express a temporal format: y, M, d, H, h, m, s, a, S, and n. A deliminator in the parameter *format* should be identical as the deliminator in the input string.\n\n```\ntemporalParse(\"14-02-2018\",\"dd-MM-yyyy\");\n// output\n2018.02.14\n\ntemporalParse(\"14-02-2018\",\"dd/MM/yyyy\");\n// output\n00d\n\ntemporalParse(\"14//02//2018\",\"dd//MM//yyyy\");\n// output\n2018.02.14\n\ntemporalParse(\"14//02//2018\",\"dd/MM/yyyy\");\n// output\n00d\n\ntemporalParse(\"14//02//2018\",\"dd..MM..yyyy\");\n// output\n00d\n```\n\nWe can simplify the formats by using a single letter between deliminators for the parameter *format*. For example, we can use the format \"y/M/d\" instead of \"yyyy/MM/dd\" for \"2018/01/16\". As \"y\" may mean both \"yyyy\" and \"yy\", for this case the system decides on the format based on the number of digits between deliminators.\n\n```\ntemporalParse(\"14-02-18\",\"d-M-y\");\n// output\n2018.02.14\n\ntemporalParse(\"2018/2/6 02:33:01 PM\",\"y/M/d h:m:s a\");\n// output\n2018.02.06T14:33:01\n```\n\n\"MMM\",\"SSS\", \"nnnnnn\" and \"nnnnnnnnn\", however, cannot be simplified to a single letter.\n\n```\ntemporalParse(\"02-FEB-2018\",\"d-MMM-y\");\n// output\n2018.02.02\n\ntemporalParse(\"02-FEB-2018\",\"d-M-y\");\n// output\n00d\n\ntemporalParse(\"13:30:10.001\",\"H:m:s.SSS\");\n// output\n13:30:10.001\n\ntemporalParse(\"13:30:10.001\",\"H:m:s.S\");\n// output\nInvalid temporal format: 'H:m:s.S'. Millisecond (S) must have three digits.\n\ntemporalParse(\"13:30:10.008001\",\"H:m:s.nnnnnn\");\n// output\n13:30:10.008001000\n\ntemporalParse(\"13:30:10.008001\",\"H:m:s.n\");\n// output\nInvalid temporal format: 'H:m:s.n'. Nanosecond (n) must have six or nine digits.\n```\n\nThe `temporalParse` function is very flexible in interpreting the numbers between deliminators in the input string.\n\n```\ntemporalParse(\"2-4-18\",\"d-M-y\");\n// output\n2018.04.02\n\ntemporalParse(\"2-19-6\",\"H-m-s\");\n// output\n02:19:06\n\ntemporalParse(\"002-019-006\",\"H-m-s\");\n// output\n02:19:06\n```\n\nFor millisecond, microsecond and nanosecond, however, the corresponding number of digits in the input string must be 3, 6 and 9 respectively.\n\n```\ntemporalParse(\"2018/2/6 13:30:10.001\",\"y/M/d H:m:s.SSS\");\n// output\n2018.02.06T13:30:10.001\n\ntemporalParse(\"2018/2/6 13:30:10.01\",\"y/M/d H:m:s.SSS\");\n// output\n00T\n\ntemporalParse(\"2018/2/6 13:30:10.000001\",\"y/M/d H:m:s.nnnnnn\");\n// output\n2018.02.06T13:30:10.000001000\n\ntemporalParse(\"2018/2/6 13:30:10.0000010\",\"y/M/d H:m:s.nnnnnn\");\n// output\n00N\n```\n\nIf a character that is used to express a temporal format (y, M, d, H, h, m, s, a, S, n) appears in the input string as a deliminator, we need to use \"\" before the character in parameter *format*.\n\n```\ntemporalParse(\"2013a02\", \"y\\\\aM\");\n// output\n2013.02M\n\ntemporalParse(\"2013an02\", \"y\\\\a\\\\nM\");\n// output\n2013.02M\n```\n\n* **Without deliminators**\n\nFor this reprensentation, the parameter *format* must be composed of the formats in the temporal formats table. We cannot use a single letter to represent a format in the temporal format table.\n\n```\ntemporalParse(\"20180214\",\"yyyyMMdd\");\n// output\n2018.02.14\n\ntemporalParse(\"122506\",\"MMddyy\");\n// output\n2006.12.25\n\ntemporalParse(\"155950\",\"HHmmss\");\n// output\n15:59:50\n\ntemporalParse(\"035901PM\",\"hhmmssaa\");\n// output\n15:59:01\n\ntemporalParse(\"02062018155956001000001\",\"MMddyyyyHHmmssnnnnnnnnn\");\n// output\n2018.02.06T15:59:56.001000001\n```\n"
    },
    "dayOfMonth": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dayOfMonth.html",
        "signatures": [
            {
                "full": "dayOfMonth(X)",
                "name": "dayOfMonth",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [dayOfMonth](https://docs.dolphindb.com/en/Functions/d/dayOfMonth.html)\n\n\n\n#### Syntax\n\ndayOfMonth(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nReturn the day of the month for each element in X.\n\n**Return value**: an integer\n\n#### Examples\n\n```\ndayOfMonth(2011.01.01);\n// output\n1\n\ndayOfMonth([2012.06.12T12:30:00,2012.07.28T12:35:00]);\n// output\n[12,28]\n```\n\nRelated functions: [dayOfYear](https://docs.dolphindb.com/en/Functions/d/dayOfYear.html), [quarterOfYear](https://docs.dolphindb.com/en/Functions/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.com/en/Functions/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.com/en/Functions/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.com/en/Functions/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.com/en/Functions/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.com/en/Functions/m/millisecond.html), [microsecond](https://docs.dolphindb.com/en/Functions/m/microsecond.html), [nanosecond](https://docs.dolphindb.com/en/Functions/n/nanosecond.html)\n"
    },
    "dayOfWeek": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dayOfWeek.html",
        "signatures": [
            {
                "full": "dayOfWeek(X)",
                "name": "dayOfWeek",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [dayOfWeek](https://docs.dolphindb.com/en/Functions/d/dayOfWeek.html)\n\n\n\n#### Syntax\n\ndayOfWeek(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATETIME, DATEHOUR, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nReturn which day of the week is *X*.\n\n**Return value**: an integer from 0 to 6, where 0 means Monday, .., 6 means Sunday.\n\n#### Examples\n\n```\ndayOfWeek(2012.12.05);\n// output\n2\n\ndayOfWeek 2013.05.23T12:00:00;\n// output\n3\n\ndayOfWeek(2014.01.11T23:04:28.113);\n// output\n5\n\ndayOfWeek(2012.12.05 2012.12.06 2013.01.05);\n// output\n[2,3,4]\n```\n"
    },
    "dayOfYear": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dayOfYear.html",
        "signatures": [
            {
                "full": "dayOfYear(X)",
                "name": "dayOfYear",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [dayOfYear](https://docs.dolphindb.com/en/Functions/d/dayOfYear.html)\n\n\n\n#### Syntax\n\ndayOfYear(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nReturn the day of the year for each element in *X*.\n\n**Return value**: an integer\n\n#### Examples\n\n```\ndayOfYear(2011.01.01);\n// output\n1\n\ndayOfYear([2011.12.31,2012.12.31]);\n// output\n[365,366]\n\ndayOfYear([2012.06.12T12:30:00,2012.07.12T12:35:00]);\n// output\n[164,194]\n```\n\nRelated functions: [dayOfMonth](https://docs.dolphindb.com/en/Functions/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.com/en/Functions/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.com/en/Functions/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.com/en/Functions/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.com/en/Functions/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.com/en/Functions/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.com/en/Functions/m/millisecond.html), [microsecond](https://docs.dolphindb.com/en/Functions/m/microsecond.html), [nanosecond](https://docs.dolphindb.com/en/Functions/n/nanosecond.html)\n"
    },
    "daysInMonth": {
        "url": "https://docs.dolphindb.com/en/Functions/d/daysInMonth.html",
        "signatures": [
            {
                "full": "daysInMonth(X)",
                "name": "daysInMonth",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [daysInMonth](https://docs.dolphindb.com/en/Functions/d/daysInMonth.html)\n\n\n\n#### Syntax\n\ndaysInMonth(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nReturn the number of days in the month for each element in *X*.\n\n**Return value**: an integer\n\n#### Examples\n\n```\ndaysInMonth(2012.06.12T12:30:00);\n// output\n30\n\ndaysInMonth([2012.02.01,2013.12.05]);\n// output\n[29,31]\n```\n"
    },
    "decimal128": {
        "url": "https://docs.dolphindb.com/en/Functions/d/decimal128.html",
        "signatures": [
            {
                "full": "decimal128(X, scale)",
                "name": "decimal128",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    }
                ]
            }
        ],
        "markdown": "### [decimal128](https://docs.dolphindb.com/en/Functions/d/decimal128.html)\n\n\n\n#### Syntax\n\ndecimal128(X, scale)\n\n#### Arguments\n\n**X** is a scalar/vector of Integral, Floating, or STRING type.\n\n**scale** is an integer in \\[0,38] that determines the number of digits to the right of the decimal point.\n\n#### Details\n\nConvert the input values into DECIMAL128.\n\n#### Examples\n\n```\na=decimal128(142, 2)\na\n// output\n142.00\n\nb=decimal128(1\\7, 6)\nb\n// output\n0.142857\n\na+b\n// output\n142.142857\n\na*b\n// output\n20.28569400\n\ndecimal128(\"3.1415926535\", 4)\n// output\n3.1416\n\n// All elements of a DECIMAL vector must be of the same type and scale\nd1=[1.23$DECIMAL128(4), 3$DECIMAL128(4), 3.14$DECIMAL128(4)];\n// output\n[1.2300,3.0000,3.1400]\ntypestr(d1)\n// output\nFAST DECIMAL128 VECTOR\n\n// If the elements are of different scales, a tuple is created\nd2=[1.23$DECIMAL128(4), 3$DECIMAL128(4), 3.14$DECIMAL128(3)];\n// output\n(1.2300,3.0000,3.140)\ntypestr(d2)\n// output\nANY VECTOR\n```\n"
    },
    "decimal32": {
        "url": "https://docs.dolphindb.com/en/Functions/d/decimal32.html",
        "signatures": [
            {
                "full": "decimal32(X, scale)",
                "name": "decimal32",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    }
                ]
            }
        ],
        "markdown": "### [decimal32](https://docs.dolphindb.com/en/Functions/d/decimal32.html)\n\n\n\n#### Syntax\n\ndecimal32(X, scale)\n\n#### Arguments\n\n**X** is a scalar/vector of Integral, Floating, or STRING type.\n\n**scale** is an integer in \\[0,9] that determines the number of digits to the right of the decimal point.\n\n#### Details\n\nConvert the input values into DECIMAL32 type.\n\n#### Examples\n\n```\na=decimal32(142, 2)\na\n// output\n142.00\n\nb=decimal32(1\\7, 6)\nb\n// output\n0.142857\n\na+b\n// output\n142.142857\n\na*b\n// output\n20.28569400\n\ndecimal32(\"3.1415926535\", 4)\n// output\n3.1415\n\n// the elements of a DECIMAL vector must be of the same decimal type and scale\nd1=[1.23$DECIMAL32(4), 3$DECIMAL32(4), 3.14$DECIMAL32(4)];\n// output\n[1.2300,3.0000,3.1400]\ntypestr(d1)\n// output\nFAST DECIMAL32 VECTOR\n\nd2=[1.23$DECIMAL32(4), 3$DECIMAL32(4), 3.14$DECIMAL32(3)];\n// output\n(1.2300,3.0000,3.140)\ntypestr(d2)\n// output\nANY VECTOR\n```\n\n**Note:** When converting data of STRING/SYMBOL type into DECIMAL, there has been a modification in the way the decimal part exceeding the scale is handled since version 2.00.10.\n\n* Before version 2.00.10, the decimal part is truncated;\n\n* Starting from version 2.00.10, the decimal part is rounded.\n\n```\nsymbol([\"1.341\", \"4.5677\"])$DECIMAL32(2)\n//before version 2.00.10, the output is:\n[1.34,4.56]\n//starting from version 2.00.10, the output turns to:\n[1.34,4.57]\n```\n"
    },
    "decimal64": {
        "url": "https://docs.dolphindb.com/en/Functions/d/decimal64.html",
        "signatures": [
            {
                "full": "decimal64(X, scale)",
                "name": "decimal64",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    }
                ]
            }
        ],
        "markdown": "### [decimal64](https://docs.dolphindb.com/en/Functions/d/decimal64.html)\n\n\n\n#### Syntax\n\ndecimal64(X, scale)\n\n#### Arguments\n\n**X** is a scalar/vector of Integral, Floating, or STRING type.\n\n**scale** is an integer in \\[0,18] that determines the number of digits to the right of the decimal point.\n\n#### Details\n\nConvert the input values into DECIMAL64.\n\n#### Examples\n\n```\na=decimal64(142, 2)\na\n// output\n142.00\n\nb=decimal64(1\\7, 6)\nb\n// output\n0.142857\n\na+b\n// output\n142.142857\n\na*b\n// output\n20.28569400\n\ndecimal64(\"3.1415926535\", 4)\n// output\n3.1415\n\n// the elements of a DECIMAL vector must be of the same decimal type and scale\nd1=[1.23$DECIMAL64(4), 3$DECIMAL64(4), 3.14$DECIMAL64(4)];\n// output\n[1.2300,3.0000,3.1400]\ntypestr(d1)\n// output\nFAST DECIMAL64 VECTOR\n\nd2=[1.23$DECIMAL64(4), 3$DECIMAL64(4), 3.14$DECIMAL64(3)];\n// output\n(1.2300,3.0000,3.140)\ntypestr(d2)\n// output\nANY VECTOR\n```\n\n**Note:** When converting data of STRING/SYMBOL type into DECIMAL, there has been a modification in the way the decimal part exceeding the scale is handled since version 2.00.10.\n\n* Before version 2.00.10, the decimal part is truncated;\n\n* Starting from version 2.00.10, the decimal part is rounded.\n\n```\nsymbol([\"1.341\", \"4.5677\"])$DECIMAL64(2)\n//before version 2.00.10, the output is:\n[1.34,4.56]\n//starting from version 2.00.10, the output turns to:\n[1.34,4.57]\n```\n"
    },
    "decimalFormat": {
        "url": "https://docs.dolphindb.com/en/Functions/d/decimalFormat.html",
        "signatures": [
            {
                "full": "decimalFormat(X, format)",
                "name": "decimalFormat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "format",
                        "name": "format"
                    }
                ]
            }
        ],
        "markdown": "### [decimalFormat](https://docs.dolphindb.com/en/Functions/d/decimalFormat.html)\n\n\n\n#### Syntax\n\ndecimalFormat(X, format)\n\n#### Arguments\n\n**X** is a scalar/vector of Integral or Floating type.\n\n**format** is a string indicating the format to apply to *X*.\n\n#### Details\n\nApply a specified *format* to the given object.\n\n**Return value**: a STRING scalar/vector.\n\n| Symbol | Meaning                                                                       | Notes  |\n| ------ | ----------------------------------------------------------------------------- | ------ |\n| 0      | mandatory digit                                                               | note 1 |\n| #      | optional digit                                                                | note 2 |\n| .      | decimal point                                                                 |        |\n| %      | percent sign                                                                  | note 3 |\n| E      | separates mantissa and exponent in scientific notation.                       | note 4 |\n| ,      | grouping separator                                                            | note 5 |\n| ;      | separates the format for positive numbers and the format for negative numbers | note 6 |\n\n* Note 1: The number of 0s before the decimal point means the minimum number of digits before the decimal point. In comparison, the number of 0s after the decimal point means the number of digits after the decimal point.\n\n  ```\n  decimalFormat(123,\"0\");\n  // output\n  123\n\n  decimalFormat(123,\"00000\");\n  // output\n  00123\n\n  decimalFormat(123.45,\"0\");\n  // output\n  123\n\n  decimalFormat(123.45,\"0.0\");\n  // output\n  123.5\n\n  decimalFormat(123.45,\"0.000\");\n  // output\n  123.450\n\n  decimalFormat(123.45, \".0\");\n  // output\n  123.5\n\n  decimalFormat(0.45, \".0\");\n  // output\n  .5\n  ```\n\n* Note 2: If 0s and #s are used together after the decimal point, 0s must appear before #s.\n\n  ```\n  decimalFormat(123.45,\"0.#\");\n  // output\n  123.5\n\n  decimalFormat(123.45,\"0.###\");\n  // output\n  123.45\n\n  decimalFormat(123.456,\"0.000###\");\n  // output\n  123.456\n\n  decimalFormat(123.456789110,\"0.000###\");\n  // output\n  123.456789\n\n  decimalFormat(0.345, \".##\");\n  // output\n  .35\n  ```\n\n* Note 3: % is always at the end of a format. % and E cannot both appear in a format.\n\n  ```\n  decimalFormat(0.125,\"0.00%\");\n  // output\n  12.50%\n\n  decimalFormat(0.125, \"#.##%\");\n  // output\n  12.5%\n\n  decimalFormat(0.12567,\"#.##%\");\n  // output\n  12.57%\n  ```\n\n* Note 4: \"E\" is followed by at least one 0 and 0s only.\n\n  ```\n  decimalFormat(1234567.89,\"0.##E00\");\n  // output\n  1.23E06\n\n  decimalFormat(0.0000000000123456789,\"0.000E0\");\n  // output\n  1.235E-11\n  ```\n\n* Note 5: The grouping separator may only appear at most once in the parameter *format*. The number of digits between the grouping separator and the decimal point (if the decimal point is used) or the end of the format (if the decimal point is not used) determines the number of digits between grouping separators in the result.\n\n  ```\n  decimalFormat(123456789,\"#,###\");\n  // output\n  123,456,789\n\n  decimalFormat(123456789.166,\"#,###.##\");\n  // output\n  123,456,789.17\n\n  decimalFormat(123456789.166,\"0,000.00\");\n  // output\n  123,456,789.17\n  ```\n\n* Note 6: If we prefer to apply different formats to an object depending on whether it is positive or negative, we can use \";\" to seperate the 2 formats.\n\n  ```\n  decimalFormat(123.456,\"0.00#E00;(0.00#E00)\");\n  // output\n  1.235E02\n\n  decimalFormat(-123.456,\"0.00#E00;(0.00#E00)\");\n  // output\n  (1.235E02)\n  ```\n"
    },
    "decimalMultiply": {
        "url": "https://docs.dolphindb.com/en/Functions/d/decimalMultiply.html",
        "signatures": [
            {
                "full": "decimalMultiply(X, Y, scale)",
                "name": "decimalMultiply",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    }
                ]
            }
        ],
        "markdown": "### [decimalMultiply](https://docs.dolphindb.com/en/Functions/d/decimalMultiply.html)\n\n\n\n#### Syntax\n\ndecimalMultiply(X, Y, scale)\n\n#### Arguments\n\n**X** and **Y** can be scalar or vector, and at least one argument is of DECIMAL type.\n\n**scale** is a non-negative integer indicating the decimal places to be retained in the result.\n\n#### Details\n\nThe function multiplies Decimals. Compared with the [mul](https://docs.dolphindb.com/en/Functions/m/mul.html) function or operator [\\*](https://docs.dolphindb.com/en/Programming/Operators/OperatorReferences/mul.html), the function can set the decimal places of the result with *scale*.\n\nNote: In the following situations, the specified scale does not take effect and the function is equivalent to operator `*`.\n\n* Only one argument is of DECIMAL type (with scale S), and the specified *scale* is not equal to S.\n* *X* and *Y* are both of DECIMAL type (with scale S1 and S2, respectively), and the specified *scale* is smaller than `min(S1, S2)` or greater than `(S1+S2)`.\n* One argument is a floating-point number.\n\nFor the first two situations, the function return a DECIMAL type result, and for the third situation it returns a result of DOUBLE type.\n\n#### Examples\n\n```\na = decimal32(`1.235, 3);\nb = decimal32(`7.5689, 4);\nc=decimalMultiply(a, b, 5)\n// output\n9.34759\n\ntypestr(c)\n// output\nDECIMAL32\n\ndecimalMultiply(a, b, 2)   // As scale is smaller than min(3,4), the operation is equivalent to a*b.\n// output\n9.3475915\n\nb=float(`7.5689)\nc=decimalMultiply(a, b, 5)   // As b is a floating-point number, the operation is equivalent to a*b and returns a result of DOUBLE type.\n// output\n9.3475916337\ntypestr(c)\n// output\nDOUBLE\n```\n\nIf the calculation result of a multiplication operation (`*`) or decimalMultiply overflows, it is automatically converted to type with higher precision. If the conversion fails, an exception will be thrown.\n\n```\nx = decimal32(1\\7, 8)\ny = decimal32(1\\6, 8)\nz = x * y\nz\n// output\n0.0238095223809524\ntypestr z\n// output\nDECIMAL64\n\nz = decimalMultiply(x, y, 8)\nz\n// output\n0.02380952\ntypestr z\n// output\nDECIMAL64\n\nx = decimal128(1\\7, 35)\ny = decimal128(1\\6, 35)\nx*y\nx * y => Scale out of bound (valid range: [0, 38], but get: 70)\n\ndecimalMultiply(x, y, 35)\ndecimalMultiply(x, y, 35) => Decimal math overflow\n```\n\nWhen X or Y is a vector:\n\n```\nx = [decimal32(3.213312, 3), decimal32(3.1435332, 3), decimal32(3.54321, 3)]\ny = 2.1\ndecimalMultiply(x, y, 5)\n// output\n[6.7473,6.6003,7.440300000000001]\n\nx = [decimal32(3.213312, 3), decimal32(3.1435332, 3), decimal32(3.54321, 3)]\ny = [decimal64(4.312412, 3), decimal64(4.53231, 3), decimal64(4.31258, 3)]\ndecimalMultiply(x, y, 5)\n// output\n[13.85445,14.24407,15.27741]\n```\n"
    },
    "decodeShortGenomeSeq": {
        "url": "https://docs.dolphindb.com/en/Functions/d/decodeShortGenomeSeq.html",
        "signatures": [
            {
                "full": "decodeShortGenomeSeq(X)",
                "name": "decodeShortGenomeSeq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [decodeShortGenomeSeq](https://docs.dolphindb.com/en/Functions/d/decodeShortGenomeSeq.html)\n\n#### Syntax\n\ndecodeShortGenomeSeq(X)\n\nAlias: decodeSGS\n\n#### Arguments\n\n**X** is an integral scalar/vector.\n\n#### Details\n\nDecode the DNA sequences which have been encoded with `encodeShortGenomeSeg`.\n\n**Return Value**: a STRING scalar or vector\n\n#### Examples\n\n```\na=encodeShortGenomeSeq(\"TCGATCG\")\ndecodeShortGenomeSeq(a)\n// output\n\"TCGATCG\"\n\nb=encodeShortGenomeSeq(\"TCGATCG\" \"TCGATCGCCC\")\ndecodeShortGenomeSeq(b)\n// output\n[\"TCGATCG\",\"TCGATCGCCC\"]\n    \n// When the input is empty, an empty string is returned.\ndecodeShortGenomeSeq(int(NULL))\n// output\n\"\"\n    \n// encodeShortGenomeSeq returns NULL as the input exceeds 28 characters after \"TCGATCG\" is repeated 5 times. As a result, when decoding it, an empty string is returned.\nc=encodeShortGenomeSeq(repeat(\"TCGATCG\" \"TCGAT\", 5))\ndecodeShortGenomeSeq(c)\n// output\n[,\"TCGATTCGATTCGATTCGATTCGAT\"]     \n```\n\nRelated functions: [encodeShortGenomeSeq](https://docs.dolphindb.com/en/Functions/e/encodeShortGenomeSeq.html), [genShortGenomeSeq](https://docs.dolphindb.com/en/Functions/g/genShortGenomeSeq.html)\n\n"
    },
    "decompress": {
        "url": "https://docs.dolphindb.com/en/Functions/d/decompress.html",
        "signatures": [
            {
                "full": "decompress(X)",
                "name": "decompress",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [decompress](https://docs.dolphindb.com/en/Functions/d/decompress.html)\n\n\n\n#### Syntax\n\ndecompress(X)\n\n#### Arguments\n\n**X** is a compressed vector or a table.\n\n#### Details\n\nDecompress a compressed vector or a table.\n\n#### Examples\n\n```\nx=1..100000000\ny=compress(x, \"delta\");\n\ny.typestr();\n// output\nHUGE COMPRESSED VECTOR\n\nz=decompress(y);\nz.size();\n// output\n100000000\n```\n\nRelated function: [compress](https://docs.dolphindb.com/en/Functions/c/compress.html)\n"
    },
    "defined": {
        "url": "https://docs.dolphindb.com/en/Functions/d/defined.html",
        "signatures": [
            {
                "full": "defined(names, [type=VAR])",
                "name": "defined",
                "parameters": [
                    {
                        "full": "names",
                        "name": "names"
                    },
                    {
                        "full": "[type=VAR]",
                        "name": "type",
                        "optional": true,
                        "default": "VAR"
                    }
                ]
            }
        ],
        "markdown": "### [defined](https://docs.dolphindb.com/en/Functions/d/defined.html)\n\n\n\n#### Syntax\n\ndefined(names, \\[type=VAR])\n\n#### Arguments\n\n**names** is a STRING scalar/vector indicating object name(s).\n\n**type** (optional) can be VAR (variable, default), SHARED (shared variable) or DEF (function definitions).\n\n#### Details\n\nReturn a scalar/vector indicating whether each element of names is defined.\n\n#### Examples\n\n```\nx=10\ny=20\ndef f(a){return a+1}\nshare table(1..3 as x, 4..6 as y) as t1;\n\ndefined([\"x\",\"y\",\"f\",`t1]);\n// output\n[1,1,0,0]\n\ndefined([\"x\",\"y\",\"f\",`t1], DEF);\n// output\n[0,0,1,0]\n\ndefined([\"x\",\"y\",\"f\",`t1], SHARED);\n// output\n[0,0,0,1]\n```\n"
    },
    "defs": {
        "url": "https://docs.dolphindb.com/en/Functions/d/defs.html",
        "signatures": [
            {
                "full": "defs([X])",
                "name": "defs",
                "parameters": [
                    {
                        "full": "[X]",
                        "name": "X",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [defs](https://docs.dolphindb.com/en/Functions/d/defs.html)\n\n\n\n#### Syntax\n\ndefs(\\[X])\n\n#### Arguments\n\n**X** is a string. It supports wildcard symbols \"%\" and \"?\". \"%\" means 0, 1 or multiple characters and \"?\" means 1 character.\n\n#### Details\n\n* If *X* is not specified, return all functions in the system as a table.\n* If *X* is specified, return all functions with names consistent with the pattern of *X*.\n\n#### Examples\n\n```\ndefs();\n```\n\n| name    | isCommand | userDefined | minParamCount | maxParamCount | syntax      |\n| ------- | --------- | ----------- | ------------- | ------------- | ----------- |\n| !=\\_2   | 0         | 0           | 2             | 2             | (X, Y)      |\n| !\\_1    | 0         | 0           | 1             | 1             | (X)         |\n| $\\_2    | 0         | 0           | 2             | 2             | (obj, type) |\n| %\\_2    | 0         | 0           | 2             | 2             | (X, Y)      |\n| &&\\_2   | 0         | 0           | 2             | 2             | (X, Y)      |\n| &\\_2    | 0         | 0           | 2             | 2             | (X, Y)      |\n| \\*\\*\\_2 | 0         | 0           | 2             | 2             | (X, Y)      |\n| \\*\\_2   | 0         | 0           | 2             | 2             | (X, Y)      |\n| +\\_2    | 0         | 0           | 2             | 2             | (X, Y)      |\n| -\\_1    | 0         | 0           | 1             | 1             | (X)         |\n| ...     |           |             |               |               |             |\n\n```\ntypestr defs();\n// output\nIN-MEMORY TABLE;\n\nselect * from defs() where name like \"bit%\";\n```\n\n| name   | isCommand | userDefined | minParamCount | maxParamCount | syntax |\n| ------ | --------- | ----------- | ------------- | ------------- | ------ |\n| bitAnd | 0         | 0           | 2             | 2             | (X, Y) |\n| bitNot | 0         | 0           | 1             | 1             | (X)    |\n| bitOr  | 0         | 0           | 2             | 2             | (X, Y) |\n| bitXor | 0         | 0           | 2             | 2             | (X, Y) |\n\n```\ndefs(\"bit%\");\n```\n\n| name   | isCommand | userDefined | minParamCount | maxParamCount | syntax |\n| ------ | --------- | ----------- | ------------- | ------------- | ------ |\n| bitAnd | 0         | 0           | 2             | 2             | (X, Y) |\n| bitNot | 0         | 0           | 1             | 1             | (X)    |\n| bitOr  | 0         | 0           | 2             | 2             | (X, Y) |\n| bitXor | 0         | 0           | 2             | 2             | (X, Y) |\n\n```\ndefs(\"%sin\");\n```\n\n| name | isCommand | userDefined | minParamCount | maxParamCount | syntax |\n| ---- | --------- | ----------- | ------------- | ------------- | ------ |\n| asin | 0         | 0           | 1             | 1             | (X)    |\n| sin  | 0         | 0           | 1             | 1             | (X)    |\n\n```\ndefs(\"?sin\");\n```\n\n| name | isCommand | userDefined | minParamCount | maxParamCount | syntax |\n| ---- | --------- | ----------- | ------------- | ------------- | ------ |\n| asin | 0         | 0           | 1             | 1             | (X)    |\n"
    },
    "deg2rad": {
        "url": "https://docs.dolphindb.com/en/Functions/d/deg2rad.html",
        "signatures": [
            {
                "full": "deg2rad(X)",
                "name": "deg2rad",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [deg2rad](https://docs.dolphindb.com/en/Functions/d/deg2rad.html)\n\n\n\n#### Syntax\n\ndeg2rad(X)\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n#### Details\n\nConvert angle units from degrees to radians for each element of *X*.\n\n#### Examples\n\n```\ndeg2rad 45 90 180 360;\n// output\n[0.785398,1.570796,3.141593,6.283185]\n```\n"
    },
    "deleteChunkMetaOnMasterById": {
        "url": "https://docs.dolphindb.com/en/Functions/d/deleteChunkMetaOnMasterById.html",
        "signatures": [
            {
                "full": "deleteChunkMetaOnMasterById(chunkPath, chunkId)",
                "name": "deleteChunkMetaOnMasterById",
                "parameters": [
                    {
                        "full": "chunkPath",
                        "name": "chunkPath"
                    },
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    }
                ]
            }
        ],
        "markdown": "### [deleteChunkMetaOnMasterById](https://docs.dolphindb.com/en/Functions/d/deleteChunkMetaOnMasterById.html)\n\n\n\n#### Syntax\n\ndeleteChunkMetaOnMasterById(chunkPath, chunkId)\n\n#### Arguments\n\n**chunkPath** is a string indicating the path to the chunk.\n\n**chunkId** is a string indicating the chunk ID.\n\n#### Details\n\nDelete the metadata of the specified chunk on the controller based on the path and ID.\n\n**Note**: This function can only be executed by administrators on the controller.\n\n#### Examples\n\n```\n`deleteChunkMetaOnMasterById(chunkPath=\"/olap_value/8/40o\", chunkId=\"11d45d2d-a995-7c97-c041-32362f3400d7\")`\n```\n"
    },
    "deleteGroup": {
        "url": "https://docs.dolphindb.com/en/Functions/d/deleteGroup.html",
        "signatures": [
            {
                "full": "deleteGroup(groupName)",
                "name": "deleteGroup",
                "parameters": [
                    {
                        "full": "groupName",
                        "name": "groupName"
                    }
                ]
            }
        ],
        "markdown": "### [deleteGroup](https://docs.dolphindb.com/en/Functions/d/deleteGroup.html)\n\n\n\n#### Syntax\n\ndeleteGroup(groupName)\n\n#### Arguments\n\n**groupName** is a string indicating a group name.\n\n#### Details\n\nDelete a group. It can only be executed by an administrator.\n\n#### Examples\n\n```\ndeleteGroup(`Production);\n```\n"
    },
    "deleteGroupMember": {
        "url": "https://docs.dolphindb.com/en/Functions/d/deleteGroupMember.html",
        "signatures": [
            {
                "full": "deleteGroupMember(userIds, groupIds)",
                "name": "deleteGroupMember",
                "parameters": [
                    {
                        "full": "userIds",
                        "name": "userIds"
                    },
                    {
                        "full": "groupIds",
                        "name": "groupIds"
                    }
                ]
            }
        ],
        "markdown": "### [deleteGroupMember](https://docs.dolphindb.com/en/Functions/d/deleteGroupMember.html)\n\n\n\n#### Syntax\n\ndeleteGroupMember(userIds, groupIds)\n\n#### Arguments\n\n**userIds** is a STRING scalar/vector indicating user name(s).\n\n**groupIds** is a STRING scalar/vector indicating group name(s).\n\n*userIds* and *groupIds* cannot both be vectors.\n\n#### Details\n\nRemove a user from a group or multiple groups, or remove multiple users from a group.\n\nIt can only be executed by an administrator.\n\n#### Examples\n\n```\ndeleteGroupMember(`AlexEdwards`ElizabethRoberts, `production);\n```\n"
    },
    "deleteReplicas": {
        "url": "https://docs.dolphindb.com/en/Functions/d/deleteReplicas.html",
        "signatures": [
            {
                "full": "deleteReplicas(chunkId, nodeAlias)",
                "name": "deleteReplicas",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    },
                    {
                        "full": "nodeAlias",
                        "name": "nodeAlias"
                    }
                ]
            }
        ],
        "markdown": "### [deleteReplicas](https://docs.dolphindb.com/en/Functions/d/deleteReplicas.html)\n\n\n\n#### Syntax\n\ndeleteReplicas(chunkId, nodeAlias)\n\n#### Arguments\n\n**chunkId** is a STRING scalar/vector indicating ID of chunks.\n\n**nodeAlias** is a string indicating the node alias.\n\n#### Details\n\nDelete replicas of one or multiple chunks from a node.\n\nThis command can only be executed by an administrator on a controller node.\n\n#### Examples\n\nDelete the replicas of all chunks on \"node1\".\n\n```\nchunkIds=exec chunkId from pnodeRun(getAllChunks) where node=\"node1\"\ndeleteReplicas(chunkIds,\"node1\");\n```\n"
    },
    "deleteRule": {
        "url": "https://docs.dolphindb.com/en/Functions/d/deleteRule.html",
        "signatures": [
            {
                "full": "deleteRule(engineName, key)",
                "name": "deleteRule",
                "parameters": [
                    {
                        "full": "engineName",
                        "name": "engineName"
                    },
                    {
                        "full": "key",
                        "name": "key"
                    }
                ]
            }
        ],
        "markdown": "### [deleteRule](https://docs.dolphindb.com/en/Functions/d/deleteRule.html)\n\n\n\n#### Syntax\n\ndeleteRule(engineName, key)\n\n#### Arguments\n\n**engineName**is a string indicating the engine name.\n\n**key**is a STRING or INT scalar indicating the key for the rule set to be deleted.\n\n#### Details\n\nIf the specified *key*already exists in the rule engine, delete the corresponding rule set. The default rule set cannot be deleted.\n\n**Return value**: true if successful, otherwise false.\n\n#### Examples\n\n```\nx = [1, 2, NULL]\ny = [ [ < value>1 > ], [ < price<2 >, < price>6 > ], [ < value*price>10 > ] ]\nruleSets = dict(x, y)\nnames = `sym`value`price`quatity\ntypes = [INT, DOUBLE, DOUBLE, DOUBLE]\ndummy = table(10:0, names, types)\noutputNames = `sym`value`price`rule\noutputTypes = [INT, DOUBLE, DOUBLE, BOOL[]]\noutputTable = table(10:0, outputNames, outputTypes)\ntest = createRuleEngine(\"ruleEngineTest\",ruleSets,dummy ,`sym`value`price, outputTable,  \"all\",`sym)\n\ntest.append!(table(1 as sym, 6 as value, 1 as price, 8 as quatity))\n// outputTable\n1\t6\t1\t[true]\n\n// delete the rule set for sym=1 and the default rule set will be applied to sym=1.\ndeleteRule(\"ruleEngineTest\",1)\ntest.append!(table(1 as sym, 6 as value, 1 as price, 8 as quatity))\n// outputTable\n1\t6\t1\t[false]\n```\n"
    },
    "deleteScheduledJob": {
        "url": "https://docs.dolphindb.com/en/Functions/d/deleteScheduledJob.html",
        "signatures": [
            {
                "full": "deleteScheduledJob(jobId)",
                "name": "deleteScheduledJob",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    }
                ]
            }
        ],
        "markdown": "### [deleteScheduledJob](https://docs.dolphindb.com/en/Functions/d/deleteScheduledJob.html)\n\n\n\n#### Syntax\n\ndeleteScheduledJob(jobId)\n\n#### Arguments\n\n**jobId** is a string indicating a scheduled job ID.\n\n#### Details\n\nDelete a scheduled job. If the specified job ID doesn't exist, throw an exception.\n\n#### Examples\n\n```\ndeleteScheduledJob(`dailyJob1);\n```\n"
    },
    "deleteUser": {
        "url": "https://docs.dolphindb.com/en/Functions/d/deleteUser.html",
        "signatures": [
            {
                "full": "deleteUser(userId)",
                "name": "deleteUser",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    }
                ]
            }
        ],
        "markdown": "### [deleteUser](https://docs.dolphindb.com/en/Functions/d/deleteUser.html)\n\n\n\n#### Syntax\n\ndeleteUser(userId)\n\n#### Arguments\n\n**userId** a string indicating a user name.\n\n#### Details\n\nDelete a user. It removes the user from all the groups the user belongs to.\n\nIt can only be executed by an administrator.\n\n#### Examples\n\n```\ndeleteUser(`JohnSmith);\n```\n"
    },
    "deltas": {
        "url": "https://docs.dolphindb.com/en/Functions/d/deltas.html",
        "signatures": [
            {
                "full": "deltas(X, [n])",
                "name": "deltas",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[n]",
                        "name": "n",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [deltas](https://docs.dolphindb.com/en/Functions/d/deltas.html)\n\n\n\n#### Syntax\n\ndeltas(X, \\[n])\n\n#### Arguments\n\n**X** is a vector, matrix or table.\n\n**n** (optional) is an integer specifying the step to shift when comparing elements in *X*. The default value is 1, meaning to compare the current element with the adjacent element at left.\n\n#### Details\n\nFor each element *Xi* in *X*, return *Xi*-*Xi-n*, representing the differences between elements.\n\n**Return value**: A vector/matrix/table with the same shape as *X*.\n\n#### Examples\n\n```\nx=7 4 5 8 9;\ndeltas(x);\n// output: [,-3,1,3,1] \n\nx=NULL 1 2 NULL 3;\ndeltas(x);\n// output: [,,1,,]\n\nm=matrix(1 3 2 5 6, 0 8 NULL 7 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 0  |\n| 3  | 8  |\n| 2  |    |\n| 5  | 7  |\n| 6  | 6  |\n\n```\ndeltas(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n| 2  | 8  |\n| -1 |    |\n| 3  |    |\n| 1  | -1 |\n\nWhen *n* is a positive integer:\n\n```\nm=matrix(1 3 2 5 6, 0 8 NULL 7 6);\na=deltas(m,2)\na;\n```\n\n| 0 | 1  |\n| - | -- |\n|   |    |\n|   |    |\n| 1 |    |\n| 2 | -1 |\n| 4 |    |\n\nWhen n is a negative integer:\n\n```\nm = 3 4 6 9\nr2= deltas(m,-2)\nr2; \n// output: [-3,-5,,]\n```\n"
    },
    "dema": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dema.html",
        "signatures": [
            {
                "full": "dema(X, window)",
                "name": "dema",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [dema](https://docs.dolphindb.com/en/Functions/d/dema.html)\n\n\n\n#### Syntax\n\ndema(X, window)\n\nPlease see [TA-Lib Functions](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameter description and windowing logic.\n\n#### Details\n\nCalculate the Double Exponential Moving Average (dema) for *X* in a sliding window of the given length.\n\nThe formula is:\n\n![](https://docs.dolphindb.com/en/images/ema1.png)\n\n![](https://docs.dolphindb.com/en/images/dema.png)\n\n#### Examples\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\ndema(x,3);\n// output\n[,,,,12.091666666666668,11.689583333333335,11.266666666666665]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\ndema(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n| 12.0917 | 20.9444 |\n| 11.6896 | 14.6806 |\n| 11.2667 | 10.9444 |\n\nRelated functions: [ema](https://docs.dolphindb.com/en/Functions/e/ema.html), [tema](https://docs.dolphindb.com/en/Functions/t/tema.html)\n"
    },
    "demean": {
        "url": "https://docs.dolphindb.com/en/Functions/d/demean.html",
        "signatures": [
            {
                "full": "demean(X)",
                "name": "demean",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [demean](https://docs.dolphindb.com/en/Functions/d/demean.html)\n\n#### Syntax\n\ndemean(X)\n\n#### Arguments\n\n`X` is a numeric scalar/vector/matrix/table.\n\n#### Details\n\nCenter a dataset (zero-centering), and return an object of DOUBLE type with the same dimension as *X*. NULL values are ignored in the calculation.\n\n* If *X* is a vector, calculate X - avg(X);\n\n* If *X* is a matrix, perform calculations by columns;\n\n* If *X* is a table, perform calculations only for numeric columns.\n\n#### Examples\n\n```\nx = 1 NULL 2 3\ndemean(x)\n// output\n[-1,,0,1]\n\nv = 1 0 1 1 8 2 -4 0\ndemean(v)\n// output\n[-0.125,-1.125,-0.125,-0.125,6.875,0.875,-5.125,-1.125]\n```\n\n"
    },
    "denseRank": {
        "url": "https://docs.dolphindb.com/en/Functions/d/denseRank.html",
        "signatures": [
            {
                "full": "denseRank(X, [ascending=true],[ignoreNA=true], [percent=false])",
                "name": "denseRank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [denseRank](https://docs.dolphindb.com/en/Functions/d/denseRank.html)\n\n\n\n#### Syntax\n\ndenseRank(X, \\[ascending=true],\\[ignoreNA=true], \\[percent=false])\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n**ascending** (optional) is a Boolean value indicating whether to sort in ascending order. The default value is true.\n\n**ignoreNA** (optional) is a Boolean value indicating whether NULL values are ignored in ranking. The default value is true. If set to false, NULL is ranked as the minimum value.\n\n**percent** (optional) is a Boolean value, indicating whether to display the returned rankings in percentile form. The default value is false.\n\n#### Details\n\nIf *X* is a vector:\n\n* return the consecutive rank of each element in *X* based on the specified *ascending* order.\n\n* If *ignoreNA* = true, the NULL values are ignored in ranking and return NULL.\n\nIf *X* is a matrix, conduct the aforementioned calculation within each column of *X*. The result is a matrix with the same shape as *X*.\n\nUnlike `denseRank`, [rank](https://docs.dolphindb.com/en/Functions/r/rank.html) skips positions after equal rankings.\n\n#### Examples\n\n```\nx=1 5 5 6 8 8 9\nprint denseRank(x)\n// output\n[0,1,1,2,3,3,4]\n\ny=time(4 1 1 2)\nprint denseRank(y, ascending=false)\n// output\n[0,2,2,1]\nm = matrix(1 2 2 NULL, 0 0 0 1, 0 0 NULL 2)\ndenseRank(m, ignoreNA=false)\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 0  | 1  |\n| 2  | 0  | 1  |\n| 2  | 0  | 0  |\n| 0  | 1  | 2  |\n\n```\nt=table(`A`A`B`C`B`B`A`C`C as id,[4,1,NULL,1,2,4,5,0,-1] as val)\nselect id,val, denseRank(val) from t context by id\n```\n\n| id | val | denseRank\\_val |\n| -- | --- | -------------- |\n| A  | 4   | 1              |\n| A  | 1   | 0              |\n| A  | 5   | 2              |\n| B  |     |                |\n| B  | 2   | 0              |\n| B  | 4   | 1              |\n| C  | 1   | 2              |\n| C  | 0   | 1              |\n| C  | -1  | 0              |\n\nRelated function: [rowDenseRank](https://docs.dolphindb.com/en/Functions/r/rowDenseRank.html)\n"
    },
    "deny": {
        "url": "https://docs.dolphindb.com/en/Functions/d/deny.html",
        "signatures": [
            {
                "full": "deny(userId|groupId,accessType,[objs])",
                "name": "deny",
                "parameters": [
                    {
                        "full": "userId|groupId",
                        "name": "userId|groupId"
                    },
                    {
                        "full": "accessType",
                        "name": "accessType"
                    },
                    {
                        "full": "[objs]",
                        "name": "objs",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [deny](https://docs.dolphindb.com/en/Functions/d/deny.html)\n\n\n\n#### Syntax\n\ndeny(userId|groupId,accessType,\\[objs])\n\n#### Arguments\n\n**userId** or **groupId** is a string indicating a user name or a group name.\n\n**accessType** is the type of privilege.\n\n**objs** (optional) is a STRING scalar/vector indicating the objects that the priviledges specified by *accessType* applies to.\n\nSee the table of privileges listed in [User Access Control](https://docs.dolphindb.com/en/Maintenance/UserAccessControl.html) for the values that *accessType* and *objs* can take.\n\n#### Details\n\nDeny specified access privileges to a user or a group.\n\nAdministrators can grant users all privileges (*accessType*) through this command, but regular users, after having the relevant OWNER privileges, can only grant the following privileges through this command: TABLE\\_READ, TABLE\\_WRITE, TABLE\\_INSERT, TABLE\\_UPDATE, TABLE\\_DELETE, DB\\_READ, DB\\_WRITE, DB\\_INSERT, DB\\_UPDATE, DB\\_DELETE, DBOBJ\\_DELETE, DBOBJ\\_CREATE and VIEW\\_EXEC.\n\nNote that when *accessType* is DB\\_OWNER, `deny` only takes effect globally.\n\n#### Examples\n\nNone of the members of the group \"production\" can read any table in the database *dfs\\://db1*:\n\n```\ndeny(`production, TABLE_READ, \"dfs://db1\")\n```\n\nNone of the members of the group \"research\" can write to the table *dfs\\://db1/t1*:\n\n```\ndeny(`research, TABLE_WRITE, \"dfs://db1/t1\")\n```\n\nNone of the members of the group \"research\" can create tables in the databases *dfs\\://db1* or *dfs\\://db2*:\n\n```\ndeny(\"research\", DBOBJ_CREATE, [\"dfs://db1\",\"dfs://db2\"])\n```\n\nThe user \"AlexSmith\" cannot create or delete databases:\n\n```\ndeny(\"AlexSmith\", DB_MANAGE)\n```\n\nThe user \"AlexSmith\" cannot execute script:\n\n```\ndeny(\"AlexSmith\", SCRIPT_EXEC)\n```\n\nThe user \"AlexSmith\" cannot test script:\n\n```\ndeny(\"AlexSmith\", TEST_EXEC)\n```\n"
    },
    "derivative": {
        "url": "https://docs.dolphindb.com/en/Functions/d/derivative.html",
        "signatures": [
            {
                "full": "derivative(func, X, [dx =1.0], [n=1], [order=3])",
                "name": "derivative",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[dx =1.0]",
                        "name": "[dx =1.0]"
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[order=3]",
                        "name": "order",
                        "optional": true,
                        "default": "3"
                    }
                ]
            }
        ],
        "markdown": "### [derivative](https://docs.dolphindb.com/en/Functions/d/derivative.html)\n\n\n\n#### Syntax\n\nderivative(func, X, \\[dx =1.0], \\[n=1], \\[order=3])\n\n#### Arguments\n\n**func** is a unary function.\n\n**X** is a numeric scalar/vector indicating where the derivative is evaluated.\n\n**dx** (optional) is a scalar of FLOAT type indicating spacing. The default value is 1.0.\n\n**n** (optional) is an integer scalar indicating the order of the derivative. As of now only *n*=1 is supported.\n\n**order** (optional) is an integer scalar indicating the number of points to use. It must be an odd number. The default value is 3 and can be values between 3 and 1023.\n\n#### Details\n\nReturn the derivative of *func* of order *n* at *X*.\n\n#### Examples\n\n```\nderivative(acos, 0.458, 1e-3);\n// output\n-1.12492\n\na=[0.25, -4.53, 1.85, 12.45, 2.0];\nderivative(cbrt, a, 1e-3, 1, 5);\n// output\n[0.83995,0.121753,0.221189,0.062053,0.209987]\n\nderivative(pow{3,}, 5);\n// output\n324\n```\n"
    },
    "det": {
        "url": "https://docs.dolphindb.com/en/Functions/d/det.html",
        "signatures": [
            {
                "full": "det(X)",
                "name": "det",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [det](https://docs.dolphindb.com/en/Functions/d/det.html)\n\n\n\n#### Syntax\n\ndet(X)\n\n#### Arguments\n\n**X** is a matrix.\n\n#### Details\n\nReturn the determinant of matrix *X*. NULL values are replaced with 0 in the calculation.\n\n#### Examples\n\n```\nx=1..4$2:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\nx.det();\n// output\n-2\n\nx=1 2 3 6 5 4 8 7 0$3:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 6  | 8  |\n| 2  | 5  | 7  |\n| 3  | 4  | 0  |\n\n```\ndet(x);\n// output\n42\n\nx=1 2 3 6 5 4 8 7 NULL $3:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 6  | 8  |\n| 2  | 5  | 7  |\n| 3  | 4  |    |\n\n```\ndet(x);\n// output\n42\n```\n"
    },
    "diag": {
        "url": "https://docs.dolphindb.com/en/Functions/d/diag.html",
        "signatures": [
            {
                "full": "diag(X)",
                "name": "diag",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [diag](https://docs.dolphindb.com/en/Functions/d/diag.html)\n\n\n\n#### Syntax\n\ndiag(X)\n\n#### Arguments\n\n**X** is a numeric vector or a square matrix.\n\n#### Details\n\n* If *X* is a vector, return a diagonal matrix.\n* If *X* is a square matrix, return a vector with the diagonal elements of the matrix.\n\n#### Examples\n\n```\ndiag(1..5);\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 0  | 0  | 0  | 0  |\n| 0  | 2  | 0  | 0  | 0  |\n| 0  | 0  | 3  | 0  | 0  |\n| 0  | 0  | 0  | 4  | 0  |\n| 0  | 0  | 0  | 0  | 5  |\n\n```\nm=1..4$2:2;\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\ndiag(m);\n// output\n[1,4]\n```\n"
    },
    "dict": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dict.html",
        "signatures": [
            {
                "full": "dict(keyObj, valueObj, [ordered=false])",
                "name": "dict",
                "parameters": [
                    {
                        "full": "keyObj",
                        "name": "keyObj"
                    },
                    {
                        "full": "valueObj",
                        "name": "valueObj"
                    },
                    {
                        "full": "[ordered=false]",
                        "name": "ordered",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "dict(keyType, valueType, [ordered=false])",
                "name": "dict",
                "parameters": [
                    {
                        "full": "keyType",
                        "name": "keyType"
                    },
                    {
                        "full": "valueType",
                        "name": "valueType"
                    },
                    {
                        "full": "[ordered=false]",
                        "name": "ordered",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [dict](https://docs.dolphindb.com/en/Functions/d/dict.html)\n\n\n\n#### Syntax\n\ndict(keyObj, valueObj, \\[ordered=false])\n\nor\n\ndict(keyType, valueType, \\[ordered=false])\n\n#### Arguments\n\nFor the first usage:\n\n**keyObj** is a vector indicating dictionary keys.\n\n**valueObj** is a vector indicating dictionary values.\n\nFor the second usage:\n\n**keyType** is the data type of dictionary keys. The following data categories are supported: Integral (excluding COMPRESSED), Temporal, Floating and Literal.\n\n**valueType** is the data type of dictionary values. Note that COMPLEX/POINT/DECIMAL is not supported.\n\n**ordered** (optional) is a Boolean value. The default value is false, which indicates to create a regular dictionary. True means to create an ordered dictionary. The regular dictionaries do not track the insertion order of the key-value pairs whereas the ordered dictionaries preserve the insertion order of key-value pairs.\n\n#### Details\n\nReturn a dictionary object.\n\n#### Examples\n\n```\nx=1 2 3\ny=4.5 7.8 4.3\nz=dict(x,y);\nz;\n// output\n3->4.3\n1->4.5\n2->7.8\n\nz=dict(INT,DOUBLE);\nz[5]=7.9;\nz;\n// output\n5->7.9\n\nz[3]=6;\nz;\n// output\n3->6\n5->7.9\n\ndt=dict([`test], [1]);\ndt;\n// output\ntest->1\n\n//create an ordered dictionary\n$z=dict(x,y,true)\n$z;\n1->4.5\n2->7.8\n3->4.3\n\n// y is a vector of DECIMAL32 type. Create an ordered dictionary z with y as values.\nx=1 3 2\ny = decimal32\\(1.23 3 3.14, 3\\)\nz=dict\\(x,y,true\\);\nz;\n// output\n1-&gt;1.230\n3-&gt;3.000\n2-&gt;3.140\n```\n\nTo get keys and values of a dictionary:\n\n```\nx=1 2 3\ny=4.5 7.8 4.3\nz=dict(x,y);\n\nz.keys();\n// output\n[3,1,2]\n\nz.values();\n// output\n[4.3,4.5,7.8]\n```\n\nrelated system functions: [array](https://docs.dolphindb.com/en/Functions/a/array.html), [matrix](https://docs.dolphindb.com/en/Functions/m/matrix.html), [dictUpdate!](https://docs.dolphindb.com/en/Functions/d/dictUpdate!.html), [syncDict](https://docs.dolphindb.com/en/Functions/s/syncDict.html)\n"
    },
    "dictUpdate!": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dictUpdate!.html",
        "signatures": [
            {
                "full": "dictUpdate!(dictionary, function, keys, parameters, [initFunc=copy])",
                "name": "dictUpdate!",
                "parameters": [
                    {
                        "full": "dictionary",
                        "name": "dictionary"
                    },
                    {
                        "full": "function",
                        "name": "function"
                    },
                    {
                        "full": "keys",
                        "name": "keys"
                    },
                    {
                        "full": "parameters",
                        "name": "parameters"
                    },
                    {
                        "full": "[initFunc=copy]",
                        "name": "initFunc",
                        "optional": true,
                        "default": "copy"
                    }
                ]
            }
        ],
        "markdown": "### [dictUpdate!](https://docs.dolphindb.com/en/Functions/d/dictUpdate!.html)\n\n\n\n#### Syntax\n\ndictUpdate!(dictionary, function, keys, parameters, \\[initFunc=copy])\n\n#### Arguments\n\n**dictionary** is a dictionary object.\n\n**function** is a function object.\n\n**keys** is a scalar/vector indicating for which keys to apply the *function*.\n\n**parameters** are of the same size as *keys*. The arguments passed to the applied function are *parameters* and the initial values of the dictionary.\n\n**initFunc** (optional) is a unary function. If the update operation involves new keys that did not exist in the dictionary to be updated, execute *initFunc* for these keys. If *initFunc* is specified, the values of *dictionary* must be a tuple.\n\n#### Details\n\nUpdate a dictionary for specified keys with the specified function.\n\n#### Examples\n\n```\nx=dict(1 2 3, 1 1 1);\nx;\n// output\n3->1\n1->1\n2->1\n\ndictUpdate!(x, add, 2 3, 1 2);\n// output\n3->3\n1->1\n2->2\n\nx.dictUpdate!(mul, 3 4, 2 4);\n// output\n4->4\n3->6\n1->1\n2->2\n\nd = dict(`IBM`MSFT, [1 2, 3 4])\nmsg = table(`IBM`MSFT`GOOG as symbol, 2 3 2 as ap)\nd.dictUpdate!(append!, msg.symbol, msg.ap, x->array(x.type(), 0, 512).append!(x))\nd;\n// output\nMSFT->[3,4,3]\nGOOG->[2]\nIBM->[1,2,2]\n```\n"
    },
    "difference": {
        "url": "https://docs.dolphindb.com/en/Functions/d/difference.html",
        "signatures": [
            {
                "full": "difference(X)",
                "name": "difference",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [difference](https://docs.dolphindb.com/en/Functions/d/difference.html)\n\n\n\n#### Syntax\n\ndifference(X)\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n#### Details\n\nReturn the last element minus the first element of a vector. If *X* is a scalar, it returns 0.\n\n#### Examples\n\n```\ndifference(2 4 2);\n// output\n0\n\ndifference(12.3 15.6 17.8);\n// output\n5.5\n\ndifference(278);\n// output\n0\n```\n"
    },
    "differentialEvolution": {
        "url": "https://docs.dolphindb.com/en/Functions/d/differentialEvolution.html",
        "signatures": [
            {
                "full": "differentialEvolution(func, bounds, [X0], [maxIter=1000], [popSize=15], [mutation], [recombination=0.7], [tol=0.01], [atol=0], [polish=true], [seed])",
                "name": "differentialEvolution",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "bounds",
                        "name": "bounds"
                    },
                    {
                        "full": "[X0]",
                        "name": "X0",
                        "optional": true
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[popSize=15]",
                        "name": "popSize",
                        "optional": true,
                        "default": "15"
                    },
                    {
                        "full": "[mutation]",
                        "name": "mutation",
                        "optional": true
                    },
                    {
                        "full": "[recombination=0.7]",
                        "name": "recombination",
                        "optional": true,
                        "default": "0.7"
                    },
                    {
                        "full": "[tol=0.01]",
                        "name": "tol",
                        "optional": true,
                        "default": "0.01"
                    },
                    {
                        "full": "[atol=0]",
                        "name": "atol",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[polish=true]",
                        "name": "polish",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[seed]",
                        "name": "seed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [differentialEvolution](https://docs.dolphindb.com/en/Functions/d/differentialEvolution.html)\n\n\n\n#### Syntax\n\ndifferentialEvolution(func, bounds, \\[X0], \\[maxIter=1000], \\[popSize=15], \\[mutation], \\[recombination=0.7], \\[tol=0.01], \\[atol=0], \\[polish=true], \\[seed])\n\n#### Arguments\n\n**func** is the objective function to be minimized. Note that the function must return a scalar.\n\n**bounds** is a numeric matrix of shape (N, 2) indicating the bounds for parameters, where N is the number of parameters to be optimized.\n\n**X0** (optional) is a numeric vector indicating the initial guess to the minimization.\n\n**Note**:\n\n* Each row in the *bound* parameter contains two values (min, max), which define the lower and upper limits for the parameter values specified by *X0*.\n* *X0* and *bounds* must have the same length, i.e., N = size(*X0*).\n\n**maxIter** (optional) is a non-negative integer indicating the maximum number of iterations. The default value is 1000.\n\n**popSize** (optional) is a positive integer specifying the multiplier for setting the total population size. The population contains `popSize*(N - N_equal)` individuals, where `N_equal` represents the number of parameters whose bounds are equal. The default value is 15.\n\n**mutation** (optional) is a numeric pair in the format of (min, max), indicating the range of the mutation constant. It should satisfy 0 <= min <= max < 2. The default value is (0.5, 1).\n\n**recombination** (optional) is a numeric scalar in \\[0, 1], indicating the recombination constant, also known as the crossover probability.\n\n**tol** (optional) is a non-negative floating-point scalar indicating the relative tolerance for convergence. The default value is 0.01.\n\n**atol** (optional) is a non-negative floating-point scalar indicating the absolute tolerance for convergence. The default value is 0. The algorithm terminates when `stdev(population_energies) <= atol + tol * abs(mean(population_energies))`, where `population_energies` is the vector consisting of objective function values for all individuals in the population.\n\n**polish** (optional) is a Boolean scalar indicating whether to polish the differential evolution result using the L-BFGS-B method. The default value is true.\n\n**seed** (optional) is an integer indicating the random seed used in the differential evolution algorithm, allowing users to reproduce the results. If unspecified (default), a non-deterministic random number generator is used.\n\n#### Details\n\nUse the Differential Evolution algorithm to calculate the global minimum of a function with multiple variables.\n\n**Return value**: A dictionary containing the following keys:\n\n* xopt: A floating-point vector indicating the parameter values that minimize the objective function.\n* fopt: A floating-point scalar indicating the minimum value of the objective function, where fopt = f(xopt).\n* iterations: An integer indicating the number of iterations during the optimization process.\n* fcalls: An integer indicating the number of times the objective function is called during the optimization process.\n* converged: A Boolean scalar indicating whether the optimization result is converged.\n  * true: The optimization result has been converged to below a preset tolerance and the algorithm terminates.\n  * false: The algorithm terminates without converging after reaching the maximum number of iterations.\n\n#### Examples\n\nThe following example creates a user-defined function `rosen` and uses `differentialEvolution` (with *bounds* specified) to calculate the global minimum of `rosen`.\n\n```\ndef rosen(x) { \n\tN = size(x);\n\treturn sum(100.0*power(x[1:]-power(x[:N-1], 2.0), 2.0)+power(1-x[:N-1], 2.0));\n}\nbounds = matrix([0 0 0 0 0, 2 2 2 2 2])\ndifferentialEvolution(rosen, bounds)\n\n/* Ouput:\nfcalls->43656\nxopt->[1.000000000000,1.000000000000,1.000000000000,1.000000000000,1.000000000000]\nfopt->0.0\niterations->581\nconverged->true\n*/\n```\n"
    },
    "digitize": {
        "url": "https://docs.dolphindb.com/en/Functions/d/digitize.html",
        "signatures": [
            {
                "full": "digitize(x, bins, [right=false])",
                "name": "digitize",
                "parameters": [
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "bins",
                        "name": "bins"
                    },
                    {
                        "full": "[right=false]",
                        "name": "right",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [digitize](https://docs.dolphindb.com/en/Functions/d/digitize.html)\n\n#### Syntax\n\ndigitize(x, bins, \\[right=false])\n\n#### Arguments\n\n**x**is a scalar or vector of floating-point, integral, or DECIMAL type, indicating the value to be binned.\n\n**bins** is a monotonically increasing or decreasing vector of floating-point, integral, or DECIMAL type, indicating the bins.\n\n**right** (optional) is a Boolean value indicating whether the intervals include the right or the left bin edge. Default behavior is*right*=false indicating that the interval includes the left edge.\n\n#### Details\n\nReturn the indices of the bins to which each value in *x* belongs. The return value has the same data form as *x*.\n\n| *right* | order of *bins* | returned index *i* satisfies |\n| ------- | --------------- | ---------------------------- |\n| false   | increasing      | bins\\[i-1] <= x < bins\\[i]   |\n| true    | increasing      | bins\\[i-1] < x <= bins\\[i]   |\n| false   | decreasing      | bins\\[i-1] > x >= bins\\[i]   |\n| true    | decreasing      | bins\\[i-1] >= x > bins\\[i]   |\n\nIf values in *x* are beyond the bounds of *bins*, 0 (for values beyond left bound) or length of *bins*(for values beyond right bound) is returned.\n\nThis function serves the same functionality as numpy.digitize.\n\n#### Examples\n\nWhen *x* is a scalar:\n\n```\nbins = [1,3,3,5,5]\n\n// returns index i that satisfies bins[i-1] <= 3 < bins[i]\ndigitize(3, bins=bins, right=false)\n// output: 3\n\n//returns index i that satisfies bins[i-1] <= 5 < bins[i]. Since bins[i] > 5 does not exist, size(bins) is returned.\ndigitize(5, bins=bins, right=false)\n//output: 5\n\n// returns index i that satisfies bins[i-1] < 5 <= bins[i].\ndigitize(5, bins=bins, right=true)\n//output: 3\n\nbins = reverse(bins)\ndigitize(5, bins=bins, right=false)\n//output: 0\n\ndigitize(5, bins=bins, right=true)\n//output: 2\n```\n\nWhen *x* is a vector:\n\n```\nx = [-1,0,1,2,3,4,5,6]\nbins = [1,3,5]\ndigitize(x=x, bins=bins, right=false)\n//output: [0,0,1,1,2,2,3,3]\n\ndigitize(x=x, bins=bins, right=true)\n//output: [0,0,0,1,1,2,2,3]\n\nbins = reverse(bins)\ndigitize(x=x, bins=bins, right=false)\n//output: [3,3,2,2,1,1,0,0]\n\ndigitize(x=x, bins=bins, right=true)\n//output: [3,3,3,2,2,1,1,0]\n```\n\nThe following example demonstrates the difference between `digitize` and `bucket`.\n\nFor function `bucket`, if the number of elements of the input vector that belong to *dataRange*(\"\\[12, 53)\" in this case) is not a multiple of *bucketNum*(\\*\"\\*2\" in this case), an error will be thrown. The `digitize` function, however, is more flexible in customizing *bins*.\n\n```\nbucket(9 23 54 36 46 12, 12:53, 2)\n//throw an error: dataRange must be the mutltiplier of bucketNum.\n\ndigitize(9 23 54 36 46 12 , 12 40 53)\n// output: [0,1,3,1,2,1]\n```\n\n"
    },
    "disableActivePartition": {
        "url": "https://docs.dolphindb.com/en/Functions/d/disableActivePartition.html",
        "signatures": [
            {
                "full": "disableActivePartition(dbHandle)",
                "name": "disableActivePartition",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    }
                ]
            }
        ],
        "markdown": "### [disableActivePartition](https://docs.dolphindb.com/en/Functions/d/disableActivePartition.html)\n\n\n\n#### Syntax\n\ndisableActivePartition(dbHandle)\n\n#### Arguments\n\n**dbHandle** is the handle of the historical database.\n\n#### Details\n\nCancel the connection between the active database and the historical database.\n\n#### Examples\n\n```\nhistdb = database(\"C:\\DolphinDBDemo\\example\\data\\dbspace\\historical-A\\Trades2ndDomain\")\nactiveNodeAlias = getNodeAlias()\nactiveDate = today()\nenableActivePartition(histdb, activeDate, activeNodeAlias);\n\ndisableActivePartition(histdb);\n```\n"
    },
    "disableQueryMonitor": {
        "url": "https://docs.dolphindb.com/en/Functions/d/disableQueryMonitor.html",
        "signatures": [
            {
                "full": "disableQueryMonitor()",
                "name": "disableQueryMonitor",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [disableQueryMonitor](https://docs.dolphindb.com/en/Functions/d/disableQueryMonitor.html)\n\n\n\n#### Syntax\n\ndisableQueryMonitor()\n\n#### Arguments\n\nNone\n\n#### Details\n\nDisable the monitor on query status.\n\nAs monitoring the query status has some memory overhead, you can disable the monitor when the system is low on memory.\n\nNote: After calling the command, users cannot get the query job status with [getQueryStatus](https://docs.dolphindb.com/en/Functions/g/getQueryStatus.html).\n\nRelated function: [enableQueryMonitor](https://docs.dolphindb.com/en/Functions/e/enableQueryMonitor.html)\n"
    },
    "disableResourceTracking": {
        "url": "https://docs.dolphindb.com/en/Functions/d/disableresourcetracking.html",
        "signatures": [
            {
                "full": "disableResourceTracking()",
                "name": "disableResourceTracking",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [disableResourceTracking](https://docs.dolphindb.com/en/Functions/d/disableresourcetracking.html)\n\n\n\n#### Syntax\n\ndisableResourceTracking()\n\n#### Arguments\n\nNone\n\n#### Details\n\nUse this function to disable resource tracking at runtime. This function can only be called by the administrator on a data node, and it only takes effect when *resourceSamplingInterval*is set to a positive integer. Note that enabling or disabling resource tracking will not affect log retention.\n\nRelated function: [enableResourceTracking](https://docs.dolphindb.com/en/Functions/e/enableresourcetracking.html)\n"
    },
    "disableTablePersistence": {
        "url": "https://docs.dolphindb.com/en/Functions/d/disableTablePersistence.html",
        "signatures": [
            {
                "full": "disableTablePersistence(table)",
                "name": "disableTablePersistence",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [disableTablePersistence](https://docs.dolphindb.com/en/Functions/d/disableTablePersistence.html)\n\n\n\n#### Syntax\n\ndisableTablePersistence(table)\n\n#### Arguments\n\n**table** is a table object.\n\n#### Details\n\nDisable a table persistence to disk. Any future update of the table will not be persisted to disk.\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt = streamTable(100:0, colName, colType);\nshare t as st\nenableTablePersistence(table=st, cacheSize=1200000)\n```\n\n```\nfor(s in 0:200){\n     n=10000\n     time=2019.01.01T00:00:00.000+s*n+1..n\n     x=rand(10.0, n)\n     insert into st values(time, x)\n}\ndisableTablePersistence(st);\n```\n\nRelated commands: [enableTablePersistence](https://docs.dolphindb.com/en/Functions/e/enableTablePersistence.html), [clearTablePersistence](https://docs.dolphindb.com/en/Functions/c/clearTablePersistence.html)\n"
    },
    "disableTSDBAsyncSorting": {
        "url": "https://docs.dolphindb.com/en/Functions/d/disableTSDBAsyncSorting.html",
        "signatures": [
            {
                "full": "disableTSDBAsyncSorting()",
                "name": "disableTSDBAsyncSorting",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [disableTSDBAsyncSorting](https://docs.dolphindb.com/en/Functions/d/disableTSDBAsyncSorting.html)\n\n\n\n#### Syntax\n\ndisableTSDBAsyncSorting()\n\n#### Arguments\n\nNone\n\n#### Details\n\nData written to the TSDB cache engine are sorted by *sortColumns*. The tasks of writing and sorting data can be processed synchronously or asynchronously. Execute the command to disable asynchronous sorting mode. This command can only be executed by an administrator on a data node.\n\nRelated function: [enableTSDBAsyncSorting](https://docs.dolphindb.com/en/Functions/e/enableTSDBAsyncSorting.html)\n"
    },
    "distance": {
        "url": "https://docs.dolphindb.com/en/Functions/d/distance.html",
        "signatures": [
            {
                "full": "distance(X, Y)",
                "name": "distance",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [distance](https://docs.dolphindb.com/en/Functions/d/distance.html)\n\n\n\n#### Syntax\n\ndistance(X, Y)\n\n#### Arguments\n\n**X** and **Y** can be a POINT scalar/pair/vector representing points in the coordinate system of earth.\n\n#### Details\n\nCalculate the distance in meters between 2 points on the earth's surface.\n\n#### Examples\n\n```\np1 = point(180, 24.118418)\np2 = point(180, 24.11931)\ndistance(p1,p2)\n// output\n99.185916\n\np1 = point(117.60972, 24.118418)\np2 = point(117.50972, 24.118418)\np3 = point(117.70972, 24.118418)\np4 = point(117.75972, 24.118418)\ndistance([p1,p2], [p3,p4])\n```\n\n| 0          | 1           |\n| ---------- | ----------- |\n| 10,148.799 | 25,371.9947 |\n\nCalculate the distance between the two points p1 (Lon1,Lat1) and p2 (Lon2,Lat2) on the map. Based on the 0-degree longitude, the east longitude is taken as a positive value (Longitude), the west longitude is taken as a negative value (-Longitude), the north latitude is taken as 90-latitude, and the south latitude is taken as 90+latitude. So the calculation is:\n\n```\np1 = point(-117.60972,24.118418)  //Longitude: 117.60972 W Latitude: 65.881582 N\np2 = point(117.61113,114.11931)  //Longitude: 117.60972 E Latitude: 24.118418 S\ndistance(p1,p2)\n// output\n6.02098E6\n```\n"
    },
    "distinct": {
        "url": "https://docs.dolphindb.com/en/Functions/d/distinct.html",
        "signatures": [
            {
                "full": "distinct(X)",
                "name": "distinct",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [distinct](https://docs.dolphindb.com/en/Functions/d/distinct.html)\n\n\n\n#### Syntax\n\ndistinct(X)\n\n#### Arguments\n\n**X** is a vector.\n\n#### Details\n\nReturn the distinct elements from vector *X*. The order of the elements in the result is not guaranteed.\n\n#### Examples\n\n```\ndistinct 4 5 5 2 3;\n// output\n[3,2,5,4]\n\nt=table(3 1 2 2 3 as x);\nselect distinct x from t;\n```\n\n| distinct\\_x |\n| ----------- |\n| 2           |\n| 1           |\n| 3           |\n\n```\nselect sort(distinct(x)) as x from t;\n```\n\n| x |\n| - |\n| 1 |\n| 2 |\n| 3 |\n\nThe function `distinct` returns a vector, while the function [set](https://docs.dolphindb.com/en/Functions/s/set.html) returns a set.\n\n```\nx=set(4 5 5 2 3);\nx;\n// output\nset(3,2,5,4)\n\nx.intersection(set(2 5));\n// output\nset(2,5)\n```\n"
    },
    "div": {
        "url": "https://docs.dolphindb.com/en/Functions/d/div.html",
        "signatures": [
            {
                "full": "div(X, Y)",
                "name": "div",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [div](https://docs.dolphindb.com/en/Functions/d/div.html)\n\n\n\n#### Syntax\n\ndiv(X, Y)\n\nor\n\nX/Y\n\n#### Arguments\n\n**X** and **Y** can be a scalar/pair/vector/matrix. If *X* or *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nReturn element-by-element division of *X* by *Y*.\n\nWhen *X* or *Y* is floating, it returns a floating value.\n\nWhen both *X* and *Y* are integers, `div` means integer division, which is the same as applying the [floor](https://docs.dolphindb.com/en/Functions/f/floor.html) function after division. For example, 5/2 is 2. If you want \"true\" division for integers, you can apply the operator [ratio(\\\\)](https://docs.dolphindb.com/en/Functions/r/ratio.html) instead. Integer division is often used together with the operator [mod](https://docs.dolphindb.com/en/Functions/m/mod.html) for grouping data. The results of `div` and `mod` should satisfy the relationship: `X=div(X,Y)*Y+mod(X,Y)`.\n\n#### Examples\n\n```\n9/2:5;\n// output\n4 : 1\n\n11:25/3:4;\n// output\n3 : 6\n\nx=1 2 3;\nx/2;\n// output\n[0,1,1]\n\n2/x;\n// output\n[2,1,0]\n\ny=4 5 6;\nx/y;\n// output\n[0,0,0]\ny/x;\n// output\n[4,2,2]\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1/2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 1  | 2  |\n| 1  | 2  | 3  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1/m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 0  | 2  |\n| 0  | 1  | 6  |\n\n```\n-7/5;\n// output\n-2\n\n\nx=-1 2 6;\nx/-5;\n// output\n[0,-1,-2]\n```\n"
    },
    "dividedDifference": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dividedDifference.html",
        "signatures": [
            {
                "full": "dividedDifference(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false])",
                "name": "dividedDifference",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "resampleRule",
                        "name": "resampleRule"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    },
                    {
                        "full": "[outputX=false]",
                        "name": "outputX",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [dividedDifference](https://docs.dolphindb.com/en/Functions/d/dividedDifference.html)\n\n\n\n#### Syntax\n\ndividedDifference(X, Y, resampleRule, \\[closed='left'], \\[origin='start\\_day'], \\[outputX=false])\n\n#### Arguments\n\n**X** is a strictly increasing vector of temporal type.\n\n**Y** is a numeric vector of the same length as *X*.\n\n**resampleRule** is a string. See the parameter *rule* of function [resample](https://docs.dolphindb.com/en/Functions/r/resample.html) for the optional values.\n\n**closed** and **origin** are the same as the parameters *closed* and *origin* of function [resample](https://docs.dolphindb.com/en/Functions/r/resample.html).\n\n**outputX** is a Boolean value indicating whether to output the resampled *X*. The default value is false.\n\n#### Details\n\nResample *X* based on the specified *resampleRule*, *closed* and *origin*. Perform divided difference interpolation on *Y* based on the resampled *X*.\n\nIf *outputX* is unspecified, return a vector of *Y* after the interpolation.\n\nIf *outputX*=true, return a tuple where the first element is the vector of resampled *X* and the second element is a vector of *Y* after the interpolation.\n\n#### Examples\n\n```\ndividedDifference([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min);\n\n// output\n[1,1.0217,1.0451,1.0703,1.0972,1.1259,1.1562,1.1884,1.2222,1.2578,\n1.2951,1.3342,1.375,1.4175,1.4618,1.5078,1.5556,1.605,1.6562,1.7092,\n1.7639,1.8203,1.8785,1.9384,2,2.0634,2.1285,2.1953,2.2639,2.3342,\n2.4062,2.48,2.5556,2.6328,2.7118,2.7925,2.875,2.9592,3.0451,3.1328,\n3.2222,3.3134,3.4062,3.5009,3.5972,3.6953,3.7951,3.8967,4]\n```\n"
    },
    "dot": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dot.html",
        "signatures": [
            {
                "full": "dot(X, Y)",
                "name": "dot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [dot](https://docs.dolphindb.com/en/Functions/d/dot.html)\n\n\n\n#### Syntax\n\ndot(X, Y)\n\nor\n\nX\\*\\*Y\n\n#### Arguments\n\n**X** / **Y** can be a scalar/vector/matrix. If both of *X* and *Y* are vectors, they must have the same length. If one of *X* and *Y* is a matrix, the other is a vector/matrix and their dimensions must satisfy the rules of matrix multiplication.\n\n#### Details\n\nReturn the matrix multiplication of *X* and *Y*. If *X* and *Y* are vectors of the same length, return their inner product.\n\n#### Examples\n\n```\nx=1..6$2:3;\ny=1 2 3;\nx dot y;\n```\n\n| #0 |\n| -- |\n| 22 |\n| 28 |\n\n```\nx=1..6$2:3;\ny=6..1$3:2;\nx**y;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 41 | 14 |\n| 56 | 20 |\n\n```\ny**x;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 12 | 30 | 48 |\n| 9  | 23 | 37 |\n| 6  | 16 | 26 |\n\n```\na=1 2 3;\nshape a;\n// output\n3:1\n\nx**a;\n```\n\n| #0 |\n| -- |\n| 22 |\n| 28 |\n\n```\nb=1 2;\nshape b;\n// output\n2:1\n\nb**x;  // for a matrix multiplication between a matrix and a vector, the system may rotate the dimension of the vector for the multiplication to go through.\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 5  | 11 | 17 |\n\n```\nx=1 2 3;\ny=4 5 6;\nx ** y;\n// output\n32  // inner product of two vectors. Equivalent to 1*4 + 2*5 + 3*6\n\nx ** 2;\n// output\n[2,4,6]\n\nx=1..6$2:3\nx ** 2;\nError: Use * rather than ** for scalar and matrix multiplication.\n```\n"
    },
    "double": {
        "url": "https://docs.dolphindb.com/en/Functions/d/double.html",
        "signatures": [
            {
                "full": "double(X)",
                "name": "double",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [double](https://docs.dolphindb.com/en/Functions/d/double.html)\n\n\n\n#### Syntax\n\ndouble(X)\n\n#### Arguments\n\n**X** can be of any data type.\n\n#### Details\n\nConvert the input to the data type of DOUBLE.\n\n#### Examples\n\n```\n// create a DOUBLE variable with default value 0\nx=double();\nx;\n// output\n00F\ntypestr x;\n// output\nDOUBLE\n\ntypestr double(`10);\n// output\nDOUBLE\n\ndouble(`10.9);\n// output\n10.9\n\ndouble(now());\n// output\n5.297834e+011\n```\n"
    },
    "drop": {
        "url": "https://docs.dolphindb.com/en/Functions/d/drop.html",
        "signatures": [
            {
                "full": "drop(X, n)",
                "name": "drop",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [drop](https://docs.dolphindb.com/en/Functions/d/drop.html)\n\n\n\n#### Syntax\n\ndrop(X, n)\n\n#### Arguments\n\n**X** is a vector/matrix/table.\n\n**n** is an integer.\n\n#### Details\n\n* If *X* is a vector, delete the first *n* or last *n* (if *n* is negative) elements.\n* If *X* is a matrix, delete the first *n* or last *n* (if *n* is negative) columns.\n* If *X* is a table, delete the first *n* or last *n* (if *n* is negative) rows.\n\n#### Examples\n\n```\nx=1..10;\nx.drop(2);\n// output\n[3,4,5,6,7,8,9,10]\nx.drop(-2);\n// output\n[1,2,3,4,5,6,7,8]\n\nx=1..10$2:5;\nx;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  |\n| 2  | 4  | 6  | 8  | 10 |\n\n```\ndrop(x,2);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 5  | 7  | 9  |\n| 6  | 8  | 10 |\n\n```\nx drop -2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nt=table(1 2 3 4 as x, 11..14 as y);\nt;\n```\n\n| x | y  |\n| - | -- |\n| 1 | 11 |\n| 2 | 12 |\n| 3 | 13 |\n| 4 | 14 |\n\n```\nt.drop(2);\n```\n\n| x | y  |\n| - | -- |\n| 3 | 13 |\n| 4 | 14 |\n"
    },
    "dropAggregator": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropAggregator.html",
        "signatures": [
            {
                "full": "dropStreamEngine(name)",
                "name": "dropStreamEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [dropAggregator](https://docs.dolphindb.com/en/Functions/d/dropAggregator.html)\n\nAlias for [dropStreamEngine](https://docs.dolphindb.com/en/Functions/d/dropStreamEngine.html)\n\n\nDocumentation for the `dropStreamEngine` function:\n### [dropStreamEngine](https://docs.dolphindb.com/en/Functions/d/dropStreamEngine.html)\n\n\n\n#### Syntax\n\ndropStreamEngine(name)\n\nAlias: dropAggregator\n\n#### Arguments\n\n**name** is a string indicating the name of a created stream engine. You can obtain all created engines with function [getStreamEngineStat](https://docs.dolphindb.com/en/Functions/g/getStreamEngineStat.html).\n\n#### Details\n\nRelease the definition of a stream engine from the memory.\n\n#### Examples\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\noutputTable = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\ntradesEngine = createTimeSeriesEngine(name=\"StreamEngineDemo\", windowSize=3, step=3, metrics=<[sum(qty)]>, dummyTable=trades, outputTable=outputTable, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesEngine\", offset=0, handler=append!{tradesEngine}, msgAsTable=true)\n```\n\n```\ndef writeData(n){\n    timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n    symv =take(`A`B, n)\n    qtyv = take(1, n)\n    insert into trades values(timev, symv, qtyv)\n}\n\nwriteData(6);\n```\n\n```\n// output\nselect * from outputTable;\n```\n\n| time                    | sym | sumQty |\n| ----------------------- | --- | ------ |\n| 2018.10.08T01:01:01.003 | A   | 1      |\n| 2018.10.08T01:01:01.006 | A   | 1      |\n| 2018.10.08T01:01:01.006 | B   | 2      |\n\n```\ndropStreamEngine(\"StreamEngineDemo\");\n```\n"
    },
    "dropCatalog": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropCatalog.html",
        "signatures": [
            {
                "full": "dropCatalog(catalog)",
                "name": "dropCatalog",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    }
                ]
            }
        ],
        "markdown": "### [dropCatalog](https://docs.dolphindb.com/en/Functions/d/dropCatalog.html)\n\n#### Syntax\n\ndropCatalog(catalog)\n\n#### Arguments\n\n**catalog**is a string specifying the catalog name.\n\n#### Details\n\nDrop a catalog.\n\n#### Examples\n\n```\ndropCatalog(\"cat1\")\n```\n\n"
    },
    "dropColumns!": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropColumns!.html",
        "signatures": [
            {
                "full": "dropColumns!(table, colNames)",
                "name": "dropColumns!",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    }
                ]
            }
        ],
        "markdown": "### [dropColumns!](https://docs.dolphindb.com/en/Functions/d/dropColumns!.html)\n\n\n\n#### Syntax\n\ndropColumns!(table, colNames)\n\nAlias: drop!\n\n#### Arguments\n\n**table** is a table object. It is an in-memory tableor a DFS table (for OLAP engine only).\n\n**colNames** is a STRING scalar/vector indicating a column name.If *table* is a DFS table, it must be a scalar.\n\n#### Details\n\nDelete one or multiple columns from a table.\n\nNote that deleting a partitioning column from a DFS table, or deleting a column of SYMBOL type is not supported.\n\n#### Examples\n\n```\nt=table(1 2 3 as x, 4 5 6 as y, 7..9 as z, 10..12 as a, 13..15 as b, 16..18 as c);\nt;\n```\n\n| x | y | z | a  | b  | c  |\n| - | - | - | -- | -- | -- |\n| 1 | 4 | 7 | 10 | 13 | 16 |\n| 2 | 5 | 8 | 11 | 14 | 17 |\n| 3 | 6 | 9 | 12 | 15 | 18 |\n\n```\nt.dropColumns!(`x);\n```\n\n| y | z | a  | b  | c  |\n| - | - | -- | -- | -- |\n| 4 | 7 | 10 | 13 | 16 |\n| 5 | 8 | 11 | 14 | 17 |\n| 6 | 9 | 12 | 15 | 18 |\n\n```\ndropColumns!(t, `a`b);\n```\n\n| y | z | c  |\n| - | - | -- |\n| 4 | 7 | 16 |\n| 5 | 8 | 17 |\n| 6 | 9 | 18 |\n"
    },
    "dropDatabase": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropDatabase.html",
        "signatures": [
            {
                "full": "dropDatabase(dbDir)",
                "name": "dropDatabase",
                "parameters": [
                    {
                        "full": "dbDir",
                        "name": "dbDir"
                    }
                ]
            }
        ],
        "markdown": "### [dropDatabase](https://docs.dolphindb.com/en/Functions/d/dropDatabase.html)\n\n\n\n#### Syntax\n\ndropDatabase(dbDir)\n\n#### Arguments\n\n**dbDir** specifies the directory where the database is located. For a database in the distributed file system, the directory should start with \"dfs\\://\".\n\n#### Details\n\nDelete all physical files from the specified database.\n\n#### Examples\n\nDrop a DFS database:\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x);\nsaveText(t, \"C:/DolphinDB/Data/t.txt\");\n\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt = loadTextEx(db, `pt1, `date, \"C:/DolphinDB/Data/t.txt\");\n\ndropDatabase(\"dfs://valueDB\")\n```\n\nDrop a database on disk:\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\nsaveText(t, \"C:/DolphinDB/Data/t.txt\");\n\ndb = database(\"C:/DolphinDB/Data/rangedb\", RANGE, 0 5 10)\npt = loadTextEx(db, `pt, `ID, \"C:/DolphinDB/Data/t.txt\");\n\ndropDatabase(\"C:/DolphinDB/Data/rangedb\");\n```\n"
    },
    "dropDistributedInMemoryTable": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropDistributedInMemoryTable.html",
        "signatures": [
            {
                "full": "dropDistributedInMemoryTable(tableName)",
                "name": "dropDistributedInMemoryTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [dropDistributedInMemoryTable](https://docs.dolphindb.com/en/Functions/d/dropDistributedInMemoryTable.html)\n\n\n\n#### Syntax\n\ndropDistributedInMemoryTable(tableName)\n\n#### Arguments\n\n**tableName** is a STRING scalar indicating column names of a distributed in-memory table.\n\n#### Details\n\nDelete the specified distributed in-memory table. This function can only be executed on a data node or compute node.\n\n#### Examples\n\n```\npt = createDistributedInMemoryTable(`dt, `time`id`value, `DATETIME`INT`LONG, HASH, [INT, 2],`id)\ntime = take(2021.08.20 00:00:00..2021.08.30 00:00:00, 40);\nid = 0..39;\nvalue = rand(100, 40);\ntmp = table(time, id, value);\n\npt = loadDistributedInMemoryTable(`dt)\npt.append!(tmp);\ndropDistributedInMemoryTable(`dt)\n```\n\nRelated functions: [loadDistributedInMemoryTable](https://docs.dolphindb.com/en/Functions/l/loadDistributedInMemoryTable.html), [createDistributedInMemoryTable](https://docs.dolphindb.com/en/Functions/c/createDistributedInMemoryTable.html)\n"
    },
    "dropFunctionView": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropFunctionView.html",
        "signatures": [
            {
                "full": "dropFunctionView(name)",
                "name": "dropFunctionView",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [dropFunctionView](https://docs.dolphindb.com/en/Functions/d/dropFunctionView.html)\n\n\n\n#### Syntax\n\ndropFunctionView(name)\n\n#### Arguments\n\n**name** is a STRING scalar indicating the user-defined function.\n\n#### Details\n\nDelete a function view.\n\nIt can only be executed by administrators or users with VIEW\\_OWNER permission.\n"
    },
    "dropIPCInMemoryTable": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropIPCInMemoryTable.html",
        "signatures": [
            {
                "full": "dropIPCInMemoryTable(tableName)",
                "name": "dropIPCInMemoryTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [dropIPCInMemoryTable](https://docs.dolphindb.com/en/Functions/d/dropIPCInMemoryTable.html)\n\n\n\n#### Syntax\n\ndropIPCInMemoryTable(tableName)\n\n#### Arguments\n\n**tableName** is a string indicating the name of IPC in-memory table to be dropped.\n\n#### Details\n\nDrop an IPC in-memory table.\n\n**Note:**\n\n* This function can only be executed on Linux.\n* An IPC in-memory table cannot be deleted if a server is shut down. It still needs to be deleted through function `dropIPCInMemoryTable`.\n\n#### Examples\n\nDrop the table ipc\\_table created by function [createIPCInMemoryTable](https://docs.dolphindb.com/en/Functions/c/createIPCInMemoryTable.html).\n\n```\ndropIPCInMemoryTable(`ipc_table)\n// output\nipc_table\n```\n"
    },
    "dropna": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropna.html",
        "signatures": [
            {
                "full": "dropna(X, [byRow=true], [thresh])",
                "name": "dropna",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[byRow=true]",
                        "name": "byRow",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[thresh]",
                        "name": "thresh",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [dropna](https://docs.dolphindb.com/en/Functions/d/dropna.html)\n\n\n\n#### Syntax\n\ndropna(X, \\[byRow=true], \\[thresh])\n\n#### Arguments\n\n**X** is a vector or matrix.\n\n**byRow** (optional) is a Boolean value. The default value is true.\n\n**thresh** (optional) is a positive integer.\n\n#### Details\n\nIf *X* is a vector, delete all NULL values from *X*.\n\nIf *X* is a matrix and *byRow*=true, delete all rows with NULL values.\n\nIf *X* is a matrix and *byRow*=false, delete all columns with NULL values.\n\nIf *thresh* is specified, each row or column (as specified by *byRow*) in the result must have at least *thresh* non-NULL values.\n\n#### Examples\n\n```\nx=1 NULL 2 3 NULL NULL 4;\nx.dropna();\n// output\n[1,2,3,4]\n\nm=matrix(1 1 1 1, 1 1 1 NULL, 1 NULL 1 NULL);\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 1  | 1  |    |\n| 1  | 1  | 1  |\n| 1  |    |    |\n\n```\ndropna(m);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 1  | 1  | 1  |\n\n```\ndropna(m,,2);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 1  | 1  |    |\n| 1  | 1  | 1  |\n\n```\ndropna(m,false);\n```\n\n| #0 |\n| -- |\n| 1  |\n| 1  |\n| 1  |\n| 1  |\n\n```\ndropna(m,false,3);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 1  | 1  |\n| 1  | 1  |\n| 1  |    |\n"
    },
    "dropPartition": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropPartition.html",
        "signatures": [
            {
                "full": "dropPartition(dbHandle, partitionPaths, tableName, [forceDelete=false], [deleteSchema=false])",
                "name": "dropPartition",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "partitionPaths",
                        "name": "partitionPaths"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[forceDelete=false]",
                        "name": "forceDelete",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[deleteSchema=false]",
                        "name": "deleteSchema",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [dropPartition](https://docs.dolphindb.com/en/Functions/d/dropPartition.html)\n\n\n\n#### Syntax\n\ndropPartition(dbHandle, partitionPaths, tableName, \\[forceDelete=false], \\[deleteSchema=false])\n\n#### Arguments\n\n**dbHandle** is a DolphinDB database handle.\n\n**partitionPaths** can be specified in two ways:\n\n* By path: *partitionPaths* is a STRING scalar/vector indicating the path of one or multiple partitions. Each string must start with \"/\". For composite partitions, the path must include all partition levels.\n\n* By condition: *partitionPaths* is a scalar or vector indicating the value(s) in the partitioning column. The system will drop all partitions containing these values. For composite partitions, *partitionPaths* is a tuple where each element is a filtering condition for each partition level (starting from the first level). If you do not want to apply filtering at a certain partition level, leave the corresponding element empty.\n\n**tableName** is a string indicating a table name. It can be left empty if the database chunk granularity is at DATABASE level (i.e., [database](https://docs.dolphindb.com/en/Functions/d/database.html): *chunkGranularity* = 'DATABASE'). Otherwise, it is a required parameter.\n\n**forceDelete** (optional) is a Boolean value. If set to true, the specified partition(s) will be deleted even if the partition(s) is recovering. The default value is false.\n\n**Note:** When using the `dropPartition` function with *forceDelete*=false, the number of available replicas for the chunks involved in the transaction must be greater than or equal to the configured *dfsReplicationFactor*.\n\n**deleteSchema** (optional) is a Boolean value. The default value is false, indicating that only the data in the selected partitions will be deleted, but the partition schema (which you can check with `schema().partitionSchema`) is kept. When the following conditions are satisfied, you can delete the schema of the selected partitions along with the partition data by setting *deleteSchema* to true:\n\n* There's only one table in the database.\n* The partitioning type of the database is VALUE.\n* For composite partitions, the first level of partitioning type must be VALUE, and only the first level of partitions are selected for deletion.\n\n#### Details\n\nDelete data from one or multiple partitions from a DFS database.\n\nPlease note that *dropPartition* only deletes data from selected partitions. It does not change the partitioning scheme. We do not need to reestablish these partitions if we need to append new data to them.\n\nIf *tableName* is specified: delete one or multiple partitions of the given table.\n\nIf *tableName* is not specified: delete one or multiple partitions of all tables with this partition.\n\n#### Examples\n\nThe script should be executed on a data node or compute node of a cluster.\n\n```\nn=1000000\nID=rand(150, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID = database(, RANGE, 0 50 100 150)\ndb = database(\"dfs://compoDB\", COMPO, [dbDate, dbID])\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n```\n\nThe script above created a database with composite partition. The first level is a value partition with partitioning column of date, and the second level is a range partition with partitioning column of ID.\n\nExample 1. Delete one partition\n\nUse either of the following ways to delete the partition \"/20170807/0\\_50\".\n\n(1) Specify the partition path.\n\n```\ndropPartition(db,\"/20170807/0_50\");\n```\n\n(2) Specify the filtering condition.\n\n```\ndropPartition(db,[2017.08.07, 0]);\n```\n\nHere 0 means the partition of \\[0, 50). We can choose any number from 0 to 49 to represent this partition.\n\nExample 2. Delete a first level partition\n\nUse either of the following ways to delete the first level partition of 2017.08.08.\n\n(1) Specify the path of all partitions under 2017.08.08.\n\n```\npartitions=[\"/20170808/0_50\",\"/20170808/50_100\",\"/20170808/100_150\"]\ndropPartition(db,partitions);\n```\n\n(2) Specify the filtering condition.\n\n```\ndropPartition(db, 2017.08.08, tableName=`pt);\n```\n\nAfter the deletion, check the table partitioning scheme with [schema](https://docs.dolphindb.com/en/Functions/s/schema.html)\n\n```\nschema(db);\n// output\npartitionSchema->([2017.08.11,2017.08.10,2017.08.09,2017.08.08,2017.08.07],[0,50,100,150])\npartitionSites->\npartitionTypeName->[VALUE,RANGE]\natomic->TRANS\ndatabaseDir->dfs://compoDB\nchunkGranularity->TABLE\nengineType->OLAP\npartitionType->[1,2]\n```\n\nWe can see that \"2017.08.08\" is still in *partitionSchema* as `dropPartition` only deleted the data from this partition but kept its schema. Since \"2017.08.08\" is a first level VALUE partition, we can also delete its schema from the table partitioning scheme along with its data by specifying *deleteSchema* = true:\n\n```\ndropPartition(db, 2017.08.08, tableName=`pt, deleteSchema = true);\n```\n\nCheck the table partitioning scheme with [schema](https://docs.dolphindb.com/en/Functions/s/schema.html) - \"2017.08.08\" is no longer in *partitionSchema*:\n\n```\nschema(db);\n// output\npartitionSchema->([2017.08.11,2017.08.10,2017.08.09,2017.08.07],[0,50,100,150])\n...\n```\n\nExample 3. Delete a second level partition\n\nUse either of the following ways to delete the second level partition of \\[0,50).\n\n(1) Specify the path of all partitions of \\[0,50).\n\n```\npartitions=[\"/20170807/0_50\",\"/20170808/0_50\",\"/20170809/0_50\",\"/20170810/0_50\",\"/20170811/0_50\"]\ndropPartition(db,partitions);\n```\n\n(2) Specify the filtering condition.\n\n```\ndropPartition(db,[,[0]]);\n```\n\nExample 4. Delete multiple same level partitions\n\nTo delete the second level partitions of \\[0,50) and \\[100,150):\n\n```\ndropPartition(db,[,[0,100]]);\n```\n\nExample 5: Modify data in a distributed table on disk\n\nTo revise data in a distributed table, we need to update the entire partitions that the rows to be updated belong to. The following example adds 10 to column x of the rows with date=2017.08.10 and ID=88 in the distributed table pt.\n\n(1) First load the data of the partition with date=2017.08.10 and ID=88 into memory.\n\n```\ntmp=select * from loadTable(\"dfs://compoDB\",\"pt\") where date=2017.08.10 and 50<=ID<100 ;\n```\n\n(2) Then add 10 to column x of table tmp:\n\n```\nupdate tmp set x=x+10 where date=2017.08.10 and ID=88;\n```\n\n(3) Delete data in the relevant partition:\n\n```\ndropPartition(db,\"/20170810/50_100\",`pt);\n```\n\n(4) Append table tmp to table pt:\n\n```\npt.append!(tmp);\n```\n"
    },
    "dropSchema": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropSchema.html",
        "signatures": [
            {
                "full": "dropSchema(catalog, schema)",
                "name": "dropSchema",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    },
                    {
                        "full": "schema",
                        "name": "schema"
                    }
                ]
            }
        ],
        "markdown": "### [dropSchema](https://docs.dolphindb.com/en/Functions/d/dropSchema.html)\n\n#### Syntax\n\ndropSchema(catalog, schema)\n\n#### Arguments\n\n**catalog**is a string specifying the catalog name.\n\n**schema**is a string indicating the schema to be deleted.\n\n#### Details\n\nDrop a schema from a catalog.\n\n#### Examples\n\n```\ndropSchema(\"catalog1\", \"schema\")\n```\n\n"
    },
    "dropStreamEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropStreamEngine.html",
        "signatures": [
            {
                "full": "dropStreamEngine(name)",
                "name": "dropStreamEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [dropStreamEngine](https://docs.dolphindb.com/en/Functions/d/dropStreamEngine.html)\n\n\n\n#### Syntax\n\ndropStreamEngine(name)\n\nAlias: dropAggregator\n\n#### Arguments\n\n**name** is a string indicating the name of a created stream engine. You can obtain all created engines with function [getStreamEngineStat](https://docs.dolphindb.com/en/Functions/g/getStreamEngineStat.html).\n\n#### Details\n\nRelease the definition of a stream engine from the memory.\n\n#### Examples\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\noutputTable = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\ntradesEngine = createTimeSeriesEngine(name=\"StreamEngineDemo\", windowSize=3, step=3, metrics=<[sum(qty)]>, dummyTable=trades, outputTable=outputTable, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesEngine\", offset=0, handler=append!{tradesEngine}, msgAsTable=true)\n```\n\n```\ndef writeData(n){\n    timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n    symv =take(`A`B, n)\n    qtyv = take(1, n)\n    insert into trades values(timev, symv, qtyv)\n}\n\nwriteData(6);\n```\n\n```\n// output\nselect * from outputTable;\n```\n\n| time                    | sym | sumQty |\n| ----------------------- | --- | ------ |\n| 2018.10.08T01:01:01.003 | A   | 1      |\n| 2018.10.08T01:01:01.006 | A   | 1      |\n| 2018.10.08T01:01:01.006 | B   | 2      |\n\n```\ndropStreamEngine(\"StreamEngineDemo\");\n```\n"
    },
    "dropStreamTable": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropStreamTable.html",
        "signatures": [
            {
                "full": "dropStreamTable(tableName, [force=false])",
                "name": "dropStreamTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[force=false]",
                        "name": "force",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [dropStreamTable](https://docs.dolphindb.com/en/Functions/d/dropStreamTable.html)\n\n\n\n#### Syntax\n\ndropStreamTable(tableName, \\[force=false])\n\n#### Arguments\n\n**tableName** is a string indicating a stream table name.\n\n**force** (optional) is a Boolean scalar indicating whether to force the deletion of the stream table named *tableName* from the disk if it is not available in memory. The default value is false.\n\n#### Details\n\nDelete a stream table. If the table has been persisted to disk, the persisted data on disk will be deleted as well.\n\nTo delete a high-availability stream table, we can execute the command on any data/compute node in the Raft group. The high-availability stream table with the same name on other data nodes will be deleted as well.\n\nIf the table has been persisted to disk but not yet loaded into memory, setting the parameter *force* to true can delete the table directly from disk. Note that it can only be executed by an administrator.\n\n#### Examples\n\nDelete stream table:\n\n```\ncolNames = `timestamp`sym`qty`price\ncolTypes = [TIMESTAMP,SYMBOL,INT,DOUBLE]\nt=streamTable(1:0,colNames,colTypes)\nenableTableShareAndPersistence(t,`trades);\n\ndropStreamTable(`trades);\n```\n\nDelete a stream table that has been persisted to disk but not yet loaded into memory.\n\n```\ncolNames = `timestamp`sym`qty`price\ncolTypes = [TIMESTAMP,SYMBOL,INT,DOUBLE]\nt=streamTable(1:0,colNames,colTypes)\nenableTableShareAndPersistence(t,`trades);\n\n//delete an in-memory stream table\nundef(`trades,SHARED)\n\n//failed to delete a persisted stream table\ndropStreamTable(`trades)\n//dropStreamTable(\"trades\") => Can't find stream table trades\n\n//set force to true\ndropStreamTable(tableName=`trades,force=true)\n```\n\nDelete high-availability stream table:\n\n```\ncolNames = `timestamp`sym`qty`price\ncolTypes = [TIMESTAMP,SYMBOL,INT,DOUBLE]\nt=table(1:0,colNames,colTypes)\nhaStreamTable(11,t,`trades,100000);\n\ndropStreamTable(`trades);\n```\n"
    },
    "dropTable": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dropTable.html",
        "signatures": [
            {
                "full": "dropTable(dbHandle, tableName)",
                "name": "dropTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [dropTable](https://docs.dolphindb.com/en/Functions/d/dropTable.html)\n\n\n\n#### Syntax\n\ndropTable(dbHandle, tableName)\n\n#### Arguments\n\n**dnHandle** is a DolphinDB database handle.\n\n**tableName** is a string indicating a table name.\n\n#### Details\n\nDelete the specified table on disk. It can only be executed on a data node or compute node.\n\n#### Examples\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x)\ndb=database(\"dfs://rangedb\", RANGE,  0 5 10)\npt = db.createPartitionedTable(t, `pt, `ID)\npt.append!(t)\n\ndropTable(db,`pt);\n```\n"
    },
    "dumpHeapSample": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dumpHeapSample.html",
        "signatures": [
            {
                "full": "dumpHeapSample(filename)",
                "name": "dumpHeapSample",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    }
                ]
            }
        ],
        "markdown": "### [dumpHeapSample](https://docs.dolphindb.com/en/Functions/d/dumpHeapSample.html)\n\n\n\n#### Syntax\n\ndumpHeapSample(filename)\n\n#### Details\n\nThis function generates a snapshot of the current heap memory. It records the current memory usage, including allocated memory blocks, their sizes, and states. Only administrators can execute this function.\n\n#### Arguments\n\n**filename** is a string representing the path for the heap memory snapshot file.\n\n#### Examples\n\nRecommended workflow for memory usage analysis:\n\n1. Enable heap memory sampling: This can be done by setting the environment variable TCMALLOC\\_SAMPLE\\_PARAMETER to a value between 1 and 524288 (recommended: 524288) before starting DolphinDB; or by dynamically enabling it using `startHeapSample`.\n2. Execute `dumpHeapSample` before and after operations that may cause memory leaks, saving to two different files. Compare these files to confirm memory allocation and usage related to the operation.\n3. Disable heap memory sampling.\n\n```\nstartHeapSample(524288)\n​\ndumpHeapSample(\"/DolphinDB/Data/heap1\")\ndumpHeapSample(\"/DolphinDB/Data/heap2\")\n​\nstopHeapSample()\n```\n\nRelated functions: [startHeapSample](https://docs.dolphindb.com/en/Functions/s/startHeapSample.html), [stopHeapSample](https://docs.dolphindb.com/en/Functions/s/stopHeapSample.html)\n"
    },
    "duration": {
        "url": "https://docs.dolphindb.com/en/Functions/d/duration.html",
        "signatures": [
            {
                "full": "duration(X)",
                "name": "duration",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [duration](https://docs.dolphindb.com/en/Functions/d/duration.html)\n\n\n\n#### Syntax\n\nduration(X)\n\n#### Arguments\n\n**X** is a STRING scalar. It is composed of an integer and a unit of time (y, M, w, d, B, H, m, s, ms, us, ns). For examples: \"2y\", \"3M\", \"30m\", \"100ms\".\n\n**X** is a STRING scalar composed of an integer and a unit of time. It supports the following units of time: y, M, w, d, B, H, m, s, ms, us, ns, and trading calendar identifier consisting of four capital letters. For example, *X* can be \"2y\", \"3M\", \"30m\", \"100ms\", and \"3XNYS\". Note that function `duration` won't verify whether the trading calendar file is stored in *marketHolidayDir*.\n\n#### Details\n\nConvert *X* to DURATION type which indicates the length of a time interval.\n\nNote:\n\n* The unit of the time interval used for grouping cannot be more granular than the unit of the temporal column.\n\n* Time units are case-sensitive, for example, \"M\" means month and \"m\" means minute. If the unit of the time interval is M, use function [month](https://docs.dolphindb.com/en/Functions/m/month.html) to convert the time column values to months.\n\n* Data of DURATION type cannot participate in calculations. For example, comparisons between DURATION values (such as `duration(`20ms) >= duration(`10ms)`) are not supported.\n\n#### Examples\n\n```\ny=duration(\"20H\")\ny\n// output\n20H\n\ntypestr(y)\n// output\nDURATION\n\nduration\\(\"3XNYS\"\\)\n// output\n3XNYS\n```\n\nIn function bar, we can use a number followed by a time unit to indicate a duration.\n\n```\nt=table(take(2018.01.01T01:00:00+1..10,10) join take(2018.01.01T02:00:00+1..10,10) join take(2018.01.01T08:00:00+1..10,10) as time, rand(1.0, 30) as x)\nselect max(x) from t group by bar(time, 5);\n```\n\n| bar\\_time           | max\\_x |\n| ------------------- | ------ |\n| 2018.01.01T01:00:00 | 0.8824 |\n| 2018.01.01T01:00:05 | 0.8027 |\n| 2018.01.01T01:00:10 | 0.572  |\n| 2018.01.01T02:00:00 | 0.8875 |\n| 2018.01.01T02:00:05 | 0.8542 |\n| 2018.01.01T02:00:10 | 0.4287 |\n| 2018.01.01T08:00:00 | 0.9294 |\n| 2018.01.01T08:00:05 | 0.9804 |\n| 2018.01.01T08:00:10 | 0.2147 |\n\n```\nselect max(x) from t group by bar(time, 1m);\n```\n\n| bar\\_time           | max\\_x |\n| ------------------- | ------ |\n| 2018.01.01T01:00:00 | 0.8824 |\n| 2018.01.01T02:00:00 | 0.8875 |\n| 2018.01.01T08:00:00 | 0.9804 |\n\nRelated information: [Trading Calendar](https://docs.dolphindb.com/en/Tutorials/trading_calendar.html)\n"
    },
    "dynamicGroupCumcount": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dynamicGroupCumcount.html",
        "signatures": [
            {
                "full": "dynamicGroupCumcount(membership, prevMembership, groupCount)",
                "name": "dynamicGroupCumcount",
                "parameters": [
                    {
                        "full": "membership",
                        "name": "membership"
                    },
                    {
                        "full": "prevMembership",
                        "name": "prevMembership"
                    },
                    {
                        "full": "groupCount",
                        "name": "groupCount"
                    }
                ]
            }
        ],
        "markdown": "### [dynamicGroupCumcount](https://docs.dolphindb.com/en/Functions/d/dynamicGroupCumcount.html)\n\n\n\n#### Syntax\n\ndynamicGroupCumcount(membership, prevMembership, groupCount)\n\n#### Arguments\n\n**membership** is a vector, of which elements must be integers in the interval \\[0, groupCount), indicating tags for the record at the current timestamp.\n\n**prevMembership** is a vector of INT type, of which elements can be NULL values (the first record of each group), indicating tags for the record at the previous timestamp of *membership*.\n\n**groupCount** is an integer in the interval \\[2, 8], indicating the number of tags.\n\n#### Details\n\nThe attribute and category of an event are fixed in most cases. In some scenarios, the category of an event, however, will change dynamically. For example, when processing real-time tick data, users may judge whether an order (attribute) is a large or a small one (category) based on the cumulative volume to analyze capital flow. As real-time data continues to flow in, trading volume keeps increasing, and thus a small order may change to a large one.\n\nFunction `dynamicGroupCumcount` is used in such scenarios to count the number of dynamically cumulative events of different categories.\n\nDetails are as follows:\n\n* If *membership = prevMembership*, count remains unchanged.\n\n* If *membership ≠ prevMembership*, the count of corresponding group of *membership* increases by 1, and the count of corresponding group of *prevMembership* decreases by 1.\n\n* If *prevMembership* is a NULL value (the first record of each group), the count of corresponding group of *membership* increases by 1.\n\nIt returns a tuple of length *groupCount*. Each element is a vector of the same length as *membership*, which sequentially records the cumulative count of each tag.\n\n**Note**: The index of the tuple matches the tags, which means that the count of tag 0 is output to the vector at index 0 of the tuple.\n\n#### Examples\n\nData preprocessing:\n\n```\n// Define a function to generate tags\ndef tag_func(v){\n\n  return iif(v <= 5, 0, iif(v <= 10 and v > 5, 1, 2))\n# output\n}\n// original table\ntime = take(2022.01.01T09:00:00.000 + 1..3, 6)\nsym=`st0`st0`st0`st1`st1`st1\norderNo = `10001`10002`10001`10002`10003`10002\nvolume = 2 4 6 3 2 9\nt = table(sym, time, orderNo, volume)\n\n// calculate cumulative sums and tag the results\nt1 = select *, cumsum(volume) as sumVolume from t context by sym, orderNo\nt2 = lj(t, t1,`sym`time`orderNo)\nt3 = select sym, time, orderNo, volume, sumVolume, tag_func(sumVolume) as groupId from t2\n```\n\nFor historical data, you can use SQL statements to calculate the cumulative count for each group:\n\n```\nt4 = select sym, time, orderNo, prev(groupId) as prevGroupId from t3 context by sym,orderNo\nt5 = lj(t3, t4,`sym`time`orderNo)\nre = select sym, time, orderNo, dynamicGroupCumcount(groupId, prevGroupId, 3) as `groupId0`groupId1`groupId2 from t5 context by sym\nre\n```\n\n| sym | time                    | orderNo | groupId0 | groupId1 | groupId2 |\n| --- | ----------------------- | ------- | -------- | -------- | -------- |\n| st0 | 2022.01.01T09:00:00.001 | 10001   | 1        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.002 | 10002   | 2        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.003 | 10001   | 1        | 1        | 0        |\n| st1 | 2022.01.01T09:00:00.001 | 10002   | 1        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.002 | 10003   | 2        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.003 | 10002   | 1        | 0        | 1        |\n\nFor real-time data, you can use reactive state engine to calculate the cumulative count for each group:\n\n```\nresult = table(1000:0, `sym`time`orderNo`groupId0`groupId1`groupId2, [SYMBOL, TIME, SYMBOL,INT,INT,INT])\nfactor0 = [<time>,  <prev(groupId) as prevGroupId>, <groupId>, <volume>]\nfactor1 = [<time>, <orderNo>, <dynamicGroupCumcount(groupId, prevGroupId, 3)>]\ndm1 = table(1000:0, `sym`time`orderNo`volume`sumVolume`groupId, [SYMBOL, TIME, SYMBOL,INT, INT,INT])\ndm2 = table(1000:0, `sym`orderNo`time`prevGroupId`groupId`volume, [SYMBOL, SYMBOL, TIME, INT,INT,INT])\nres1 = createReactiveStateEngine(name=\"reactive_ccnt\", metrics =factor1, dummyTable=dm2, outputTable=result, keyColumn=`sym, keepOrder=true)\nres0 = createReactiveStateEngine(name=\"reactive_prev\", metrics =factor0, dummyTable=dm1, outputTable=res1, keyColumn=`sym`orderNo, keepOrder=true)\nres0.append!(t3)\n\nselect * from result\n```\n\n| sym | time                    | orderNo | groupId0 | groupId1 | groupId2 |\n| --- | ----------------------- | ------- | -------- | -------- | -------- |\n| st0 | 2022.01.01T09:00:00.001 | 10001   | 1        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.002 | 10002   | 2        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.003 | 10001   | 1        | 1        | 0        |\n| st1 | 2022.01.01T09:00:00.001 | 10002   | 1        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.002 | 10003   | 2        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.003 | 10002   | 1        | 0        | 1        |\n\n```\ndropStreamEngine(\"reactive_ccnt\")\ndropStreamEngine(\"reactive_prev\")\n```\n\nRelated function: [dynamicGroupCumsum](https://docs.dolphindb.com/en/Functions/d/dynamicGroupCumsum.html)\n"
    },
    "dynamicGroupCumsum": {
        "url": "https://docs.dolphindb.com/en/Functions/d/dynamicGroupCumsum.html",
        "signatures": [
            {
                "full": "dynamicGroupCumsum(cumValue, prevCumValue, membership, prevMembership, groupCount)",
                "name": "dynamicGroupCumsum",
                "parameters": [
                    {
                        "full": "cumValue",
                        "name": "cumValue"
                    },
                    {
                        "full": "prevCumValue",
                        "name": "prevCumValue"
                    },
                    {
                        "full": "membership",
                        "name": "membership"
                    },
                    {
                        "full": "prevMembership",
                        "name": "prevMembership"
                    },
                    {
                        "full": "groupCount",
                        "name": "groupCount"
                    }
                ]
            }
        ],
        "markdown": "### [dynamicGroupCumsum](https://docs.dolphindb.com/en/Functions/d/dynamicGroupCumsum.html)\n\n\n\n#### Syntax\n\ndynamicGroupCumsum(cumValue, prevCumValue, membership, prevMembership, groupCount)\n\n#### Arguments\n\n**cumValue** is a numeric vector that records the cumulative value of the event at the current timestamp.\n\n**prevCumValue** is a numeric vector, of which elements can be NULL values (the first record of each group), indicating the cumulative value of the event at the previous timestamp of *cumValue*.\n\n**membership** is a vector of INT type, of which elements must be integers in the interval \\[0, groupCount), indicating tags for records at the current timestamp.\n\n**prevMembership** is a vector of INT type, of which elements can be NULL value (the first record of each group), indicating tags for records at the previous timestamp of *membership*.\n\n**groupCount** is an integer in the interval \\[2, 8], indicating the number of tags.\n\n#### Details\n\nThe attribute and category of an event are fixed in most cases. In some scenarios, the category of an event, however, will change dynamically. For example, when processing real-time tick data, users may judge whether an order (attribute) is a large or a small one (category) based on the cumulative volume to analyze capital flow. As real-time data continues to flow in, trading volume keeps increasing, and thus a small order may change to a large one.\n\nFunction `dynamicGroupCumsum` is used in such scenarios to obtain the cumulative sum of an indicator for events of different categories.\n\nDetails are as follows:\n\n* If *membership = prevMembership*, count remains unchanged.\n\n* If *membership ≠ prevMembership*, the count of corresponding group of *membership* increases by *cumValue*, and the count of corresponding group of *prevMembership* decreases by *preCumValue*.\n\n* If *prevMembership* is a NULL value (the first record of each group), the count of corresponding group of *membership* increases by *cumValue*.\n\nIt returns a tuple of length *groupCount*. Each element is a vector of the same length as *membership*, which sequentially records the cumulative sum of an indicator (*cumValue*) for each tag.\n\n**Note**: The index of the tuple matches the tags, which means that the count of tag 0 is output at index 0 of the tuple.\n\n#### Examples\n\nData preparation:\n\n```\n// Define a function to generate tags\ndef tag_func(v){\n\n  return iif(v <= 5, 0, iif(v <= 10 and v > 5, 1, 2))\n# output\n}\n// original table\ntime = take(2022.01.01T09:00:00.000 + 1..3, 6)\nsym=`st0`st0`st0`st1`st1`st1\norderNo = `10001`10002`10001`10002`10003`10002\nvolume = 2 4 6 3 2 9\nt = table(sym, time, orderNo, volume)\n\n// calculate cumulative sums and tag the results\nt1 = select *, cumsum(volume) as sumVolume from t context by sym, orderNo\nt2 = lj(t, t1,`sym`time`orderNo)\nt3 = select sym, time, orderNo, volume, sumVolume, tag_func(sumVolume) as groupId from t2\n```\n\nFor historical data, you can use SQL statement to calculate the cumulative volume for each group:\n\n```\nt4 = select sym, time, orderNo, prev(groupId) as prevGroupId, groupId, prev(sumVolume) as prevSumVolume, sumVolume from t3 context by sym,orderNo\nt5 = lj(t3, t4,`sym`time`orderNo)\nre = select sym, time, orderNo, dynamicGroupCumsum(sumVolume, prevSumVolume, groupId, prevGroupId, 3) as `groupId0`groupId1`groupId2 from t5 context by sym\nre\n```\n\n| sym | time                    | orderNo | groupId0 | groupId1 | groupId2 |\n| --- | ----------------------- | ------- | -------- | -------- | -------- |\n| st0 | 2022.01.01T09:00:00.001 | 10001   | 2        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.002 | 10002   | 6        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.003 | 10001   | 4        | 8        | 0        |\n| st1 | 2022.01.01T09:00:00.001 | 10002   | 3        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.002 | 10003   | 5        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.003 | 10002   | 2        | 0        | 12       |\n\nFor real-time data, you can use reactive state engine to calculate the cumulative volume for each group:\n\n```\nresult = table(1000:0, `sym`time`orderNo`groupId0`groupId1`groupId2, [SYMBOL, TIME, SYMBOL,INT,INT,INT])\nfactor0 = [ <time>, <prev(groupId) as prevGroupId>, <groupId>, <prev(sumVolume) as prevSumVolume>, <sumVolume>]\nfactor1 = [<time>, <orderNo>, <dynamicGroupCumsum(sumVolume, prevSumVolume, groupId, prevGroupId, 3)>]\ndm1 = table(1000:0, `sym`time`orderNo`volume`sumVolume`groupId, [SYMBOL, TIME, SYMBOL,INT, INT,INT])\ndm2 = table(1000:0, `sym`orderNo`time`prevGroupId`groupId`prevSumVolume`sumVolume, [SYMBOL, SYMBOL, TIME, INT, INT, INT, INT])\nres1 = createReactiveStateEngine(name=\"reactive_csum\", metrics =factor1, dummyTable=dm2, outputTable=result, keyColumn=`sym, keepOrder=true)\nres0 = createReactiveStateEngine(name=\"reactive_prev\", metrics =factor0, dummyTable=dm1, outputTable=res1, keyColumn=`sym`orderNo, keepOrder=true)\nres0.append!(t3)\n\nselect * from result\n```\n\n| sym | time                    | orderNo | groupId0 | groupId1 | groupId2 |\n| --- | ----------------------- | ------- | -------- | -------- | -------- |\n| st0 | 2022.01.01T09:00:00.001 | 10001   | 2        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.002 | 10002   | 6        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.003 | 10001   | 4        | 8        | 0        |\n| st1 | 2022.01.01T09:00:00.001 | 10002   | 3        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.002 | 10003   | 5        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.003 | 10002   | 2        | 0        | 12       |\n\n```\ndropStreamEngine(\"reactive_csum\")\ndropStreamEngine(\"reactive_prev\")\n```\n\nRelated function: [dynamicGroupCumcount](https://docs.dolphindb.com/en/Functions/d/dynamicGroupCumcount.html)\n"
    },
    "ffill!": {
        "url": "https://docs.dolphindb.com/en/Functions/f/ffill!.html",
        "signatures": [
            {
                "full": "ffill!(obj, [limit])",
                "name": "ffill!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ffill!](https://docs.dolphindb.com/en/Functions/f/ffill!.html)\n\n\n\n#### Syntax\n\nffill!(obj, \\[limit])\n\n#### Arguments\n\n**obj** is a vector/matrix/table.\n\n**limit** is a positive integer that specifies the number of NULL values to forward fill for each block of NULL values.\n\n#### Details\n\nIf *obj* is a vector, forward fill the NULL values in *obj* with the previous non-NULL value.\n\nIf *obj* is a matrix or a table, forward fill the NULL values in each column of *obj* with the previous non-NULL value.\n\n**Note:** The only difference between `ffill` and `ffill!` is that the latter assigns the result to *obj* and thus changing the value of *obj* after the execution.\n\n#### Examples\n\nExample 1\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.ffill!(); \nx; \n// The value of x is changed. \n[1,2,3,3,3,3,4,5,6]\n```\n\nExample 2: Specify parameter *limit* = 1. The first NULL value is filled.\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.ffill!(1);\n// output\n[1,2,3,3,,,4,5,6]\n```\n\nExample 3: Specify *obj* as a table.\n\n```\ndate=[2012.06.12,2012.06.12,2012.06.13,2012.06.14,2012.06.15]\nsym=[\"IBM\",\"MSFT\",\"IBM\",\"MSFT\",\"MSFT\"]\nprice=[40.56,26.56,,,50.76]\nqty=[2200,4500,,5600,]\ntimestamp=[09:34:07,09:35:26,09:36:42,09:36:51,09:36:59]\nt=table(date,timestamp,sym,price,qty);\nffill!(t); \nt;\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 40.56 | 2200 |\n| 2012.06.12 | 09:35:26  | MSFT | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  | 26.56 | 4500 |\n| 2012.06.14 | 09:36:51  | MSFT | 26.56 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 5600 |\n"
    },
    "ffill": {
        "url": "https://docs.dolphindb.com/en/Functions/f/ffill.html",
        "signatures": [
            {
                "full": "ffill(obj, [limit])",
                "name": "ffill",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ffill](https://docs.dolphindb.com/en/Functions/f/ffill.html)\n\n\n\n#### Syntax\n\nffill(obj, \\[limit])\n\n#### Arguments\n\n**obj** is a vector/matrix/table.\n\n**limit** is a positive integer that specifies the number of NULL values to forward fill for each block of NULL values.\n\n#### Details\n\nIf *obj* is a vector, forward fill the NULL values in *obj* with the previous non-NULL value.\n\nIf *obj* is a matrix or a table, forward fill the NULL values in each column of *obj* with the previous non-NULL value.\n\nThis operation creates a new vector and does not change the input vector. Function [ffill!](https://docs.dolphindb.com/en/Functions/f/ffill!.html) changes the input vector.\n\n**Note:** The only difference between `ffill` and `ffill!` is that the latter assigns the result to *obj* and thus changing the value of *obj* after the execution.\n\n#### Examples\n\nExample 1\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.ffill();\n// output\n[1,2,3,3,3,3,4,5,6]\n\nx;\n// The value of x is not changed.\n[1,2,3,,,,4,5,6]\n```\n\nExample 2: Specify parameter *limit*.\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.ffill(1);\n// output\n[1,2,3,3,,,4,5,6]\n                \nx.ffill(2);\nx;\n// output\n[1,2,3,3,3,,4,5,6]\n```\n\nExample 3: Specify *obj* as a table.\n\n```\ndate=[2012.06.12,2012.06.12,2012.06.13,2012.06.14,2012.06.15]\nsym=[\"IBM\",\"MSFT\",\"IBM\",\"MSFT\",\"MSFT\"]\nprice=[40.56,26.56,,,50.76]\nqty=[2200,4500,,5600,]\ntimestamp=[09:34:07,09:35:26,09:36:42,09:36:51,09:36:59]\nt=table(date,timestamp,sym,price,qty);\nt;\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 40.56 | 2200 |\n| 2012.06.12 | 09:35:26  | MSFT | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  |       |      |\n| 2012.06.14 | 09:36:51  | MSFT |       | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 |      |\n\n```\nt.ffill();\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 40.56 | 2200 |\n| 2012.06.12 | 09:35:26  | MSFT | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  | 26.56 | 4500 |\n| 2012.06.14 | 09:36:51  | MSFT | 26.56 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 5600 |\n\n```\nselect date, timestamp, sym, price.ffill() as price, qty.ffill() as qty from t context by sym;\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 40.56 | 2200 |\n| 2012.06.13 | 09:36:42  | IBM  | 40.56 | 2200 |\n| 2012.06.12 | 09:35:26  | MSFT | 26.56 | 4500 |\n| 2012.06.14 | 09:36:51  | MSFT | 26.56 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 5600 |\n"
    },
    "fflush": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fflush.html",
        "signatures": [
            {
                "full": "fflush(obj)",
                "name": "fflush",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    }
                ]
            }
        ],
        "markdown": "### [fflush](https://docs.dolphindb.com/en/Functions/f/fflush.html)\n\n\n\n#### Syntax\n\nfflush(obj)\n\n#### Arguments\n\n**obj** is a file handle. Open a file with function [file](https://docs.dolphindb.com/en/Functions/f/file.html) to obtain the file handle.\n\n#### Details\n\nWrite the buffered data to the file system in the operating system. It must be executed by a logged-in user.\n\nNote:\n\n1. It is recommended to `close` the file or `fflush` the buffered data to the file after writing to it, otherwise the data may be lost.\n\n2. This command does not synchronize data to the disk. Data loss may occur in case of unexpected crash.\n\n#### Examples\n\n```\nrows = 10\nt=table(1..rows as id, 1..rows+100 as value)\nf1=file(\"test.bin\", \"w\")\nf1.writeRecord(t)\n//The file was not closed and the buffered data was not flushed to the file system, so the file read here does not contain the newly written data.\nt1 = table(rows:0,`id`value,`INT`INT)\nf=file('test.bin')\nf.readRecord!(t1)\n::readRecord!(f, t1) => Reach the end of a file or a buffer.\n\n//call fflush\nf1.fflush()\n\nt1 = table(rows:0,`id`value,`INT`INT)\nf=file('test.bin')\nf.readRecord!(t1)\n10\n```\n"
    },
    "file": {
        "url": "https://docs.dolphindb.com/en/Functions/f/file.html",
        "signatures": [
            {
                "full": "file(name, [mode=\"r\"], [isLittleEndian])",
                "name": "file",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[mode=\"r\"]",
                        "name": "mode",
                        "optional": true,
                        "default": "\"r\""
                    },
                    {
                        "full": "[isLittleEndian]",
                        "name": "isLittleEndian",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [file](https://docs.dolphindb.com/en/Functions/f/file.html)\n\n\n\n#### Syntax\n\nfile(name, \\[mode=\"r\"], \\[isLittleEndian])\n\n#### Arguments\n\n**name** is a string indicating a file name.\n\n**mode** is a string indicating the opening mode.\n\n**isLittleEndian** (optional) is a Boolean value indicating if the file adopts the little endian format.\n\n#### Details\n\nOpen a file with a given mode. It must be executed by a logged-in user.\n\nThe opening mode could be one of the 6 modes: \"r\", \"r+\", \"w\", \"w+\", \"a\", and \"a+\".\n\n* \"r\" (default): Open text file for reading. The cursor is positioned at the beginning of the file.\n* \"r+\": Open for reading and writing. The cursor is positioned at the beginning of the file.\n* \"w\": Truncate file to zero length or create a text file for writing. The cursor is positioned at the beginning of the file.\n* \"w+\": Open for reading and writing. The file is created if it does not exist, otherwise it is truncated. The cursor is positioned at the beginning of the file.\n* \"a\": Open for writing. The file is created if it does not exist. The cursor is positioned at the end of the file. Subsequent writes to the file will always end up at the end of file.\n* \"a+\": Open for reading and writing. The file is created if it does not exist. The cursor is positioned at the end of the file. Subsequent writes to the file will always end up at the end of file.\n\nUse the [close](https://docs.dolphindb.com/en/Functions/c/close.html) function to close an opened file handle.\n\n#### Examples\n\n```\nfout=file(\"test.txt\",\"w\");\nfout.writeLine(\"hello world!\");\n// output\n1\nfout.close();\n\nfin = file(\"test.txt\");\nprint fin.readLine();\n// output\nhello world!\nfin.close();\n```\n"
    },
    "files": {
        "url": "https://docs.dolphindb.com/en/Functions/f/files.html",
        "signatures": [
            {
                "full": "files(directory, [pattern])",
                "name": "files",
                "parameters": [
                    {
                        "full": "directory",
                        "name": "directory"
                    },
                    {
                        "full": "[pattern]",
                        "name": "pattern",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [files](https://docs.dolphindb.com/en/Functions/f/files.html)\n\n\n\n#### Syntax\n\nfiles(directory, \\[pattern])\n\n#### Arguments\n\n**directory** is a string indicating a directory path.\n\n**pattern** (optional) is a string indicating the file name pattern to be searched under the directory.\n\n#### Details\n\nIt must be executed by a logged-in user.\n\nIf *pattern* is not specified, return a table with descriptive information of the files and the sub-directories under directory.\n\nIf *pattern* is specified, return a table with descriptive information of the files and sub-directories that contain pattern in their names.\n\n#### Examples\n\n```\nfiles(\"D:/06_DolphinDB/01_App/DolphinDB_Win_V0.2\");\n```\n\n| filename                          | isDir | fileSize | lastAccessed  | lastModified  |\n| --------------------------------- | ----- | -------- | ------------- | ------------- |\n| LICENSE\\_AND\\_AGREEMENT.txt       | 0     | 22558    | 1495508675000 | 1483773234998 |\n| README\\_WIN.txt                   | 0     | 5104     | 1495508675000 | 1483866232680 |\n| server                            | 1     | 0        | 1496624932437 | 1496624932437 |\n| THIRD\\_PARTY\\_SOFTWARE\\_LICENS... | 0     | 8435     | 1495508675000 | 1483628426506 |\n\n```\nfiles(\"D:/06_DolphinDB/01_App/DolphinDB_Win_V0.2\", \"readme%\");\n```\n\n| filename        | isDir | fileSize | lastAccessed  | lastModified  |\n| --------------- | ----- | -------- | ------------- | ------------- |\n| README\\_WIN.txt | 0     | 5104     | 1495508675000 | 1483866232680 |\n\n```\nselect * from files(\"D:/06_DolphinDB/01_App/DolphinDB_Win_V0.2\") where filename like \"README%\";\n```\n\n| filename        | isDir | fileSize | lastAccessed  | lastModified  |\n| --------------- | ----- | -------- | ------------- | ------------- |\n| README\\_WIN.txt | 0     | 5104     | 1495508675000 | 1483866232680 |\n"
    },
    "fill!": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fill!.html",
        "signatures": [
            {
                "full": "fill!(obj, index, value)",
                "name": "fill!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "index",
                        "name": "index"
                    },
                    {
                        "full": "value",
                        "name": "value"
                    }
                ]
            }
        ],
        "markdown": "### [fill!](https://docs.dolphindb.com/en/Functions/f/fill!.html)\n\n\n\n#### Syntax\n\nfill!(obj, index, value)\n\n#### Arguments\n\n**obj** can be a vector, tuple, matrix, dictionary or table.\n\n**index**\n\n* If *obj* is a vector, tuple or matrix, *index* is an integer scalar/vector;\n* If *obj* is a dictionary, *index* is a string scalar/vector indicating dictionary keys;\n* If *obj* is a table, *index* is a string scalar/vector indicating column names.\n\n**value** is a scalar/vector.\n\n#### Details\n\nAssign *value* to the elements of *obj* at *index*. It is equivalent to `obj[index]=value`.\n\n#### Examples\n\nExample 1. vector\n\n```\na=[1,2,3,4];\nfill!(a,3,12);\na;\n// output\n[1,2,3,12]\n\nfill!(a,[0,1],[10,11]);\n// output\n[10,11,3,12]\n```\n\nExample 2. tuple\n\n```\na=([1,2,3],[\"a\",\"b\",\"c\"]);\nfill!(a,0,[4,2]);\na[0];\n[4,2]\n\n// Create a tuple with 20 elements. Each element is a NULL of floating type.\narray(ANY, 20).fill!(0:20, float());\n// which is equivalent to\nt = array(ANY, 20);\nt[0:20] = float()\n```\n\nExample 3. matrix\n\n```\nm=1..12$3:4;\nfill!(m,2,5);\nm;\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 4  | 5  | 10 |\n| 2  | 5  | 5  | 11 |\n| 3  | 6  | 5  | 12 |\n\n```\nfill!(m,[1,2],5);\nm;\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 5  | 5  | 10 |\n| 2  | 5  | 5  | 11 |\n| 3  | 5  | 5  | 12 |\n\n```\nfill!(m,(1,),9);\nm;\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 5  | 5  | 10 |\n| 9  | 9  | 9  | 9  |\n| 3  | 5  | 5  | 12 |\n\n```\nm.fill!((1,2),10).fill!((2,2),12);\nm;\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 5  | 5  | 10 |\n| 9  | 9  | 10 | 9  |\n| 3  | 5  | 12 | 12 |\n\nExample 4. table\n\n```\nt=table(1 2 3 as id,10.2 45.2 12.3 as val);\nfill!(t,`id,4 5 6);\nt;\n```\n\n| id | val  |\n| -- | ---- |\n| 4  | 10.2 |\n| 5  | 45.2 |\n| 6  | 12.3 |\n\n```\nfill!(t,`qty,452 142 48);\nt;\n```\n\n| id | val  | qty |\n| :- | :--- | :-- |\n| 4  | 10.2 | 452 |\n| 5  | 45.2 | 142 |\n| 6  | 12.3 | 48  |\n\nExample 5. dictionary\n\n```\nd=dict(`a`b`c,1 2 3);\nfill!(d,`a,4);\nd;\n// output\nc->3\na->4\nb->2\n```\n"
    },
    "find": {
        "url": "https://docs.dolphindb.com/en/Functions/f/find.html",
        "signatures": [
            {
                "full": "find(X, Y)",
                "name": "find",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [find](https://docs.dolphindb.com/en/Functions/f/find.html)\n\n\n\n#### Syntax\n\nfind(X, Y)\n\n#### Arguments\n\n**X** can be a vector, dictionary, in-memory table with one column, keyed table, or indexed table.\n\n**Y** can be a scalar, vector, matrix, tuple, dictionary, or table.\n\n#### Details\n\n* If *X* is a vector: for each element of *Y*, return the position of its first occurrence in vector X. If the element doesn't appear in X, return -1. (To find the positions of all occurences, please use function [at](https://docs.dolphindb.com/en/Functions/a/at.html).)\n* If *X* is a dictionary: for each element of *Y*, if it is a key in *X*, return the corresponding value in *X*; if it is not a key in *X*, return NULL.\n* If *X* is an in-memory table with one column: for each element of *Y*, return the position of its first occurrence in the column of *X*. If the element doesn't appear in *X*, return -1.Note the column cannot be of array vector form.\n* If *X* is a keyed table or indexed table: for each element of *Y*, return the position of its first occurrence in the key columns of *X*. If the element doesn't appear in the key columns of *X*, return -1.\n\nTo search for a small amount of data in a sorted vector, we recommend to use function [binsrch](https://docs.dolphindb.com/en/Functions/b/binsrch.html).\n\n#### Examples\n\nWhen *X* is a vector:\n\n```\nfind(7 3 3 5, 3);\n// output\n1\n\nat(7 3 3 5 == 3);\n// output\n[1,2]\n\n(7 3 3 5 6).find(2 4 5);\n// output\n[-1,-1,3]\n```\n\nWhen *X* is a dictionary:\n\n```\nz=dict(1 2 3,4.5 6.6 3.2);\nz;\n// output\n3->3.2\n1->4.5\n2->6.6\n\nfind(z,3);\n// output\n3.2\nfind(z,5);\n// output\n00F\n```\n\nWhen *X* is an in-memory table with one column:\n\n```\nt = table(1 3 5 7 9 as id)\nfind(t, 2 3)\n// output\n[-1,1]\n```\n\nWhen *X* is a keyed table or an indexed table:\n\n```\nkt = keyedTable(`name`id,1000:0,`name`id`age`department,[STRING,INT,INT,STRING])\ninsert into kt values(`Tom`Sam`Cindy`Emma`Nick, 1 2 3 4 5, 30 35 32 25 30, `IT`Finance`HR`HR`IT)\nfind(kt,(`Emma`Sam, 4 1));\n// output\n[3,-1]\n\nt1 = indexedTable(`sym`side, 10000:0, `sym`side`price`qty, [SYMBOL,CHAR,DOUBLE,INT])\ninsert into t1 values(`IBM`MSFT`GOOG, ['B','S','B'], 10.01 10.02 10.03, 10 10 20)\nfind(t1, (`GOOG`MSFT, ['B','S']))\n// output\n[2,1]\n```\n"
    },
    "first": {
        "url": "https://docs.dolphindb.com/en/Functions/f/first.html",
        "signatures": [
            {
                "full": "first(X)",
                "name": "first",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [first](https://docs.dolphindb.com/en/Functions/f/first.html)\n\n\n\n#### Syntax\n\nfirst(X)\n\nor\n\nfirst X\n\n#### Arguments\n\n**X** can be a scalar, pair, vector, matrix or table.\n\n#### Details\n\nReturn the first element of a vector, or the first row of a matrix or table.\n\nIf the first element is NULL, the function returns NULL. To get the first non-NULL element, use [firstNot](https://docs.dolphindb.com/en/Functions/f/firstNot.html).\n\n#### Examples\n\n```\nfirst(`hello `world);\n// output\nhello\n\nfirst(1..10);\n// output\n1\n\nm = matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nfirst(m);\n// output\n[1,4]\n```\n\nRelated function: [last](https://docs.dolphindb.com/en/Functions/l/last.html)\n"
    },
    "firstHit": {
        "url": "https://docs.dolphindb.com/en/Functions/f/firstHit.html",
        "signatures": [
            {
                "full": "firstHit(func, X, target)",
                "name": "firstHit",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "target",
                        "name": "target"
                    }
                ]
            }
        ],
        "markdown": "### [firstHit](https://docs.dolphindb.com/en/Functions/f/firstHit.html)\n\n\n\n#### Syntax\n\nfirstHit(func, X, target)\n\n#### Arguments\n\n**func** can only be the following operators: >, >=, <, <=, !=, <>, ==.\n\n**X** is a vector/matrix/table.\n\n**target** is a scalar of the same type as *X* indicating the value to be compared with *X*.\n\n#### Details\n\nReturn the first element in *X* that satisfies the condition `X func target` (e.g. X>5). If no element in *X* satisfies the condition, return a NULL vlaue.\n\nNULL values are ignored in `firstHit`. Use [firstNot](https://docs.dolphindb.com/en/Functions/f/firstNot.html) to find the first non-NULL value.\n\n#### Examples\n\n```\nX = NULL 3.2 4.5 1.2 NULL 7.8 0.6 9.1\nfirstHit(<, X, 2.5)\n// output\n1.2\n\n// return null value if no element satisfies the condition\nfirstHit(>, X, 10.0)\n// output\nNULL\n```\n\nRelated Function: [ifirstHit](https://docs.dolphindb.com/en/Functions/i/ifirstHit.html)\n"
    },
    "firstNot": {
        "url": "https://docs.dolphindb.com/en/Functions/f/firstNot.html",
        "signatures": [
            {
                "full": "firstNot(X, [k])",
                "name": "firstNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k]",
                        "name": "k",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [firstNot](https://docs.dolphindb.com/en/Functions/f/firstNot.html)\n\n\n\n#### Syntax\n\nfirstNot(X, \\[k])\n\n#### Arguments\n\n**X** can be a scalar, pair, vector, matrix or table.\n\n**k** (optional) is a scalar.\n\n#### Details\n\nIf *X* is a vector:\n\n* If *k* is not specified: return the first element of *X* that is not NULL.\n\n* If *k* is specified: return the first element of *X* that is neither *k* nor NULL.\n\nIf *X* is a matrix or table, conduct the aforementioned calculation within each column of *X*. The result is a vector.\n\n#### Examples\n\n```\nfirstNot(0 0 0 6 1, 0);\n// output\n6\n\nfirstNot(NULL 0 3 2 1, 0);\n// output\n3\n\nfirstNot(NULL 0 1 6);\n// output\n0\n\nt=table(1 1 1 1 1 2 2 2 2 2 as id, 0 0 0 2 1 NULL NULL 0 0 3 as x);\nt;\n```\n\n| id | x |\n| -- | - |\n| 1  | 0 |\n| 1  | 0 |\n| 1  | 0 |\n| 1  | 2 |\n| 1  | 1 |\n| 2  |   |\n| 2  |   |\n| 2  | 0 |\n| 2  | 0 |\n| 2  | 3 |\n\n```\nselect firstNot(x, 0) from t group by id;\n```\n\n| id | firstNot\\_x |\n| -- | ----------- |\n| 1  | 2           |\n| 2  | 3           |\n\n```\nm=matrix(0 NULL 1 2 3, NULL 2 NULL 0 3);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 0  | 2  |\n| 1  |    |\n| 2  | 0  |\n| 3  | 3  |\n\n```\nfirstNot(m, 0);\n// output\n[1,2]\n```\n"
    },
    "fixedLengthArrayVector": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fixedLengthArrayVector.html",
        "signatures": [
            {
                "full": "fixedLengthArrayVector(args…)",
                "name": "fixedLengthArrayVector",
                "parameters": [
                    {
                        "full": "args…",
                        "name": "args…"
                    }
                ]
            }
        ],
        "markdown": "### [fixedLengthArrayVector](https://docs.dolphindb.com/en/Functions/f/fixedLengthArrayVector.html)\n\n\n\n#### Syntax\n\nfixedLengthArrayVector(args…)\n\n#### Arguments\n\n**args** can be vectors, tuples, fixed length array vectors, matrices, or tables. All *args* must be of the same data type supported by [array vectors](https://docs.dolphindb.com/en/Programming/DataTypesandStructures/DataForms/Vector/arrayVector.html).\n\n#### Details\n\nConcatenate vectors, matrices, and tables and return an array vector.\n\nNote: The length of a vector or each vector in a tuple, and the number of rows of a matrix or table must be the same.\n\nThe following figure describes how different data forms are concatenated into an array vector based on Example 1.\n\n![](https://docs.dolphindb.com/en/images/fixedLengthArrayVector.png)\n\n#### Examples\n\nExample 1.\n\n```\nvec = 1 5 3\ntp = [3 4 5, 4 5 6]\nm =  matrix(5 0 7, 7 6 9, 1 9 0)\ntb = table(6 9 4 as v1, 1 4 3 as v2)\nf = fixedLengthArrayVector(vec, tp, m, tb)\nf;\n// output\n[[1,3,4,5,7,1,6,1],[5,4,5,0,6,9,9,4],[3,5,6,7,9,0,4,3]]\n\ntypestr(f);\n// output\nFAST INT[] VECTOR\n```\n\nExample 2. store multiple columns as one column\n\n```\nlogin(\"admin\",\"123456\")\nsyms=\"A\"+string(1..30)\ndatetimes=2019.01.01T00:00:00..2019.01.31T23:59:59\nn=200\nif(existsDatabase(\"dfs://stock\")) {\n      dropDatabase(\"dfs://stock\")\n}\ndb=database(\"dfs://stock\", RANGE, cutPoints(syms,3), engine=\"TSDB\");\nt=table(take(datetimes,n) as trade_time, take(syms,n) as sym,take(500+rand(10.0,n), n) as bid1, take(500+rand(20.0,n),n) as bid2)\nt1=select trade_time, sym, fixedLengthArrayVector(bid1,bid2) as bid from t\n\nquotes=db.createPartitionedTable(t1,`quotes,`sym, sortColumns=`sym`trade_time).append!(t1)\nselect * from quotes\n```\n\n| trade\\_time         | sym | bid                      |\n| ------------------- | --- | ------------------------ |\n| 2019.01.01T00:00:00 | A1  | \\[503.111142,507.55833]  |\n| 2019.01.01T00:00:30 | A1  | \\[502.991382,501.734092] |\n| 2019.01.01T00:01:00 | A1  | \\[500.790709,509.200963] |\n| 2019.01.01T00:01:30 | A1  | \\[501.127932,507.972508] |\n| 2019.01.01T00:02:00 | A1  | \\[500.678614,514.947117] |\n\nYou can obtain a bid price by specifying the index. Applying a function to the bid column is equivalent to calculating on all bid prices.\n\n```\nselect avg(bid[0]) as avg_bid1, avg(bid[1]) as avg_bid2, avg(bid) as avg_bid from quotes\n```\n\n| avg\\_bid1 | avg\\_bid2 | avg\\_bid |\n| --------- | --------- | -------- |\n| 505.0263  | 509.2912  | 507.16   |\n\nNormally the field names of quotes are composed of the quote type and a number. To store multiple quote prices into an array vector, you can write the script as shown below:\n\n```\n// generate 50 bid/ask prices\nn = 200\nt=table(take(datetimes,n) as trade_time, take(syms,n) as sym)\nfor(i  in 1:51){\n\n      t[\"bid\"+string(i)] = take(500+rand(10.0,n), n)\n}\n\n// store the data into an array vector\nt[\"bid\"]=fixedLengthArrayVector(t[\"bid\"+string(1..50)])\nt1=select trade_time, sym, bid from t\n```\n\nTo improve the performance, you can use it with function [unifiedCall](https://docs.dolphindb.com/en/Functions/Templates/unifiedCall.html).\n\n```\nt[\"bid\"]=unifiedCall(fixedLengthArrayVector, t[\"bid\"+string(1..50)])\nt1=select trade_time, sym, bid from t\n```\n\nExample 3. Save 5 levels of quotes for exchanges A and B as array vectors, then concatenate them into an array vector.\n\n```\n// Generate 5 levels of quotes for exchanges A and B\nsyms = \"A\" + string(1..5)\ndatetimes = 2019.01.01T00:00:00..2019.01.31T23:59:59\nn = 10\nt1 = table(take(datetimes, n) as trade_time, take(syms, n) as sym)\nfor(i  in 1:6){\n      t1[\"bid\" + string(i)] = take(50 + rand(10.0, n), n)\n}\nt2 = table(take(datetimes, n) as trade_time, take(syms, n) as sym)\nfor(i  in 1:6){\n      t2[\"bid\" + string(i)] = take(50 + rand(10.0, n), n)\n}\n\n// save quotes as array vectors\nt1[\"bid\"] = fixedLengthArrayVector(t1[\"bid\" + string(1..5)])\nt2[\"bid\"] = fixedLengthArrayVector(t2[\"bid\" + string(1..5)])\n\n// concatenate fixed length array vectors\nt1[\"bid\"] = fixedLengthArrayVector(t1[\"bid\"], t2[\"bid\"])\nt3 = select trade_time, sym, bid from t1\n```\n\n| trade\\_time         | sym | bid                                                            |\n| ------------------- | --- | -------------------------------------------------------------- |\n| 2019.01.01T00:00:00 | A1  | \\[56.68,54.55,53.11,53.38,59.60,57.35,59.92,50.62,56.06,54.69] |\n| 2019.01.01T00:00:01 | A2  | \\[58.97,50.65,54.38,50.11,56.26,52.35,52.79,55.43,52.16,53.35] |\n| 2019.01.01T00:00:02 | A3  | \\[50.25,53.45,52.68,58.19,56.51,57.54,55.22,51.74,58.63,57.43] |\n| 2019.01.01T00:00:03 | A4  | \\[56.42,50.28,57.04,52.45,51.83,57.75,55.04,57.34,57.82,53.28] |\n| 2019.01.01T00:00:04 | A5  | \\[59.90,51.73,55.54,57.74,53.48,59.62,57.26,53.99,52.67,57.82] |\n| 2019.01.01T00:00:05 | A1  | \\[53.16,59.27,52.97,50.41,58.30,57.83,54.93,56.91,52.51,57.95] |\n| 2019.01.01T00:00:06 | A2  | \\[53.14,50.87,52.62,54.47,59.97,56.99,55.32,54.66,56.77,58.39] |\n| 2019.01.01T00:00:07 | A3  | \\[58.33,59.80,52.34,57.52,57.39,54.67,51.19,52.11,55.27,53.07] |\n| 2019.01.01T00:00:08 | A4  | \\[55.21,54.88,54.38,52.36,56.56,53.81,57.84,53.24,54.87,54.63] |\n| 2019.01.01T00:00:09 | A5  | \\[52.98,55.72,55.83,50.60,51.01,57.02,54.07,54.63,55.44,59.28] |\n"
    },
    "flatten": {
        "url": "https://docs.dolphindb.com/en/Functions/f/flatten.html",
        "signatures": [
            {
                "full": "flatten(X)",
                "name": "flatten",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [flatten](https://docs.dolphindb.com/en/Functions/f/flatten.html)\n\n\n\n#### Syntax\n\nflatten(X)\n\n#### Arguments\n\n**X** is a vector, tuple or matrix.\n\n#### Details\n\nConvert *X* into a 1D vector.\n\nNote that for a tuple:\n\n* If it contains tuple elements, `flatten` converts these elements to 1D vectors and retains other elements, returns a tuple.\n\n* If it does not contain tuple elements, `flatten` returns a 1D vector.\n\n#### Examples\n\nConvert a matrix into a vector.\n\n```\nm=1..10$5:2;\nflatten(m);\n// output: [1,2,3,4,5,6,7,8,9,10]\n```\n\nConvert a list of vectors into a vector.\n\n```\na=1..10;\nb = a cut 2;\nb;\n// output: ([1,2],[3,4],[5,6],[7,8],[9,10])\n\nflatten(b);\n// output: [1,2,3,4,5,6,7,8,9,10]\n\nx=flatten([1, [2,3]]);\nx;\n// output: [1,2,3]\n```\n\nConvert a tuple with tuple elements into a 1d vector, which involves several times of `flatten` operations:\n\n```\nlist = (1, (2, (3, 4, 5)), (6, 7), 8, [9])\nx1 = flatten(list)\nx1\n//(3, 4, 5) and (6, 7) are converted to 1D vectors\n// output:(1,(2,[3,4,5]),[6,7],8,[9])\n\nx2= flatten(x1)\nx2\n//(2,[3,4,5]) is converted to 1D vectors\n// output:(1,[2,3,4,5],[6,7],8,[9])\n\nx3= flatten(x2)\nx3\n// flatten to 1D vector\n// output:[1,2,3,4,5,6,7,8,9]\n```\n\nOr use `flatten` with `reduce` to get the result after iteration:\n\n```\nreduce(flatten, init=list)\n// output:[1,2,3,4,5,6,7,8,9]\n```\n"
    },
    "flip": {
        "url": "https://docs.dolphindb.com/en/Functions/f/flip.html",
        "signatures": [
            {
                "full": "transpose(X)",
                "name": "transpose",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [flip](https://docs.dolphindb.com/en/Functions/f/flip.html)\n\nAlias for [transpose](https://docs.dolphindb.com/en/Functions/t/transpose.html)\n\n\nDocumentation for the `transpose` function:\n### [transpose](https://docs.dolphindb.com/en/Functions/t/transpose.html)\n\n\n\n#### Syntax\n\ntranspose(X)\n\nAlias: flip\n\n#### Arguments\n\n**X** is a tuple/matrix/table/dictionary/array vector/columnar tuple. If *X* is an array vector or columnar tuple, the number of elements in each row must be the same.\n\n#### Details\n\n* If *X* is a tuple: all elements of the tuple must have the same length. Return a tuple of the same length as each element of *X*. The n-th element of the result is a vector composed of the n-th element of each element of *X*.\n\n* If *X* is a matrix: return the transpose of *X*.\n\n* If *X* is a table: convert *X* into an ordered dictionary. The dictionary keys are column names. Each dictionary value is a vector of the corresponding column.\n\n* If *X* is a dictionary: convert *X* into a table. The dictionary keys must be of STRING type, and dictionary values can be scalars or vectors of the same length. The column names of the table are the dictionary keys, and each column is the corresponding dictionary value.\n\n* If *X* is an array vector or columnar tuple: switch data from columns to rows, or vice versa.\n\n#### Examples\n\nExample 1: transpose of a tuple:\n\n```\nx=(`A`B`C,1 2 3);\nx.transpose();\n// output: ((\"A\",1),(\"B\",2),(\"C\",3))\n```\n\nExample 2: transpose of a matrix:\n\n```\nx=1..6 $ 3:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ntranspose x;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 2  | 3  |\n| 4  | 5  | 6  |\n\nExample 3: convert a table into a dictionary:\n\n```\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nt = table(timestamp, sym, qty, price);\nt;\n```\n\n| timestamp | sym | qty  | price  |\n| --------- | --- | ---- | ------ |\n| 09:34:07  | C   | 2200 | 49.6   |\n| 09:36:42  | MS  | 1900 | 29.46  |\n| 09:36:51  | MS  | 2100 | 29.52  |\n| 09:36:59  | MS  | 3200 | 30.02  |\n| 09:32:47  | IBM | 6800 | 174.97 |\n| 09:35:26  | IBM | 5400 | 175.23 |\n| 09:34:16  | C   | 1300 | 50.76  |\n| 09:34:26  | C   | 2500 | 50.32  |\n| 09:38:12  | C   | 8800 | 51.29  |\n\n```\ntranspose(t);\n/*\ntimestamp->[09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym->[C,MS,MS,MS,IBM,IBM,C,C,C]\nqty->[2200,1900,2100,3200,6800,5400,1300,2500,8800]\nprice->[49.6,29.46,29.52,30.02,174.97,175.23,50.76,50.32,51.29]\n*/\n```\n\nExample 4: convert a dictionary into a table:\n\n```\nz=dict(`id`val,[`a`b`c,1 2 3]);\nz;\n/*\nval->[1,2,3]\nid->[a,b,c]\n*/\ntranspose(z);\n```\n\n| val | id |\n| --- | -- |\n| 1   | a  |\n| 2   | b  |\n| 3   | c  |\n\n```\n// When the value of a dictionary contains both a scalar and a vector, the scalar will be automatically filled to match the length of the vector.\nz1=dict(`id`val,[`a,1 2 3]);\nz1;\ntranspose(z1)\n```\n\n| val | id |\n| --- | -- |\n| 1   | a  |\n| 2   | a  |\n| 3   | a  |\n"
    },
    "floor": {
        "url": "https://docs.dolphindb.com/en/Functions/f/floor.html",
        "signatures": [
            {
                "full": "floor(X)",
                "name": "floor",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [floor](https://docs.dolphindb.com/en/Functions/f/floor.html)\n\n\n\n#### Syntax\n\nfloor(X)\n\n#### Arguments\n\n**X** is a scalar, vector, or matrix.\n\n#### Details\n\nThe `floor` and [ceil](https://docs.dolphindb.com/en/Functions/c/ceil.html) functions map a real number to the largest previous and the smallest following integer, respectively. Function [round](https://docs.dolphindb.com/en/Functions/r/round.html) maps a real number to the largest previous or the smallest following integer with the round half up rule.\n\n#### Examples\n\n```\nfloor(2.1);\n// output\n2\nfloor(2.9);\n// output\n2\nfloor(-2.1);\n// output\n-3\n\nceil(2.1);\n// output\n3\nceil(2.9);\n// output\n3\nceil(-2.1);\n// output\n-2\n\nround(2.1);\n// output\n2\nround(2.9);\n// output\n3\nround(-2.1);\n// output\n-2\n```\n\n```\nm = 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9 10$2:5;\nm;\n```\n\n| #0  | #1  | #2  | #3  | #4  |\n| --- | --- | --- | --- | --- |\n| 1.1 | 3.3 | 5.5 | 7.7 | 9.9 |\n| 2.2 | 4.4 | 6.6 | 8.8 | 10  |\n\n```\nfloor(m);\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  |\n| 2  | 4  | 6  | 8  | 10 |\n"
    },
    "flushOLAPCache": {
        "url": "https://docs.dolphindb.com/en/Functions/f/flushOLAPCache.html",
        "signatures": [
            {
                "full": "flushOLAPCache()",
                "name": "flushOLAPCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [flushOLAPCache](https://docs.dolphindb.com/en/Functions/f/flushOLAPCache.html)\n\n\n\n#### Syntax\n\nflushOLAPCache()\n\nAlias: purgeCacheEngine\n\n#### Arguments\n\nNone\n\n#### Details\n\nFlush the data of completed transactions cached in the OLAP cache engine to the database. Specify the configuration parameter *chunkCacheEngineMemSize* and set *dataSync* = 1 before execution.\n"
    },
    "flushPKEYCache": {
        "url": "https://docs.dolphindb.com/en/Functions/f/flushPKEYCache.html",
        "signatures": [
            {
                "full": "flushPKEYCache()",
                "name": "flushPKEYCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [flushPKEYCache](https://docs.dolphindb.com/en/Functions/f/flushPKEYCache.html)\n\n\n\n#### Syntax\n\nflushPKEYCache()\n\n#### Arguments\n\nNone\n\n#### Details\n\nForcibly flush the completed transactions in the PKEY cache engine to the database and evict cached SYMBOL base.\n"
    },
    "flushTSDBCache": {
        "url": "https://docs.dolphindb.com/en/Functions/f/flushTSDBCache.html",
        "signatures": [
            {
                "full": "flushTSDBCache()",
                "name": "flushTSDBCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [flushTSDBCache](https://docs.dolphindb.com/en/Functions/f/flushTSDBCache.html)\n\n\n\n#### Syntax\n\nflushTSDBCache()\n\n#### Arguments\n\nNone\n\n#### Details\n\nForcibly flush the completed transactions cached in the TSDB cache engine to the database. Specify the configuration parameter *TSDBCacheEngineSize* before execution.\n"
    },
    "fmin": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fmin.html",
        "signatures": [
            {
                "full": "fmin(f, X0, [fargs], [xtol=0.0001], [ftol=0.0001], [maxIter], [maxFun])",
                "name": "fmin",
                "parameters": [
                    {
                        "full": "f",
                        "name": "f"
                    },
                    {
                        "full": "X0",
                        "name": "X0"
                    },
                    {
                        "full": "[fargs]",
                        "name": "fargs",
                        "optional": true
                    },
                    {
                        "full": "[xtol=0.0001]",
                        "name": "xtol",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[ftol=0.0001]",
                        "name": "ftol",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[maxFun]",
                        "name": "maxFun",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [fmin](https://docs.dolphindb.com/en/Functions/f/fmin.html)\n\n#### Syntax\n\nfmin(f, X0, \\[fargs], \\[xtol=0.0001], \\[ftol=0.0001], \\[maxIter], \\[maxFun])\n\n#### Details\n\nUse a Nelder-Mead simplex algorithm to find the minimum of function of one or more variables. This algorithm only uses function values, not derivatives or second derivatives.\n\n#### Arguments\n\n**func** is the objective function to be minimized. The function must return a numeric scalar.\n\n**X0** is a numeric scalar or vector indicating the initial guess.\n\n**xtol** (optional) is a positive number specifying the absolute error in xopt between iterations that is acceptable for convergence. The default value is\n\n**ftol** (optional) is a positive number specifying the absolute error in `func(xopt)` between iterations that is acceptable for convergence. The default value is 0.0001.\n\n**maxIter** (optional) is a non-negative integer indicating the maximum number of iterations to perform.\n\n**maxFun** (optional) is a non-negative integer indicating the maximum number of function evaluations to make.\n\nIt returns a dictionary with the following keys:\n\n* xopt: a vector of floating-point numbers, indicating parameter that minimizes function.\n\n* fopt: a floating-point number, indicating value of function at minimum: `fopt = f(xopt)`.\n\n* iterations: an integer, indicating number of iterations performed.\n\n* fcalls: an integer, indicating number of function calls made.\n\n* warnFlag: an integer that takes the following values\n\n  * 0: Optimization algorithm completed.\n\n  * 1: Maximum number of function evaluations made.\n\n  * 2: Maximum number of iterations reached.\n\n#### Examples\n\nIn the following example, we define a function `f(x)` and use the Nelder-Mead simplex algorithm to find its minimum value.\n\n```\ndef f(x) {return x*x}\nfmin(f, 1)\n/* Ouput:\nxopt->[-8.881784197001252E-16]\nfopt->7.888609052210119E-31\niterations->17\nfcalls->34\nwarnFlag->0\n*/\n```\n\n"
    },
    "fminBFGS": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fminBFGS.html",
        "signatures": [
            {
                "full": "fminBFGS(func, X0, [fprime], [gtol=1e-5], [norm], [epsilon], [maxIter], [xrtol=0], [c1=1e-4], [c2=0.9])",
                "name": "fminBFGS",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X0",
                        "name": "X0"
                    },
                    {
                        "full": "[fprime]",
                        "name": "fprime",
                        "optional": true
                    },
                    {
                        "full": "[gtol=1e-5]",
                        "name": "gtol",
                        "optional": true,
                        "default": "1e-5"
                    },
                    {
                        "full": "[norm]",
                        "name": "norm",
                        "optional": true
                    },
                    {
                        "full": "[epsilon]",
                        "name": "epsilon",
                        "optional": true
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[xrtol=0]",
                        "name": "xrtol",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[c1=1e-4]",
                        "name": "c1",
                        "optional": true,
                        "default": "1e-4"
                    },
                    {
                        "full": "[c2=0.9]",
                        "name": "c2",
                        "optional": true,
                        "default": "0.9"
                    }
                ]
            }
        ],
        "markdown": "### [fminBFGS](https://docs.dolphindb.com/en/Functions/f/fminBFGS.html)\n\n\n\n#### Syntax\n\nfminBFGS(func, X0, \\[fprime], \\[gtol=1e-5], \\[norm], \\[epsilon], \\[maxIter], \\[xrtol=0], \\[c1=1e-4], \\[c2=0.9])\n\n#### Arguments\n\n**func** is the function to minimize. The return value of the function must be numeric type.\n\n**X0** is a numeric scalar or vector indicating the initial guess.\n\n**fprime** (optional) is the gradient of *func*. If not provided, then *func* returns the function value and the gradient.\n\n**gtol** (optional) is a postive number. Iteration will terminates if gradient norm is less than *gtol*. The default value is 1e-5.\n\n**norm** (optional) is a positive number indicating the order of norm. Maximum norm is used by default.\n\n**epsilon** (optional) is a positive number indicating the step size used for numerically calculating the gradient. The default value is 1.4901161193847656e-08.\n\n**maxIter** (optional) is a non-negative integer indicating the maximum number of iterations. The default value is *X0 \\* 200*.\n\n**xrtol** (optional) is a non-negative number indicating the relative tolerance. Iteration will terminate if step size is less than `xk * xrtol` where *xk* is the current parameter vector. The default value is 0.\n\n**c1** (optional) is a number in (0,1) indicating the parameter for Armijo condition rule. The default value is 1e-4.\n\n**c2** (optional) is a number in (0,1) indicating the parameter for curvature condition rule. The default value is 0.9. Note that *c2* must be greater than *c1*.\n\n#### Details\n\nMinimize a function using the BFGS algorithm.\n\n**Return value**: A dictionary with the following members:\n\n* xopt: A floating-point vector indicating the parameters of the minimum.\n\n* fopt: A floating-point scalar indicating the value of *func* at the minimum, i.e., `fopt=func(xopt)`.\n\n* gopt: A floating-point vector indicating the gradient at the minimum. `gopt=func'(xopt)`, which should be near 0.\n\n* Hinv: A floating-point matrix representing the inverse Hessian matrix.\n\n* iterations: Number of iterations.\n\n* fcalls: Number of function calls made.\n\n* gcalls: Number of gradient calls made.\n\n* warnFlag: An integer, which can be\n\n  * 0: Minimization performed.\n\n  * 1: Maximum number of iterations exceeded.\n\n  * 2: Line search failed or extreme values encountered.\n\n  * 3: NULL result encountered.\n\n#### Examples\n\nMinimize function `quadratic_cost` using the BFGS algorithm:\n\n```\ndef quadratic_cost(x, Q) {\n\treturn dot(dot(x, Q), x)\n}\n\ndef quadratic_cost_grad(x, Q) {\n\treturn 2 * dot(Q, x)\n}\n\nx0 = [-3, -4]\ncost_weight = diag([1., 10.])\n\nfminBFGS(quadratic_cost{,cost_weight}, x0, quadratic_cost_grad{,cost_weight})\n```\n\nOutput:\n\n```\nfcalls->8\nwarnFlag->0\nxopt->[0.000002859166,-4.54371E-7]\nHinv->\n#0              #1             \n0.508225788096  -0.001307222772\n-0.001307222772 0.050207740748 \n\ngopt->[0.000005718332,-0.000009087439]\nfopt->1.0E-11\ngcalls->8\niterations->7\n```\n"
    },
    "fminLBFGSB": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fminLBFGSB.html",
        "signatures": [
            {
                "full": "fminLBFGSB(func, X0, [fprime], [bounds], [m=10], [factr=1e7], [pgtol=1e-5], [epsilon=1e-8], [maxIter=15000], [maxFun=15000], [maxLS=20])",
                "name": "fminLBFGSB",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X0",
                        "name": "X0"
                    },
                    {
                        "full": "[fprime]",
                        "name": "fprime",
                        "optional": true
                    },
                    {
                        "full": "[bounds]",
                        "name": "bounds",
                        "optional": true
                    },
                    {
                        "full": "[m=10]",
                        "name": "m",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[factr=1e7]",
                        "name": "factr",
                        "optional": true,
                        "default": "1e7"
                    },
                    {
                        "full": "[pgtol=1e-5]",
                        "name": "pgtol",
                        "optional": true,
                        "default": "1e-5"
                    },
                    {
                        "full": "[epsilon=1e-8]",
                        "name": "epsilon",
                        "optional": true,
                        "default": "1e-8"
                    },
                    {
                        "full": "[maxIter=15000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "15000"
                    },
                    {
                        "full": "[maxFun=15000]",
                        "name": "maxFun",
                        "optional": true,
                        "default": "15000"
                    },
                    {
                        "full": "[maxLS=20]",
                        "name": "maxLS",
                        "optional": true,
                        "default": "20"
                    }
                ]
            }
        ],
        "markdown": "### [fminLBFGSB](https://docs.dolphindb.com/en/Functions/f/fminLBFGSB.html)\n\n\n\n#### Syntax\n\nfminLBFGSB(func, X0, \\[fprime], \\[bounds], \\[m=10], \\[factr=1e7], \\[pgtol=1e-5], \\[epsilon=1e-8], \\[maxIter=15000], \\[maxFun=15000], \\[maxLS=20])\n\n#### Arguments\n\n**func** is the function to minimize. The return value of the function must be numeric type.\n\n**X0** is a numeric scalar or vector indicating the initial guess.\n\n**fprime** (optional) is the gradient of *func*. If not provided, then *func* returns the function value and the gradient (`f, g = func(x, *args)`).\n\n**bounds** (optional) is a numeric matrix indicating the bounds on parameters of *X0*. The matrix must be in the shape of (N,2), where *N*=size(*X0*). The two elements of each row defines the bounds (min, max) on that parameter. `float(\"inf\")` can be specified for no bound in that direction.\n\n**m** (optional) is a positive integer indicating the maximum number of variable metric corrections used to define the limited memory matrix. The default value is 10.\n\n**factr** (optional) is a positive number to stop the iteration when ![](https://docs.dolphindb.com/en/images/factr.png), where *eps* is the machine precision. Typical values for *factr* are: 1e12 for low accuracy; 1e7 (default) for moderate accuracy; 10.0 for extremely high accuracy.\n\n**pgtol** (optional) is a positive number to stop the iteration when ![](https://docs.dolphindb.com/en/images/pgtol1.png), where *proj g\\_i* is the i-th component of the projected gradient. The default value is 1e-5.\n\n**epsilon** (optional) is a positive number indicating the step size used for numerically calculating the gradient. The default value is 1e-8.\n\n**maxIter** (optional) is a non-negative integer indicating the maximum number of iterations. The default value is 15000.\n\n**maxFun** (optional) is a non-negative integer indicating the maximum number of function evaluations. The default value is 15000.\n\n**maxLS** (optional) is a non-negative integer indicating the maximum number of line search steps (per iteration). The default value is 20.\n\n#### Details\n\nMinimize a function *func* using the L-BFGS-B algorithm.\n\n**Return value**: A dictionary with the following members:\n\n* xopt: A floating-point vector indicating the parameters of the minimum.\n\n* fopt: A floating-point scalar indicating the value of *func* at the minimum, i.e., `fopt=func(xopt)`.\n\n* gopt: A floating-point vector indicating the gradient at the minimum, i.e., `gopt=func'(xopt)`.\n\n* iterations: The number of iterations.\n\n* fcalls: The number of function calls made.\n\n* warnFlag: An integer, which can be\n\n  * 0: Minimization performed.\n\n  * 1: Maximum number of evaluations/iterations exceeded.\n\n  * 2: Stopped for other reasons.\n\n#### Examples\n\n```\nX = double(0..9)\nM = 2\nB = 3\nY = double(M * X + B)\ndef fun(params, x, y) {\n\tm = params[0]\n\tb = params[1]\n\ty_model = m*x + b\n\terror = sum(square(y - y_model))\n\treturn error\n}\ninitial_values = [0.0, 1.0]\nfminLBFGSB(fun{,X,Y}, initial_values)\n```\n\nOutput:\n\n```\nfcalls->27\nwarnFlag->0\nxopt->[1.999999985435,3.000000060585]\ngopt->[8.05E-10,8.84E-10]\nfopt->0E-12\niterations->6\n```\n"
    },
    "fminNCG": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fminNCG.html",
        "signatures": [
            {
                "full": "fminNCG(func, X0, fprime, fhess, [xtol=1e-5], [maxIter], [c1=1e-4], [c2=0.9])",
                "name": "fminNCG",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X0",
                        "name": "X0"
                    },
                    {
                        "full": "fprime",
                        "name": "fprime"
                    },
                    {
                        "full": "fhess",
                        "name": "fhess"
                    },
                    {
                        "full": "[xtol=1e-5]",
                        "name": "xtol",
                        "optional": true,
                        "default": "1e-5"
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[c1=1e-4]",
                        "name": "c1",
                        "optional": true,
                        "default": "1e-4"
                    },
                    {
                        "full": "[c2=0.9]",
                        "name": "c2",
                        "optional": true,
                        "default": "0.9"
                    }
                ]
            }
        ],
        "markdown": "### [fminNCG](https://docs.dolphindb.com/en/Functions/f/fminNCG.html)\n\n\n\n#### Syntax\n\nfminNCG(func, X0, fprime, fhess, \\[xtol=1e-5], \\[maxIter], \\[c1=1e-4], \\[c2=0.9])\n\n#### Arguments\n\n**func** is the function to minimize. The return value of the function must be numeric type.\n\n**X0** is a numeric scalar or vector indicating the initial guess.\n\n**fprime** is the gradient of *func*.\n\n**fhess** is the function to compute the Hessian matrix of *func*.\n\n**xtol** (optional) is a positive number. Convergence is assumed when the average relative error in the minimizer falls below this amount. The default value is 1e-5.\n\n**maxIter** (optional) is a non-negative integer indicating the maximum number of iterations. The default value is 15000.\n\n**c1** (optional) is a number in (0,1) indicating the parameter for Armijo condition rule. The default value is 1e-4.\n\n**c2** (optional) is a number in (0,1) indicating the parameter for curvature condition rule. The default value is 0.9. Note that *c2* must be greater than *c1*.\n\n#### Details\n\nPerform unconstrained minimization of a function using the Newton-CG method.\n\n**Return value**: A dictionary with the following members:\n\n* xopt: A floating-point vector indicating the parameters of the minimum.\n\n* fopt: A floating-point scalar indicating the value of *func* at the minimum, i.e., `fopt=func(xopt)`.\n\n* iterations: The number of iterations.\n\n* fcalls: The number of function calls made.\n\n* hcalls: The number of Hessian calls made.\n\n* warnFlag: An integer, which can be\n\n  * 0: Minimization performed.\n\n  * 1: Maximum number of iterations exceeded.\n\n  * 2: Line search failure (precision loss).\n\n  * 3: NULL result encountered.\n\n#### Examples\n\nTo minimize function `rosen`:\n\n```\ndef rosen(x) { \n\tN = size(x);\n\treturn sum(100.0*power(x[1:N]-power(x[0:(N-1)], 2.0), 2.0)+power(1-x[0:(N-1)], 2.0));\n}\n\ndef rosen_der(x) {\n\tN = size(x);\n\txm = x[1:(N-1)]\n\txm_m1 = x[0:(N-2)]\n\txm_p1 = x[2:N]\n\tder = array(double, N)\n\tder[1:(N-1)] = (200 * (xm - xm_m1*xm_m1) - 400 * (xm_p1 - xm*xm) * xm - 2 * (1 - xm))\n\tder[0] = -400 * x[0] * (x[1] - x[0]*x[0]) - 2 * (1 - x[0])\n\tder[N-1] = 200 * (x[N-1] - x[N-2]*x[N-2])\n\treturn der\n}\n\ndef diag1(x, k) {\n\tN = size(x)\n\tm = matrix(type(x), N+1,N+1)\n\tif (k == 1) {\n\t\tfor(i in 0:N){\n\t\t\tm[i, i+1] = x[i]\n\t\t}\n\t} else {\n\t\tfor(i in 0:N){\n\t\t\tm[i+1, i] = x[i]\n\t\t}\n\t}\n\n\treturn m\n}\n\ndef rosen_hess(x) {\n\tN = size(x);\n\tx1= x[0:(N-1)] * 400\n\tH = diag1(-x1, 1) - diag1(x1, -1)\n\tdiagonal = array(type(x), N)\n\tdiagonal[0] = 1200 * x[0]*x[0] - 400 * x[1] + 2\n\tdiagonal[N-1] = 200\n\tdiagonal[1:(N-1)] = 202 + 1200 * x[1:(N-1)]*x[1:(N-1)] - 400 * x[2:N]\n\tH = H + diag(diagonal)\n\treturn H\n}\n\nX0 = [4, -2.5]\nfminNCG(rosen, X0, rosen_der, rosen_hess)\n```\n\nOutput:\n\n```\nxopt->[0.999999966120496,0.999999932105584]\nfopt->1.149654357653714E-15\niterations->34\nfcalls->45\ngcalls->45\nhcalls->34\nwarnFlag->0\n```\n"
    },
    "fminSLSQP": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fminSLSQP.html",
        "signatures": [
            {
                "full": "fminSLSQP(func, X0, [fprime], [constraints], [bounds], [ftol=1e-6], [epsilon], [maxIter=100])",
                "name": "fminSLSQP",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X0",
                        "name": "X0"
                    },
                    {
                        "full": "[fprime]",
                        "name": "fprime",
                        "optional": true
                    },
                    {
                        "full": "[constraints]",
                        "name": "constraints",
                        "optional": true
                    },
                    {
                        "full": "[bounds]",
                        "name": "bounds",
                        "optional": true
                    },
                    {
                        "full": "[ftol=1e-6]",
                        "name": "ftol",
                        "optional": true,
                        "default": "1e-6"
                    },
                    {
                        "full": "[epsilon]",
                        "name": "epsilon",
                        "optional": true
                    },
                    {
                        "full": "[maxIter=100]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "100"
                    }
                ]
            }
        ],
        "markdown": "### [fminSLSQP](https://docs.dolphindb.com/en/Functions/f/fminSLSQP.html)\n\n\n\n#### Syntax\n\nfminSLSQP(func, X0, \\[fprime], \\[constraints], \\[bounds], \\[ftol=1e-6], \\[epsilon], \\[maxIter=100])\n\n#### Arguments\n\n**func** is the function to minimize. The return value of the function must be numeric type.\n\n**X0** is a numeric scalar or vector indicating the initial guess.\n\n**fprime** (optional) is the gradient of *func*. If not provided, then *func* returns the function value and the gradient.\n\n**constraints** (optional) is a vector of dictionaries. Each dictionary should include the following keys:\n\n* type: A string indicating the constraint type, which can be 'eq' for equality constraints and 'ineq' for inequality constraints.\n* fun: The constraint function. The return value must be a numeric scalar or vector.\n* jac: The gradient function of constraint *fun*. The return value must be a numeric vector or a matrix. If the size of the return value of fun is m, and the size of the parameters to be optimized is n, then the shape of the return value of jac must be (n,m).\n\nNote: The number of equality constraints in *constraints*cannot exceed the size of the parameters to be optimized. Let n be the number of parameters, k be the number of equality constraint functions, and leni be the size of the return value of the i-th equality constraint function. The following condition must be satisfied: ![](https://docs.dolphindb.com/en/images/leni.png).\n\n**bounds** (optional) is a numeric matrix indicating the bounds on parameters of *X0*. The matrix must be in the shape of (N,2), where *N*=size(*X0*). The two elements of each row defines the bounds (min, max) on that parameter. `float(\"inf\")` can be specified for no bound in that direction.\n\n**ftol** (optional) is a positive number indicating the precision requirement for the function value when the optimization stops. The default value is 1e-6.\n\n**epsilon** (optional) is a positive number indicating the step size used for numerically calculating the gradient. The default value is 1.4901161193847656e-08.\n\n**maxIter** (optional) is a non-negative integer indicating the maximum number of iterations. The default value is 15000.\n\n#### Details\n\nMinimize a function using Sequential Least Squares Programming.\n\n**Return value**: A dictionary with the following keys:\n\n* xopt: A floating-point vector indicating the parameters of the minimum.\n* fopt: A floating-point scalar indicating the value of *func* at the minimum, i.e., `fopt=func(xopt)`.\n* iterations: Number of iterations.\n* mode: An integer indicating the optimization state. *mode*=0 means optimization succeeded, while other values indicate abnormal algorithm termination. For more information, refer to [jacobwilliams - slsqp](https://jacobwilliams.github.io/slsqp/proc/slsqp.html).\n\n#### Examples\n\nMinimize function `rosen` using Sequential Least Squares Programming:\n\n```\ndef rosen(x) { \n\tN = size(x);\n\treturn sum(100.0*power(x[1:N]-power(x[0:(N-1)], 2.0), 2.0)+power(1-x[0:(N-1)], 2.0));\n}\n\ndef rosen_der(x) {\n\tN = size(x);\n\txm = x[1:(N-1)]\n\txm_m1 = x[0:(N-2)]\n\txm_p1 = x[2:N]\n\tder = array(double, N)\n\tder[1:(N-1)] = (200 * (xm - xm_m1*xm_m1) - 400 * (xm_p1 - xm*xm) * xm - 2 * (1 - xm))\n\tder[0] = -400 * x[0] * (x[1] - x[0]*x[0]) - 2 * (1 - x[0])\n\tder[N-1] = 200 * (x[N-1] - x[N-2]*x[N-2])\n\treturn der\n}\n\ndef eq_fun(x) {\n\treturn 2*x[0] + x[1] - 1\n}\n\ndef eq_jac(x) {\n\treturn [2.0, 1.0]\n}\n\ndef ieq_fun(x) {\n\treturn [1 - x[0] - 2*x[1], 1 - x[0]*x[0] - x[1], 1 - x[0]*x[0] + x[1]]\n}\n\ndef ieq_jac(x) {\n\tret = matrix(DOUBLE, 2, 3)\n\tret[0,:] = [-1.0, -2*x[0], -2*x[0]]\n\tret[1,:] = [-2.0, -1.0, 1.0]\n\treturn ret\n}\n\neqCons=dict(STRING, ANY)\neqCons[`type]=`eq\neqCons[`fun]=eq_fun\neqCons[`jac]=eq_jac\n\nineqCons=dict(STRING, ANY)\nineqCons[`type]=`ineq\nineqCons[`fun]=ieq_fun\nineqCons[`jac]=ieq_jac\n\ncons = [eqCons, ineqCons]\n\nX0 = [0.5, 0]\nbounds = matrix([0 -0.5, 1.0 2.0])\nres = fminSLSQP(rosen, X0, rosen_der, cons, bounds, 1e-9)\nres;\n```\n\nOutput:\n\n```\nmode->0\nxopt->[0.414944749170,0.170110501659]\nfopt->0.342717574994\niterations->4\n```\n"
    },
    "forceMvccCheckpoint": {
        "url": "https://docs.dolphindb.com/en/Functions/f/forceMvccCheckpoint.html",
        "signatures": [
            {
                "full": "forceMvccCheckpoint(mvccTable)",
                "name": "forceMvccCheckpoint",
                "parameters": [
                    {
                        "full": "mvccTable",
                        "name": "mvccTable"
                    }
                ]
            }
        ],
        "markdown": "### [forceMvccCheckpoint](https://docs.dolphindb.com/en/Functions/f/forceMvccCheckpoint.html)\n\n\n\n#### Syntax\n\nforceMvccCheckpoint(mvccTable)\n\n#### Arguments\n\n**mvccTable** is the handle of the MVCC table. To obtain a handle of a persisted MVCC table, you can call function `loadMvccTable`.\n\n#### Details\n\nManually trigger a checkpoint for the specified MVCC table and clear the data in the log.\n"
    },
    "form": {
        "url": "https://docs.dolphindb.com/en/Functions/f/form.html",
        "signatures": [
            {
                "full": "form(X)",
                "name": "form",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [form](https://docs.dolphindb.com/en/Functions/f/form.html)\n\n\n\n#### Syntax\n\nform(X)\n\n#### Arguments\n\n**X** is a variable or constant.\n\n#### Details\n\nGenerate the data form ID of a variable or a constant. Data form IDs and their corresponding data forms are: 0: scalar; 1: vector; 2: pair; 3: matrix; 4: set; 5: dictionary; 6: table.\n\n#### Examples\n\n```\nform(false);\n// output\n0\n\nform(`TEST);\n// output\n0\n\nform(`t1`t2`t3);\n// output\n1\n\nform(1 2 3);\n// output\n1\n\nx= 1 2 3\nif(form(x) == VECTOR){y=1}\ny;\n// output\n1\n\nform(1..6$2:3);\n// output\n3\n```\n"
    },
    "format": {
        "url": "https://docs.dolphindb.com/en/Functions/f/format.html",
        "signatures": [
            {
                "full": "format(X, format)",
                "name": "format",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "format",
                        "name": "format"
                    }
                ]
            }
        ],
        "markdown": "### [format](https://docs.dolphindb.com/en/Functions/f/format.html)\n\n\n\n#### Syntax\n\nformat(X, format)\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n**format** is a string indicating the format to be applied to *X*. Depending on the data type of input *X*, *format* calls either function [decimalFormat](https://docs.dolphindb.com/en/Functions/d/decimalFormat.html) or [temporalFormat](https://docs.dolphindb.com/en/Functions/t/temporalFormat.html).\n\n#### Details\n\nApply a specified format to the given object.\n\n**Return value**: a STRING scalar/vector.\n\n#### Examples\n\n```\nt = table(1..100 as id, (1..100 + 2018.01.01) as date, rand(100.0, 100) as price, rand(10000, 100) as qty);\nt;\n```\n\n| id  | date       | price     | qty  |\n| --- | ---------- | --------- | ---- |\n| 1   | 2018.01.02 | 70.832104 | 1719 |\n| 2   | 2018.01.03 | 12.22557  | 6229 |\n| 3   | 2018.01.04 | 8.695886  | 1656 |\n| 4   | 2018.01.05 | 24.324535 | 2860 |\n| 5   | 2018.01.06 | 0.443173  | 6874 |\n| 6   | 2018.01.07 | 90.302176 | 3277 |\n| 7   | 2018.01.08 | 78.556843 | 3424 |\n| 8   | 2018.01.09 | 45.836447 | 8636 |\n| 9   | 2018.01.10 | 57.416425 | 707  |\n| 10  | 2018.01.11 | 98.879764 | 2267 |\n| ... |            |           |      |\n\n```\nselect id, date.format(\"MM/dd/yyyy\") as date, price.format(\"00.00\") as price, qty.format(\"#,###\") as qty from t;\n```\n\n| id  | date       | price | qty   |\n| --- | ---------- | ----- | ----- |\n| 1   | 01/02/2018 | 70.83 | 1,719 |\n| 2   | 01/03/2018 | 12.23 | 6,229 |\n| 3   | 01/04/2018 | 08.70 | 1,656 |\n| 4   | 01/05/2018 | 24.32 | 2,860 |\n| 5   | 01/06/2018 | 00.44 | 6,874 |\n| 6   | 01/07/2018 | 90.30 | 3,277 |\n| 7   | 01/08/2018 | 78.56 | 3,424 |\n| 8   | 01/09/2018 | 45.84 | 8,636 |\n| 9   | 01/10/2018 | 57.42 | 707   |\n| 10  | 01/11/2018 | 98.88 | 2,267 |\n| ... |            |       |       |\n"
    },
    "fromJson": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fromJson.html",
        "signatures": [
            {
                "full": "fromJson(X)",
                "name": "fromJson",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [fromJson](https://docs.dolphindb.com/en/Functions/f/fromJson.html)\n\n\n\n#### Syntax\n\nfromJson(X)\n\n#### Arguments\n\n**X** is a JSON string that complies with DolphinDB specification.\n\n#### Details\n\nConverta a JSON string that complies with DolphinDB specification to a DolphinDB variable.\n\nA JSON string that complies with DolphinDB specification has at least the following 3 key-value pairs: form, type and value.\n\nFor a table, the key-value pair 'name' can indicate column names.\n\n#### Examples\n\n```\nx=1 2 3\ny=toJson(x)\ny;\n// output\n{\"name\":\"x\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[1,2,3]}\n\nfromJson(y);\n// output\n[1,2,3]\n```\n\nRelated functions: [toJson](https://docs.dolphindb.com/en/Functions/t/toJson.html)\n"
    },
    "fromStdJson": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fromStdJson.html",
        "signatures": [
            {
                "full": "fromStdJson(X)",
                "name": "fromStdJson",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [fromStdJson](https://docs.dolphindb.com/en/Functions/f/fromStdJson.html)\n\n#### Syntax\n\nfromStdJson(X)\n\n#### Arguments\n\n**X** is a scalar or vector of standard JSON string(s).\n\n#### Details\n\nConvert *X* to a DolphinDB variable. The following table shows the data form/type mappings.\n\n| JSON    | DolphinDB                                                                                                    |\n| ------- | ------------------------------------------------------------------------------------------------------------ |\n| object  | Dictionary whose keys must be of STRING type, and values can be of ANY type if multiple types are converted. |\n| array   | vector                                                                                                       |\n| string  | Convert to a Temporal value first. If fails, it convert to a UTF-8 string.                                   |\n| number  | DOUBLE                                                                                                       |\n| boolean | BOOL                                                                                                         |\n| null    | NULL                                                                                                         |\n\nNote: Escape sequences will be automatically interpreted during conversion.\n\n#### Examples\n\n```\nX = \"[1, 2, 3]\";\nfromStdJson(X);\n//output:[1,2,3]\n\nX = \"{\\\"1\\\": \\\"2017.07.10 14:10:12\\\",\\\"0\\\": \\\"2012.06.13 13:30:10\\\"}\";\nfromStdJson(X);\n//output:1->2017.07.10T14:10:12\n//       0->2012.06.13T13:30:10\n```\n\n"
    },
    "fromUTF8": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fromUTF8.html",
        "signatures": [
            {
                "full": "fromUTF8(str, encode)",
                "name": "fromUTF8",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "encode",
                        "name": "encode"
                    }
                ]
            }
        ],
        "markdown": "### [fromUTF8](https://docs.dolphindb.com/en/Functions/f/fromUTF8.html)\n\n\n\n#### Syntax\n\nfromUTF8(str, encode)\n\n#### Arguments\n\n**str** is a STRING scalar/vector.\n\n**encode** is a string indicating the new encoding name. It must use lowercase.\n\n#### Details\n\nConvert the encoding of strings from UTF-8.\n\nFor the Windows version, *encode* can only be \"gbk\".\n\n#### Examples\n\n```\nfromUTF8(\"DolphinDB\",\"gbk\");\n// output\nDolphinDB\n\nfromUTF8([\"hello\",\"world\"],\"euc-cn\");\n// output\n[\"hello\",\"world\"]\n```\n"
    },
    "fTest": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fTest.html",
        "signatures": [
            {
                "full": "fTest(X, Y, [ratio=1.0], [confLevel=0.95])",
                "name": "fTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[ratio=1.0]",
                        "name": "ratio",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[confLevel=0.95]",
                        "name": "confLevel",
                        "optional": true,
                        "default": "0.95"
                    }
                ]
            }
        ],
        "markdown": "### [fTest](https://docs.dolphindb.com/en/Functions/f/fTest.html)\n\n\n\n#### Syntax\n\nfTest(X, Y, \\[ratio=1.0], \\[confLevel=0.95])\n\n#### Arguments\n\n**X** is a numeric vector indicating the first sample for the F-test.\n\n**Y** is a numeric vector indicating the second sample for the F-test.\n\n**ratio** (optional) is a positive floating number indicating the ratio of the variances of *X* and *Y* in the null hypothesis. The default value is 1.\n\n**confLevel** (optional) is a floating number between 0 and 1 indicating the confidence level of the test. It is optional and the default value is 0.95.\n\n#### Details\n\nConduct an F-test to compare the variances of two samples.\n\nReturn a dictionary with the following keys:\n\n* stat: a table with p-value and confidence interval under 3 alternative hypotheses\n\n* numeratorDf: degree of freedom of the numerator\n\n* denominatorDf: degree of freedom of the denominator\n\n* confLevel: confidence level\n\n* method: \"F test to compare two variances\"\n\n* fValue: F-stat\n\n#### Examples\n\n```\nx = norm(10.0, 1.0, 20);\ny = norm(1.0, 2.0, 10);\nfTest(x, y, 0.5);\n// output\nnumeratorDf->19\nstat->\nalternativeHypothesis                  pValue    lowerBound upperBound\n-------------------------------------- --------- ---------- ----------\nratio of variances is not equal to 0.5 0.002326  0.025844   0.274161\nratio of variances is less than 0.5    0.001163  0          0.230624\nratio of variances is greater than 0.5 0.998837  0.032295   Infinity\n\ndenominatorDf->9\nconfLevel->0.95\nfValue->0.190386\nmethod->F test to compare two variances\n```\n"
    },
    "funcByName": {
        "url": "https://docs.dolphindb.com/en/Functions/f/funcByName.html",
        "signatures": [
            {
                "full": "funcByName(name)",
                "name": "funcByName",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [funcByName](https://docs.dolphindb.com/en/Functions/f/funcByName.html)\n\n\n\n#### Syntax\n\nfuncByName(name)\n\n#### Arguments\n\n**name** is a string indicating an operator or a function. The function can be either a built-in function or a user-defined function.\n\n#### Details\n\nDynamically execute an operator or a function. It is mainly used in metaprogramming.\n\n#### Examples\n\n```\ndef f(x, a, b){\n   return funcByName(x)(a, b)\n}\n\nf(\"+\", 1 2 3, 4 5 6);\n// output\n[5,7,9]\n\nf(\"sub\", 1 8 3, 4 8 6);\n// output\n[-3,0,-3]\n\nf(\"corr\", 1 8 3, 4 8 6);\n// output\n0.970725\n\ndef cal(a,b){\n   return pow(a\\b,2)\n}\n\nf(\"cal\", 4 8 10, 2 2 2);\n// output\n[4,16,25]\n\nfuncByName(\"call\")(sum,1..10);\n// output\n55\n```\n"
    },
    "fy5253": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fy5253.html",
        "signatures": [
            {
                "full": "fy5253(X, [weekday=0], [startingMonth=1], [nearest=true], [offset], [n=1])",
                "name": "fy5253",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weekday=0]",
                        "name": "weekday",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[nearest=true]",
                        "name": "nearest",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [fy5253](https://docs.dolphindb.com/en/Functions/f/fy5253.html)\n\n\n\n#### Syntax\n\nfy5253(X, \\[weekday=0], \\[startingMonth=1], \\[nearest=true], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector. Its data type can be DATE, DATETIME, TIMESTAMP, or NANOTIMESTAMP.\n\n**weekday** (optional) is an integer between 0 and 6. 0 means Monday, 1 means Tuesday, …, and 6 means Sunday. The default value is 0.\n\n**startingMonth** (optional) is an integer between 1 and 12 indicating the beginning month of a year. The default value is 1.\n\n**nearest** (optional) is a Boolean value. The default value is true.\n\n**offset** (optional) is a scalar with the same data type as *X*. It must be no greater than the minimum value in *X*. The default value is the minimum value in *X*.\n\n**n** (optional) is a positive integer.The default value is 1.\n\n#### Details\n\nUsing the 52-53 weeks in a fiscal year (4-4-5 calendar), it returns the start date of fiscal year which includes *X*.\n\n* If *nearest*=true, the last weekday which is closest to the last day of *startingMonth* will be used as the starting date of the fiscal year.\n\n* If *nearest*=false, the last weekday in *startingMonth* will be used as the starting date of the fiscal year.\n\nIf *offset* is specified, it means that starting from the *offset*, the result will be updated every *n* years. Note that *offset* can take effect only when *n* is greater than 1.\n\n#### Examples\n\n```\nfy5253(2016.11.01,0,1,true);\n// output\n2016.02.01 // The Monday closest to 2016.01.31 is 2016.02.01\n\nfy5253(2016.11.01,0,1,false);\n// output\n2016.01.25 // The last Monday in January 2016 is 2016.01.25\n\ndate=2011.10.25 2012.10.25 2013.10.25 2014.10.25 2015.10.25 2016.10.25 2017.10.25 2018.10.25 2019.10.25 2020.10.25\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by fy5253(date,0,1,true,2011.10.01,2);\n```\n\n| fy5253\\_date | avg\\_price | sum\\_qty |\n| ------------ | ---------- | -------- |\n| 2011.01.31   | 39.53      | 4100     |\n| 2013.01.28   | 29.77      | 5300     |\n| 2015.02.02   | 175.1      | 12200    |\n| 2017.01.30   | 50.54      | 3800     |\n| 2019.01.28   | 51.835     | 13300    |\n\nRelated function: [fy5253Quarter](https://docs.dolphindb.com/en/Functions/f/fy5253Quarter.html)\n"
    },
    "fy5253Quarter": {
        "url": "https://docs.dolphindb.com/en/Functions/f/fy5253Quarter.html",
        "signatures": [
            {
                "full": "fy5253Quarter(X, [weekday=0], [startingMonth=1], [qtrWithExtraWeek=1], [nearest=true], [offset], [n=1])",
                "name": "fy5253Quarter",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weekday=0]",
                        "name": "weekday",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[qtrWithExtraWeek=1]",
                        "name": "qtrWithExtraWeek",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[nearest=true]",
                        "name": "nearest",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [fy5253Quarter](https://docs.dolphindb.com/en/Functions/f/fy5253Quarter.html)\n\n\n\n#### Syntax\n\nfy5253Quarter(X, \\[weekday=0], \\[startingMonth=1], \\[qtrWithExtraWeek=1], \\[nearest=true], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector, its type can be DATE, DATETIME, TIMESTAMP, NANOTIMESTAMP.\n\n**weekday** (optional) is an integer between 0 and 6. 0 means Monday, 1 means Tuesday, …, and 6 means Sunday. The default value is 0.\n\n**startingMonth** (optional) is an integer between 1 and 12 indicating the beginning month of the year. The default value is 1.\n\n**qtrWithExtraWeek** (optional) is an integer between 1 to 4. If there is a leap quarter (usually the quarter contains 13 weeks, but the leap quarter contains 14 weeks ), it indicates the leap quarter.\n\n**nearest** (optional) is a Boolean value with the default value of true.\n\n**offset** (optional) is a scalar with the same data type as *X*. It must be smaller than the minimum value in *X*. The default value is the minimum value in *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nUsing the 52-53 week in fiscal year (4-4-5 calendar), this function returns the start date of fiscal year which includes *X*.\n\n* If *nearest*=true, the last weekday which is closest to the last day of *startingMonth* will be used as the starting date of the fiscal year.\n\n* If *nearest*=false, the last weekday in *startingMonth* will be used as the starting date of the fiscal year.\n\nIf the *offset* is specified, indicating that starting from the *offset*, the result will be updated every *n* years. Note that only when *n* is greater than 1, the *offset* can take effect.\n\n#### Examples\n\n```\nfy5253Quarter(2019.12.01,0,1,1,true);\n// output\n2019.11.04\n\nfy5253Quarter(2019.12.01,0,1,4,true);\n// output\n2019.10.28   // The start date of the fiscal year 2019 is 2019.01.28. For the fiscal year 2020 it is 2020.02.03. The difference between them is 53 weeks, suggesting the existence of a leap quarter. qtrWithExtraWeek=1 means the first quarter is a leap quarter, which contains 14 weeks, so the start date of the quarter including 2019.12.01 is 2019.11.01; qtrWithExtraWeek=4 means that the fourth quarter is a leap season, which contains 14 weeks, so the start date of the quarter including 2019.12.01 is 2019.10.28.\n\ndate=2016.01.12 2016.02.25 2016.05.12 2016.06.28 2016.07.10 2016.08.18 2016.09.02 2016.10.16 2016.11.26 2016.12.30\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by fy5253Quarter(date,0,1,1,true,2016.01.01,2);\n```\n\n| fy5253Quarter\\_date | avg\\_price | sum\\_qty |\n| ------------------- | ---------- | -------- |\n| 2015.11.02          | 39.53      | 4100     |\n| 2016.05.02          | 85.136667  | 21300    |\n| 2016.10.31          | 51.835     | 13300    |\n\nRelated function: [fy5253](https://docs.dolphindb.com/en/Functions/f/fy5253.html)\n"
    },
    "cacheDS!": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cacheDS!.html",
        "signatures": [
            {
                "full": "cacheDS!(ds)",
                "name": "cacheDS!",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    }
                ]
            }
        ],
        "markdown": "### [cacheDS!](https://docs.dolphindb.com/en/Functions/c/cacheDS!.html)\n\n\n\n#### Syntax\n\ncacheDS!(ds)\n\n#### Arguments\n\n**ds** is a data source or a list of data sources.\n\n#### Details\n\nInstruct the system to cache the data source when it is executed next time. It returns true or false to indicate if this operation is successful.\n\n#### Examples\n\n```\nPTNDB_DIR = \"/home/db_testing\"\ndbName = database(PTNDB_DIR + \"/NYSETAQByName\")\nTrades = dbName.loadTable(`Trades)\n\nds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\nds.cacheDS!()        //cache the data\nds.clearDSCache!()   //clear the cache\n```\n"
    },
    "cacheDSNow": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cacheDSNow.html",
        "signatures": [
            {
                "full": "cacheDSNow(ds)",
                "name": "cacheDSNow",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    }
                ]
            }
        ],
        "markdown": "### [cacheDSNow](https://docs.dolphindb.com/en/Functions/c/cacheDSNow.html)\n\n\n\n#### Syntax\n\ncacheDSNow(ds)\n\n#### Arguments\n\n**ds** is a data source or a list of data sources.\n\n#### Details\n\nImmediately execute and cache the data source. It returns the total number of cached rows.\n\n#### Examples\n\n```\nPTNDB_DIR = \"/home/db_testing\"\ndbName = database(PTNDB_DIR + \"/NYSETAQByName\")\nTrades = dbName.loadTable(`Trades)\n\nds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\nds.cacheDSNow()        //cache the data immediately\nds.clearDSCacheNow()   //clear the cache immediately\n```\n"
    },
    "cachedTable": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cachedTable.html",
        "signatures": [
            {
                "full": "cachedTable(updateFunc, retentionSeconds)",
                "name": "cachedTable",
                "parameters": [
                    {
                        "full": "updateFunc",
                        "name": "updateFunc"
                    },
                    {
                        "full": "retentionSeconds",
                        "name": "retentionSeconds"
                    }
                ]
            }
        ],
        "markdown": "### [cachedTable](https://docs.dolphindb.com/en/Functions/c/cachedTable.html)\n\n\n\n#### Syntax\n\ncachedTable(updateFunc, retentionSeconds)\n\n#### Arguments\n\n**updateFunc** is a function without parameters. It must return a table.\n\n**retentionSeconds** is a positive integer indicating the frequency (in seconds) to update the cached table.\n\n#### Details\n\nCreate a special type of in-memory table: cached table. When querying the cached table, if the time elapsed since the last update exceeds a specified value, *updateFunc* is executed automatically to update the cached table.\n\nTo access a cached table with multiple threads, the table must be shared.\n\n#### Examples\n\nThis example defines a unary function, `f1`, and fixes its argument to produce a partial application with no arguments, `f1{t}`. `f1{t}` is passed as the *updateFunc* to `cachedTable`.\n\n```\ndef f1(mutable t){\n    update t set id=id+1\n    return t\n}\nt=table(1..5 as id, 15 25 35 45 55 as val)\nct=cachedTable(f1{t}, 2);\n\nselect * from ct;\n```\n\n| id | val |\n| -- | --- |\n| 2  | 15  |\n| 3  | 25  |\n| 4  | 35  |\n| 5  | 45  |\n| 6  | 55  |\n\n```\nsleep(2100)\nselect * from ct\n```\n\n| id | val |\n| -- | --- |\n| 3  | 15  |\n| 4  | 25  |\n| 5  | 35  |\n| 6  | 45  |\n| 7  | 55  |\n\n```\nct=NULL;\n```\n"
    },
    "cancelConsoleJob": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cancelConsoleJob.html",
        "signatures": [
            {
                "full": "cancelConsoleJob(rootJobId)",
                "name": "cancelConsoleJob",
                "parameters": [
                    {
                        "full": "rootJobId",
                        "name": "rootJobId"
                    }
                ]
            }
        ],
        "markdown": "### [cancelConsoleJob](https://docs.dolphindb.com/en/Functions/c/cancelConsoleJob.html)\n\n\n\n#### Syntax\n\ncancelConsoleJob(rootJobId)\n\n#### Arguments\n\n**rootJobId** is the job ID(s). It is a STRING scalar or vector. If it is a vector, multiple jobs are canceled at the same time.\n\n#### Details\n\nCancel submitted but unfinished interactive job(s). To cancel batch jobs, use [cancelJob](https://docs.dolphindb.com/en/Functions/c/cancelJob.html).\n\n**Note:** This command cancels a job only after the currently running sub tasks of the job are finished. Therefore the command may not immediately take effect. If a job has no sub task, this command will not take effect.\n\n#### Examples\n\nIn a session of a data node, execute the following script:\n\n```\npt = loadTable(\"dfs://TAQ\", `quotes)\nselect count(*) from pt;\n```\n\nIn another session of the same data node, call [getConsoleJobs](https://docs.dolphindb.com/en/Functions/g/getConsoleJobs.html) to get the *rootJobId* of the job to be canceled, then execute `cancelConsoleJob` with the rootJobId:\n\n```\ncancelConsoleJob(\"bf768327-776d-40a7-8a8d-00a6cfd054e3\");\n```\n"
    },
    "cancelJob": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cancelJob.html",
        "signatures": [
            {
                "full": "cancelJob(jobId)",
                "name": "cancelJob",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    }
                ]
            }
        ],
        "markdown": "### [cancelJob](https://docs.dolphindb.com/en/Functions/c/cancelJob.html)\n\n\n\n#### Syntax\n\ncancelJob(jobId)\n\n#### Arguments\n\n**jobId** is the batch job ID(s). It is a STRING scalar or vector. If it is a vector, multiple batch jobs are canceled at the same time.\n\n#### Details\n\nCancel submitted but unfinished batch job(s).\n\nStarting from version 1.30.192.00.7, if a *jobId* does not exist when `cancelJob` is executed, the system no longer throws an exception. Instead, it outputs the error message with *jobId* to the log.\n\nVersion 1.30.232.00.11 has enhanced access control on job cancellation:\n\n* Administrators (including admin and super admin) can cancel batch jobs submitted by any user.\n\n* Regular users are only allowed to cancel batch jobs submitted by themselves.\n\n#### Examples\n\n```\ndef writeData(num){\n   n=10\n   month=take(2000.01M..2016.12M, n)\n   x=rand(1.0, n)\n   tt=table(month, x)\n   if(existsDatabase(\"dfs://test_db\")){\n       dropDatabase(\"dfs://test_db\")\n   }\n   db=database(\"dfs://test_db\", VALUE, 2000.01M..2016.12M)\n   pt = db.createPartitionedTable(tt, `pt, `month)\n   for(x in 1..num){\n       pt.append!(tt)\n       sleep(1000)\n   }\n}\n\nmyJobId=\"writeData\"+temporalFormat(datetime(now()),\"yyyyMMddHHmmss\")\nsubmitJob(myJobId,\"write data to dfs table\",writeData,120);\ncancelJob(myJobId);\n```\n\nCancel the unfinished jobs in a cluster:\n\n```\ndef cancelAllBatchJob(){\n   jobids=exec jobid from getRecentJobs() where endTime=NULL\n   cancelJob(jobids)\n}\npnodeRun(cancelAllBatchJob)\n```\n"
    },
    "cancelPKEYCompactionTask": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cancelPKEYCompactionTask.html",
        "signatures": [
            {
                "full": "cancelPKEYCompactionTask(chunkId)",
                "name": "cancelPKEYCompactionTask",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    }
                ]
            }
        ],
        "markdown": "### [cancelPKEYCompactionTask](https://docs.dolphindb.com/en/Functions/c/cancelPKEYCompactionTask.html)\n\n\n\n#### Syntax\n\ncancelPKEYCompactionTask(chunkId)\n\n#### Arguments\n\n**chunkId**is a STRING scalar indicating the target chunk ID.\n\n#### Details\n\nCancel the running compaction tasks on the specified chunk.\n\n#### Examples\n\n```\ncancelPKEYCompactionTask(chunkId=\"1486f935-6f87-479c-b341-34c6a303d4f9\")\n```\n"
    },
    "cancelRebalanceTask": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cancelRebalanceTask.html",
        "signatures": [
            {
                "full": "cancelRebalanceTask(taskId)",
                "name": "cancelRebalanceTask",
                "parameters": [
                    {
                        "full": "taskId",
                        "name": "taskId"
                    }
                ]
            }
        ],
        "markdown": "### [cancelRebalanceTask](https://docs.dolphindb.com/en/Functions/c/cancelRebalanceTask.html)\n\n\n\n#### Syntax\n\ncancelRebalanceTask(taskId)\n\n#### Arguments\n\n**taskId** is a STRING scalar or vector indicating the job ID of the rebalance task. It can be obtained with function [getRecoveryTaskStatus](https://docs.dolphindb.com/en/Functions/g/getRecoveryTaskStatus.html).\n\n#### Details\n\nCancel the rebalance jobs that have been submitted but have not begun execution. This command can only be executed by an administrator on a controller.\n"
    },
    "cancelRecoveryTask": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cancelRecoveryTask.html",
        "signatures": [
            {
                "full": "cancelRecoveryTask(taskId)",
                "name": "cancelRecoveryTask",
                "parameters": [
                    {
                        "full": "taskId",
                        "name": "taskId"
                    }
                ]
            }
        ],
        "markdown": "### [cancelRecoveryTask](https://docs.dolphindb.com/en/Functions/c/cancelRecoveryTask.html)\n\n\n\n#### Syntax\n\ncancelRecoveryTask(taskId)\n\n#### Arguments\n\n**taskId** is a STRING scalar or vector indicating the job ID of the replica recovery task. It can be obtained with function [getRecoveryTaskStatus](https://docs.dolphindb.com/en/Functions/g/getRecoveryTaskStatus.html).\n\n#### Details\n\nCancel the replica recovery jobs that have been submitted but have not begun execution. This command can only be executed by an administrator on a controller.\n"
    },
    "cast": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cast.html",
        "signatures": [
            {
                "full": "cast(X, Y)",
                "name": "cast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cast](https://docs.dolphindb.com/en/Functions/c/cast.html)\n\n\n\n#### Syntax\n\ncast(X, Y)\n\nor\n\nX $ Y\n\n#### Arguments\n\n**X** can be of any data form.\n\n**Y** is a data type or a data pair.\n\n#### Details\n\n* convert a data type to another;\n\n* reshape a matrix, or convert between matrices and vectors.\n\n#### Examples\n\n```\nx=8.9$INT;\nx;\n// output\n9\n\nx=1..10;\nx;\n// output\n[1,2,3,4,5,6,7,8,9,10]\n\ntypestr x;\n// output\nFAST INT VECTOR\n\nx/2;\n// output\n[0,1,1,2,2,3,3,4,4,5]\n\nx=x$DOUBLE;\ntypestr x;\n// output\nFAST DOUBLE VECTOR\n\nx/2;\n// output\n[0.5,1,1.5,2,2.5,3,3.5,4,4.5,5]\n\nx=`IBM`MS;\ntypestr x;\n// output\nSTRING VECTOR\n\nx=x$SYMBOL;\ntypestr x;\n// output\nFAST SYMBOL VECTOR\n\nx=`128.9;\ntypestr x;\n// output\nSTRING\n\nx=x$INT;\nx;\n// output\n128\ntypestr x;\n// output\nINT\n\n// convert a vector to a matrix\nm=1..8$2:4;\nm;\n```\n\n| 0  | 1  | 2  | 3  |\n| :- | :- | :- | :- |\n| 1  | 3  | 5  | 7  |\n| 2  | 4  | 6  | 8  |\n\n```\n// reshape a matrix\nm$4:2;\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 5 |\n| 2 | 6 |\n| 3 | 7 |\n| 4 | 8 |\n\n```\nm$1:size(m);\n```\n\n| 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  |\n| :- | :- | :- | :- | :- | :- | :- | :- |\n| 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |\n"
    },
    "cbrt": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cbrt.html",
        "signatures": [
            {
                "full": "cbrt(X)",
                "name": "cbrt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cbrt](https://docs.dolphindb.com/en/Functions/c/cbrt.html)\n\n\n\n#### Syntax\n\ncbrt(X)\n\n#### Arguments\n\n**X** can be a scalar/pair/vector/matrix/table.\n\n#### Details\n\nReturn the square root of *X*. The data type of the result is always DOUBLE.\n\n#### Examples\n\n```\ncbrt(8);\n// output\n2\n\ncbrt(8 12 16);\n// output\n[2,2.289428,2.519842]\n\ncbrt(1..6$2:3);\n```\n\n| 0        | 1        | 2        |\n| -------- | -------- | -------- |\n| 1        | 1.44225  | 1.709976 |\n| 1.259921 | 1.587401 | 1.817121 |\n"
    },
    "cdfBeta": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfBeta.html",
        "signatures": [
            {
                "full": "cdfBeta(alpha, beta, X)",
                "name": "cdfBeta",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfBeta](https://docs.dolphindb.com/en/Functions/c/cdfBeta.html)\n\n\n\n#### Syntax\n\ncdfBeta(alpha, beta, X)\n\n#### Arguments\n\nThe shape parameters **alpha** and **beta** are positive floating numbers.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a beta distribution.\n\n#### Examples\n\n```\ncdfBeta(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0, 0.116056, 0.976416]\n\ncdfBeta(2.31, 0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.002451, 0.032995, 0.116056, 0.280532, 0.597694]\n```\n"
    },
    "cdfBinomial": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfBinomial.html",
        "signatures": [
            {
                "full": "cdfBinomial(trials, p, X)",
                "name": "cdfBinomial",
                "parameters": [
                    {
                        "full": "trials",
                        "name": "trials"
                    },
                    {
                        "full": "p",
                        "name": "p"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfBinomial](https://docs.dolphindb.com/en/Functions/c/cdfBinomial.html)\n\n\n\n#### Syntax\n\ncdfBinomial(trials, p, X)\n\n#### Arguments\n\n**trials** is a positive integer.\n\n**p** is a floating number between 0 and 1.\n\n*trials* and *p* are shape parameters.\n\n**X** is a numeric scalar and vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a binomial distribution.\n\n#### Examples\n\n```\ncdfBinomial(10, 0.1, [1, 5, 9]);\n// output\n[0.736099, 0.999853, 1]\n\ncdfBinomial(12,0.627, [1, 3, 5, 7, 9]);\n// output\n[0.000154, 0.009085, 0.114844, 0.483879, 0.88373]\n```\n"
    },
    "cdfChiSquare": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfChiSquare.html",
        "signatures": [
            {
                "full": "cdfChiSquare(df, X)",
                "name": "cdfChiSquare",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfChiSquare](https://docs.dolphindb.com/en/Functions/c/cdfChiSquare.html)\n\n\n\n#### Syntax\n\ncdfChiSquare(df, X)\n\n#### Arguments\n\n**df** is a positive integer indicating the degree of freedom of a chi-squared distribution.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a chi-squared distribution.\n\n#### Examples\n\n```\ncdfChiSquare(1, [-1, 0, 0.5, 1, 2]);\n// output\n[0, 0, 0.5205, 0.682689, 0.842701]\n\ncdfChiSquare(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.24817, 0.416118, 0.5205, 0.597216, 0.657218]\n```\n"
    },
    "cdfExp": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfExp.html",
        "signatures": [
            {
                "full": "cdfExp(mean, X)",
                "name": "cdfExp",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfExp](https://docs.dolphindb.com/en/Functions/c/cdfExp.html)\n\n\n\n#### Syntax\n\ncdfExp(mean, X)\n\n#### Arguments\n\n**mean** is the mean of an exponential distribution.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of an exponential distribution.\n\n#### Examples\n\n```\ncdfExp(1, [-1, 0, 0.5, 1, 2]);\n// output\n[0, 0, 0.393469, 0.632121, 0.864665]\n\ncdfExp(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.095163, 0.259182, 0.393469, 0.503415, 0.59343]\n```\n"
    },
    "cdfF": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfF.html",
        "signatures": [
            {
                "full": "cdfF(numeratorDF, denominatorDF, X)",
                "name": "cdfF",
                "parameters": [
                    {
                        "full": "numeratorDF",
                        "name": "numeratorDF"
                    },
                    {
                        "full": "denominatorDF",
                        "name": "denominatorDF"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfF](https://docs.dolphindb.com/en/Functions/c/cdfF.html)\n\n\n\n#### Syntax\n\ncdfF(numeratorDF, denominatorDF, X)\n\n#### Arguments\n\n**numeratorDF** and **denominatorDF** are positive integers indicating degrees of freedom of an F distribution.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of an F distribution.\n\n#### Examples\n\n```\ncdfF(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0.000444, 0.245679, 0.35098]\n\ncdfF(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.07078, 0.176153, 0.245679, 0.295996, 0.334766]\n```\n"
    },
    "cdfGamma": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfGamma.html",
        "signatures": [
            {
                "full": "cdfGamma(shape, scale, X)",
                "name": "cdfGamma",
                "parameters": [
                    {
                        "full": "shape",
                        "name": "shape"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfGamma](https://docs.dolphindb.com/en/Functions/c/cdfGamma.html)\n\n\n\n#### Syntax\n\ncdfGamma(shape, scale, X)\n\n#### Arguments\n\nThe shape parameters **shape** and **scale** are both positive floating-point numbers.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a gamma distribution.\n\n#### Examples\n\n```\ncdfGamma(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0, 0.127367, 0.38032]\n\ncdfGamma(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.004754, 0.048388, 0.127367, 0.225351, 0.329391]\n```\n"
    },
    "cdfKolmogorov": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfKolmogorov.html",
        "signatures": [
            {
                "full": "cdfKolmogorov(X)",
                "name": "cdfKolmogorov",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfKolmogorov](https://docs.dolphindb.com/en/Functions/c/cdfKolmogorov.html)\n\n\n\n#### Syntax\n\ncdfKolmogorov(X)\n\n#### Arguments\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a Kolmogorov distribution.\n\n#### Examples\n\n```\ncdfKolmogorov([0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[1, 0.999991, 0.963945, 0.711235, 0.392731]\n\ncdfKolmogorov([1,2,3]);\n// output\n[0.27, 0.000671, 3.045996E-8]\n```\n"
    },
    "cdfLogistic": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfLogistic.html",
        "signatures": [
            {
                "full": "cdfLogistic(mean, s, X)",
                "name": "cdfLogistic",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "s",
                        "name": "s"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfLogistic](https://docs.dolphindb.com/en/Functions/c/cdfLogistic.html)\n\n\n\n#### Syntax\n\ncdfLogistic(mean, s, X)\n\n#### Arguments\n\n**mean** is the mean of a logistic distribution.\n\n**s** is the scale parameter of a logistic distribution.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a logistic distribution.\n\n#### Examples\n\n```\ncdfLogistic( 2.31, 0.627, [0.5, 0.3, 0.5, 0.7, 0.1]);\n// output\n[0.052812, 0.03895, 0.052812, 0.071241, 0.028617]\n```\n"
    },
    "cdfNormal": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfNormal.html",
        "signatures": [
            {
                "full": "cdfNormal(mean, stdev, X)",
                "name": "cdfNormal",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "stdev",
                        "name": "stdev"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfNormal](https://docs.dolphindb.com/en/Functions/c/cdfNormal.html)\n\n\n\n#### Syntax\n\ncdfNormal(mean, stdev, X)\n\n#### Arguments\n\n**mean** is the mean of a normal distribution.\n\n**stdev** is the standard deviation of a normal distribution.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a normal distribution.\n\n#### Examples\n\n```\ncdfNormal(0,1,-2.33);\n// output\n0.009903\n\ncdfNormal(10, 20, -30);\n// output\n0.02275\n```\n"
    },
    "cdfPoisson": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfPoisson.html",
        "signatures": [
            {
                "full": "cdfPoisson(mean, X)",
                "name": "cdfPoisson",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfPoisson](https://docs.dolphindb.com/en/Functions/c/cdfPoisson.html)\n\n\n\n#### Syntax\n\ncdfPoisson(mean, X)\n\n#### Arguments\n\n**mean** is the mean of a Poisson distribution.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a Poisson distribution.\n\n#### Examples\n\n```\ncdfPoisson(1, [-1, 0, 1, 2, 3]);\n// output\n[0, 0.367879, 0.735759, 0.919699, 0.981012]\n\ncdfPoisson(1, [1, 3, 5, 7, 9]);\n// output\n[0.735759, 0.981012, 0.999406, 0.99999, 1]\n```\n"
    },
    "cdfStudent": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfStudent.html",
        "signatures": [
            {
                "full": "cdfStudent(df, X)",
                "name": "cdfStudent",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfStudent](https://docs.dolphindb.com/en/Functions/c/cdfStudent.html)\n\n\n\n#### Syntax\n\ncdfStudent(df, X)\n\n#### Arguments\n\n**df** is a positive floating number indicating the degree of freedom of a Student's t-distribution.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a Student's t-distribution.\n\n#### Examples\n\n```language-python\ncdfStudent(1, [-1, 0, 0.5, 1, 2]);\n// output\n[0.25, 0.5, 0.647584, 0.75, 0.852416]\n\ncdfStudent(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.531726, 0.592774, 0.647584, 0.6944, 0.733262]\n```\n"
    },
    "cdfUniform": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfUniform.html",
        "signatures": [
            {
                "full": "cdfUniform(lower, upper, X)",
                "name": "cdfUniform",
                "parameters": [
                    {
                        "full": "lower",
                        "name": "lower"
                    },
                    {
                        "full": "upper",
                        "name": "upper"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfUniform](https://docs.dolphindb.com/en/Functions/c/cdfUniform.html)\n\n\n\n#### Syntax\n\ncdfUniform(lower, upper, X)\n\n#### Arguments\n\n**lower** and **upper** are numeric scalars indicating the lower bound and upper bound of a continuous uniform distribution.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a continuous uniform distribution.\n\n#### Examples\n\n```\ncdfUniform(0.627, 2.31, [0.001, 0.5, 0.999]);\n// output\n[0, 0, 0.221034]\n\ncdfUniform(0.627, 2.31, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0, 0, 0, 0.043375, 0.16221]\n```\n"
    },
    "cdfWeibull": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfWeibull.html",
        "signatures": [
            {
                "full": "cdfWeibull(alpha, beta, X)",
                "name": "cdfWeibull",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfWeibull](https://docs.dolphindb.com/en/Functions/c/cdfWeibull.html)\n\n\n\n#### Syntax\n\ncdfWeibull(alpha, beta, X)\n\n#### Arguments\n\nThe scale parameters **alpha** and **beta** are both positive floating numbers.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a Weibull distribution.\n\n#### Examples\n\n```\ncdfWeibull(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0, 0.447241, 0.946762]\n\ncdfWeibull(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.014295, 0.166535, 0.447241, 0.724646, 0.90021]\n```\n"
    },
    "cdfZipf": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cdfZipf.html",
        "signatures": [
            {
                "full": "cdfZipf(num, exponent, X)",
                "name": "cdfZipf",
                "parameters": [
                    {
                        "full": "num",
                        "name": "num"
                    },
                    {
                        "full": "exponent",
                        "name": "exponent"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfZipf](https://docs.dolphindb.com/en/Functions/c/cdfZipf.html)\n\n\n\n#### Syntax\n\ncdfZipf(num, exponent, X)\n\n#### Arguments\n\n**num** is a positive integer.\n\n**exponent** is a non-negative floating number.\n\n**X** is a numeric scalar or vector.\n\n#### Details\n\nReturn the value of the cumulative distribution function of a Zipfian distribution.\n\n#### Examples\n\n```\ncdfZipf(10, 0.5, [1, 3, 5, 7, 9]);\n// output\n[0.199164, 0.454981, 0.643631, 0.800216, 0.937019]\n```\n"
    },
    "ceil": {
        "url": "https://docs.dolphindb.com/en/Functions/c/ceil.html",
        "signatures": [
            {
                "full": "ceil(X)",
                "name": "ceil",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ceil](https://docs.dolphindb.com/en/Functions/c/ceil.html)\n\n\n\n#### Syntax\n\nceil(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nFunctions [floor](https://docs.dolphindb.com/en/Functions/f/floor.html) and `ceil` map a real number to the largest previous and the smallest following integer, respectively. Function [round](https://docs.dolphindb.com/en/Functions/r/round.html) maps a real number to the largest previous or the smallest following integer with the round half up rule.\n\n#### Examples\n\n```\nceil(2.1);\n// output\n3\nceil(2.9);\n// output\n3\nceil(-2.1);\n// output\n-2\n\nfloor(2.1);\n// output\n2\nfloor(2.9);\n// output\n2\nfloor(-2.1);\n// output\n-3\n\nround(2.1);\n// output\n2\nround(2.9);\n// output\n3\nround(-2.1);\n// output\n-2\n\nm = 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9 10$2:5;\nm;\n```\n\n| 0   | 1   | 2   | 3   | 4   |\n| --- | --- | --- | --- | --- |\n| 1.1 | 3.3 | 5.5 | 7.7 | 9.9 |\n| 2.2 | 4.4 | 6.6 | 8.8 | 10  |\n\n```\nceil(m);\n```\n\n| 0 | 1 | 2 | 3 | 4  |\n| - | - | - | - | -- |\n| 2 | 4 | 6 | 8 | 10 |\n| 3 | 5 | 7 | 9 | 10 |\n"
    },
    "cell": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cell.html",
        "signatures": [
            {
                "full": "cell(obj, row, col)",
                "name": "cell",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "row",
                        "name": "row"
                    },
                    {
                        "full": "col",
                        "name": "col"
                    }
                ]
            }
        ],
        "markdown": "### [cell](https://docs.dolphindb.com/en/Functions/c/cell.html)\n\n\n\n#### Syntax\n\ncell(obj, row, col)\n\n#### Arguments\n\n**obj** is a matrix or table.\n\n**row** is a non-negative integer indicating a column number.\n\n**col** is a non-negative integer indicating a row number.\n\n#### Details\n\nReturn a scalar that is the value of the specified cell: `obj[row, col]`. The `cell` function runs generally faster than `obj[row, col]`.\n\n#### Examples\n\n```\nx=(1..6).reshape(3:2);\nx;\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\nx.cell(0,0);\n// output\n1\nx.cell(0,1);\n// output\n4\ncell(x,1,1);\n// output\n5\ncell(x,2,0);\n// output\n3\n```\n"
    },
    "cells": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cells.html",
        "signatures": [
            {
                "full": "cells(obj, row, col)",
                "name": "cells",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "row",
                        "name": "row"
                    },
                    {
                        "full": "col",
                        "name": "col"
                    }
                ]
            }
        ],
        "markdown": "### [cells](https://docs.dolphindb.com/en/Functions/c/cells.html)\n\n\n\n#### Syntax\n\ncells(obj, row, col)\n\n#### Arguments\n\n**obj** is a matrix.\n\n**row** is a vector of integral type, indicating indices of rows.\n\n**col** is a vector of integral type of the same length as row, indicating indices of columns.\n\n#### Details\n\nReturn a vector of cells in a matrix by the specified row and column index.\n\n#### Examples\n\n```\nm=(1..15).reshape(3:5)\nm;\n```\n\n| col1 | col2 | col3 | col4 | col5 |\n| ---- | ---- | ---- | ---- | ---- |\n| 1    | 4    | 7    | 10   | 13   |\n| 2    | 5    | 8    | 11   | 14   |\n| 3    | 6    | 9    | 12   | 15   |\n\n```\n// obtain the two elements at [0,1] and [0,2]\ncells(m, 0 0, 1 2)\n// output\n[4,7]\n\n// obtain the elements on the diagonal of the matrix\nindex = 0..2\ncells(m, index, index)\n// output\n[1, 5, 9]\n```\n"
    },
    "changePwd": {
        "url": "https://docs.dolphindb.com/en/Functions/c/changePwd.html",
        "signatures": [
            {
                "full": "changePwd(oldPwd, newPwd)",
                "name": "changePwd",
                "parameters": [
                    {
                        "full": "oldPwd",
                        "name": "oldPwd"
                    },
                    {
                        "full": "newPwd",
                        "name": "newPwd"
                    }
                ]
            }
        ],
        "markdown": "### [changePwd](https://docs.dolphindb.com/en/Functions/c/changePwd.html)\n\n\n\n#### Syntax\n\nchangePwd(oldPwd, newPwd)\n\n#### Arguments\n\n**oldPwd** is a string indicating the current password for the user.\n\n**newPwd** is a string indicating the new password for the user. It cannot contain space or control characters.\n\nSince DolphinDB 2.00.10.10, users can determine whether to verify the complexity of *newPwd* by setting the configuration *enhancedSecurityVerification*. If it is not specified, no verification will be applied; if it is set to true, the password must meet the following conditions:\n\n* 8-20 characters\n\n* at least 1 capital letter\n\n* at least 1 special character, including !\"#$%&'()\\*+,-./:;<=>?@\\[]^\\_\\`{|}\\~\n\n#### Details\n\nChange password. It can only be executed by an administrator.\n\n#### Examples\n\n```\nchangePwd(`LTmp4389, `T5139pm);\n```\n"
    },
    "char": {
        "url": "https://docs.dolphindb.com/en/Functions/c/char.html",
        "signatures": [
            {
                "full": "char(X)",
                "name": "char",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [char](https://docs.dolphindb.com/en/Functions/c/char.html)\n\n\n\n#### Syntax\n\nchar(X)\n\n#### Arguments\n\n**X** can be of any data type.\n\n#### Details\n\nConvert the input to the data type of CHAR.\n\n#### Examples\n\n```\nx=char();\nx;\n// output\n00c\n\ntypestr x;\n// output\nCHAR\n\na=char(99);\na;\n// output\n'c'\n\nchar(\"990\");\nFailed to convert the string to CHAR'\n\ntypestr a;\n// output\nCHAR\n\nchar(a+5);\n// output\n'h'\n```\n"
    },
    "charAt": {
        "url": "https://docs.dolphindb.com/en/Functions/c/charAt.html",
        "signatures": [
            {
                "full": "charAt(X, Y)",
                "name": "charAt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [charAt](https://docs.dolphindb.com/en/Functions/c/charAt.html)\n\n\n\n#### Syntax\n\ncharAt(X, Y)\n\n#### Arguments\n\n**X** is a STRING scalar/vector.\n\n**Y** is an integer scalar/vector. If *Y* is a vector, it must be of the same length as *X*.\n\n#### Details\n\nReturn the character in *X* at the position specified by *Y*. The result is a scalar/vector of data type CHAR.\n\n#### Examples\n\n```\ns=charAt(\"abc\",2);\ns;\n// output\n'c'\n\ntypestr(s);\n// output\nCHAR\n\ncharAt([\"hello\",\"world\"],[3,4]);\n// output\n['l','d']\n```\n"
    },
    "checkBackup": {
        "url": "https://docs.dolphindb.com/en/Functions/c/checkBackup.html",
        "signatures": [
            {
                "full": "checkBackup(backupDir, dbPath, [tableName], [partition])",
                "name": "checkBackup",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    },
                    {
                        "full": "[partition]",
                        "name": "partition",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [checkBackup](https://docs.dolphindb.com/en/Functions/c/checkBackup.html)\n\n\n\n#### Syntax\n\ncheckBackup(backupDir, dbPath, \\[tableName], \\[partition])\n\n#### Arguments\n\n**backupDir** is a string indicating the directory to save the backup.\n\n**dbPath** is a string indicating the database path.\n\n**tableName** (optional) is a string indicating the table name. If tableName is unspecified, all tables in the database are checked.\n\n**partition** (optional) is a string indicating the relative path of the backup partitions. Use \"?\" as a single wildcard and \"%\" as a wildcard that can match zero or more characters.\n\n* For a certain partition, specify the relative path or \"%/\" + \"partition name\". For example, for the \"20170810/50\\_100\" partition under \"dfs\\://compoDB\", specify \"/compoDB/20170807/0\\_50\" or \"%/20170807/0\\_50\" as partition path.\n\n* For all the partitions: specify \"%\".\n\n#### Details\n\nCheck the data integrity of the backup files. Return an empty table if all backup files are complete and accurate; Otherwise return the information of abnormal backup files. You can set *force*=true for function backup to enable force backup to restore the corrupt backup partitions.\n\n#### Examples\n\n```\ndbName = \"dfs://compoDB2\"\nn=1000\nID=rand(\"a\"+string(1..10), n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10, n)\nt=table(ID, date, x)\ndb1 = database(, VALUE, 2017.08.07..2017.08.11)\ndb2 = database(, HASH,[INT, 20])\nif(existsDatabase(dbName)){\ndropDatabase(dbName)\n}\ndb = database(dbName, COMPO,[ db1,db2])\n\n//create 2 tables\npt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\npt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\n//back up pt1 with SQL statement\nbackup(backupDir=backupDir1, sqlObj=<select * from pt1>, parallel=true)\n//back up pt2 by copying files\nbackup(backupDir=backupDir2, dbName, parallel=true, tableName=`pt2)\n\n//check data integrity\ncheckBackup(backupDir=backupDir2, dbPath=dbName, tableName=\"pt2\")  //return an empty table\ncheckBackup(backupDir=backupDir1, dbPath=dbName, tableName=\"pt1\")  //return the corrupted chunk information\n```\n\n| dbName              | tableName                 | chunkPath                            | chunkID        | partitionPath |\n| ------------------- | ------------------------- | ------------------------------------ | -------------- | ------------- |\n| dfs\\://compoDB2 pt1 | /compoDB2/20170807/Key2/9 | 4ae71414-8bfe-4283-b04c-b2e48e90be08 | /20170807/Key2 |               |\n\nIn the above example, there is a corrupt chunk file of pt1. We can restore the file by setting *force*=true to back up the table again.\n\n```\nbackup(backupDir1, <select * from pt1>,force=true, parallel=true)\ncheckBackup(backupDir=backupDir1, dbPath=dbName, tableName=\"pt1\")  // return an empty table\n```\n"
    },
    "chiSquareTest": {
        "url": "https://docs.dolphindb.com/en/Functions/c/chiSquareTest.html",
        "signatures": [
            {
                "full": "chiSquareTest(X, [Y])",
                "name": "chiSquareTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [chiSquareTest](https://docs.dolphindb.com/en/Functions/c/chiSquareTest.html)\n\n\n\n#### Syntax\n\nchiSquareTest(X, \\[Y])\n\n#### Arguments\n\n**X** is a numeric vector/matrix/table.\n\nIf *X* is a vector, *Y* is a numeric vector of the same length as *X*. *Y* is not required if *X* is not a vector.\n\n#### Details\n\nIf *X* is a vector, conduct a Chi-squared goodness of fit test whether *X* and *Y* follow the same distribution.\n\nIf *X* is a matrix/table, conduct Pearson's Chi-squared test on *X*.\n\nReturn a dictionary with the following keys:\n\n* pValue: p-value of the test\n\n* df: degree of freedom\n\n* chiSquaredValue: Chi-squared test statistic\n\n* method: either \"Chi-square goodness of fit test\" or \"Pearson's Chi-squared test\"\n\n#### Examples\n\nExample 1. *X* is a vector.\n\n```\nx=rand(10.0,50)\ny=rand(10.0,50)\nchiSquareTest(x,y);\n\n// output\npValue->0\ndf->49\nchiSquaredValue->947.388015\nmethod->Chi-square goodness of fit test\n```\n\nExample 2. *X* is a matrix.\n\n```\nx = matrix([762, 484], [327, 239], [468, 477])\nx.rename!(`female`male, `Democrat`Independent`Republican)\nx;\n```\n\n|        | Democrat | Independent | Republican |\n| ------ | -------- | ----------- | ---------- |\n| female | 762      | 327         | 468        |\n| male   | 484      | 239         | 477        |\n\n```\nchiSquareTest(x);\n// output\npValue->2.953589E-7\ndf->2\nchiSquaredValue->30.070149\nmethod->Pearson's Chi-squared test\n```\n"
    },
    "cholesky": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cholesky.html",
        "signatures": [
            {
                "full": "cholesky(obj, [lower=true])",
                "name": "cholesky",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[lower=true]",
                        "name": "lower",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [cholesky](https://docs.dolphindb.com/en/Functions/c/cholesky.html)\n\n\n\n#### Syntax\n\ncholesky(obj, \\[lower=true])\n\n#### Arguments\n\n**obj** is a symmetric positive definite matrix.\n\n**lower** (optional) is a Boolean value indicating whether the result is a lower triangular matrix (true, default) or an upper triangular matrix (false).\n\n#### Details\n\nConduct Cholesky decomposition of a symmetric positive-definite matrix.\n\n#### Examples\n\n```\nm=[1, 0, 1, 0, 2, 0, 1, 0, 3]$3:3\nL=cholesky(m);\nL;\n```\n\n| #0 | #1       | #2       |\n| -- | -------- | -------- |\n| 1  | 0 96.56  | 0        |\n| 0  | 1.414214 | 0        |\n| 1  | 0        | 1.414214 |\n\n```\nL**transpose(L);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 0  | 1  |\n| 0  | 2  | 0  |\n| 1  | 0  | 3  |\n\n```\ncholesky(m, false);\n```\n\n| #0 | #1       | #2       |\n| -- | -------- | -------- |\n| 1  | 0        | 1        |\n| 0  | 1.414214 | 0        |\n| 0  | 0        | 1.414214 |\n"
    },
    "cj": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cj.html",
        "signatures": [
            {
                "full": "cj(X, Y)",
                "name": "cj",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cj](https://docs.dolphindb.com/en/Functions/c/cj.html)\n\n\n\n#### Syntax\n\ncj(X, Y)\n\n#### Arguments\n\n**X** and **Y** are tables.\n\n#### Details\n\nPerform a cross join between two tables and returns their Cartesian product. If *X* has n rows and *Y* has m rows, then cj(X,Y) has n\\*m rows.\n\n#### Examples\n\n```\na=table(1..3 as x,`IBM`C`AAPL as y)\nb=table(172.3 25 106.5 as z)\nc=cj(a,b);\nc;\n```\n\n| x | y    | z     |\n| - | ---- | ----- |\n| 1 | IBM  | 172.3 |\n| 1 | IBM  | 25    |\n| 1 | IBM  | 106.5 |\n| 2 | C    | 172.3 |\n| 2 | C    | 25    |\n| 2 | C    | 106.5 |\n| 3 | AAPL | 172.3 |\n| 3 | AAPL | 25    |\n| 3 | AAPL | 106.5 |\n\n```\n// in contrast, the join (<-) operation simply merges two tables' columns\na join b;\n```\n\n| x | y    | z     |\n| - | ---- | ----- |\n| 1 | IBM  | 172.3 |\n| 2 | C    | 25    |\n| 3 | AAPL | 106.5 |\n"
    },
    "cleanOutdateLogFiles": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cleanOutdateLogFiles.html",
        "signatures": [
            {
                "full": "cleanOutdateLogFiles([retentionTime=30])",
                "name": "cleanOutdateLogFiles",
                "parameters": [
                    {
                        "full": "[retentionTime=30]",
                        "name": "retentionTime",
                        "optional": true,
                        "default": "30"
                    }
                ]
            }
        ],
        "markdown": "### [cleanOutdateLogFiles](https://docs.dolphindb.com/en/Functions/c/cleanOutdateLogFiles.html)\n\n\n\n#### Syntax\n\ncleanOutdateLogFiles(\\[retentionTime=30])\n\n#### Arguments\n\n**retentionTime** (optional) is the amount of time to keep a log file. The default value is 30 (days).\n\n#### Details\n\nCall this command to remove the log files kept for over *retentionTime*.\n"
    },
    "clear!": {
        "url": "https://docs.dolphindb.com/en/Functions/c/clear!.html",
        "signatures": [
            {
                "full": "clear!(X)",
                "name": "clear!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [clear!](https://docs.dolphindb.com/en/Functions/c/clear!.html)\n\n\n\n#### Syntax\n\nclear!(X)\n\n#### Arguments\n\n**X** can be a vector, matrix, set, dictionary, or in-memory table.\n\n#### Details\n\nClear the contents of *X*. After execution *X* still exists. It retains its initial data type and can be appended with new data.\n\n#### Examples\n\n```\nx=1 2 3;\nclear!(x);\n// output\n[]\n\ntypestr x;\n// output\nFAST INT VECTOR\n\nsize x;\n// output\n0\n\nx.append!(1..6);\n// output\n[1,2,3,4,5,6]\n\ny=set(8 9 4 6);\ny.clear!();\n// output\nset()\n\nx=1..3;\ny=4..6;\nz=dict(x,y);\nz;\n// output\n3->6\n1->4\n2->5\nz.clear!();\n\nt = table(1 2 3 as id, 1.0 2.0 3.0 as value)\nt.clear!()\n```\n"
    },
    "clearAllCache": {
        "url": "https://docs.dolphindb.com/en/Functions/c/clearAllCache.html",
        "signatures": [
            {
                "full": "clearAllCache()",
                "name": "clearAllCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [clearAllCache](https://docs.dolphindb.com/en/Functions/c/clearAllCache.html)\n\n\n\n#### Syntax\n\nclearAllCache()\n\n#### Arguments\n\nNone\n\n#### Details\n\nClear the following cached data:\n\n* the data of dimension table stored in memory\n* the data of OLAP DFS tables that has been loaded into memory\n* the cached level file index of TSDB engine\n* the cached SYMBOL base of TSDB engine\n* the intermediate results of the map-reduce tasks in distributed computing\n\n#### Examples\n\n```\nclearAllCache();\n```\n"
    },
    "clearAllTSDBSymbolBaseCache": {
        "url": "https://docs.dolphindb.com/en/Functions/c/clearAllTSDBSymbolBaseCache.html",
        "signatures": [
            {
                "full": "clearAllTSDBSymbolBaseCache()",
                "name": "clearAllTSDBSymbolBaseCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [clearAllTSDBSymbolBaseCache](https://docs.dolphindb.com/en/Functions/c/clearAllTSDBSymbolBaseCache.html)\n\n\n\n#### Syntax\n\nclearAllTSDBSymbolBaseCache()\n\n#### Arguments\n\nNone\n\n#### Details\n\nClear all cached SYMBOL base entries that are absent from both the cache engine and ongoing transactions.\n\n#### Examples\n\n```\nclearAllTSDBSymbolBaseCache();\n```\n"
    },
    "clearCachedDatabase": {
        "url": "https://docs.dolphindb.com/en/Functions/c/clearCachedDatabase.html",
        "signatures": [
            {
                "full": "clearCachedDatabase(dbUrl, [tableName])",
                "name": "clearCachedDatabase",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [clearCachedDatabase](https://docs.dolphindb.com/en/Functions/c/clearCachedDatabase.html)\n\n\n\n#### Syntax\n\nclearCachedDatabase(dbUrl, \\[tableName])\n\n#### Arguments\n\n**dbUrl** is a string indicating the path to a DFS database.\n\n**tableName** (optional) is a string indicating the table name. It can be a dimension table or DFS partitionted table.\n\n#### Details\n\nClears the cached tables in memory loaded from a DFS database. You can check the memory usage with function [getSessionMemoryStat](https://docs.dolphindb.com/en/Functions/g/getSessionMemoryStat.html).\n"
    },
    "clearCachedModules": {
        "url": "https://docs.dolphindb.com/en/Functions/c/clearCachedModules.html",
        "signatures": [
            {
                "full": "clearCachedModules()",
                "name": "clearCachedModules",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [clearCachedModules](https://docs.dolphindb.com/en/Functions/c/clearCachedModules.html)\n\n\n\n#### Syntax\n\nclearCachedModules()\n\n#### Arguments\n\nNone\n\n#### Details\n\nClear all cached modules. After updating a module, execute this command to clear the cached module data. When you call the module via `use`, the system reloads it from the module file instead of using the cached data, and there is no need to restart the node.\n\nNote: This function can only be executed by administrators.\n\n#### Examples\n\nDefine a module.\n\n```\nmodule printLog\ndef printLog(){\nprint \"hello\"\n}\n```\n\nLoad the module.\n\n```\nuse printLog\nprintLog()\n// output\nhello\n```\n\nUpdate the module.\n\n```\nmodule printLog\ndef printLog(){\nprint \"hello new\"\n}\n```\n\nBefore loading the updated module, call `clearCachedModules` to clear the cached module.\n\n```\nlogin(\"admin\", \"123456\")\n\nclearCachedModules();\n\nuse printLog\nprintLog()\n// output\nhello new\n```\n"
    },
    "clearDSCache!": {
        "url": "https://docs.dolphindb.com/en/Functions/c/clearDSCache!.html",
        "signatures": [
            {
                "full": "clearDSCache!(ds)",
                "name": "clearDSCache!",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    }
                ]
            }
        ],
        "markdown": "### [clearDSCache!](https://docs.dolphindb.com/en/Functions/c/clearDSCache!.html)\n\n\n\n#### Syntax\n\nclearDSCache!(ds)\n\n#### Arguments\n\n**ds** is a data source or a list of data sources.\n\n#### Details\n\nInstruct the system to clear the cache after the next time the data source is executed.\n\n#### Examples\n\n```\nPTNDB_DIR = \"/home/db_testing\"\ndbName = database(PTNDB_DIR + \"/NYSETAQByName\")\nTrades = dbName.loadTable(`Trades)\n\nds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\nds.cacheDS!()        //cache the data\nds.clearDSCache!()   //clear the cache\n```\n"
    },
    "clearDSCacheNow": {
        "url": "https://docs.dolphindb.com/en/Functions/c/clearDSCacheNow.html",
        "signatures": [
            {
                "full": "clearDSCacheNow(ds)",
                "name": "clearDSCacheNow",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    }
                ]
            }
        ],
        "markdown": "### [clearDSCacheNow](https://docs.dolphindb.com/en/Functions/c/clearDSCacheNow.html)\n\n\n\n#### Syntax\n\nclearDSCacheNow(ds)\n\n#### Arguments\n\n**ds** is a data source or a list of data sources.\n\n#### Details\n\nImmediately clear the data source and cache.\n\n#### Examples\n\n```\nPTNDB_DIR = \"/home/db_testing\"\ndbName = database(PTNDB_DIR + \"/NYSETAQByName\")\nTrades = dbName.loadTable(`Trades)\n\nds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\nds.cacheDSNow()        //cache the data immediately\nds.clearDSCacheNow()   //clear the cache immediately\n```\n"
    },
    "clearTablePersistence": {
        "url": "https://docs.dolphindb.com/en/Functions/c/clearTablePersistence.html",
        "signatures": [
            {
                "full": "clearTablePersistence(table)",
                "name": "clearTablePersistence",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [clearTablePersistence](https://docs.dolphindb.com/en/Functions/c/clearTablePersistence.html)\n\n\n\n#### Syntax\n\nclearTablePersistence(table)\n\n#### Arguments\n\n**table** is a table object.\n\n#### Details\n\nDisable a table's persistence to disk, then delete the content of the table on disk. The table schema remains.\n\n#### Examples\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt = streamTable(100:0, colName, colType);\nenableTableShareAndPersistence(table=t, tableName=`st, cacheSize=1200000)\ngo;\n```\n\n```\nfor(s in 0:200){\n   n=10000\n   time=2019.01.01T00:00:00.000+s*n+1..n\n   x=rand(10.0, n)\n   insert into st values(time, x)\n}\nclearTablePersistence(st);\n```\n\nRelated commands: [enableTablePersistence](https://docs.dolphindb.com/en/Functions/e/enableTablePersistence.html), [disableTablePersistence](https://docs.dolphindb.com/en/Functions/d/disableTablePersistence.html)\n"
    },
    "clip": {
        "url": "https://docs.dolphindb.com/en/Functions/c/clip.html",
        "signatures": [
            {
                "full": "clip(X,Y,Z)",
                "name": "clip",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "Z",
                        "name": "Z"
                    }
                ]
            }
        ],
        "markdown": "### [clip](https://docs.dolphindb.com/en/Functions/c/clip.html)\n\n\n\n#### Syntax\n\nclip(X,Y,Z)\n\n#### Arguments\n\n**X** is a vector/matrix/table.\n\n**Y** is a scalar/vector/matrix/table.\n\n**Z** is a scalar/vector/matrix/table.\n\n* If *X* is a vector, *Y* and *Z* can be scalars or vectors of the same length as *X*.\n\n* If *X* is a matrix, *Y* and *Z* can be scalars or vectors with a length equal to the row number of *X*, matrices with the same dimensions as *X*.\n\n* If *X* is a table, *Y* and *Z* can be scalars or vectors with a length equal to the row number of *X*, tables with the same dimensions as *X*.\n\n#### Details\n\nIf *X* is a vector, return a vector *X'* of the same length.\n\n* Values in *X'* smaller than *Y* will be replaced by *Y*. If *Y* is a NULL scalar, no replacement will be done.\n\n* Values in *X'* greater than *Z* will be replaced by *Z*. If *Z* is a NULL scalar, no replacement will be done.\n\n* If *Y* or *Z* is a vector containing NULLs, values in *X'* with the same index will be replaced by NULLs.\n\n* If *Z* is smaller than *Y*, values in *X'* will be replaced by *Z*.\n\nIf *X* is a matrix or table, the aforementioned calculations will be performed on each column and return a matrix or table with the same dimensions.\n\n#### Examples\n\n```\nx = 1..9\ny = 3\nz = 7\nclip(x,y,z)\n// output\n[3,3,3,4,5,6,7,7,7]\n\nx = 1..9\ny = 3\nz = NULL\nclip(x,y,z)\n// output\n[3,3,3,4,5,6,7,8,9]\n\nx = 1..9$3:3\ny = [1,3,3,3,,5,6,7,8]$3:3\nz = [2,4,5,5,6,7,,6,10]$3:3\nclip(x,y,z)\n// output\n#0 #1 #2\n-- -- --\n1  4    \n3     6 \n3  6  9 \n\nx = table(1..3 as x1, 4..6 as x2, 7..9 as x3)\ny = table([1.0,3.5,3.0] as y1, [3,,5] as y2, [6,7,8] as y3)\nz = table([2,4,5] as z1, [5,6,7] as z2, [,6,10] as z3)\nclip(x,y,z)\n// output\nx1  x2 x3\n--- -- --\n1.0 4    \n3.5    6 \n3.0 6  9\n```\n"
    },
    "clip!": {
        "url": "https://docs.dolphindb.com/en/Functions/c/clip_.html",
        "signatures": [
            {
                "full": "clip!(X,Y,Z)",
                "name": "clip!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "Z",
                        "name": "Z"
                    }
                ]
            }
        ],
        "markdown": "### [clip!](https://docs.dolphindb.com/en/Functions/c/clip_.html)\n\n\n\n#### Syntax\n\nclip!(X,Y,Z)\n\n#### Arguments\n\n**X** is a vector/matrix/table.\n\n**Y** is a scalar/vector/matrix/table.\n\n**Z** is a scalar/vector/matrix/table.\n\n* If *X* is a vector, *Y* and *Z* can be scalars or vectors of the same length as *X*.\n\n* If *X* is a matrix, *Y* and *Z* can be scalars or vectors with a length equal to the row number of *X*, matrices with the same dimensions as *X*.\n\n* If *X* is a table, *Y* and *Z* can be scalars or vectors with a length equal to the row number of *X*, tables with the same dimensions as *X*.\n\n#### Details\n\nClip the values to be within a specified range. In *X*, values outside the range \\[Y, Z] are clipped to the interval edges.\n\n* Values in *X* smaller than *Y* will be replaced by *Y*. If *Y* is a NULL scalar, no replacement will be done.\n\n* Values in *X* greater than *Z* will be replaced by *Z*. If *Z* is a NULL scalar, no replacement will be done.\n\n* If *Y* or *Z* is a vector containing NULLs, values in *X* with the same index will be replaced by NULLs.\n\n* If *Z* is smaller than *Y*, values in *X'* will be replaced by *Z*.\n\nIf *X* is a matrix or table, the aforementioned calculations will be performed on each column and the values of *X* will be modified.\n\n**Note**: If the data type of *Y* or *Z* is inconsistent with that of *X*, values may be rounded or overflowed.\n\n#### Examples\n\n```\nx = 1..9\ny = 3\nz = 7\nclip!(x,y,z)\nprint(x)\n// output\n[3,3,3,4,5,6,7,7,7]\n\nx = 1..9\ny = 3\nz = NULL\nclip!(x,y,z)\nprint(x)\n// output\n[3,3,3,4,5,6,7,8,9]\n\nx = 1..9$3:3\ny = [1,3,3,3,,5,6,7,8]$3:3\nz = [2,4,5,5,6,7,,6,10]$3:3\nclip!(x,y,z)\nprint(x)\n// output\n#0 #1 #2\n-- -- --\n1  4    \n3     6 \n3  6  9 \n\nx = table(1..3 as x1, 4..6 as x2, 7..9 as x3)\ny = table([1.0,3.5,3.0] as y1, [3,,5] as y2, [6,7,8] as y3)\nz = table([2,4,5] as z1, [5,6,7] as z2, [,6,10] as z3)\nclip!(x,y,z)\nprint(x)\n// output\nx1  x2 x3\n--- -- --\n1.0 4    \n3.5    6 \n3.0 6  9 \n\n\nx = [1,2,3]\nx.clip!(1.1,2.2)\n// output\n[1,2,2]\n```\n"
    },
    "close": {
        "url": "https://docs.dolphindb.com/en/Functions/c/close.html",
        "signatures": [
            {
                "full": "close(X)",
                "name": "close",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [close](https://docs.dolphindb.com/en/Functions/c/close.html)\n\n\n\n#### Syntax\n\nclose(X)\n\n#### Arguments\n\n**X** is a file handle or a remote call connection.\n\n#### Details\n\nClose an opened file handle or a remote call connection. It must be executed by a logged-in user.\n\n#### Examples\n\n```\nfout.writeLine(\"hello world!\");\n// output\n1\n\nfout.close();\nfin = file(\"test3.txt\");\nprint fin.readLine();\nhello world!\nfin.close();\n```\n"
    },
    "closeSessions": {
        "url": "https://docs.dolphindb.com/en/Functions/c/closeSessions.html",
        "signatures": [
            {
                "full": "closeSessions(sessionId)",
                "name": "closeSessions",
                "parameters": [
                    {
                        "full": "sessionId",
                        "name": "sessionId"
                    }
                ]
            }
        ],
        "markdown": "### [closeSessions](https://docs.dolphindb.com/en/Functions/c/closeSessions.html)\n\n\n\n#### Syntax\n\ncloseSessions(sessionId)\n\n#### Arguments\n\n**sessionId** is a LONG scalar or vector indicating one or multiple session IDs.\n\n#### Details\n\nForce close one or multiple sessions.\n\n#### Examples\n\n```\ngetSessionMemoryStat();\n```\n\n| userId                   | sessionId     | memSize | remoteIP    | remotePort | createTime              | lastActiveTime          |\n| ------------------------ | ------------- | ------- | ----------- | ---------- | ----------------------- | ----------------------- |\n| \\_DimensionalTable\\_     | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_SharedTable\\_          | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_OLAPTablet\\_           | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_OLAPCacheEngine\\_      | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_OLAPCachedSymbolBase\\_ | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_DFSMetadata\\_          | 13,571        | 0.0.0.0 |             |            |                         |                         |\n| \\_TSDBCacheEngine\\_      | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_TSDBLevelFileIndex\\_   | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_TSDBCachedSymbolBase\\_ | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_StreamingPubQueue\\_    | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_StreamingSubQueue\\_    | 0             | 0.0.0.0 |             |            |                         |                         |\n| guest                    | 1,769,725,800 | 16      | 36.27.51.13 | 63,133     | 1970.01.01T00:00:00.000 | 2023.08.31T22:35:27.385 |\n| admin                    | 2,882,591,513 | 6,449   | 36.27.51.13 | 60,812     | 1970.01.01T00:00:00.000 | 2023.08.31T22:18:27.562 |\n\n```\ncloseSessions(getSessionMemoryStat().sessionId[11]);\n```\n\n| userId                   | sessionId     | memSize | remoteIP    | remotePort | createTime              | lastActiveTime          |\n| ------------------------ | ------------- | ------- | ----------- | ---------- | ----------------------- | ----------------------- |\n| \\_DimensionalTable\\_     | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_SharedTable\\_          | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_OLAPTablet\\_           | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_OLAPCacheEngine\\_      | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_OLAPCachedSymbolBase\\_ | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_DFSMetadata\\_          | 13,571        | 0.0.0.0 |             |            |                         |                         |\n| \\_StreamingPubQueue\\_    | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_StreamingSubQueue\\_    | 0             | 0.0.0.0 |             |            |                         |                         |\n| guest                    | 1,769,725,800 | 16      | 36.27.51.13 | 63,133     | 1970.01.01T00:00:00.000 | 2023.08.31T22:35:27.385 |\n| admin                    | 2,882,591,513 | 6,449   | 36.27.51.13 | 60,812     | 1970.01.01T00:00:00.000 | 2023.08.31T22:18:27.562 |\n\n```\ncloseSessions(getSessionMemoryStat().sessionId[8]);\n```\n"
    },
    "coevent": {
        "url": "https://docs.dolphindb.com/en/Functions/c/coevent.html",
        "signatures": [
            {
                "full": "coevent(event, eventTime, window, [orderSensitive=false])",
                "name": "coevent",
                "parameters": [
                    {
                        "full": "event",
                        "name": "event"
                    },
                    {
                        "full": "eventTime",
                        "name": "eventTime"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[orderSensitive=false]",
                        "name": "orderSensitive",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [coevent](https://docs.dolphindb.com/en/Functions/c/coevent.html)\n\n\n\n#### Syntax\n\ncoevent(event, eventTime, window, \\[orderSensitive=false])\n\n#### Arguments\n\n**event** is a vector indicating events.\n\n**eventTime** is a temporal or integer vector of the same length as event indicating the timestamps of events.\n\n**window** is a non-negative integer indicating the length of an interval.\n\n**orderSensitive** (optional) is a Boolean value indicating whether the order of the two events matters. The default value is false.\n\n#### Details\n\nCount the number of occurrences of two events within the specified intervals.\n\nReturn a table with 3 columns: event1, event2 and hits. The values of event1 and event2 are based on the column event. Column hits is the number of occurrences of the event pair.\n\n#### Examples\n\n```\nsensor_id=`A`B`C`D`C`A`B\ntime=[2012.06.13T12:30:00,2012.06.13T12:30:02,2012.06.13T12:30:04,2012.06.13T12:30:05,2012.06.13T12:30:06,2012.06.13T12:30:09,2012.06.13T12:30:10];\n\ncoevent(sensor_id, time, 2);\n```\n\n| event1 | event2 | hits |\n| ------ | ------ | ---- |\n| B      | C      | 1    |\n| C      | D      | 2    |\n| C      | C      | 1    |\n| A      | B      | 2    |\n\n```\ncoevent(sensor_id, time, 2, true);\n```\n\n| event1 | event2 | hits |\n| ------ | ------ | ---- |\n| C      | C      | 1    |\n| B      | C      | 1    |\n| C      | D      | 1    |\n| D      | C      | 1    |\n| A      | B      | 2    |\n"
    },
    "coint": {
        "url": "https://docs.dolphindb.com/en/Functions/c/coint.html",
        "signatures": [
            {
                "full": "coint(Y0, Y1, [trend=\"c\"], [method=\"aeg\"], [maxLag], [autoLag=\"aic\"])",
                "name": "coint",
                "parameters": [
                    {
                        "full": "Y0",
                        "name": "Y0"
                    },
                    {
                        "full": "Y1",
                        "name": "Y1"
                    },
                    {
                        "full": "[trend=\"c\"]",
                        "name": "trend",
                        "optional": true,
                        "default": "\"c\""
                    },
                    {
                        "full": "[method=\"aeg\"]",
                        "name": "method",
                        "optional": true,
                        "default": "\"aeg\""
                    },
                    {
                        "full": "[maxLag]",
                        "name": "maxLag",
                        "optional": true
                    },
                    {
                        "full": "[autoLag=\"aic\"]",
                        "name": "autoLag",
                        "optional": true,
                        "default": "\"aic\""
                    }
                ]
            }
        ],
        "markdown": "### [coint](https://docs.dolphindb.com/en/Functions/c/coint.html)\n\n\n\n#### Syntax\n\ncoint(Y0, Y1, \\[trend=\"c\"], \\[method=\"aeg\"], \\[maxLag], \\[autoLag=\"aic\"])\n\n#### Arguments\n\n**Y0**is a numeric vector indicating the first element in cointegrated system. NULL values are not supported.\n\n**Y1**is a numeric vector or matrix indicating the remaining elements in cointegrated system. The number of elements in Y1 and Y0 must be equal. NULL values are not supported.\n\n**trend**is a scalar specifying the trend term included in regression for cointegrating equation. It can be\n\n* \"c\" : constant.\n\n* \"ct\" : constant and linear trend.\n\n* \"ctt\" : constant, and linear and quadratic trend.\n\n* \"n\" : no constant, no trend.\n\n**method** is a string indicating the method for cointegration testing. Only \"aeg\" (augmented Engle-Granger) is available.\n\n**maxLag** is a non-negative integer indicating the largest number of lags, which is used as an argument for `adfuller`.\n\n**autoLag** is a string indicating the lag selection criterion, which is used as an argument for `adfuller`. It can be:\n\n* \"aic\": The number of lags is chosen to minimize the Akaike information criterion.\n\n* \"bic\": The number of lags is chosen to minimize the Bayesian information criterion.\n\n* \"tstat\": Start with *maxLag* and drops a lag until the t-statistic on the last lag length is significant using a 5%-sized test.\n\n* \"max\": The number of included lags is set to *maxLag*.\n\n#### Details\n\nTest for no-cointegration of a univariate equation.\n\n**Return value**: A dictionary containing the following keys\n\n* tStat: A floating-point scalar indicating the t-statistic of unit-root test on residuals.\n\n* pValue: A floating-point scalar indicating the MacKinnon's approximate p-value based on MacKinnon (1994, 2010).\n\n* criticalValues: A dictionary containing the critical values for the test statistic at the 1 %, 5 %, and 10 % levels based on regression curve.\n\n#### Examples\n\n```\nY0 = 234 267 289 301 312 323 334 345 356;\nY1 = 267 289 301 312 323 334 345 356 367;\ncoint(Y0, Y1);\n```\n\nA dictionary is returned:\n\n```\ntValue->-1.498236972489574\npValue->0.761867238199341\ncriticalValues->[-5.789286875000001,-4.206501875,-3.6171]\n```\n"
    },
    "col": {
        "url": "https://docs.dolphindb.com/en/Functions/c/col.html",
        "signatures": [
            {
                "full": "col(obj, index)",
                "name": "col",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "index",
                        "name": "index"
                    }
                ]
            },
            {
                "full": "column(obj, index)",
                "name": "column",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "index",
                        "name": "index"
                    }
                ]
            }
        ],
        "markdown": "### [col](https://docs.dolphindb.com/en/Functions/c/col.html)\n\n\n\n#### Syntax\n\ncol(obj, index)\n\nor\n\ncolumn(obj, index)\n\n#### Arguments\n\n**obj** is a vector/matrix/table.\n\n**index** is an integral scalar or pair.\n\n#### Details\n\nReturn a column of a vector/matrix/table. Please check related function: [row](https://docs.dolphindb.com/en/Functions/r/row.html).\n\n#### Examples\n\n```\nx=1..6$3:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ncol(x,0);\n// output\n[1,2,3]\n\nx.col(1);\n// output\n[4,5,6]\n\na=table(1..3 as x,`IBM`C`AAPL as y);\na;\n```\n\n| x | y    |\n| - | ---- |\n| 1 | IBM  |\n| 2 | C    |\n| 3 | AAPL |\n\n```\na col 1;\n// output\n[\"IBM\",\"C\",\"AAPL\"]\n```\n"
    },
    "cols": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cols.html",
        "signatures": [
            {
                "full": "cols(X)",
                "name": "cols",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cols](https://docs.dolphindb.com/en/Functions/c/cols.html)\n\n\n\n#### Syntax\n\ncols(X)\n\n#### Arguments\n\n**X** is a vector/matrix/table.\n\n#### Details\n\nReturn the total number of columns in *X*. Please check related function: [rows](https://docs.dolphindb.com/en/Functions/r/rows.html).\n\n#### Examples\n\n```\nx=1..6$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\ncols x;\n// output\n3\n\na=table(1..3 as x,`IBM`C`AAPL as y);\na;\n```\n\n| x | y    |\n| - | ---- |\n| 1 | IBM  |\n| 2 | C    |\n| 3 | AAPL |\n\n```\ncols a;\n// output\n2\n\ny=1 2 3;\ncols(y);\n// output\n1  // a vector can be viewed as an n*1 matrix\n```\n"
    },
    "columnNames": {
        "url": "https://docs.dolphindb.com/en/Functions/c/columnNames.html",
        "signatures": [
            {
                "full": "columnNames(X)",
                "name": "columnNames",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [columnNames](https://docs.dolphindb.com/en/Functions/c/columnNames.html)\n\n\n\n#### Syntax\n\ncolumnNames(X)\n\n#### Arguments\n\n**X** is a matrix/table.\n\n#### Details\n\nReturn the column names of *X* as a vector. Please check related function: [rowNames](https://docs.dolphindb.com/en/Functions/r/rowNames.html).\n\n#### Examples\n\n```\nx=1..6$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nx.rename!(`a`b`c);\n```\n\n| a | b | c |\n| - | - | - |\n| 1 | 3 | 5 |\n| 2 | 4 | 6 |\n\n```\nx.columnNames();\n// output\n[\"a\",\"b\",\"c\"]\n\nt = table(1 2 3 as id, 4 5 6 as value, `IBM`MSFT`GOOG as name);\nt;\n```\n\n| id | value | name |\n| -- | ----- | ---- |\n| 1  | 4     | IBM  |\n| 2  | 5     | MSFT |\n| 3  | 6     | GOOG |\n\n```\ncolumnNames t;\n// output\n[\"id\",\"value\",\"name\"]\n\nt[t.columnNames().tail()];\n// output\n[\"IBM\",\"MSFT\",\"GOOG\"] // retrieve the last column of a table as a vector\n```\n"
    },
    "complex": {
        "url": "https://docs.dolphindb.com/en/Functions/c/complex.html",
        "signatures": [
            {
                "full": "complex(X, Y)",
                "name": "complex",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [complex](https://docs.dolphindb.com/en/Functions/c/complex.html)\n\n\n\n#### Syntax\n\ncomplex(X, Y)\n\n#### Arguments\n\n**X** and **Y** are numeric scalars, pairs, vectors or matrices. They can be of Integral (excluding compress and INT128) or Floating type.\n\n#### Details\n\nCreate a complex number `X+Y*i`.\n\nThe length of a complex number is 16 bytes. The low 8 bytes are stored in *X*, and the high 8 bytes are stored in *Y*.\n\n#### Examples\n\n```\ncomplex(2, 5)\n// output\n2.0+5.0i\n\na=1.0 2.3\nb=3 4\ncomplex(a,b)\n```\n\n| 0        | 1        |\n| -------- | -------- |\n| 1.0+3.0i | 2.3+4.0i |\n"
    },
    "compress": {
        "url": "https://docs.dolphindb.com/en/Functions/c/compress.html",
        "signatures": [
            {
                "full": "compress(X, [method='lz4'])",
                "name": "compress",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[method='lz4']",
                        "name": "method",
                        "optional": true,
                        "default": "'lz4'"
                    }
                ]
            }
        ],
        "markdown": "### [compress](https://docs.dolphindb.com/en/Functions/c/compress.html)\n\n\n\n#### Syntax\n\ncompress(X, \\[method='lz4'])\n\n#### Arguments\n\n**X** is a vector or a table.\n\n**method** (optional) is a string indicating the compression algorithm. The available options are:\n\n* \"lz4\" (by default) is suitable for almost all data types. Although the \"lz4\" method may not achieve the highest compression ratio, it provides fast compression and decompression speeds.\n\n* \"delta\" option applies delta-of-delta algorithm, which is particularly suitable for data types like SHORT, INT, LONG, and date/time data.\n\n* \"zstd\" is also suitable for almost all data types. It provides a higher compression ratio compared to \"lz4\", but the compression and decompression speed is about half as fast as \"lz4\".\n\n* \"chimp\" is suitable for DOUBLE type data with decimal parts not exceeding three digits in length.\n\n#### Details\n\nCompress a vector or a table with the specified compression algorithm. The compressed variable needs to be decompressed with function [decompress](https://docs.dolphindb.com/en/Functions/d/decompress.html) before it can be used in a calculation.\n\n#### Examples\n\n```\nx=1..100000000\ny=compress(x, \"delta\");\n\ny.typestr();\n// output: HUGE COMPRESSED VECTOR\n\nz=compress(x, \"zstd\");\nz.typestr();\n// output: HUGE COMPRESSED VECTOR\n\nselect name, bytes from objs() where name in `x`y;\n```\n\n| name | bytes     |\n| ---- | --------- |\n| x    | 402653952 |\n| y    | 13634544  |\n\nPlease note that if function `size` is applied on the compressed vector y, the result is the length of the compressed vector y instead of the original vector x. To extract information about x from y, we need to decompress y first.\n\n```\ny.size();\n// output: 12670932\n\nz=decompress(y);\nz.size();\n// output: 100000000\n```\n\nRelated functions: [decompress](https://docs.dolphindb.com/en/Functions/d/decompress.html)\n"
    },
    "concat": {
        "url": "https://docs.dolphindb.com/en/Functions/c/concat.html",
        "signatures": [
            {
                "full": "concat(X, Y)",
                "name": "concat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [concat](https://docs.dolphindb.com/en/Functions/c/concat.html)\n\n\n\n#### Syntax\n\nconcat(X, Y)\n\n#### Arguments\n\n**X** can be a STRING/CHAR scalar or vector.\n\n**Y** can be a STRING/CHAR scalar.\n\nIf *X* or *Y* is not specified, it is treated as an empty string.\n\n#### Details\n\nIf *X* is a STRING/CHAR scalar\n\n* For an empty *X*,\n\n  * if *Y* is an empty STRING/CHAR scalar, the function returns an empty string.\n\n  * if *Y* is a non-empty STRING/CHAR scalar, the function returns *Y*.\n\n* Otherwise, the function forms a new string by combining *X* and *Y* regardless of whether *Y* is an empty string or not.\n\nIf *X* is a STRING/CHAR vector\n\n* For an empty *X*, the function returns an empty string.\n\n* Otherwise,\n\n  * if *Y* is an empty STRING/CHAR scalar, the function concatenates each element in *X* and returns a string object;\n\n  * if *Y* is a non-empty STRING/CHAR scalar, *Y* serves as the separator between the elements in vector *X* and the function returns a string object.\n\nNote: The function *concat* implicitly converts all arguments to STRING type (NULL values to empty strings) before concatenation.\n\n**Return value**: a STRING scalar\n\n#### Examples\n\n```\n// join two strings\nconcat (`hello, `world);\n// output\nhelloworld\n\n// join IBM, GOOG and APPL with \",\" as the delimiter\nx = concat(`IBM`GOOG`APPL, \",\");\nx;\n// output\nIBM,GOOG,APPL\n\ntypestr x;\n// output\nSTRING\n\nsize x;\n// output\n1\n\nconcat(string([]),\"a\")\n// output\nNULL\n\nconcat(\"55\",\"\")\n// output\n55\n\n// When Y is not specified, the function joins the elements of X to form a new string\nconcat(`a`b`c`d,)\n// output\nabcd\n```\n"
    },
    "concatDateTime": {
        "url": "https://docs.dolphindb.com/en/Functions/c/concatDateTime.html",
        "signatures": [
            {
                "full": "concatDateTime(date, time)",
                "name": "concatDateTime",
                "parameters": [
                    {
                        "full": "date",
                        "name": "date"
                    },
                    {
                        "full": "time",
                        "name": "time"
                    }
                ]
            }
        ],
        "markdown": "### [concatDateTime](https://docs.dolphindb.com/en/Functions/c/concatDateTime.html)\n\n\n\n#### Syntax\n\nconcatDateTime(date, time)\n\nAlias: concatDT\n\n#### Arguments\n\n**date** is a scalar/vector of data type DATE.\n\n**time** is a scalar/vector of data type SECOND, TIME or NANOTIME.\n\nIf *date* and *time* are both vector,s they must have the same length.\n\n#### Details\n\nCombine *date* and *time* into one new variable.\n\nIf *time* is SECOND, return DATETIME.\n\nIf *time* is TIME, return TIMESTAMP.\n\nIf *time* is NANOTIME, return NANOTIMESTAMP.\n\n#### Examples\n\n```\nconcatDateTime(2019.06.15,13:25:10);\n// output\n2019.06.15T13:25:10\n\nconcatDateTime(2019.06.15,[13:25:10, 13:25:12, 13:25:13]);\n// output\n[2019.06.15T13:25:10,2019.06.15T13:25:12,2019.06.15T13:25:13]\n\ndate=[2019.06.18, 2019.06.20, 2019.06.21, 2019.06.19, 2019.06.18, 2019.06.20]\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26]\nsym = `C`MS`MS`MS`IBM`IBM$SYMBOL\nprice= 49.6 29.46 29.52 30.02 174.97 175.23\nqty = 2200 1900 2100 3200 6800 5400\nt = table(date, time, sym, qty, price);\n\nselect concatDateTime(date,time) as datetime, sym, qty, price from t;\n```\n\n| datetime            | sym | qty  | price  |\n| ------------------- | --- | ---- | ------ |\n| 2019.06.18T09:34:07 | C   | 2200 | 49.6   |\n| 2019.06.20T09:36:42 | MS  | 1900 | 29.46  |\n| 2019.06.21T09:36:51 | MS  | 2100 | 29.52  |\n| 2019.06.19T09:36:59 | MS  | 3200 | 30.02  |\n| 2019.06.18T09:32:47 | IBM | 6800 | 174.97 |\n| 2019.06.20T09:35:26 | IBM | 5400 | 175.23 |\n"
    },
    "concatMatrix": {
        "url": "https://docs.dolphindb.com/en/Functions/c/concatMatrix.html",
        "signatures": [
            {
                "full": "concatMatrix(X, [horizontal=true])",
                "name": "concatMatrix",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[horizontal=true]",
                        "name": "horizontal",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [concatMatrix](https://docs.dolphindb.com/en/Functions/c/concatMatrix.html)\n\n\n\n#### Syntax\n\nconcatMatrix(X, \\[horizontal=true])\n\n#### Arguments\n\n**X** is a tuple of multiple matrices.\n\n**horizontal** (optional) is a Boolean value indicating whether the matrices are contatenated horizontally. The default value is true. If set to false, the matrices are contatenated vertically.\n\n#### Details\n\nConcatenate the matrices vertically or horizontally.\n\nWhen you concatenate matrices horizontally, they must have the same number of rows. When you concatenate them vertically, they must have the same number of columns.\n\n#### Examples\n\n```\nm1 = matrix(4 0 5, 2 1 8);\nm2 = matrix(2 9 8, 3 7 -3, 6 4 2, 0 5 8);\nm3 = matrix(1 -1 6 2, 1 -3 1 9, 5 3 0 -4, 1 NULL 3 4);\nconcatMatrix([m1, m2]);\n```\n\n| col1 | col2 | col3 | col4 | col5 | col6 |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n| 4    | 2    | 2    | 3    | 6    | 0    |\n| 0    | 1    | 9    | 7    | 4    | 5    |\n| 5    | 8    | 8    | -3   | 2    | 8    |\n\n```\nprint concatMatrix([m2, m3], false);\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 2    | 3    | 6    | 0    |\n| 9    | 7    | 4    | 5    |\n| 8    | -3   | 2    | 8    |\n| 1    | 1    | 5    | 1    |\n| -1   | -3   | 3    |      |\n| 6    | 1    | 0    | 3    |\n| 2    | 9    | 4    | 4    |\n"
    },
    "conditionalFilter": {
        "url": "https://docs.dolphindb.com/en/Functions/c/conditionalFilter.html",
        "signatures": [
            {
                "full": "conditionalFilter(X, condition, filterMap)",
                "name": "conditionalFilter",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "condition",
                        "name": "condition"
                    },
                    {
                        "full": "filterMap",
                        "name": "filterMap"
                    }
                ]
            }
        ],
        "markdown": "### [conditionalFilter](https://docs.dolphindb.com/en/Functions/c/conditionalFilter.html)\n\n\n\n#### Syntax\n\nconditionalFilter(X, condition, filterMap)\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n**condition** is a scalar or a vector of the same length as *X*.\n\n**filterMap** is a dictionary indicating the filtering conditions.\n\n#### Details\n\nReturn true if both of the following conditions are satisfied, otherwise return false.\n\n* An element in the vector condition is a key to the dictionary *filterMap*;\n\n* The corresponding element in *X* is one of the elements of the key's value in the dictionary *filterMap*.\n\nIf both *X* and *condition* are vectors, the result is a vector of the same length as X.\n\n#### Examples\n\nExample 1\n\n```\nconditionalFilter(1 2 3,`a`b`c, dict(`a`b,1 2));\n// output\n[1,1,0]\n\nconditionalFilter(1 2 3,`a`b`b, dict(`a`b,[1 2,3 4]))\n// output\n[1,0,1]\n```\n\nExample 2. Get the specified stock data of the specified dates from table t:\n\n2012.06.01: C, MS 2012.06.02: IBM, MS 2012.06.03: MS 2012.06.04: IBM\n\n```\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C$SYMBOL\ndate = 2012.06.01 2012.06.01 2012.06.02 2012.06.03 2012.06.01 2012.06.02 2012.06.02 2012.06.03 2012.06.04\nprice = 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nt = table(sym, date, price, qty)\nt;\n```\n\n| sym | date       | price  | qty  |\n| --- | ---------- | ------ | ---- |\n| C   | 2012.06.01 | 49.60  | 2200 |\n| MS  | 2012.06.01 | 29.46  | 1900 |\n| MS  | 2012.06.02 | 29.52  | 2100 |\n| MS  | 2012.06.03 | 30.02  | 3200 |\n| IBM | 2012.06.01 | 174.97 | 6800 |\n| IBM | 2012.06.02 | 175.23 | 5400 |\n| C   | 2012.06.02 | 50.76  | 1300 |\n| C   | 2012.06.03 | 50.32  | 2500 |\n| C   | 2012.06.04 | 51.29  | 8800 |\n\n```\nfilter = dict(2012.06.01..2012.06.04, [`C`MS, `IBM`MS, `MS, `IBM])\nselect * from t where conditionalFilter(sym, date, filter) order by date, sym;\n```\n\n| sym | date       | price  | qty  |\n| --- | ---------- | ------ | ---- |\n| C   | 2012.06.01 | 49.6   | 2200 |\n| MS  | 2012.06.01 | 29.46  | 1900 |\n| IBM | 2012.06.02 | 175.23 | 5400 |\n| MS  | 2012.06.02 | 29.52  | 2100 |\n| MS  | 2012.06.03 | 30.02  | 3200 |\n\nExample 3. The values of *filterMap* can also be pairs:\n\n```\nt=table(`aaa`aaa`bbb`bbb as id, 2020.09.03 2020.09.10 2020.09.06 2020.09.09 as date)\nt\n```\n\n| id  | date       |\n| --- | ---------- |\n| aaa | 2020.09.03 |\n| aaa | 2020.09.10 |\n| bbb | 2020.09.06 |\n| bbb | 2020.09.09 |\n\n```\nmydict = dict(`aaa`bbb, [2020.09.01 : 2020.09.09,  2020.09.05 : 2020.09.09])\nselect * from t where conditionalFilter(date, id, mydict);\n```\n\n| id  | date       |\n| --- | ---------- |\n| aaa | 2020.09.03 |\n| bbb | 2020.09.06 |\n| bbb | 2020.09.09 |\n"
    },
    "conditionalIterate": {
        "url": "https://docs.dolphindb.com/en/Functions/c/conditionalIterate.html",
        "signatures": [
            {
                "full": "conditionalIterate(cond, trueValue, falseIterFunc)",
                "name": "conditionalIterate",
                "parameters": [
                    {
                        "full": "cond",
                        "name": "cond"
                    },
                    {
                        "full": "trueValue",
                        "name": "trueValue"
                    },
                    {
                        "full": "falseIterFunc",
                        "name": "falseIterFunc"
                    }
                ]
            }
        ],
        "markdown": "### [conditionalIterate](https://docs.dolphindb.com/en/Functions/c/conditionalIterate.html)\n\n\n\n#### Syntax\n\nconditionalIterate(cond, trueValue, falseIterFunc)\n\nThis function can only be used as a state function in the [reactive state engine](https://docs.dolphindb.com/en/Functions/c/createReactiveStateEngine.html).\n\n#### Arguments\n\n**cond** is a conditional expression or a function with BOOLEAN return values. It must contain fields from the input table. Constants/constant expressions are not supported.\n\n**trueValue** is the calculation formula.\n\n**falseIterFunc** is the function for iteration, whose only parameter is the column from the output table. Currently, only the following functions are supported (use partial application to specify functions with multiple parameters):\n\n* Moving functions: `tmove`, `tmavg`, `tmmax`, `tmmin`, `tmsum`, `mavg`, `mmax`, `mmin`, `mcount`, `msum`;\n\n* Cumulative window functions: `cumlastNot`, `cumfirstNot`;\n\n* Order-sensitive functions: `ffill`, `move`.\n\nIf *cond* returns true, the calculation of *trueValue* is triggered. If *cond* returns false, *falseIterFunc* is called for iteration.\n\n#### Note:\n\n* As the iterations are performed based on the historical data, the output for the current record is calculated based on the historical results in the output table and *X*.\n\n* When calculating with time-based moving windows, windows are determined by the current timestamp T, i.e., *(T - window, T)*.\n\n* The data type of the result column is determined by the result of *trueValue*. Therefore, the data type of the result of *trueValue* and *falseIterFunc* must be compatible. Data type compatibility rules:\n\n  * INT, SHORT, LONG and CHAR are compatible;\n\n  * FLOAT and DOUBLE are compatible;\n\n  * STRING and SYMBOL are compatible.\n\n#### Details\n\nSupposing the iteration is based only on the previous result, for the k-th (k ∈ N+) record, the calculation logic is (where the column \"factor\" holds the results):\n\n* cond\\[k] == true: factor\\[k] = trueValue\n* cond\\[k] == false: factor\\[k] = falseIterFunc(factor)\\[k-1]\n\nNote: If *falseIterFunc* is a window function, the iteration is based on multiple previous results.\n\n#### Examples\n\nExample 1. Understand the calculation logic of `conditionalIterate` with the following example.\n\n```\ntrade = table(take(\"A\", 10) as sym,  take(1 3 6, 10) as val0,  take(10, 10) as val1)\ntrade\n```\n\n| sym | val0 | val1 |\n| --- | ---- | ---- |\n| A   | 1    | 10   |\n| A   | 3    | 10   |\n| A   | 6    | 10   |\n| A   | 1    | 10   |\n| A   | 3    | 10   |\n| A   | 6    | 10   |\n| A   | 1    | 10   |\n| A   | 3    | 10   |\n| A   | 6    | 10   |\n| A   | 1    | 10   |\n\nDefine a reactive state stream engine and group the data by \"sym\" for calculation.\n\n* If val0 > 5 returns true, the formula is *factor\\[k]=trueValue*. Output the value of val1.\n\n* If val0 > 5 returns false, the corresponding formula is *factor\\[k]=falseIterFunc(factor)\\[k-1]*. When k=3, then the corresponding val0=1, val1=10, factor=\\[NULL, NULL, 10], the result is *msum(\\[NULL, NULL, 10], 3)\\[2]=10*. Similarly, when k=4, the corresponding val0=3, val1=10, factor=\\[NULL, NULL, 10, 10], the result is *msum(\\[NULL, NULL, 10, 10], 3)\\[3]=20*.\n\n```\ninputTable = streamTable(1:0, `sym`val0`val1, [SYMBOL, INT, INT])\noutputTable = table(100:0, `sym`factor, [STRING, DOUBLE])\nrse = createReactiveStateEngine(name=\"rsTest\", metrics=<conditionalIterate(val0 > 5, val1, msum{, 3})>, dummyTable=inputTable, outputTable=outputTable, keyColumn=\"sym\")\nrse.append!(trade)\nselect * from outputTable\n```\n\n| sym | factor |\n| --- | ------ |\n| A   |        |\n| A   |        |\n| A   | 10     |\n| A   | 10     |\n| A   | 20     |\n| A   | 10     |\n| A   | 40     |\n| A   | 70     |\n| A   | 10     |\n| A   | 120    |\n\nExample 2. The calculation logic of \"factor\":\n\n```\ndef factor(TotalVolumeTrade, TotalValueTrade, HighPx, LowPx){\n    factorValue = iif(TotalVolumeTrade < 1500000, pow(HighPx*LowPx, 0.5)-(TotalVolumeTrade/TotalValueTrade), mavg(factor(TotalVolumeTrade, TotalValueTrade, HighPx, LowPx), 3))\n    return factorValue\n}\n```\n\nThe calculation of factor involves recursion. You can use function `conditionalIterate` to implement the factor in a reactive state engine with the following script:\n\n```\n@state\ndef factor1(TotalVolumeTrade, TotalValueTrade, HighPx, LowPx){\n   factorValue = conditionalIterate(TotalVolumeTrade < 1500000, (pow(HighPx*LowPx, 0.5)-(TotalVolumeTrade/TotalValueTrade)), mavg{,3})\n   return factorValue\n}\n\nSecurityID =  [\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\"]$SYMBOL\nDate = [2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01]\nTime = [09:30:00.000,09:30:03.000,09:30:06.000,09:30:09.000,09:30:12.000,09:30:15.000,09:30:18.000,09:30:21.000,09:30:24.000,09:30:27.000]\nTotalVolumeTrade = [844800,1035700,1240100,1304500,1457800,1522400,1550900,1663800,1692100,1767100]\nTotalValueTrade = [12982101,15908020,19038479,20022525,22363886,23349799,23784950,25506625.75,25937850.75,27080561.75]\nHighPx = [15.37,15.37,15.37,15.37,15.37,15.37,15.37,15.37,15.37,15.37]\nLowPx = [15.3,15.3,15.29,15.28,15.24,15.24,15.24,15.22,15.22,15.22]\ntrade = table(SecurityID, Date, Time, TotalVolumeTrade, TotalValueTrade, HighPx, LowPx)\n\nresult = table(1:0, `SecurityID`Date`Time`Factor, `SYMBOL`DATE`TIME`DOUBLE)\n\nfactor=[<Date>,<Time>, <factor1(TotalVolumeTrade, TotalValueTrade, HighPx, LowPx)>]\nrse = createReactiveStateEngine(name=\"rsTest\", metrics=factor, dummyTable=trade, outputTable=result, keyColumn=\"SecurityID\")\nrse.append!(trade)\n\ntrade1 = select *,  (pow(HighPx*LowPx, 0.5)-(TotalVolumeTrade/TotalValueTrade)) as Factor0 from trade\nselect * from lj(trade1, result, `SecurityID`Date`Time)\ndropStreamEngine(\"rsTest\")\n```\n\nThe following is part of the result:\n\n![](https://docs.dolphindb.com/en/images/conditionalIterate_output.png)\n\nFor records in blue box, data in column Factor is the results of *trueValue*, which are the same as the output in Factor0. For records in red box, data in column Factor is the results of *falseIterFunc*, and each of them is the average of the previous three results.\n\nRelated functions: [stateIterate](https://docs.dolphindb.com/en/Functions/s/stateIterate.html)\n"
    },
    "condValueAtRisk": {
        "url": "https://docs.dolphindb.com/en/Functions/c/condValueAtRisk.html",
        "signatures": [
            {
                "full": "condValueAtRisk(returns, method, [confidenceLevel=0.95])",
                "name": "condValueAtRisk",
                "parameters": [
                    {
                        "full": "returns",
                        "name": "returns"
                    },
                    {
                        "full": "method",
                        "name": "method"
                    },
                    {
                        "full": "[confidenceLevel=0.95]",
                        "name": "confidenceLevel",
                        "optional": true,
                        "default": "0.95"
                    }
                ]
            }
        ],
        "markdown": "### [condValueAtRisk](https://docs.dolphindb.com/en/Functions/c/condValueAtRisk.html)\n\n#### Syntax\n\ncondValueAtRisk(returns, method, \\[confidenceLevel=0.95])\n\nAlias: CVaR\n\n#### Arguments\n\n**returns** is a numeric vector representing the returns. The element must be greater than -1 and cannot be empty.\n\n**method** is a string indicating the CVaR calculation method, which can be:\n\n* 'normal': parametric method with normal distribution\n* 'logNormal': parametric method with log-normal distribution\n* 'historical': historical method\n* 'monteCarlo': Monte Carlo simulation\n\n**confidenceLevel** (optional) is a numeric scalar representing the confidence level, with a valid range of (0,1). The default value is 0.95.\n\n#### Details\n\nCalculate Conditional Value at Risk (CVaR), or expected shortfall (ES) to estimate the average losses incurred beyond the VaR level.\n\n**Return value**: a DOUBLE value indicating the absolute value of the average losses that exceed the VaR. The value of VaR is returned if there is no return beyond the level.\n\n#### Examples\n\nCalculate CVaR using historical method at a confidence level of 0.9 based on given returns:\n\n```\nreturns = [0.0, -0.0023816107391389394, -0.0028351258634076834, 0.00789570628538656, 0.0022056267475062397, -0.004515475812603498, 0.0031189325339843646, 0.010774648811452205, 0.0030816164453268957, 0.02172541561228001, 0.011106185767699728, -0.005369098699244845, -0.0096490689793588, 0.0025152212699484314, 0.017822140037111668, -0.02837536728283525, 0.018373545076599204, -0.0026401111537113003, 0.019524374522517898, -0.010800546314337627, 0.014073362622486131, -0.00398277532382243, 0.008398647051501285, 0.0024056749358184904, 0.007093080335863512, -0.005332549248384733, -0.008471915938733665, -0.0038788486165083342, -0.01308504169086584, 0.00350496242864784, 0.009036118926745962, 0.0013358223875250545, 0.0036426642608267563, 0.003974568474545581, -0.003944066366522669, -0.011969668605022311, 0.015116930499066374, 0.006931427295653037, -0.0032650627551519267, 0.003407880132851648]\ncondValueAtRisk(returns, 'historical', 0.9);\n//output: 0.016057655973\n```\n\n"
    },
    "contextCount": {
        "url": "https://docs.dolphindb.com/en/Functions/c/contextCount.html",
        "signatures": [
            {
                "full": "contextCount(X, Y)",
                "name": "contextCount",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [contextCount](https://docs.dolphindb.com/en/Functions/c/contextCount.html)\n\n\n\n#### Syntax\n\ncontextCount(X, Y)\n\n#### Arguments\n\n**X** and **Y** are vectors of the same length.\n\n#### Details\n\nCount the number of positions that are not NULL in both *X* and *Y*.\n\n#### Examples\n\n```\ncontextCount(1 2 3, 1 NULL 3)\n// output\n2\n\ncontextCount(1..3,true false true)\n// output\n3\n\ncontextCount(1 2 NULL, 1 NULL 3)\n// output\n1\n```\n\nRelated functions: [contextSum](https://docs.dolphindb.com/en/Functions/c/contextSum.html), [contextSum2](https://docs.dolphindb.com/en/Functions/c/contextSum2.html)\n"
    },
    "contextSum": {
        "url": "https://docs.dolphindb.com/en/Functions/c/contextSum.html",
        "signatures": [
            {
                "full": "contextSum(X, Y)",
                "name": "contextSum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [contextSum](https://docs.dolphindb.com/en/Functions/c/contextSum.html)\n\n\n\n#### Syntax\n\ncontextSum(X, Y)\n\n#### Arguments\n\n**X** and **Y** are vectors, matrices or tables.\n\n#### Details\n\nGet of positions that are not NULL in both *X* and *Y*, and calculate the sum of the elements in *X* on these positions.\n\n#### Examples\n\n```\ncontextSum(1 2 3 4 5, 2 3 4 5 6)\n// output\n15\n\ncontextSum(1..3, true false true)\n// output\n6\n\ncontextSum(1 2 NULL, 1 NULL 3)\n// output\n1\n```\n\nRelated functions: [contextCount](https://docs.dolphindb.com/en/Functions/c/contextCount.html), [contextSum2](https://docs.dolphindb.com/en/Functions/c/contextSum2.html)\n"
    },
    "contextSum2": {
        "url": "https://docs.dolphindb.com/en/Functions/c/contextSum2.html",
        "signatures": [
            {
                "full": "contextSum2(X, Y)",
                "name": "contextSum2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [contextSum2](https://docs.dolphindb.com/en/Functions/c/contextSum2.html)\n\n\n\n#### Syntax\n\ncontextSum2(X, Y)\n\n#### Arguments\n\n**X** and **Y** are vectors, matrices or tables.\n\n#### Details\n\nGet of positions that are not NULL in both *X* and *Y*, and calculate the sum of squares of the elements in *X* on these positions.\n\n**Return Value**: DOUBLE type (regardless of the data types of *X* and *Y*)\n\n#### Examples\n\n```\ncontextSum2(1 2 3, 10 NULL 30);\n// output\n10\n\ncontextSum2(1 2 3, true false true);\n// output\n14\n```\n\nRelated functions: [contextCount](https://docs.dolphindb.com/en/Functions/c/contextCount.html), [contextSum](https://docs.dolphindb.com/en/Functions/c/contextSum.html)\n"
    },
    "convertEncode": {
        "url": "https://docs.dolphindb.com/en/Functions/c/convertEncode.html",
        "signatures": [
            {
                "full": "convertEncode(str, srcEncode, destEncode)",
                "name": "convertEncode",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "srcEncode",
                        "name": "srcEncode"
                    },
                    {
                        "full": "destEncode",
                        "name": "destEncode"
                    }
                ]
            }
        ],
        "markdown": "### [convertEncode](https://docs.dolphindb.com/en/Functions/c/convertEncode.html)\n\n\n\n#### Syntax\n\nconvertEncode(str, srcEncode, destEncode)\n\n#### Arguments\n\n**str** is a STRING scalar/vector.\n\n**srcEncode** is a string indicating the original encoding name.\n\n**destEncode** is a string indicating the new encoding name.\n\n#### Details\n\nChange the encoding of strings. All encoding names must use lowercase.\n\nThe Linux version supports conversion between any two encodings. The Windows version only supports conversion between GBK and UTF-8.\n\n#### Examples\n\n```\nconvertEncode(\"high-performance time-series database\",\"utf-8\",\"gbk\");\n// output\nhigh-performance time-series database\n\nconvertEncode([\"hello\",\"DolphinDB\"],\"gbk\",\"utf-8\");\n// output\n[\"hello\",\"DolphinDB\"]\n```\n\nRelated functions: [fromUTF8](https://docs.dolphindb.com/en/Functions/f/fromUTF8.html), [toUTF8](https://docs.dolphindb.com/en/Functions/t/toUTF8.html)\n"
    },
    "convertExcelFormula": {
        "url": "https://docs.dolphindb.com/en/Functions/c/convertExcelFormula.html",
        "signatures": [
            {
                "full": "convertExcelFormula(formula, colStart, colEnd, rowStart, rowEnd)",
                "name": "convertExcelFormula",
                "parameters": [
                    {
                        "full": "formula",
                        "name": "formula"
                    },
                    {
                        "full": "colStart",
                        "name": "colStart"
                    },
                    {
                        "full": "colEnd",
                        "name": "colEnd"
                    },
                    {
                        "full": "rowStart",
                        "name": "rowStart"
                    },
                    {
                        "full": "rowEnd",
                        "name": "rowEnd"
                    }
                ]
            }
        ],
        "markdown": "### [convertExcelFormula](https://docs.dolphindb.com/en/Functions/c/convertExcelFormula.html)\n\n\n\n#### Syntax\n\nconvertExcelFormula(formula, colStart, colEnd, rowStart, rowEnd)\n\n#### Arguments\n\n**formula** is a STRING scalar/vector indicating an Excel formula.\n\n**colStart** is a STRING scalar indicating the starting column of the data in Excel.\n\n**colEnd** is a STRING scalar indicating the ending column of the data in Excel.\n\n**rowStart** is a positive integer indicating the starting row of the data in Excel.\n\n**rowEnd** is a positive integer indicating the ending row of the data in Excel. *rowEnd* must be greater than or equal to *rowStart*.\n\n#### Details\n\nConvert Excel formula to DolphinDB expressions.\n\nThe function only supports the following conversions: the arithmetic operations, logical operations, and aggregate functions.\n\nCurrently, it does not support converting the expressions that operate on both rows and columns.\n\nWhen applying an aggregate function on a single column, the aggregation will be performed on this column if the processing row number is equal to the actual row number. Otherwise, the aggregation will be performed on a moving window.\n\n#### Examples\n\n```\nconvertExcelFormula(\"A2+B2\", \"A\", \"Z\", 2, 10);\n// output\ncol0+col1\n\nconvertExcelFormula(\"SUM(A2:C2)\", \"A\", \"Z\", 2, 10);\n// output\nrowSum(col0, col1, col2)\n\nconvertExcelFormula(\"SUM(A2)\", \"A\", \"Z\", 2, 10);\n// output\ncumsum(col0)\n\nconvertExcelFormula(\"SUM(A2:A5)\", \"A\", \"Z\", 2, 10);\n// output\nmsum(col0, 4)\n\nconvertExcelFormula(\"SUM(A2:A10)\", \"A\", \"Z\", 2, 10);\n// output\nsum(col0)\n\nconvertExcelFormula([\"=SUM(A1:A10)\",\"IF(A1>0,B1,0\"], \"A\", \"D\", 1, 10)\n// output\n[\"sum(col0)\",\"iif(col0>0,col1,0)\"]\n```\n"
    },
    "convertTZ": {
        "url": "https://docs.dolphindb.com/en/Functions/c/convertTZ.html",
        "signatures": [
            {
                "full": "convertTZ(obj, srcTZ, destTZ)",
                "name": "convertTZ",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "srcTZ",
                        "name": "srcTZ"
                    },
                    {
                        "full": "destTZ",
                        "name": "destTZ"
                    }
                ]
            }
        ],
        "markdown": "### [convertTZ](https://docs.dolphindb.com/en/Functions/c/convertTZ.html)\n\n\n\n#### Syntax\n\nconvertTZ(obj, srcTZ, destTZ)\n\n#### Arguments\n\n**obj** is a scalar or vector of DATETIME, TIMESTAMP, or NANOTIMESTAMP type.\n\n**srcTZ** and **destTZ** are both strings indicating time zones.\n\n#### Details\n\nConvert *obj* from time zone *srcTZ* to time zone *destTZ*. Daylight saving time is considered in time zone conversion.\n\n#### Examples\n\n```\nconvertTZ(2016.04.25T08:25:45,\"US/Eastern\",\"Asia/Shanghai\");\n// output\n2016.04.25T20:25:45\n```\n"
    },
    "copy": {
        "url": "https://docs.dolphindb.com/en/Functions/c/copy.html",
        "signatures": [
            {
                "full": "copy(X)",
                "name": "copy",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [copy](https://docs.dolphindb.com/en/Functions/c/copy.html)\n\n\n\n#### Syntax\n\ncopy(X)\n\n#### Arguments\n\n**X** can be of any data type.\n\n#### Details\n\nReturn a copy of *X*.\n\n#### Examples\n\n```\nx=1 2 3;\nx.copy();\n// output\n[1,2,3]\n```\n"
    },
    "copyReplicas": {
        "url": "https://docs.dolphindb.com/en/Functions/c/copyReplicas.html",
        "signatures": [
            {
                "full": "copyReplicas(srcNode, destNode, chunkId)",
                "name": "copyReplicas",
                "parameters": [
                    {
                        "full": "srcNode",
                        "name": "srcNode"
                    },
                    {
                        "full": "destNode",
                        "name": "destNode"
                    },
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    }
                ]
            }
        ],
        "markdown": "### [copyReplicas](https://docs.dolphindb.com/en/Functions/c/copyReplicas.html)\n\n\n\n#### Syntax\n\ncopyReplicas(srcNode, destNode, chunkId)\n\n#### Arguments\n\n**srcNode** is a string indicating the alias of origination node.\n\n**destNode** is a string indicating the alias of destination node.\n\n**chunkId** is a STRING scalar or vector indicating ID of chunk(s).\n\n#### Details\n\nCopy replicas of one or multiple chunks from a node to another node. If the destination node already has the chunk, the command is skipped.\n\nThis command can only be executed by an administrator on a controller node.\n\nYou can check the execution status with function [getRecoveryTaskStatus](https://docs.dolphindb.com/en/Functions/g/getRecoveryTaskStatus.html) .\n\n#### Examples\n\nCopy replicas of all chunks on \"node1\" to \"node2\".\n\n```\nchunkIds=exec chunkId from pnodeRun(getAllChunks) where node=\"node1\"\ncopyReplicas(\"node1\",\"node2\",chunkIds);\n```\n"
    },
    "corr": {
        "url": "https://docs.dolphindb.com/en/Functions/c/corr.html",
        "signatures": [
            {
                "full": "corr(X,Y)",
                "name": "corr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [corr](https://docs.dolphindb.com/en/Functions/c/corr.html)\n\n\n\n#### Syntax\n\ncorr(X,Y)\n\n#### Arguments\n\n**X** and **Y** are vectors/matrices/tables of the same size. If *X* is a table, only the numeric and Boolean values are calculated.\n\n#### Details\n\nCalculate the correlation of *X* and *Y*.\n\n#### Examples\n\n```\nx = 7 4 5 8 9 3 3 5 2 6 12 1 0 -5 32\ny=1.1 7 8 9 9 5 4 8.6 2 1 -9 -3 5 8 13\ncorr(x,y);\n// output\n0.238769\n```\n"
    },
    "corrMatrix": {
        "url": "https://docs.dolphindb.com/en/Functions/c/corrMatrix.html",
        "signatures": [
            {
                "full": "corrMatrix(X)",
                "name": "corrMatrix",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [corrMatrix](https://docs.dolphindb.com/en/Functions/c/corrMatrix.html)\n\n\n\n#### Syntax\n\ncorrMatrix(X)\n\n#### Arguments\n\n**X** is a matrix.\n\n#### Details\n\nReturn a correlation matrix, where the (i, j) entry is the correlation between the columns *i* and *j* of *X*.\n\nNote:\n\n* For a matrix *X* without NULL values, the result of `corrMatrix(X)` is equivalent to `cross/pcross(corr, X)`, but the performance of function corrMatrix is significantly improved.\n\n* For a matrix with NULL values, the results of `corrMatrix(X)` and `cross/pcross(corr, X)` are different, because the NULL values are converted to 0 by default in function `corrMatrix`, but ignored in function `corr`.\n\n#### Examples\n\n```\nm = rand(10.0, 30)$10:3\ncorrMatrix(m)\n```\n\n| #0                | #1                | #2                |\n| ----------------- | ----------------- | ----------------- |\n| 1                 | 0.167257129736134 | 0.224955585716037 |\n| 0.167257129736134 | 1                 | -0.12066768907057 |\n| 0.224955585716037 | -0.12066768907057 | 1                 |\n\n```\na = rand(1.0, 30000000).reshape(10000:3000)\na.rename!(\"s\" + string(1..3000))\n\ntimer corrMatrix(a)\nTime elapsed: 2986.932 ms\n\ntimer pcross(corr, a)\nTime elapsed: 45629.6 ms\n```\n\nRelated function: [covarMatrix](https://docs.dolphindb.com/en/Functions/c/covarMatrix.html)\n"
    },
    "cos": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cos.html",
        "signatures": [
            {
                "full": "cos(X)",
                "name": "cos",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cos](https://docs.dolphindb.com/en/Functions/c/cos.html)\n\n\n\n#### Syntax\n\ncos(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nApply the function of cos to X.\n\n#### Examples\n\n```\ncos 0 1 2;\n// output\n[1,0.540302,-0.416147]\n```\n\nRelated functions: [asin](https://docs.dolphindb.com/en/Functions/a/asin.html), [acos](https://docs.dolphindb.com/en/Functions/a/acos.html), [atan](https://docs.dolphindb.com/en/Functions/a/atan.html), [sin](https://docs.dolphindb.com/en/Functions/s/sin.html), [tan](https://docs.dolphindb.com/en/Functions/t/tan.html), [asinh](https://docs.dolphindb.com/en/Functions/a/asinh.html), [acosh](https://docs.dolphindb.com/en/Functions/a/acosh.html), [atanh](https://docs.dolphindb.com/en/Functions/a/atanh.html), [sinh](https://docs.dolphindb.com/en/Functions/s/sinh.html), [cosh](https://docs.dolphindb.com/en/Functions/c/cosh.html), [tanh](https://docs.dolphindb.com/en/Functions/t/tanh.html)\n"
    },
    "cosh": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cosh.html",
        "signatures": [
            {
                "full": "cosh(X)",
                "name": "cosh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cosh](https://docs.dolphindb.com/en/Functions/c/cosh.html)\n\n\n\n#### Syntax\n\ncosh(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nThe hyperbolic cosine function.\n\n#### Examples\n\n```\ncosh 0 1 2;\n// output\n[1,1.543081,3.762196]\n```\n\nRelated functions: [asin](https://docs.dolphindb.com/en/Functions/a/asin.html), [acos](https://docs.dolphindb.com/en/Functions/a/acos.html), [atan](https://docs.dolphindb.com/en/Functions/a/atan.html), [sin](https://docs.dolphindb.com/en/Functions/s/sin.html), [cos](https://docs.dolphindb.com/en/Functions/c/cos.html), [tan](https://docs.dolphindb.com/en/Functions/t/tan.html), [asinh](https://docs.dolphindb.com/en/Functions/a/asinh.html), [acosh](https://docs.dolphindb.com/en/Functions/a/acosh.html), [atanh](https://docs.dolphindb.com/en/Functions/a/atanh.html), [sinh](https://docs.dolphindb.com/en/Functions/s/sinh.html), [tanh](https://docs.dolphindb.com/en/Functions/t/tanh.html)\n"
    },
    "count": {
        "url": "https://docs.dolphindb.com/en/Functions/c/count.html",
        "signatures": [
            {
                "full": "count(X)",
                "name": "count",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [count](https://docs.dolphindb.com/en/Functions/c/count.html)\n\n\n\n#### Syntax\n\ncount(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\n[size](https://docs.dolphindb.com/en/Functions/s/size.html) returns the number of elements in a vector or matrix, while `count` returns the number of non-NULL elements in a vector/matrix. `count` can be used in a SQL query, but `size` cannot. For tables, `size` and `count` both return the number of rows.\n\n#### Examples\n\n```\ncount(3 NULL 5 6);\n// output\n3\nsize(3 NULL 5 6);\n// output\n4\n\nm=1 2 3 NULL 4 5$2:3;\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 4  |\n| 2  |    | 5  |\n\n```\ncount(m);\n// output\n5\nsize(m);\n// output\n6\n\nt = table(1 NULL 3 as id, 3 NULL 9 as qty);\nt;\n```\n\n| id | qty |\n| -- | --- |\n| 1  | 3   |\n|    |     |\n| 3  | 9   |\n\n```\ncount(t);\n// output\n3\nsize(t);\n// output\n3\n```\n"
    },
    "countNanInf": {
        "url": "https://docs.dolphindb.com/en/Functions/c/countNanInf.html",
        "signatures": [
            {
                "full": "countNanInf(X, [includeNull=false])",
                "name": "countNanInf",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[includeNull=false]",
                        "name": "includeNull",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [countNanInf](https://docs.dolphindb.com/en/Functions/c/countNanInf.html)\n\n\n\n#### Syntax\n\ncountNanInf(X, \\[includeNull=false])\n\n#### Arguments\n\n**X** is a DOUBLE type scalar, vector or matrix.\n\n**includeNull** (optional) is a BOOLEAN value. The default value is false.\n\n#### Details\n\nAn aggregate function that counts the number of NaN values and Inf values in *X*. When *includeNull* = true, the result includes the number of NULL values.\n\nRelated function: [isNanInf](https://docs.dolphindb.com/en/Functions/i/isNanInf.html)\n"
    },
    "covar": {
        "url": "https://docs.dolphindb.com/en/Functions/c/covar.html",
        "signatures": [
            {
                "full": "covar(X,Y)",
                "name": "covar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [covar](https://docs.dolphindb.com/en/Functions/c/covar.html)\n\n\n\n#### Syntax\n\ncovar(X,Y)\n\n#### Arguments\n\n**X** and **Y** are vectors/matrices/tables of the same size. If *X* is a table, only the numeric and Boolean columns are calculated.\n\n#### Details\n\nCalculate the covariance of *X* and *Y*.\n\n#### Examples\n\n```\nx=7 4 5 8 9 3 3 5 2 6 12 1 0 -5 32\ny=1.1 7 8 9 9 5 4 8.6 2 1 -9 -3 5 8 13\ncovar(x,y);\n// output\n10.881429\n```\n"
    },
    "covarMatrix": {
        "url": "https://docs.dolphindb.com/en/Functions/c/covarMatrix.html",
        "signatures": [
            {
                "full": "covarMatrix(X)",
                "name": "covarMatrix",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [covarMatrix](https://docs.dolphindb.com/en/Functions/c/covarMatrix.html)\n\n\n\n#### Syntax\n\ncovarMatrix(X)\n\n#### Arguments\n\n**X** is a matrix.\n\n#### Details\n\nReturn a covariance matrix, where the (i, j) entry is the covariance between the columns *i* and *j* of *X*.\n\nNote:\n\n* For a matrix *X* without NULL values, the result of `covarMatrix(X)` is equivalent to `cross/pcross(covar, X)`, but the performance of function covarMatrix is significantly improved.\n\n* For a matrix with NULL values, the results of `covarMatrix(X)` and `cross/pcross(covar, X)` are different, because the NULL values are converted to 0 by default in function `covarMatrix`, but ignored in function `covar`.\n\n#### Examples\n\n```\nm = rand(10.0, 30)$10:3\ncovarMatrix(m)\n```\n\n| #0                | #1                 | #2                 |\n| ----------------- | ------------------ | ------------------ |\n| 6.116181845352529 | 1.107026927999891  | 1.306707566911273  |\n| 1.107026927999891 | 7.162534080771522  | -0.758517799304199 |\n| 1.306707566911273 | -0.758517799304199 | 5.516744365930221  |\n\n```\na = rand(1.0, 30000000).reshape(10000:3000)\na.rename!(\"s\" + string(1..3000))\n\ntimer covarMatrix(a)\nTime elapsed: 2927.264 ms\n\ntimer pcross(covar, a)\nTime elapsed: 29484.85 ms\n```\n\nRelated function: [corrMatrix](https://docs.dolphindb.com/en/Functions/c/corrMatrix.html)\n"
    },
    "crc32": {
        "url": "https://docs.dolphindb.com/en/Functions/c/crc32.html",
        "signatures": [
            {
                "full": "crc32(str, [cksum=0])",
                "name": "crc32",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "[cksum=0]",
                        "name": "cksum",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [crc32](https://docs.dolphindb.com/en/Functions/c/crc32.html)\n\n\n\n#### Syntax\n\ncrc32(str, \\[cksum=0])\n\n#### Arguments\n\n**str** is a STRING scalar/vector.\n\n**cksum** (optional) is a integral scalar/vector. The default value is 0.\n\n#### Details\n\nCreate a CRC32 hash from STRING. The result is of data type INT.\n\n#### Examples\n\n```\na=crc32(`aa`cc,1);\na;\n// output\n[512829590,-1029100744]\n\ntypestr(a);\n// output\nFAST INT VECTOR\n```\n"
    },
    "createAnomalyDetectionEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createAnomalyDetectionEngine.html",
        "signatures": [
            {
                "full": "createAnomalyDetectionEngine(name, metrics, dummyTable, outputTable, timeColumn, [keyColumn], [windowSize], [step], [garbageSize], [roundTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup],[anomalyDescription])",
                "name": "createAnomalyDetectionEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[windowSize]",
                        "name": "windowSize",
                        "optional": true
                    },
                    {
                        "full": "[step]",
                        "name": "step",
                        "optional": true
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[anomalyDescription]",
                        "name": "anomalyDescription",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createAnomalyDetectionEngine](https://docs.dolphindb.com/en/Functions/c/createAnomalyDetectionEngine.html)\n\n\n\n#### Syntax\n\ncreateAnomalyDetectionEngine(name, metrics, dummyTable, outputTable, timeColumn, \\[keyColumn], \\[windowSize], \\[step], \\[garbageSize], \\[roundTime=true], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[raftGroup],\\[anomalyDescription])\n\n#### Details\n\nThis function creates an anomaly detection engine and returns a table object. Data inserted into this table is used to calculate specified metrics to detect anomalies.\n\nNote that the following functions are not supported in metrics: `next`, `talibNull`, `linearTimeTrend`, `iterate`, or aggregate function nested within an order-sensitive function (e.g., `tmsum(sum())`).\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n##### Calculation Rules\n\nThe anomaly detection engine uses different calculation rules for the following 3 types of anomaly metrics:\n\n* Comparison between a column and a constant or between columns. Non-aggregate functions may be used but aggregate function are not used. For examples: `qty < 4`, `qty > price`, `lt(qty, prev(qty))`, `isNull(qty) == false`, etc. For these metrics, the engine conducts calculations for each row and determines whether to output the result.\n\n* Comparison between aggregate function result and a constant or between aggregate function results. Non-aggregate functions may be used, but their arguments may only include aggregate functions and/or constants, not columns. For examples: `avg(qty - price) > 10`, `percentile(qty, 90) < 100`, `max(qty) < avg(qty) * 2`, `le(sum(qty), 5)`, etc. For these metrics, the engine conducts calculations at frequencies determined by the parameter *step* and determines whether to output the result.\n\n* Comparison between aggregate function result and a column, or non-aggregate functions are used and their arguments include aggregate functions and columns. For examples: `avg(qty) > qty`, `le(med(qty), price)`, etc. For these metrics, the engine conducts calculations at frequencies determined by the parameter *step* and determines whether to output the result.\n\nNote: If an aggregate function is used in *metrics*, the parameters *windowSize* and *step* must be specified. The anomaly metrics are calculated in a window of *windowSize* at every step. To facilitate observation and comparison of calculation results, the engine automatically adjusts the starting point of the first window. See [createTimeSeriesEngine](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html) for the alignment rules.\n\nIf the parameter *keyColumn* is specified, the anomaly metrics are calculated in each group.\n\n##### Other Features:\n\n* Data cleanup: If an aggregate function or order-sensitive function is specified for *metrics*, the engine keeps the historical data. You can specify the parameter *garbageSize* to clean up the data that are no longer needed. If *keyColumn* is specified, data cleanup is performed within each group independently.\n\n* Snapshot: Snapshot mechanism is used to restore the streaming engine to the latest snapshot after system interruption. (See parameters *snapshotDir* and *snapshotIntervalInMsgCount*)\n\n* High availability: To enable high availability for the streaming engines, specify the parameter *raftGroup* on the leader of a raft group on the subscriber. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table.\n\n#### Arguments\n\n**name** is a string indicating the name of the anomaly detection engine. It is the unique identifier of the engine on a data/compute node. It can contain letters, numbers and underscores, and must start with a letter.\n\n**metrics** is metacode or tuple specifying the formulas for anomaly detection. It uses functions or expressions such as `<[sum(qty)>5, avg(qty)>qty, qty<4]>` that indicate anomaly conditions and return Boolean values.\n\nNote: The column names specified in *metrics* are not case-sensitive and can be inconsistent with the column names of the input tables.\n\n**dummyTable** is a table object whose schema must be the same as the stream table to which the engine subscribes.\n\n**outputTable** is the output table of detected anomalies. It can be an in-memory table or a DFS table. Create an empty table before calling the function.\n\nThe output columns are in the following order:\n\n(1) The first column is of temporal data type and stores the time when an anomaly is detected.\n\n(2) The following column(s) are *keyColumn* (if specified).\n\n(3) Then followed by an INT column indicating the position of the condition in metrics;\n\n(4) And a STRING/SYMBOL column indicating the content of the anomaly conditions or description.\n\n**timeColumn** is a string indicating the name of the temporal column of the input stream table.\n\n**keyColumn** (optional) is a STRING scalar or vector indicating the grouping columns. The anomaly detection engine conducts calculations within each group specified by *keyColumn*.\n\n**windowSize** (optional) is a positive integer indicating the size of window for calculation. Only the left boundary is included in the window.\n\n**step** (optional) is a positive integer indicating the duration between 2 adjacent windows. The value of *windowSize* must be a multiple of *step*.\n\nNote: If aggregate functions are used in *metrics*, parameters *windowSize* and *step* must be specified.\n\n**garbageSize** (optional) is a positive integer. The default value is 2,000 (in Bytes).\n\n* If *keyColumn* is not specified, when the number of historical records in memory exceeds *garbageSize*, the system will clear the records that are no longer needed.\n\n* If *keyColumn* is specified, garbage collection is conducted separately in each group. When the number of historical records in a group exceeds *garbageSize*, the system will clear the records that are no longer needed within the group.\n\nNote that *garbageSize* only takes effect when aggregate function(s) are specified in parameter metrics.\n\n**roundTime** (optional) is a Boolean value indicating the method to align the window boundary if the time column is in millisecond or second precision and step is greater than one minute. The default value is true indicating the alignment is based on the multi-minute rule. False means alignment is based on the one-minute rule (See [Alignment Rules](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html)).\n\nTo enable snapshot in the streaming engines, specify parameters *snapshotDir* and *snapshotIntervalInMsgCount*.\n\n**snapshotDir** (optional) is a string indicating the directory where the streaming engine snapshot is saved. The directory must already exist, otherwise an exception is thrown. If the *snapshotDir* is specified, the system checks whether a snapshot already exists in the directory when creating a streaming engine. If it exists, the snapshot will be loaded to restore the engine state. Multiple streaming engines can share a directory where the snapshot files are named as the engine names.\n\nThe file extension of a snapshot can be:\n\n* *\\<engineName>.tmp*: a temporary snapshot\n\n* *\\<engineName>.snapshot*: a snapshot that is generated and flushed to disk\n\n* *\\<engineName>.old*: if a snapshot with the same name already exists, the previous snapshot is renamed to *\\<engineName>.old*.\n\n**snapshotIntervalInMsgCount** (optional) is a positive integer indicating the number of messages to receive before the next snapshot is saved.\n\n**raftGroup** (optional) is an integer greater than 1, indicating the ID of the raft group on the high-availability streaming subscriber specified by the configuration parameter *streamingRaftGroups*. Specify *raftGroup* to enable high availability on the streaming engine. When an engine is created on the leader, it is also created on each follower and the engine snapshot is synchronized to the followers. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table. Note that *snapshotDir* must also be specified when specifying a raft group.\n\n**anomalyDescription** (optional) is a STRING vector, where each element indicates a custom description for the corresponding anomaly condition specified in *metrics*.\n\n#### Examples\n\nExample 1: The following example creates a table \"engine\" with `createAnomalyDetectionEngine`, then subscribes to the stream table trades and writes data to the engine. The engine conducts calculations by group based on column sym and saves the results to *outputTable*.\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(1000:0, `time`sym`type`metric, [TIMESTAMP, SYMBOL, INT, STRING]) as outputTable\nengine = createAnomalyDetectionEngine(name=\"anomalyDetection1\", metrics=<[sum(qty) > 5, avg(qty) > qty, qty < 4]>, dummyTable=trades, outputTable=outputTable, timeColumn=`time, keyColumn=`sym, windowSize=3, step=3)\nsubscribeTable(tableName=\"trades\", actionName=\"anomalyDetectionSub1\", offset=0, handler=append!{engine}, msgAsTable=true)\n\ndef writeData(n){\ntimev = 2018.10.08T01:01:01.001 + 1..n\nsymv =take(`A`B, n)\nqtyv = n..1\ninsert into trades values(timev, symv, qtyv)\n}\n\nwriteData(6);\n\nselect * from trades;\n```\n\n| time                    | sym | qty |\n| ----------------------- | --- | --- |\n| 2018.10.08T01:01:01.002 | A   | 6   |\n| 2018.10.08T01:01:01.003 | B   | 5   |\n| 2018.10.08T01:01:01.004 | A   | 4   |\n| 2018.10.08T01:01:01.005 | B   | 3   |\n| 2018.10.08T01:01:01.006 | A   | 2   |\n| 2018.10.08T01:01:01.007 | B   | 1   |\n\n```\nselect * from outputTable;\n```\n\n| time                    | sym | type | metric         |\n| ----------------------- | --- | ---- | -------------- |\n| 2018.10.08T01:01:01.003 | A   | 0    | sum(qty) > 5   |\n| 2018.10.08T01:01:01.004 | A   | 1    | avg(qty) > qty |\n| 2018.10.08T01:01:01.005 | B   | 2    | qty < 4        |\n| 2018.10.08T01:01:01.006 | A   | 1    | avg(qty) > qty |\n| 2018.10.08T01:01:01.006 | A   | 2    | qty < 4        |\n| 2018.10.08T01:01:01.006 | B   | 0    | sum(qty) > 5   |\n| 2018.10.08T01:01:01.007 | B   | 1    | avg(qty) > qty |\n| 2018.10.08T01:01:01.007 | B   | 2    | qty < 4        |\n\nThe calculation process of the anomaly detection engine is explained in details below:\n\n(1) The indicator `sum(qty)>5` represents the comparison between the aggregate result and a constant, the anomaly detection engine checks this indicator during the calculation in each window.\n\n* The first window ranges from 2018.10.08T01:01:01.000 to 2018.10.08T01:01:01.002, and the `sum(qty)` of A and B is calculated respectively. At 2018.10.08T01:01:01.003 the engine starts to judge whether it meets the condition `sum(qty)>5`.\n\n* The second window ranges from 2018.10.08T01:01:01.003 to 2018.10.08T01:01:01.005, at 2018.10.08T01:01:01.006, the engine starts to judge whether it meets the condition `sum(qty)>5`, and so on.\n\n(2) The indicator `avg(qty)>qty` represents the comparison between the aggregate result and a certain column. Therefore, whenever data arrives, the anomaly detection engine compares the data with the aggregate result of the previous window. Until the next aggregation is triggered, the engine checks whether the result meets the conditions and outputs it.\n\n* The first window ranges from 2018.10.08T01:01:01.000 to 2018.10.08T01:01:01.002, the `avg(qty)` of A and B is calculated respectively. Each qty between 2018.10.08T01:01:01.003 and 2018.10.08T01:01:01.005 will be compared with the `avg(qty)` of the previous window.\n\n* The window moves at 2018.10.08T01:01:01.005.\n\n* The second window ranges from 2018.10.08T01:01:01.003 to 2018.10.08T01:01:01.005. In the second window, the `avg(qty)` of A and B is calculated, each qty between 2018.10.08T01:01:01.006 and 2018.10.08T01:01:01.008 will be compared with the `avg(qty)` of the previous window, and so on.\n\n(3) The metric `qty<4` represents the comparison between a column and a constant. Therefore, whenever a new record arrives, the anomaly detection engine compares the value with 4.\n\nExample 2: The following example demonstrates how the *anomalyDescription* parameter works.\n\n```\nshare streamTable(1000:0, `time`temp, [TIMESTAMP, DOUBLE]) as sensordata\nshare streamTable(1000:0, `time`anomalyType`anomalyString, [TIMESTAMP, INT, SYMBOL]) as outputTable\nengine = createAnomalyDetectionEngine(name = \"engineB\", metrics=<[temp > 65, temp > percentile(temp, 75)]>, dummyTable = sensordata, outputTable = outputTable, timeColumn = `time, windowSize = 6, step = 3, anomalyDescription=[\"The temperature is higher than 65°C\", \"The temperature is larger than 75% values of the last window\"])\nsubscribeTable(,tableName = \"sensordata\", actionName = \"sensorAnomalyDetection\", offset = 0, handler = append!{engine}, msgAsTable = true)\n\ntimev = 2018.10.08T01:01:01.001 + 1..10\ntempv = 59 66 57 60 63 51 53 52 56 55\ninsert into sensordata values(timev, tempv)\n\nsleep(10)\nselect * from outputTable\n```\n\n| time                    | anomalyType | anomalyString                                                |\n| ----------------------- | ----------- | ------------------------------------------------------------ |\n| 2018.10.08T01:01:01.003 | 0           | The temperature is higher than 65°C                          |\n| 2018.10.08T01:01:01.003 | 1           | The temperature is larger than 75% values of the last window |\n| 2018.10.08T01:01:01.005 | 1           | The temperature is larger than 75% values of the last window |\n| 2018.10.08T01:01:01.006 | 1           | The temperature is larger than 75% values of the last window |\n"
    },
    "createAsofJoinEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createAsofJoinEngine.html",
        "signatures": [
            {
                "full": "createAsofJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, [timeColumn], [useSystemTime=false], [delayedTime], [garbageSize], [sortByTime])",
                "name": "createAsofJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[delayedTime]",
                        "name": "delayedTime",
                        "optional": true
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[sortByTime]",
                        "name": "sortByTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createAsofJoinEngine](https://docs.dolphindb.com/en/Functions/c/createAsofJoinEngine.html)\n\n\n\n#### Syntax\n\ncreateAsofJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, \\[timeColumn], \\[useSystemTime=false], \\[delayedTime], \\[garbageSize], \\[sortByTime])\n\n#### Details\n\nCreate an asof join streaming engine. Streams are ingested into the left table and the right table and joined on *matchingColumn* and *timeColumn* (or system time). For each record in the left table, join it with the right table record (1) with matching *matchingColumn* value and (2) whose timestamp is the last of the timestamps that are less than or equal to the timestamp of the left table record. This function returns a table object holding the asof join results.\n\nAsof join engine joins records that have no exact match on time columns. For each timestamp in one table, the engine obtains the latest (i.e., current as of the timestamp) value from another table.\n\nNote:\n\n* The records in the left table and the right table must be sequenced by time.\n\n* If *delayedTime* is not specified, a join operation is only triggered when the right table receives a record whose timestamp is greater than the timestamp of the latest record in the left table.\n\n* If *delayedTime* is specified, a join operation is triggered when either of the following conditions is met:\n\n  * In the left table, the difference between the timestamp of the latest record and the timestamp of the previous unjoined record is greater than *delayedTime*.\n\n  * The record is still not joined after 2 \\* *delayedTime* or 2 seconds, whichever is larger, since its ingestion into the left table.\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n#### Arguments\n\n**name** is a string indicating the name of the asof join engine. It is the unique identifier of the engine on a data/compute node. It can contain letters, numbers and underscores and must start with a letter.\n\n**leftTable** and **rightTable** are table objects whose schema must be the same as the stream table to which the engine subscribes. Since version 2.00.11, array vectors are allowed for *leftTable* and *rightTable*.\n\n**outputTable** is a table to which the engine inserts calculation result. It can be an in-memory table or a DFS table. Before calling a function, an empty table with specified column names must be created.Since version 2.00.11, array vectors are allowed for *outputTable*.\n\nThe columns of *outputTable* are in the following order:\n\n(1) The first column must be a temporal column.\n\n* if *useSystemTime* = true, the data type must be TIMESTAMP;\n\n* if *useSystemTime* = false, it has the same data type as *timeColumn*.\n\n(2) Then followed by one or more columns on which the tables are joined, arranged in the same order as specified in *matchingColumn*.\n\n(3) Further followed by one or more columns which are the calculation results of *metrics*.\n\n**metrics** is metacode (can be a tuple) specifying the calculation formulas. For more information about metacode, refer to [Metaprogramming](https://test.dolphindb.cn/en/Programming/Metaprogramming/MetacodeWithFunction.html).\n\n* *metrics* can use one or more expressions, built-in or user-defined functions (but not aggregate functions), or a constant scalar/vector. Note that the output column for a constant vector must be in array vector form.\n\n* *metrics* can be functions with multiple returns and the columns in the output table to hold the return values must be specified. For example, \\<func(price) as \\`col1\\`col2>.\n\n* To specify a column that exists in both the left and the right tables, use the format *tableName.colName*.\n\n* The column names specified in *metrics* are not case-sensitive and can be inconsistent with the column names of the input tables.\n\n**matchingColumn** is a STRING scaler/vector/tuple indicating the column(s) on which the tables are joined. It supports integral, temporal or literal (except UUID) types.\n\n* When there is only 1 column to match - If the names of the columns to match are the same in both tables, *matchingColumn* should be specified as a STRING scalar; otherwise it's a tuple of two elements. For example, if the column is named \"sym\" in the left table and \"sym1\" in the right table, then *matchingColumn* = \\[\\[\\`sym],\\[\\`sym1]].\n* When there are multiple columns to match - If both tables share the names of all columns to match, *matchingColumn* is a STRING vector; otherwise it's a tuple of two elements. For example, if the columns are named \"orderNo\" and \"sym\" in the left table, whereas in the right table they're named \"orderNo\" and \"sym1\", then *matchingColumn* = \\[\\[\\`orderNo, \\`sym], \\[\\`orderNo,\\`sym1]].\n\n**timeColumn** (optional) specifies the name of the time column in the left table and the right table. The time columns must have the same data type. When *useSystemTime* = false, it must be specified. If the names of the time column in the left table and the right table are the same, *timeColumn* is a string. Otherwise, it is a vector of 2 strings indicating the time column in each table.\n\n**useSystemTime** (optional) indicates whether the left table and the right table are joined on the system time, instead of on *timeColumn*.\n\n* *useSystemTime* = true: join records based on the system time (timestamp with millisecond precision) when they are ingested into the engine.\n* *useSystemTime* = false (default): join records based on the specified \\*timeColumn\\* from the left table and the right table.\n\n**delayedTime** (optional) is a positive integer with the same precision as *timeColumn*, indicating the maximum time to wait before the engine joins an uncalculated record in the left table with a right table record. To specify *delayedTime*, *timeColumn* must be specified. For more information, see Details.\n\n**garbageSize** (optional) is a positive integer with the default value of 5,000 (rows). As the subscribed data is ingested into the engine, it continues to take up the memory. Within the left/right table, the records are grouped by *matchingColumn* values; When the number of records in a group exceeds *garbageSize*, the system will remove those already been calculated from memory.\n\n**sortByTime** (optional) is a Boolean value that indicates whether the output data is globally sorted by time. The default value is false, meaning the output data is sorted only within groups. Note that if *sortByTime* is set to true, the parameter *delayedTime* cannot be specified, and the data input to the left and right tables must be globally sorted.\n\n#### Examples\n\n```\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\nshare streamTable(1:0, `time`sym`bid`ask, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE]) as quotes\nshare table(100:0, `time`sym`price`bid`ask`spread, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as prevailingQuotes\n\najEngine=createAsofJoinEngine(name=\"aj1\", leftTable=trades, rightTable=quotes, outputTable=prevailingQuotes, metrics=<[price, bid, ask, abs(price-(bid+ask)/2)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false)\ntmp1=table(2020.08.27T09:30:00.000+2 8 20 22 23 24 as time, take(`A`B, 6) as sym, 20.01 20.04 20.07 20.08 20.4 20.5 as price)\ntmp2=table(2020.08.27T09:30:00.000+1 5 6 11 19 20 21 as time, take(`A`B, 7) as sym, 20 20.02 20.03 20.05 20.06 20.6 20.4 as bid,  20.01 20.03 20.04 20.06 20.07 20.5 20.6 as ask)\ntmp1.sortBy!(`time)\ntmp2.sortBy!(`time)\n\nsubscribeTable(tableName=\"trades\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{ajEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"quotes\", actionName=\"joinRight\", offset=0, handler=appendForJoin{ajEngine, false}, msgAsTable=true)\n\ntrades.append!(tmp1)\nquotes.append!(tmp2)\n\nsleep(100)\nselect time, sym, bid from prevailingQuotes\n\n// output\ntime\tsym\tbid\n2020.08.27T09:30:00.002\tA\t20\n2020.08.27T09:30:00.020\tA\t20.06\n2020.08.27T09:30:00.008\tB\t20.02\n```\n\n```\n// clean environment\nunsubscribeTable(tableName=\"trades\", actionName=\"joinLeft\")\nunsubscribeTable(tableName=\"quotes\", actionName=\"joinRight\")\nundef(`trades,SHARED)\nundef(`quotes,SHARED)\ndropAggregator(name=\"aj1\")\n\n//define an asof join engine and set sortByTime=true\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\nshare streamTable(1:0, `time`sym`bid`ask, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE]) as quotes\nshare table(100:0, `time`sym`price`bid`ask`spread, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as prevailingQuotes\najEngine=createAsofJoinEngine(name=\"aj1\", leftTable=trades, rightTable=quotes, outputTable=prevailingQuotes, metrics=<[price, bid, ask, abs(price-(bid+ask)/2)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false, sortByTime=true)\n\ntmp1=table(2020.08.27T09:30:00.000+2 8 20 22 23 24 as time, take(`A`B, 6) as sym, 20.01 20.04 20.07 20.08 20.4 20.5 as price)\ntmp2=table(2020.08.27T09:30:00.000+1 5 6 11 19 20 21 as time, take(`A`B, 7) as sym, 20 20.02 20.03 20.05 20.06 20.6 20.4 as bid,  20.01 20.03 20.04 20.06 20.07 20.5 20.6 as ask)\ntmp1.sortBy!(`time)\ntmp2.sortBy!(`time)\n\n//only appendForJoin can be used to insert data\nsubscribeTable(tableName=\"trades\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{ajEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"quotes\", actionName=\"joinRight\", offset=0, handler=appendForJoin{ajEngine, false}, msgAsTable=true)\n\ntrades.append!(tmp1)\nquotes.append!(tmp2)\n\nsleep(100)\n\n//check the output table\nselect time, sym, bid from prevailingQuotes\n\n// output\ntime                   sym   bid\n2020.08.27T09:30:00.002      A       20\n2020.08.27T09:30:00.008      B       20.02\n2020.08.27T09:30:00.020      A       20.06\n```\n"
    },
    "createCatalog": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createCatalog.html",
        "signatures": [
            {
                "full": "createCatalog(catalog)",
                "name": "createCatalog",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    }
                ]
            }
        ],
        "markdown": "### [createCatalog](https://docs.dolphindb.com/en/Functions/c/createCatalog.html)\n\n#### Syntax\n\ncreateCatalog(catalog)\n\n#### Arguments\n\n**catalog**is a string specifying the catalog name.\n\n#### Details\n\nCreate a catalog.\n\n#### Examples\n\n```\ncreateCatalog(\"cat1\")\n```\n\n"
    },
    "createCrossSectionalAggregator": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createCrossSectionalAggregator.html",
        "signatures": [
            {
                "full": "createCrossSectionalEngine(name, [metrics], dummyTable, [outputTable], keyColumn, [triggeringPattern='perBatch'], [triggeringInterval=1000], [useSystemTime=true], [timeColumn], [lastBatchOnly=false], [contextByColumn], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup], [outputElapsedMicroseconds=false], [roundTime=true], [keyFilter])",
                "name": "createCrossSectionalEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[metrics]",
                        "name": "metrics",
                        "optional": true
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "[outputTable]",
                        "name": "outputTable",
                        "optional": true
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "[triggeringPattern='perBatch']",
                        "name": "triggeringPattern",
                        "optional": true,
                        "default": "'perBatch'"
                    },
                    {
                        "full": "[triggeringInterval=1000]",
                        "name": "triggeringInterval",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[useSystemTime=true]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[lastBatchOnly=false]",
                        "name": "lastBatchOnly",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[contextByColumn]",
                        "name": "contextByColumn",
                        "optional": true
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[keyFilter]",
                        "name": "keyFilter",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createCrossSectionalAggregator](https://docs.dolphindb.com/en/Functions/c/createCrossSectionalAggregator.html)\n\nAlias for [createCrossSectionalEngine](https://docs.dolphindb.com/en/Functions/c/createCrossSectionalEngine.html)\n\n\nDocumentation for the `createCrossSectionalEngine` function:\n### [createCrossSectionalEngine](https://docs.dolphindb.com/en/Functions/c/createCrossSectionalEngine.html)\n\n\n\n#### Syntax\n\ncreateCrossSectionalEngine(name, \\[metrics], dummyTable, \\[outputTable], keyColumn, \\[triggeringPattern='perBatch'], \\[triggeringInterval=1000], \\[useSystemTime=true], \\[timeColumn], \\[lastBatchOnly=false], \\[contextByColumn], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[raftGroup], \\[outputElapsedMicroseconds=false], \\[roundTime=true], \\[keyFilter])\n\nAlias: createCrossSectionalAggregator\n\n#### Details\n\nThis function creates a cross-sectional streaming engine and returns a keyed table with *keyColumn* as the key.\n\nThe keyed table is updated every time a new record arrives. If the parameter *lastBatchOnly* is set to true, the table only maintains the latest record in each group. When new data is ingested into the engine,\n\n* if *metrics* and *outputTable* are specified, the engine first updates the keyed table, then performs calculations on the latest data and outputs the results to *outputTable*.\n\n* if *metrics* and *outputTable* are not specified, the engine only updates the keyed table.\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n##### Calculation Rules\n\nThe calculation can be triggered by the number of records or time interval. See parameters *triggeringPattern* and *triggeringInterval*. Note that if *contextByColumn* is specified, the data will be grouped by the specified columns and calculated by group.\n\n##### Features\n\n* Snapshot: Snapshot mechanism is used to restore the streaming engine to the latest snapshot after system interruption. (See parameters *snapshotDir* and *snapshotIntervalInMsgCount*)\n\n* High availability: To enable high availability for streaming engines, specify the parameter *raftGroup* on the leader of the raft group on the subscriber. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table.\n\n#### Arguments\n\n**name** is a string of the engine name. It is the only identifier of a cross sectional engine on a data/compute node. It can have letter, number and \"\\_\" and must start with a letter.\n\n**metrics** (optional) is metacode or a tuple specifying the formulas for calculation. It can be:\n\n* Built-in or user-defined aggregate functions, e.g., `<[sum(qty), avg(price)]>`; Or expressions on previous results, e.g., `<[avg(price1)-avg(price2)]>`; Or calculation on multiple columns, e.g., `<[std(price1-price2)]>`\n\n* Functions with multiple returns, such as `<func(price) as `col1`col2>`. The column names can be specified or not. For more information about metacode, see [Metaprogramming](https://docs.dolphindb.com/en/Programming/Metaprogramming/functional_meta.html).\n\n* The column names specified in *metrics* are not case-sensitive and can be inconsistent with the column names of the input tables.\n\n**dummyTable** is a table object whose schema must be the same as the stream table to which the engine subscribes. Whether *dummyTable* contains data does not matter. For versions 2.00.14/3.00.2 and later, *dummyTable* can include array vector columns.\n\n**outputTable** (optional) is the output table for the results. It can be an in-memory table or a DFS table. Create an empty table and specify the column names and types before calling the function. Make sure that data types of columns storing calculation results are the same as the results of metrics. The output columns are in the following order:\n\n(1) The first column is of TIMESTAMP type.\n\n* If *useSystemTime* = true, the column stores the time when each calculation starts;\n\n* If *useSystemTime* = false, it takes the values of *timeColumn*.\n\n(2) The following column is the *contextByColumn* (if specified).\n\n(3) If the *outputElapsedMicroseconds* is set to true, specify two more columns: a LONG column and an INT column.\n\n(4) The remaining columns store the calculation results of metrics.\n\n**keyColumn** is a STRING scalar or vector that specifies one or more columns in the stream table as the key columns. For each unique value in the *keyColumn*, only the latest record is used in the calculation.\n\n**triggeringPattern** (optional) is a STRING scalar specifying how to trigger the calculations. The engine returns a result every time a calculation is triggered. It can take one of the following values:\n\n* 'perBatch' (default): calculates when a batch of data arrives.\n\n* 'perRow': calculates when a new record arrives.\n\n* 'interval': calculates at intervals specified by *triggeringInterval*, using system time.\n\n* 'interval': calculates at the intervals of triggeringInterval (using system time).\n\n* 'keyCount': When data with the same timestamp arrives in batches, the calculation is triggered when:\n\n  * if the number of keys with the latest timestamp reaches *triggeringInterval*;\n\n  * or data with newer timestamp arrives.\n\n* 'dataInterval': calculates at intervals based on timestamps in the data. To use this, *timeColumn* must be specified and *useSystemTime* must be false.\n\nNote: To set *triggeringPattern* as 'keyCount', *timeColumn* must be specified and *useSystemTime* must be set to false. In this case, the out-of-order data will be discarded.\n\n**triggeringInterval** (optional) can be an integer or a tuple. Below explains its optional values and triggering rules:\n\n* If *triggeringPattern* = 'interval', *triggeringInterval* is a positive integer indicating the interval in milliseconds between 2 adjacent calculations. The default value is 1,000. Every *triggeringInterval* milliseconds, the system checks if the data in the engine has been calculated; if not, a calculation is triggered.\n\n* If *triggeringPattern* = 'keyCount', *triggeringInterval* can be:\n\n  * an integer specifying a threshold. Before data with a greater timestamp arrives, a calculation is triggered when the number of uncalculated records reaches the threshold.\n\n  * a tuple of 2 elements. The first element is an integer indicating the threshold of the number records with the latest timestamp to trigger calculation. The second element is an integer or duration value.\n\n  For example, when *triggeringInterval* is set to (c1, c2):\n\n  * If c2 is an integer and the number of keys with the latest timestamp t1 doesn't reach c1, calculation will not be triggered and the system goes on to save data with greater timestamp t2 (t2>t1). Data with t1 will be calculated when either of the events happens: the number of keys with timestamp t2 reaches c2, or data with greater timestamp t3 (t3>t2) arrives. Note that c2 must be smaller than c1.\n\n  * If c2 is a duration and the number of keys with the latest timestamp t1 doesn't reach c1, calculation will not be triggered and the system goes on to save data with greater timestamp t2 (t2>t1) . Once data with t2 starts to come in, data with t1 will not be calculated until any of the events happens: the number of keys with timestamp t1 reaches c1, or data with greater timestamp t3 (t3>t2) arrives, or the duration c2 comes to an end.\n\n* If *triggeringPattern*= 'dataInterval', *triggeringInterval* is a positive integer measured in the same units as the timestamps in *timeColumn*. The default is 1,000. Starting with the first record, a window is started at intervals defined by *triggeringInterval*, based on the timestamp units. When the first record of the next window arrives, a calculation is triggered on all data in the current window.\n\n  * In versions 2.00.11.21.30.23.2 and earlier, a calculation is triggered for each window.\n\n  * Since version 2.00.11.31.30.23.3, a calculation is triggered only for windows containing data.\n\n**useSystemTime** (optional) is a Boolean value indicating whether the calculations are performed based on the system time when data is ingested into the engine.\n\n* If *useSystemTime* = true, the time column of outputTable is the system time;\n\n* If *useSystemTime* = false, the parameter timeColumn must be specified. The time column of *outputTable* uses the timestamp of each record.\n\n**timeColumn** (optional) is a STRING scalar which specifies the time column in the stream table to which the engine subscribes if *useSystemTime* = false. It can only be of TIMESTAMP type.\n\n**lastBatchOnly** (optional) is a Boolean value indicating whether to keep only the records with the latest timestamp in the engine. When *lastBatchOnly* = true, *triggeringPattern* must take the value 'keyCount', and the cross-sectional engine only maintains key values with the latest timestamp for calculation. Otherwise, the engine updates and retains all values for calculation.\n\n**contextByColumn** (optional) is a STRING scalar or vector indicating the grouping column(s) based on which calculations are performed by group. This parameter only takes effect if *metrics* and *outputTable* are specified. If *metrics* only contains aggregate functions, the calculation results would be the same as a SQL query using `group by`. Otherwise, the results would be consistent with that using `context by`.\n\nTo enable snapshot in the streaming engines, specify parameters *snapshotDir* and *snapshotIntervalInMsgCount*.\n\n**snapshotDir** (optional) is a string indicating the directory where the streaming engine snapshot is saved. The directory must already exist, otherwise an exception is thrown. If *snapshotDir* is specified, the system checks whether a snapshot already exists in the directory when creating a streaming engine. If it exists, the snapshot will be loaded to restore the engine state. Multiple streaming engines can share a directory where the snapshot files are named as the engine names.\n\nThe file extension of a snapshot can be:\n\n* *\\<engineName>.tmp*: temporary snapshot\n* *\\<engineName>.snapshot*: a snapshot that is generated and flushed to disk\n* *\\<engineName>.old*: if a snapshot with the same name already exists, the previous snapshot is renamed to *\\<engineName>.old*.\n\n**snapshotIntervalInMsgCount** (optional) is a positive integer indicating the number of messages to receive before the next snapshot is saved.\n\n**raftGroup** (optional) is an integer greater than 1, indicating ID of the raft group on the high-availability streaming subscriber specified by the configuration parameter *streamingRaftGroups*. Specify *raftGroup* to enable high availability for the streaming engines. When an engine is created on the leader, it is also created on each follower and the engine snapshot is synchronized to the followers. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table. Note that *SnapShotDir* must also be specified when specifying a raft group.\n\n**outputElapsedMicroseconds** (optional) is a Boolean value. The default value is false. It determines whether to output:\n\n* the elapsed time (in microseconds) from the ingestion of data to the output of result in each batch.\n\n* the total row number of each batch.\n\n**Note**: When both *outputElapsedMicroseconds*and *useSystemTime*parameters are set to true, aggregate function cannot be used in *metrics*.\n\n**roundTime** (optional) is a Boolean value indicating the method to align the window boundary when *triggeringPattern*='dataInterval'. The default value is true indicating the alignment is based on the multi-minute rule (see the [alignment rules](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.md#) of time-series engine). False means alignment is based on the one-minute rule.\n\n**keyFilter** (optional) is metacode of an expression or function call that returns a Boolean vector. It specifies the conditions for filtering keys in the keyed table returned by the engine. Only data with keys satisfying the filtering conditions will be taken for calculation.\n\n#### Examples\n\nExample 1. A table \"csEngine1\" is created with function `createCrossSectionalEngine` and it subscribes to the stream table trades1. We set *triggeringPattern* to 'perRow', so each row that is inserted into table csEngine1 triggers a calculation.\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine1=createCrossSectionalEngine(name=\"csEngineDemo1\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades1, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"perRow\", useSystemTime=false, timeColumn=`time)\nsubscribeTable(tableName=\"trades1\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine1}, msgAsTable=true)\ninsert into trades1 values(2020.08.12T09:30:00.000 + 123 234 456 678 890 901, `A`B`A`B`B`A, 10 20 10.1 20.1 20.2 10.2, 20 10 20 30 40 20);\n\nselect * from trades1;\n```\n\n| time                    | sym | price | volume |\n| ----------------------- | --- | ----- | ------ |\n| 2020.08.12T09:30:00.123 | A   | 10    | 20     |\n| 2020.08.12T09:30:00.234 | B   | 20    | 10     |\n| 2020.08.12T09:30:00.456 | A   | 10.1  | 20     |\n| 2020.08.12T09:30:00.678 | B   | 20.1  | 30     |\n| 2020.08.12T09:30:00.890 | B   | 20.2  | 40     |\n| 2020.08.12T09:30:00.901 | A   | 10.2  | 20     |\n\n```\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2020.08.12T09:30:00.123 | 10       | 20     | 200          | 1     |\n| 2020.08.12T09:30:00.234 | 15       | 30     | 400          | 2     |\n| 2020.08.12T09:30:00.456 | 15.05    | 30     | 402          | 2     |\n| 2020.08.12T09:30:00.678 | 15.1     | 50     | 805          | 2     |\n| 2020.08.12T09:30:00.890 | 15.15    | 60     | 1010         | 2     |\n| 2020.08.12T09:30:00.901 | 15.2     | 60     | 1012         | 2     |\n\nExample 2. When*triggeringPattern* is set to 'perBatch', insert 2 batches of data.\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades2\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine2=createCrossSectionalEngine(name=\"csEngineDemo2\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades2, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"perBatch\", useSystemTime=false, timeColumn=`time)\nsubscribeTable(tableName=\"trades2\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine2}, msgAsTable=true)\ninsert into trades2 values(2020.08.12T09:30:00.000 + 123 234 456, `A`B`A, 10 20 10.1, 20 10 20);\nsleep(1)\ninsert into trades2 values(2020.08.12T09:30:00.000 + 678 890 901, `B`B`A, 20.1 20.2 10.2, 30 40 20);\n\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2020.08.12T09:30:00.456 | 15.05    | 30     | 402          | 2     |\n| 2020.08.12T09:30:00.901 | 15.2     | 60     | 1012         | 2     |\n\nExample 3. The following example sets *triggeringPattern* to 'keyCount' and *lastBatchOnly* to true. Only the data with the latest timestamp will participate in calculation. Since there are both aggregate and non-aggregate functions set in metrics, the number of rows in the result table will be the same as that in the input table.\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1\nshare table(1:0, `time`factor1`factor2, [TIMESTAMP, DOUBLE,INT]) as outputTable\nagg=createCrossSectionalEngine(name=\"csEngineDemo4\", metrics=<[price+ 0.1, sum(volume)]>, dummyTable=trades1, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"keyCount\", triggeringInterval=5, useSystemTime=false, timeColumn=`time,lastBatchOnly=true)\nsubscribeTable(tableName=`trades1, actionName=\"csEngineDemo4\", msgAsTable=true, handler=append!{agg})\nnum=10\ntime=array(TIMESTAMP)\ntime=take(2018.01.01T09:30:00.000,num)\nsym=take(\"A\"+string(1..10),num)\nprice=1..num\nvolume=1..num\ntmp=table(time, sym, price, volume)\ntrades1.append!(tmp)\n\n// Only the latest 5 records will participate in calculation.\nnum=5\ntime = array(TIMESTAMP)\ntime=take(2018.01.01T09:30:01.000,num)\nsym=take(\"A\"+string(1..10),num)\nprice=6..10\nvolume=6..10\ntmp=table(time, sym, price, volume)\ntrades1.append!(tmp)\n```\n\n| time                    | factor1 | factor2 |\n| ----------------------- | ------- | ------- |\n| 2018.01.01T09:30:00.000 | 1.1     | 55      |\n| 2018.01.01T09:30:00.000 | 2.1     | 55      |\n| 2018.01.01T09:30:00.000 | 3.1     | 55      |\n| 2018.01.01T09:30:00.000 | 4.1     | 55      |\n| 2018.01.01T09:30:00.000 | 5.1     | 55      |\n| 2018.01.01T09:30:00.000 | 6.1     | 55      |\n| 2018.01.01T09:30:00.000 | 7.1     | 55      |\n| 2018.01.01T09:30:00.000 | 8.1     | 55      |\n| 2018.01.01T09:30:00.000 | 9.1     | 55      |\n| 2018.01.01T09:30:00.000 | 10.1    | 55      |\n| 2018.01.01T09:30:01.000 | 6.1     | 40      |\n| 2018.01.01T09:30:01.000 | 7.1     | 40      |\n| 2018.01.01T09:30:01.000 | 8.1     | 40      |\n| 2018.01.01T09:30:01.000 | 9.1     | 40      |\n| 2018.01.01T09:30:01.000 | 10.1    | 40      |\n\nExample 4. Set *triggeringPattern* to 'interval' and *triggeringInterval* to 500 (milliseconds).\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades3\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine3=createCrossSectionalEngine(name=\"csEngineDemo3\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades3, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"interval\", triggeringInterval=500)\nsubscribeTable(tableName=\"trades3\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine3}, msgAsTable=true);\n\ninsert into trades3 values(2020.08.12T09:30:00.000, `A, 10, 20)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 500, `B, 20, 10)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 1000, `A, 10.1, 20)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 2000, `B, 20.1, 30)\nsleep(500)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 2500, `B, 20.2, 40)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 3000, `A, 10.2, 20);\nsleep(500)\n\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2022.03.02T11:17:02.341 | 15.1     | 50     | 805          | 2     |\n| 2022.03.02T11:17:02.850 | 15.2     | 60     | 1,012        | 2     |\n\nThe calculation is triggered every 500 ms based on the system time. Only the records with the latest timestamp participate in the calculation, even if there are multiple uncalculated records with the same key.\n\nIn the above example, the table returned by cross sectional engine is usually an intermediate result for the calculation. But it can also be a final result. For example, if you need to regularly refresh the latest trading price of a certain stock, the basic way is to filter the stocks by code from the real-time trading table and retrieve the last record. However, the amount of data in the trading table is growing rapidly over time. For frequent queries, it is not the best practice in terms of system resource consumption or query performance. The cross sectional table only saves the latest transaction data of all stocks, the data amount is stable. So it is very suitable for the timing polling scenario.\n\nTo use a cross sectional table as a final result, you need to set *metrics* and *outputTable* to be empty.\n\n```\ntradesCrossEngine=createCrossSectionalEngine(name=\"CrossSectionalDemo\", dummyTable=trades, keyColumn=`sym, triggeringPattern=`perRow)\n```\n"
    },
    "createCrossSectionalEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createCrossSectionalEngine.html",
        "signatures": [
            {
                "full": "createCrossSectionalEngine(name, [metrics], dummyTable, [outputTable], keyColumn, [triggeringPattern='perBatch'], [triggeringInterval=1000], [useSystemTime=true], [timeColumn], [lastBatchOnly=false], [contextByColumn], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup], [outputElapsedMicroseconds=false], [roundTime=true], [keyFilter])",
                "name": "createCrossSectionalEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[metrics]",
                        "name": "metrics",
                        "optional": true
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "[outputTable]",
                        "name": "outputTable",
                        "optional": true
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "[triggeringPattern='perBatch']",
                        "name": "triggeringPattern",
                        "optional": true,
                        "default": "'perBatch'"
                    },
                    {
                        "full": "[triggeringInterval=1000]",
                        "name": "triggeringInterval",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[useSystemTime=true]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[lastBatchOnly=false]",
                        "name": "lastBatchOnly",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[contextByColumn]",
                        "name": "contextByColumn",
                        "optional": true
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[keyFilter]",
                        "name": "keyFilter",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createCrossSectionalEngine](https://docs.dolphindb.com/en/Functions/c/createCrossSectionalEngine.html)\n\n\n\n#### Syntax\n\ncreateCrossSectionalEngine(name, \\[metrics], dummyTable, \\[outputTable], keyColumn, \\[triggeringPattern='perBatch'], \\[triggeringInterval=1000], \\[useSystemTime=true], \\[timeColumn], \\[lastBatchOnly=false], \\[contextByColumn], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[raftGroup], \\[outputElapsedMicroseconds=false], \\[roundTime=true], \\[keyFilter])\n\nAlias: createCrossSectionalAggregator\n\n#### Details\n\nThis function creates a cross-sectional streaming engine and returns a keyed table with *keyColumn* as the key.\n\nThe keyed table is updated every time a new record arrives. If the parameter *lastBatchOnly* is set to true, the table only maintains the latest record in each group. When new data is ingested into the engine,\n\n* if *metrics* and *outputTable* are specified, the engine first updates the keyed table, then performs calculations on the latest data and outputs the results to *outputTable*.\n\n* if *metrics* and *outputTable* are not specified, the engine only updates the keyed table.\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n##### Calculation Rules\n\nThe calculation can be triggered by the number of records or time interval. See parameters *triggeringPattern* and *triggeringInterval*. Note that if *contextByColumn* is specified, the data will be grouped by the specified columns and calculated by group.\n\n##### Features\n\n* Snapshot: Snapshot mechanism is used to restore the streaming engine to the latest snapshot after system interruption. (See parameters *snapshotDir* and *snapshotIntervalInMsgCount*)\n\n* High availability: To enable high availability for streaming engines, specify the parameter *raftGroup* on the leader of the raft group on the subscriber. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table.\n\n#### Arguments\n\n**name** is a string of the engine name. It is the only identifier of a cross sectional engine on a data/compute node. It can have letter, number and \"\\_\" and must start with a letter.\n\n**metrics** (optional) is metacode or a tuple specifying the formulas for calculation. It can be:\n\n* Built-in or user-defined aggregate functions, e.g., `<[sum(qty), avg(price)]>`; Or expressions on previous results, e.g., `<[avg(price1)-avg(price2)]>`; Or calculation on multiple columns, e.g., `<[std(price1-price2)]>`\n\n* Functions with multiple returns, such as `<func(price) as `col1`col2>`. The column names can be specified or not. For more information about metacode, see [Metaprogramming](https://docs.dolphindb.com/en/Programming/Metaprogramming/functional_meta.html).\n\n* The column names specified in *metrics* are not case-sensitive and can be inconsistent with the column names of the input tables.\n\n**dummyTable** is a table object whose schema must be the same as the stream table to which the engine subscribes. Whether *dummyTable* contains data does not matter. For versions 2.00.14/3.00.2 and later, *dummyTable* can include array vector columns.\n\n**outputTable** (optional) is the output table for the results. It can be an in-memory table or a DFS table. Create an empty table and specify the column names and types before calling the function. Make sure that data types of columns storing calculation results are the same as the results of metrics. The output columns are in the following order:\n\n(1) The first column is of TIMESTAMP type.\n\n* If *useSystemTime* = true, the column stores the time when each calculation starts;\n\n* If *useSystemTime* = false, it takes the values of *timeColumn*.\n\n(2) The following column is the *contextByColumn* (if specified).\n\n(3) If the *outputElapsedMicroseconds* is set to true, specify two more columns: a LONG column and an INT column.\n\n(4) The remaining columns store the calculation results of metrics.\n\n**keyColumn** is a STRING scalar or vector that specifies one or more columns in the stream table as the key columns. For each unique value in the *keyColumn*, only the latest record is used in the calculation.\n\n**triggeringPattern** (optional) is a STRING scalar specifying how to trigger the calculations. The engine returns a result every time a calculation is triggered. It can take one of the following values:\n\n* 'perBatch' (default): calculates when a batch of data arrives.\n\n* 'perRow': calculates when a new record arrives.\n\n* 'interval': calculates at intervals specified by *triggeringInterval*, using system time.\n\n* 'interval': calculates at the intervals of triggeringInterval (using system time).\n\n* 'keyCount': When data with the same timestamp arrives in batches, the calculation is triggered when:\n\n  * if the number of keys with the latest timestamp reaches *triggeringInterval*;\n\n  * or data with newer timestamp arrives.\n\n* 'dataInterval': calculates at intervals based on timestamps in the data. To use this, *timeColumn* must be specified and *useSystemTime* must be false.\n\nNote: To set *triggeringPattern* as 'keyCount', *timeColumn* must be specified and *useSystemTime* must be set to false. In this case, the out-of-order data will be discarded.\n\n**triggeringInterval** (optional) can be an integer or a tuple. Below explains its optional values and triggering rules:\n\n* If *triggeringPattern* = 'interval', *triggeringInterval* is a positive integer indicating the interval in milliseconds between 2 adjacent calculations. The default value is 1,000. Every *triggeringInterval* milliseconds, the system checks if the data in the engine has been calculated; if not, a calculation is triggered.\n\n* If *triggeringPattern* = 'keyCount', *triggeringInterval* can be:\n\n  * an integer specifying a threshold. Before data with a greater timestamp arrives, a calculation is triggered when the number of uncalculated records reaches the threshold.\n\n  * a tuple of 2 elements. The first element is an integer indicating the threshold of the number records with the latest timestamp to trigger calculation. The second element is an integer or duration value.\n\n  For example, when *triggeringInterval* is set to (c1, c2):\n\n  * If c2 is an integer and the number of keys with the latest timestamp t1 doesn't reach c1, calculation will not be triggered and the system goes on to save data with greater timestamp t2 (t2>t1). Data with t1 will be calculated when either of the events happens: the number of keys with timestamp t2 reaches c2, or data with greater timestamp t3 (t3>t2) arrives. Note that c2 must be smaller than c1.\n\n  * If c2 is a duration and the number of keys with the latest timestamp t1 doesn't reach c1, calculation will not be triggered and the system goes on to save data with greater timestamp t2 (t2>t1) . Once data with t2 starts to come in, data with t1 will not be calculated until any of the events happens: the number of keys with timestamp t1 reaches c1, or data with greater timestamp t3 (t3>t2) arrives, or the duration c2 comes to an end.\n\n* If *triggeringPattern*= 'dataInterval', *triggeringInterval* is a positive integer measured in the same units as the timestamps in *timeColumn*. The default is 1,000. Starting with the first record, a window is started at intervals defined by *triggeringInterval*, based on the timestamp units. When the first record of the next window arrives, a calculation is triggered on all data in the current window.\n\n  * In versions 2.00.11.21.30.23.2 and earlier, a calculation is triggered for each window.\n\n  * Since version 2.00.11.31.30.23.3, a calculation is triggered only for windows containing data.\n\n**useSystemTime** (optional) is a Boolean value indicating whether the calculations are performed based on the system time when data is ingested into the engine.\n\n* If *useSystemTime* = true, the time column of outputTable is the system time;\n\n* If *useSystemTime* = false, the parameter timeColumn must be specified. The time column of *outputTable* uses the timestamp of each record.\n\n**timeColumn** (optional) is a STRING scalar which specifies the time column in the stream table to which the engine subscribes if *useSystemTime* = false. It can only be of TIMESTAMP type.\n\n**lastBatchOnly** (optional) is a Boolean value indicating whether to keep only the records with the latest timestamp in the engine. When *lastBatchOnly* = true, *triggeringPattern* must take the value 'keyCount', and the cross-sectional engine only maintains key values with the latest timestamp for calculation. Otherwise, the engine updates and retains all values for calculation.\n\n**contextByColumn** (optional) is a STRING scalar or vector indicating the grouping column(s) based on which calculations are performed by group. This parameter only takes effect if *metrics* and *outputTable* are specified. If *metrics* only contains aggregate functions, the calculation results would be the same as a SQL query using `group by`. Otherwise, the results would be consistent with that using `context by`.\n\nTo enable snapshot in the streaming engines, specify parameters *snapshotDir* and *snapshotIntervalInMsgCount*.\n\n**snapshotDir** (optional) is a string indicating the directory where the streaming engine snapshot is saved. The directory must already exist, otherwise an exception is thrown. If *snapshotDir* is specified, the system checks whether a snapshot already exists in the directory when creating a streaming engine. If it exists, the snapshot will be loaded to restore the engine state. Multiple streaming engines can share a directory where the snapshot files are named as the engine names.\n\nThe file extension of a snapshot can be:\n\n* *\\<engineName>.tmp*: temporary snapshot\n* *\\<engineName>.snapshot*: a snapshot that is generated and flushed to disk\n* *\\<engineName>.old*: if a snapshot with the same name already exists, the previous snapshot is renamed to *\\<engineName>.old*.\n\n**snapshotIntervalInMsgCount** (optional) is a positive integer indicating the number of messages to receive before the next snapshot is saved.\n\n**raftGroup** (optional) is an integer greater than 1, indicating ID of the raft group on the high-availability streaming subscriber specified by the configuration parameter *streamingRaftGroups*. Specify *raftGroup* to enable high availability for the streaming engines. When an engine is created on the leader, it is also created on each follower and the engine snapshot is synchronized to the followers. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table. Note that *SnapShotDir* must also be specified when specifying a raft group.\n\n**outputElapsedMicroseconds** (optional) is a Boolean value. The default value is false. It determines whether to output:\n\n* the elapsed time (in microseconds) from the ingestion of data to the output of result in each batch.\n\n* the total row number of each batch.\n\n**Note**: When both *outputElapsedMicroseconds*and *useSystemTime*parameters are set to true, aggregate function cannot be used in *metrics*.\n\n**roundTime** (optional) is a Boolean value indicating the method to align the window boundary when *triggeringPattern*='dataInterval'. The default value is true indicating the alignment is based on the multi-minute rule (see the [alignment rules](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.md#) of time-series engine). False means alignment is based on the one-minute rule.\n\n**keyFilter** (optional) is metacode of an expression or function call that returns a Boolean vector. It specifies the conditions for filtering keys in the keyed table returned by the engine. Only data with keys satisfying the filtering conditions will be taken for calculation.\n\n#### Examples\n\nExample 1. A table \"csEngine1\" is created with function `createCrossSectionalEngine` and it subscribes to the stream table trades1. We set *triggeringPattern* to 'perRow', so each row that is inserted into table csEngine1 triggers a calculation.\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine1=createCrossSectionalEngine(name=\"csEngineDemo1\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades1, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"perRow\", useSystemTime=false, timeColumn=`time)\nsubscribeTable(tableName=\"trades1\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine1}, msgAsTable=true)\ninsert into trades1 values(2020.08.12T09:30:00.000 + 123 234 456 678 890 901, `A`B`A`B`B`A, 10 20 10.1 20.1 20.2 10.2, 20 10 20 30 40 20);\n\nselect * from trades1;\n```\n\n| time                    | sym | price | volume |\n| ----------------------- | --- | ----- | ------ |\n| 2020.08.12T09:30:00.123 | A   | 10    | 20     |\n| 2020.08.12T09:30:00.234 | B   | 20    | 10     |\n| 2020.08.12T09:30:00.456 | A   | 10.1  | 20     |\n| 2020.08.12T09:30:00.678 | B   | 20.1  | 30     |\n| 2020.08.12T09:30:00.890 | B   | 20.2  | 40     |\n| 2020.08.12T09:30:00.901 | A   | 10.2  | 20     |\n\n```\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2020.08.12T09:30:00.123 | 10       | 20     | 200          | 1     |\n| 2020.08.12T09:30:00.234 | 15       | 30     | 400          | 2     |\n| 2020.08.12T09:30:00.456 | 15.05    | 30     | 402          | 2     |\n| 2020.08.12T09:30:00.678 | 15.1     | 50     | 805          | 2     |\n| 2020.08.12T09:30:00.890 | 15.15    | 60     | 1010         | 2     |\n| 2020.08.12T09:30:00.901 | 15.2     | 60     | 1012         | 2     |\n\nExample 2. When*triggeringPattern* is set to 'perBatch', insert 2 batches of data.\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades2\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine2=createCrossSectionalEngine(name=\"csEngineDemo2\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades2, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"perBatch\", useSystemTime=false, timeColumn=`time)\nsubscribeTable(tableName=\"trades2\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine2}, msgAsTable=true)\ninsert into trades2 values(2020.08.12T09:30:00.000 + 123 234 456, `A`B`A, 10 20 10.1, 20 10 20);\nsleep(1)\ninsert into trades2 values(2020.08.12T09:30:00.000 + 678 890 901, `B`B`A, 20.1 20.2 10.2, 30 40 20);\n\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2020.08.12T09:30:00.456 | 15.05    | 30     | 402          | 2     |\n| 2020.08.12T09:30:00.901 | 15.2     | 60     | 1012         | 2     |\n\nExample 3. The following example sets *triggeringPattern* to 'keyCount' and *lastBatchOnly* to true. Only the data with the latest timestamp will participate in calculation. Since there are both aggregate and non-aggregate functions set in metrics, the number of rows in the result table will be the same as that in the input table.\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1\nshare table(1:0, `time`factor1`factor2, [TIMESTAMP, DOUBLE,INT]) as outputTable\nagg=createCrossSectionalEngine(name=\"csEngineDemo4\", metrics=<[price+ 0.1, sum(volume)]>, dummyTable=trades1, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"keyCount\", triggeringInterval=5, useSystemTime=false, timeColumn=`time,lastBatchOnly=true)\nsubscribeTable(tableName=`trades1, actionName=\"csEngineDemo4\", msgAsTable=true, handler=append!{agg})\nnum=10\ntime=array(TIMESTAMP)\ntime=take(2018.01.01T09:30:00.000,num)\nsym=take(\"A\"+string(1..10),num)\nprice=1..num\nvolume=1..num\ntmp=table(time, sym, price, volume)\ntrades1.append!(tmp)\n\n// Only the latest 5 records will participate in calculation.\nnum=5\ntime = array(TIMESTAMP)\ntime=take(2018.01.01T09:30:01.000,num)\nsym=take(\"A\"+string(1..10),num)\nprice=6..10\nvolume=6..10\ntmp=table(time, sym, price, volume)\ntrades1.append!(tmp)\n```\n\n| time                    | factor1 | factor2 |\n| ----------------------- | ------- | ------- |\n| 2018.01.01T09:30:00.000 | 1.1     | 55      |\n| 2018.01.01T09:30:00.000 | 2.1     | 55      |\n| 2018.01.01T09:30:00.000 | 3.1     | 55      |\n| 2018.01.01T09:30:00.000 | 4.1     | 55      |\n| 2018.01.01T09:30:00.000 | 5.1     | 55      |\n| 2018.01.01T09:30:00.000 | 6.1     | 55      |\n| 2018.01.01T09:30:00.000 | 7.1     | 55      |\n| 2018.01.01T09:30:00.000 | 8.1     | 55      |\n| 2018.01.01T09:30:00.000 | 9.1     | 55      |\n| 2018.01.01T09:30:00.000 | 10.1    | 55      |\n| 2018.01.01T09:30:01.000 | 6.1     | 40      |\n| 2018.01.01T09:30:01.000 | 7.1     | 40      |\n| 2018.01.01T09:30:01.000 | 8.1     | 40      |\n| 2018.01.01T09:30:01.000 | 9.1     | 40      |\n| 2018.01.01T09:30:01.000 | 10.1    | 40      |\n\nExample 4. Set *triggeringPattern* to 'interval' and *triggeringInterval* to 500 (milliseconds).\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades3\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine3=createCrossSectionalEngine(name=\"csEngineDemo3\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades3, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"interval\", triggeringInterval=500)\nsubscribeTable(tableName=\"trades3\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine3}, msgAsTable=true);\n\ninsert into trades3 values(2020.08.12T09:30:00.000, `A, 10, 20)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 500, `B, 20, 10)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 1000, `A, 10.1, 20)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 2000, `B, 20.1, 30)\nsleep(500)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 2500, `B, 20.2, 40)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 3000, `A, 10.2, 20);\nsleep(500)\n\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2022.03.02T11:17:02.341 | 15.1     | 50     | 805          | 2     |\n| 2022.03.02T11:17:02.850 | 15.2     | 60     | 1,012        | 2     |\n\nThe calculation is triggered every 500 ms based on the system time. Only the records with the latest timestamp participate in the calculation, even if there are multiple uncalculated records with the same key.\n\nIn the above example, the table returned by cross sectional engine is usually an intermediate result for the calculation. But it can also be a final result. For example, if you need to regularly refresh the latest trading price of a certain stock, the basic way is to filter the stocks by code from the real-time trading table and retrieve the last record. However, the amount of data in the trading table is growing rapidly over time. For frequent queries, it is not the best practice in terms of system resource consumption or query performance. The cross sectional table only saves the latest transaction data of all stocks, the data amount is stable. So it is very suitable for the timing polling scenario.\n\nTo use a cross sectional table as a final result, you need to set *metrics* and *outputTable* to be empty.\n\n```\ntradesCrossEngine=createCrossSectionalEngine(name=\"CrossSectionalDemo\", dummyTable=trades, keyColumn=`sym, triggeringPattern=`perRow)\n```\n"
    },
    "createDailyTimeSeriesEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createDailyTimeSeriesEngine.html",
        "signatures": [
            {
                "full": "createDailyTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, [timeColumn], [useSystemTime=false], [keyColumn], [garbageSize], [updateTime], [useWindowStartTime], [roundTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [fill='none'], [sessionBegin], [sessionEnd], [mergeSessionEnd=false], [forceTriggerTime], [raftGroup], [forceTriggerSessionEndTime], [keyPurgeFreqInSec=-1], [closed='left'], [outputElapsedMicroseconds=false], [subWindow], [parallelism=1], [acceptedDelay=0], [outputHandler=NULL], [msgAsTable=false], [keyPurgeDaily=true])",
                "name": "createDailyTimeSeriesEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "windowSize",
                        "name": "windowSize"
                    },
                    {
                        "full": "step",
                        "name": "step"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[updateTime]",
                        "name": "updateTime",
                        "optional": true
                    },
                    {
                        "full": "[useWindowStartTime]",
                        "name": "useWindowStartTime",
                        "optional": true
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[fill='none']",
                        "name": "fill",
                        "optional": true,
                        "default": "'none'"
                    },
                    {
                        "full": "[sessionBegin]",
                        "name": "sessionBegin",
                        "optional": true
                    },
                    {
                        "full": "[sessionEnd]",
                        "name": "sessionEnd",
                        "optional": true
                    },
                    {
                        "full": "[mergeSessionEnd=false]",
                        "name": "mergeSessionEnd",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[forceTriggerTime]",
                        "name": "forceTriggerTime",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[forceTriggerSessionEndTime]",
                        "name": "forceTriggerSessionEndTime",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSec=-1]",
                        "name": "keyPurgeFreqInSec",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[subWindow]",
                        "name": "subWindow",
                        "optional": true
                    },
                    {
                        "full": "[parallelism=1]",
                        "name": "parallelism",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[acceptedDelay=0]",
                        "name": "acceptedDelay",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyPurgeDaily=true]",
                        "name": "keyPurgeDaily",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [createDailyTimeSeriesEngine](https://docs.dolphindb.com/en/Functions/c/createDailyTimeSeriesEngine.html)\n\n\n\n#### Syntax\n\ncreateDailyTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, \\[timeColumn], \\[useSystemTime=false], \\[keyColumn], \\[garbageSize], \\[updateTime], \\[useWindowStartTime], \\[roundTime=true], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[fill='none'], \\[sessionBegin], \\[sessionEnd], \\[mergeSessionEnd=false], \\[forceTriggerTime], \\[raftGroup], \\[forceTriggerSessionEndTime], \\[keyPurgeFreqInSec=-1], \\[closed='left'], \\[outputElapsedMicroseconds=false], \\[subWindow], \\[parallelism=1], \\[acceptedDelay=0], \\[outputHandler=NULL], \\[msgAsTable=false], \\[keyPurgeDaily=true])\n\n#### Details\n\nThis function creates a daily time-series streaming engine. The windowing logic and calculation rules of the daily time-series engine are similar to those of the time-series engine. Features exclusive to the daily time-series engine are listed as follows:\n\n* Window calculations are performed only within a specified time period (known as a \"session\") of a calendar day. A day can have multiple sessions, such as 9:00-12:00, 13:00-15:00, and so on.\n\n* Data that arrives before the start of a session within a calendar day will be included in the calculation of the first window of that session.\n\n* Data that arrives after the end of the last session of that day will be discarded.\n\nNote: If *keyColumn* is specified to group data by the column values, the calculations described above will be performed within each group.\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n#### Arguments\n\nThe daily time-series engine is an extension of the time-series engine ([createTimeSeriesEngine](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html)) and inherits all of its parameters. In this section, we will only cover the parameters specific to this engine.\n\n**sessionBegin** (optional) can be a scalar or vector of type SECOND, TIME or NANOTIME corresponding to the data type of the time column, indicating the starting time of each session. If it is a vector, it must be increasing.\n\n**sessionEnd** (optional) can be a scalar or vector of type SECOND, TIME or NANOTIME corresponding to the data type of the time column, indicating the end time of each session. Specify *sessionEnd* as 00:00:00 to indicate the beginning of the next day (i.e., 24:00:00 of the current day).\n\n**mergeSessionEnd** (optional) is a Boolean value. This parameter is only applicable when *closed* = 'left'. It determines whether the record arriving at the end of a session (which has been adjusted based on the alignment rules) will be included in the calculation of the last window of that session. The default value is false, which means the record will not be included in the last window but will trigger its calculation. If the current session is not the last session of the day, the record will participate in the calculation of the first window of the next session.\n\n**forceTriggerSessionEndTime** (optional) is a positive integer. The unit of *forceTriggerSessionEndTime* is consistent with the precision of *timeColumn*. It indicates the waiting time to force trigger calculation in the window containing the *sessionEnd*, if it ends without calculation.\n\nIf no data is ingested into a group after the last window is calculated, and new data continues to ingest into other groups, the specified *fill* parameter can be used to fill the results of empty windows of that group. This ensures that the group's windows will still be output at the latest time point. If parameter *fill* is not specified, no new windows will be generated for that group after the calculation of the last window.\n\n**Note:** The engine automatically adjusts the starting point of the window for *sessionBegin* and *sessionEnd* according to the value of *alignmentSize*.\n\n**acceptedDelay** (optional) is a positive integer less than or equal to\\*windowSize,\\*specifying the maximum delay for each window to accept data.The default value is 0.\n\n* When *useSystemTime*=true, data received within the *acceptedDelay*time after the window ends will still be considered part of the current window and participate in the computation, and will not be included in the computation of the next window.\n\n* When *useSystemTime*=false, a window with t as right boundary will wait until a record with a timestamp equal to or later than t + *acceptedDelay* arrives. When such a record arrives, the current window closes and performs a calculation on all records within the window frame. This handles scenarios with out-of-order data.\n\n**outputHandler** (optional) is a unary function or a partial function with a single unfixed parameter. If set, the engine will not write the calculation results to the output table directly. Instead, the results will be passed as a parameter to the *outputHandler* function. The default value is NULL, which means the result will be written to the output table.\n\n**msgAsTable** (optional) is a Boolean scalar indicating whether the output data is passed into function (specified by *outputHandler*) as a table or as a tuple. If *msgAsTable*=true, the subscribed data is passed into function as a table. The default value is false, which means the output data is passed into function as a tuple of columns.\n\n**keyPurgeDaily** (optional) is a Boolean value determining if existing data groups are automatically removed when newer data of a subsequent calendar day is ingested. The default value is true. If set to false, groups of the previous calendar day are retained.\n\n#### Examples\n\nExample 1:\n\n```\nshare streamTable(1000:0, `date`second`sym`volume, [DATE, SECOND, SYMBOL, INT]) as trades\nshare keyedTable(`time`sym, 10000:0, `time`sym`sumVolume, [DATETIME, SYMBOL, INT]) as output1\nengine1 = createDailyTimeSeriesEngine(name=\"engine1\", windowSize=60, step=60, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`date`second, useSystemTime=false, keyColumn=`sym, garbageSize=50, updateTime=2, useWindowStartTime=false, sessionBegin=09:30:00 13:00:00, sessionEnd=11:30:00 15:00:00,mergeSessionEnd=true)\nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=append!{engine1}, msgAsTable=true);\n\ninsert into trades values(2018.10.08,09:25:31,`A,8)\ninsert into trades values(2018.10.08,09:26:01,`B,10)\ninsert into trades values(2018.10.08,09:30:02,`A,26)\ninsert into trades values(2018.10.08,09:30:10,`B,14)\ninsert into trades values(2018.10.08,11:29:46,`A,30)\ninsert into trades values(2018.10.08,11:29:50,`B,11)\ninsert into trades values(2018.10.08,11:30:00,`A,14)\ninsert into trades values(2018.10.08,11:30:00,`B,4)\ninsert into trades values(2018.10.08,13:00:10,`A,16)\ninsert into trades values(2018.10.08,13:00:12,`B,9)\ninsert into trades values(2018.10.08,14:59:56,`A,20)\ninsert into trades values(2018.10.08,14:59:58,`B,20)\ninsert into trades values(2018.10.08,15:00:00,`A,10)\ninsert into trades values(2018.10.08,15:00:00,`B,29)\n\nsleep(1000)\nselect * from output1\n```\n\n| time                | sym | sumVolume |\n| ------------------- | --- | --------- |\n| 2018.10.08T09:31:00 | A   | 34        |\n| 2018.10.08T09:31:00 | B   | 24        |\n| 2018.10.08T11:30:00 | A   | 44        |\n| 2018.10.08T11:30:00 | B   | 15        |\n| 2018.10.08T13:01:00 | A   | 16        |\n| 2018.10.08T13:01:00 | B   | 9         |\n| 2018.10.08T15:00:00 | A   | 30        |\n| 2018.10.08T15:00:00 | B   | 49        |\n\nExample 2:\n\n```\nshare streamTable(1000:0, `date`second`sym`volume, [DATE, SECOND, SYMBOL, INT]) as trades\nshare keyedTable(`time`sym, 10000:0, `time`sym`sumVolume, [DATETIME, SYMBOL, INT]) as output1\nengine1 = createDailyTimeSeriesEngine(name=\"engine1\", windowSize=60, step=60, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`date`second, useSystemTime=false, keyColumn=`sym, garbageSize=50, useWindowStartTime=false, sessionBegin=09:30:00 13:00:00, sessionEnd=11:30:00 15:00:00,mergeSessionEnd=true,forceTriggerSessionEndTime=10)\nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=append!{engine1}, msgAsTable=true);\n\ninsert into trades values(date(now()),09:25:31,`A,8)\ninsert into trades values(date(now()),09:26:01,`B,10)\ninsert into trades values(date(now()),09:30:02,`A,26)\ninsert into trades values(date(now()),09:30:10,`B,14)\ninsert into trades values(date(now()),11:29:46,`A,30)\ninsert into trades values(date(now()),11:29:50,`B,11)\ninsert into trades values(date(now()),11:30:00,`B,14)\ninsert into trades values(date(now()),11:30:01,`A,4)\n\nselect * from output1\n```\n\n| time                | sym | sumVolume |\n| ------------------- | --- | --------- |\n| 2022.03.24T09:31:00 | A   | 34        |\n| 2022.03.24T09:31:00 | B   | 24        |\n| 2022.03.24T11:30:00 | A   | 30        |\n\nSet *forceTriggerSessionEndTime* = 10. Calculation on the window with the right boundary at 11:30:00 will be triggered 10 seconds after the system time reaches 11:30:00.\n\n```\nsleep(10000)\nselect * from output1\n```\n\n| time                | sym | sumVolume |\n| ------------------- | --- | --------- |\n| 2022.03.24T09:31:00 | A   | 34        |\n| 2022.03.24T09:31:00 | B   | 24        |\n| 2022.03.24T11:30:00 | A   | 30        |\n| 2022.03.03T11:30:00 | B   | 25        |\n\nExample 3:\n\nSet *keyPurgeDaily*=false. When the engine receives data of 2024.09.11, it will not remove groups of 2024.09.10.\n\n```\nshare streamTable(1000:0, `date`second`sym`volume, [DATE, SECOND, SYMBOL, INT]) as trades\nshare table(10000:0, `time`sym`sumVolume, [DATETIME, SYMBOL, INT]) as output1\nengine1 = createDailyTimeSeriesEngine(name=\"engine1\", windowSize=30*60, step=30*60, \n  metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, \n  timeColumn=`date`second, useSystemTime=false, keyColumn=`sym, garbageSize=50,\n  useWindowStartTime=false, sessionBegin=09:30:00 13:00:00, \n  sessionEnd=11:30:00 15:00:00,mergeSessionEnd=true, keyPurgeDaily=false, \n  fill=\"null\", forceTriggerTime=60)\n\ninsert into engine1 values(2024.09.10,13:00:10,`A,16)\ninsert into engine1 values(2024.09.10,13:00:12,`B,9)\ninsert into engine1 values(2024.09.10,13:00:12,`C,9)\ninsert into engine1 values(2024.09.10,14:59:56,`A,20)\ninsert into engine1 values(2024.09.10,14:59:58,`B,20)\ninsert into engine1 values(2024.09.10,15:00:00,`A,10)\ninsert into engine1 values(2024.09.10,15:00:00,`B,29)\n\ninsert into engine1 values(2024.09.11,09:30:02,`A,26)\ninsert into engine1 values(2024.09.11,09:30:10,`B,14)\ninsert into engine1 values(2024.09.11,10:30:46,`A,30)\ninsert into engine1 values(2024.09.11,10:30:50,`B,11)\n\nselect * from output1\n```\n\n| time                | sym | sumVolume |\n| ------------------- | --- | --------- |\n| 2024.09.10T13:30:00 | A   | 16        |\n| 2024.09.10T13:30:00 | B   | 9         |\n| 2024.09.10T13:30:00 | C   | 9         |\n| 2024.09.10T14:00:00 | A   | 11        |\n| 2024.09.10T14:00:00 | B   | 30        |\n| 2024.09.10T14:00:00 | C   | 13        |\n| 2024.09.10T14:30:00 | A   | 20        |\n| 2024.09.10T14:30:00 | B   | 20        |\n| 2024.09.10T14:30:00 | C   | 10        |\n| 2024.09.10T15:00:00 | A   | 30        |\n| 2024.09.10T15:00:00 | B   | 49        |\n| 2024.09.10T15:00:00 | C   |           |\n| 2024.09.11T10:00:00 | A   | 26        |\n| 2024.09.11T10:00:00 | B   | 14        |\n| 2024.09.11T10:00:00 | C   |           |\n| 2024.09.11T10:30:00 | A   |           |\n\nIt can be seen that group C is still present in the results for 2024.09.11, even though the data for this day does not include group C.\n\nExample 4:\n\nIf the difference between *sessionEnd* and *sessionBegin* cannot be evenly divided by *step*, the last window of the session will not be output due to insufficient window size. To output the data for this window, you need to set *roundTime* = false, which will align the window according to the one-minute basis.\n\n```\n// clear variables\ndropStreamEngine(\"engine1\")\nunsubscribeTable(tableName=\"trades\", actionName=\"engine1\")\nundef(`trades, SHARED)\nundef(`output1,SHARED)\n\nshare streamTable(1000:0, `date`time`sym`volume, [DATE, TIME, SYMBOL, INT]) as trades\nshare keyedTable(`timestamp`sym, 10000:0, `timestamp`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output1\n\n// Create the engine, specifying a window length of 10 minutes. The last sessionEnd is 14:57:00\nengine1 = createDailyTimeSeriesEngine(name=\"engine1\", windowSize=600000, step=600000, \n  metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`date`time, garbageSize=50, updateTime=2, \n  useSystemTime=false, keyColumn=`sym,  useWindowStartTime=false, mergeSessionEnd=true,\n  sessionBegin=09:30:00.000 13:00:00.000,  sessionEnd=11:30:00.000 14:57:00.000, roundTime=false)\n  \nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, \n  handler=append!{engine1}, msgAsTable=true);\n\n// Simulate data insertion into the stream table\n// The last data point is at 14:56:00, which will be aligned to the 14:57:00 window\ninsert into trades values(2024.09.10,14:00:10.988,`A,16)\ninsert into trades values(2024.09.10,14:00:12.458,`B,9)\ninsert into trades values(2024.09.10,14:21:10.772,`A,13)\ninsert into trades values(2024.09.10,14:22:12.090,`B,15)\ninsert into trades values(2024.09.10,14:29:56.953,`A,20)\ninsert into trades values(2024.09.10,14:29:58.537,`B,20)\ninsert into trades values(2024.09.10,14:31:00.612,`A,10)\ninsert into trades values(2024.09.10,14:56:00.000,`B,29)\n\nsleep(1000)\nselect * from output1\n```\n"
    },
    "createDeviceEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createDeviceEngine.html",
        "signatures": [
            {
                "full": "createDeviceEngine(name, metrics, dummyTable, outputTable, [keyColumn],[keepOrder])",
                "name": "createDeviceEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[keepOrder]",
                        "name": "keepOrder",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createDeviceEngine](https://docs.dolphindb.com/en/Functions/c/createDeviceEngine.html)\n\n**Note:** This function is not supported by Community Edition. You can [get a trial](https://dolphindb.com/product#downloads-down) of Shark from DolphinDB official website.\n\n#### Syntax\n\ncreateDeviceEngine(name, metrics, dummyTable, outputTable, \\[keyColumn],\\[keepOrder])\n\n#### Arguments\n\n**name** is a string of the engine name. It is the only identifier of a reactive state engine on a data/compute node. It can have letter, number and \"\\_\" and must start with a letter.\n\n**metrics** is metacode specifying the formulas for calculation. It can include one or more expressions, built-in functions, or user-defined functions. User-defined functions must have a single return value and must not contain embedded for loops or any loops that exceed 100 iterations. It can also include a constant or a vector of constants (in which case, the output column must be of the array vector type). For more information about metacode, refer to [Metaprogramming](https://docs.dolphindb.com/en/Programming/Metaprogramming/functional_meta.html).\n\n**dummyTable** is a table object whose schema must be the same as the subscribed stream table. Whether *dummyTable* contains data does not matter.\n\n**outputTable** is the output table for the results. It can be an in-memory table or a DFS table. Create an empty table and specify the column names and types before calling the function.\n\n**keyColumn** (optional) is a STRING scalar/vector indicating the grouping column(s).\n\n**keepOrder** (optional) specifies whether to preserve the insertion order of the records in the output table. The default value is false, meaning data is sorted by *keyColumn*.\n\n#### Details\n\nCreate a device engine which conducts the calculations defined in the *metrics*with GPU acceleration.\n\n**Note:** The device engine does not retain any state information from one batch of data to the next. In other words, when two batches are processed, the second batch is processed independently of the first batch.\n\nThe following functions can be accelerated using GPUs:\n\n* Basic unary operation: not, neg, cast, log, log2, log10 ,log1p ,abs, sign, sqrt, sin, sinh, asin, asinh, cos, cosh, acos, acosh, tan, tanh, atan, atanh, reciprocal, cbrt, exp, exp2, expm1\n\n* Basic binary operation: add, sub, mul, div, ratio, pow, lt, gt, le, ge, eq, ne, and, or, or\\_\\_, max, min\n\n* Binary operation on integers: mod, bitAnd, bitOr, bitXor, lshift, rshift\n\n* Ternary operation: iif\n\n* Unary moving functions: mavg, msum, mcount, mprod, mvar, mvarp, mstd, mstdp, mskew, mkurtosis, mmin, mmax, mimin, mimax, sma, wma, mfirst, mlast, mrank, mmaxPositiveStreak, mmed, mpercentile, mmad (*useMedian* is currently not supported)\n\n* TALib-series Unary moving functions: sma, ema, wma, dema, tema, trima, t3, wilder, gema, linearTimeTrend, ma, talib (only the `m-` /moving functions and `mTopN-`/moving TopN functions are accepted)\n\n* Binary moving functions: mcorr, mbeta, mcovar, mwsum, mwavg\n\n* Other moving functions: linearTimeTrend, mslr\n\n* Unary cumulative functions: cumsum, cumprod, cummin, cummax, cumvar, cumvarp, cumstd, cumstdp, cumnunique, cumfirstNot, cumlastNot, cumavg, cumcount, cumPositiveStreak\n\n* Binary cumulative functions: cumcorr, cumcovar, cumbeta, cumwsum, cumwavg\n\n* Order-sensitive functions: deltas, ratios, ffill, move, prev, next, percentChange, iterate, prevState, ewmMean, ewmVar, ewmStd, ewmCov, ewmCorr\n\n  **Note:** For `ewmVar`, `ewmStd`, `ewmCov`, and `ewmCorr`, the *adjust* parameter must be set to false and *bias*must be true.\n\n* Moving TopN functions: msumTopN, mavgTopN, mstdpTopN, mstdTopN, mvarTopN, mvarpTopN, mwsumTopN, mcorrTopN, mcovarTopN, mbetaTopN, mskewTopN, mkurtosisTopN\n\n* Row-based functions: rowMin, rowMax, rowAnd, rowOr, rowXor, rowProd, rowSum, rowSum2, rowSize, rowCount, rowAvg, rowVar, rowVarp, rowStd, rowStdp\n\n* Time-based moving functions: tmsum, tmsum2, tmavg, tmprod, tmcount, tmvar, tmvarp, tmstd, tmstdp, tmcovar, tmcorr, tmwavg, tmwsum, tmbeta, tmfirst, tmlast, tmmin, tmmax, tmskew, tmkurtosis, tmove\n\n* Other functions: TrueRange, topRange, lowRange, stateMavg\n\n**Note:** Starting from version 3.00.1, when the absolute value of a calculation result is less than DBL\\_EPSILON\\*10000 *(approximately 2.22\\**10^-12), all moving functions and cumulative window functions will retain full precision instead of rounding the result.\n\n#### Details\n\n```\n// create a device engine\ndummyTb = table(1:0, `sym`id`value, [SYMBOL,INT,DOUBLE])\nshare table(100:0, `sym`id`flag`value`factor, [SYMBOL,INT,SYMBOL,DOUBLE,DOUBLE]) as result\nde = createDeviceEngine(name=\"myDe\", metrics=[<id>,<\"flag\"+\"_A\">,<value>,<mavg(value,5)>], dummyTable=dummyTb, outputTable=result, keyColumn=\"sym\")\n\n\n// simulate data\ndata1 = table(take(\"A\", 100) as sym, 1..100 as id, double(10+1..100) as value)\ndata2 = table(take(\"B\", 100) as sym, 1..100 as id, double(20+1..100) as value)\ndata3 = table(take(\"C\", 100) as sym, 1..100 as id, double(30+1..100) as value)\ndata = data1.unionAll(data2).unionAll(data3).sortBy!(`id)\n\n// write data\nde.append!(data)\nselect top 10 * from result\n```\n\n| sym | id | flag    | value | factor |\n| --- | -- | ------- | ----- | ------ |\n| A   | 1  | flag\\_A | 11    |        |\n| A   | 2  | flag\\_A | 12    |        |\n| A   | 3  | flag\\_A | 13    |        |\n| A   | 4  | flag\\_A | 14    |        |\n| A   | 5  | flag\\_A | 15    | 13     |\n| A   | 6  | flag\\_A | 16    | 14     |\n| A   | 7  | flag\\_A | 17    | 15     |\n| A   | 8  | flag\\_A | 18    | 16     |\n| A   | 9  | flag\\_A | 19    | 17     |\n| A   | 10 | flag\\_A | 20    | 18     |\n\n"
    },
    "createDimensionTable": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createDimensionTable.html",
        "signatures": [
            {
                "full": "createDimensionTable(dbHandle, table, tableName, [compressMethods], [sortColumns|primaryKey], [keepDuplicates=ALL], [softDelete=false], [indexes])",
                "name": "createDimensionTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[compressMethods]",
                        "name": "compressMethods",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns|primaryKey]",
                        "name": "[sortColumns|primaryKey]"
                    },
                    {
                        "full": "[keepDuplicates=ALL]",
                        "name": "keepDuplicates",
                        "optional": true,
                        "default": "ALL"
                    },
                    {
                        "full": "[softDelete=false]",
                        "name": "softDelete",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[indexes]",
                        "name": "indexes",
                        "optional": true
                    }
                ]
            },
            {
                "full": "createDimensionTable(dbHandle, table, tableName, [compressMethods], [sortColumns], [keepDuplicates=ALL], [softDelete=false])",
                "name": "createDimensionTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[compressMethods]",
                        "name": "compressMethods",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns]",
                        "name": "sortColumns",
                        "optional": true
                    },
                    {
                        "full": "[keepDuplicates=ALL]",
                        "name": "keepDuplicates",
                        "optional": true,
                        "default": "ALL"
                    },
                    {
                        "full": "[softDelete=false]",
                        "name": "softDelete",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createDimensionTable](https://docs.dolphindb.com/en/Functions/c/createDimensionTable.html)\n\n\n\n#### Syntax\n\ncreateDimensionTable(dbHandle, table, tableName, \\[compressMethods], \\[sortColumns|primaryKey], \\[keepDuplicates=ALL], \\[softDelete=false], \\[indexes])\n\ncreateDimensionTable(dbHandle, table, tableName, \\[compressMethods], \\[sortColumns], \\[keepDuplicates=ALL], \\[softDelete=false])\n\nAlias: createTable\n\n#### Arguments\n\n**Note:** The parameters *sortColumns* and *keepDuplicates* take effect only in a TSDB storage engine (i.e., `database().engine` = TSDB).\n\n**dbHandle** is a DFS database handle returned by function [database](https://docs.dolphindb.com/en/Functions/d/database.html).\n\n**table** is a table object. The table schema will be used to construct the new dimension table.\n\n**tableName** is a string indicating the name of the dimension table.\n\n**compressMethods** (optional) is a dictionary indicating which compression methods are used for specified columns. The keys are columns name and the values are compression methods (\"lz4\", \"delta\", \"zstd\" or \"chimp\"). If unspecified, use LZ4 compression method.\n\nNote:\n\n* The delta compression method can be used for DECIMAL, SHORT, INT, LONG or temporal data types.\n* Save strings as SYMBOL type to enable compression of strings.\n* The chimp compression method can be used for DOUBLE type data with decimal parts not exceeding three digits in length.\n\n**sortColumns** (optional) is a STRING scalar/vector that specifies the column(s) used to sort the ingested data within each level file. The sort columns must be of Integral, Temporal, STRING, SYMBOL, or DECIMAL type. Note that *sortColumns* is not necessarily consistent with the partitioning column.\n\n* If multiple columns are specified for *sortColumns*, the last column must be a time column. The preceding columns are used as the sort keys and they cannot be of TIME, TIMESTAMP, NANOTIME, or NANOTIMESTAMP type.\n* If only one column is specified for *sortColumns*, the column is used as the sort key, and it can be a time column or not. If the sort column is a time column and *sortKeyMappingFunction* is specified, the sort column specified in a SQL where condition can only be compared with temporal values of the same data type.\n* It is recommended to specify frequently-queried columns for *sortColumns* and sort them in the descending order of query frequency, which ensures that frequently-used data is readily available during query processing.\n* The number of sort key entries (which are unique combinations of the values of the sort keys) may not exceed 1000 for optimal performance. This limitation prevents excessive memory usage and ensures efficient query processing.\n\n**primaryKey** (optional) is a STRING scalar/vector that specifies the primary key column(s), uniquely identifying each record in a DFS table of **the PKEY database**. For records with the same primary key, only the latest one is retained. Note that:\n\n* *primaryKey* must include all partitioning columns.\n* The primary key columns must be of Logical, Integral (excluding COMPRESSED), Temporal, STRING, SYMBOL, or DECIMAL type.\n* With more than one primary key column, a composite primary key is maintained. The composite primary key uses a Bloomfilter index by default (see the *indexes* parameter for details).\n\n**keepDuplicates** (optional) specifies how to deal with records with duplicate *sortColumns* values. It can have the following values:\n\n* ALL: keep all records;\n* LAST: only keep the last record;\n* FIRST: only keep the first record.\n\n**softDelete** (optional) determines whether to enable soft delete for TSDB databases. The default value is false. To use it, *keepDuplicates* must be set to 'LAST'. It is recommended to enable soft delete for databases where the row count is large and delete operations are infrequent.\n\n**indexes** (optional) is a dictionary with columns as keys and index types as values. Both keys and values are of STRING type. *indexes* can only be set for tables of PKEY databases.\n\n* Currently, only \"bloomfilter\" index type is available. Bloomfilter indexing excels in point queries on high-cardinality columns (e.g., ID card numbers, order numbers, foreign keys from upstreams).\n* It supports indexing on columns of the following data types: BOOL, CHAR, SHORT, INT, LONG, BLOB, STRING, DECIMAL32, DECIMAL64, DECIMAL128.\n* Composite primary keys are automatically indexed with Bloomfilter. Columns not specified in *indexes* default to ZoneMap indexing.\n\n#### Details\n\nThis function creates an empty dimension (non-partitioned) table in a DFS database, used to store small datasets with infrequent updates. During query, all data in a dimension table will be loaded into the memory.\n\nThe system will regularly check the memory usage. When memory usage exceeds *warningMemSize*, the system will discard the least recently used (LRU) data from memory to clean up the cache. Users can also manually call command `clearCachedDatabase` to clear the cached data.\n\nLike partitioned tables, a dimension table can have multiple replicas (determined by the configuration parameter *dfsReplicationFactor*).\n\nTo enable concurrent writes, updates or deletes on a dimension table, set the configuration parameter *enableConcurrentDimensionalTableWrite* to true.\n\n#### Examples\n\nExample 1\n\n```\ndb=database(\"dfs://db1\",VALUE,1 2 3)\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nt = table(timestamp, sym, qty, price);\n\ndt=db.createDimensionTable(t,`dt).append!(t);\nselect * from dt;\n```\n\n| timestamp | sym | qty  | price  |\n| --------- | --- | ---- | ------ |\n| 09:34:07  | C   | 2200 | 49.6   |\n| 09:36:42  | MS  | 1900 | 29.46  |\n| 09:36:51  | MS  | 2100 | 29.52  |\n| 09:36:59  | MS  | 3200 | 30.02  |\n| 09:32:47  | IBM | 6800 | 174.97 |\n| 09:35:26  | IBM | 5400 | 175.23 |\n| 09:34:16  | C   | 1300 | 50.76  |\n| 09:34:26  | C   | 2500 | 50.32  |\n| 09:38:12  | C   | 8800 | 51.29  |\n\nExample 2\n\n```\ndb = database(\"dfs://demodb\", VALUE, 1..10)\nt=table(take(1, 86400) as id, 2020.01.01T00:00:00 + 0..86399 as timestamp, rand(1..100, 86400) as val)\ndt = db.createDimensionTable(t, \"dt\", {timestamp:\"delta\", val:\"delta\"})\ndt.append!(t)\n```\n\nExample 3. Create a dimension table in a TSDB database\n\n```\nif(existsDatabase(\"dfs://dbctable_createDimensionTable\")){\n    dropDatabase(\"dfs://dbctable_createDimensionTable\")\n}\ndb = database(\"dfs://dbctable_createDimensionTable\", VALUE, 1..100, , \"TSDB\")\nt1 = table(1 100 100 300 300 400 500 as id, 1..7 as v)\ndb.createDimensionTable(t1, \"dt\", , \"id\").append!(t1)\ndt=loadTable(\"dfs://dbctable_createDimensionTable\",\"dt\")\n```\n\nExample 4. Create a dimension table in a PKEY database.\n\n```\ndb = database(directory=\"dfs://PKDB\", partitionType=VALUE, partitionScheme=1..10, engine=\"PKEY\")\nschematb = table(1:0,`id1`id2`val1`val2`date1`time1,[INT,INT,INT,DECIMAL32(2),DATE,TIME])\npkt = createDimensionTable(dbHandle=db, table=schematb, tableName=\"pkt\", primaryKey=`id1`id2, indexes={\"val1\": \"bloomfilter\", \"val2\": \"bloomfilter\"})\n```\n\nRelated functions: [createPartitionedTable](https://docs.dolphindb.com/en/Functions/c/createPartitionedTable.html)\n"
    },
    "createDistributedInMemoryTable": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createDistributedInMemoryTable.html",
        "signatures": [
            {
                "full": "createDistributedInMemoryTable(tableName, colNames, colTypes, globalPartitionType, globalPartitionScheme, globalPartitionColumn, [localPartitionType], [localPartitionScheme], [localPartitionColumn])",
                "name": "createDistributedInMemoryTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    },
                    {
                        "full": "globalPartitionType",
                        "name": "globalPartitionType"
                    },
                    {
                        "full": "globalPartitionScheme",
                        "name": "globalPartitionScheme"
                    },
                    {
                        "full": "globalPartitionColumn",
                        "name": "globalPartitionColumn"
                    },
                    {
                        "full": "[localPartitionType]",
                        "name": "localPartitionType",
                        "optional": true
                    },
                    {
                        "full": "[localPartitionScheme]",
                        "name": "localPartitionScheme",
                        "optional": true
                    },
                    {
                        "full": "[localPartitionColumn]",
                        "name": "localPartitionColumn",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createDistributedInMemoryTable](https://docs.dolphindb.com/en/Functions/c/createDistributedInMemoryTable.html)\n\n\n\n#### Syntax\n\ncreateDistributedInMemoryTable(tableName, colNames, colTypes, globalPartitionType, globalPartitionScheme, globalPartitionColumn, \\[localPartitionType], \\[localPartitionScheme], \\[localPartitionColumn])\n\n#### Details\n\nCreate a distributed in-memory table and store it on different nodes based on the specified partitioning scheme. This function can only be executed on a data node or compute node in cluster mode.\n\nA distributed in-memory table is stored on different nodes (data nodes or compute nodes) based on the global partitioning scheme. Each node can only hold one partition. Concurrent reads and writes are supported in a distributed in-memory table. Therefore, it is suitable for scenarios that require distributed computing on in-memory tables.\n\nA distributed in-memory table can be partitioned on 2 different levels:\n\n* global (across nodes): a distributed in-memory table is partitioned and the partitions are stored on different nodes. The number of global partitions must be greater than or equal to 2, but no greater than the total number of data nodes and compute nodes.\n\n* local (within node, optional): data within each node can be partitioned again. If both global and local partitioning are adopted, the partitioning scheme of the distributed in-memory table is equivalent to a composite domain.\n\n**Note**:\n\n* To access the distributed in-memory table from other nodes, use function [loadDistributedInMemoryTable](https://docs.dolphindb.com/en/Functions/l/loadDistributedInMemoryTable.html) first to load the table.\n* To drop a distributed in-memory table, use command [dropDistributedInMemoryTable](https://docs.dolphindb.com/en/Functions/d/dropDistributedInMemoryTable.html).\n* Transactions are not supported currently for distributed in-memory tables.\n\n#### Arguments\n\n**tableName** is a STRING scalar indicating the name of a distributed in-memory table.\n\n**colNames** is a STRING vector of column names.\n\n**colTypes** is a vector indicating data types of columns specified by *colNames*.\n\n**globalPartitionType** is a required parameter indicating the partition type for a table in a cluster, which only supports RANGE, HASG, VALUE, and LIST.\n\n**globalPartitionScheme** is a required parameter indicating the partitioning scheme that describes how the partitions are created in a cluster.\n\nThe partition type and partitioning scheme are shown as follows:\n\n| Partition Type | Partition Type Symbol | Partitioning Scheme                                                                                                 |\n| -------------- | --------------------- | ------------------------------------------------------------------------------------------------------------------- |\n| range domain   | RANGE                 | A vector. Any two adjacent elements of the vector define the range for a partition.                                 |\n| hash domain    | HASH                  | A tuple. The first element is the data type of partitioning column. The second element is the number of partitions. |\n| value domain   | VALUE                 | A vector. Each element of the vector defines a partition.                                                           |\n| list domain    | LIST                  | A vector. Each element of the vector defines a partition.                                                           |\n\n**globalPartitionColumn** is a required parameter. It is a STRING scalar indicating the partitioning column for a table in a cluster.\n\nThe above parameters are specified for a cluster. The distributed in-memory table is partitioned and the partitions are stored on each node based on the above partitioning schemes.\n\nThe data within each node can be partitioned again through the following parameters.\n\n**localPartitionType** (optional) indicates the partition type within a node, which only supports RANGE, HASG, VALUE, and LIST.\n\n**localPartitionScheme** (optional) indicates the partitioning scheme that describes how the partitions are created within a node.\n\n**localPartitionColumn** (optional) is a STRING scalar indicating the partitioning column within a node.\n\n#### Examples\n\nCreate a distributed in-memory table.\n\nThe cluster in this example has two data nodes: node1 and node2. Create a distributed in-memory table on node1. The number of partitions should be less than the total number of data nodes and compute nodes, thus HASH partitioning is recommended.\n\n```\npt = createDistributedInMemoryTable(`dt, `time`id`value, `DATETIME`INT`LONG, HASH, [INT, 2],`id)\n```\n\nLoad a distributed in-memory table on node2 and insert data into it.\n\n```\ntime = take(2021.08.20 00:00:00..2021.08.30 00:00:00, 40);\nid = 0..39;\nvalue = rand(100, 40);\ntmp = table(time, id, value);\n\npt = loadDistributedInMemoryTable(`dt)\npt.append!(tmp);\n\nselect * from pt;\n```\n\nCheck whether a distributed in-memory table exists.\n\n```\nobjs(true)\n```\n\nDelete a distributed in-memory table.\n\n```\ndropDistributedInMemoryTable(`dt)\n```\n"
    },
    "createDualOwnershipReactiveStateEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createDualOwnershipReactiveStateEngine.html",
        "signatures": [
            {
                "full": "createDualOwnershipReactiveStateEngine(name, metrics1, metrics2, dummyTable, outputTable, keyColumn1, keyColumn2, [snapshotDir], [snapshotIntervalInMsgCount], [keyPurgeFilter1], [keyPurgeFilter2], [keyPurgeFreqInSecond=0], [raftGroup], [outputHandler=NULL], [msgAsTable=false])",
                "name": "createDualOwnershipReactiveStateEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics1",
                        "name": "metrics1"
                    },
                    {
                        "full": "metrics2",
                        "name": "metrics2"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "keyColumn1",
                        "name": "keyColumn1"
                    },
                    {
                        "full": "keyColumn2",
                        "name": "keyColumn2"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFilter1]",
                        "name": "keyPurgeFilter1",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFilter2]",
                        "name": "keyPurgeFilter2",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSecond=0]",
                        "name": "keyPurgeFreqInSecond",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createDualOwnershipReactiveStateEngine](https://docs.dolphindb.com/en/Functions/c/createDualOwnershipReactiveStateEngine.html)\n\n\n\n#### Syntax\n\ncreateDualOwnershipReactiveStateEngine(name, metrics1, metrics2, dummyTable, outputTable, keyColumn1, keyColumn2, \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[keyPurgeFilter1], \\[keyPurgeFilter2], \\[keyPurgeFreqInSecond=0], \\[raftGroup], \\[outputHandler=NULL], \\[msgAsTable=false])\n\n#### Argument\n\nOnly the parameters of `createDualOwnershipReactiveStateEngine` and [createReactiveStateEngine](https://docs.dolphindb.com/en/Functions/c/createReactiveStateEngine.html) with different usages are explained here.\n\nFor data grouped by *keyColumn1*, they are calculated based on *metrics1* and purged based on *keyPurgeFilter1*; For data grouped by *keyColumn2*, they are calculated based on *metrics2* and purged based on *keyPurgeFilter2*.\n\n**outputTable** specifies the output table. It can be an in-memory table or a DFS table. Create an empty table and specify the names and data types of the columns before calling the function.\n\nThe output columns are in the following order:\n\n(1) The common columns of *keyColumn1* and *keyColumn2*;\n\n(2) Other columns of *keyColumn1* and *keyColumn2*;\n\n(3) The result columns of *metrics1* and *metrics2*.\n\n**outputHandler** (optional) is a unary function or a partial function with a single unfixed parameter. If set, the engine will not write the calculation results to the output table directly. Instead, the results will be passed as a parameter to the *outputHandler* function. The default value is NULL, which means the result will be written to the output table.\n\n**msgAsTable** (optional) is a Boolean scalar indicating whether the output data is passed into function (specified by *outputHandler*) as a table or as a tuple. If *msgAsTable*=true, the subscribed data is passed into function as a table. The default value is false, which means the output data is passed into function as a tuple of columns.\n\n#### Details\n\nThe dual-ownership reactive state streaming engine extends the functionality of the reactive state streaming engine with support for parallel computing on 2 groups with different metrics of a stream table. Compared to the cascade of reactive state streaming engines, this function has greatly improved the computing performance.\n\n**Note:** The output table is sorted in the same order as the input, i.e., *keepOrder* is only set to true in the engine.\n\n#### Examples\n\n```\nshare streamTable(1:0, `date`time`sym`market`price`qty, [DATE, TIME, SYMBOL, CHAR, DOUBLE, INT]) as trades\noutputTable = table(100:0, `date`sym`market`factor1`factor2, [DATE, SYMBOL, CHAR, DOUBLE, DOUBLE])\ndors = createDualOwnershipReactiveStateEngine(name=\"test\", metrics1=<mfirst(price, 3)>, metrics2=<mmax(price, 3)>, dummyTable=trades, outputTable=outputTable, keyColumn1=`date`sym, keyColumn2=`date`market)\ntmp = table(1:0, `date`time`sym`market`price`qty, [DATE, TIME, SYMBOL, CHAR, DOUBLE, INT])\nsubscribeTable(tableName=`trades, actionName=\"test\",msgAsTable=true, handler=tableInsert{dors})\ninsert into tmp values(2012.01.01, 09:00:00.030, `a, 'B', 10.65, 1500)\ninsert into tmp values(2012.01.01, 09:00:00.030, `a, 'B', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.031, `b, 'A', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.031, `a, 'B', 10.65, 1500)\ninsert into tmp values(2012.01.01, 09:00:00.031, `a, 'A', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.033, `b, 'B', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.033, `a, 'A', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.034, `b, 'A', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.034, `b, 'A', 10.22, 1200)\ninsert into tmp values(2012.01.01, 09:00:00.035, `a, 'A', 11.0, 2500)\ninsert into tmp values(2012.01.02, 09:00:00.031, `b, 'A', 10.22, 1200)\ninsert into tmp values(2012.01.02, 09:00:00.032, `a, 'B', 11.0, 2500)\ninsert into tmp values(2012.01.02, 09:00:00.032, `b, 'B', 15.6, 1300)\ninsert into tmp values(2012.01.02, 09:00:00.040, `c, 'B', 13.2, 2000)\ntrades.append!(tmp)\n\nselect * from outputTable\n```\n\n| date       | sym | market | factor1 | factor2 |\n| ---------- | --- | ------ | ------- | ------- |\n| 2012.01.01 | a   | 'B'    |         |         |\n| 2012.01.01 | a   | 'B'    |         |         |\n| 2012.01.01 | b   | 'A'    |         |         |\n| 2012.01.01 | a   | 'B'    | 10.65   | 10.65   |\n| 2012.01.01 | a   | 'A'    | 10.59   |         |\n| 2012.01.01 | b   | 'B'    |         | 10.65   |\n| 2012.01.01 | a   | 'A'    | 10.65   | 10.59   |\n| 2012.01.01 | b   | 'A'    | 10.59   | 10.59   |\n| 2012.01.01 | b   | 'A'    | 10.59   | 10.59   |\n| 2012.01.01 | a   | 'A'    | 10.59   | 11      |\n| 2012.01.02 | b   | 'A'    |         |         |\n| 2012.01.02 | a   | 'B'    |         |         |\n| 2012.01.02 | b   | 'B'    |         |         |\n| 2012.01.02 | c   | 'B'    |         | 15.6    |\n\n```\nunsubscribeTable(tableName=`trades, actionName=\"dors\")\nundef(`trades,SHARED)\ndropStreamEngine(\"dors\")\n```\n"
    },
    "createEqualJoinEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createEqualJoinEngine.html",
        "signatures": [
            {
                "full": "createEquiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, timeColumn, [garbageSize=5000], [maxDelayedTime])",
                "name": "createEquiJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[garbageSize=5000]",
                        "name": "garbageSize",
                        "optional": true,
                        "default": "5000"
                    },
                    {
                        "full": "[maxDelayedTime]",
                        "name": "maxDelayedTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createEqualJoinEngine](https://docs.dolphindb.com/en/Functions/c/createEqualJoinEngine.html)\n\nAlias for [createEquiJoinEngine](https://docs.dolphindb.com/en/Functions/c/createEquiJoinEngine.html)\n\n\nDocumentation for the `createEquiJoinEngine` function:\n### [createEquiJoinEngine](https://docs.dolphindb.com/en/Functions/c/createEquiJoinEngine.html)\n\n\n\n#### Syntax\n\ncreateEquiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, timeColumn, \\[garbageSize=5000], \\[maxDelayedTime])\n\nAlias: createEqualJoinEngine\n\n#### Details\n\nCreate an equi join streaming engine. Streams are ingested into the engine through left and right tables and joined on *matchingColumn* and *timeColumn*. Return a table object that is the equi join result of a left table and a right table. The result holds all records with matching values.\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n#### Calculation Rules\n\nWhen data is ingested into one table, the equi join streaming engine searches for records with matching values in the other table. If matches are found, the engine outputs the combined records with additional columns holding the calculation results of *metrics*.\n\n#### Arguments\n\nSome parameters of the equi join engine are the same as those of the asof join engine, please refer to the function [createAsofJoinEngine](https://docs.dolphindb.com/en/Functions/c/createAsofJoinEngine.html) for detailed information. The different parameters are described as below:\n\n**name** is a string indicating the name of the equi join streaming engine. It is the unique identifier of the engine on a data/compute node. It can contain letters, numbers and underscores and must start with a letter.\n\n**timeColumn** is a STRING scalar or vector indicating the time columns in the left table and the right table. The time columns in the left and right tables must have the same data type. When the two time columns have the same column name, *timeColumn* is a string scalar; otherwise, *timeColumn* is vector of two strings.\n\n**garbageSize** (optional) is a positive integer with the default value of 5,000 (in unit of rows). When the number of rows of historical data in memory exceeds the *garbageSize*, the system will remove the historical data that is not needed for the current calculation on the following conditions:\n\n* The historical data has already been joined and returned.\n\n* For historical data that has not been joined, if the timestamp difference between the historical data and the new arriving data in left/right table has exceeded the *maxDelayedTime*, it will also be discarded.\n\n**maxDelayedTime** (optional) is a positive integer with the default value of 3 (seconds), indicating the maximum time to keep cached data in the engine. This parameter only takes effect when the conditions described in *garbageSize* are met. It is not recommended to set the *maxDelayedTime* too small in case data got removed before it is joined.\n\n#### Examples\n\nExample 1.\n\n```\nshare streamTable(1:0, `time`sym`price, [SECOND, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [SECOND, SYMBOL, DOUBLE]) as rightTable\nshare table(100:0, `time`sym`price`val`total, [SECOND, SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\nejEngine=createEquiJoinEngine(\"test1\", leftTable, rightTable, output, [<price>, <val>, <price*val>], `sym, `time)\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{ejEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{ejEngine, false}, msgAsTable=true)\n\ntmp1=table(13:30:10+1..20 as time, take(`AAPL, 10) join take(`IBM, 10) as sym, double(1..20) as price)\nleftTable.append!(tmp1)\ntmp2=table(13:30:10+1..20 as time, take(`AAPL, 10) join take(`IBM, 10) as sym, double(50..31) as val)\nrightTable.append!(tmp2)\n\nselect count(*) from output\n// output\n20\n```\n\nExample 2. The type of the *timeColumn* is timestamp. The default value of *maxDelayedTime* is 3000ms (3s).\n\n```\nshare streamTable(5000000:0, `timestamp`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(5000000:0, `timestamp`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\nshare table(5000000:0, `timestamp`sym`price`val`total`diff`ratio, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as output\nejEngine=createEquiJoinEngine(\"test1\", leftTable, rightTable, output, <[price, val, price+val, price-val, price/val]>, `sym, `timestamp, 5000)\ntopic1=subscribeTable(tableName=\"leftTable\", actionName=\"writeLeft\", offset=0, handler=appendForJoin{ejEngine, true}, batchSize=10000, throttle=1)\ntopic2=subscribeTable(tableName=\"rightTable\", actionName=\"writeRight\", offset=0, handler=appendForJoin{ejEngine, false}, batchSize=10000, throttle=1)\ndef writeLeftTable(mutable tb){\n   batch = 1000\n   for(i in 1..300){\n           tmp = table(batch:batch, `timestamp`sym`price, [TIMESTAMP, SYMBOL, DOUBLE])\n           tmp[`timestamp]=take(2012.01.01T00:00:00.000+i, batch)\n           tmp[`sym]=shuffle(\"A\"+string(1..batch))\n           tmp[`price]=rand(100.0, batch)\n           tb.append!(tmp)\n   }\n}\n\ndef writeRightTable(mutable tb){\n   batch = 500\n   for(i in 1..200){\n           tmp = table(batch:batch, `timestamp`sym`val, [TIMESTAMP, SYMBOL, DOUBLE])\n           tmp[`timestamp]=take(2012.01.01T00:00:00.000+i, batch)\n           tmp[`sym]=shuffle(\"A\"+string(1..batch))\n           tmp[`val]=rand(100.0, batch)\n           tb.append!(tmp)\n   }\n}\n\njob1 = submitJob(\"writeLeft\", \"\", writeLeftTable, leftTable)\njob2 = submitJob(\"writeRight\", \"\", writeRightTable, rightTable)\n\nselect count(*) from output order by sym, timestamp\n// output\n100000\n```\n"
    },
    "createEquiJoinEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createEquiJoinEngine.html",
        "signatures": [
            {
                "full": "createEquiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, timeColumn, [garbageSize=5000], [maxDelayedTime])",
                "name": "createEquiJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[garbageSize=5000]",
                        "name": "garbageSize",
                        "optional": true,
                        "default": "5000"
                    },
                    {
                        "full": "[maxDelayedTime]",
                        "name": "maxDelayedTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createEquiJoinEngine](https://docs.dolphindb.com/en/Functions/c/createEquiJoinEngine.html)\n\n\n\n#### Syntax\n\ncreateEquiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, timeColumn, \\[garbageSize=5000], \\[maxDelayedTime])\n\nAlias: createEqualJoinEngine\n\n#### Details\n\nCreate an equi join streaming engine. Streams are ingested into the engine through left and right tables and joined on *matchingColumn* and *timeColumn*. Return a table object that is the equi join result of a left table and a right table. The result holds all records with matching values.\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n#### Calculation Rules\n\nWhen data is ingested into one table, the equi join streaming engine searches for records with matching values in the other table. If matches are found, the engine outputs the combined records with additional columns holding the calculation results of *metrics*.\n\n#### Arguments\n\nSome parameters of the equi join engine are the same as those of the asof join engine, please refer to the function [createAsofJoinEngine](https://docs.dolphindb.com/en/Functions/c/createAsofJoinEngine.html) for detailed information. The different parameters are described as below:\n\n**name** is a string indicating the name of the equi join streaming engine. It is the unique identifier of the engine on a data/compute node. It can contain letters, numbers and underscores and must start with a letter.\n\n**timeColumn** is a STRING scalar or vector indicating the time columns in the left table and the right table. The time columns in the left and right tables must have the same data type. When the two time columns have the same column name, *timeColumn* is a string scalar; otherwise, *timeColumn* is vector of two strings.\n\n**garbageSize** (optional) is a positive integer with the default value of 5,000 (in unit of rows). When the number of rows of historical data in memory exceeds the *garbageSize*, the system will remove the historical data that is not needed for the current calculation on the following conditions:\n\n* The historical data has already been joined and returned.\n\n* For historical data that has not been joined, if the timestamp difference between the historical data and the new arriving data in left/right table has exceeded the *maxDelayedTime*, it will also be discarded.\n\n**maxDelayedTime** (optional) is a positive integer with the default value of 3 (seconds), indicating the maximum time to keep cached data in the engine. This parameter only takes effect when the conditions described in *garbageSize* are met. It is not recommended to set the *maxDelayedTime* too small in case data got removed before it is joined.\n\n#### Examples\n\nExample 1.\n\n```\nshare streamTable(1:0, `time`sym`price, [SECOND, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [SECOND, SYMBOL, DOUBLE]) as rightTable\nshare table(100:0, `time`sym`price`val`total, [SECOND, SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\nejEngine=createEquiJoinEngine(\"test1\", leftTable, rightTable, output, [<price>, <val>, <price*val>], `sym, `time)\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{ejEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{ejEngine, false}, msgAsTable=true)\n\ntmp1=table(13:30:10+1..20 as time, take(`AAPL, 10) join take(`IBM, 10) as sym, double(1..20) as price)\nleftTable.append!(tmp1)\ntmp2=table(13:30:10+1..20 as time, take(`AAPL, 10) join take(`IBM, 10) as sym, double(50..31) as val)\nrightTable.append!(tmp2)\n\nselect count(*) from output\n// output\n20\n```\n\nExample 2. The type of the *timeColumn* is timestamp. The default value of *maxDelayedTime* is 3000ms (3s).\n\n```\nshare streamTable(5000000:0, `timestamp`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(5000000:0, `timestamp`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\nshare table(5000000:0, `timestamp`sym`price`val`total`diff`ratio, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as output\nejEngine=createEquiJoinEngine(\"test1\", leftTable, rightTable, output, <[price, val, price+val, price-val, price/val]>, `sym, `timestamp, 5000)\ntopic1=subscribeTable(tableName=\"leftTable\", actionName=\"writeLeft\", offset=0, handler=appendForJoin{ejEngine, true}, batchSize=10000, throttle=1)\ntopic2=subscribeTable(tableName=\"rightTable\", actionName=\"writeRight\", offset=0, handler=appendForJoin{ejEngine, false}, batchSize=10000, throttle=1)\ndef writeLeftTable(mutable tb){\n   batch = 1000\n   for(i in 1..300){\n           tmp = table(batch:batch, `timestamp`sym`price, [TIMESTAMP, SYMBOL, DOUBLE])\n           tmp[`timestamp]=take(2012.01.01T00:00:00.000+i, batch)\n           tmp[`sym]=shuffle(\"A\"+string(1..batch))\n           tmp[`price]=rand(100.0, batch)\n           tb.append!(tmp)\n   }\n}\n\ndef writeRightTable(mutable tb){\n   batch = 500\n   for(i in 1..200){\n           tmp = table(batch:batch, `timestamp`sym`val, [TIMESTAMP, SYMBOL, DOUBLE])\n           tmp[`timestamp]=take(2012.01.01T00:00:00.000+i, batch)\n           tmp[`sym]=shuffle(\"A\"+string(1..batch))\n           tmp[`val]=rand(100.0, batch)\n           tb.append!(tmp)\n   }\n}\n\njob1 = submitJob(\"writeLeft\", \"\", writeLeftTable, leftTable)\njob2 = submitJob(\"writeRight\", \"\", writeRightTable, rightTable)\n\nselect count(*) from output order by sym, timestamp\n// output\n100000\n```\n"
    },
    "createGPLearnEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createGPLearnEngine.html",
        "signatures": [
            {
                "full": "createGPLearnEngine(trainData, targetData,[groupCol=''], [populationSize=1000], [generations=20], [tournamentSize=20], [stoppingCriteria=0.0], [constRange], [windowRange], [initDepth], [initMethod='half'], [initProgram=''], [functionSet], [maxSamples=1.0], [fitnessFunc='mse'], [parsimonyCoefficient=0.001], [crossoverMutationProb=0.9], [subtreeMutationProb=0.01], [hoistMutationProb=0.01], [pointMutationProb=0.01], [eliteCount =0], [restrictDepth=false], [deviceId=0], [seed], [verbose=true], [minimize=true], [useAbsFit=true])",
                "name": "createGPLearnEngine",
                "parameters": [
                    {
                        "full": "trainData",
                        "name": "trainData"
                    },
                    {
                        "full": "targetData",
                        "name": "targetData"
                    },
                    {
                        "full": "[groupCol='']",
                        "name": "groupCol",
                        "optional": true,
                        "default": "''"
                    },
                    {
                        "full": "[populationSize=1000]",
                        "name": "populationSize",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[generations=20]",
                        "name": "generations",
                        "optional": true,
                        "default": "20"
                    },
                    {
                        "full": "[tournamentSize=20]",
                        "name": "tournamentSize",
                        "optional": true,
                        "default": "20"
                    },
                    {
                        "full": "[stoppingCriteria=0.0]",
                        "name": "stoppingCriteria",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[constRange]",
                        "name": "constRange",
                        "optional": true
                    },
                    {
                        "full": "[windowRange]",
                        "name": "windowRange",
                        "optional": true
                    },
                    {
                        "full": "[initDepth]",
                        "name": "initDepth",
                        "optional": true
                    },
                    {
                        "full": "[initMethod='half']",
                        "name": "initMethod",
                        "optional": true,
                        "default": "'half'"
                    },
                    {
                        "full": "[initProgram='']",
                        "name": "initProgram",
                        "optional": true,
                        "default": "''"
                    },
                    {
                        "full": "[functionSet]",
                        "name": "functionSet",
                        "optional": true
                    },
                    {
                        "full": "[maxSamples=1.0]",
                        "name": "maxSamples",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[fitnessFunc='mse']",
                        "name": "fitnessFunc",
                        "optional": true,
                        "default": "'mse'"
                    },
                    {
                        "full": "[parsimonyCoefficient=0.001]",
                        "name": "parsimonyCoefficient",
                        "optional": true,
                        "default": "0.001"
                    },
                    {
                        "full": "[crossoverMutationProb=0.9]",
                        "name": "crossoverMutationProb",
                        "optional": true,
                        "default": "0.9"
                    },
                    {
                        "full": "[subtreeMutationProb=0.01]",
                        "name": "subtreeMutationProb",
                        "optional": true,
                        "default": "0.01"
                    },
                    {
                        "full": "[hoistMutationProb=0.01]",
                        "name": "hoistMutationProb",
                        "optional": true,
                        "default": "0.01"
                    },
                    {
                        "full": "[pointMutationProb=0.01]",
                        "name": "pointMutationProb",
                        "optional": true,
                        "default": "0.01"
                    },
                    {
                        "full": "[eliteCount =0]",
                        "name": "[eliteCount =0]"
                    },
                    {
                        "full": "[restrictDepth=false]",
                        "name": "restrictDepth",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[deviceId=0]",
                        "name": "deviceId",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[seed]",
                        "name": "seed",
                        "optional": true
                    },
                    {
                        "full": "[verbose=true]",
                        "name": "verbose",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[minimize=true]",
                        "name": "minimize",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[useAbsFit=true]",
                        "name": "useAbsFit",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [createGPLearnEngine](https://docs.dolphindb.com/en/Functions/c/createGPLearnEngine.html)\n\n**Note:** This function is not supported by Community Edition. You can [get a trial](https://dolphindb.com/product#downloads-down) of Shark from DolphinDB official website.\n\n#### Syntax\n\ncreateGPLearnEngine(trainData, targetData,\\[groupCol=''], \\[populationSize=1000], \\[generations=20], \\[tournamentSize=20], \\[stoppingCriteria=0.0], \\[constRange], \\[windowRange], \\[initDepth], \\[initMethod='half'], \\[initProgram=''], \\[functionSet], \\[maxSamples=1.0], \\[fitnessFunc='mse'], \\[parsimonyCoefficient=0.001], \\[crossoverMutationProb=0.9], \\[subtreeMutationProb=0.01], \\[hoistMutationProb=0.01], \\[pointMutationProb=0.01], \\[eliteCount =0], \\[restrictDepth=false], \\[deviceId=0], \\[seed], \\[verbose=true], \\[minimize=true], \\[useAbsFit=true])\n\n#### Details\n\nCreate a GPLearn engine for training and predicting with symbolic regression.\n\n#### Arguments\n\n* **trainData** is a table where all columns are of FLOAT or DOUBLE type, indicating the training data.\n* **targetData**is a vector of the same type as *trainData*, indicating the target data to be predicted.\n* **groupCol** (optional) is a STRING scalar or vector, indicating the name of grouping column based on which grouped calculation is performed. The default value is NULL, meaning no grouping column is specified. Note that the *groupCol*values are ignored in calculation.\n* **populationSize** (optional) is an integer indicating the generation size (i.e., the number of programs) for each generation. The default value is 1000.\n* **generations** (optional) is an integer indicating the number of generations (iterations) to evolve. The default value is 20.\n* **tournamentSize** (optional) is an integer indicating the number of programs that will compete to become part of the next generation. The default value is 20.\n* **stoppingCriteria** (optional) is a floating-point scalar, indicating the required criteria for the fitness. Evolution will be ended early if fitness is smaller than *stoppingCriteria*. The default value is 0, indicating the evolution will only end when the number of iterations reaches *generations*.\n* **constRange** (optional) can be 0 or 2-element floating-point vector, specifying the range of constants included in the programs. The default is \\[-1.0, 1.0].\n  * 0 means no constants will be included in the candidate programs.\n  * For a vector, its 2 elements specify the left and right boundaries (closed) for the range.\n* **windowRange** (optional) is an integral vector from which a random value is taken as the sliding window size. The default value is \\[2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 30, 7, 14, 21, 48, 35, 42].\n* **initDepth** (optional) is a 2-element integral vector, indicating the range of tree depths for the initial population of naive formulas. The default value is \\[2, 6].\n* **initMethod** (optional) is a string indicating the initialization method. It can be:\n  * grow: Nodes are chosen at random from functions, constants and variables.\n  * full: Functions are chosen until the *initDepth*is reached, and then terminals are selected.\n  * half (default): Trees are grown through a 50/50 mix of 'full' and 'grow'.\n* **initProgram**(optional) is metacode or a tuple of metacode. The default value is NULL. This parameter is used to initialize the population. For example, `<mavg(price, 10)>`, where `mavg` is a built-in function, and price is a column from *trainData*.\n* **functionSet** (optional) is a STRING vector specifying the functions used when building and evolving programs. The default value is NULL, indicating all functions can be used. See appendix for the available functions.\n* **maxSamples** (optional) is a floating-point number in \\[0,1] indicating the fraction of samples involved in *fitnessFunc*. The default value is 1.0.\n* **fitnessFunc**(optional) is a FUNCTIONDEF or STRING scalar indicating the fitness function. It can be:\n  * 'mse' (default): mean squared error.\n  * 'rmse': root mean squared error.\n  * 'mae': mean absolute error.\n  * 'pearson': Pearson's product-moment correlation coefficient.\n  * 'spearmanr': Spearman's rank-order correlation coefficient.\n* **parsimonyCoefficient** (optional) is a floating-point number indicating the parsimony coefficient. This constant penalizes large programs by adjusting their fitness to be less favorable for selection. The default value is 0.0.\n* **crossoverMutationProb** (optional) is a floating-point number indicating the probability of performing crossover on a tournament winner. The default value is 0.9.\n* **subtreeMutationProb** (optional) is a floating-point number indicating the probability of performing subtree mutation on a tournament winner. The default value is 0.01.\n* **hoistMutationProb**(optional) is a floating-point number indicating the probability of performing hoist mutation on a tournament winner. The default value is 0.01.\n* **pointMutationProb**(optional) is a floating-point number indicating the probability of performing point mutation on a tournament winner. The default value is 0.01.\n* **useAbsFit**(optional) is a boolean value that determines if absolute values are used in fitness calculations for correlation-based fitness functions, i.e., *fitnessFunc* = 'pearson', 'spearmanr', or `corr`. The default value is true.\n\n**Note:** The above genetic operation probabilities must sum to no greater than 1.\n\n* **eliteCount** (optional) is an INT scalar indicating the number of elites to be preserved. A number of *eliteCount*programs with better fitness will be preserved to the next generation without mutation.\n\n* **restrictDepth**(optional) is a Boolean scalar specifying whether to strictly limit the program length to *initDepth*. The default value is false.\n\n* **deviceId** (optional) is an INT scalar or vector specifying the device ID to be used. The default value is 0.\n\n* **seed** (optional) is an integer indicating the seed used for training.\n\n* **verbose**(optional) is a Boolean scalar indicating whether to output the training information. The default value is true.\n\n* **minimize**(optional) is a Boolean scalar indicating whether to minimize or maximize the fitness score. The default value is true, i.e., a smaller score means better fitness.\n\n#### Examples\n\nSee [Quick Start Guide for Shark GPLearn](https://docs.dolphindb.com/en/Tutorials/gplearn_qsg.html)\n\n\n\n#### Appendix\n\nThe following table lists available functions for building and evolving programs. The parameter *n* indicates the sliding window size taken from *windowRange*. For all m-functions, if the current window is smaller than *n*, 0 is returned.\n\n| Function        | Number of Inputs | Description                                                                                    |\n| --------------- | ---------------- | ---------------------------------------------------------------------------------------------- |\n| add(x,y)        | 2                | Addition                                                                                       |\n| sub(x,y)        | 2                | Subtraction                                                                                    |\n| mul(x,y)        | 2                | Multiplication                                                                                 |\n| div(x,y)        | 2                | Division, returns 1 if the absolute value of the divisor is less than 0.001                    |\n| max(x,y)        | 2                | Maximum value                                                                                  |\n| min(x,y)        | 2                | Minimum value                                                                                  |\n| sqrt(x)         | 1                | Square root based on absolute value                                                            |\n| log(x)          | 1                | If x < 0.001, returns 0, otherwise returns log(abs(x))                                         |\n| neg(x)          | 1                | Negation                                                                                       |\n| reciprocal(x)   | 1                | Reciprocal, returns 0 if the absolute value of x is less than 0.001                            |\n| abs(x)          | 1                | Absolute value                                                                                 |\n| sin(x)          | 1                | Sine function                                                                                  |\n| cos(x)          | 1                | Cosine function                                                                                |\n| tan(x)          | 1                | Tangent function                                                                               |\n| sig(x)          | 1                | Sigmoid function                                                                               |\n| mdiff(x, n)     | 1                | n-th order difference of x                                                                     |\n| mcovar(x, y, n) | 2                | Covariance of x and y with a sliding window of size n                                          |\n| mcorr(x, y, n)  | 2                | Correlation of x and y with a sliding window of size n                                         |\n| mstd(x, n)      | 1                | Sample standard deviation of x with a sliding window of size n                                 |\n| mmax(x, n)      | 1                | Maximum value of x with a sliding window of size n                                             |\n| mmin(x, n)      | 1                | Minimum value of x with a sliding window of size n                                             |\n| msum(x, n)      | 1                | Sum of x with a sliding window of size n                                                       |\n| mavg(x, n)      | 1                | Average of x with a sliding window of size n                                                   |\n| mprod(x, n)     | 1                | Product of x with a sliding window of size n                                                   |\n| mvar(x, n)      | 1                | Sample variance of x with a sliding window of size n                                           |\n| mvarp(x, n)     | 1                | Population variance of x with a sliding window of size n                                       |\n| mstdp(x, n)     | 1                | Population standard deviation of x with a sliding window of size n                             |\n| mimin(x, n)     | 1                | Index of the minimum value of x with a sliding window of size n                                |\n| mimax(x, n)     | 1                | Index of the maximum value of x with a sliding window of size n                                |\n| mbeta(x, y, n)  | 2                | Least squares estimate of the regression coefficient of x on y with a sliding window of size n |\n| mwsum(x, y, n)  | 2                | Inner product of x and y with a sliding window of size n                                       |\n| mwavg(x, y, n)  | 2                | Weighted average of x using y as weights with a sliding window of size n                       |\n"
    },
    "createGroup": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createGroup.html",
        "signatures": [
            {
                "full": "createGroup(groupId, [userIds])",
                "name": "createGroup",
                "parameters": [
                    {
                        "full": "groupId",
                        "name": "groupId"
                    },
                    {
                        "full": "[userIds]",
                        "name": "userIds",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createGroup](https://docs.dolphindb.com/en/Functions/c/createGroup.html)\n\n\n\n#### Syntax\n\ncreateGroup(groupId, \\[userIds])\n\n#### Arguments\n\n**groupId** is a string indicating a group name.\n\n**userId** (optional) is a STRING scalar/vector indicating the user names of the group members.\n\n#### Details\n\nCreate a group of users. It can only be executed by an administrator.\n\nThe users specified by *userIds* must have been created with [createUser](https://docs.dolphindb.com/en/Functions/c/createUser.html).\n\n#### Examples\n\nCreate a group \"production\", and add a user with user name \"JohnSmith\".\n\n```\ncreateGroup(`production, `JohnSmith);\n```\n"
    },
    "createIMOLTPTable": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createIMOLTPTable.html",
        "signatures": [
            {
                "full": "createIMOLTPTable(dbHandle, table, tableName, primaryKey, [secondaryKey], [uniqueFlag])",
                "name": "createIMOLTPTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "primaryKey",
                        "name": "primaryKey"
                    },
                    {
                        "full": "[secondaryKey]",
                        "name": "secondaryKey",
                        "optional": true
                    },
                    {
                        "full": "[uniqueFlag]",
                        "name": "uniqueFlag",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createIMOLTPTable](https://docs.dolphindb.com/en/Functions/c/createIMOLTPTable.html)\n\n#### Syntax\n\ncreateIMOLTPTable(dbHandle, table, tableName, primaryKey, \\[secondaryKey], \\[uniqueFlag])\n\n#### Details\n\nCreate a table in an IMOLTP database.\n\n#### Arguments\n\n**dbHandle** is a database handle returned by the database function.\n\n**table** is a table object whose schema is used to define the schema for the new table in an IMOLTP database.\n\n**tableName** is a STRING scalar indicating the table name.\n\n**primaryKey** is a STRING scalar or vector that specifies the primary key column(s).\n\n**secondaryKey** (optional) is a STRING scalar or vector that specifies the secondary key column(s).\n\n**uniqueFlag**(optional) is a Boolean scalar or vector, indicating whether each secondary key is unique. When *uniqueFlag* is a vector, the size of *secondaryKey* and *uniqueFlag* must be the same.\n\n#### Examples\n\nFirst, create a table in an IMOLTP database.\n\n```\ndbName = \"oltp://test_imoltp\"\ndb = database(directory=dbName, partitionType=VALUE, partitionScheme=1..100, engine=\"IMOLTP\")\n```\n\n(1) Create a table \"test\\_table\\_1\" in an IMOLTP database and define a primary key on the column \"id\".\n\n```\npt1 = createIMOLTPTable(\n    dbHandle=db,\n    table=table(1:0, [\"id\", \"val1\", \"val2\", \"sym\"], [LONG, INT, LONG, STRING]),\n    tableName=\"test_table_1\",\n    primaryKey=`id\n)\n```\n\n(2) Create a table \"test\\_table\\_2\" in an IMOLTP database. Define a primary key on columns \"id\" and \"sym\" and unique secondary keys on \"val2\" and \"sym\".\n\n```\npt2 = createIMOLTPTable(\n    dbHandle=db,\n    table=table(1:0, [\"id\", \"val1\", \"val2\", \"sym\"], [LONG, INT, LONG, STRING]),\n    tableName=\"test_table_2\",\n    primaryKey=`id`sym,\n    secondaryKey=`val2`sym,\n    uniqueFlag=true\n)\n```\n\n(3) Create a table \"test\\_table\\_3\" in an IMOLTP database. Define a primary key on the column \"id\", non-unique secondary key on \"val1\" and unique secondary key on \"sym\".\n\n```\npt3 = createIMOLTPTable(\n    dbHandle=db,\n    table=table(1:0, [\"id\", \"val1\", \"val2\", \"sym\"], [LONG, INT, LONG, STRING]),\n    tableName=\"test_table_3\",\n    primaryKey=`id,\n    secondaryKey=`val1`sym,\n    uniqueFlag=[false, true]\n)\n```\n\n"
    },
    "createIPCInMemoryTable": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createIPCInMemoryTable.html",
        "signatures": [
            {
                "full": "createIPCInMemoryTable(size, tableName, columnNames, columnTypes)",
                "name": "createIPCInMemoryTable",
                "parameters": [
                    {
                        "full": "size",
                        "name": "size"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "columnNames",
                        "name": "columnNames"
                    },
                    {
                        "full": "columnTypes",
                        "name": "columnTypes"
                    }
                ]
            }
        ],
        "markdown": "### [createIPCInMemoryTable](https://docs.dolphindb.com/en/Functions/c/createIPCInMemoryTable.html)\n\n\n\n#### Syntax\n\ncreateIPCInMemoryTable(size, tableName, columnNames, columnTypes)\n\n#### Arguments\n\n**size** is an integer indicating the number of records that can be cached. The specified size must be greater than 1,000,000.\n\n**tableName** is a string indicating the name of inter-process communication (IPC) in-memory table to be created.\n\n**columnNames** is a STRING vector of column names.\n\n**columnTypes** is a vector indicating data types of columns specified by *columnNames*.\n\n#### Details\n\nCreate a handle to inter-process communication (IPC) in-memory table. IPC in-memory tables are often used as output tables for streaming. In scenarios with extremely high latency requirements, user processes can directly access shared memory to obtain data through APIs, which greatly reduces the latency of network transmissions such as TCP.\n\nAn IPC in-memory table communicates between processes through shared memory (managed by the operating system). The shared table only supports sharing within the same physical server.\n\nRead/write is supported by the IPC in-memory table, whereas its schema cannot be changed. Writing to an IPC in-memory table is done in the same way as to a regular in-memory table. If the amount of data inserted at one time exceedes shared memory, an exception will be thrown.\n\n* Read/write mechanism: The process that writes to the shared memory is regarded as the producer, and the process that reads data from the shared memory as the consumer. Data written in the same batch is consumed (read) as a whole, and the batches are consumed in the same order as they are written. For example, if 100 records are written for the first time, and 200 records for the second time, the 100 records will be read first, 200 records of the second batch will be read next, and so on. The reading process will be blocked if all data in the shared table has been consumed, and will resume when new consumable data arrives.\n\nThe DolphinDB system allows processes to concurrently write to the memory, or to read and write at the same time. Note that there can only be one reading process at a time. As explained earlier, reading to the IPC in-memory table is an one-off operation. Concurrent reads will obtain the data written in different batches.\n\n**Note:** This function can only be used on Linux.\n\n#### Examples\n\nCreate an IPC in-memory table that serves as the output table for subscription.\n\n```\nshare streamTable(10000:0,`timestamp`temperature, [TIMESTAMP,DOUBLE]) as pubTable\nipc_t = createIPCInMemoryTable(1000000, \"ipc_table\", `timestamp`temperature, [TIMESTAMP, DOUBLE])\ndef shm_append(mutable table, msg) {\n   table.append!(msg)\n}\nsubscribeTable(tableName=\"pubTable\", actionName=\"act3\", offset=0, handler=shm_append{ipc_t}, msgAsTable=true)\n// data input\n\nn = 200\ntimestamp = 2022.01.01T09:00:00.000 + 1..n\ntemp = 30 + rand(5.0,n)\n\ntableInsert(pubTable,timestamp,temp)\n```\n\nRelated functions: [dropIPCInMemoryTable](https://docs.dolphindb.com/en/Functions/d/dropIPCInMemoryTable.html), [loadIPCInMemoryTable](https://docs.dolphindb.com/en/Functions/l/loadIPCInMemoryTable.html)\n"
    },
    "createLeftSemiJoinEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createLeftSemiJoinEngine.html",
        "signatures": [
            {
                "full": "createLeftSemiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, [garbageSize=5000], [updateRightTable=false])",
                "name": "createLeftSemiJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "[garbageSize=5000]",
                        "name": "garbageSize",
                        "optional": true,
                        "default": "5000"
                    },
                    {
                        "full": "[updateRightTable=false]",
                        "name": "updateRightTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createLeftSemiJoinEngine](https://docs.dolphindb.com/en/Functions/c/createLeftSemiJoinEngine.html)\n\n\n\n#### Syntax\n\ncreateLeftSemiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, \\[garbageSize=5000], \\[updateRightTable=false])\n\n#### Details\n\nCreate a left semi join engine. For each record from the left table, the left semi join engine finds the matching records from the right table, and returns a table of its joining result. Unmatched records will not be returned.\n\nIf an incoming record has the identical *matchingColumn* of an existing record in the right table, only the first/latest record (determined by parameter *updateRightTable*) is kept.\n\nNote: Only one record with the indentical *matchingColumn* is kept by the engine in the right table, and data in the right table will not be removed from memory. Therefore, a large number of distinct values of *matchingColumn* should be avoided, otherwise an OOM problem may occur.\n\nFor more details of streaming engines, refer to [streamingEngine](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n#### Arguments\n\n**name** is a string indicating the name of the left semi join engine. It is the unique identifier of the engine on a data/compute node. It can contain letters, numbers and underscores and must start with a letter.\n\n**leftTable** is a table object whose schema must be the same as the stream table to which the engine subscribes. It does not matter whether the table contains data or not. Since version 2.00.11, array vectors are allowed for *leftTable*.\n\n**rightTable** is a table object whose schema must be the same as the stream table to which the engine subscribes. It does not matter whether the table contains data or not. Since version 2.00.11, array vectors are allowed for *RightTable*.\n\n**outputTable** is a table object to hold the calculation results. Create an empty table and specify the column names and types before calling the function. Since version 2.00.11, array vectors are allowed for *outputTable.* With the result column being an array vector column, user-defined aggregate functions can be used to output the results in the form of an array vector.\n\nThe columns of *outputTable* are in the following order:\n\n(1) The first column(s) are the column(s) on which the tables are joined, arranged in the same order as specified in *matchingColumn*.\n\n(2) Then followed by the calculation results of *metrics*. There can be one or multiple columns.\n\n**metrics** is metacode (can be a tuple) specifying the calculation formulas. For more information about metacode, refer to [Metaprogramming](https://test.dolphindb.cn/en/Programming/Metaprogramming/MetacodeWithFunction.html).\n\n* *metrics* can use one or more expressions, built-in or user-defined functions (but not aggregate functions), or a constant scalar/vector. Note that the output column for a constant vector must be in array vector form.\n\n* *metrics* can be functions that return multiple values and the columns in the output table to hold the return values must be specified. For example, \\<func(price) as \\`col1\\`col2>.\n\nTo specify a column that exists in both the left and the right tables, use the format *tableName.colName*. By default, the column from the left table is used.\n\n**Note**: The column names specified in *metrics* are not case-sensitive and can be inconsistent with the column names of the input tables.\n\n**matchingColumn** is a STRING scaler/vector/tuple indicating the column(s) on which the tables are joined. It supports integral, temporal or literal (except UUID) types.\n\n* When there is only 1 column to match - If the names of the columns to match are the same in both tables, *matchingColumn* should be specified as a STRING scalar; otherwise it's a tuple of two elements. For example, if the column is named \"sym\" in the left table and \"sym1\" in the right table, then *matchingColumn* = \\[\\[\\`sym],\\[\\`sym1]].\n* When there are multiple columns to match - If both tables share the names of all columns to match, *matchingColumn* is a STRING vector; otherwise it's a tuple of two elements. For example, if the columns are named \"timestamp\" and \"sym\" in the left table, whereas in the right table they're named \"timestamp\" and \"sym1\", then *matchingColumn* = \\[\\[\\`timestamp, \\`sym], \\[\\`timestamp,\\`sym1]].\n\n**garbageSize** (optional) is a positive integer. The default value is 5,000. Unlike other join engines, the *garbageSize* parameter for left semi join engine is only used to remove the historical data from the left table. The system will clear the data from the left table when the number of joined records exceeds *garbageSize*.\n\n**updateRightTable** (optional) is a Boolean value indicating whether to output the first record (*updateRightTable* = true) or the latest record (*updateRightTable* = false) when there are more than one matching records in the right table. The default value is false.\n\n#### Examples\n\n```\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym1`vol, [TIMESTAMP, SYMBOL, INT]) as rightTable\nshare table(100:0, `time`sym`price`vol`total, [TIMESTAMP, SYMBOL, DOUBLE, INT, DOUBLE]) as output\nlsjEngine=createLeftSemiJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output,  metrics=<[price, vol,price*vol]>, matchingColumn=[[`time,`sym], [`time,`sym1]], updateRightTable=true)\n\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{lsjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{lsjEngine, false}, msgAsTable=true)\n\nv = [1, 5, 10, 15]\ntp1=table(2012.01.01T00:00:00.000+v as time, take(`AAPL, 4) as sym, rand(100,4) as price)\nleftTable.append!(tp1)\n\nv = [1, 1, 3, 4, 5, 5, 5, 15]\ntp2=table(2012.01.01T00:00:00.000+v as time, take(`AAPL, 8) as sym, rand(100,8) as vol)\nrightTable.append!(tp2)\n\nselect * from output\n```\n\n| time                    | sym  | price | vol | total |\n| ----------------------- | ---- | ----- | --- | ----- |\n| 2012.01.01T00:00:00.001 | AAPL | 44    | 76  | 3344  |\n| 2012.01.01T00:00:00.005 | AAPL | 15    | 64  | 960   |\n| 2012.01.01T00:00:00.015 | AAPL | 24    | 75  | 1800  |\n\nTo execute the above script again, delete the engine and unsubscribe:\n\n```\ndropStreamEngine(\"test1\")\nlsjEngine=NULL\nunsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\")\nunsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\")\n```\n"
    },
    "createLookupJoinEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createLookupJoinEngine.html",
        "signatures": [
            {
                "full": "createLookupJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, [rightTimeColumn], [checkTimes], [outputElapsedMicroseconds=false], [keepDuplicates=false])",
                "name": "createLookupJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "[rightTimeColumn]",
                        "name": "rightTimeColumn",
                        "optional": true
                    },
                    {
                        "full": "[checkTimes]",
                        "name": "checkTimes",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keepDuplicates=false]",
                        "name": "keepDuplicates",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createLookupJoinEngine](https://docs.dolphindb.com/en/Functions/c/createLookupJoinEngine.html)\n\n\n\n#### Syntax\n\ncreateLookupJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, \\[rightTimeColumn], \\[checkTimes], \\[outputElapsedMicroseconds=false], \\[keepDuplicates=false])\n\n#### Details\n\nCreate a lookup join streaming engine. The engine left joins two stream tables, or a stream table and a non-stream table (refreshed regularly), on *matchingColumn*. Use this engine when the right table has infrequent updates (e.g., a dimension table with intraday indicators).\n\nNote:\n\nA left join is triggered only when new data is ingested to the left table.\n\nData in the right table is grouped by *matchingColumn*. When *keepDuplicates* = false, only the latest record in each group is kept by the engine. When *keepDuplicates* = true, all records in each group are kept.\n\n* If the right table is a stream table, the data in each group will be updated as new data is ingested into the right table;\n\n* If the right table is an in-memory table, dimension table or SQL metacode, the system refreshes the right table at regular intervals as specified by *checkTimes*.\n\nThe lookup join engine and the asof join engine are different in the following aspects:\n\n* For the asof join engine, the first column of its output table is always the time column. There is no such restriction with the lookup join engine.\n\n* With the lookup join engine, a join is triggered as soon as a new record is ingested into the left table. With the asof join engine, when the *timeColumn* is specified, there can be a delay before a record in the left table is joined.\n\nNote the difference between the lookup join engine and the left-semi join engine: with the left semi join engine, there will be no return until a match in the right table is found.\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n#### Arguments\n\n**name** is a string indicating the name of the lookup join engine. It is the unique identifier of the engine on a data/compute node. It can contain letters, numbers and underscores and must start with a letter.\n\n**leftTable** is a table object whose schema must be the same as the stream table to which the engine subscribes.\n\n**rightTable** is a table object. It can be an in-memory table, stream table, dimension table, or SQL metacode that returns a table. For regularly-updated *rightTable* that is not subscribed to, *checkTimes* must be specified for timed data refreshing.\n\n**outputTable** is a table object to hold the calculation results. Create an empty table and specify the column names and types before calling the function.\n\nThe columns of *outputTable* are in the following order:\n\n(1) The first column(s) are the column(s) on which the tables are joined, arranged in the same order as specified in *matchingColumn*.\n\n(2) Then followed by the calculation results of *metrics*.\n\n(3) If the *outputElapsedMicroseconds* is set to true, specify two more columns: a LONG column and an INT column.\n\n**metrics** is metacode (can be a tuple) specifying the calculation formulas. For more information about metacode, refer to [Metaprogramming](https://test.dolphindb.cn/en/Programming/Metaprogramming/MetacodeWithFunction.html).\n\n* *metrics* can use one or more expressions, built-in or user-defined functions (but not aggregate functions), or a constant scalar/vector. Note that the output column for a constant vector must be in array vector form.\n\n* *metrics* can be functions that return multiple values and the columns in the output table to hold the return values must be specified. For example, \\<func(price) as `col1`col2>.\n\nTo specify a column that exists in both the left and the right tables, use the format *tableName.colName*. By default, the column from the left table is used.\n\n**Note**: The column names specified in *metrics* are not case-sensitive and can be inconsistent with the column names of the input tables.\n\n**matchingColumn** is a STRING scaler/vector/tuple indicating the column(s) on which the tables are joined. It supports integral, temporal or literal (except UUID) types.\n\n* When there is only 1 column to match - If the names of the columns to match are the same in both tables, *matchingColumn* should be specified as a STRING scalar; otherwise it's a tuple of two elements. For example, if the column is named \"sym\" in the left table and \"sym1\" in the right table, then *matchingColumn* = \\[\\[\\`sym],\\[\\`sym1]].\n\n* When there are multiple columns to match - If both tables share the names of all columns to match, *matchingColumn* is a STRING vector; otherwise it's a tuple of two elements. For example, if the columns are named \"timestamp\" and \"sym\" in the left table, whereas in the right table they're named \"timestamp\" and \"sym1\", then *matchingColumn* = \\[\\[\\`timestamp, \\`sym], \\[\\`timestamp,\\`sym1]].\n\n**rightTimeColumn** (optional) is a STRING scalar indicating the time column in the right table. If the parameter is specified, the right table will keep the record with the latest timestamp. If there are multiple records with identical timestamps, only the latest record is retained. If the parameter is not specified, the latest ingested record (based) on the system time will be kept.\n\n**checkTimes** (optional) is a vector of temporal values or a DURATION scalar. If it is specified, the system will regularly update the right table (keeping only the latest data) and ingests the latest data to the lookup join engine. If the right table does not need to be updated regularly, you can leave *checkTimes* empty, but make sure to manually ingest the table data to the engine after it has been created.\n\n* If *checkTimes* is a vector of temporal values, it must be of SECOND, TIME or NANOTIME type. The lookup join engine updates the right table according to the time specified by each element in the vector on a daily basis.\n\n* If *checkTimes* is a DURATION scalar, it indicates the interval to update the right table.\n\n**outputElapsedMicroseconds** (optional) is a Boolean value. The default value is false. It determines whether to output:\n\n* the elapsed time (in microseconds) from the ingestion of data to the output of result in each batch.\n\n* the total number of each batch.\n\n**keepDuplicates** (optional) is a Boolean value indicating whether to keep all records in each group of the right table. When set to false (default), the engine keeps the latest record in each group. When set to true, the engine keeps all records in each group.\n\n#### Examples\n\nExample 1\n\n```\nlogin(`admin, `123456)\nshare streamTable(1000:0, `timestamps`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\nshare streamTable(1000:0, `timestamps`sym`val`id, [TIMESTAMP, SYMBOL, DOUBLE, INT]) as prices\nshare table(100:0, `sym`factor1`factor2`factor3, [SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\n\nLjEngine = createLookupJoinEngine(name=\"test1\", leftTable=trades, rightTable=prices, outputTable=output, metrics=<[price,val,price*val]>, matchingColumn=`sym)\nsubscribeTable(tableName=\"trades\", actionName=\"append_leftTable\", offset=0, handler=appendForJoin{LjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"prices\", actionName=\"append_rightTable\", offset=0, handler=appendForJoin{LjEngine, false}, msgAsTable=true)\n\nn = 15\ntem1 = table( (2018.10.08T01:01:01.001 + 1..12) join (2018.10.08T01:01:01.001 + 1..3)as timestamps,take(`A`B`C, n) as sym,take(1..15,n) as val,1..15 as id)\nprices.append!(tem1)\nsleep(2000)\nn  = 10\ntem2 = table( 2019.10.08T01:01:01.001 + 1..n as timestamps,take(`A`B`C, n) as sym,take(0.1+10..20,n) as price)\ntrades.append!(tem2)\nsleep(100)\nselect * from output\n```\n\n| sym | factor1 | factor2 | factor3 |\n| --- | ------- | ------- | ------- |\n| A   | 10.1    | 13      | 131.3   |\n| B   | 11.1    | 14      | 155.4   |\n| C   | 12.1    | 15      | 181.5   |\n| A   | 13.1    | 13      | 170.3   |\n| B   | 14.1    | 14      | 197.4   |\n| C   | 15.1    | 15      | 226.5   |\n| A   | 16.1    | 13      | 209.3   |\n| B   | 17.1    | 14      | 239.4   |\n| C   | 8.1     | 15      | 271.5   |\n| A   | 19.1    | 13      | 248.3   |\n\nExample 2\n\n```\nshare streamTable(1000:0, `timestamps`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\nshare streamTable(1000:0, `timestamps`sym`val`id, [TIMESTAMP, SYMBOL, DOUBLE, INT]) as prices\nshare table(100:0, `sym`factor1`factor2`factor3, [SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\nLjEngine = createLookupJoinEngine(name=\"test1\", leftTable=trades, rightTable=prices, outputTable=output, metrics=<[price,val,price*val]>, matchingColumn=`sym, rightTimeColumn=`timestamps)\nsubscribeTable(tableName=\"trades\", actionName=\"append_leftTable\", offset=0, handler=appendForJoin{LjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"prices\", actionName=\"append_rightTable\", offset=0, handler=appendForJoin{LjEngine, false}, msgAsTable=true)\n\nn = 15\ntem1 = table( (2018.10.08T01:01:01.001 + 1..12) join (2018.10.08T01:01:01.001 + 1..3)as timestamps,take(`A`B`C, n) as sym,take(1..15,n) as val,1..15 as id)\nprices.append!(tem1)\nsleep(2000)\nn  = 10\ntem2 = table( 2019.10.08T01:01:01.001 + 1..n as timestamps,take(`A`B`C, n) as sym,take(0.1+10..20,n) as price)\ntrades.append!(tem2)\nsleep(100)\nselect * from output\n```\n\n| sym | factor1 | factor2 | factor3 |\n| --- | ------- | ------- | ------- |\n| A   | 10.1    | 10      | 101     |\n| B   | 11.1    | 11      | 122.1   |\n| C   | 12.1    | 12      | 145.2   |\n| A   | 13.1    | 10      | 131     |\n| B   | 14.1    | 11      | 155.1   |\n| C   | 15.1    | 12      | 181.2   |\n| A   | 16.1    | 10      | 161     |\n| B   | 17.1    | 11      | 188.1   |\n| C   | 18.1    | 12      | 217.2   |\n| A   | 19.1    | 10      | 191     |\n\nExample 3. The right table is an in-memory table, so *checkTimes* must be set.\n\n```\nshare streamTable(1000:0, `timestamps`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\nshare table(100:0, `sym`factor1`factor2`factor3, [SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\nprices=table(1000:0, `timestamps`sym`val`id, [TIMESTAMP, SYMBOL, DOUBLE, INT])\nLjEngine = createLookupJoinEngine(name=\"test1\", leftTable=trades, rightTable=prices, outputTable=output, metrics=<[price,val,price*val]>, matchingColumn=`sym, rightTimeColumn=`timestamps, checkTimes=1s)\nsubscribeTable(tableName=\"trades\", actionName=\"append_leftTable\", offset=0, handler=appendForJoin{LjEngine, true}, msgAsTable=true)\n\nn = 15\ntem1 = table( (2018.10.08T01:01:01.001 + 1..12) join (2018.10.08T01:01:01.001 + 1..3)as timestamps,take(`A`B`C, n) as sym,take(1..15,n) as val,1..15 as id)\nprices.append!(tem1)\nsleep(2000)\nn  = 10\ntem2 = table( 2019.10.08T01:01:01.001 + 1..n as timestamps,take(`A`B`C, n) as sym,take(0.1+10..20,n) as price)\ntrades.append!(tem2)\nsleep(100)\nselect * from output\n```\n\n| sym | factor1 | factor2 | factor3 |\n| --- | ------- | ------- | ------- |\n| A   | 10.1    | 10      | 101     |\n| B   | 11.1    | 11      | 122.1   |\n| C   | 12.1    | 12      | 145.2   |\n| A   | 13.1    | 10      | 131     |\n| B   | 14.1    | 11      | 155.1   |\n| C   | 15.1    | 12      | 181.2   |\n| A   | 16.1    | 10      | 161     |\n| B   | 17.1    | 11      | 188.1   |\n| C   | 18.1    | 12      | 217.2   |\n| A   | 19.1    | 10      | 191     |\n\nExample 4. Join the left table \"trades\" (a real-time stream table) and the right table \"prices\" (a dimension table with infrequent updates) to look up the matched records in column \"id\" from the right table.\n\n```\nshare streamTable(1000:0, `time`volume`id, [TIMESTAMP, INT,INT]) as trades\ndbPath=\"dfs://testlj\"\nif(existsDatabase(dbPath)){\n   dropDatabase(dbPath)\n}\nrt=table(1000:0, `time`price`id, [TIMESTAMP, DOUBLE, INT])\ndb=database(dbPath, VALUE, `A`B`C)\nprices=db.createDimensionTable(rt,`rightTable)\nshare table(10000:0, `id`volume`price`prod, [INT,INT,DOUBLE,DOUBLE]) as outputTable\n\ntradesLookupJoin = createLookupJoinEngine(name=\"streamLookup1\", leftTable=trades, rightTable=prices, outputTable=outputTable, metrics=<[volume,price,volume*price]>, matchingColumn=`id, rightTimeColumn=`time,checkTimes=1s)\nsubscribeTable(tableName=\"trades\", actionName=\"append_trades\", offset=0, handler=appendForJoin{tradesLookupJoin, true}, msgAsTable=true)\n\ndef writeData(t,n){\n    timev = 2021.10.08T01:01:01.001 + timestamp(1..n)\n    volumev = take(1..n, n)\n    id = take(1 2 3, n)\n    insert into t values(timev, volumev, id)\n}\n\nwriteData(rt, 10)\nprices.append!(rt)\nsleep(2000)\nwriteData(trades, 6)\nsleep(2)\n\nselect * from outputTable\n```\n\n| id | volume | price | prod |\n| -- | ------ | ----- | ---- |\n| 1  | 1      | 10    | 10   |\n| 2  | 2      | 8     | 16   |\n| 3  | 3      | 9     | 27   |\n| 1  | 4      | 10    | 40   |\n| 2  | 5      | 8     | 40   |\n| 3  | 6      | 9     | 54   |\n\nExample 5. Specify SQL metacode for *rightTable* to join columns queried from a DFS partitioned table.\n\n```\nshare streamTable(1000:0, `time`volume`id, [TIMESTAMP, INT,INT]) as trades\ndbPath=\"dfs://lookupjoinDB\"\nif(existsDatabase(dbPath)){\n   dropDatabase(dbPath)\n}\nrt=table(1000:0, `time`price`id, [TIMESTAMP, DOUBLE, INT])\ndb=database(dbPath, HASH, [INT,5])\nprices=db.createPartitionedTable(rt,`rightTable, `id)\nshare table(10000:0, `id`volume`price`prod, [INT,INT,DOUBLE,DOUBLE]) as outputTable\n\ntradesLookupJoin = createLookupJoinEngine(name=\"streamLookup1\", leftTable=trades, rightTable=<select * from loadTable(dbPath, `rightTable)>, outputTable=outputTable, metrics=<[volume,price,volume*price]>, matchingColumn=`id, rightTimeColumn=`time,checkTimes=1s)\nsubscribeTable(tableName=\"trades\", actionName=\"append_trades\", offset=0, handler=appendForJoin{tradesLookupJoin, true}, msgAsTable=true)\n\ndef writeData(t,n){\n    timev = 2021.10.08T01:01:01.001 + timestamp(1..n)\n    volumev = take(1..n, n)\n    id = take(1 2 3, n)\n    insert into t values(timev, volumev, id)\n}\n\nwriteData(rt, 10)\nprices.append!(rt)\nsleep(2000)\nwriteData(trades, 6)\nsleep(2)\n\nselect * from outputTable\n```\n\n| id | volume | price | prod |\n| -- | ------ | ----- | ---- |\n| 1  | 1      | 10    | 10   |\n| 2  | 2      | 8     | 16   |\n| 3  | 3      | 9     | 27   |\n| 1  | 4      | 10    | 40   |\n| 2  | 5      | 8     | 40   |\n| 3  | 6      | 9     | 54   |\n"
    },
    "createNarrowReactiveStateEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createNarrowReactiveStateEngine.html",
        "signatures": [
            {
                "full": "createNarrowReactiveStateEngine(name, metrics, metricNames, dummyTable, outputTable, keyColumn, [filter], [snapshotDir], [snapshotIntervalInMsgCount], [keepOrder], [keyPurgeFilter], [keyPurgeFreqInSecond=0], [raftGroup], [outputElapsedMicroseconds=false], [keyCapacity=1024], [parallelism=1], [outputHandler=NULL], [msgAsTable=false])",
                "name": "createNarrowReactiveStateEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "metricNames",
                        "name": "metricNames"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "[filter]",
                        "name": "filter",
                        "optional": true
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[keepOrder]",
                        "name": "keepOrder",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFilter]",
                        "name": "keyPurgeFilter",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSecond=0]",
                        "name": "keyPurgeFreqInSecond",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyCapacity=1024]",
                        "name": "keyCapacity",
                        "optional": true,
                        "default": "1024"
                    },
                    {
                        "full": "[parallelism=1]",
                        "name": "parallelism",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createNarrowReactiveStateEngine](https://docs.dolphindb.com/en/Functions/c/createNarrowReactiveStateEngine.html)\n\n\n\n#### Syntax\n\ncreateNarrowReactiveStateEngine(name, metrics, metricNames, dummyTable, outputTable, keyColumn, \\[filter], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[keepOrder], \\[keyPurgeFilter], \\[keyPurgeFreqInSecond=0], \\[raftGroup], \\[outputElapsedMicroseconds=false], \\[keyCapacity=1024], \\[parallelism=1], \\[outputHandler=NULL], \\[msgAsTable=false])\n\n#### Details\n\nCreate a reactive state engine that returns a table in narrow format. The only difference between `createNarrowReactiveStateEngine` and `createReactiveStateEngine` lies in the schema of the returned table, i.e., the former outputs results of multiple factors to a single column, while the latter outputs results of each factor to separate columns.\n\n#### Arguments\n\nAs most of the parameters of `createNarrowReactiveStateEngine` are identical with those of [createReactiveStateEngine](https://docs.dolphindb.com/en/Functions/c/createReactiveStateEngine.html), only the different ones are explained here.\n\n**metrics** is metacode or a tuple of metacode containing columns from the input table (excluding *keyColumn*, optional) or factors (formulas for calculation, required).\n\n**metricNames** is a STRING scalar or vector, indicating the name for each factor specified in *metrics*. The number and order of names must align to that of factors specified in *metrics*.\n\n**outputTable** is the output table for the results. It can be an in-memory table or a DFS table. Create an empty table and specify the column names and types before calling the function.\n\nThe output columns are in the following order:\n\n(1) The first few columns must be in the same order as that of *keyColumn*.\n\n(2) If the *outputElapsedMicroseconds* is set to true, specify two more columns: a LONG column and an INT column.\n\n(3) The references to columns from the input table specified in *metrics.*\n\n(4) A single column containing *metricNames*.\n\n(5) Then followed by one result column.\n\n**Note**: The following parameters are not supported currently: *snapshotDir*, *snapshotIntervalInMsgCount*, and *raftGroup.*\n\n**outputHandler** (optional) is a unary function or a partial function with a single unfixed parameter. If set, the engine will not write the calculation results to the output table directly. Instead, the results will be passed as a parameter to the *outputHandler* function. The default value is NULL, which means the result will be written to the output table.\n\n**msgAsTable** (optional) is a Boolean scalar indicating whether the output data is passed into function (specified by *outputHandler*) as a table or as a tuple. If *msgAsTable*=true, the subscribed data is passed into function as a table. The default value is false, which means the output data is passed into function as a tuple of columns.\n\n#### Examples\n\nCalculate the cumulative volume and the moving average and output the results of both factors to a single column.\n\n```\ndummy = streamTable(1:0, [\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"upToDatePrice\",\"qty\",\"value\"], [STRING,STRING,STRING,TIMESTAMP,TIMESTAMP,DOUBLE,DOUBLE,INT]) \nshare streamTable(1:0,[\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"metricNames\",\"factorValue\"], [STRING,STRING,STRING, TIMESTAMP,TIMESTAMP,STRING,DOUBLE]) as outputTable\n// Define two factors: cumulative volume and the moving average\nfactor = [<createTime>, <updateTime>,<cumsum(qty)>,<cumavg(upToDatePrice)>]\nNarrowtest = createNarrowReactiveStateEngine(name=\"narrowtest1\",metrics=factor,metricNames=[\"factor1\",\"factor2\"],dummyTable=dummy,outputTable=outputTable,keyColumn=[\"securityID1\",\"securityID2\",\"securityID3\"])\n\nnum = 5\ntmp = table(take(\"A\" + lpad(string(1..4),4,\"0\"),num) as securityID1,take(\"CC.HH\" + lpad(string(21..34),4,\"0\"),num) as securityID2,take(\"FFICE\" + lpad(string(13..34),4,\"0\"),num) as securityID3, 2023.09.01 00:00:00+(1..num) as createTime, 2023.09.01 00:00:00+(1..num) as updateTime,100.0+(1..num) as upToDatePrice, 130.0+(1..num) as qty,take(1..3,num) as value)\nNarrowtest.append!(tmp)\n\nselect * from outputTable\n\n\nsecurityID1\tsecurityID2\tsecurityID3\tcreateTime\tupdateTime\tmetricNames\tfactorValue\nA0001\tCC.HH0021\tFFICE0013\t2023.09.01T00:00:01.000\t2023.09.01T00:00:01.000\tfactor1\t131\nA0001\tCC.HH0021\tFFICE0013\t2023.09.01T00:00:01.000\t2023.09.01T00:00:01.000\tfactor2\t101\nA0002\tCC.HH0022\tFFICE0014\t2023.09.01T00:00:02.000\t2023.09.01T00:00:02.000\tfactor1\t132\nA0002\tCC.HH0022\tFFICE0014\t2023.09.01T00:00:02.000\t2023.09.01T00:00:02.000\tfactor2\t102\nA0003\tCC.HH0023\tFFICE0015\t2023.09.01T00:00:03.000\t2023.09.01T00:00:03.000\tfactor1\t133\nA0003\tCC.HH0023\tFFICE0015\t2023.09.01T00:00:03.000\t2023.09.01T00:00:03.000\tfactor2\t103\nA0004\tCC.HH0024\tFFICE0016\t2023.09.01T00:00:04.000\t2023.09.01T00:00:04.000\tfactor1\t134\nA0004\tCC.HH0024\tFFICE0016\t2023.09.01T00:00:04.000\t2023.09.01T00:00:04.000\tfactor2\t104\nA0001\tCC.HH0025\tFFICE0017\t2023.09.01T00:00:05.000\t2023.09.01T00:00:05.000\tfactor1\t135\nA0001\tCC.HH0025\tFFICE0017\t2023.09.01T00:00:05.000\t2023.09.01T00:00:05.000\tfactor2\t105\n\n```\n\nRelated functions: [addReactiveMetrics](https://docs.dolphindb.com/en/Functions/a/addReactiveMetrics.html), [getReactiveMetrics](https://docs.dolphindb.com/en/Functions/g/getReactiveMetrics.html)\n"
    },
    "createPartitionedTable": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createPartitionedTable.html",
        "signatures": [
            {
                "full": "createPartitionedTable(dbHandle, table, tableName, [partitionColumns], [compressMethods], [sortColumns|primaryKey], [keepDuplicates=ALL], [sortKeyMappingFunction], [softDelete=false], [indexes])",
                "name": "createPartitionedTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[partitionColumns]",
                        "name": "partitionColumns",
                        "optional": true
                    },
                    {
                        "full": "[compressMethods]",
                        "name": "compressMethods",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns|primaryKey]",
                        "name": "[sortColumns|primaryKey]"
                    },
                    {
                        "full": "[keepDuplicates=ALL]",
                        "name": "keepDuplicates",
                        "optional": true,
                        "default": "ALL"
                    },
                    {
                        "full": "[sortKeyMappingFunction]",
                        "name": "sortKeyMappingFunction",
                        "optional": true
                    },
                    {
                        "full": "[softDelete=false]",
                        "name": "softDelete",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[indexes]",
                        "name": "indexes",
                        "optional": true
                    }
                ]
            },
            {
                "full": "createPartitionedTable(dbHandle, table, tableName, [partitionColumns], [compressMethods], [sortColumns], [keepDuplicates=ALL], [sortKeyMappingFunction], [softDelete=false])",
                "name": "createPartitionedTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[partitionColumns]",
                        "name": "partitionColumns",
                        "optional": true
                    },
                    {
                        "full": "[compressMethods]",
                        "name": "compressMethods",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns]",
                        "name": "sortColumns",
                        "optional": true
                    },
                    {
                        "full": "[keepDuplicates=ALL]",
                        "name": "keepDuplicates",
                        "optional": true,
                        "default": "ALL"
                    },
                    {
                        "full": "[sortKeyMappingFunction]",
                        "name": "sortKeyMappingFunction",
                        "optional": true
                    },
                    {
                        "full": "[softDelete=false]",
                        "name": "softDelete",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createPartitionedTable](https://docs.dolphindb.com/en/Functions/c/createPartitionedTable.html)\n\n\n\n#### Syntax\n\ncreatePartitionedTable(dbHandle, table, tableName, \\[partitionColumns], \\[compressMethods], \\[sortColumns|primaryKey], \\[keepDuplicates=ALL], \\[sortKeyMappingFunction], \\[softDelete=false], \\[indexes])\n\ncreatePartitionedTable(dbHandle, table, tableName, \\[partitionColumns], \\[compressMethods], \\[sortColumns], \\[keepDuplicates=ALL], \\[sortKeyMappingFunction], \\[softDelete=false])\n\n#### Arguments\n\n**Note:** The parameters *sortColumns*, *keepDuplicates* and *sortKeyMappingFunction* take effect only in a TSDB storage engine (i.e., `database().engine` = TSDB).\n\n**dbHandle** (optional) is a DFS database handle returned by function [database](https://docs.dolphindb.com/en/Functions/d/database.html). The database can be either in the local file system, or in the distributed file system. If the *dbHandle* is empty or unspecified, the table is an in-memory partitioned table.\n\n**table** (optional) is a table or a tuple of tables. The table schema will be used to construct the new partitioned table.\n\n**tableName** (optional) is a string indicating the name of the partitioned table.\n\n**partitionColumns** (optional) is a STRING scalar/vector indicating the partitioning column(s). For non-sequential partitioning, this parameter is required. For a composite partition, this parameter is a STRING vector.A string can be a column name, or a function call applied to a column (e.g. `partitionFunc(id)`). If a function call is specified, it must have exactly one column argument, and the other arguments must be constant scalars. In this case, the table is partitioned based on the result of the function call. Note that optimization may be limited for SQL queries involving the partitioning column (e.g., the id column in `partitionFunc(id)`).\n\n**compressMethods** (optional) is a dictionary indicating which compression methods are used for specified columns. The keys are columns name and the values are compression methods (\"lz4\", \"delta\", \"zstd\" or \"chimp\"). If unspecified, use LZ4 compression method. Note:\n\n* The delta compression method can be used for DECIMAL, SHORT, INT, LONG or temporal data types.\n* Save strings as SYMBOL type to enable compression of strings.\n* The chimp compression method can be used for DOUBLE type data with decimal parts not exceeding three digits in length.\n\n**sortColumns** (optional) is a STRING scalar/vector that specifies the column(s) used to sort the ingested data within each partitionof **the TSDB database**. The sort columns must be of Integral, Temporal, STRING, SYMBOL, or DECIMAL type. Note that *sortColumns* is not necessarily consistent with the partitioning column.\n\n* If multiple columns are specified for *sortColumns*, the last column must be a time column. The preceding columns are used as the sort keys and they cannot be of TIME, TIMESTAMP, NANOTIME, or NANOTIMESTAMP type.\n* If only one column is specified for *sortColumns*, the column is used as the sort key, and it can be a time column or not. If the sort column is a time column and *sortKeyMappingFunction* is specified, the sort column specified in a SQL where condition can only be compared with temporal values of the same data type.\n* It is recommended to specify frequently-queried columns for *sortColumns* and sort them in the descending order of query frequency, which ensures that frequently-used data is readily available during query processing.\n* The number of sort key entries (which are the combinations of the values of the sort keys) within each partition may not exceed 1000 for optimal performance. This limitation prevents excessive memory usage and ensures efficient query processing.\n\n**primaryKey** (optional) is a STRING scalar/vector that specifies the primary key column(s), uniquely identifying each record in a DFS table of **the PKEY database**. For records with the same primary key, only the latest one is retained. Note that:\n\n* *primaryKey* must include all partitioning columns.\n* The primary key columns must be of Logical, Integral (excluding COMPRESSED), Temporal, STRING, SYMBOL, or DECIMAL type.\n* With more than one primary key column, a composite primary key is maintained. The composite primary key uses a Bloomfilter index by default (see the *indexes* parameter for details).\n\n**keepDuplicates** (optional) specifies how to deal with records with duplicate *sortColumns* values. It can have the following values:\n\n* ALL: keep all records;\n* LAST: only keep the last record;\n* FIRST: only keep the first record.\n\nIt is recommended to specify the *sortKeyMappingFunction* parameter if there are many sort keys in a partition of a TSDB database and a small number of records with the same sort key. After dimensionality reduction, the blocks in a TSDB level file can store more data, which not only reduces the frequency of reading data blocks and disk I/O during query, but also improves the data compression ratio.\n\n**sortKeyMappingFunction** (optional) is a vector of unary functions. It has the same length as the number of sort keys. The specified mapping functions are applied to each sort key (i.e., the sort columns except for the temporal column) for dimensionality reduction. After the dimensionality reduction for the sort keys, records with a new sort key entry will be sorted based on the last column of *sortColumns* (the temporal column).\n\n**Note**:\n\n* Dimensionality reduction is performed when writing to disk, so specifying this parameter may affect write performance.\n* The functions specified in `sortKeyMappingFunction` correspond to each and every sort key. If a sort key does not require dimensionality reduction, leave the corresponding element empty in the vector.\n* If a mapping function is `hashBucket` AND the sort key to which it applies is a HASH partitioning column, make sure the number of hash partitions and *buckets* are not divisible by each other (except when *buckets*=1). Otherwise the column values from the same HASH partition would be mapped to the same hash bucket after dimensionality reduction.\n\n**softDelete** (optional) determines whether to enable soft delete for TSDB databases. The default value is false. To use it, *keepDuplicates* must be set to 'LAST'. It is recommended to enable soft delete for databases where the row count is large and delete operations are infrequent.\n\n**indexes** (optional) is a dictionary with columns as keys and index types as values. Both keys and values are of STRING type. *indexes* can only be set for tables of TSDB (*keepDuplicates*=ALL) or PKEY databases.\n\n* **For PKEY databases:**\n  * Currently, only \"bloomfilter\" index type is available. Bloomfilter indexing excels in point queries on high-cardinality columns (e.g., ID card numbers, order numbers, foreign keys from upstreams).\n  * It supports indexing on columns of the following data types: BOOL, CHAR, SHORT, INT, LONG, BLOB, STRING, DECIMAL32, DECIMAL64, DECIMAL128.\n  * Composite primary keys are automatically indexed with Bloomfilter. Columns not specified in *indexes* default to ZoneMap indexing.\n* **For TSDB databases:**\n  * Only supports vector indexing on a single column of FLOAT\\[] type.\n  * The vector index is specified in the form of `vectorindex(type={t}, dim={d})`, where\n    * *type* can take the following values: flat, pq, ivf, ivfpq, hnsw.\n    * *dim* is an integer no less than 1, indicating the dimension of the vector. For index types \"pq\" or \"ivfpq\", *dim* must be divisible by 4. Note that the dimension of vectors inserted into the indexing column must match the specified *dim*.\n  * Vector indexing accelerates retrieval under the following conditions:\n    * No table joins are used in queries.\n    * The `order by` clause must sort in ascending order and can only use `rowEuclidean` to compute distances.\n    * The first parameter passed to `rowEuclidean` must be the indexing column, i.e., `rowEuclidean(<vectorCol>, queryVec)`.\n    * A `limit` clause must be specified.\n    * If a `where` clause is specified, it must not include any sort columns.\n    * The query cannot include clauses such as `group by` and `having`.\n\n#### Details\n\nCreate an empty partitioned table with the same schema as the specified table.\n\n* To create a DFS table or a table on disk, parameter *table* must be a table. This function is used with [append!](https://docs.dolphindb.com/en/Functions/a/append!.html) or [tableInsert](https://docs.dolphindb.com/en/Functions/t/tableInsert.html) to generate a partitioned table. It cannot be used to create a partitioned table with sequential domain.\n* To create an in-memory partitioned table, parameter *table* can be a table or a tuple of tables. The number of tables given by the parameter *table* must be the same as the number of partitions in the database.\n\n**Note**:\n\n* Only the schema of *table* is used. None of the rows in table is imported to the newly created partitioned table.\n* For a DFS database in an OLAP engine, the maximum number of handles (including temporary handles\\*) to partitioned tables is 8,192 per node. For the TSDB storage engine, there is no limit.\n\n\\*temporary handles: If no handle is specified when you create a partitioned table in a DFS database with `createPartitionedTable`, each database creates a temporary handle to hold the return value. If you create multiple tables under the same database, the temporary handle for the database is overwritten each time.\n\n#### Examples\n\nExample 1. Create a DFS table\n\nExample 1.1. Create a DFS table in OLAP database\n\n```\nn=10000\nt=table(2020.01.01T00:00:00 + 0..(n-1) as timestamp, rand(`IBM`MS`APPL`AMZN,n) as symbol, rand(10.0, n) as value)\ndb = database(\"dfs://rangedb_tradedata\", RANGE, `A`F`M`S`ZZZZ)\nTrades = db.createPartitionedTable(table=t, tableName=\"Trades\", partitionColumns=\"symbol\", compressMethods={timestamp:\"delta\"});\n```\n\nAt this point, the table Trades is empty. The schema of Trades is the same as the schema of table t. Then we append table t to table Trades.\n\n```\nTrades.append!(t);\n```\n\nNow the contents of table Trades have been updated on disk. In the DFS system, the system doesn't dynamically refresh the contents of tables. We need to load the table into memory before we can work with it interactively.\n\n```\nTrades=loadTable(db,`Trades);\nselect min(value) from Trades;\n// output\n0\n```\n\nAfter appending data to a DFS table, we don't need to use function [loadTable](https://docs.dolphindb.com/en/Functions/l/loadTable.html) to load the table before querying the table, as the system automatically refreshes the table after appending operations. After system restarts, however, we need to use `loadTable` to load a DFS table before querying the table.\n\nExample 1.2. Create a DFS table in TSDB database\n\n```\nn = 10000\nSecurityID = rand(`st0001`st0002`st0003`st0004`st0005, n)\nsym = rand(`A`B, n)\nTradeDate = 2022.01.01 + rand(100,n)\nTotalVolumeTrade = rand(1000..3000, n)\nTotalValueTrade = rand(100.0, n)\nschemaTable_snap = table(SecurityID, TradeDate, TotalVolumeTrade, TotalValueTrade).sortBy!(`SecurityID`TradeDate)\n\ndbPath = \"dfs://TSDB_STOCK\"\nif(existsDatabase(dbPath)){dropDatabase(dbPath)}\ndb_snap = database(dbPath, VALUE, 2022.01.01..2022.01.05, engine='TSDB')\nsnap=createPartitionedTable(dbHandle=db_snap, table=schemaTable_snap, tableName=\"snap\", partitionColumns=`TradeDate, sortColumns=`SecurityID`TradeDate, keepDuplicates=ALL, sortKeyMappingFunction=[hashBucket{,5}])\nsnap.append!(schemaTable_snap)\nflushTSDBCache()\n```\n\n```\nsnap = loadTable(dbPath, `snap)\nselect * from snap\n```\n\nExample 1.3. Create a distributed partitioned table in PKEY database.\n\n```\ndb = database(directory=\"dfs://PKDB\", partitionType=VALUE, partitionScheme=1..10, engine=\"PKEY\")\nschematb = table(1:0,`id1`id2`val1`val2`date1`time1,[INT,INT,INT,DECIMAL32(2),DATE,TIME])\npkt = createPartitionedTable(dbHandle=db, table=schematb, tableName=\"pkt\", partitionColumns=\"id1\", primaryKey=`id1`id2, indexes={\"val1\": \"bloomfilter\", \"val2\": \"bloomfilter\"})\n```\n\nExample 2. Create in-memory partitioned tables\n\nExample 2.1. Create a partitioned in-memory table\n\n```\nn = 20000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt = table(n:0, colNames, colTypes)\ndb = database(, RANGE, `A`D`F)\npt = db.createPartitionedTable(t, `pt, `sym)\n\ninsert into pt values(09:30:00.001,`AAPL,100,56.5)\ninsert into pt values(09:30:01.001,`DELL,100,15.5)\n```\n\nExample 2.2. Create a partitioned keyed table\n\n```\nn = 20000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt = keyedTable(`time`sym, n:0, colNames, colTypes)\ndb = database(, RANGE, `A`D`F)\npt = db.createPartitionedTable(t, `pt, `sym)\n\ninsert into pt values(09:30:00.001,`AAPL,100,56.5)\ninsert into pt values(09:30:01.001,`DELL,100,15.5)\n```\n\nExample 2.3. Create a partitioned stream table\n\nWhen creating a partitioned stream table, the second parameter of `createPartitionedTable` must be a tuple of tables, and its length must be equal to the number of partitions. Each table in the tuple represents a partition. In the following example, trades\\_stream1 and trades\\_stream2 form a partitioned stream table trades. We cannot directly write data to trades. Instead, we need to write to trades\\_stream1 and trades\\_stream2.\n\n```\nn=200000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\ntrades_stream1 = streamTable(n:0, colNames, colTypes)\ntrades_stream2 = streamTable(n:0, colNames, colTypes)\ndb=database(, RANGE, `A`D`F)\ntrades = createPartitionedTable(db,[trades_stream1, trades_stream2], \"\", `sym)\n\ninsert into trades_stream1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into trades_stream2 values(09:30:01.001,`DELL,100,15.5)\n\nselect * from trades;\n```\n\n| time         | sym  | qty | price |\n| ------------ | ---- | --- | ----- |\n| 09:30:00.001 | AAPL | 100 | 56.5  |\n| 09:30:01.001 | DELL | 100 | 15.5  |\n\nExample 2.4. Create a partitioned MVCC table\n\nSimilar to a partitioned stream table, to create a partitioned MVCC table, the second parameter of `createPartitionedTable` must be a tuple of tables, and its length must be equal to the number of partitions. Each table in the tuple represents a partition. In the following example, trades\\_mvcc1 and trades\\_mvcc2 form a partitioned MVCC table trades. We cannot directly write data to trades. Instead, we need to write to trades\\_mvcc1 and trades\\_mvcc2.\n\n```\nn=200000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\ntrades_mvcc1 = mvccTable(n:0, colNames, colTypes)\ntrades_mvcc2 = mvccTable(n:0, colNames, colTypes)\ndb=database(, RANGE, `A`D`F)\ntrades = createPartitionedTable(db,[trades_mvcc1, trades_mvcc2], \"\", `sym)\n\ninsert into trades_mvcc1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into trades_mvcc2 values(09:30:01.001,`DELL,100,15.5)\n\nselect * from trades;\n```\n\n| time         | sym  | qty | price |\n| ------------ | ---- | --- | ----- |\n| 09:30:00.001 | AAPL | 100 | 56.5  |\n| 09:30:01.001 | DELL | 100 | 15.5  |\n\nExample 3. Create a distributed partitioned table in TSDB database with a vector index set. Then execute a query that is optimized using the vector index.\n\n```\ndb = database(directory=\"dfs://indexesTest\", partitionType=VALUE, partitionScheme=1..10, engine=\"TSDB\")\nschematb = table(1:0,`col0`col1`col2`col3,[INT,INT,TIMESTAMP,FLOAT[]])\npt = createPartitionedTable(dbHandle=db, table=schematb, tableName=`pt, partitionColumns=`col0, sortColumns=`col1`col2, indexes={\"col3\":\"vectorindex(type=flat, dim=5)\"})\n\ntmp = cj(table(1..10 as col0),cj(table(1..10 as col1),table(now()+1..10 as col2))) join table(arrayVector(1..1000*5,1..5000) as col3)\n\npt.tableInsert(tmp)\n\nselect * from pt where col2<now() order by rowEuclidean(col3,[1339,252,105,105,829]) limit 10\n```\n\n<table id=\"table_nnw_dvp_zbc\"><tbody><tr><td>\n\ncol0\n\n</td><td>\n\ncol1\n\n</td><td>\n\ncol2\n\n</td><td>\n\ncol3\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.06.27 16:56:38.950\n\n</td><td>\n\n\\[526, 527, 528, 529, 530]\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.06.27 16:56:38.949\n\n</td><td>\n\n\\[521, 522, 523, 524, 525]\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.06.27 16:56:38.951\n\n</td><td>\n\n\\[531, 532, 533, 534, 535]\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.06.27 16:56:38.948\n\n</td><td>\n\n\\[516, 517, 518, 519, 520]\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.06.27 16:56:38.952\n\n</td><td>\n\n\\[536, 537, 538, 539, 540]\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.06.27 16:56:38.947\n\n</td><td>\n\n\\[511, 512, 513, 514, 515]\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.06.27 16:56:38.953\n\n</td><td>\n\n\\[541, 542, 543, 544, 545]\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.06.27 16:56:38.946\n\n</td><td>\n\n\\[506, 507, 508, 509, 510]\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.06.27 16:56:38.954\n\n</td><td>\n\n\\[546, 547, 548, 549, 550]\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.06.27 16:56:38.945\n\n</td><td>\n\n\\[501, 502, 503, 504, 505]\n\n</td></tr></tbody>\n</table>Example 4. For data with a column in the format `id_date_id` \\(e.g., ax1ve\\_20240101\\_e37f6\\), partition by date using a user-defined function:\n\n```\n// Define a function to extract the date information\ndef myPartitionFunc(str,a,b) {\n    return temporalParse(substr(str, a, b),\"yyyyMMdd\")\n}\n\n// Create a database\ndata = [\"ax1ve_20240101_e37f6\", \"91f86_20240103_b781d\", \"475b4_20240101_6d9b2\", \"239xj_20240102_x983n\",\"2940x_20240102_d9237\"]\ntb = table(data as id_date, 1..5 as value, `a`b`c`d`e as sym)\ndb = database(\"dfs://testdb\", VALUE, 2024.02.01..2024.02.02)\n\n// Use myPartitionFunc to process the data column\npt = db.createPartitionedTable(table=tb, tableName=`pt, \n    partitionColumns=[\"myPartitionFunc(id_date, 6, 8)\"])\npt.append!(tb)\n\nselect * from pt\n```\n\nThe queried data are read and returned by partition. The query result shows that table pt is partitioned by the date information extracted from the id\\_date column.\n\n| id\\_date               | value | sym |\n| ---------------------- | ----- | --- |\n| ax1ve\\_20240101\\_e37f6 | 1     | a   |\n| 475b4\\_20240101\\_6d9b2 | 3     | c   |\n| 239xj\\_20240102\\_x983n | 4     | d   |\n| 2940x\\_20240102\\_d9237 | 5     | e   |\n| 91f86\\_20240103\\_b781d | 2     | b   |\n"
    },
    "createReactiveStateEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createReactiveStateEngine.html",
        "signatures": [
            {
                "full": "createReactiveStateEngine(name, metrics, dummyTable, outputTable, keyColumn, [filter], [snapshotDir], [snapshotIntervalInMsgCount], [keepOrder], [keyPurgeFilter], [keyPurgeFreqInSecond=0], [raftGroup], [outputElapsedMicroseconds=false], [keyCapacity=1024], [parallelism=1], [outputHandler=NULL], [msgAsTable=false])",
                "name": "createReactiveStateEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "[filter]",
                        "name": "filter",
                        "optional": true
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[keepOrder]",
                        "name": "keepOrder",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFilter]",
                        "name": "keyPurgeFilter",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSecond=0]",
                        "name": "keyPurgeFreqInSecond",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyCapacity=1024]",
                        "name": "keyCapacity",
                        "optional": true,
                        "default": "1024"
                    },
                    {
                        "full": "[parallelism=1]",
                        "name": "parallelism",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createReactiveStateEngine](https://docs.dolphindb.com/en/Functions/c/createReactiveStateEngine.html)\n\n\n\n#### Syntax\n\ncreateReactiveStateEngine(name, metrics, dummyTable, outputTable, keyColumn, \\[filter], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[keepOrder], \\[keyPurgeFilter], \\[keyPurgeFreqInSecond=0], \\[raftGroup], \\[outputElapsedMicroseconds=false], \\[keyCapacity=1024], \\[parallelism=1], \\[outputHandler=NULL], \\[msgAsTable=false])\n\n#### Details\n\nThis function creates a reactive state engine and returns a table object. Writing to the table means that data is ingested into the reactive state engine for calculation.\n\nThe following state functions are optimized in DolphinDB reactive state engine. Note that unoptimized built-in state functions are not supported by this engine. Aggregate functions should be avoided.\n\n* cumulative function: [cumavg](https://docs.dolphindb.com/en/Functions/c/cumavg.html), [cumsum](https://docs.dolphindb.com/en/Functions/c/cumsum.html), [cumprod](https://docs.dolphindb.com/en/Functions/c/cumprod.html), [cumcount](https://docs.dolphindb.com/en/Functions/c/cumcount.html), [cummin](https://docs.dolphindb.com/en/Functions/c/cummin.html), [cummax](https://docs.dolphindb.com/en/Functions/c/cummax.html), [cumvar](https://docs.dolphindb.com/en/Functions/c/cumvar.html), [cumvarp](https://docs.dolphindb.com/en/Functions/c/cumvarp.html), [cumstd](https://docs.dolphindb.com/en/Functions/c/cumstd.html), [cumstdp](https://docs.dolphindb.com/en/Functions/c/cumstdp.html), [cumcorr](https://docs.dolphindb.com/en/Functions/c/cumcorr.html), [cumcovar](https://docs.dolphindb.com/en/Functions/c/cumcovar.html), [cumbeta](https://docs.dolphindb.com/en/Functions/c/cumbeta.html), [cumwsum](https://docs.dolphindb.com/en/Functions/c/cumwsum.html), [cumwavg](https://docs.dolphindb.com/en/Functions/c/cumwavg.html), [cumfirstNot](https://docs.dolphindb.com/en/Functions/c/cumfirstNot.html), [cumlastNot](https://docs.dolphindb.com/en/Functions/c/cumlastNot.html), [cummed](https://docs.dolphindb.com/en/Functions/c/cummed.html), [cumpercentile](https://docs.dolphindb.com/en/Functions/c/cumpercentile.html), [cumnunique](https://docs.dolphindb.com/en/Functions/c/cumnunique.html), [cumPositiveStreak](https://docs.dolphindb.com/en/Functions/c/cumPositiveStreak.html)\n\n* moving function: [ema](https://docs.dolphindb.com/en/Functions/e/ema.html), [mavg](https://docs.dolphindb.com/en/Functions/m/mavg.html), [msum](https://docs.dolphindb.com/en/Functions/m/msum.html), [mcount](https://docs.dolphindb.com/en/Functions/m/mcount.html), [mprod](https://docs.dolphindb.com/en/Functions/m/mprod.html), [mvar](https://docs.dolphindb.com/en/Functions/m/mvar.html), [mvarp](https://docs.dolphindb.com/en/Functions/m/mvarp.html), [mstd](https://docs.dolphindb.com/en/Functions/m/mstd.html), [mstdp](https://docs.dolphindb.com/en/Functions/m/mstdp.html), [mskew](https://docs.dolphindb.com/en/Functions/m/mskew.html), [mkurtosis](https://docs.dolphindb.com/en/Functions/m/mkurtosis.html), [mmin](https://docs.dolphindb.com/en/Functions/m/mmin.html), [mmax](https://docs.dolphindb.com/en/Functions/m/mmax.html), [mimin](https://docs.dolphindb.com/en/Functions/m/mimin.html), [mimax](https://docs.dolphindb.com/en/Functions/m/mimax.html), [mmed](https://docs.dolphindb.com/en/Functions/m/mmed.html), [mpercentile](https://docs.dolphindb.com/en/Functions/m/mpercentile.html), [mrank](https://docs.dolphindb.com/en/Functions/m/mrank.html), [mcorr](https://docs.dolphindb.com/en/Functions/m/mcorr.html), [mcovar](https://docs.dolphindb.com/en/Functions/m/mcovar.html), [mbeta](https://docs.dolphindb.com/en/Functions/m/mbeta.html), [mwsum](https://docs.dolphindb.com/en/Functions/m/mwsum.html), [mwavg](https://docs.dolphindb.com/en/Functions/m/mwavg.html), [mmad](https://docs.dolphindb.com/en/Functions/m/mmad.html), [mfirst](https://docs.dolphindb.com/en/Functions/m/mfirst.html), [mlast](https://docs.dolphindb.com/en/Functions/m/mlast.html), [mslr](https://docs.dolphindb.com/en/Functions/m/mslr.html), [tmove](https://docs.dolphindb.com/en/Functions/t/tmove.html), [tmfirst](https://docs.dolphindb.com/en/Functions/t/tmfirst.html), [tmlast](https://docs.dolphindb.com/en/Functions/t/tmlast.html), [tmsum](https://docs.dolphindb.com/en/Functions/t/tmsum.html), [tmavg](https://docs.dolphindb.com/en/Functions/t/tmavg.html), [tmcount](https://docs.dolphindb.com/en/Functions/t/tmcount.html), [tmvar](https://docs.dolphindb.com/en/Functions/t/tmvar.html), [tmvarp](https://docs.dolphindb.com/en/Functions/t/tmvarp.html), [tmstd](https://docs.dolphindb.com/en/Functions/t/tmstd.html), [tmstdp](https://docs.dolphindb.com/en/Functions/t/tmstdp.html), [tmprod](https://docs.dolphindb.com/en/Functions/t/tmprod.html), [tmskew](https://docs.dolphindb.com/en/Functions/t/tmskew.html), [tmkurtosis](https://docs.dolphindb.com/en/Functions/t/tmkurtosis.html), [tmmin](https://docs.dolphindb.com/en/Functions/t/tmmin.html), [tmmax](https://docs.dolphindb.com/en/Functions/t/tmmax.html), [tmmed](https://docs.dolphindb.com/en/Functions/t/tmmed.html), [tmpercentile](https://docs.dolphindb.com/en/Functions/t/tmpercentile.html), [tmrank](https://docs.dolphindb.com/en/Functions/t/tmrank.html), [tmcovar](https://docs.dolphindb.com/en/Functions/t/tmcovar.html), [tmbeta](https://docs.dolphindb.com/en/Functions/t/tmbeta.html), [tmcorr](https://docs.dolphindb.com/en/Functions/t/tmcorr.html), [tmwavg](https://docs.dolphindb.com/en/Functions/t/tmwavg.html), [tmwsum](https://docs.dolphindb.com/en/Functions/t/tmwsum.html), [tmoving](https://docs.dolphindb.com/en/Functions/Templates/tmoving.html), [moving](https://docs.dolphindb.com/en/Functions/Templates/moving.html), [sma](https://docs.dolphindb.com/en/Functions/s/sma.html), [wma](https://docs.dolphindb.com/en/Functions/w/wma.html), [dema](https://docs.dolphindb.com/en/Functions/d/dema.html), [tema](https://docs.dolphindb.com/en/Functions/t/tema.html), [trima](https://docs.dolphindb.com/en/Functions/t/trima.html), [linearTimeTrend](https://docs.dolphindb.com/en/Functions/l/linearTimeTrend.html), [talib](https://docs.dolphindb.com/en/Functions/Templates/talib.html), [t3](https://docs.dolphindb.com/en/Functions/t/t3.html), [ma](https://docs.dolphindb.com/en/Functions/m/ma.html), [mmaxPositiveStreak](https://docs.dolphindb.com/en/Functions/m/mmaxPositiveStreak.html)\n\n* row-based function: [rowMin](https://docs.dolphindb.com/en/Functions/r/rowMin.html), [rowMax](https://docs.dolphindb.com/en/Functions/r/rowMax.html), [rowAnd](https://docs.dolphindb.com/en/Functions/r/rowAnd.html), [rowOr](https://docs.dolphindb.com/en/Functions/r/rowOr.html), [rowXor](https://docs.dolphindb.com/en/Functions/r/rowXor.html), [rowProd](https://docs.dolphindb.com/en/Functions/r/rowProd.html), [rowSum](https://docs.dolphindb.com/en/Functions/r/rowSum.html), [rowSum2](https://docs.dolphindb.com/en/Functions/r/rowSum2.html), [rowSize](https://docs.dolphindb.com/en/Functions/r/rowSize.html), [rowCount](https://docs.dolphindb.com/en/Functions/r/rowCount.html), [rowAvg](https://docs.dolphindb.com/en/Functions/r/rowAvg.html), [rowKurtosis](https://docs.dolphindb.com/en/Functions/r/rowKurtosis.html), [rowSkew](https://docs.dolphindb.com/en/Functions/r/rowSkew.html), [rowVar](https://docs.dolphindb.com/en/Functions/r/rowVar.html), [rowVarp](https://docs.dolphindb.com/en/Functions/r/rowVarp.html), [rowStd](https://docs.dolphindb.com/en/Functions/r/rowStd.html), [rowStdp](https://docs.dolphindb.com/en/Functions/r/rowStdp.html)\n\n* order-sensitive function: [deltas](https://docs.dolphindb.com/en/Functions/d/deltas.html), [ratios](https://docs.dolphindb.com/en/Functions/r/ratios.html), [ffill](https://docs.dolphindb.com/en/Functions/f/ffill.html), [move](https://docs.dolphindb.com/en/Functions/m/move.html), [prev](https://docs.dolphindb.com/en/Functions/p/prev.html), [iterate](https://docs.dolphindb.com/en/Functions/i/iterate.html), [ewmMean](https://docs.dolphindb.com/en/Functions/e/ewmMean.html), [ewmVar](https://docs.dolphindb.com/en/Functions/e/ewmVar.html), [ewmStd](https://docs.dolphindb.com/en/Functions/e/ewmStd.html), [ewmCov](https://docs.dolphindb.com/en/Functions/e/ewmCov.html), [ewmCorr](https://docs.dolphindb.com/en/Functions/e/ewmCorr.html), [prevState](https://docs.dolphindb.com/en/Functions/p/prevState.html), [percentChange](https://docs.dolphindb.com/en/Functions/p/percentChange.html)\n\n* topN function: [msumTopN](https://docs.dolphindb.com/en/Functions/m/msumTopN.html), [mavgTopN](https://docs.dolphindb.com/en/Functions/m/mavgTopN.html), [mstdpTopN](https://docs.dolphindb.com/en/Functions/m/mstdpTopN.html), [mstdTopN](https://docs.dolphindb.com/en/Functions/m/mstdTopN.html), [mvarpTopN](https://docs.dolphindb.com/en/Functions/m/mvarpTopN.html), [mvarTopN](https://docs.dolphindb.com/en/Functions/m/mvarTopN.html), [mcorrTopN](https://docs.dolphindb.com/en/Functions/m/mcorrTopN.html), [mbetaTopN](https://docs.dolphindb.com/en/Functions/m/mbetaTopN.html), [mcovarTopN](https://docs.dolphindb.com/en/Functions/m/mcovarTopN.html), [mwsumTopN](https://docs.dolphindb.com/en/Functions/m/mwsumTopN.html),[cumwsumTopN](https://docs.dolphindb.com/en/Functions/c/cumwsumTopN.html), [cumsumTopN](https://docs.dolphindb.com/en/Functions/c/cumsumTopN.html), [cumvarTopN](https://docs.dolphindb.com/en/Functions/c/cumvarTopN.html), [cumvarpTopN](https://docs.dolphindb.com/en/Functions/c/cumvarpTopN.html),[cumstdTopN](https://docs.dolphindb.com/en/Functions/c/cumstdTopN.html), [cumstdpTopN](https://docs.dolphindb.com/en/Functions/c/cumstdpTopN.html), [cumcorrTopN](https://docs.dolphindb.com/en/Functions/c/cumcorrTopN.html), [cumbetaTopN](https://docs.dolphindb.com/en/Functions/c/cumbetaTopN.html),[cumavgTopN](https://docs.dolphindb.com/en/Functions/c/cumavgTopN.html), [cumskewTopN](https://docs.dolphindb.com/en/Functions/c/cumskewTopN.html), [cumkurtosisTopN](https://docs.dolphindb.com/en/Functions/c/cumkurtosisTopN.html), [mskewTopN](https://docs.dolphindb.com/en/Functions/m/mskewTopN.html), [mkurtosisTopN](https://docs.dolphindb.com/en/Functions/m/mkurtosisTopN.html), [tmsumTopN](https://docs.dolphindb.com/en/Functions/t/tmsumTopN.html), [tmavgTopN](https://docs.dolphindb.com/en/Functions/t/tmavgTopN.html), [tmstdTopN](https://docs.dolphindb.com/en/Functions/t/tmstdTopN.html), [tmstdpTopN](https://docs.dolphindb.com/en/Functions/t/tmstdpTopN.html), [tmvarTopN](https://docs.dolphindb.com/en/Functions/t/tmvarTopN.html), [tmvarpTopN](https://docs.dolphindb.com/en/Functions/t/tmvarpTopN.html), [tmskewTopN](https://docs.dolphindb.com/en/Functions/t/tmskewTopN.html), [tmkurtosisTopN](https://docs.dolphindb.com/en/Functions/t/tmkurtosisTopN.html), [tmbetaTopN](https://docs.dolphindb.com/en/Functions/t/tmbetaTopN.html), [tmcorrTopN](https://docs.dolphindb.com/en/Functions/t/tmcorrTopN.html), [tmcovarTopN](https://docs.dolphindb.com/en/Functions/t/tmcovarTopN.html), [tmwsumTopN](https://docs.dolphindb.com/en/Functions/t/tmwsumTopN.html)\n\n* higher-order function: [segmentby](https://docs.dolphindb.com/en/Functions/Templates/segmentby.html) (whose parameter *func* can only take cumsum, cummax, cummin, cumcount, cumavg, cumstd, cumvar, cumstdp, cumvarp), [moving](https://docs.dolphindb.com/en/Functions/Templates/moving.html), [byColumn](https://docs.dolphindb.com/en/Functions/Templates/byColumn.html), [accumulate](https://docs.dolphindb.com/en/Functions/Templates/accumulate.html), [window](https://docs.dolphindb.com/en/Functions/Templates/window.html)\n\n* others: [talibNull](https://docs.dolphindb.com/en/Functions/t/talibNull.html), [topRange](https://docs.dolphindb.com/en/Functions/t/topRange.html), [lowRange](https://docs.dolphindb.com/en/Functions/l/lowRange.html), [trueRange](https://docs.dolphindb.com/en/Functions/t/trueRange.html)\n\n* functions that can only be used in the reactive state engine: [stateIterate](https://docs.dolphindb.com/en/Functions/s/stateIterate.html), [conditionalIterate](https://docs.dolphindb.com/en/Functions/c/conditionalIterate.html), [genericStateIterate](https://docs.dolphindb.com/en/Functions/g/genericStateIterate.html), [genericTStateIterate](https://docs.dolphindb.com/en/Functions/g/genericTStateIterate.html)\n\nNote: If function `talib` is used as a state function, the first parameter *func* must be a state function.\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n##### Calculation Rules\n\nThe reactive state engine outputs a result for each input. If multiple records are ingested into the reactive state engine at the same time, the data is calculated in batches. The number of records in each batch is determined by the system.\n\n* To output only the results that met the specified conditions, set the parameter *filter*;\n\n* To perform calculations by group, set the parameter *keyColumn*;\n\n* To preserve the insertion order of the records in the output table, set the parameter *keepOrder*.\n\n##### Features\n\n* State cleanup: States in the engine are maintained by group. A large number of groups may lead to high memory overhead, and you can set a cleanup rule to clear data that are no longer needed. (See parameters *keyPurgeFilter* and *keyPurgeFreInSecond*)\n\n* Snapshot: Snapshot mechanism is used to restore the streaming engine to the latest snapshot after system interruption. (See parameters *snapshotDir* and *snapshotIntervalInMsgCount*)\n\n* High availability: To enable high availability for streaming engines, specify the parameter *raftGroup* on the leader of the raft group on the subscriber. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table.\n\n#### Arguments\n\n**name** is a string of the engine name. It is the only identifier of a reactive state engine on a data/compute node. It can have letter, number and \"\\_\" and must start with a letter.\n\n**metrics** is metacode specifying the formulas for calculation. The metacode can include one or more expressions, built-in or user-defined functions, or a constant scalar/vector. Note that the output column for a constant vector must be in array vector form. For more information about metacode refer to [Metaprogramming](https://docs.dolphindb.cn/en/Programming/Metaprogramming/MetacodeWithFunction.html). To use a user-defined function in the reactive state engine,\n\n(1) Add `@state` to declare the function before the definition. For state functions, the following statements are supported:\n\n* Assignment and return statements\n\n* `if...else` statements with scalar expressions (since 1.30.21/2.00.9)\n\n* `for` loops, including `break` and `continue` (since 1.30.23/2.00.11). Loop iterations must be under 100 times. Nested `for` loops are currently unsupported.\n\n(2) Stateless or state functions can be used in a reactive state engine, but the *metrics* parameter cannot be specified as the stateless function nesting with the state function.\n\n(3) If the rvalue of an assignment statement is a built-in or user-defined function that returns multiple values, the values must be assigned to variables at the same time. In the following example, the user-defined state function references linearTimeTrend, which returns two values.\n\n```\n@state\ndef forcast2(S, N){\n\tlinearregIntercept, linearregSlope = linearTimeTrend(S, N)\n\treturn (N - 1) * linearregSlope + linearregIntercept\n}\n```\n\nNote: The column names specified in *metrics* are not case-sensitive and can be inconsistent with the column names of the input tables.\n\n**dummyTable** is a table object whose schema must be the same as the subscribed stream table. Whether dummyTable contains data does not matter.\n\n**outputTable** is the output table for the results. It can be an in-memory table or a DFS table. Create an empty table and specify the column names and types before calling the function.\n\nThe output columns are in the following order:\n\n(1) If *keyColumn* is specified, the first few columns must match its order.\n\n(2) If the *outputElapsedMicroseconds* is set to true, specify two more columns: a LONG column for elapsed time of each batch and an INT column for total records in each batch.\n\n(3) Then followed by one or more result columns.\n\n**keyColumn** (optional) is a STRING scalar/vector indicating the grouping column(s). The calculation is conducted within each group.\n\n**filter** (optional) is the metacode that indicates the filtering conditions. A filtering condition must be an expression and only columns of *dummyTable*can be included. You can specify multiple conditions with logical operators (and, or). Only the results that satisfy the filter conditions are ingested to the output table.\n\nTo enable snapshot in the streaming engines, specify parameters *snapshotDir* and *snapshotIntervalInMsgCount*.\n\n**snapshotDir** (optional) is a string indicating the directory where the streaming engine snapshot is saved. The directory must already exist, otherwise an exception is thrown. If *snapshotDir* is specified, the system checks whether a snapshot already exists in the directory when creating a streaming engine. If it exists, the snapshot will be loaded to restore the engine state. Multiple streaming engines can share a directory where the snapshot files are named as the engine names.\n\nThe file extension of a snapshot can be:\n\n* *\\<engineName>.tmp*: temporary snapshot\n\n* *\\<engineName>.snapshot*: a snapshot that is generated and flushed to disk\n\n* *\\<engineName>.old*: if a snapshot with the same name already exists, the previous snapshot is renamed to *\\<engineName>.old*.\n\n**snapshotIntervalInMsgCount** (optional) is a positive integer indicating the number of messages to receive before the next snapshot is saved.\n\n**keepOrder** (optional) specifies whether to preserve the insertion order of the records in the output table. If *keyColumn* contains a time column, the default value is true, and otherwise false.\n\nTo clean up the data that is no longer needed after calculation, specify parameters *keyPurgeFilter* and *keyPurgeFreqInSecond*.\n\n**keyPurgeFilter** (optional) indicates the filtering conditions that identify the data to be purged from the cache. It is metacode composed of conditional expressions, and these expressions must refer to the columns in the *outputTable*. *keyPurgeFilter* is effective only when *keyColumn* is specified.\n\n**keyPurgeFreqInSecond** (optional) is a positive integer indicating the time interval (in seconds) to trigger a purge. *keyPurgeFreqInSecond* is effective only when *keyColumn* is specified.\n\nFor each data ingestion, the engine starts a purge if all of the following conditions are satisfied:\n\n(1) The time elapsed since the last data ingestion is equal to or greater than *keyPurgeFreqInSecond* (For the first check, the time elapsed between the ingestion of data and the creation of the engine is used);\n\n(2) If the first condition is satisfied, the engine applies *keyPurgeFilter* to the cached data to get the data to be purged.\n\n(3) The number of groups which contain data to be purged is equal to or greater than 10% of the total number of groups in the engine.\n\nTo check the engine status before and after the purge, call `getStreamEngineStat().ReactiveStreamEngine` (see [getStreamEngineStat](https://docs.dolphindb.com/en/Functions/g/getStreamEngineStat.html)) where the *numGroups* field indicates the number of groups in the reactive state streaming engine.\n\n**raftGroup** (optional) is an integer greater than 1, indicating ID of the raft group on the high-availability streaming subscriber specified by the configuration parameter *streamingRaftGroups*. Specify *raftGroup* to enable high availability for the streaming engine. When an engine is created on the leader, it is also created on each follower and the engine snapshot is synchronized to the followers. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table. Note that *SnapShotDir* must also be specified when specifying a raft group.\n\n**outputElapsedMicroseconds** (optional) is a Boolean value. The default value is false. It determines whether to output:\n\n* the elapsed time (in microseconds) from the ingestion of data to the output of result in each batch.\n\n* the total number of each batch.\n\nIf specified, two additional columns must be added to the output table (see *outputTable*).\n\n**keyCapacity** (optional) is a positive integer indicating the amount of memory allocated for buffering state of each group (defined by *keyColumn*) on a row basis. The default value is 1024. For data with large amount of groups, setting of this parameter can reduce the latency that may occur.\n\n**parallelism** (optional) is a positive integer no greater than 63, indicating the maximum number of workers that can run in parallel. The default value is 1. For large computation workloads, reasonable adjustment of this parameter can effectively utilize computing resources and reduce computation time.\n\n**Note**: *parallelism* cannot exceed the lesser of the numbers of licensed cores and logical cores minus one.\n\n**outputHandler** (optional) is a unary function or a partial function with a single unfixed parameter. If set, the engine will not write the calculation results to the output table directly. Instead, the results will be passed as a parameter to the *outputHandler* function. The default value is NULL, which means the result will be written to the output table.\n\n**msgAsTable** (optional) is a Boolean scalar indicating whether the output data is passed into function (specified by *outputHandler*) as a table or as a tuple. If *msgAsTable*=true, the subscribed data is passed into function as a table. The default value is false, which means the output data is passed into function as a tuple of columns.\n\n#### Examples\n\nExample 1.\n\n```\ndef sum_diff(x, y){\n     return (x-y)/(x+y)\n}\n\nfactor1 = <ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) -  ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)>\nshare streamTable(1:0, `sym`time`price, [STRING,DATETIME,DOUBLE]) as tickStream\nshare table(1000:0, `sym`time`factor1, [STRING,DATETIME,DOUBLE]) as result\nrse = createReactiveStateEngine(name=\"reactiveDemo\", metrics =[<time>, factor1], dummyTable=tickStream, outputTable=result, keyColumn=\"sym\", filter=<sym in [\"000001.SH\", \"000002.SH\"]>)\nsubscribeTable(tableName=`tickStream, actionName=\"factors\", handler=tableInsert{rse})\n\ndata1 = table(take(\"000001.SH\", 100) as sym, 2021.02.08T09:30:00 + 1..100 *3 as time, 10+cumsum(rand(0.1, 100)-0.05) as price)\ndata2 = table(take(\"000002.SH\", 100) as sym, 2021.02.08T09:30:00 + 1..100 *3 as time, 20+cumsum(rand(0.2, 100)-0.1) as price)\ndata3 = table(take(\"000003.SH\", 100) as sym, 2021.02.08T09:30:00 + 1..100 *3 as time, 30+cumsum(rand(0.3, 100)-0.15) as price)\ndata = data1.unionAll(data2).unionAll(data3).sortBy!(`time)\n\nreplay(inputTables=data, outputTables=tickStream, timeColumn=`time)\n\n// Execute the following code before re-run the above code.\nunsubscribeTable(tableName=`tickStream, actionName=\"factors\")\ndropStreamEngine(`reactiveDemo)\nundef(`tickStream, SHARED)\n```\n\nThe result only contains the stocks \"000001.SH\" and \"000002.SH\" that are specified in the filtering condition.\n\nExecute the following code before re-run the above code.\n\n```\nunsubscribeTable(tableName=`tickStream, actionName=\"factors\")\ndropStreamEngine(`reactiveDemo) undef(`tickStream, SHARED)\n```\n\nExample 2. Calculate in groups by date and sym column. Then output the result which time is between \"2012.01.01\" and \"2012.01.03\".\n\n```\nshare streamTable(1:0, `date`time`sym`market`price`qty, [DATE, TIME, SYMBOL, CHAR, DOUBLE, INT]) as trades\nshare table(100:0, `date`sym`factor1, [DATE, STRING, DOUBLE]) as outputTable\nengine = createReactiveStateEngine(name=\"test\", metrics=<mavg(price, 3)>, dummyTable=trades, outputTable=outputTable, keyColumn=[\"date\",\"sym\"], filter=<date between 2012.01.01 : 2012.01.03>, keepOrder=true)\nsubscribeTable(tableName=`trades, actionName=\"test\", msgAsTable=true, handler=tableInsert{engine})\n\nn=100\ntmp = table(rand(2012.01.01..2012.01.10, n) as date, rand(09:00:00.000..15:59:59.999, n) as time, rand(\"A\"+string(1..10), n) as sym, rand(['B', 'S'], n) as market, rand(100.0, n) as price, rand(1000..2000, n) as qty)\ntrades.append!(tmp)\nselect * from outputTable\n```\n\nExample 3. Since version 2.00.9, higher-order function `moving` can be called in the reactive state engine to calculate array vectors.\n\n```\ndefg myFactor(x){\n    return avg(var(x));\n}\nshare streamTable(1:0, `DateTime`SecurityID`Trade, [TIMESTAMP, SYMBOL, DOUBLE[]]) as tickStream\nshare table(1000:0, `SecurityID`DateTime`result, [SYMBOL, DATETIME, DOUBLE]) as result\nrse = createReactiveStateEngine(name=\"reactiveDemo\", metrics =<[DateTime, moving(myFactor, Trade, 3, 1)]>, dummyTable=tickStream, outputTable=result, keyColumn=\"SecurityID\")\nDateTime = 2022.09.15T09:00:00.000+1..12\nSecurityID = take(`600021, 12)\nTrade = [[10.06, 10.06], [10.04], [10.05, 10.06, 10.05, 10.08],[10.02,10.01], [10.06, 10.06, 10.05, 10.05], [10.04], [10.05,10.08, 10.09],[10.02,10.01],[10.06, 10.06, 10.05], [10.04, 10.03], [10.05, 10.06, 10.05, 10.08, 10.09],[10.02]]\nt = table(1:0, `DateTime`SecurityID`Trade, [TIMESTAMP, SYMBOL, DOUBLE[]])\ntableInsert(t, DateTime, SecurityID, Trade)\nrse.append!(t)\nselect * from result\ndropStreamEngine(\"reactiveDemo\")\n```\n\nExample 4. Define a constant in metrics indicating the factor name based on the above example.\n\n```\ndefg myFactor(x){\n   return avg(var(x));\n}\nshare streamTable(1:0, `DateTime`SecurityID`Trade, [TIMESTAMP, SYMBOL, DOUBLE[]]) as tickStream\nshare table(1000:0, `SecurityID`DateTime`factorName`result, [SYMBOL, DATETIME, STRING, DOUBLE]) as result\nrse = createReactiveStateEngine(name=\"reactiveDemo\", metrics =<[DateTime,\"factor1\", moving(myFactor, Trade, 3, 1)]>, dummyTable=tickStream, outputTable=result, keyColumn=\"SecurityID\")\nDateTime = 2022.09.15T09:00:00.000+1..12\nSecurityID = take(`600021, 12)\nTrade = [[10.06, 10.06], [10.04], [10.05, 10.06, 10.05, 10.08],[10.02,10.01], [10.06, 10.06, 10.05, 10.05], [10.04], [10.05,10.08, 10.09],[10.02,10.01],[10.06, 10.06, 10.05], [10.04, 10.03], [10.05, 10.06, 10.05, 10.08, 10.09],[10.02]]\nt = table(1:0, `DateTime`SecurityID`Trade, [TIMESTAMP, SYMBOL, DOUBLE[]])\ntableInsert(t, DateTime, SecurityID, Trade)\nrse.append!(t)\nselect * from result\n```\n\n<table id=\"table_akr_4bj_zbc\"><tbody><tr><td>\n\nSecurityID\n\n</td><td>\n\nDateTime\n\n</td><td>\n\nfactorName\n\n</td><td>\n\nresult\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0001\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0002\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0006\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0004\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0004\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0003\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.001\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0007\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0004\n\n</td></tr></tbody>\n</table>\n"
    },
    "createReactiveStatelessEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createReactiveStatelessEngine.html",
        "signatures": [
            {
                "full": "createReactiveStatelessEngine(name, metrics, outputTable)",
                "name": "createReactiveStatelessEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    }
                ]
            }
        ],
        "markdown": "### [createReactiveStatelessEngine](https://docs.dolphindb.com/en/Functions/c/createReactiveStatelessEngine.html)\n\n#### Syntax\n\ncreateReactiveStatelessEngine(name, metrics, outputTable)\n\n#### Details\n\nThis function creates a reactive stateless engine and returns a table object with the following schema:\n\n| Column Name | Type   |\n| ----------- | ------ |\n| productName | STRING |\n| metricName  | STRING |\n| value       | DOUBLE |\n\nWriting to the table means that data is ingested into the engine for calculation. The reactive stateless engine supports defining dependencies for dynamic calculations.\n\n#### Calculation Rules\n\nThe reactive stateless engine processes each batch of input data and calculates formulas as defined in *metrics*. Once a precedent value (referred to by a metric) is ingested or updated, all dependent formulas are output accordingly. The calculation is based on the latest variable values.\n\n#### Arguments\n\n**name** is a string of the engine name. It is the only identifier of a reactive state engine on a data/compute node. It can have letter, number and \"\\_\" and must start with a letter.\n\n**metrics** is a vector of dictionaries, specifying the calculation formulas and their dependencies. Each dictionary has the following key-value pairs:\n\n* \"outputName\"->productName:metricName\n\n* \"formula\"->\\<expression>\n\n  The value of *formula*is a metacode expression defining the formula for calculation, which can reference other variables. For example, the expression can be `<A*B>`, and A and B are precedent variables for this formula.\n\n* Key-value pairs specifying the precedent variable locations used in the *formula*above. For exmaple, for `<A*B>`, specify:\n\n  * \"A\"->productName:metricName\n  * \"B\"->productName:metricName\n    The *productName*and *metricName*uniquely specify the location of the variable, which can be the input or output table.\n\n**outputTable** is the output table for the results. It can be an in-memory table or a DFS table. Create an empty table and specify the column names and types before calling the function.\n\nThe output columns are in the following order:\n\n* productName: STRING or SYMBOL type, as defined in *metrics*.\n* metricName: STRING or SYMBOL type, as defined in *metrics*.\n* A column of DOUBLE or FLOAT type storing calculation results of *formula*defined in *metrics*.\n\n#### Examples\n\n| productName | metricName | value |\n| ----------- | ---------- | ----- |\n| product\\_A  | factor1    | 1     |\n| product\\_A  | factor2    | 2     |\n| product\\_B  | factor1    | 1     |\n| product\\_B  | value      | 4     |\n| product\\_C  | factor1    | 2     |\n| product\\_C  | value      | 8     |\n\nFor a table as above, factors (e.g., product\\_A:factor1) are ingested into the table, and values are calculated based on other variables:\n\n* product\\_B:value=product\\_A:factor1+product\\_A:factor2+product\\_B:factor1\n\n* product\\_C:value=product\\_B:value\\*product\\_C:factor1\n\nBased on the above information, create a reactive stateless engine:\n\n```\n// create output table\nnames = `product`metric`value\ntypes = [STRING, STRING, DOUBLE]\nshare table(1:0, names, types) as outputTable\n\n// define metrics\nmetrics = array(ANY, 0, 0)\nmetric1 = dict(STRING,ANY)\n// product_B:factor2=product_A:factor1+product_A:factor2+product_B:factor1\nmetric1[\"outputName\"] = `product_B:`value\nmetric1[\"formula\"] = <A+B+C>\nmetric1[\"A\"] = `product_A:`factor1\nmetric1[\"B\"] = `product_A:`factor2\nmetric1[\"C\"] = `product_B:`factor1\nmetrics.append!(metric1)\n// product_C:value=product_B:value*product_C:factor1\nmetric2 = dict(STRING, ANY)\nmetric2[\"outputName\"] =`product_C:`value\nmetric2[\"formula\"] = <A*B>\nmetric2[\"A\"] = `product_B:`value \nmetric2[\"B\"] = `product_C:`factor1\nmetrics.append!(metric2)\n\n// create engine\nengine1 = createReactiveStatelessEngine(\"engine1\", metrics, outputTable)\n```\n\n(1) Ingest 2 records to the engine. The dependent values cannot be calculated yet since the precedent variables are not enough. Empty results are returned.\n\n```\ninsert into engine1 values([\"product_A\",\"product_A\"],[\"factor1\",\"factor2\"],[1,2])\noutputTable\n```\n\n| product    | metric | value |\n| ---------- | ------ | ----- |\n| product\\_B | value  |       |\n| product\\_C | value  |       |\n\n(2) Then ingest 1 record for product\\_B:factor1, and the first dependent value can be calculated.\n\n```\ninsert into engine1 values(\"product_B\",\"factor1\",1)\noutputTable\n```\n\n<table id=\"table_nsd_5vx_2bc\"><tbody><tr><td>\n\nproduct\n\n</td><td>\n\nmetric\n\n</td><td>\n\nvalue\n\n</td></tr><tr><td>\n\nproduct\\_B\n\n</td><td>\n\nvalue\n\n</td><td>\n\n</td></tr><tr><td>\n\nproduct\\_C\n\n</td><td>\n\nvalue\n\n</td><td>\n\n</td></tr><tr><td>\n\nproduct\\_B\n\n</td><td>\n\nvalue\n\n</td><td>\n\n4\n\n</td></tr><tr><td>\n\nproduct\\_C\n\n</td><td>\n\nvalue\n\n</td><td>\n\n</td></tr></tbody>\n</table>\\(3\\) Ingest 1 record for product\\_C:factor1, and the second dependent value can be calculated.\n\n```\ninsert into engine1 values(\"product_C\",\"factor1\",2)\noutputTable\n```\n\n| product    | metric | value |\n| ---------- | ------ | ----- |\n| product\\_B | value  |       |\n| product\\_C | value  |       |\n| product\\_B | value  | 4     |\n| product\\_C | value  |       |\n| product\\_C | value  | 8     |\n\n(4) Ingest 1 record which updates product\\_C:factor1 from 2 to 3. One new result for product\\_C:value is calculated.\n\n```\ninsert into engine1 values(\"product_C\",\"factor1\",3)\noutputTable\n```\n\n| product    | metric | value |\n| ---------- | ------ | ----- |\n| product\\_B | value  |       |\n| product\\_C | value  |       |\n| product\\_B | value  | 4     |\n| product\\_C | value  |       |\n| product\\_C | value  | 8     |\n| product\\_C | value  | 12    |\n\n(5) Once a record is updated, related calculation results are returned even if the results do not eventually change.\n\n```\ninsert into engine1 values([\"product_A\",\"product_A\"],[\"factor1\",\"factor2\"],[2,1])\noutputTable\n```\n\n| product    | metric | value |\n| ---------- | ------ | ----- |\n| product\\_B | value  |       |\n| product\\_C | value  |       |\n| product\\_B | value  | 4     |\n| product\\_C | value  |       |\n| product\\_C | value  | 8     |\n| product\\_C | value  | 12    |\n| product\\_B | value  | 4     |\n| product\\_C | value  | 12    |\n\n"
    },
    "createRuleEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createRuleEngine.html",
        "signatures": [
            {
                "full": "createRuleEngine(name, ruleSets, dummyTable, outputColumns, outputTable, [policy], [ruleSetColumn], [callback])",
                "name": "createRuleEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "ruleSets",
                        "name": "ruleSets"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputColumns",
                        "name": "outputColumns"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[policy]",
                        "name": "policy",
                        "optional": true
                    },
                    {
                        "full": "[ruleSetColumn]",
                        "name": "ruleSetColumn",
                        "optional": true
                    },
                    {
                        "full": "[callback]",
                        "name": "callback",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createRuleEngine](https://docs.dolphindb.com/en/Functions/c/createRuleEngine.html)\n\n\n\n#### Syntax\n\ncreateRuleEngine(name, ruleSets, dummyTable, outputColumns, outputTable, \\[policy], \\[ruleSetColumn], \\[callback])\n\n#### Details\n\nCreate a rule engine that supports multiple rule sets. When a record is ingested into the engine, the engine applies a specific rule based on its *ruleSetColumn*value. The rule sets can be dynamically added, modified, or deleted. This engine can be used to validate incoming data from multiple aspects for risk control.\n\nDifferent from the anomaly detection engine (`createAnomalyDetectionEngine`):\n\n* The rule engine is stateless while the anomaly detection engine is stateful.\n\n* The rule engine can apply different rules for different messages, while the anomaly detection engine applies a set of rule to all messages.\n\n* Only the rule engine supports dynamic addition, modification, or deletion of the rule sets.\n\n* Only the rule engine supports specifying a callback function for further processing on the check results.\n\n#### Arguments\n\n**name** is a string indicating the name of the engine.\n\n**ruleSets** is a dictionary specifying the rule sets. Its key is of STRING or INT type, and value is a tuple with metacode. It must contain a default rule set with a key of NULL.\n\n**dummyTable** is a table object whose schema must be the same as the subscribed stream table. Whether *dummyTable* contains data does not matter.\n\n**outputColumns** is a STRING vector indicating the input columns to be preserved in the output table.\n\n**outputTable** is a table to which the engine inserts calculation results. It can be an in-memory table or a DFS table. Create an empty table and specify the column names and types before calling the function.\n\nThe output columns are in the following order:\n\n(1) The first few are columns specified in *outputColumns*.\n\n(2) Then followed by a result column after applying the rule sets. When *policy*is set to \"shortcut\", this column is of INT type; otherwise it's of BOOL\\[] type.\n\n**policy**(optional) is a STRING scalar indicating the checking policy of rule sets. It can take the following values:\n\n* shortcut (default): When any check result is false, the corresponding index (which starts from 0) of the rule set is returned. Otherwise NULL is returned.\n\n* all: Check all specified rules and return an array vector of BOOLEAN type, its elements are the checking results for each rule set.\n\n**ruleSetColumn**(optional) is a STRING scalar indicating an input column name. If it is not set, or the specified column does not match any rule set, then the default rule set is applied.\n\n**callback** (optional) is a function which takes a table as input. The table contains a record output by the engine. If specified, the callback function is invoked with each output passed in as an argument. If not specified, the engine will only insert the checking results into the output table.\n\n#### Examples\n\n```\n// define rule sets\nx = [1, 2, NULL]\ny = [ [ < value > 1 > ], [ < price < 2 >, < price > 6 > ], [ < value*price > 10 > ] ]\nruleSets = dict(x, y)\n\n// create a DFS table to write results to the callback function\ndb = database(\"dfs://temp\", VALUE, 1..3)\nt1 = table(1:0, `sym`value`price, [INT,DOUBLE,DOUBLE])\npt = db.createPartitionedTable(t1,`pt,`sym)\n\n// create callback function\ndef writeBack(result){\n    if(result.rule[0]==false){\n        temp = select sym,value,price from result\n        loadTable(\"dfs://temp\",`pt).append!(temp)\n    }\n}\n\n// create a rule engine\nnames = `sym`value`price`quantity\ntypes = [INT, DOUBLE, DOUBLE, DOUBLE]\ndummy = table(1:0, names, types)\noutputNames = `sym`value`price`rule\noutputTypes = [INT, DOUBLE, DOUBLE, BOOL[]]\nshare table(10:0, outputNames, outputTypes) as outputTable\ntest = createRuleEngine(name=\"ruleEngineTest\", ruleSets=ruleSets, dummyTable=dummy, outputColumns=[\"sym\",\"value\",\"price\"], outputTable=outputTable, policy=\"all\", ruleSetColumn=\"sym\", callback=writeBack)\n\n// When sym=1, check whether value > 1\ntest.append!(table(1 as sym, 0 as value, 2 as price, 3 as quantity))\ntest.append!(table(1 as sym, 2 as value, 2 as price, 3 as quantity))\n\n// When sym=2, check whether value price < 2 and price > 6\ntest.append!(table(2 as sym, 2 as value, 0 as price, 3 as quantity))\ntest.append!(table(2 as sym, 2 as value, 4 as price, 3 as quantity))\ntest.append!(table(2 as sym, 2 as value, 8 as price, 3 as quantity))\n\n// When sym is not 1 or 2, check whether value*price > 10\ntest.append!(table(3 as sym, 2 as value, 3 as price, 3 as quantity))\ntest.append!(table(3 as sym, 2 as value, 6 as price, 3 as quantity))\n```\n\noutputTable:\n\n| sym | value | price | rule           |\n| --- | ----- | ----- | -------------- |\n| 1   | 0     | 2     | \\[false]       |\n| 1   | 2     | 2     | \\[true]        |\n| 2   | 2     | 0     | \\[true,false]  |\n| 2   | 2     | 4     | \\[false,false] |\n| 2   | 2     | 8     | \\[false,true]  |\n| 3   | 2     | 3     | \\[false]       |\n| 3   | 2     | 6     | \\[true]        |\n\nCheck table \"dfs\\://temp/pt\" for the callback result:\n\n```\nselect * from loadTable(\"dfs://temp\",\"pt\")\n```\n\n| sym | value | price |\n| --- | ----- | ----- |\n| 1   | 0     | 2     |\n| 2   | 2     | 4     |\n| 2   | 2     | 8     |\n| 3   | 2     | 3     |\n\nRelated functions: [updateRule](https://docs.dolphindb.com/en/Functions/u/updateRule.html), [deleteRule](https://docs.dolphindb.com/en/Functions/d/deleteRule.html)\n"
    },
    "createSchema": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createSchema.html",
        "signatures": [
            {
                "full": "createSchema(catalog, dbUrl, schema)",
                "name": "createSchema",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    },
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    },
                    {
                        "full": "schema",
                        "name": "schema"
                    }
                ]
            }
        ],
        "markdown": "### [createSchema](https://docs.dolphindb.com/en/Functions/c/createSchema.html)\n\n#### Syntax\n\ncreateSchema(catalog, dbUrl, schema)\n\n#### Arguments\n\n**catalog**is a string specifying the catalog name.\n\n**dbUrl** is a string indicating the database URL.\n\n**schema** is a string indicating the schema name.\n\n#### Details\n\nAdd a database to a catalog. Note that a database can only be added to one catalog.\n\nThe *dbUrl*of a database is unique globally, while the schemas under difference catalogs can share the same names. When adding a database to a catalog, a schema name must be specified. Operations on this schema must use this name instead of *dbUrl*.\n\n#### Examples\n\n```\ncreateSchema(\"catalog1\", \"dfs://db1\", \"schema1\")\n```\n\n"
    },
    "createSessionWindowEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createSessionWindowEngine.html",
        "signatures": [
            {
                "full": "createSessionWindowEngine(name, sessionGap, metrics, dummyTable, outputTable, [timeColumn], [useSystemTime=false], [keyColumn], [updateTime], [useSessionStartTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup], [forceTriggerTime])",
                "name": "createSessionWindowEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "sessionGap",
                        "name": "sessionGap"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[updateTime]",
                        "name": "updateTime",
                        "optional": true
                    },
                    {
                        "full": "[useSessionStartTime=true]",
                        "name": "useSessionStartTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[forceTriggerTime]",
                        "name": "forceTriggerTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createSessionWindowEngine](https://docs.dolphindb.com/en/Functions/c/createSessionWindowEngine.html)\n\n\n\n#### Syntax\n\ncreateSessionWindowEngine(name, sessionGap, metrics, dummyTable, outputTable, \\[timeColumn], \\[useSystemTime=false], \\[keyColumn], \\[updateTime], \\[useSessionStartTime=true], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[raftGroup], \\[forceTriggerTime])\n\n#### Details\n\nThis function creates a session window streaming engine. The session window engine shares most of its parameters with the time-series engine ([createTimeSeriesEngine](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html)), but includes two unique parameters: *sessionGap* and *useSessionStartTime*.\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\nStarting from version 2.00.11, array vectors are allowed in *dummyTable*and *outputTable*, but they cannot be involved in calculations specified in *metrics*.\n\n#### Calculation Rules\n\nWhen records are ingested into a session window, the window remains open until a specified period of inactivity passes (specified by *sessionGap*). The window end is equal to the timestamp of the last received record + the *sessionGap* interval. The calculation of this window is triggered by the arrival of the next record after the window ends.\n\nNote: If *keyColumn* is specified to group data by the column values, the calculations described above will be performed within each group.\n\n#### Arguments\n\nAs most of the parameters of `createSessionWindowEngine` are identical with those of [createTimeSeriesEngine](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html), we only explain the following parameters of `createSessionWindowEngine` that are different from those of `createTimeSeriesEngine`.\n\n**sessionGap** a positive integer indicating the gap between 2 session windows. Its unit is determined by the parameter *useSystemTime*.\n\n**useSessionStartTime** (optional) is a Boolean value indicating whether the first column in *outputTable* is the starting time of the windows, i.e., the timestamp of the first record in each window. Setting it to false means the timestamps in the output table are the ending time of the windows, i.e., timestamp of the last record in window + *sessionGap*. If *updateTime* is specified, *useSessionStartTime* must be true.\n\n**forceTriggerTime** (optional) is a non-negative integer. Its unit is the same as the time precision of *timeColumn*. *forceTriggerTime* indicates the waiting time to force trigger calculation in uncalculated windows for each group.\n\n#### Examples\n\n```\nshare streamTable(1000:0, `time`sym`volume, [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output1\nengine_sw = createSessionWindowEngine(name = \"engine_sw\", sessionGap = 5, metrics = <sum(volume)>, dummyTable = trades, outputTable = output1, timeColumn = `time, keyColumn=`sym)\nsubscribeTable(tableName=\"trades\", actionName=\"append_engine_sw\", offset=0, handler=append!{engine_sw}, msgAsTable=true)\n\nn = 5\ntimev = 2018.10.12T10:01:00.000 + (1..n)\nsymv=take(`A`B`C,n)\nvolumev = (1..n)%1000\ninsert into trades values(timev, symv, volumev)\n\nn = 5\ntimev = 2018.10.12T10:01:00.010 + (1..n)\nvolumev = (1..n)%1000\nsymv=take(`A`B`C,n)\ninsert into trades values(timev, symv, volumev)\n\nn = 6\ntimev = 2018.10.12T10:01:00.020 + 1 2 3 8 14 20\nvolumev = (1..n)%1000\nsymv=take(`A`B`C,n)\ninsert into trades values(timev, symv, volumev)\n\nselect * from output1;\n```\n\n| time                    | sym | volume |\n| ----------------------- | --- | ------ |\n| 2018.10.12T10:01:00.001 | A   | 5      |\n| 2018.10.12T10:01:00.002 | B   | 7      |\n| 2018.10.12T10:01:00.003 | C   | 3      |\n| 2018.10.12T10:01:00.011 | A   | 5      |\n| 2018.10.12T10:01:00.012 | B   | 7      |\n| 2018.10.12T10:01:00.013 | C   | 3      |\n| 2018.10.12T10:01:00.021 | A   | 1      |\n| 2018.10.12T10:01:00.022 | B   | 2      |\n| 2018.10.12T10:01:00.023 | C   | 3      |\n\nSpecify *forceTriggerTime* as 1000. 1000 ms after the ingestion of the last record, calculation is triggered in all groups. Replace the engine creation statement with the following code:\n\n```\nengine_sw = createSessionWindowEngine(name = \"engine_sw\", sessionGap = 5, metrics = <sum(volume)>, dummyTable = trades, outputTable = output1, timeColumn = `time, keyColumn=`sym, forceTriggerTime=1000)\n```\n\nPrint the output table again. The result is as follows:\n\n| time                    | sym | volume |\n| ----------------------- | --- | ------ |\n| 2018.10.12T10:01:00.001 | A   | 5      |\n| 2018.10.12T10:01:00.002 | B   | 7      |\n| 2018.10.12T10:01:00.003 | C   | 3      |\n| 2018.10.12T10:01:00.011 | A   | 5      |\n| 2018.10.12T10:01:00.012 | B   | 7      |\n| 2018.10.12T10:01:00.013 | C   | 3      |\n| 2018.10.12T10:01:00.021 | A   | 1      |\n| 2018.10.12T10:01:00.022 | B   | 2      |\n| 2018.10.12T10:01:00.023 | C   | 3      |\n| 2018.10.12T10:01:00.028 | A   | 4      |\n| 2018.10.12T10:01:00.034 | B   | 5      |\n| 2018.10.12T10:01:00.040 | C   | 6      |\n"
    },
    "createStreamBroadcastEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createStreamBroadcastEngine.html",
        "signatures": [
            {
                "full": "createStreamBroadcastEngine(name, dummyTable, outputTables)",
                "name": "createStreamBroadcastEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTables",
                        "name": "outputTables"
                    }
                ]
            }
        ],
        "markdown": "### [createStreamBroadcastEngine](https://docs.dolphindb.com/en/Functions/c/createStreamBroadcastEngine.html)\n\n#### Syntax\n\ncreateStreamBroadcastEngine(name, dummyTable, outputTables)\n\n#### Details\n\n`createStreamBroadcastEngine` creates a stream broadcast engine that distributes the same data stream to different target tables. This function returns a table object, and by ingesting data to the table, multi-channel broadcasting of the streaming data is achieved.\n\nUse this engine when you need to process a single stream of data in multiple ways. For example, save one copy to disk while sending another copy to a computing engine for further processing.\n\n#### Arguments\n\n**name** is a string indicating the name of the engine. It is the only identifier of an engine on a data or compute node. It can have letter, number and \"\\_\" and must start with a letter.\n\n**dummyTable** is a table object whose schema must be the same as the subscribed stream table. Whether dummyTable contains data does not matter.\n\n**outputTables** is a tuple of two or more table objects (which can be in-memory tables, DFS tables, or streaming engines). The schema of each table object must be the same as *dummyTable*.\n\n#### Examples\n\n```\nshare streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream\nshare streamTable(1000:0, `sym`factor1, [STRING,DOUBLE]) as resultStream\n\nt=table(100:0, `sym`price, [STRING,DOUBLE])\n\n//define the output tables: a reactive state engine and a DFS table for storing data\nrse = createReactiveStateEngine(name=\"reactiveDemo\", metrics =<cumavg(price)>, dummyTable=tickStream, outputTable=resultStream, keyColumn=\"sym\")\nif(existsDatabase(\"dfs://database1\")){\n\tdropDatabase(\"dfs://database1\")\n}\ndb=database(\"dfs://database1\", VALUE, \"A\"+string(1..10))\npt=db.createPartitionedTable(t,`pt,`sym)\n\n//create the stream broadcast engine\nbroadcastEngine=createStreamBroadcastEngine(name=\"broadcastEngine\", dummyTable=tickStream, outputTables=[loadTable(\"dfs://database1\", `pt),getStreamEngine(\"reactiveDemo\")])\n\n//subscribe to the tickStream stream table\nsubscribeTable(tableName=`tickStream, actionName=\"sub\", handler=tableInsert{broadcastEngine}, msgAsTable = true)\n\n//ingest the subscribed data into the engine\nn=100000\nsymbols=take((\"A\" + string(1..10)),n)\nprices=100+rand(1.0,n)\nt1=table(symbols as sym, prices as price)\ntickStream.append!(t1)\n\n//check the number of records in the DFS table\nselect count(*) from loadTable(\"dfs://database1\", `pt)\n// output: 100,000\n\n//check the status of the reactive state streaming engine\ngetStreamEngineStat().ReactiveStreamEngine\n```\n\n<table id=\"table_xgz_qpr_5bc\"><thead><tr><th>\n\nname\n\n</th><th>\n\nuser\n\n</th><th>\n\nstatus\n\n</th><th>\n\nlastErrMsg\n\n</th><th>\n\nnumGroups\n\n</th><th>\n\nnumRows\n\n</th><th>\n\nnumMetrics\n\n</th><th>\n\nmemoryInUsed\n\n</th><th>\n\nsnapshotDir\n\n</th><th>\n\nsnapshotInterval\n\n</th><th>\n\nsnapshotMsgId\n\n</th><th>\n\nsnapshotTimestamp\n\n</th></tr></thead><tbody><tr><td>\n\nreactiveDemo\n\n</td><td>\n\nadmin\n\n</td><td>\n\nOK\n\n</td><td>\n\n10\n\n</td><td>\n\n100,000\n\n</td><td>\n\n1\n\n</td><td>\n\n2,600\n\n</td><td>\n\n-1\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr></tbody>\n</table>**Parent topic:**[Functions](../../Functions/category.md)\n"
    },
    "createStreamDispatchEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createStreamDispatchEngine.html",
        "signatures": [
            {
                "full": "createStreamDispatchEngine(name, dummyTable, keyColumn, outputTable, [dispatchType='hash'], [hashByBatch=false], [outputLock=true], [queueDepth=4096], [outputElapsedTime=false], [mode='buffer'])",
                "name": "createStreamDispatchEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[dispatchType='hash']",
                        "name": "dispatchType",
                        "optional": true,
                        "default": "'hash'"
                    },
                    {
                        "full": "[hashByBatch=false]",
                        "name": "hashByBatch",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[outputLock=true]",
                        "name": "outputLock",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[queueDepth=4096]",
                        "name": "queueDepth",
                        "optional": true,
                        "default": "4096"
                    },
                    {
                        "full": "[outputElapsedTime=false]",
                        "name": "outputElapsedTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[mode='buffer']",
                        "name": "mode",
                        "optional": true,
                        "default": "'buffer'"
                    }
                ]
            }
        ],
        "markdown": "### [createStreamDispatchEngine](https://docs.dolphindb.com/en/Functions/c/createStreamDispatchEngine.html)\n\n\n\n#### Syntax\n\ncreateStreamDispatchEngine(name, dummyTable, keyColumn, outputTable, \\[dispatchType='hash'], \\[hashByBatch=false], \\[outputLock=true], \\[queueDepth=4096], \\[outputElapsedTime=false], \\[mode='buffer'])\n\n#### Details\n\n`createStreamDispatchEngine` function creates a stream dispatch engine that distributes incoming data streams to specified output tables for computational load balancing. The output tables can be in-memory tables, DFS tables, or other streaming engines. The function returns a table object.\n\nKey characteristics of the stream dispatch engine:\n\n* Supports multithreaded input and output of streams.\n\n* Used only for data dispatching, not for metrics computing.\n\nTypical usage:\n\nThe stream dispatch engine can distribute market data to one or more computational streaming engines that calculate factors. This achieves optimal performance by balancing the computational load.\n\n#### Arguments\n\n**name** is a string indicating the name of the engine. It is the only identifier of an engine. It can contain letters, numbers and underscores but must start with a letter.\n\n**dummyTable** is a table whose schema must be the same as the stream table to which the engine subscribes. Whether *dummyTable* contains data does not matter.\n\n**keyColumn** is a string. If provided, the ingested data will be distributed to output tables based on the values in this column. Unique values in *keyColumn* are treated as keys.\n\n**outputTable** is one or more tables that the engine outputs data to. When *outputElapsedTime* = false, *outputTable* must have the same schema as *dummyTable*; when *outputElapsedTime* = true, *outputTable* should have two additional columns - a LONG column and an INT column (see *outputElapsedTime*).\n\nUp to 100 tables can be specified for *outputTable*. The engine starts a thread for each output table to process the distributed data. To specify multiple output tables, pass a tuple, embedding sub-tuples if needed. For examples:\n\n* To distribute evenly to 4 tables, specify `outputTable=[table1, table2, table3, table4]`\n\n* To distribute evenly to 2 replicated table sets, specify `[[table1_1, table1_2], [table2_1, table2_2]]`. This maintains 2 replicas of the ingested data - replica 1 distributed across table1\\_1 and table1\\_2, and replica 2 distributed across table2\\_1 and table2\\_2.\n\n**dispatchType** (optional) is a string. It can be:\n\n* \"hash\" (default) - Apply a hash algorithm on *keyColumn* and distribute records based on the hash result. Hash distribution can be uneven across tables.\n\n* \"uniform\" - Evenly distribute records across output tables based on *keyColumn* values.\n\n* \"saltedHash\" - Apply a salted hash algorithm on *keyColumn* and distribute records based on the hash result. Salting ensures unique hashes even with the same input. This option is more suitable for scenarios that involve multi-level hash distribution (e.g., a dispatch engine with all nested engines using hash for data distribution).\n\nThe default \"hash\" is recommended unless data distribution is highly uneven and impacts performance. In that case, try \"uniform\".\n\n**hashByBatch** (optional) is a Boolean value. The default is false, indicating that for each batch of data ingested into the engine, group records by *keyColumn* values first, then distribute groups across tables based on *dispatchType*.\n\nTo set *hashByBatch* to true, *dispatchType* must be 'hash'. In this case, for each ingested batch of data, the engine randomly selects a key, computes its hash value, and distributes the entire batch based on the hash result.\n\nNote: Setting *hashbyBatch* = false ensures that records with identical keys are output to the same table. However, grouping records by key adds processing cost.\n\n**outputLock** (optional) is a Boolean value indicating whether to apply a lock output table(s) to prevent concurrent write conflicts. The default is true (recommended). False means not to apply lock to the output table(s).\n\nAn output table, essentially an in-memory table, does not allow concurrent writes. As threads working for other streaming engines or subscriptions may also write to the output tables, the lock ensures thread safety. However, locking comes at a performance cost. If it can be guaranteed no other threads will write to the output tables concurrently, *outputLock* can be set to false to optimize performance.\n\n**queueDepth** (optional) is a positive integer controlling the queue or buffer size for each output thread. The default is 4096 (records).\n\n* When *mode* = \"buffer\", *queueDepth* sets the size of the cache table for each thread of an output table;\n\n* When *mode* = \"queue\", *queueDepth* sets the maximum depth of each output queue.\n\nSet *queueDepth* based on the expected data volume: if the ingested amount is small, a large *queueDepth* wastes memory; if the ingested amount is large, a small *queueDepth* may cause output blocking.\n\n**outputElapsedTime** (optional) is a Boolean value indicating whether to print the elapsed time to process each ingested batch, from ingestion to output. The default is false. If *outputElapsedTime* = true, two extra columns are added to each output table: a LONG column for the time elapsed in microseconds to process each data batch internally, and an INT column for nanosecond timestamps of when each batch was output.\n\n**mode** (optional) is a string. It can be:\n\n* \"buffer\" (default) - For each thread working for an output table, the engine creates an in-memory cache table to buffer pending writes. It copies data into the cache before writing to output table. Use this mode when (1) the input source(s) may have concurrent reads/writes while ingesting data into the engine; or (2) the input source(s) frequently appends small batches of data to the engine.\n\n* \"queue\" - For each thread working for an output table, the engine maintains a queue per with references to input data. Input data is not copied, only referenced. This requires no concurrent reads/writes to the input source(s) during ingestion. This mode is best when the input source(s) infrequently append large batches of data.\n\n#### Examples\n\nDistribute data of a stream table to 3 reactive state streaming engines for metric computation using the stream dispatch engine. The final results are output into one single table.\n\n```\n// define the input stream table for the stream dispatch engine\nshare streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream\nshare streamTable(1000:0, `sym`factor1, [STRING,DOUBLE]) as resultStream\n\n// define the output table for the reactive state engines\nfor(i in 0..2){\nrse = createReactiveStateEngine(name=\"reactiveDemo\"+string(i), metrics =<cumavg(price)>, dummyTable=tickStream, outputTable=resultStream, keyColumn=\"sym\")\n}\n// create the stream dispatch engine\ndispatchEngine=createStreamDispatchEngine(name=\"dispatchDemo\", dummyTable=tickStream, keyColumn=`sym, outputTable=[getStreamEngine(\"reactiveDemo0\"),getStreamEngine(\"reactiveDemo1\"),getStreamEngine(\"reactiveDemo2\")])\n\n// the stream dispatch engine subscribes to the stream table\nsubscribeTable(tableName=`tickStream, actionName=\"sub\", handler=tableInsert{dispatchEngine}, msgAsTable = true)\n    \n// ingest data to the stream dispatch engine\nn=100000\nsymbols=take((\"A\" + string(1..10)),n)\nprices=100+rand(1.0,n)\nt=table(symbols as sym, prices as price)\ntickStream.append!(t)\n\nselect count(*) from resultStream\n// output\n100,000\n\n// check the status of the reactive state engines\ngetStreamEngineStat().ReactiveStreamEngine\n```\n\n| name          | user  | status | lastErrMsg | numGroups | numRows | numMetrics | memoryInUsed | snapshotDir | snapshotInterval | snapshotMsgId | snapshotTimestamp |\n| ------------- | ----- | ------ | ---------- | --------- | ------- | ---------- | ------------ | ----------- | ---------------- | ------------- | ----------------- |\n| reactiveDemo2 | admin | OK     | 1          | 10,000    | 1       | 921        | -1           |             |                  |               |                   |\n| reactiveDemo1 | admin | OK     | 5          | 50,000    | 1       | 1,437      | -1           |             |                  |               |                   |\n| reactiveDemo0 | admin | OK     | 4          | 40,000    | 1       | 1,308      | -1           |             |                  |               |                   |\n"
    },
    "createTable": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createTable.html",
        "signatures": [
            {
                "full": "createDimensionTable(dbHandle, table, tableName, [compressMethods], [sortColumns|primaryKey], [keepDuplicates=ALL], [softDelete=false], [indexes])",
                "name": "createDimensionTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[compressMethods]",
                        "name": "compressMethods",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns|primaryKey]",
                        "name": "[sortColumns|primaryKey]"
                    },
                    {
                        "full": "[keepDuplicates=ALL]",
                        "name": "keepDuplicates",
                        "optional": true,
                        "default": "ALL"
                    },
                    {
                        "full": "[softDelete=false]",
                        "name": "softDelete",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[indexes]",
                        "name": "indexes",
                        "optional": true
                    }
                ]
            },
            {
                "full": "createDimensionTable(dbHandle, table, tableName, [compressMethods], [sortColumns], [keepDuplicates=ALL], [softDelete=false])",
                "name": "createDimensionTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[compressMethods]",
                        "name": "compressMethods",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns]",
                        "name": "sortColumns",
                        "optional": true
                    },
                    {
                        "full": "[keepDuplicates=ALL]",
                        "name": "keepDuplicates",
                        "optional": true,
                        "default": "ALL"
                    },
                    {
                        "full": "[softDelete=false]",
                        "name": "softDelete",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createTable](https://docs.dolphindb.com/en/Functions/c/createTable.html)\n\nAlias for [createDimensionTable](https://docs.dolphindb.com/en/Functions/c/createDimensionTable.html)\n\n\nDocumentation for the `createDimensionTable` function:\n### [createDimensionTable](https://docs.dolphindb.com/en/Functions/c/createDimensionTable.html)\n\n\n\n#### Syntax\n\ncreateDimensionTable(dbHandle, table, tableName, \\[compressMethods], \\[sortColumns|primaryKey], \\[keepDuplicates=ALL], \\[softDelete=false], \\[indexes])\n\ncreateDimensionTable(dbHandle, table, tableName, \\[compressMethods], \\[sortColumns], \\[keepDuplicates=ALL], \\[softDelete=false])\n\nAlias: createTable\n\n#### Arguments\n\n**Note:** The parameters *sortColumns* and *keepDuplicates* take effect only in a TSDB storage engine (i.e., `database().engine` = TSDB).\n\n**dbHandle** is a DFS database handle returned by function [database](https://docs.dolphindb.com/en/Functions/d/database.html).\n\n**table** is a table object. The table schema will be used to construct the new dimension table.\n\n**tableName** is a string indicating the name of the dimension table.\n\n**compressMethods** (optional) is a dictionary indicating which compression methods are used for specified columns. The keys are columns name and the values are compression methods (\"lz4\", \"delta\", \"zstd\" or \"chimp\"). If unspecified, use LZ4 compression method.\n\nNote:\n\n* The delta compression method can be used for DECIMAL, SHORT, INT, LONG or temporal data types.\n* Save strings as SYMBOL type to enable compression of strings.\n* The chimp compression method can be used for DOUBLE type data with decimal parts not exceeding three digits in length.\n\n**sortColumns** (optional) is a STRING scalar/vector that specifies the column(s) used to sort the ingested data within each level file. The sort columns must be of Integral, Temporal, STRING, SYMBOL, or DECIMAL type. Note that *sortColumns* is not necessarily consistent with the partitioning column.\n\n* If multiple columns are specified for *sortColumns*, the last column must be a time column. The preceding columns are used as the sort keys and they cannot be of TIME, TIMESTAMP, NANOTIME, or NANOTIMESTAMP type.\n* If only one column is specified for *sortColumns*, the column is used as the sort key, and it can be a time column or not. If the sort column is a time column and *sortKeyMappingFunction* is specified, the sort column specified in a SQL where condition can only be compared with temporal values of the same data type.\n* It is recommended to specify frequently-queried columns for *sortColumns* and sort them in the descending order of query frequency, which ensures that frequently-used data is readily available during query processing.\n* The number of sort key entries (which are unique combinations of the values of the sort keys) may not exceed 1000 for optimal performance. This limitation prevents excessive memory usage and ensures efficient query processing.\n\n**primaryKey** (optional) is a STRING scalar/vector that specifies the primary key column(s), uniquely identifying each record in a DFS table of **the PKEY database**. For records with the same primary key, only the latest one is retained. Note that:\n\n* *primaryKey* must include all partitioning columns.\n* The primary key columns must be of Logical, Integral (excluding COMPRESSED), Temporal, STRING, SYMBOL, or DECIMAL type.\n* With more than one primary key column, a composite primary key is maintained. The composite primary key uses a Bloomfilter index by default (see the *indexes* parameter for details).\n\n**keepDuplicates** (optional) specifies how to deal with records with duplicate *sortColumns* values. It can have the following values:\n\n* ALL: keep all records;\n* LAST: only keep the last record;\n* FIRST: only keep the first record.\n\n**softDelete** (optional) determines whether to enable soft delete for TSDB databases. The default value is false. To use it, *keepDuplicates* must be set to 'LAST'. It is recommended to enable soft delete for databases where the row count is large and delete operations are infrequent.\n\n**indexes** (optional) is a dictionary with columns as keys and index types as values. Both keys and values are of STRING type. *indexes* can only be set for tables of PKEY databases.\n\n* Currently, only \"bloomfilter\" index type is available. Bloomfilter indexing excels in point queries on high-cardinality columns (e.g., ID card numbers, order numbers, foreign keys from upstreams).\n* It supports indexing on columns of the following data types: BOOL, CHAR, SHORT, INT, LONG, BLOB, STRING, DECIMAL32, DECIMAL64, DECIMAL128.\n* Composite primary keys are automatically indexed with Bloomfilter. Columns not specified in *indexes* default to ZoneMap indexing.\n\n#### Details\n\nThis function creates an empty dimension (non-partitioned) table in a DFS database, used to store small datasets with infrequent updates. During query, all data in a dimension table will be loaded into the memory.\n\nThe system will regularly check the memory usage. When memory usage exceeds *warningMemSize*, the system will discard the least recently used (LRU) data from memory to clean up the cache. Users can also manually call command `clearCachedDatabase` to clear the cached data.\n\nLike partitioned tables, a dimension table can have multiple replicas (determined by the configuration parameter *dfsReplicationFactor*).\n\nTo enable concurrent writes, updates or deletes on a dimension table, set the configuration parameter *enableConcurrentDimensionalTableWrite* to true.\n\n#### Examples\n\nExample 1\n\n```\ndb=database(\"dfs://db1\",VALUE,1 2 3)\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nt = table(timestamp, sym, qty, price);\n\ndt=db.createDimensionTable(t,`dt).append!(t);\nselect * from dt;\n```\n\n| timestamp | sym | qty  | price  |\n| --------- | --- | ---- | ------ |\n| 09:34:07  | C   | 2200 | 49.6   |\n| 09:36:42  | MS  | 1900 | 29.46  |\n| 09:36:51  | MS  | 2100 | 29.52  |\n| 09:36:59  | MS  | 3200 | 30.02  |\n| 09:32:47  | IBM | 6800 | 174.97 |\n| 09:35:26  | IBM | 5400 | 175.23 |\n| 09:34:16  | C   | 1300 | 50.76  |\n| 09:34:26  | C   | 2500 | 50.32  |\n| 09:38:12  | C   | 8800 | 51.29  |\n\nExample 2\n\n```\ndb = database(\"dfs://demodb\", VALUE, 1..10)\nt=table(take(1, 86400) as id, 2020.01.01T00:00:00 + 0..86399 as timestamp, rand(1..100, 86400) as val)\ndt = db.createDimensionTable(t, \"dt\", {timestamp:\"delta\", val:\"delta\"})\ndt.append!(t)\n```\n\nExample 3. Create a dimension table in a TSDB database\n\n```\nif(existsDatabase(\"dfs://dbctable_createDimensionTable\")){\n    dropDatabase(\"dfs://dbctable_createDimensionTable\")\n}\ndb = database(\"dfs://dbctable_createDimensionTable\", VALUE, 1..100, , \"TSDB\")\nt1 = table(1 100 100 300 300 400 500 as id, 1..7 as v)\ndb.createDimensionTable(t1, \"dt\", , \"id\").append!(t1)\ndt=loadTable(\"dfs://dbctable_createDimensionTable\",\"dt\")\n```\n\nExample 4. Create a dimension table in a PKEY database.\n\n```\ndb = database(directory=\"dfs://PKDB\", partitionType=VALUE, partitionScheme=1..10, engine=\"PKEY\")\nschematb = table(1:0,`id1`id2`val1`val2`date1`time1,[INT,INT,INT,DECIMAL32(2),DATE,TIME])\npkt = createDimensionTable(dbHandle=db, table=schematb, tableName=\"pkt\", primaryKey=`id1`id2, indexes={\"val1\": \"bloomfilter\", \"val2\": \"bloomfilter\"})\n```\n\nRelated functions: [createPartitionedTable](https://docs.dolphindb.com/en/Functions/c/createPartitionedTable.html)\n"
    },
    "createTimeSeriesAggregator": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createTimeSeriesAggregator.html",
        "signatures": [
            {
                "full": "createTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, [timeColumn], [useSystemTime=false], [keyColumn], [garbageSize], [updateTime], [useWindowStartTime], [roundTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [fill='none'], [forceTriggerTime], [raftGroup], [keyPurgeFreqInSec=-1], [closed='left'], [outputElapsedMicroseconds=false], [subWindow], [parallelism=1], [acceptedDelay=0], [outputHandler=NULL], [msgAsTable=false])",
                "name": "createTimeSeriesEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "windowSize",
                        "name": "windowSize"
                    },
                    {
                        "full": "step",
                        "name": "step"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[updateTime]",
                        "name": "updateTime",
                        "optional": true
                    },
                    {
                        "full": "[useWindowStartTime]",
                        "name": "useWindowStartTime",
                        "optional": true
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[fill='none']",
                        "name": "fill",
                        "optional": true,
                        "default": "'none'"
                    },
                    {
                        "full": "[forceTriggerTime]",
                        "name": "forceTriggerTime",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSec=-1]",
                        "name": "keyPurgeFreqInSec",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[subWindow]",
                        "name": "subWindow",
                        "optional": true
                    },
                    {
                        "full": "[parallelism=1]",
                        "name": "parallelism",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[acceptedDelay=0]",
                        "name": "acceptedDelay",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createTimeSeriesAggregator](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesAggregator.html)\n\nAlias for [createTimeSeriesEngine](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html)\n\n\nDocumentation for the `createTimeSeriesEngine` function:\n### [createTimeSeriesEngine](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html)\n\n\n\n#### Syntax\n\ncreateTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, \\[timeColumn], \\[useSystemTime=false], \\[keyColumn], \\[garbageSize], \\[updateTime], \\[useWindowStartTime], \\[roundTime=true], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[fill='none'], \\[forceTriggerTime], \\[raftGroup], \\[keyPurgeFreqInSec=-1], \\[closed='left'], \\[outputElapsedMicroseconds=false], \\[subWindow], \\[parallelism=1], \\[acceptedDelay=0], \\[outputHandler=NULL], \\[msgAsTable=false])\n\nAlias: createTimeSeriesAggregator\n\n#### Details\n\nThis function creates a time-series streaming engine to conduct real-time time-series calculations with moving windows, and returns a table object where data is ingested for window calculations.\n\nThere are two types of aggregate operators in the time-series engine: incremental operators and full operators. Incremental operators incrementally aggregate the data as they arrive without keeping the historical data. Full operators (e.g., user-defined aggregate functions, unoptimized built-in aggregate functions, or functions with nested state functions) keep all the data in a window and recompute the output as a full refresh whenever new data arrives.\n\nThe following aggregate operators in the time-series engine are optimized for incremental computations: corr, covar, first, last, max, med, min, percentile, quantile, std, var, sum, sum2, sum3, sum4, wavg, wsum, count, firstNot, ifirstNot, lastNot, ilastNot, imax, imin, nunique, prod, sem, mode, searchK, beta, avg.\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n##### Windowing logic\n\nWindow boundaries: The engine automatically adjusts the starting point of the first window. (see parameter description for *step* and *roundTime*, and [alignment rules](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html#alignment-rules)).\n\nWindow properties:\n\n* *windowSize* - the size of each window;\n* *closed* - whether the left/right boundaries of a window is inclusive/exclusive;\n* *step* - the duration of time between windows;\n* *useSystemTime* specifies how values are windowed - based on the time column in the data or the system time of data ingestion.\n\n##### Calculation Rules\n\n* If *timeColumn* is specified, its values must be increasing. If *keyColumn* is specified to group the data, the values in *timeColumn* must be increasing with each group specified by *keyColumn*. Otherwise, out-of-order data will be discarded.\n* If *useSystemTime* = true, the calculation of a window is triggered as soon as the window ends. If *useSystemTime* = false (with *timeColumn* specified), the calculation of a window is triggered by the arrival of the next record after the window ends. To trigger the calculation for the uncalculated windows, you can specify the parameter *updateTime* or *forceTriggerTime*.\n* If *fill* is unspecified or \"None\", only windows with calculation results are output. If *fill* is specified, all windows are output, and the empty windows are filled using the specified filling method.\n* Since version 2.00.11, if *updateTime* = 0, incoming records in the current window can be immediately calculated and output.\n\n##### Other Features\n\n* Data/state cleanup: You can set a cleanup rule to clear historical data. (See parameters *keyPurgeFilter* and *keyPurgeFreInSecond*)\n\n* Snapshot: Snapshot mechanism is used to restore the streaming engine to the latest snapshot after system interruption. (See parameters *snapshotDir* and *snapshotIntervalInMsgCount*)\n\n* High availability: To enable high availability for streaming engines, specify the parameter *raftGroup* on the leader of the raft group on the subscriber. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table.\n\n#### Arguments\n\n**name** is a string indicating the name of the engine. It is the only identifier of an engine on a data or compute node. It can have letter, number and \"\\_\" and must start with a letter.\n\n**windowSize** is a scalar or vector with positive integers that specifies the size of the windows for calculation.\n\n**step** is a positive integer indicating how much each window moves forward relative to the previous one. Note that step must be divisible by *windowSize*, otherwise an exception will be thrown.\n\nThe unit of *windowSize* and *step* are determined by the value of *useSystemTime*.\n\n* If *useSystemTime* =true, the unit of *windowSize* and *step* is millisecond.\n* If *useSystemTime* =false, the unit of *windowSize* and *step* is the same as the unit of *timeColumn*.\n\n**metrics** is metacode or a tuple specifying the calculation formulas. For more information about metacode please refer to [Metaprogramming](https://docs.dolphindb.com/en/Programming/Metaprogramming/functional_meta.html).\n\n* It can use one or more built-in or user-defined aggregate functions (which must be defined by the `defg` keyword) such as `<[sum(volume), avg(price)]>`, or expressions of aggregate functions such as as `<[avg(price1)-avg(price2)]>`, or aggregate functions involving multiple columns such as `<[std(price1-price2)]>`.\n* You can specify functions that return multiple values for *metrics*, such as `<func(price) as `col1`col2>` (it's optional to specify the column names).\n* If *metrics* is a tuple with multiple formulas, *windowSize* is specified as a vector of the same length as *metrics*. Each element of *windowSize* corresponds to the elements in *metrics*. For example, if *windowSize*=\\[10,20], *metrics* can be `(<[min(volume), max(volume)]>, <sum(volume)>)`. *metrics* can also input nested tuple vectors, such as `[[<[min(volume), max(volume)]>, <sum(volume)>], [<avg(volume)>]]`.\n\n**Note:**\n\n* The column names specified in *metrics* are not case-sensitive and can be inconsistent with the column names of the input tables.\n* Nested aggregate function calls are not supported in *metrics*.\n\n**dummyTable** is a table object whose schema must be the same as the subscribed stream table. Whether *dummyTable* contains data does not matter.\n\n**outputTable** is a table to which the engine inserts calculation results. It can be an in-memory table or a DFS table. Create an empty table and specify the column names and types before calling the function.\n\nThe output columns are in the following order:\n\n(1) The first column must be a time column.\n\n* If *useSystemTime* = true, it is TIMESTAMP; Otherwise, it has the same data type as *timeColumn*;\n* If *useWindowStartTime* = true, the column displays the start time of each window; Otherwise, it displays the end time of each window.\n\n(2) If *keyColumn* is specified, the subsequent column(s) must be in the same order as that specified by *keyColumn*.\n\n(3) If *outputElapsedMicroseconds* is set to true, you need to specify a column of LONG type. See the *outputElapsedMicroseconds* parameter for details.\n\n(4) Then followed by one or more result columns.\n\nNote: Starting from version 2.00.10, the engine supports a user-defined aggregate function to merge multiple results in an array vector column. The result column in the output table must be in the form of array vector (i.e., append a pair of square brackets (\\[]) to the data type). See example 3.\n\n**timeColumn** (optional) is a STRING scalar or vector specifying the time column(s) of the subscribed stream table. When *useSystemTime* = false, it must be specified.\n\nNote: If *timeColumn* is a vector, it must have a date element (of DATE type) and a time element (of TIME, SECOND or NANOTIME type). In this case, the first column in *outputTable* must take the data type of concatDateTime(date, time).\n\n**useSystemTime** (optional) is a Boolean value indicating whether the calculations are performed based on the system time when data is ingested into the engine.\n\n* *useSystemTime* = true: the engine will regularly window the streaming data at fixed time intervals for calculations according to the ingestion time (local system time with millisecond precision, independent of any temporal columns in the streaming table) of each record. As long as a window contains data, the calculation will be performed automatically when the window ends. The first column in output table indicates the timestamp when the calculation occurred.\n* *useSystemTime* = false (default): the engine will window the streaming data according to the timeColumn in the stream table. The calculation for a window is triggered by the first record after the previous window. Note that the record which triggers the calculation will not participate in this calculation.\n\nFor example, there is a window ranges from 10:10:10 to 10:10:19. If *useSystemTime* = true and the window is not empty, the calculation will be triggered at 10:10:20. If *useSystemTime* = false and the first record after 10:10:19 is at 10:10:25, the calculation will be triggered at 10:10:25.\n\n**keyColumn** (optional) is a STRING scalar/vector indicating the name of the grouping column(s). If it is specified, the engine conducts the calculations within each group. For example, group the data by stock symbol and apply moving aggregation functions to each stock.\n\n**garbageSize** (optional) is a positive integer. The default value is 50,000 (rows). The subscribed data continues to accumulate in the engine. When the number of rows of historical data in the memory exceeds *garbageSize*, the system will clear the historical data that is no longer needed.\n\nNote: For incremental operators, the data no longer needed will be automatically removed from memory. However, for full operators, this parameter must be specified to enable garbage collection.\n\n**updateTime** (optional) is a non-negative integer which takes the same time precision as *timeColumn*. It is used to trigger window calculations at an interval shorter than *step*. *step* must be a multiple of *updateTime*. To specify *updateTime*, *useSystemTime* must be set to false.\n\nIf *updateTime* is not specified, calculation for a window will not occur before the window ends. By specifying *updateTime*, you can calculate the values for several times in an window of which calculation hasn't been triggered for a long time.\n\nThe calculations within a window are triggered with the following rules:\n\n* Starting from the left boundary of the window, if there is a new record arriving after every *updateTime*, all data before this record in the current window is calculated. If it still has unprocessed data after 2\\**updateTime* (at least 2 seconds), all data in this window is calculated.\n* If *keyColumn* is specified, these rules apply within each group.\n\nIt is recommended to specify a keyed table for *outputTable* if *updateTime* is set. If *outputTable* is a standard in-memory table or stream table, it will have multiple results for each timestamp (in each group). It is not recommended to use a keyed stream table either as the records of a keyed stream table cannot be updated.\n\n**useWindowStartTime** (optional) is a Boolean value indicating whether the time column in *outputTable* is the starting time of the windows. The default value is false, which means the timestamps in the output table are the end time of the windows. If the *windowSize* is a vector, *useWindowStartTime* must be false.\n\n**roundTime** (optional) is a Boolean value indicating the method to align the window boundary if the time precision is milliseconds or seconds and step is bigger than one minute. The default value is true indicating the alignment is based on the multi-minute rule (see the [alignment rules](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html#alignment-rules)). False means alignment is based on the one-minute rule.\n\n**snapshotDir** (optional) is a string indicating the directory where the streaming engine snapshot is saved. The directory must already exist, otherwise an exception is thrown. If *snapshotDir* is specified, the system checks whether a snapshot already exists in the directory when creating a streaming engine. If it exists, the snapshot will be loaded to restore the engine state. Multiple streaming engines can share a directory where the snapshot files are named as the engine names.\n\nThe file extension of a snapshot can be:\n\n* * *\\<engineName>.tmp*: temporary snapshot\n* *\\<engineName>.snapshot*: a snapshot that is generated and flushed to disk\n* *\\<engineName>.old*: if a snapshot with the same name already exists, the previous snapshot is renamed to *\\<engineName>.old*.\n\n**snapshotIntervalInMsgCount** (optional) is a positive integer indicating the number of messages to receive before the next snapshot is saved.\n\n**fill** (optional) is a vector/scalar indicating the filling method to deal with an empty window (in a group). It can be:\n\n* 'none': no result\n* 'null': output a NULL value.\n* 'ffill': output the result in the last window.\n* specific value: output the specified value. Its type should be the same as metrics output's type.\n\n*fill* could be a vector to specify different filling method for each metric. The size of the vector must be consistent with the number of elements specified in *metrics*. The element in vector cannot be 'none'.\n\n**forceTriggerTime** (optional) is a non-negative integer which takes the same time precision as *timeColumn*, indicating the waiting time to force trigger calculation in the uncalculated windows for each group. If *forceTriggerTime* is set, *useSystemTime* must be false and *updateTime* cannot be specified.\n\nThe rules are as follow:\n\n(1) Suppose the end time of the uncalculated window is t, and an incoming record of another group arrives at t1: when t1-t>=forceTriggerTime, calculation of the window will be triggered.\n\n(2) If no data is ingested into a group after the last window is calculated, and new data continues to ingest into other groups, the specified *fill* parameter can be used to fill results for empty windows of that group. The group's windows will still be output at the latest time point. If parameter *fill* is not specified, no new windows will be generated for that group after the last window has been triggered for computation.\n\nNote the following points when setting *forceTriggerTime* or *updateTime*:\n\n* If *updateTime* is specified, the result of the current window calculation will be updated again when data belonging to the current window still arrives after the calculation is triggered.\n* If *forceTriggerTime* is specified, the incoming data with a timestamp within the current window will be discarded after the calculation is forced to be triggered.\n\n**raftGroup** (optional) is an integer greater than 1, indicating ID of the raft group on the high-availability streaming subscriber specified by the configuration parameter *streamingRaftGroups*. Specify *raftGroup* to enable high availability on the streaming engine. When an engine is created on the leader, it is also created on each follower and the engine snapshot is synchronized to the followers. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table. Note that *SnapShotDir* must also be specified when specifying a raft group.\n\n**keyPurgeFreqInSec** (optional) is a positive integer indicating the interval (in seconds) to remove groups with no incoming data for a long time. If a group has no incoming data for at least *keyPurgeFreqInSec* seconds after the last time of data purging, it will be removed.\n\nNote: To specify this parameter, parameter *forceTriggerTime* must be specified and parameter *fill* cannot be specified.\n\nYou can check the number of groups in a time-series streaming engine based on the column \"numGroups\" returned by [getStreamEngineStat](https://docs.dolphindb.com/en/Functions/g/getStreamEngineStat.html).\n\n**closed** (optional) is a STRING indicating whether the left or the right boundary is included.\n\n* closed = 'left': left-closed, right-open\n* closed = 'right': left-open, right-closed\n\n**outputElapsedMicroseconds** (optional) is a BOOLEAN value. The default value is false. It determines whether to output the elapsed time (in microseconds) from the time the calculation is triggered to the output of result for each window.\n\n**subWindow**(optional)is a pair of integers or DURATION values, indicating the range of the subwindow within the window specified by *windowSize*. If specified, only results calculated within subwindows will be returned and the time column of the output table displays the end time of each subwindow. The calculation of the subwindow will be triggered by the arrival of the next record after the subwindow ends. The boundary of the subwindow is determined by parameter *closed*. When *subWindow* is a pair of integers, it takes the same time precision as *timeColumn*.\n\nIf it is specified, note that:\n\n* *windowSize* must be equal to *step*.\n* Shall not specify *updateTime*>0 and *useSystemTime*=true.\n\n**parallelism** (optional) is a positive integer no greater than 63, representing the number of worker threads for parallel computation. The default value is 1. For compute-intensive workloads, adjusting this parameter appropriately can effectively utilize computing resources and reduce computation time. It is recommended to set a value less than the number of CPU cores, normally from 4 to 8.\n\n**acceptedDelay** (optional) is a positive integer less than or equal to\\*windowSize,\\*specifying the maximum delay for each window to accept data.The default value is 0.\n\n* When *useSystemTime*=true, data received within the *acceptedDelay*time after the window ends will still be considered part of the current window and participate in the computation, and will not be included in the computation of the next window.\n* When *useSystemTime*=false, a window with t as right boundary will wait until a record with a timestamp equal to or later than t + *acceptedDelay* arrives. When such a record arrives, the current window closes and performs a calculation on all records within the window frame. This handles scenarios with out-of-order data.\n\n**outputHandler** (optional) is a unary function or a partial function with a single unfixed parameter. If set, the engine will not write the calculation results to the output table directly. Instead, the results will be passed as a parameter to the *outputHandler* function. The default value is NULL, which means the result will be written to the output table.\n\n**msgAsTable** (optional) is a Boolean scalar indicating whether the output data is passed into function (specified by *outputHandler*) as a table or as a tuple. If *msgAsTable*=true, the subscribed data is passed into function as a table. The default value is false, which means the output data is passed into function as a tuple of columns.\n\n#### Alignment Rules\n\nTo facilitate observation and comparison of calculation results, the engine automatically adjusts the starting point of the first window. The alignment size (integer) will be decided by parameter *step*, *roundTime*, and the precision of *timeColumn*. When time series engine calculates within groups, all groups' windows will be uniformly aligned. The boundaries of each window are the same for each group.\n\n* If the data type of *timeColumn* is MINUTE(HH:mm), the value of *alignmentSize* is as follows:\n\n  *if roundTime=false*:\n\n  | step   | alignmentSize |\n  | ------ | ------------- |\n  | 0\\~2   | 2             |\n  | 3      | 3             |\n  | 4\\~5   | 5             |\n  | 6\\~10  | 10            |\n  | 11\\~15 | 15            |\n  | 16\\~20 | 20            |\n  | 21\\~30 | 30            |\n  | >30    | 60 (1 hour)   |\n\n  *if roundTime=true*:\n\n  The value of *alignmentSize* is same as above table if *step*<=30; The value of *alignmentSize* is as folllows if *step*>30:\n\n  | step       | alignmentSize   |\n  | ---------- | --------------- |\n  | 31\\~60     | 60 (1 hour)     |\n  | 60\\~120    | 120 (2 hours)   |\n  | 121\\~180   | 180 (3 hours)   |\n  | 181\\~300   | 300 (5 hours)   |\n  | 301\\~600   | 600 (10 hours)  |\n  | 601\\~900   | 900 (15 hours)  |\n  | 901\\~1200  | 1200 (20 hours) |\n  | 1201\\~1800 | 1800 (30 hours) |\n  | >1800      | 3600 (60 hours) |\n\n* If the data type of *timeColumn* is DATETIME (yyyy-MM-dd HH:mm:ss) or SECOND (HH:mm:ss), the value of *alignmentSize* is as follows:\n\n  *if roundTime=false*:\n\n  | step   | alignmentSize |\n  | ------ | ------------- |\n  | 0\\~2   | 2             |\n  | 3      | 3             |\n  | 4\\~5   | 5             |\n  | 6\\~10  | 10            |\n  | 11\\~15 | 15            |\n  | 16\\~20 | 20            |\n  | 21\\~30 | 30            |\n  | >30    | 60 (1minute)  |\n\n  *if roundTime=true*:\n\n  The value of *alignmentSize* is same as above table if step<=30; The value of *alignmentSize* is as folllows if step>30:\n\n  | step       | alignmentSize    |\n  | ---------- | ---------------- |\n  | 31\\~60     | 60 (1minute)     |\n  | 61\\~120    | 120 (2minutes)   |\n  | 121\\~180   | 180 (3minutes)   |\n  | 181\\~300   | 300 (5minutes)   |\n  | 301\\~600   | 600 (10minutes)  |\n  | 601\\~900   | 900 (15minutes)  |\n  | 901\\~1200  | 1200 (20minutes) |\n  | 1201\\~1800 | 1800 (30minutes) |\n  | >1800      | 3600 (1hour)     |\n\n* If the data type of *timeColumn* is TIMESTAMP(yyyy-MM-dd HH:mm:ss.mmm) or TIME(HH:mm:ss.mmm), the value of *alignmentSize* is as follows:\n\n  *if roundTime=false*:\n\n  | step         | alignmentSize    |\n  | ------------ | ---------------- |\n  | 0\\~2         | 2                |\n  | 3\\~5         | 5                |\n  | 6\\~10        | 10               |\n  | 11\\~20       | 20               |\n  | 21\\~25       | 25               |\n  | 26\\~50       | 50               |\n  | 51\\~100      | 100              |\n  | 101\\~200     | 200              |\n  | 201\\~250     | 250              |\n  | 251\\~500     | 500              |\n  | 501\\~1000    | 1000(1second)    |\n  | 1001\\~2000   | 2000(2seconds)   |\n  | 2001\\~5000   | 5000(5seconds)   |\n  | 5001\\~10000  | 10000(10seconds) |\n  | 10001\\~15000 | 15000(15seconds) |\n  | 15001\\~20000 | 20000(20seconds) |\n  | 20001\\~30000 | 30000(30seconds) |\n  | >30000       | 60000(1minutes)  |\n\n  *if roundTime=true:*\n\n  The value of *alignmentSize* is same as above table if step<=30000; The value of *alignmentSize* is as folllows if step>30000:\n\n  | step             | alignmentSize      |\n  | ---------------- | ------------------ |\n  | 30001\\~60000     | 60000(1minute)     |\n  | 60001\\~120000    | 120000(2minutes)   |\n  | 120001\\~300000   | 300000(5minutes)   |\n  | 300001\\~600000   | 600000(10minutes)  |\n  | 600001\\~900000   | 900000(15minutes)  |\n  | 900001\\~1200000  | 1200000(20minutes) |\n  | 1200001\\~1800000 | 1800000(30minutes) |\n  | >1800000         | 3600000(1hour)     |\n\n* If the data type of *timeColumn* is NANOTIMESTAMP(yyyy-MM-dd HH:mm:ss.nnnnnnnnn) or NANOTIME(HH:mm:ss.nnnnnnnnn), the value of *alignmentSize* is as follows:\n\n  *if roundTime=false*:\n\n  | step         | alignmentSize |\n  | ------------ | ------------- |\n  | 0\\~2ns       | 2ns           |\n  | 3ns\\~5ns     | 5ns           |\n  | 6ns\\~10ns    | 10ns          |\n  | 11ns\\~20ns   | 20ns          |\n  | 21ns\\~25ns   | 25ns          |\n  | 26ns\\~50ns   | 50ns          |\n  | 51ns\\~100ns  | 100ns         |\n  | 101ns\\~200ns | 200ns         |\n  | 201ns\\~250ns | 250ns         |\n  | 251ns\\~500ns | 500ns         |\n  | >500ns       | 1000ns        |\n\n  *if roundTime=true*:\n\n  | step        | alignmentSize |\n  | ----------- | ------------- |\n  | 1000ns\\~1ms | 1ms           |\n  | 1ms\\~10ms   | 10ms          |\n  | 10ms\\~100ms | 100ms         |\n  | 100ms\\~1s   | 1s            |\n  | 1s\\~2s      | 2s            |\n  | 2s\\~3s      | 3s            |\n  | 3s\\~5s      | 5s            |\n  | 5s\\~10s     | 10s           |\n  | 10s\\~15s    | 15s           |\n  | 15s\\~20s    | 20s           |\n  | 20s\\~30s    | 30s           |\n  | >30s        | 1min          |\n\nIf the time of the first record is x with data type of TIMESTAMP, then the starting time of the first window is adjusted to be `timeType_cast(x/alignmentSize*alignmentSize+step-windowSize)`, where \"/\" produces only the integer part after division. For example, if the time of the first record is 2018.10.08T01:01:01.365, *windowSize* = 120000, and *step* = 60000, then *alignmentSize* = 60000, and the starting time of the first window is timestamp(2018.10.08T01:01:01.365/60000\\*60000+60000-120000)=2018.10.08T01:01:00.000.\n\n#### Examples\n\nExample 1\n\nIn the following example, the time-series engine1 subscribes to the stream table \"trades\" and calculates sum(volume) for each stock in the last minute in real time. The result is saved in table output1.\n\n```\nshare streamTable(1000:0, `time`sym`volume, [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output1\nengine1 = createTimeSeriesEngine(name=\"engine1\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=append!{engine1}, msgAsTable=true);\n\ninsert into trades values(2018.10.08T01:01:01.785,`A,10)\ninsert into trades values(2018.10.08T01:01:02.125,`B,26)\ninsert into trades values(2018.10.08T01:01:10.263,`B,14)\ninsert into trades values(2018.10.08T01:01:12.457,`A,28)\ninsert into trades values(2018.10.08T01:02:10.789,`A,15)\ninsert into trades values(2018.10.08T01:02:12.005,`B,9)\ninsert into trades values(2018.10.08T01:02:30.021,`A,10)\ninsert into trades values(2018.10.08T01:04:02.236,`A,29)\ninsert into trades values(2018.10.08T01:04:04.412,`B,32)\ninsert into trades values(2018.10.08T01:04:05.152,`B,23)\n\nsleep(10)\n\nselect * from output1;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:02:00.000 | A   | 38        |\n| 2018.10.08T01:02:00.000 | B   | 40        |\n| 2018.10.08T01:03:00.000 | A   | 25        |\n| 2018.10.08T01:03:00.000 | B   | 9         |\n\nThe following paragraphs explain in details how the time-series engine conducts the calculations. For simplicity, regarding the \"time\" column we ignore the part of \"2018.10.08T\" and only use the \"hour:minute:second.millisecond\" part.\n\nFirst, the time-series engine adjusts the starting time of the first window to be 01:01:00.000. The first window is from 01:01:00.000 (inclusive) to 01:02:00.000 (exclusive). When the record (01:02:10.789,\\`A,15) arrives, it triggers the calculation of group A for the first window; the arrival of (01:02:12.005,\\`B,9) triggers the calculation of group B for the first window.\n\nThe second window is from 01:02:00.000 (inclusive) to 01:03:00.000 (exclusive). When the record (01:04:02.236,\\`A,29) arrives, it triggers the calculation of group A for the second window; the arrival of (01:04:04.412,\\`B,32) triggers the calculation of group B for the second window.\n\nAs there are no records since 01:05:00.000, no calculations are triggered for the window of \\[01:04:00.000, 01:05:00.000).\n\nThe table output1 stores the calculation results of the time-series engine. As *useWindowStartTime*=false, the timestamps in the output table are the end time of the windows. If *useWindowStartTime*=true, then the timestamps in the output table are the starting time of the windows, as illustrated in the following example:\n\n```\nshare table(10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output2\nengine2 = createTimeSeriesEngine(name=\"engine2\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output2, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50, useWindowStartTime=true)\nsubscribeTable(tableName=\"trades\", actionName=\"engine2\", offset=0, handler=append!{engine2}, msgAsTable=true)\n\nsleep(10)\nselect * from output2;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:01:00.000 | A   | 38        |\n| 2018.10.08T01:01:00.000 | B   | 40        |\n| 2018.10.08T01:02:00.000 | A   | 25        |\n| 2018.10.08T01:02:00.000 | B   | 9         |\n\nExample 2\n\nIn the following example, we specify *updateTime* to be 1000 (milliseconds):\n\n```\nshare keyedTable(`time`sym,10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output3\nengine3 = createTimeSeriesEngine(name=\"engine3\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output3, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50, updateTime=1000, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"engine3\", offset=0, handler=append!{engine3}, msgAsTable=true)\n\nsleep(2001)\nselect * from output3;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:02:00.000 | A   | 38        |\n| 2018.10.08T01:02:00.000 | B   | 40        |\n| 2018.10.08T01:03:00.000 | A   | 25        |\n| 2018.10.08T01:03:00.000 | B   | 9         |\n| 2018.10.08T01:05:00.000 | B   | 55        |\n| 2018.10.08T01:05:00.000 | A   | 29        |\n\nNext, we will explain the calculations triggered in the last window from 01:04:00.000 to 01:05:00.000.\n\n(1) At 01:04:04.236, 2000 milliseconds after the first record of group A arrived, a group A calculation is triggered. The result (01:05:00.000, \\`A, 29) is written to the output table.\n\n(2) The record of group B at 01:04:05.152 is the first record after the small window of \\[01:04:04.000, 01:04:05.000) that contains the group B record at 01:04:04.412. It triggers a group B calculation. The result (01:05:00.000,\"B\",32) is written to the output table.\n\n(3) 2000 milliseconds later, at 01:04:07.152, as the B group record at 1:04:05.152 has not been used in a calculation, a group B calculation is triggered. The result is (01:05:00.000,\"B\",55). As the output table's keys are columns 'time' and 'sym', the record of (01:05:00.000,\\`B,32) in the output table is updated and becomes (01:05:00.000,\\`B,55).\n\nIn the example, the shared stream table \"pubT\" contains two time columns with the type of DATE and SECOND. When creating time series engine, the two time columns could be combined into one column with the type of DATETIME in output table \"streamMinuteBar\\_1min\" by setting *timeColumn*.\n\n```\ncolNames=`symbol`date`minute`price`type`volume\ncolTypes=`SYMBOL`DATE`SECOND`DOUBLE`STRING`INT\npubTable = streamTable(10000:0,colNames,colTypes)\nshare pubTable as pubT\n\ncolNames = `time`symbol`open`max`min`close`volume`amount`ret`vwap\ncolTypes = `DATETIME`SYMBOL`DOUBLE`DOUBLE`DOUBLE`DOUBLE`INT`DOUBLE`DOUBLE`DOUBLE\nshare streamTable(10000:0,colNames, colTypes) as streamMinuteBar_1min\n\ntsAggrOHLC = createTimeSeriesEngine(name=\"subT\", windowSize=60, step=60, metrics=<[first(price) as open ,max(price) as max,min(price) as min ,last(price) as close ,sum(volume) as volume ,wsum(volume, price) as amount ,(last(price)-first(price)/first(price)) as ret, (wsum(volume, price)/sum(volume)) as vwap]>, dummyTable=pubTable, outputTable=streamMinuteBar_1min, timeColumn=`date`minute, useSystemTime=false, keyColumn='symbol', fill=`none)\nsubscribeTable(tableName=\"pubT\", actionName=\"subT\", offset=-1, handler=append!{tsAggrOHLC}, msgAsTable=true)\n\ninsert into pubT values(`000001, 2021.04.05, 09:25:01, 1, 'B', 1)\ninsert into pubT values(`000001, 2021.04.05, 09:30:05, 2, 'B', 1)\ninsert into pubT values(`000001, 2021.04.05, 09:31:06, 3, 'B', 1)\ninsert into pubT values(`000001, 2021.04.05, 09:35:05, 4, 'S', 4)\ninsert into pubT values(`000001, 2021.04.05, 09:40:05, 5, 'S', 5)\ninsert into pubT values(`000001, 2021.04.06, 09:25:05, 6, 'S', 6)\n```\n\n| symbol | date       | minute   | price | type | volume |\n| ------ | ---------- | -------- | ----- | ---- | ------ |\n| 000001 | 2021.04.05 | 09:25:01 | 1     | B    | 1      |\n| 000001 | 2021.04.05 | 09:30:05 | 2     | B    | 1      |\n| 000001 | 2021.04.05 | 09:31:06 | 3     | B    | 1      |\n| 000001 | 2021.04.05 | 09:35:05 | 4     | S    | 4      |\n| 000001 | 2021.04.05 | 09:40:05 | 5     | S    | 5      |\n| 000001 | 2021.04.06 | 09:25:05 | 6     | S    | 6      |\n\n```\nselect * from streamMinuteBar_1min\n```\n\n| time                | symbol | open | max | min | close | volume | amount | ret | vwap |\n| ------------------- | ------ | ---- | --- | --- | ----- | ------ | ------ | --- | ---- |\n| 2021.04.05T09:26:00 | 000001 | 1    | 1   | 1   | 1     | 1      | 1      | 0   | 1    |\n| 2021.04.05T09:31:00 | 000001 | 2    | 2   | 2   | 2     | 1      | 2      | 1   | 2    |\n| 2021.04.05T09:32:00 | 000001 | 3    | 3   | 3   | 3     | 1      | 3      | 2   | 3    |\n| 2021.04.05T09:36:00 | 000001 | 4    | 4   | 4   | 4     | 4      | 16     | 3   | 4    |\n| 2021.04.05T09:41:00 | 000001 | 5    | 5   | 5   | 5     | 5      | 25     | 4   | 5    |\n\n```\nshare streamTable(1000:0, `time`sym`qty, [DATETIME, SYMBOL, INT]) as trades\nshare table(10000:0, `time`sym`sumQty, [DATETIME, SYMBOL, INT]) as output3\n\nengine = createTimeSeriesEngine(name=\"engine\", windowSize=6, step=6, metrics=<sum(qty)>, dummyTable=trades, outputTable=output3, timeColumn=`time,keyColumn=`sym, forceTriggerTime=7,fill=1000)\nsubscribeTable(tableName=\"trades\", actionName=\"engine\", offset=0, handler=append!{engine}, msgAsTable=true)\nsleep(1000)\ninsert into engine values(2018.08.01T14:05:43,`A,1)\ninsert into engine values(2018.08.01T14:05:43,`C,3)\nsleep(10)\ninsert into engine values(2018.08.01T14:05:44,`B,1)\nsleep(80)\ninsert into engine values(2018.08.01T14:05:52,`B,3)\nsleep(20)\ninsert into engine values(2018.08.01T14:05:54,`A,3)\nsleep(10)\ninsert into engine values(2018.08.01T14:05:55,`A,5)\nsleep(20)\ninsert into engine values(2018.08.01T14:05:57,`B,5)\nsleep(50)\ninsert into engine values(2018.08.01T14:06:12,`A,1)\nsleep(50)\nselect * from output3 order by sym\n```\n\n| time                | sum | Qty   |\n| ------------------- | --- | ----- |\n| 2018.08.01T14:05:46 | A   | 1     |\n| 2018.08.01T14:05:52 | A   | 1,000 |\n| 2018.08.01T14:05:58 | A   | 8     |\n| 2018.08.01T14:06:04 | A   | 1,000 |\n| 2018.08.01T14:06:10 | A   | 1,000 |\n| 2018.08.01T14:05:46 | B   | 1     |\n| 2018.08.01T14:05:52 | B   | 1,000 |\n| 2018.08.01T14:05:58 | B   | 8     |\n| 2018.08.01T14:05:46 | C   | 3     |\n| 2018.08.01T14:05:52 | C   | 1,000 |\n\nExample 3\n\nThe following example calculates the first/last volume in each window and merges the result in an array vector column.\n\n```\n// Define a function toVector with defg. The results are merged into array vectors\ndefg toVector(x){\n    return x\n}\nshare streamTable(1000:0, `time`sym`volume`price, [TIMESTAMP, SYMBOL, DOUBLE,DOUBLE]) as trades\n// Define the output table and specify the result column as DOUBLE[] type\nshare table(10000:0, `time`sym`sumVolume`avg, [TIMESTAMP,STRING,DOUBLE[],DOUBLE]) as output1\n// Call toVector in metrics to combine the first and last volumes in a 1-minute window into an array vector\nengine1 = createTimeSeriesEngine(name=\"engine1\", windowSize=60000, step=60000, metrics=<[toVector([first(volume),last(volume)]),avg(volume+price)]>, dummyTable=trades, outputTable=output1, timeColumn=`time, keyColumn=`sym , useSystemTime=false, garbageSize=50, useWindowStartTime=false)\n\ntimes = sort(2023.10.08T00:00:00.000 + rand(1..(1+3000*200), 30))\nsyms = rand(\"A\"+string(1..10), 30)\nvolumes = rand(rand(100.0, 10) join 2.3 NULL NULL NULL NULL, 30)\nprices = rand(rand(100.0, 10) join 2.3 NULL NULL NULL NULL, 30)\nt=table(times as time, syms as sym, volumes as volume,prices as price)\n\nengine1.append!(t)\n\nselect * from output1 where time between 2023.10.08T00:01:00.000 and 2023.10.08T00:05:00.000 order by time,sym \n```\n\n| time                    | sym | sumVolume                             | avg                |\n| ----------------------- | --- | ------------------------------------- | ------------------ |\n| 2023.10.08 00:01:00.000 | A1  | \\[, ]                                 |                    |\n| 2023.10.08 00:02:00.000 | A4  | \\[2.3, 2.3]                           |                    |\n| 2023.10.08 00:03:00.000 | A10 | \\[68.5665876371786, 68.5665876371786] | 121.97567140683532 |\n| 2023.10.08 00:03:00.000 | A6  | \\[, 22.65533998142928]                | 33.386794407851994 |\n\nExample 4\n\nThe following example specifies the parameter *subWindow*.\n\n```\n\nshare streamTable(1000:0, `time`sym`volume, [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output1\n//specify a 10-second subwindow within a 1-min window. With closed unspecified, the subwindow takes the default value, i.e., left-closed, right-open window, [0s, 10s).\nengine4 = createTimeSeriesEngine(name=\"engine4\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50, useWindowStartTime=true, subWindow=0s:10s)\n\nsubscribeTable(tableName=\"trades\", actionName=\"engine4\", offset=0, handler=append!{engine4}, msgAsTable=true);\n\ninsert into trades values(2018.10.08T01:01:01.785,`A,10)\ninsert into trades values(2018.10.08T01:01:02.125,`B,26)\ninsert into trades values(2018.10.08T01:01:10.000,`A,14)\ninsert into trades values(2018.10.08T01:01:12.457,`A,28)\n\nsleep(10)\n\nselect * from output1;\n\n```\n\nThe calculation for group \"A\" within the subwindow \\[2018.10.08T01:01:00.000, 2018.10.08T01:01:10.000) is triggered by the arrival of data at 2018.10.08T01:01:10.000. No new data from group \"B\" is received after the subwindow ends, so the calculation of group \"B\" is not triggered.\n\n<table id=\"table_mzg_pwy_21c\"><thead><tr><th>\n\ntime\n\n</th><th>\n\nsym\n\n</th><th>\n\nsumVolume\n\n</th></tr></thead><tbody><tr><td>\n\n2018.10.08T01:01:10.000\n\n</td><td>\n\nA\n\n</td><td>\n\n10\n\n</td></tr></tbody>\n</table>\n"
    },
    "createTimeSeriesEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html",
        "signatures": [
            {
                "full": "createTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, [timeColumn], [useSystemTime=false], [keyColumn], [garbageSize], [updateTime], [useWindowStartTime], [roundTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [fill='none'], [forceTriggerTime], [raftGroup], [keyPurgeFreqInSec=-1], [closed='left'], [outputElapsedMicroseconds=false], [subWindow], [parallelism=1], [acceptedDelay=0], [outputHandler=NULL], [msgAsTable=false])",
                "name": "createTimeSeriesEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "windowSize",
                        "name": "windowSize"
                    },
                    {
                        "full": "step",
                        "name": "step"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[updateTime]",
                        "name": "updateTime",
                        "optional": true
                    },
                    {
                        "full": "[useWindowStartTime]",
                        "name": "useWindowStartTime",
                        "optional": true
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[fill='none']",
                        "name": "fill",
                        "optional": true,
                        "default": "'none'"
                    },
                    {
                        "full": "[forceTriggerTime]",
                        "name": "forceTriggerTime",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSec=-1]",
                        "name": "keyPurgeFreqInSec",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[subWindow]",
                        "name": "subWindow",
                        "optional": true
                    },
                    {
                        "full": "[parallelism=1]",
                        "name": "parallelism",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[acceptedDelay=0]",
                        "name": "acceptedDelay",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createTimeSeriesEngine](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html)\n\n\n\n#### Syntax\n\ncreateTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, \\[timeColumn], \\[useSystemTime=false], \\[keyColumn], \\[garbageSize], \\[updateTime], \\[useWindowStartTime], \\[roundTime=true], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[fill='none'], \\[forceTriggerTime], \\[raftGroup], \\[keyPurgeFreqInSec=-1], \\[closed='left'], \\[outputElapsedMicroseconds=false], \\[subWindow], \\[parallelism=1], \\[acceptedDelay=0], \\[outputHandler=NULL], \\[msgAsTable=false])\n\nAlias: createTimeSeriesAggregator\n\n#### Details\n\nThis function creates a time-series streaming engine to conduct real-time time-series calculations with moving windows, and returns a table object where data is ingested for window calculations.\n\nThere are two types of aggregate operators in the time-series engine: incremental operators and full operators. Incremental operators incrementally aggregate the data as they arrive without keeping the historical data. Full operators (e.g., user-defined aggregate functions, unoptimized built-in aggregate functions, or functions with nested state functions) keep all the data in a window and recompute the output as a full refresh whenever new data arrives.\n\nThe following aggregate operators in the time-series engine are optimized for incremental computations: corr, covar, first, last, max, med, min, percentile, quantile, std, var, sum, sum2, sum3, sum4, wavg, wsum, count, firstNot, ifirstNot, lastNot, ilastNot, imax, imin, nunique, prod, sem, mode, searchK, beta, avg.\n\nFor more application scenarios, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n##### Windowing logic\n\nWindow boundaries: The engine automatically adjusts the starting point of the first window. (see parameter description for *step* and *roundTime*, and [alignment rules](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html#alignment-rules)).\n\nWindow properties:\n\n* *windowSize* - the size of each window;\n* *closed* - whether the left/right boundaries of a window is inclusive/exclusive;\n* *step* - the duration of time between windows;\n* *useSystemTime* specifies how values are windowed - based on the time column in the data or the system time of data ingestion.\n\n##### Calculation Rules\n\n* If *timeColumn* is specified, its values must be increasing. If *keyColumn* is specified to group the data, the values in *timeColumn* must be increasing with each group specified by *keyColumn*. Otherwise, out-of-order data will be discarded.\n* If *useSystemTime* = true, the calculation of a window is triggered as soon as the window ends. If *useSystemTime* = false (with *timeColumn* specified), the calculation of a window is triggered by the arrival of the next record after the window ends. To trigger the calculation for the uncalculated windows, you can specify the parameter *updateTime* or *forceTriggerTime*.\n* If *fill* is unspecified or \"None\", only windows with calculation results are output. If *fill* is specified, all windows are output, and the empty windows are filled using the specified filling method.\n* Since version 2.00.11, if *updateTime* = 0, incoming records in the current window can be immediately calculated and output.\n\n##### Other Features\n\n* Data/state cleanup: You can set a cleanup rule to clear historical data. (See parameters *keyPurgeFilter* and *keyPurgeFreInSecond*)\n\n* Snapshot: Snapshot mechanism is used to restore the streaming engine to the latest snapshot after system interruption. (See parameters *snapshotDir* and *snapshotIntervalInMsgCount*)\n\n* High availability: To enable high availability for streaming engines, specify the parameter *raftGroup* on the leader of the raft group on the subscriber. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table.\n\n#### Arguments\n\n**name** is a string indicating the name of the engine. It is the only identifier of an engine on a data or compute node. It can have letter, number and \"\\_\" and must start with a letter.\n\n**windowSize** is a scalar or vector with positive integers that specifies the size of the windows for calculation.\n\n**step** is a positive integer indicating how much each window moves forward relative to the previous one. Note that step must be divisible by *windowSize*, otherwise an exception will be thrown.\n\nThe unit of *windowSize* and *step* are determined by the value of *useSystemTime*.\n\n* If *useSystemTime* =true, the unit of *windowSize* and *step* is millisecond.\n* If *useSystemTime* =false, the unit of *windowSize* and *step* is the same as the unit of *timeColumn*.\n\n**metrics** is metacode or a tuple specifying the calculation formulas. For more information about metacode please refer to [Metaprogramming](https://docs.dolphindb.com/en/Programming/Metaprogramming/functional_meta.html).\n\n* It can use one or more built-in or user-defined aggregate functions (which must be defined by the `defg` keyword) such as `<[sum(volume), avg(price)]>`, or expressions of aggregate functions such as as `<[avg(price1)-avg(price2)]>`, or aggregate functions involving multiple columns such as `<[std(price1-price2)]>`.\n* You can specify functions that return multiple values for *metrics*, such as `<func(price) as `col1`col2>` (it's optional to specify the column names).\n* If *metrics* is a tuple with multiple formulas, *windowSize* is specified as a vector of the same length as *metrics*. Each element of *windowSize* corresponds to the elements in *metrics*. For example, if *windowSize*=\\[10,20], *metrics* can be `(<[min(volume), max(volume)]>, <sum(volume)>)`. *metrics* can also input nested tuple vectors, such as `[[<[min(volume), max(volume)]>, <sum(volume)>], [<avg(volume)>]]`.\n\n**Note:**\n\n* The column names specified in *metrics* are not case-sensitive and can be inconsistent with the column names of the input tables.\n* Nested aggregate function calls are not supported in *metrics*.\n\n**dummyTable** is a table object whose schema must be the same as the subscribed stream table. Whether *dummyTable* contains data does not matter.\n\n**outputTable** is a table to which the engine inserts calculation results. It can be an in-memory table or a DFS table. Create an empty table and specify the column names and types before calling the function.\n\nThe output columns are in the following order:\n\n(1) The first column must be a time column.\n\n* If *useSystemTime* = true, it is TIMESTAMP; Otherwise, it has the same data type as *timeColumn*;\n* If *useWindowStartTime* = true, the column displays the start time of each window; Otherwise, it displays the end time of each window.\n\n(2) If *keyColumn* is specified, the subsequent column(s) must be in the same order as that specified by *keyColumn*.\n\n(3) If *outputElapsedMicroseconds* is set to true, you need to specify a column of LONG type. See the *outputElapsedMicroseconds* parameter for details.\n\n(4) Then followed by one or more result columns.\n\nNote: Starting from version 2.00.10, the engine supports a user-defined aggregate function to merge multiple results in an array vector column. The result column in the output table must be in the form of array vector (i.e., append a pair of square brackets (\\[]) to the data type). See example 3.\n\n**timeColumn** (optional) is a STRING scalar or vector specifying the time column(s) of the subscribed stream table. When *useSystemTime* = false, it must be specified.\n\nNote: If *timeColumn* is a vector, it must have a date element (of DATE type) and a time element (of TIME, SECOND or NANOTIME type). In this case, the first column in *outputTable* must take the data type of concatDateTime(date, time).\n\n**useSystemTime** (optional) is a Boolean value indicating whether the calculations are performed based on the system time when data is ingested into the engine.\n\n* *useSystemTime* = true: the engine will regularly window the streaming data at fixed time intervals for calculations according to the ingestion time (local system time with millisecond precision, independent of any temporal columns in the streaming table) of each record. As long as a window contains data, the calculation will be performed automatically when the window ends. The first column in output table indicates the timestamp when the calculation occurred.\n* *useSystemTime* = false (default): the engine will window the streaming data according to the timeColumn in the stream table. The calculation for a window is triggered by the first record after the previous window. Note that the record which triggers the calculation will not participate in this calculation.\n\nFor example, there is a window ranges from 10:10:10 to 10:10:19. If *useSystemTime* = true and the window is not empty, the calculation will be triggered at 10:10:20. If *useSystemTime* = false and the first record after 10:10:19 is at 10:10:25, the calculation will be triggered at 10:10:25.\n\n**keyColumn** (optional) is a STRING scalar/vector indicating the name of the grouping column(s). If it is specified, the engine conducts the calculations within each group. For example, group the data by stock symbol and apply moving aggregation functions to each stock.\n\n**garbageSize** (optional) is a positive integer. The default value is 50,000 (rows). The subscribed data continues to accumulate in the engine. When the number of rows of historical data in the memory exceeds *garbageSize*, the system will clear the historical data that is no longer needed.\n\nNote: For incremental operators, the data no longer needed will be automatically removed from memory. However, for full operators, this parameter must be specified to enable garbage collection.\n\n**updateTime** (optional) is a non-negative integer which takes the same time precision as *timeColumn*. It is used to trigger window calculations at an interval shorter than *step*. *step* must be a multiple of *updateTime*. To specify *updateTime*, *useSystemTime* must be set to false.\n\nIf *updateTime* is not specified, calculation for a window will not occur before the window ends. By specifying *updateTime*, you can calculate the values for several times in an window of which calculation hasn't been triggered for a long time.\n\nThe calculations within a window are triggered with the following rules:\n\n* Starting from the left boundary of the window, if there is a new record arriving after every *updateTime*, all data before this record in the current window is calculated. If it still has unprocessed data after 2\\**updateTime* (at least 2 seconds), all data in this window is calculated.\n* If *keyColumn* is specified, these rules apply within each group.\n\nIt is recommended to specify a keyed table for *outputTable* if *updateTime* is set. If *outputTable* is a standard in-memory table or stream table, it will have multiple results for each timestamp (in each group). It is not recommended to use a keyed stream table either as the records of a keyed stream table cannot be updated.\n\n**useWindowStartTime** (optional) is a Boolean value indicating whether the time column in *outputTable* is the starting time of the windows. The default value is false, which means the timestamps in the output table are the end time of the windows. If the *windowSize* is a vector, *useWindowStartTime* must be false.\n\n**roundTime** (optional) is a Boolean value indicating the method to align the window boundary if the time precision is milliseconds or seconds and step is bigger than one minute. The default value is true indicating the alignment is based on the multi-minute rule (see the [alignment rules](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html#alignment-rules)). False means alignment is based on the one-minute rule.\n\n**snapshotDir** (optional) is a string indicating the directory where the streaming engine snapshot is saved. The directory must already exist, otherwise an exception is thrown. If *snapshotDir* is specified, the system checks whether a snapshot already exists in the directory when creating a streaming engine. If it exists, the snapshot will be loaded to restore the engine state. Multiple streaming engines can share a directory where the snapshot files are named as the engine names.\n\nThe file extension of a snapshot can be:\n\n* * *\\<engineName>.tmp*: temporary snapshot\n* *\\<engineName>.snapshot*: a snapshot that is generated and flushed to disk\n* *\\<engineName>.old*: if a snapshot with the same name already exists, the previous snapshot is renamed to *\\<engineName>.old*.\n\n**snapshotIntervalInMsgCount** (optional) is a positive integer indicating the number of messages to receive before the next snapshot is saved.\n\n**fill** (optional) is a vector/scalar indicating the filling method to deal with an empty window (in a group). It can be:\n\n* 'none': no result\n* 'null': output a NULL value.\n* 'ffill': output the result in the last window.\n* specific value: output the specified value. Its type should be the same as metrics output's type.\n\n*fill* could be a vector to specify different filling method for each metric. The size of the vector must be consistent with the number of elements specified in *metrics*. The element in vector cannot be 'none'.\n\n**forceTriggerTime** (optional) is a non-negative integer which takes the same time precision as *timeColumn*, indicating the waiting time to force trigger calculation in the uncalculated windows for each group. If *forceTriggerTime* is set, *useSystemTime* must be false and *updateTime* cannot be specified.\n\nThe rules are as follow:\n\n(1) Suppose the end time of the uncalculated window is t, and an incoming record of another group arrives at t1: when t1-t>=forceTriggerTime, calculation of the window will be triggered.\n\n(2) If no data is ingested into a group after the last window is calculated, and new data continues to ingest into other groups, the specified *fill* parameter can be used to fill results for empty windows of that group. The group's windows will still be output at the latest time point. If parameter *fill* is not specified, no new windows will be generated for that group after the last window has been triggered for computation.\n\nNote the following points when setting *forceTriggerTime* or *updateTime*:\n\n* If *updateTime* is specified, the result of the current window calculation will be updated again when data belonging to the current window still arrives after the calculation is triggered.\n* If *forceTriggerTime* is specified, the incoming data with a timestamp within the current window will be discarded after the calculation is forced to be triggered.\n\n**raftGroup** (optional) is an integer greater than 1, indicating ID of the raft group on the high-availability streaming subscriber specified by the configuration parameter *streamingRaftGroups*. Specify *raftGroup* to enable high availability on the streaming engine. When an engine is created on the leader, it is also created on each follower and the engine snapshot is synchronized to the followers. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table. Note that *SnapShotDir* must also be specified when specifying a raft group.\n\n**keyPurgeFreqInSec** (optional) is a positive integer indicating the interval (in seconds) to remove groups with no incoming data for a long time. If a group has no incoming data for at least *keyPurgeFreqInSec* seconds after the last time of data purging, it will be removed.\n\nNote: To specify this parameter, parameter *forceTriggerTime* must be specified and parameter *fill* cannot be specified.\n\nYou can check the number of groups in a time-series streaming engine based on the column \"numGroups\" returned by [getStreamEngineStat](https://docs.dolphindb.com/en/Functions/g/getStreamEngineStat.html).\n\n**closed** (optional) is a STRING indicating whether the left or the right boundary is included.\n\n* closed = 'left': left-closed, right-open\n* closed = 'right': left-open, right-closed\n\n**outputElapsedMicroseconds** (optional) is a BOOLEAN value. The default value is false. It determines whether to output the elapsed time (in microseconds) from the time the calculation is triggered to the output of result for each window.\n\n**subWindow**(optional)is a pair of integers or DURATION values, indicating the range of the subwindow within the window specified by *windowSize*. If specified, only results calculated within subwindows will be returned and the time column of the output table displays the end time of each subwindow. The calculation of the subwindow will be triggered by the arrival of the next record after the subwindow ends. The boundary of the subwindow is determined by parameter *closed*. When *subWindow* is a pair of integers, it takes the same time precision as *timeColumn*.\n\nIf it is specified, note that:\n\n* *windowSize* must be equal to *step*.\n* Shall not specify *updateTime*>0 and *useSystemTime*=true.\n\n**parallelism** (optional) is a positive integer no greater than 63, representing the number of worker threads for parallel computation. The default value is 1. For compute-intensive workloads, adjusting this parameter appropriately can effectively utilize computing resources and reduce computation time. It is recommended to set a value less than the number of CPU cores, normally from 4 to 8.\n\n**acceptedDelay** (optional) is a positive integer less than or equal to\\*windowSize,\\*specifying the maximum delay for each window to accept data.The default value is 0.\n\n* When *useSystemTime*=true, data received within the *acceptedDelay*time after the window ends will still be considered part of the current window and participate in the computation, and will not be included in the computation of the next window.\n* When *useSystemTime*=false, a window with t as right boundary will wait until a record with a timestamp equal to or later than t + *acceptedDelay* arrives. When such a record arrives, the current window closes and performs a calculation on all records within the window frame. This handles scenarios with out-of-order data.\n\n**outputHandler** (optional) is a unary function or a partial function with a single unfixed parameter. If set, the engine will not write the calculation results to the output table directly. Instead, the results will be passed as a parameter to the *outputHandler* function. The default value is NULL, which means the result will be written to the output table.\n\n**msgAsTable** (optional) is a Boolean scalar indicating whether the output data is passed into function (specified by *outputHandler*) as a table or as a tuple. If *msgAsTable*=true, the subscribed data is passed into function as a table. The default value is false, which means the output data is passed into function as a tuple of columns.\n\n#### Alignment Rules\n\nTo facilitate observation and comparison of calculation results, the engine automatically adjusts the starting point of the first window. The alignment size (integer) will be decided by parameter *step*, *roundTime*, and the precision of *timeColumn*. When time series engine calculates within groups, all groups' windows will be uniformly aligned. The boundaries of each window are the same for each group.\n\n* If the data type of *timeColumn* is MINUTE(HH:mm), the value of *alignmentSize* is as follows:\n\n  *if roundTime=false*:\n\n  | step   | alignmentSize |\n  | ------ | ------------- |\n  | 0\\~2   | 2             |\n  | 3      | 3             |\n  | 4\\~5   | 5             |\n  | 6\\~10  | 10            |\n  | 11\\~15 | 15            |\n  | 16\\~20 | 20            |\n  | 21\\~30 | 30            |\n  | >30    | 60 (1 hour)   |\n\n  *if roundTime=true*:\n\n  The value of *alignmentSize* is same as above table if *step*<=30; The value of *alignmentSize* is as folllows if *step*>30:\n\n  | step       | alignmentSize   |\n  | ---------- | --------------- |\n  | 31\\~60     | 60 (1 hour)     |\n  | 60\\~120    | 120 (2 hours)   |\n  | 121\\~180   | 180 (3 hours)   |\n  | 181\\~300   | 300 (5 hours)   |\n  | 301\\~600   | 600 (10 hours)  |\n  | 601\\~900   | 900 (15 hours)  |\n  | 901\\~1200  | 1200 (20 hours) |\n  | 1201\\~1800 | 1800 (30 hours) |\n  | >1800      | 3600 (60 hours) |\n\n* If the data type of *timeColumn* is DATETIME (yyyy-MM-dd HH:mm:ss) or SECOND (HH:mm:ss), the value of *alignmentSize* is as follows:\n\n  *if roundTime=false*:\n\n  | step   | alignmentSize |\n  | ------ | ------------- |\n  | 0\\~2   | 2             |\n  | 3      | 3             |\n  | 4\\~5   | 5             |\n  | 6\\~10  | 10            |\n  | 11\\~15 | 15            |\n  | 16\\~20 | 20            |\n  | 21\\~30 | 30            |\n  | >30    | 60 (1minute)  |\n\n  *if roundTime=true*:\n\n  The value of *alignmentSize* is same as above table if step<=30; The value of *alignmentSize* is as folllows if step>30:\n\n  | step       | alignmentSize    |\n  | ---------- | ---------------- |\n  | 31\\~60     | 60 (1minute)     |\n  | 61\\~120    | 120 (2minutes)   |\n  | 121\\~180   | 180 (3minutes)   |\n  | 181\\~300   | 300 (5minutes)   |\n  | 301\\~600   | 600 (10minutes)  |\n  | 601\\~900   | 900 (15minutes)  |\n  | 901\\~1200  | 1200 (20minutes) |\n  | 1201\\~1800 | 1800 (30minutes) |\n  | >1800      | 3600 (1hour)     |\n\n* If the data type of *timeColumn* is TIMESTAMP(yyyy-MM-dd HH:mm:ss.mmm) or TIME(HH:mm:ss.mmm), the value of *alignmentSize* is as follows:\n\n  *if roundTime=false*:\n\n  | step         | alignmentSize    |\n  | ------------ | ---------------- |\n  | 0\\~2         | 2                |\n  | 3\\~5         | 5                |\n  | 6\\~10        | 10               |\n  | 11\\~20       | 20               |\n  | 21\\~25       | 25               |\n  | 26\\~50       | 50               |\n  | 51\\~100      | 100              |\n  | 101\\~200     | 200              |\n  | 201\\~250     | 250              |\n  | 251\\~500     | 500              |\n  | 501\\~1000    | 1000(1second)    |\n  | 1001\\~2000   | 2000(2seconds)   |\n  | 2001\\~5000   | 5000(5seconds)   |\n  | 5001\\~10000  | 10000(10seconds) |\n  | 10001\\~15000 | 15000(15seconds) |\n  | 15001\\~20000 | 20000(20seconds) |\n  | 20001\\~30000 | 30000(30seconds) |\n  | >30000       | 60000(1minutes)  |\n\n  *if roundTime=true:*\n\n  The value of *alignmentSize* is same as above table if step<=30000; The value of *alignmentSize* is as folllows if step>30000:\n\n  | step             | alignmentSize      |\n  | ---------------- | ------------------ |\n  | 30001\\~60000     | 60000(1minute)     |\n  | 60001\\~120000    | 120000(2minutes)   |\n  | 120001\\~300000   | 300000(5minutes)   |\n  | 300001\\~600000   | 600000(10minutes)  |\n  | 600001\\~900000   | 900000(15minutes)  |\n  | 900001\\~1200000  | 1200000(20minutes) |\n  | 1200001\\~1800000 | 1800000(30minutes) |\n  | >1800000         | 3600000(1hour)     |\n\n* If the data type of *timeColumn* is NANOTIMESTAMP(yyyy-MM-dd HH:mm:ss.nnnnnnnnn) or NANOTIME(HH:mm:ss.nnnnnnnnn), the value of *alignmentSize* is as follows:\n\n  *if roundTime=false*:\n\n  | step         | alignmentSize |\n  | ------------ | ------------- |\n  | 0\\~2ns       | 2ns           |\n  | 3ns\\~5ns     | 5ns           |\n  | 6ns\\~10ns    | 10ns          |\n  | 11ns\\~20ns   | 20ns          |\n  | 21ns\\~25ns   | 25ns          |\n  | 26ns\\~50ns   | 50ns          |\n  | 51ns\\~100ns  | 100ns         |\n  | 101ns\\~200ns | 200ns         |\n  | 201ns\\~250ns | 250ns         |\n  | 251ns\\~500ns | 500ns         |\n  | >500ns       | 1000ns        |\n\n  *if roundTime=true*:\n\n  | step        | alignmentSize |\n  | ----------- | ------------- |\n  | 1000ns\\~1ms | 1ms           |\n  | 1ms\\~10ms   | 10ms          |\n  | 10ms\\~100ms | 100ms         |\n  | 100ms\\~1s   | 1s            |\n  | 1s\\~2s      | 2s            |\n  | 2s\\~3s      | 3s            |\n  | 3s\\~5s      | 5s            |\n  | 5s\\~10s     | 10s           |\n  | 10s\\~15s    | 15s           |\n  | 15s\\~20s    | 20s           |\n  | 20s\\~30s    | 30s           |\n  | >30s        | 1min          |\n\nIf the time of the first record is x with data type of TIMESTAMP, then the starting time of the first window is adjusted to be `timeType_cast(x/alignmentSize*alignmentSize+step-windowSize)`, where \"/\" produces only the integer part after division. For example, if the time of the first record is 2018.10.08T01:01:01.365, *windowSize* = 120000, and *step* = 60000, then *alignmentSize* = 60000, and the starting time of the first window is timestamp(2018.10.08T01:01:01.365/60000\\*60000+60000-120000)=2018.10.08T01:01:00.000.\n\n#### Examples\n\nExample 1\n\nIn the following example, the time-series engine1 subscribes to the stream table \"trades\" and calculates sum(volume) for each stock in the last minute in real time. The result is saved in table output1.\n\n```\nshare streamTable(1000:0, `time`sym`volume, [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output1\nengine1 = createTimeSeriesEngine(name=\"engine1\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=append!{engine1}, msgAsTable=true);\n\ninsert into trades values(2018.10.08T01:01:01.785,`A,10)\ninsert into trades values(2018.10.08T01:01:02.125,`B,26)\ninsert into trades values(2018.10.08T01:01:10.263,`B,14)\ninsert into trades values(2018.10.08T01:01:12.457,`A,28)\ninsert into trades values(2018.10.08T01:02:10.789,`A,15)\ninsert into trades values(2018.10.08T01:02:12.005,`B,9)\ninsert into trades values(2018.10.08T01:02:30.021,`A,10)\ninsert into trades values(2018.10.08T01:04:02.236,`A,29)\ninsert into trades values(2018.10.08T01:04:04.412,`B,32)\ninsert into trades values(2018.10.08T01:04:05.152,`B,23)\n\nsleep(10)\n\nselect * from output1;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:02:00.000 | A   | 38        |\n| 2018.10.08T01:02:00.000 | B   | 40        |\n| 2018.10.08T01:03:00.000 | A   | 25        |\n| 2018.10.08T01:03:00.000 | B   | 9         |\n\nThe following paragraphs explain in details how the time-series engine conducts the calculations. For simplicity, regarding the \"time\" column we ignore the part of \"2018.10.08T\" and only use the \"hour:minute:second.millisecond\" part.\n\nFirst, the time-series engine adjusts the starting time of the first window to be 01:01:00.000. The first window is from 01:01:00.000 (inclusive) to 01:02:00.000 (exclusive). When the record (01:02:10.789,\\`A,15) arrives, it triggers the calculation of group A for the first window; the arrival of (01:02:12.005,\\`B,9) triggers the calculation of group B for the first window.\n\nThe second window is from 01:02:00.000 (inclusive) to 01:03:00.000 (exclusive). When the record (01:04:02.236,\\`A,29) arrives, it triggers the calculation of group A for the second window; the arrival of (01:04:04.412,\\`B,32) triggers the calculation of group B for the second window.\n\nAs there are no records since 01:05:00.000, no calculations are triggered for the window of \\[01:04:00.000, 01:05:00.000).\n\nThe table output1 stores the calculation results of the time-series engine. As *useWindowStartTime*=false, the timestamps in the output table are the end time of the windows. If *useWindowStartTime*=true, then the timestamps in the output table are the starting time of the windows, as illustrated in the following example:\n\n```\nshare table(10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output2\nengine2 = createTimeSeriesEngine(name=\"engine2\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output2, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50, useWindowStartTime=true)\nsubscribeTable(tableName=\"trades\", actionName=\"engine2\", offset=0, handler=append!{engine2}, msgAsTable=true)\n\nsleep(10)\nselect * from output2;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:01:00.000 | A   | 38        |\n| 2018.10.08T01:01:00.000 | B   | 40        |\n| 2018.10.08T01:02:00.000 | A   | 25        |\n| 2018.10.08T01:02:00.000 | B   | 9         |\n\nExample 2\n\nIn the following example, we specify *updateTime* to be 1000 (milliseconds):\n\n```\nshare keyedTable(`time`sym,10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output3\nengine3 = createTimeSeriesEngine(name=\"engine3\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output3, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50, updateTime=1000, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"engine3\", offset=0, handler=append!{engine3}, msgAsTable=true)\n\nsleep(2001)\nselect * from output3;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:02:00.000 | A   | 38        |\n| 2018.10.08T01:02:00.000 | B   | 40        |\n| 2018.10.08T01:03:00.000 | A   | 25        |\n| 2018.10.08T01:03:00.000 | B   | 9         |\n| 2018.10.08T01:05:00.000 | B   | 55        |\n| 2018.10.08T01:05:00.000 | A   | 29        |\n\nNext, we will explain the calculations triggered in the last window from 01:04:00.000 to 01:05:00.000.\n\n(1) At 01:04:04.236, 2000 milliseconds after the first record of group A arrived, a group A calculation is triggered. The result (01:05:00.000, \\`A, 29) is written to the output table.\n\n(2) The record of group B at 01:04:05.152 is the first record after the small window of \\[01:04:04.000, 01:04:05.000) that contains the group B record at 01:04:04.412. It triggers a group B calculation. The result (01:05:00.000,\"B\",32) is written to the output table.\n\n(3) 2000 milliseconds later, at 01:04:07.152, as the B group record at 1:04:05.152 has not been used in a calculation, a group B calculation is triggered. The result is (01:05:00.000,\"B\",55). As the output table's keys are columns 'time' and 'sym', the record of (01:05:00.000,\\`B,32) in the output table is updated and becomes (01:05:00.000,\\`B,55).\n\nIn the example, the shared stream table \"pubT\" contains two time columns with the type of DATE and SECOND. When creating time series engine, the two time columns could be combined into one column with the type of DATETIME in output table \"streamMinuteBar\\_1min\" by setting *timeColumn*.\n\n```\ncolNames=`symbol`date`minute`price`type`volume\ncolTypes=`SYMBOL`DATE`SECOND`DOUBLE`STRING`INT\npubTable = streamTable(10000:0,colNames,colTypes)\nshare pubTable as pubT\n\ncolNames = `time`symbol`open`max`min`close`volume`amount`ret`vwap\ncolTypes = `DATETIME`SYMBOL`DOUBLE`DOUBLE`DOUBLE`DOUBLE`INT`DOUBLE`DOUBLE`DOUBLE\nshare streamTable(10000:0,colNames, colTypes) as streamMinuteBar_1min\n\ntsAggrOHLC = createTimeSeriesEngine(name=\"subT\", windowSize=60, step=60, metrics=<[first(price) as open ,max(price) as max,min(price) as min ,last(price) as close ,sum(volume) as volume ,wsum(volume, price) as amount ,(last(price)-first(price)/first(price)) as ret, (wsum(volume, price)/sum(volume)) as vwap]>, dummyTable=pubTable, outputTable=streamMinuteBar_1min, timeColumn=`date`minute, useSystemTime=false, keyColumn='symbol', fill=`none)\nsubscribeTable(tableName=\"pubT\", actionName=\"subT\", offset=-1, handler=append!{tsAggrOHLC}, msgAsTable=true)\n\ninsert into pubT values(`000001, 2021.04.05, 09:25:01, 1, 'B', 1)\ninsert into pubT values(`000001, 2021.04.05, 09:30:05, 2, 'B', 1)\ninsert into pubT values(`000001, 2021.04.05, 09:31:06, 3, 'B', 1)\ninsert into pubT values(`000001, 2021.04.05, 09:35:05, 4, 'S', 4)\ninsert into pubT values(`000001, 2021.04.05, 09:40:05, 5, 'S', 5)\ninsert into pubT values(`000001, 2021.04.06, 09:25:05, 6, 'S', 6)\n```\n\n| symbol | date       | minute   | price | type | volume |\n| ------ | ---------- | -------- | ----- | ---- | ------ |\n| 000001 | 2021.04.05 | 09:25:01 | 1     | B    | 1      |\n| 000001 | 2021.04.05 | 09:30:05 | 2     | B    | 1      |\n| 000001 | 2021.04.05 | 09:31:06 | 3     | B    | 1      |\n| 000001 | 2021.04.05 | 09:35:05 | 4     | S    | 4      |\n| 000001 | 2021.04.05 | 09:40:05 | 5     | S    | 5      |\n| 000001 | 2021.04.06 | 09:25:05 | 6     | S    | 6      |\n\n```\nselect * from streamMinuteBar_1min\n```\n\n| time                | symbol | open | max | min | close | volume | amount | ret | vwap |\n| ------------------- | ------ | ---- | --- | --- | ----- | ------ | ------ | --- | ---- |\n| 2021.04.05T09:26:00 | 000001 | 1    | 1   | 1   | 1     | 1      | 1      | 0   | 1    |\n| 2021.04.05T09:31:00 | 000001 | 2    | 2   | 2   | 2     | 1      | 2      | 1   | 2    |\n| 2021.04.05T09:32:00 | 000001 | 3    | 3   | 3   | 3     | 1      | 3      | 2   | 3    |\n| 2021.04.05T09:36:00 | 000001 | 4    | 4   | 4   | 4     | 4      | 16     | 3   | 4    |\n| 2021.04.05T09:41:00 | 000001 | 5    | 5   | 5   | 5     | 5      | 25     | 4   | 5    |\n\n```\nshare streamTable(1000:0, `time`sym`qty, [DATETIME, SYMBOL, INT]) as trades\nshare table(10000:0, `time`sym`sumQty, [DATETIME, SYMBOL, INT]) as output3\n\nengine = createTimeSeriesEngine(name=\"engine\", windowSize=6, step=6, metrics=<sum(qty)>, dummyTable=trades, outputTable=output3, timeColumn=`time,keyColumn=`sym, forceTriggerTime=7,fill=1000)\nsubscribeTable(tableName=\"trades\", actionName=\"engine\", offset=0, handler=append!{engine}, msgAsTable=true)\nsleep(1000)\ninsert into engine values(2018.08.01T14:05:43,`A,1)\ninsert into engine values(2018.08.01T14:05:43,`C,3)\nsleep(10)\ninsert into engine values(2018.08.01T14:05:44,`B,1)\nsleep(80)\ninsert into engine values(2018.08.01T14:05:52,`B,3)\nsleep(20)\ninsert into engine values(2018.08.01T14:05:54,`A,3)\nsleep(10)\ninsert into engine values(2018.08.01T14:05:55,`A,5)\nsleep(20)\ninsert into engine values(2018.08.01T14:05:57,`B,5)\nsleep(50)\ninsert into engine values(2018.08.01T14:06:12,`A,1)\nsleep(50)\nselect * from output3 order by sym\n```\n\n| time                | sum | Qty   |\n| ------------------- | --- | ----- |\n| 2018.08.01T14:05:46 | A   | 1     |\n| 2018.08.01T14:05:52 | A   | 1,000 |\n| 2018.08.01T14:05:58 | A   | 8     |\n| 2018.08.01T14:06:04 | A   | 1,000 |\n| 2018.08.01T14:06:10 | A   | 1,000 |\n| 2018.08.01T14:05:46 | B   | 1     |\n| 2018.08.01T14:05:52 | B   | 1,000 |\n| 2018.08.01T14:05:58 | B   | 8     |\n| 2018.08.01T14:05:46 | C   | 3     |\n| 2018.08.01T14:05:52 | C   | 1,000 |\n\nExample 3\n\nThe following example calculates the first/last volume in each window and merges the result in an array vector column.\n\n```\n// Define a function toVector with defg. The results are merged into array vectors\ndefg toVector(x){\n    return x\n}\nshare streamTable(1000:0, `time`sym`volume`price, [TIMESTAMP, SYMBOL, DOUBLE,DOUBLE]) as trades\n// Define the output table and specify the result column as DOUBLE[] type\nshare table(10000:0, `time`sym`sumVolume`avg, [TIMESTAMP,STRING,DOUBLE[],DOUBLE]) as output1\n// Call toVector in metrics to combine the first and last volumes in a 1-minute window into an array vector\nengine1 = createTimeSeriesEngine(name=\"engine1\", windowSize=60000, step=60000, metrics=<[toVector([first(volume),last(volume)]),avg(volume+price)]>, dummyTable=trades, outputTable=output1, timeColumn=`time, keyColumn=`sym , useSystemTime=false, garbageSize=50, useWindowStartTime=false)\n\ntimes = sort(2023.10.08T00:00:00.000 + rand(1..(1+3000*200), 30))\nsyms = rand(\"A\"+string(1..10), 30)\nvolumes = rand(rand(100.0, 10) join 2.3 NULL NULL NULL NULL, 30)\nprices = rand(rand(100.0, 10) join 2.3 NULL NULL NULL NULL, 30)\nt=table(times as time, syms as sym, volumes as volume,prices as price)\n\nengine1.append!(t)\n\nselect * from output1 where time between 2023.10.08T00:01:00.000 and 2023.10.08T00:05:00.000 order by time,sym \n```\n\n| time                    | sym | sumVolume                             | avg                |\n| ----------------------- | --- | ------------------------------------- | ------------------ |\n| 2023.10.08 00:01:00.000 | A1  | \\[, ]                                 |                    |\n| 2023.10.08 00:02:00.000 | A4  | \\[2.3, 2.3]                           |                    |\n| 2023.10.08 00:03:00.000 | A10 | \\[68.5665876371786, 68.5665876371786] | 121.97567140683532 |\n| 2023.10.08 00:03:00.000 | A6  | \\[, 22.65533998142928]                | 33.386794407851994 |\n\nExample 4\n\nThe following example specifies the parameter *subWindow*.\n\n```\n\nshare streamTable(1000:0, `time`sym`volume, [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output1\n//specify a 10-second subwindow within a 1-min window. With closed unspecified, the subwindow takes the default value, i.e., left-closed, right-open window, [0s, 10s).\nengine4 = createTimeSeriesEngine(name=\"engine4\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50, useWindowStartTime=true, subWindow=0s:10s)\n\nsubscribeTable(tableName=\"trades\", actionName=\"engine4\", offset=0, handler=append!{engine4}, msgAsTable=true);\n\ninsert into trades values(2018.10.08T01:01:01.785,`A,10)\ninsert into trades values(2018.10.08T01:01:02.125,`B,26)\ninsert into trades values(2018.10.08T01:01:10.000,`A,14)\ninsert into trades values(2018.10.08T01:01:12.457,`A,28)\n\nsleep(10)\n\nselect * from output1;\n\n```\n\nThe calculation for group \"A\" within the subwindow \\[2018.10.08T01:01:00.000, 2018.10.08T01:01:10.000) is triggered by the arrival of data at 2018.10.08T01:01:10.000. No new data from group \"B\" is received after the subwindow ends, so the calculation of group \"B\" is not triggered.\n\n<table id=\"table_mzg_pwy_21c\"><thead><tr><th>\n\ntime\n\n</th><th>\n\nsym\n\n</th><th>\n\nsumVolume\n\n</th></tr></thead><tbody><tr><td>\n\n2018.10.08T01:01:10.000\n\n</td><td>\n\nA\n\n</td><td>\n\n10\n\n</td></tr></tbody>\n</table>\n"
    },
    "createUser": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createUser.html",
        "signatures": [
            {
                "full": "createUser(userId, password, [groupIds], [isAdmin=false])",
                "name": "createUser",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    },
                    {
                        "full": "password",
                        "name": "password"
                    },
                    {
                        "full": "[groupIds]",
                        "name": "groupIds",
                        "optional": true
                    },
                    {
                        "full": "[isAdmin=false]",
                        "name": "isAdmin",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createUser](https://docs.dolphindb.com/en/Functions/c/createUser.html)\n\n\n\n#### Syntax\n\ncreateUser(userId, password, \\[groupIds], \\[isAdmin=false])\n\n#### Arguments\n\n**userId** is a string indicating a user name. It can only contain letters, underscores, or numbers. It cannot start with numbers. The length cannot exceed 30 characters.\n\n**password** is a string indicating the password. It cannot contain space or control characters.\n\nSince DolphinDB 2.00.10.10, users can determine whether to verify the complexity of *password* by setting the configuration *enhancedSecurityVerification*. If it is not specified, no verification will be applied; if it is set to true, the password must meet the following conditions:\n\n* 8-20 characters\n\n* at least 1 capital letter\n\n* at least 1 special character, including !\"#$%&'()\\*+,-./:;<=>?@\\[]^\\_\\`{|}\\~\n\n**groupIds** (optional) is a STRING scalar/vector indicating the group(s) the user belongs to.\n\n**isAdmin** (optional) is a Boolean value indicating whether the user is an administrator.\n\n#### Details\n\nCreate an user. It can only be executed by an administrator.\n\nThe groups in groupIds must have been created with [createGroup](https://docs.dolphindb.com/en/Functions/c/createGroup.html).\n\n#### Examples\n\nCreate a user with user name 'JohnSmith' and password 'Qb0507'. This user belongs to group \"research\" and group \"production. He is not an administrator.\n\n```\ncreateUser(`JohnSmith, \"Qb0507#$\", `research`production);\n```\n"
    },
    "createWindowJoinEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/c/createWindowJoinEngine.html",
        "signatures": [
            {
                "full": "createWindowJoinEngine(name, leftTable, rightTable, outputTable, window, metrics, matchingColumn, [timeColumn], [useSystemTime=false], [garbageSize = 5000], [maxDelayedTime], [nullFill], [outputElapsedMicroseconds=false], [sortByTime=false],[closed])",
                "name": "createWindowJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[garbageSize = 5000]",
                        "name": "[garbageSize = 5000]"
                    },
                    {
                        "full": "[maxDelayedTime]",
                        "name": "maxDelayedTime",
                        "optional": true
                    },
                    {
                        "full": "[nullFill]",
                        "name": "nullFill",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[sortByTime=false]",
                        "name": "sortByTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createWindowJoinEngine](https://docs.dolphindb.com/en/Functions/c/createWindowJoinEngine.html)\n\n\n\n#### Syntax\n\ncreateWindowJoinEngine(name, leftTable, rightTable, outputTable, window, metrics, matchingColumn, \\[timeColumn], \\[useSystemTime=false], \\[garbageSize = 5000], \\[maxDelayedTime], \\[nullFill], \\[outputElapsedMicroseconds=false], \\[sortByTime=false],\\[closed])\n\n#### Details\n\nCreate a window join streaming engine. Return a table object that is the real-time [window join](https://docs.dolphindb.com/en/Programming/SQLStatements/TableJoiners/windowjoin.html) result of a left table and a right table.\n\nData ingested into the engine is grouped by *matchingColumn*. Within a group, for each record in the left table, calculate the *metrics* over the specified window in the right table and return the metrics in additional columns.\n\n**Standard windows (i.e., *window* = *a:b*)**:\n\nThe windows over the right table are determined by the current timestamp in the left table and the specified parameter *window*. Suppose the current timestamp in the left table is *t*, and window is set to *a:b*, then the corresponding window in the right table consists of records with timestamps in \\[t+a, t+b]. The engine returns the join result containing the results of the metrics calculated using the windowed data.\n\nWindow triggering rules:\n\n* A window is triggered when a timestamp (with the same *matchingColumn* value) past the end of that window arrives in the right table. The record itself does not participate in the calculation of that window.\n* If *maxDelayedTime* is specified - a new timestamp *t* (regardless of its *matchingColumn* value) in the right table triggers an uncalculated window when *t > b + maxDelayedTime*\n\n**Special windows (i.e., *window* = *0:0*, *maxDelayedTime* is not supported)**:\n\nThe windows over the right table are determined by the current timestamp in the left table and its previous timestamp. By default, the window is left-closed and right-open.Suppose the current timestamp in the left table is *t* and the previous timestamp is *t0*, then the corresponding window in the right table consists of records with timestamps in \\[*t0*, *t*).The window boundary can be adjusted using the *closed*parameter.\n\nWindow triggering rules:\n\n* When *useSystemTime* = false, a window is triggered when a timestamp past the end of that window arrives in the right table.\n* When *useSystemTime* = true, a window is triggered at the ingestion of each record in the left table.\n\nNote: When *window* = *0:0*, *metrics* does not support non-aggregate functions that are applied to columns from the right table. if *metrics* contains a non-aggregate function which applies to a right table column, the corresponding output column must be specified as an array vector of the appropriate data type.\n\nFor more application scenarios of streaming engines, see [Streaming Engines](https://docs.dolphindb.com/en/Streaming/streaming_engines.html).\n\n#### Arguments\n\n**name** is a string indicating the name of the window join streaming engine. It is the unique identifier of the engine on a data/compute node. It can contain letters, numbers and underscores and must start with a letter.\n\n**leftTable** and **rightTable** are table objects whose schema must be the same as the stream table to which the engine subscribes. Since version 2.00.10, array vectors are allowed for *leftTable*.\n\n**outputTable** is a table to which the engine inserts calculation result. It can be an in-memory table or a DFS table. Before calling a function, an empty table with specified column names must be created.\n\nThe columns of *outputTable* are in the following order:\n\n(1) The first column must be a temporal column.\n\n* if *useSystemTime* = true, the data type must be TIMESTAMP;\n\n* if *useSystemTime* = false, it has the same data type as *timeColumn*.\n\n(2) Then followed by one or more columns on which the tables are joined, arranged in the same order as specified in *matchingColumn*.\n\n(3) Further followed by one or more columns which are the calculation results of *metrics*.\n\n(4) If the *outputElapsedMicroseconds* is set to true, specify two more columns: a LONG column and an INT column.\n\n**window** is a pair of integers or duration values, indicating the range of a sliding window, including both left and right bounds.\n\n**metrics** is metacode (which can be a tuple) specifying the calculation formulas. For more information about metacode, please refer to [Metaprogramming](https://docs.dolphindb.com/en/Programming/Metaprogramming/functional_meta.html).\n\n* *metrics* can use one or more expressions, built-in or user-defined functions (both aggregate functions and non-aggregate functions are accepted).\n\n* *metrics* can be functions that return multiple values and the columns in the output table to hold the return values must be specified. For example, \\<func(price) as \\`col1\\`col2>.\n\n* The column names specified in *metrics* are not case-sensitive and can be inconsistent with the column names of the input tables.\n\nIf you want to specify a column that exists in both the left and the right tables, use the format *tableName.colName*. By default, the column from the left table is used.\n\nPerformance will be optimized when the following functions are applied to and only to columns from the right table. `sum`, `sum2`, `avg`, `std`, `var`, `corr`, `covar`, `wavg`, `wsum`, `beta`, `max`, `min`, `last`, `first`, `med`, `percentile`.\n\n**matchingColumn** is a STRING scaler/vector/tuple indicating the column(s) on which the tables are joined. It supports integral, temporal or literal (except UUID) types.\n\n* When there is only 1 column to match - If the names of the matching column are the same in both tables, *matchingColumn* should be specified as a STRING scalar; otherwise it's a tuple of two elements. For example, if the column is named \"sym\" in the left table and \"sym1\" in the right table, then *matchingColumn* = \\[\\[\\`sym],\\[\\`sym1]].\n* When there are multiple columns to match - If the names of all the columns to match are the same in both tables, *matchingColumn* is a STRING vector; otherwise it's a tuple of two elements. For example, if the columns are named \"timestamp\" and \"sym\" in the left table, whereas in the right table they're named \"timestamp\" and \"sym1\", then matchingColumn = \\[\\[\\`timestamp, \\`sym], \\[\\`timestamp,\\`sym1]].\n\n**timeColumn** (optional) When *useSystemTime* = false, it must be specified to indicate the name(s) of the time column in the left table and the right table. The time columns must have the same data type. If the names of the time column in the left table and the right table are the same, *timeColumn* is a string. Otherwise, it is a vector of 2 strings indicating the time column in each table.\n\n**useSystemTime** (optional) indicates whether the left table and the right table are joined on the system time, instead of on the *timeColumn*.\n\n* *useSystemTime* = true: join records based on the system time (timestamp with millisecond precision) when they are ingested into the engine.\n\n* *useSystemTime* = false (default): join records based on the specified timeColumn from the left table and the right table.\n\n**garbageSize** (optional) is a positive integer with the default value of 5,000 (rows). As the subscribed data is ingested into the engine, it continues to take up the memory. Within the left/right table, the records are grouped by *matchingColumn* values; When the number of records in a group exceeds *garbageSize*, the system will remove those already been calculated from memory.\n\n**maxDelayedTime** (optional) is a positive integer with the default value of 3 (seconds). Use *maxDelayedTime* to trigger windows which remain uncalculated long past its end. *maxDelayedTime* only takes effect when *timeColumn* is specified and the two arguments must have the same time precision. For more information about this parameter, see \"Window triggering rules\" in the Details section.\n\n**nullFill** (optional) is a tuple of the same size as the number of output columns. It is used to fill in the NULL values in the output table. The data type of each element corresponds to each output column.\n\nWhen multiple records are ingested into the engine at the same time, the engine divides the data into batches for calculation. The number of records in each batch is determined by the system internally.\n\n**outputElapsedMicroseconds** (optional) is a Boolean value, indicating whether to output the elapsed time to calculate each batch and the number of records in each batch in the output table. The default value is false. When *outputElapsedMicroseconds* = true, two additional columns are required when specifying outputTables (see the Arguments section).\n\n**sortByTime** (optional) is a Boolean value that indicates whether the output data is globally sorted by time. The default value is false, meaning the output data is sorted only within groups. Note that if *sortByTime* is set to true, the parameter *maxDelayedTime* cannot be specified, and the data input to the left and right tables must be globally sorted.\n\n**closed**(optional) is a string that indicates whether the left or the right boundary is included. It only takes effect when *window*=0:0.\n\n* *closed*= 'left': left-closed, right-open.\n\n* *closed*= 'right': left-open, right-closed. The parameter *useSystemTime*must be set to false.\n\n#### Examples\n\n```\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\nshare table(100:0, `time`sym`factor1`factor2`factor3, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\n\nnullFill= [2012.01.01T00:00:00.000, `NONE, 0.0, 0.0, 0.0]\nwjEngine=createWindowJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output, window=-2:2, metrics=<[price,val,sum(val)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false,nullFill=nullFill)\n\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{wjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{wjEngine, false}, msgAsTable=true)\n\nn=10\ntp1=table(take(2012.01.01T00:00:00.000+0..10, 2*n) as time, take(`AAPL, n) join take(`IBM, n) as sym, take(NULL join rand(10.0, n-1),2*n) as price)\ntp1.sortBy!(`time)\nleftTable.append!(tp1)\n\ntp2=table(take(2012.01.01T00:00:00.000+0..10, 2*n) as time, take(`AAPL, n) join take(`IBM, n) as sym, take(double(1..n),2*n) as val)\ntp2.sortBy!(`time)\nrightTable.append!(tp2)\n\nselect * from output where time between 2012.01.01T00:00:00.000:2012.01.01T00:00:00.001\n```\n\n| time                    | sym  | factor1 | factor2 | factor3 |\n| ----------------------- | ---- | ------- | ------- | ------- |\n| 2012.01.01T00:00:00.000 | AAPL | 0       | 1       | 6       |\n| 2012.01.01T00:00:00.000 | AAPL | 0       | 2       | 6       |\n| 2012.01.01T00:00:00.000 | AAPL | 0       | 3       | 6       |\n| 2012.01.01T00:00:00.001 | AAPL | 5.2705  | 1       | 10      |\n| 2012.01.01T00:00:00.001 | AAPL | 5.2705  | 2       | 10      |\n| 2012.01.01T00:00:00.001 | AAPL | 5.2705  | 3       | 10      |\n| 2012.01.01T00:00:00.001 | AAPL | 5.2705  | 4       | 10      |\n| 2012.01.01T00:00:00.000 | IBM  | 5.2705  | 2       | 9       |\n| 2012.01.01T00:00:00.000 | IBM  | 5.2705  | 3       | 9       |\n| 2012.01.01T00:00:00.000 | IBM  | 5.2705  | 4       | 9       |\n| 2012.01.01T00:00:00.001 | IBM  | 1.0179  | 2       | 14      |\n| 2012.01.01T00:00:00.001 | IBM  | 1.0179  | 3       | 14      |\n| 2012.01.01T00:00:00.001 | IBM  | 1.0179  | 4       | 14      |\n| 2012.01.01T00:00:00.001 | IBM  | 1.0179  | 5       | 14      |\n\nExample for *window* = 0:0:\n\n```\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\n\nv = [1, 5, 10, 15]\ntp1=table(2012.01.01T00:00:00.000+v as time, take(`AAPL, 4) as sym, rand(10.0,4) as price)\n\nv = [1, 2, 3, 4, 5, 6, 9, 15]\ntp2=table(2012.01.01T00:00:00.000+v as time, take(`AAPL, 8) as sym, rand(10.0,8) as val)\n\nshare table(100:0, `time`sym`price`val`sum_val, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE[], DOUBLE]) as output\nwjEngine=createWindowJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output,  window=0:0, metrics=<[price, val, sum(val)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false)\n\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{wjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{wjEngine, false}, msgAsTable=true)\n\nleftTable.append!(tp1)\nrightTable.append!(tp2)\n```\n\n| time                    | sym  | price  | val                             | sum\\_val |\n| ----------------------- | ---- | ------ | ------------------------------- | -------- |\n| 2012.01.01T00:00:00.001 | AAPL | 8.8252 | \\[]                             |          |\n| 2012.01.01T00:00:00.005 | AAPL | 7.1195 | \\[7.495792,9.417891,1.419681,…] | 21.3741  |\n| 2012.01.01T00:00:00.010 | AAPL | 5.2217 | \\[4.840462,8.086567,3.495306]   | 16.4223  |\n| 2012.01.01T00:00:00.015 | AAPL | 9.2517 | \\[]                             |          |\n\n```\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\n\nv = [1, 5, 10, 15]\ntp1=table(2012.01.01T00:00:00.000+v as time, take(`A, 4) as sym, rand(10.0,4) as price)\n\nv = [1, 2, 3, 4, 5, 6, 9, 15]\ntp2=table(2012.01.01T00:00:00.000+v as time, take(`A, 8) as sym, rand(10.0,8) as val)\n\nshare table(100:0, `time`sym`price`sum_val, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE]) as output\nwjEngine=createWindowJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output,  window=0:0, metrics=<[price, sum(val)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false)\n\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{wjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{wjEngine, false}, msgAsTable=true)\n\nleftTable.append!(tp1)\nrightTable.append!(tp2)\n```\n\n<table id=\"table_eky_352_hzb\"><tbody><tr><td align=\"left\">\n\ntime\n\n</td><td align=\"left\">\n\nsym\n\n</td><td align=\"left\">\n\nprice\n\n</td><td align=\"left\">\n\nsum\\_val\n\n</td></tr><tr><td align=\"left\">\n\n2012.01.01T00:00:00.001\n\n</td><td align=\"left\">\n\nA\n\n</td><td align=\"left\">\n\n8.8252\n\n</td><td align=\"left\">\n\n \n\n</td></tr><tr><td align=\"left\">\n\n2012.01.01T00:00:00.005\n\n</td><td align=\"left\">\n\nA\n\n</td><td align=\"left\">\n\n7.1195\n\n</td><td align=\"left\">\n\n21.3741\n\n</td></tr><tr><td align=\"left\">\n\n2012.01.01T00:00:00.010\n\n</td><td align=\"left\">\n\nA\n\n</td><td align=\"left\">\n\n5.2217\n\n</td><td align=\"left\">\n\n16.4223\n\n</td></tr><tr><td align=\"left\">\n\n2012.01.01T00:00:00.015\n\n</td><td align=\"left\">\n\nA\n\n</td><td align=\"left\">\n\n9.2517\n\n</td><td align=\"left\">\n\n \n\n</td></tr></tbody>\n</table>When *window*=0:0, the window is left-closed and right-open by default. The following example uses a left-open and right-closed window by setting *closed*to 'right'.\n\n```\nunsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\")\nunsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\")\nundef(`leftTable,SHARED)\nundef(`rightTable,SHARED)\ndropAggregator(name=\"test1\")\n\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\n\nv1 = [1, 5, 10, 15]\ntp1=table(2012.01.01T00:00:00.000+v1 as time, take(`A, 4) as sym, rand(10.0,4) as price)\n\nv2 = [1, 2, 3, 4, 5, 6, 9, 15]\ntp2=table(2012.01.01T00:00:00.000+v2 as time, take(`A, 8) as sym, rand(10.0,8) as val)\n\nshare table(100:0, `time`sym`price`val`sum_val, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE[], DOUBLE]) as output\nwjEngine=createWindowJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output,  window=0:0, metrics=<[price, val, sum(val)]>, matchingColumn=\"sym\", timeColumn=\"time\", useSystemTime=false, closed=\"right\")\n\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{wjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{wjEngine, false}, msgAsTable=true)\n\nleftTable.append!(tp1)\nrightTable.append!(tp2)\nsleep(100)\nselect * from output\n// output\ntime\t                  sym\tprice\tval\t                      sum_val\n2012.01.01T00:00:00.001\tA\t9.7366\t[7.8310]\t                  7.831\n2012.01.01T00:00:00.005\tA\t2.6537\t[1.8564,4.6238,8.2536,3.1028]     17.8368\n2012.01.01T00:00:00.010\tA\t3.9586\t[0.8413,8.0684]\t           8.9098\n```\n\nThe following example shows that when *sortByTime* =true, the engine outputs data sorted by time.\n\n```\nunsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\")\nunsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\")\nundef(`leftTable,SHARED)\nundef(`rightTable,SHARED)\ndropAggregator(name=\"test1\")\n\n//define a window join engine\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\nshare table(100:0, `time`sym`factor1`factor2`factor3, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\nnullFill= [2012.01.01T00:00:00.000, `NONE, 0.0, 0.0, 0.0]\nwjEngine=createWindowJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output,  window=-2:2, metrics=<[price,val,sum(val)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false,nullFill=nullFill, sortByTime=true)\n\n//subscribe data\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{wjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{wjEngine, false}, msgAsTable=true)\n\nn=10\ntp1=table(take(2012.01.01T00:00:00.000+0..10, 2*n) as time, take(`A, n) join take(`B, n) as sym, take(NULL join rand(10.0, n-1),2*n) as price)\ntp1.sortBy!(`time)\nleftTable.append!(tp1)\n\ntp2=table(take(2012.01.01T00:00:00.000+0..10, 2*n) as time, take(`A, n) join take(`B, n) as sym, take(double(1..n),2*n) as val)\ntp2.sortBy!(`time)\nrightTable.append!(tp2)\n\nsleep(100)\nselect * from output where time between 2012.01.01T00:00:00.000:2012.01.01T00:00:00.001\n\n\n// output\ntime                    sym   factor1        factor2 factor3\n2012.01.01T00:00:00.000      A       0        1        6\n2012.01.01T00:00:00.000      A       0        2        6\n2012.01.01T00:00:00.000      A       0        3        6\n2012.01.01T00:00:00.000      B     3.9389     2        9\n2012.01.01T00:00:00.000      B     3.9389     3        9\n2012.01.01T00:00:00.000      B     3.9389     4        9\n2012.01.01T00:00:00.001      A     3.9389     1        10\n2012.01.01T00:00:00.001      A     3.9389     2        10\n2012.01.01T00:00:00.001      A     3.9389     3        10\n2012.01.01T00:00:00.001      A     3.9389     4        10\n2012.01.01T00:00:00.001      B     4.9875     2        14\n2012.01.01T00:00:00.001      B     4.9875     3        14\n2012.01.01T00:00:00.001      B     4.9875     4        14\n2012.01.01T00:00:00.001      B     4.9875     5        14\n```\n"
    },
    "crossStat": {
        "url": "https://docs.dolphindb.com/en/Functions/c/crossStat.html",
        "signatures": [
            {
                "full": "crossStat(X, Y)",
                "name": "crossStat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [crossStat](https://docs.dolphindb.com/en/Functions/c/crossStat.html)\n\n\n\n#### Syntax\n\ncrossStat(X, Y)\n\n#### Arguments\n\n**X** and **Y** are numeric vectors of the same size.\n\n#### Details\n\nReturn a tuple with the following elements: count(X), sum(X), sum(Y), sum2(X), sum2(Y), sum(X\\*Y)\n\n#### Examples\n\n```\nx=1 NULL 2 3\ny=4 3 NULL 2\ncrossStat(x,y);\n// output\n(2,4,6,10,20,10)\n```\n"
    },
    "cubicSpline": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cubicspline.html",
        "signatures": [
            {
                "full": "cubicSpline(x, y, bc_type=\"not-a-knot\")",
                "name": "cubicSpline",
                "parameters": [
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "y",
                        "name": "y"
                    },
                    {
                        "full": "bc_type=\"not-a-knot\"",
                        "name": "bc_type=\"not-a-knot\""
                    }
                ]
            }
        ],
        "markdown": "### [cubicSpline](https://docs.dolphindb.com/en/Functions/c/cubicspline.html)\n\n\n\n#### Syntax\n\ncubicSpline(x, y, bc\\_type=\"not-a-knot\")\n\n#### Arguments\n\n**x** is a numeric vector containing values of the independent variable. The length of *x*must be no smaller than 3. Its values must be real and in strictly increasing order.\n\n**y** is a numeric vector containing values of the dependent variable. The length of *y* must match the length of *x*.\n\n**bc\\_type** is of STRING type, which can be a scalar, pair, or a vector of length no greater than 2. It specifies the boundary condition type.\n\n* If *bc\\_type*is a string or a vector of length 1, the specified condition will be applied at both ends of a spline.\n\n* If *bc\\_type*is a pair or a vector of length 2, the first and the second value will be applied at the curve start and end respectively.\n\nIts value can be:\n\n* \"not-a-knot\" (default): The first and second segment at a curve end are the same polynomial.\n\n* \"clamped\": The first derivative at curves ends are zero.\n\n* \"natural\": The second derivative at curve ends are zero.\n\n#### Details\n\nCubic spline data interpolator.\n\n**Return value**: A dictionary withthe following keys:\n\n* c: Coefficients of the polynomials on each segment.\n* x: Breakpoints. The input *x*.\n* predict: A prediction function of the model, which returns the cubic spline interpolation result at point X. It can be called using `model.predict(X)` or `predict(model, X)`, where\n  * model: A dictionary indicating the output of `cubicSpline`.\n  * X: A numeric vector indicating the X-coordinate of the point to be queried.\n* modelName: A string indicating the model name, which is “`cubicSpline`”.\n\n#### Examples\n\n```\nn = 10\nx = 0..(n-1)\ny = sin(x)\nmodel = cubicSpline(x, y, bc_type=\"not-a-knot\")\nmodel\n\n// output\nx->[0,1,2,3,4,5,6,7,8,9]\npredict->cubicSplinePredict\nmodelName->cubicSpline\nc->[-0.0418500756165063,-0.2612720445455365,1.1445931049699394,0.0,-0.0418500756165067,-0.3868222713950554,0.4964987890293473,0.8414709848078965,0.1468910600890447,-0.5123724982445756,...]\n```\n\nRelated Function: [cubicSplinePredict](https://docs.dolphindb.com/en/Functions/c/cubicsplinepredict.html)\n"
    },
    "cubicSplinePredict": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cubicsplinepredict.html",
        "signatures": [
            {
                "full": "cubicSplinePredict(model, x)",
                "name": "cubicSplinePredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "x",
                        "name": "x"
                    }
                ]
            }
        ],
        "markdown": "### [cubicSplinePredict](https://docs.dolphindb.com/en/Functions/c/cubicsplinepredict.html)\n\n\n\n#### Syntax\n\ncubicSplinePredict(model, x)\n\n#### Arguments\n\n**model** is a dictionary with two keys, c and x. The value of c is the coefficients of the polynomials on each segment, and the value of x is the polynomial breakpoints. The length of c is equal to `(the length of x -1)*4`. Neither c nor x can contain NULL values. The model can be obtained with function `cubicSpline`.\n\n**x** is a numeric scalar or vector containing the independent variable to be predicted.\n\n#### Details\n\nPredict the corresponding y for x with the given model.\n\n#### Examples\n\n```\nn = 10\nx = 0..(n-1)\ny = sin(x)\nmodel = cubicSpline(x, y, bc_type=\"not-a-knot\")\n\nnewx = [-0.5, 0.5, 0.7, 1.2, 4.5, 8.9, 9.3]\nret = cubicSplinePredict(model, newx)\n\n// output\n[-0.632383304169291,0.501747281896522,0.658837295715183,0.924963051153032,-0.974025627606784,0.515113155358425,0.03881591118089]\n```\n\nRelated Function: [cubicSpline](https://docs.dolphindb.com/en/Functions/c/cubicspline.html)\n"
    },
    "cumavg": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumavg.html",
        "signatures": [
            {
                "full": "cumavg(X)",
                "name": "cumavg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumavg](https://docs.dolphindb.com/en/Functions/c/cumavg.html)\n\n\n\n#### Syntax\n\ncumavg(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCalculate the cumulative average of *X*.\n\n#### Examples\n\n```\nx=[2,3,NULL,4];\ncumavg(x);\n// output\n[2,2.5,2.5,3]\n\nm=matrix(1 2 3 NULL 4, 5 6 NULL 7 8);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 2  | 6  |\n| 3  |    |\n|    | 7  |\n| 4  | 8  |\n\n```\ncumavg(m);\n```\n\n| #0  | #1  |\n| --- | --- |\n| 1   | 5   |\n| 1.5 | 5.5 |\n| 2   | 5.5 |\n| 2   | 6   |\n| 2.5 | 6.5 |\n\nRelated functions: [cummax](https://docs.dolphindb.com/en/Functions/c/cummax.html), [cummin](https://docs.dolphindb.com/en/Functions/c/cummin.html), [cumprod](https://docs.dolphindb.com/en/Functions/c/cumprod.html), [cumPositiveStreak](https://docs.dolphindb.com/en/Functions/c/cumPositiveStreak.html), [cumsum](https://docs.dolphindb.com/en/Functions/c/cumsum.html)\n"
    },
    "cumavgTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumavgTopN.html",
        "signatures": [
            {
                "full": "cumavgTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumavgTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumavgTopN](https://docs.dolphindb.com/en/Functions/c/cumavgTopN.html)\n\n\n\n#### Syntax\n\ncumavgTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the average of the first *top* elements in a cumulative window.\n\n**Return value**: DOUBLE type.\n\n#### Examples\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumavgTopN(X, S, 6, 4)\n// output\n[1,1.5,2,4,23.199,20,20.167]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumavgTopN(X, S, 6, 4)\n```\n\n| #0   | #1      |\n| ---- | ------- |\n| 1    |         |\n| 1.5  | 12      |\n| 2    | 12.5    |\n| 2    | 13      |\n| 2.75 | 13      |\n| 3.4  | 13.75   |\n| 4    | 14.4    |\n| 5    | 15      |\n| 5    | 15.8333 |\n| 5    | 16      |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumavgTopN(price, id, 6, 4) as result from t\n```\n\n| result  |\n| ------- |\n| 94      |\n| 69.5    |\n| 46.3333 |\n| 55.75   |\n| 57.8    |\n| 49.6667 |\n| 50.5    |\n| 50.5    |\n| 51.5    |\n| 51.5    |\n"
    },
    "cumbeta": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumbeta.html",
        "signatures": [
            {
                "full": "cumbeta(Y, X)",
                "name": "cumbeta",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumbeta](https://docs.dolphindb.com/en/Functions/c/cumbeta.html)\n\n\n\n#### Syntax\n\ncumbeta(Y, X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the coefficient estimate of the regression of *Y* on *X*. The result is a vector of the same length as *X*.\n\n#### Examples\n\n```\nx=1 3 5 7 11 16 23\ny=1 6 9 8 15 23 34;\n\ncumbeta(y,x);\n// output\n[,2.5,2,1.2,1.256757,1.365322,1.440948]\n```\n"
    },
    "cumbetaTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumbetaTopN.html",
        "signatures": [
            {
                "full": "cumbetaTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumbetaTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumbetaTopN](https://docs.dolphindb.com/en/Functions/c/cumbetaTopN.html)\n\n\n\n#### Syntax\n\ncumbetaTopN(X, Y, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the coefficient estimate ordinary-least-squares regressions of *Y* on *X* in a cumulative window.\n\n**Return value**: DOUBLE type\n\n#### Examples\n\n```\nX=1 2 3 10 100 4 3\nY=1 7 8 9 0 5 8\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumbetaTopN(X, Y, S, 6, 4)\n// output\n[,0.1666,0.2441,0.7483,-6.4428,-6.4428,-6.2293]\n```\n"
    },
    "cumcorr": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumcorr.html",
        "signatures": [
            {
                "full": "cumcorr(X,Y)",
                "name": "cumcorr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cumcorr](https://docs.dolphindb.com/en/Functions/c/cumcorr.html)\n\n\n\n#### Syntax\n\ncumcorr(X,Y)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the correlation of *X* and *Y*. The result is a vector of the same length as *X*.\n\n#### Examples\n\n```\nx = 7 4 5 8 9\ny = 1 7 8 9 0\ncumcorr(x, y);\n// output\n[,-1,-0.893405,-0.1524,-0.518751]\n```\n"
    },
    "cumcorrTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumcorrTopN.html",
        "signatures": [
            {
                "full": "cumcorrTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumcorrTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumcorrTopN](https://docs.dolphindb.com/en/Functions/c/cumcorrTopN.html)\n\n\n\n#### Syntax\n\ncumcorrTopN(X, Y, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the correlation of the first *top* pairs of elements in *X* and *Y* in a cumulative window.\n\n**Return value**: DOUBLE type\n\n#### Examples\n\n```\nX=1 2 3 10 13 4 3\nY = 1 7 8 9 0 5 8\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumcorrTopN(X, Y, S, 6, 3)\n// output\n[,1,0.9244,0.6588,-0.1784,-0.1764,-0.1825]\n```\n"
    },
    "cumcount": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumcount.html",
        "signatures": [
            {
                "full": "cumcount(X)",
                "name": "cumcount",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumcount](https://docs.dolphindb.com/en/Functions/c/cumcount.html)\n\n\n\n#### Syntax\n\ncumcount(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the number of non-NULL elements in *X*.\n\n#### Examples\n\n```\nx=[1,2,NULL,3,4,NULL,5,6]\ncumcount(x);\n// output\n[1,2,2,3,4,4,5,6]\n\nm=matrix(1 2 3 NULL 4, 5 6 NULL NULL 8);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 2  | 6  |\n| 3  |    |\n|    |    |\n| 4  | 8  |\n\n```\ncumcount(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 2  | 2  |\n| 3  | 2  |\n| 3  | 2  |\n| 4  | 3  |\n"
    },
    "cumcovar": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumcovar.html",
        "signatures": [
            {
                "full": "cumcovar(X,Y)",
                "name": "cumcovar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cumcovar](https://docs.dolphindb.com/en/Functions/c/cumcovar.html)\n\n\n\n#### Syntax\n\ncumcovar(X,Y)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the covariance of *X* and *Y*. The result is a vector of the same length as *X*.\n\n#### Examples\n\n```\nx = 7 4 5 8 9\ny = 1 7 8 9 0\ncumcovar(x, y);\n// output\n[,-9,-5.166667,-1,-4.5]\n```\n"
    },
    "cumcovarTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumcovarTopN.html",
        "signatures": [
            {
                "full": "cumcovarTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumcovarTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumcovarTopN](https://docs.dolphindb.com/en/Functions/c/cumcovarTopN.html)\n\n\n\n#### Syntax\n\ncumcovarTopN(X, Y, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the covariance of the first *top* pairs of elements in *X* and *Y* in a cumulative window.\n\n**Return value**: DOUBLE type\n\n#### Examples\n\n```\nX=1 2 3 10 13 4 3\nY = 1 7 8 9 0 5 8\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumcovarTopN(X, Y, S, 6, 3)\n// output\n[,3,3.5,9.6666,-4,-3.2,-3.3333]\n```\n"
    },
    "cumdenserank": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumdenseRank.html",
        "signatures": [
            {
                "full": "cumdenseRank(X, [ascending=true], [ignoreNA=true], [percent=false], [norm='max'])",
                "name": "cumdenseRank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[norm='max']",
                        "name": "norm",
                        "optional": true,
                        "default": "'max'"
                    }
                ]
            }
        ],
        "markdown": "### [cumdenserank](https://docs.dolphindb.com/en/Functions/c/cumdenseRank.html)\n\n\n\n#### Syntax\n\ncumdenseRank(X, \\[ascending=true], \\[ignoreNA=true], \\[percent=false], \\[norm='max'])\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Arguments\n\n**X** is a vector/matrix/in-memory table.\n\n**ascending** (optional) is a Boolean value indicating whether to sort data in ascending order. The default value is true.\n\n**ignoreNA** (optional) is a Boolean value indicating whether NULL values are ignored in ranking. True means ignoring NULL values, and false (default) means the NULL values participate in the calculation and are ranked the lowest.\n\n**percent** (optional) is a Boolean value, indicating whether to display the returned rankings in percentile form. The default value is false.\n\n**norm** (optional) is a string that can be either 'max' or 'minmax'. This parameter determines whether the ranking starts at 0 or 1, which impacts the percentile calculation. If *norm* = 'max', the ranking numbers start at 1; if *norm* = 'minmax', they start at 0. For example, when cumulative dense ranking \\[3,1,2] with result returned in percentiles:\n\n* if *norm* = 'max', the rank of \"2\" is 2 out of a max rank of 3 in the last cumulative window, so the percentile is 2\\3.\n\n* if *norm* = 'minmax', the rank of \"2\" is 1 out of a max rank of 2, so the result will be 1\\2.\n\nNote: To use *norm*, *percent* must be true.\n\n#### Details\n\nIf *X* is a vector, for each element in *X*, return the position ranking from the first element to the current element. Rank values are consecutive integers and not skipped in the event of ties. The result is of the same length as *X*.\n\n* The sorting order is specified by *ascending*.\n\n* If *ignoreNA* = true, NULL values return NULL.\n\nIf *X* is a matrix or in-memory table, conduct the aforementioned calculation within each column of *X*. The result is a matrix or in-memory table with the same shape as *X*.\n\n#### Examples\n\n```\na = 1 3 2 3 4\ncumdenseRank(X=a, ascending=true, ignoreNA=true, percent=false)\n// output\n[0,1,1,2,3]\n\ncumdenseRank(X=a, ascending=true, ignoreNA=true, percent=true, norm=\"max\")\n//output\n[1,1,0.6667,1,1]\n\ncumdenseRank(X=a, ascending=true, ignoreNA=true, percent=true, norm=\"minmax\")\n// output\n[1,1,0.5,1,1]\n\nm = matrix(1 6 2 NULL, 3 0 1 6, 7 3 NULL 2)\ncumdenseRank(X=m, ascending=true, ignoreNA=true, percent=false)\n// output\n#0 #1 #2\n-- -- --\n0  0  0 \n1  0  0 \n1  1    \n   3  0\n   \nt = table([4,10,3,4,8,1] as val1, [10,8,1,8,5,2]  as val2)\ncumdenseRank(X=t, ascending=true, ignoreNA=true, percent=false)\n// output\n\tval1    val2\n0\t0\t0\n1\t1\t0\n2\t0\t0\n3\t1\t1\n4\t2\t1\n5\t0\t1\n```\n\nRelated function: [cumrank](https://docs.dolphindb.com/en/Functions/c/cumrank.html)\n"
    },
    "cumfirstNot": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumfirstNot.html",
        "signatures": [
            {
                "full": "cumfirstNot(X, [k])",
                "name": "cumfirstNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k]",
                        "name": "k",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [cumfirstNot](https://docs.dolphindb.com/en/Functions/c/cumfirstNot.html)\n\n\n\n#### Syntax\n\ncumfirstNot(X, \\[k])\n\n#### Arguments\n\n**k** is a scalar.\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nIf *X* is a vector:\n\n* If *k* is unspecified, return the first non-NULL element in *X*;\n* If *k* is specified, return the first element that is not *k*.\n\nIf *X* is a matrix, conduct the aforementioned calculation within each column of *X*. The result is a matrix with the same shape as *X*.\n\n#### Examples\n\n```\nx=[NULL,1,2,6,NULL,3,4,NULL]\ncumfirstNot(x);\n// output\n[,1,1,1,1,1,1,1]\n\ncumfirstNot(x, 1)\n// output\n[,,2,2,2,2,2,2]\n\nm=matrix(1 2 3 NULL 4, NULL NULL 8 8 9);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 2  |    |\n| 3  | 8  |\n|    | 8  |\n| 4  | 9  |\n\n```\ncumfirstNot(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 1  |    |\n| 1  | 8  |\n| 1  | 8  |\n| 1  | 8  |\n\nRelated function: [firstNot](https://docs.dolphindb.com/en/Functions/f/firstNot.html)\n"
    },
    "cumkurtosisTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumkurtosisTopN.html",
        "signatures": [
            {
                "full": "cumkurtosisTopN(X, S, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "cumkurtosisTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumkurtosisTopN](https://docs.dolphindb.com/en/Functions/c/cumkurtosisTopN.html)\n\n\n\n#### Syntax\n\ncumkurtosisTopN(X, S, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\n#### Arguments\n\n**biased** (optional) is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the moving kurtosis of the first *top* elements in a cumulative window.\n\n**Return value**: DOUBLE type.\n\n#### Examples\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumkurtosisTopN(X, S, 6, 4)\n// output\n[,,1.5,2.2304,3.2152,4.1525,4.1554]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumkurtosisTopN(X, S, 6, 4)\n```\n\n| #0     | #1     |\n| ------ | ------ |\n|        |        |\n|        |        |\n| 1.5    |        |\n| 1.5    | 1.5    |\n| 1.8457 | 1.5    |\n| 1.5092 | 1.8457 |\n| 1.5    | 1.5092 |\n| 1.9204 | 1.5    |\n| 1.9204 | 1.6107 |\n| 1.9204 | 1.7297 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumkurtosisTopN(price, id, 6, 4) as result from t\n```\n\n| result |\n| ------ |\n|        |\n|        |\n| 1.5    |\n| 1.4036 |\n| 1.537  |\n| 1.8185 |\n| 1.8838 |\n| 2.0968 |\n| 2.6695 |\n| 2.6695 |\n"
    },
    "cumlastNot": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumlastNot.html",
        "signatures": [
            {
                "full": "cumlastNot(X, [k])",
                "name": "cumlastNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k]",
                        "name": "k",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [cumlastNot](https://docs.dolphindb.com/en/Functions/c/cumlastNot.html)\n\n\n\n#### Syntax\n\ncumlastNot(X, \\[k])\n\n#### Arguments\n\n**k** is a scalar.\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nIf *X* is a vector:\n\n* If *k* is unspecified, return the last non-NULL element in *X*;\n* If *k* is specified, return the last element that is not *k*.\n\nIf *X* is a matrix, conduct the aforementioned calculation within each column of *X*. The result is a matrix with the same shape as *X*.\n\n#### Examples\n\n```\nx=[NULL,1,2,6,NULL,3,4,NULL]\ncumlastNot(x);\n// output\n[,1,2,6,6,3,4,4]\n\ncumlastNot(x, 4)\n// output\n[,1,2,6,6,3,3,3]\n\nm=matrix(1 2 3 NULL 4, NULL NULL 8 8 9);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 2  |    |\n| 3  | 8  |\n|    | 8  |\n| 4  | 9  |\n\n```\ncumlastNot(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 2  |    |\n| 3  | 8  |\n| 3  | 8  |\n| 4  | 9  |\n\nRelated function: [lastNot](https://docs.dolphindb.com/en/Functions/l/lastNot.html)\n"
    },
    "cummax": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cummax.html",
        "signatures": [
            {
                "full": "cummax(X)",
                "name": "cummax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cummax](https://docs.dolphindb.com/en/Functions/c/cummax.html)\n\n\n\n#### Syntax\n\ncummax(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the maximum values in *X*. It can be used to calculate maximum drawdown, for example.\n\n#### Examples\n\n```\nx = [7,4,5,8,9]\ncummax(x);\n// output\n[7,7,7,8,9]\n\nm = matrix(6 5 7 8 1, 3 9 4 2 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 5  | 9  |\n| 7  | 4  |\n| 8  | 2  |\n| 1  | 10 |\n\n```\ncummax(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 6  | 9  |\n| 7  | 9  |\n| 8  | 9  |\n| 8  | 10 |\n\nRelated functions: [cummin](https://docs.dolphindb.com/en/Functions/c/cummin.html), [cumsum](https://docs.dolphindb.com/en/Functions/c/cumsum.html), [cumprod](https://docs.dolphindb.com/en/Functions/c/cumprod.html)\n"
    },
    "cummed": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cummed.html",
        "signatures": [
            {
                "full": "cummed(X)",
                "name": "cummed",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cummed](https://docs.dolphindb.com/en/Functions/c/cummed.html)\n\n\n\n#### Syntax\n\ncummed(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCalculate the cumulative median of *X*.\n\n#### Examples\n\n```\nx = [7,9,5,NULL,9]\ncummed(x);\n// output\n[7,8,7,7,8]\n\nm = matrix(6 5 7 8 1, 3 9 4 2 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 5  | 9  |\n| 7  | 4  |\n| 8  | 2  |\n| 1  | 10 |\n\n```\ncummed(m);\n```\n\n| #0  | #1  |\n| --- | --- |\n| 6   | 3   |\n| 5.5 | 6   |\n| 6   | 4   |\n| 6.5 | 3.5 |\n| 6   | 4   |\n\nRelated functions: [cummax](https://docs.dolphindb.com/en/Functions/c/cummax.html), [cummin](https://docs.dolphindb.com/en/Functions/c/cummin.html), [med](https://docs.dolphindb.com/en/Functions/m/med.html)\n"
    },
    "cummin": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cummin.html",
        "signatures": [
            {
                "full": "cummin(X)",
                "name": "cummin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cummin](https://docs.dolphindb.com/en/Functions/c/cummin.html)\n\n\n\n#### Syntax\n\ncummin(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the minimum values in *X*.\n\n#### Examples\n\n```\nx = [7,4,5,NULL,9]\ncummin(x);\n// output\n[7,4,4,4,4]\n\nm = matrix(6 5 7 8 1, 3 9 4 2 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 5  | 9  |\n| 7  | 4  |\n| 8  | 2  |\n| 1  | 10 |\n\n```\ncummin(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 5  | 3  |\n| 5  | 3  |\n| 5  | 2  |\n| 1  | 2  |\n\nRelated functions:[cummax](https://docs.dolphindb.com/en/Functions/c/cummax.html), [min](https://docs.dolphindb.com/en/Functions/m/min.html)\n"
    },
    "cumnunique": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumnunique.html",
        "signatures": [
            {
                "full": "cumnunique(X, [ignoreNull=false])",
                "name": "cumnunique",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ignoreNull=false]",
                        "name": "ignoreNull",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [cumnunique](https://docs.dolphindb.com/en/Functions/c/cumnunique.html)\n\n#### Syntax\n\ncumnunique(X, \\[ignoreNull=false])\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Arguments\n\n**ignoreNull** (optional) is a Boolean value. If set to true, only non-NULL elements will be included in the calculation. The default value is false.\n\n#### Details\n\nReturn the cumulative count of unique elements in *X*.\n\n**Note:** NULL values are included in the calculation.\n\n#### Examples\n\n```\nv = [NULL, 1, 2, -6, 0, 1, 2]\ncumnunique(v)\n// output: [1,2,3,4,5,5,5]\n\nt = table(`a`a`b`c`a`b as id, 20 20 10 40 30 20 as val)\nselect cumnunique(id) as cumVal from t\n```\n\n| cumVal |\n| ------ |\n| 1      |\n| 1      |\n| 2      |\n| 3      |\n| 3      |\n| 3      |\n\n"
    },
    "cumpercentile": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumpercentile.html",
        "signatures": [
            {
                "full": "cumpercentile(X, percent, [interpolation='linear'])",
                "name": "cumpercentile",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "percent",
                        "name": "percent"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    }
                ]
            }
        ],
        "markdown": "### [cumpercentile](https://docs.dolphindb.com/en/Functions/c/cumpercentile.html)\n\n\n\n#### Syntax\n\ncumpercentile(X, percent, \\[interpolation='linear'])\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Arguments\n\n**X** is a vector or matrix.\n\n**percent** is an integer or a floating point number between 0 and 100.\n\n**interpolation** (optional) is a string indicating the interpolation method to use if the specified percentile is between two elements in *X* (assuming the i-th and (i+1)-th element in the sorted *X*) . It can take the following values:\n\n* 'linear': Return X(i)+(X(t+1)-X(t))\\*fraction, where fraction = ((percentile100)-(i(size-1)))(1(size-1))\n\n* 'lower': Return X(i)\n\n* 'higher': Return X(i+1)\n\n* 'nearest': Return X(i) or X(i+1) that is closest to the specified percentile\n\n* 'midpoint': Return (X(i)+X(i+1))2\n\nThe default value of interpolation is 'linear'.\n\n#### Details\n\n* If *X* is a vector, cumulatively calculate the given percentile of a vector. The calculation ignores NULL values.\n* If *X* is a matrix, conduct the aforementioned calculation within each column of *X*. The result is a matrix with the same shape as *X*.\n\n#### Examples\n\n```\na=1..10;\n\ncumpercentile(a,25);\n// output\n[1,1.25,1.5,1.75,2,2.25,2.5,2.75,3,3.25]\n\ncumpercentile(a,25,'lower');\n// output\n[1,1,1,1,2,2,2,2,3,3]\n\ncumpercentile(a,25,'higher');\n// output\n[1,2,2,2,2,3,3,3,3,4]\n\ncumpercentile(a,25,'midpoint');\n// output\n[1,1.5,1.5,1.5,2,2.5,2.5,2.5,3,3.5]\n\ncumpercentile(a,25,'nearest');\n// output\n[1,1,1,2,2,2,2,3,3,3]\n\ncumpercentile(a,50.5);\n// output\n[1,1.505,2.01,2.515,3.02,3.525,4.03,4.535,5.04,5.545]\n\nm=matrix(1..10, 11..20);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n| 6  | 16 |\n| 7  | 17 |\n| 8  | 18 |\n| 9  | 19 |\n| 10 | 20 |\n\n```\ncumpercentile(m,25);\n```\n\n| #0   | #1    |\n| ---- | ----- |\n| 1    | 11    |\n| 1.25 | 11.25 |\n| 1.5  | 11.5  |\n| 1.75 | 11.75 |\n| 2    | 12    |\n| 2.25 | 12.25 |\n| 2.5  | 12.5  |\n| 2.75 | 12.75 |\n| 3    | 13    |\n| 3.25 | 13.25 |\n\nRelated functions: [percentile](https://docs.dolphindb.com/en/Functions/p/percentile.html)\n"
    },
    "cumPositiveStreak": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumPositiveStreak.html",
        "signatures": [
            {
                "full": "cumPositiveStreak(X)",
                "name": "cumPositiveStreak",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumPositiveStreak](https://docs.dolphindb.com/en/Functions/c/cumPositiveStreak.html)\n\n\n\n#### Syntax\n\ncumPositiveStreak(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the sum of consecutive positive elements of *X* after the last non-positive element to the left.\n\n#### Examples\n\n```\nx=1 0 -1 1 2 2 2 1 0 -1 0 2;\n\ncumPositiveStreak x;\n// output\n[1,0,0,1,3,5,7,8,0,0,0,2]\n\nm=matrix(1 0 -1 1 2 2 2 1 0 -1 0 2, -1 -2 -1 0 1 3 6 7 0 -1 -2 0);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | -1 |\n| 0  | -2 |\n| -1 | -1 |\n| 1  | 0  |\n| 2  | 1  |\n| 2  | 3  |\n| 2  | 6  |\n| 1  | 7  |\n| 0  | 0  |\n| -1 | -1 |\n| 0  | -2 |\n| 2  | 0  |\n\n```\ncumPositiveStreak(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 0  |\n| 0  | 0  |\n| 0  | 0  |\n| 1  | 0  |\n| 3  | 1  |\n| 5  | 4  |\n| 7  | 10 |\n| 8  | 17 |\n| 0  | 0  |\n| 0  | 0  |\n| 0  | 0  |\n| 2  | 0  |\n\nrelaated functions: [cumsum](https://docs.dolphindb.com/en/Functions/c/cumsum.html), [cummax](https://docs.dolphindb.com/en/Functions/c/cummax.html), [cummin](https://docs.dolphindb.com/en/Functions/c/cummin.html), [cumprod](https://docs.dolphindb.com/en/Functions/c/cumprod.html)\n"
    },
    "cumprod": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumprod.html",
        "signatures": [
            {
                "full": "cumprod(X)",
                "name": "cumprod",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumprod](https://docs.dolphindb.com/en/Functions/c/cumprod.html)\n\n\n\n#### Syntax\n\ncumprod(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the product of the elements in *X*.\n\n#### Examples\n\n```\ncumprod(2 3 4);\n// output\n[2,6,24]  // equivalent to  [2, 2*3, 2*3*4]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ncumprod(m);\n```\n\n| #0 | #1  |\n| -- | --- |\n| 1  | 4   |\n| 2  | 20  |\n| 6  | 120 |\n\nRelated functions: [prod](https://docs.dolphindb.com/en/Functions/p/prod.html)\n"
    },
    "cumrank": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumrank.html",
        "signatures": [
            {
                "full": "cumrank(X, [ascending=true], [ignoreNA=true], [tiesMethod='min'], [percent=false])",
                "name": "cumrank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='min']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'min'"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [cumrank](https://docs.dolphindb.com/en/Functions/c/cumrank.html)\n\n\n\n#### Syntax\n\ncumrank(X, \\[ascending=true], \\[ignoreNA=true], \\[tiesMethod='min'], \\[percent=false])\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Arguments\n\n**X** is a vector/ matrix.\n\n**ascending** (optional) is a Boolean value indicating whether to sort in ascending order. It is an optional parameter and the default value is true.\n\n**ignoreNA** (optional) is a Boolean value indicating whether NULL values are ignored in ranking. True means ignoring the NULL value, and false means the NULL values participate in the calculation. The default value is true. If NULL values participate in the ranking, they are ranked the lowest.\n\n**tiesMethod** (optional) is a string indicating how to rank the group of records with the same value (i.e., ties):\n\n* 'min': lowest rank of the group\n\n* 'max': highest rank of the group\n\n* 'average': average rank of the group\n\n**percent** (optional) is a Boolean value, indicating whether to display the returned rankings in percentile form. The default value is false.\n\n#### Details\n\nIf *X* is a vector, for each element in *X*, return the position ranking from the first element to the current element. The result is of the same length as *X*. If *ignoreNA* = true, NULL values return NULL.\n\nIf *X* is a matrix, conduct the aforementioned calculation within each column of *X*. The result is a matrix with the same shape as *X*.\n\n#### Examples\n\n```\ncumrank(1 3 2 3 4);\n// output\n[0,1,1,2,4]\n\ncumrank(1 3 2 2 4 NULL, , true);\n// output\n[0,1,1,1,4,]\n\ncumrank(1 3 2 2 4 NULL, , false);\n// output\n[0,1,1,1,4,0]\n\ncumrank(1 3 2 2 4 NULL, , false, 'max');\n// output\n[0,1,1,2,4,0]\n\nm=matrix(1 4 2 3 4, 4 NULL 6 1 2);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 4  |    |\n| 2  | 6  |\n| 3  | 1  |\n| 4  | 2  |\n\n```\ncumrank(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 0  | 0  |\n| 1  |    |\n| 1  | 1  |\n| 2  | 0  |\n| 3  | 1  |\n\nRelated function: [rank](https://docs.dolphindb.com/en/Functions/r/rank.html)\n"
    },
    "cumskewTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumskewTopN.html",
        "signatures": [
            {
                "full": "cumskewTopN(X, S, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "cumskewTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumskewTopN](https://docs.dolphindb.com/en/Functions/c/cumskewTopN.html)\n\n\n\n#### Syntax\n\ncumskewTopN(X, S, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\n#### Arguments\n\n**biased** (optional) is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the moving skewness of the first *top* elements in a cumulative window.\n\n**Return value**: DOUBLE type.\n\n#### Examples\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumskewTopN(X, S, 6, 4)\n// output\n[,0,0,1.0182,1.4754,1.7635,1.7650]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumskewTopN(X, S, 6, 4)\n```\n\n| #0      | #1      |\n| ------- | ------- |\n|         |         |\n| 0       |         |\n| 0       | 0       |\n| 0       | 0       |\n| 0.4373  | 0       |\n| 0.158   | 0.4347  |\n| 0       | 0.158   |\n| -0.4448 | 0       |\n| -0.4448 | -0.3599 |\n| -0.4448 | -0.1413 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumskewTopN(price, id, 6, 4) as result from t\n```\n\n| result  |\n| ------- |\n|         |\n| 0       |\n| -0.6435 |\n| -0.7353 |\n| -0.209  |\n| -0.2864 |\n| -0.0042 |\n| 0.0955  |\n| 0.0955  |\n| -0.5659 |\n"
    },
    "cumstd": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumstd.html",
        "signatures": [
            {
                "full": "cumstd(X)",
                "name": "cumstd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumstd](https://docs.dolphindb.com/en/Functions/c/cumstd.html)\n\n\n\n#### Syntax\n\ncumstd(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the standard deviation of *X*.\n\n#### Examples\n\n```\nx = [1,2,4,NULL,8];\ncumstd(x);\n// output\n[,0.707107,1.527525,1.527525,3.095696]\n\nm=matrix(0.15 0.08 0.03 -0.14 -0.09, 0.2 -0.12 -0.16 0.08 0.16);\nm;\n```\n\n| #0    | #1    |\n| ----- | ----- |\n| 0.15  | 0.2   |\n| 0.08  | -0.12 |\n| 0.03  | -0.16 |\n| -0.14 | 0.08  |\n| -0.09 | 0.16  |\n\n```\ncumstd(m);\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n| 0.049497474683058 | 0.226274169979695 |\n| 0.060277137733417 | 0.19731531449265  |\n| 0.123558353285671 | 0.169705627484771 |\n| 0.119707978013163 | 0.16346253393362  |\n\nRelated functions: [std](https://docs.dolphindb.com/en/Functions/s/std.html)\n"
    },
    "cumstdp": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumstdp.html",
        "signatures": [
            {
                "full": "cumstdp(X)",
                "name": "cumstdp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumstdp](https://docs.dolphindb.com/en/Functions/c/cumstdp.html)\n\n\n\n#### Syntax\n\ncumstdp(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the population standard deviation of *X*.\n\n#### Examples\n\n```\ncumstdp(1 2 4 NULL 8);\n// output\n[ , 0.5, 1.247219128924647, 1.247219128924647, 2.680951323690902]\n```\n\n```\nm=matrix(0.15 0.08 0.03 -0.14 -0.09, 0.2 -0.12 -0.16 0.08 0.16);\nm;\n```\n\n| #0    | #1    |\n| ----- | ----- |\n| 0.15  | 0.2   |\n| 0.08  | -0.12 |\n| 0.03  | -0.16 |\n| -0.14 | 0.08  |\n| -0.09 | 0.16  |\n\n```\ncumstdp(m);\n```\n\n| col1   | col2   |\n| ------ | ------ |\n| 0      | 0      |\n| 0.035  | 0.16   |\n| 0.0492 | 0.1611 |\n| 0.107  | 0.147  |\n| 0.1071 | 0.1462 |\n\nRelated function: [stdp](https://docs.dolphindb.com/en/Functions/s/stdp.html)\n"
    },
    "cumstdpTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumstdpTopN.html",
        "signatures": [
            {
                "full": "cumstdpTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumstdpTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumstdpTopN](https://docs.dolphindb.com/en/Functions/c/cumstdpTopN.html)\n\n\n\n#### Syntax\n\ncumstdpTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the population standard deviation of the first *top* elements in a cumulative window.\n\n**Return value**: DOUBLE type.\n\n#### Examples\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumstdpTopN(X, S, 6, 4)\n// output\n[0,0.5,0.8164,3.5355,38.5299,35.8933,35.8116]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumstdpTopN(X, S, 6, 4)\n```\n\n| #1     | #2     |\n| ------ | ------ |\n| 0      |        |\n| 0.5    | 0      |\n| 0.8165 | 0.5    |\n| 0.8165 | 0.8165 |\n| 1.479  | 0.8165 |\n| 1.8547 | 1.479  |\n| 2.1602 | 1.8547 |\n| 2.3805 | 2.1602 |\n| 2.3805 | 2.5441 |\n| 2.3805 | 2.7689 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumstdpTopN(price, id, 6, 4) as result from t\n```\n\n| result  |\n| ------- |\n| 0       |\n| 28.5    |\n| 26.8701 |\n| 24.8294 |\n| 22.2657 |\n| 29.4543 |\n| 29.4543 |\n| 30.8081 |\n| 25.5435 |\n| 25.5435 |\n"
    },
    "cumstdTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumstdTopN.html",
        "signatures": [
            {
                "full": "cumstdTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumstdTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumstdTopN](https://docs.dolphindb.com/en/Functions/c/cumstdTopN.html)\n\n\n\n#### Syntax\n\ncumstdTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the unbiased sample standard deviation of the first *top* elements in a cumulative window.\n\n**Return value**: DOUBLE type.\n\n#### Examples\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumstdTopN(X, S, 6, 4)\n// output\n[,0.70,1,4.08,43.07,39.31,39.22]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumstdTopN(X, S, 6, 4)\n```\n\n| #0     | #1     |\n| ------ | ------ |\n|        |        |\n| 0.7071 |        |\n| 1      | 0.7071 |\n| 1      | 1      |\n| 1.7078 | 1      |\n| 2.0736 | 1.7078 |\n| 2.3664 | 2.0736 |\n| 2.6077 | 2.3664 |\n| 2.6077 | 2.7869 |\n| 2.6077 | 3.0332 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumavgTopN(price, id, 6, 4) as result from t\n```\n\n| result  |\n| ------- |\n| 94      |\n| 69.5    |\n| 46.3333 |\n| 55.75   |\n| 57.8    |\n| 49.6667 |\n| 50.5    |\n| 50.5    |\n| 51.5    |\n| 51.5    |\n"
    },
    "cumsum": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumsum.html",
        "signatures": [
            {
                "full": "cumsum(X)",
                "name": "cumsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumsum](https://docs.dolphindb.com/en/Functions/c/cumsum.html)\n\n\n\n#### Syntax\n\ncumsum(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the sum of the elements in *X*.\n\n#### Examples\n\n```language-python\nx=[2,3,4];\ncumsum(x);\n// output\n[2,5,9]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```language-python\ncumsum(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 3  | 9  |\n| 6  | 15 |\n\nRelated functions: [cumsum2](https://docs.dolphindb.com/en/Functions/c/cumsum2.html), [cumsum3](https://docs.dolphindb.com/en/Functions/c/cumsum3.html), [cumsum4](https://docs.dolphindb.com/en/Functions/c/cumsum4.html)\n"
    },
    "cumsum2": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumsum2.html",
        "signatures": [
            {
                "full": "cumsum2(X)",
                "name": "cumsum2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumsum2](https://docs.dolphindb.com/en/Functions/c/cumsum2.html)\n\n\n\n#### Syntax\n\ncumsum2(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the sum of squares of the elements in *X*.\n\n#### Examples\n\n```\nx=[2,3,4];\ncumsum2 x;\n// output\n[4,13,29]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 16 |\n| 5  | 41 |\n| 14 | 77 |\n\nRelated function: [cumsum](https://docs.dolphindb.com/en/Functions/c/cumsum.html), [cumsum3](https://docs.dolphindb.com/en/Functions/c/cumsum3.html), [cumsum4](https://docs.dolphindb.com/en/Functions/c/cumsum4.html)\n"
    },
    "cumsum3": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumsum3.html",
        "signatures": [
            {
                "full": "cumsum3(X)",
                "name": "cumsum3",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumsum3](https://docs.dolphindb.com/en/Functions/c/cumsum3.html)\n\n\n\n#### Syntax\n\ncumsum3(X)\n\nPlease see [cumFunctions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCumulatively calculate the cubes of squares of the elements in *X*.\n\n#### Examples\n\n```\nx=[2,3,4];\ncumsum3 x;\n// output\n[8,35,99]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ncumsum3(m);\n```\n\n| #0 | #1  |\n| -- | --- |\n| 1  | 64  |\n| 9  | 189 |\n| 36 | 405 |\n\nRelated functions: [cumsum](https://docs.dolphindb.com/en/Functions/c/cumsum.html), [cumsum2](https://docs.dolphindb.com/en/Functions/c/cumsum2.html), [cumsum4](https://docs.dolphindb.com/en/Functions/c/cumsum4.html)\n"
    },
    "cumsum4": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumsum4.html",
        "signatures": [
            {
                "full": "cumsum4(X)",
                "name": "cumsum4",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumsum4](https://docs.dolphindb.com/en/Functions/c/cumsum4.html)\n\n\n\n#### Syntax\n\ncumsum4(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the fourth powers of the elements in *X*.\n\n#### Examples\n\n```\nx=[2,3,4];\ncumsum4 x;\n// output\n[16,97,353]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ncumsum4(m);\n```\n\n| #0 | #1   |\n| -- | ---- |\n| 1  | 256  |\n| 17 | 881  |\n| 98 | 2177 |\n\nRelated functions: [cumsum](https://docs.dolphindb.com/en/Functions/c/cumsum.html), [cumsum2](https://docs.dolphindb.com/en/Functions/c/cumsum2.html), [cumsum3](https://docs.dolphindb.com/en/Functions/c/cumsum3.html)\n"
    },
    "cumsumTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumsumTopN.html",
        "signatures": [
            {
                "full": "cumsumTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumsumTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumsumTopN](https://docs.dolphindb.com/en/Functions/c/cumsumTopN.html)\n\n\n\n#### Syntax\n\ncumsumTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* by *S* in the order specified by *ascending*, then sums up the first *top* elements in a cumulative window.\n\n**Return value**: LONG or DOUBLE type.\n\n#### Examples\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumsumTopN(X, S, 6, 4)\n// output\n[1,3,6,16,116,120,121]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumsumTopN(X, S, 6, 4)\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 3  | 12 |\n| 6  | 25 |\n| 6  | 39 |\n| 11 | 39 |\n| 17 | 55 |\n| 24 | 72 |\n| 30 | 90 |\n| 30 | 95 |\n| 30 | 96 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumsumTopN(price, id, 6, 4) as result from t\n```\n\n| result |\n| ------ |\n| 32     |\n| 130    |\n| 145    |\n| 223    |\n| 283    |\n| 292    |\n| 344    |\n| 364    |\n| 406    |\n| 333    |\n"
    },
    "cumvar": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumvar.html",
        "signatures": [
            {
                "full": "cumvar(X)",
                "name": "cumvar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumvar](https://docs.dolphindb.com/en/Functions/c/cumvar.html)\n\n\n\n#### Syntax\n\ncumvar(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the variance of *X*.\n\n#### Examples\n\n```\nx=[2,3,4];\ncumvar(x);\n// output\n[,0.5,1]\n\nm=matrix(0.15 0.08 0.03 -0.14 -0.09, 0.2 -0.12 -0.16 0.08 0.16);\nm;\n```\n\n| #0    | #1    |\n| ----- | ----- |\n| 0.15  | 0.2   |\n| 0.08  | -0.12 |\n| 0.03  | -0.16 |\n| -0.14 | 0.08  |\n| -0.09 | 0.16  |\n\n```\ncumvar(m);\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n| 0.00245           | 0.0512            |\n| 0.003633333333333 | 0.038933333333333 |\n| 0.015266666666667 | 0.0288            |\n| 0.01433           | 0.02672           |\n\nRelated functions: [cummax](https://docs.dolphindb.com/en/Functions/c/cummax.html), [cummin](https://docs.dolphindb.com/en/Functions/c/cummin.html), [cumprod](https://docs.dolphindb.com/en/Functions/c/cumprod.html), [cumPositiveStreak](https://docs.dolphindb.com/en/Functions/c/cumPositiveStreak.html), [cumsum](https://docs.dolphindb.com/en/Functions/c/cumsum.html), [cumavg](https://docs.dolphindb.com/en/Functions/c/cumavg.html), [cumstd](https://docs.dolphindb.com/en/Functions/c/cumstd.html)\n"
    },
    "cumvarp": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumvarp.html",
        "signatures": [
            {
                "full": "cumvarp(X)",
                "name": "cumvarp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumvarp](https://docs.dolphindb.com/en/Functions/c/cumvarp.html)\n\n\n\n#### Syntax\n\ncumvarp(X)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCumulatively calculate the population variance of *X*.\n\n#### Examples\n\n```\ncumvarp(1 2 3 NULL 4);\n// output\n[ , 0.25, 0.666666666666667, 0.666666666666667, 1.25]\n```\n\n```\nm=matrix(1.1 3 5.0 7.5 9.2, 1 4.3 7.1 10.6 13.5);\nm;\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1.1  | 1    |\n| 3    | 4.3  |\n| 5    | 7.1  |\n| 7.5  | 10.6 |\n| 9.2  | 13.5 |\n\n```\ncumvarp(m);\n```\n\n| col1   | col2    |\n| ------ | ------- |\n| 0      | 0       |\n| 0.9025 | 2.7225  |\n| 2.5356 | 6.2156  |\n| 5.6425 | 12.5025 |\n| 8.5944 | 19.612  |\n\nRelated function: [varp](https://docs.dolphindb.com/en/Functions/v/varp.html)\n"
    },
    "cumvarpTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumvarpTopN.html",
        "signatures": [
            {
                "full": "cumvarpTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumvarpTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumvarpTopN](https://docs.dolphindb.com/en/Functions/c/cumvarpTopN.html)\n\n\n\n#### Syntax\n\ncumvarpTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the population variance of the first *top* elements in a cumulative window.\n\n**Return value**: DOUBLE type.\n\n#### Examples\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumvarpTopN(X, S, 6, 4)\n// output\n[0,0.25,0.6666,12.5,1484.5599,1288.3333,1282.4722]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumvarpTopN(X, S, 6, 4)\n```\n\n| #1     | #2     |\n| ------ | ------ |\n| 0      |        |\n| 0.25   | 0      |\n| 0.6667 | 0.25   |\n| 0.6667 | 0.6667 |\n| 2.1875 | 0.6667 |\n| 3.44   | 2.1875 |\n| 4.6667 | 3.44   |\n| 5.6667 | 4.6667 |\n| 5.6667 | 6.4722 |\n| 5.6667 | 7.6667 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumvarpTopN(price, id, 6, 4) as result from t\n```\n\n| result   |\n| -------- |\n| 0        |\n| 182.25   |\n| 124.2222 |\n| 114.5    |\n| 255.44   |\n| 428.4722 |\n| 428.4722 |\n| 416.9167 |\n| 722.9167 |\n| 722.9167 |\n"
    },
    "cumvarTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumvarTopN.html",
        "signatures": [
            {
                "full": "cumvarTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumvarTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumvarTopN](https://docs.dolphindb.com/en/Functions/c/cumvarTopN.html)\n\n\n\n#### Syntax\n\ncumvarTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the unbiased sample variance of the first *top* elements in a cumulative window.\n\n**Return value**: DOUBLE type.\n\n#### Examples\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumvarTopN(X, S, 6, 4)\n// output\n[,0.5,1,16.6666,1855.7,1546,1538.9666]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumvarTopN(X, S, 6, 4)\n```\n\n| #0     | #1     |\n| ------ | ------ |\n|        |        |\n| 0.5    |        |\n| 1      | 0.5    |\n| 1      | 1      |\n| 2.9167 | 1      |\n| 4.3    | 2.9167 |\n| 5.6    | 4.3    |\n| 6.8    | 5.6    |\n| 6.8    | 7.7667 |\n| 6.8    | 9.2    |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumvarTopN(price, id, 6, 4) as result from t\n```\n\n| result   |\n| -------- |\n|          |\n| 800      |\n| 808.3333 |\n| 730.25   |\n| 825.2    |\n| 903.3667 |\n| 747.3667 |\n| 856.7    |\n| 887.4667 |\n| 994.9667 |\n"
    },
    "cumwavg": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumwavg.html",
        "signatures": [
            {
                "full": "cumwavg(X, Y)",
                "name": "cumwavg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cumwavg](https://docs.dolphindb.com/en/Functions/c/cumwavg.html)\n\n\n\n#### Syntax\n\ncumwavg(X, Y)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCalculate the cumulative weighted average of *X* with *Y* as the weights. The result is a vector of the same length as *X*. NULL values are ignored in the calculation.\n\n#### Examples\n\n```\ncumwavg(2.2 1.1 3.3, 4 5 6);\n// output\n[2.2,1.588889,2.273333]\n\ncumwavg(1 NULL 1, 1 1 1);\n// output\n[1,1,1]\n```\n\nRelated function: [wavg](https://docs.dolphindb.com/en/Functions/w/wavg.html)\n"
    },
    "cumwsum": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumwsum.html",
        "signatures": [
            {
                "full": "cumwsum(X, Y)",
                "name": "cumwsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cumwsum](https://docs.dolphindb.com/en/Functions/c/cumwsum.html)\n\n\n\n#### Syntax\n\ncumwsum(X, Y)\n\nPlease see [Cumulative Window Functions](https://docs.dolphindb.com/en/Functions/Themes/cumFunctions.html) for the parameter description and windowing logic.\n\n#### Details\n\nCalculate the cumulative weighted sum of *X* with *Y* as the weights. The result is a vector of the same length as *X*. NULL values are ignored in the calculation.\n\n#### Examples\n\n```\ncumwsum(2.2 1.1 3.3, 4 5 6);\n// output\n[8.8,14.3,34.1]\n\ncumwsum(1 NULL 1, 1 1 1);\n// output\n[1,1,2]\n```\n\nRelated function: [wsum](https://docs.dolphindb.com/en/Functions/w/wsum.html)\n"
    },
    "cumwsumTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cumwsumTopN.html",
        "signatures": [
            {
                "full": "cumwsumTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumwsumTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumwsumTopN](https://docs.dolphindb.com/en/Functions/c/cumwsumTopN.html)\n\n\n\n#### Syntax\n\ncumwsumTopN(X, Y, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [Cumulative Moving TopN Functions](https://docs.dolphindb.com/en/Functions/Themes/cumTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nThe function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the moving sums of *X* with *Y* as weights in a cumulative window.\n\n**Return value**: DOUBLE type\n\n#### Examples\n\n```\nX=1 2 3 10 13 4 3\nY = 1 7 8 9 0 5 8\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumwsumTopN(X, Y, S, 6, 3)\n// output\n[1,15,39,129,129,149,159]\n```\n"
    },
    "cut": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cut.html",
        "signatures": [
            {
                "full": "cut(X, size|cutPositions)",
                "name": "cut",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "size|cutPositions",
                        "name": "size|cutPositions"
                    }
                ]
            }
        ],
        "markdown": "### [cut](https://docs.dolphindb.com/en/Functions/c/cut.html)\n\n\n\n#### Syntax\n\ncut(X, size|cutPositions)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n**size** is a positive integer that must be no greater than the size of *X*.\n\n**cutPositions** is a vector with increasing elements, which is used to specify the starting position of each vector in the result.\n\n#### Details\n\nThis function divides *X* based on the specified *size* or *cutPositions* and returns a tuple.\n\n* When *X* is a scalar, *size* can only be specified as 1.\n\n* When *X* is a vector:\n\n  * if *size* is specified, it divides *X* into a list of scalars (*size*=1) or vectors (*size*>1) of length *size*.\n\n  * if *cutPositions* is specified, it divides *X* into a list of vectors at the specified positions.\n\n* When *X* is a matrix (table):\n\n  * if *size* is specified, it divides *X* into several matrices (tables) with *size* columns (rows).\n\n  * if *cutPositions* is specified, it divides *X* into several matrices (tables) at the specified positions.\n\nRefer to function [flatten](https://docs.dolphindb.com/en/Functions/f/flatten.html) for the reverse operation.\n\n#### Examples\n\n```\na=1..10;\n\ncut(a,2);\n// output\n([1,2],[3,4],[5,6],[7,8],[9,10])\n\ncut(a,3);\n// output\n([1,2,3],[4,5,6],[7,8,9],[10])\n\ncut(a,9);\n// output\n([1,2,3,4,5,6,7,8,9],[10])\n\nb = cut(a,2);\nb;\n// output\n([1,2],[3,4],[5,6],[7,8],[9,10])\n\nflatten b;\n// output\n(1,2,3,4,5,6,7,8,9,10)\n\ncut(a, 0 2 7);\n// output\n([1,2],[3,4,5,6,7],[8,9,10])\n\ncut(a, 2 7);\n// output\n([3,4,5,6,7],[8,9,10])\n```\n\nThe `cut` function can be a convenient tool in time-series data analysis. In the example below, we use the cut function to calculate an aggregate measure between two events.\n\n```\nincomes=table(2016.07.31 - 10..1 as date, rand(100,10) as income);\nincomes;\n```\n\n| date       | income |\n| ---------- | ------ |\n| 2016.07.21 | 78     |\n| 2016.07.22 | 61     |\n| 2016.07.23 | 79     |\n| 2016.07.24 | 15     |\n| 2016.07.25 | 78     |\n| 2016.07.26 | 22     |\n| 2016.07.27 | 30     |\n| 2016.07.28 | 81     |\n| 2016.07.29 | 17     |\n| 2016.07.30 | 52     |\n\n```\neventdates = [2016.07.22, 2016.07.25, 2016.07.29];\n\nx = incomes.date.binsrch(eventdates);\nx;\n// output\n[1,4,8]\n\nincomes.date.cut(x);\n// output\n([2016.07.22,2016.07.23,2016.07.24],[2016.07.25,2016.07.26,2016.07.27,2016.07.28],[2016.07.29,2016.07.30])\n\ntable(eventdates as startDate, each(last,incomes.date.cut(x)) as endDate, each(sum,incomes.income.cut(x)) as incomeSum);\n```\n\n| startDate  | endDate    | incomeSum |\n| ---------- | ---------- | --------- |\n| 2016.07.22 | 2016.07.24 | 155       |\n| 2016.07.25 | 2016.07.28 | 211       |\n| 2016.07.29 | 2016.07.30 | 69        |\n"
    },
    "cutPoints": {
        "url": "https://docs.dolphindb.com/en/Functions/c/cutPoints.html",
        "signatures": [
            {
                "full": "cutPoints(X, binNum, [freq])",
                "name": "cutPoints",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "binNum",
                        "name": "binNum"
                    },
                    {
                        "full": "[freq]",
                        "name": "freq",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [cutPoints](https://docs.dolphindb.com/en/Functions/c/cutPoints.html)\n\n\n\n#### Syntax\n\ncutPoints(X, binNum, \\[freq])\n\n#### Arguments\n\n**X** is a vector.\n\n**binNum** is the number of buckets to be formed.\n\n**freq** (optional) is a vector with the same size as *X*. It specifies the frequency for each element in *X*. If it is specified, all the elements in *X* must be unique and sorted in ascending order.\n\n#### Details\n\nReturn a vector with (*binNum*+1) elements such that the elements of *X* are evenly distributed within each of the *binNum* buckets indicated by the vector. Each bucket is defined by two adjacent elements of the vector. The lower bound is inclusive and the upper bound is exclusive.\n\nThe function can be used to get the partition scheme of a range domain in a distributed database.\n\n#### Examples\n\n```\ncutPoints(2 3 1 4, 2);\n// output\n[1,3,5]\n\ncutPoints(1 2 3 4, 2, 1 1 1 3);\n// output\n[1,4,5]\n```\n"
    },
    "CVaR": {
        "url": "https://docs.dolphindb.com/en/Functions/c/CVaR.html",
        "signatures": [
            {
                "full": "condValueAtRisk(returns, method, [confidenceLevel=0.95])",
                "name": "condValueAtRisk",
                "parameters": [
                    {
                        "full": "returns",
                        "name": "returns"
                    },
                    {
                        "full": "method",
                        "name": "method"
                    },
                    {
                        "full": "[confidenceLevel=0.95]",
                        "name": "confidenceLevel",
                        "optional": true,
                        "default": "0.95"
                    }
                ]
            }
        ],
        "markdown": "### [CVaR](https://docs.dolphindb.com/en/Functions/c/CVaR.html)\n\nAlias for [condValueAtRisk](https://docs.dolphindb.com/en/Functions/c/condValueAtRisk.html)\n\n\nDocumentation for the `condValueAtRisk` function:\n### [condValueAtRisk](https://docs.dolphindb.com/en/Functions/c/condValueAtRisk.html)\n\n#### Syntax\n\ncondValueAtRisk(returns, method, \\[confidenceLevel=0.95])\n\nAlias: CVaR\n\n#### Arguments\n\n**returns** is a numeric vector representing the returns. The element must be greater than -1 and cannot be empty.\n\n**method** is a string indicating the CVaR calculation method, which can be:\n\n* 'normal': parametric method with normal distribution\n* 'logNormal': parametric method with log-normal distribution\n* 'historical': historical method\n* 'monteCarlo': Monte Carlo simulation\n\n**confidenceLevel** (optional) is a numeric scalar representing the confidence level, with a valid range of (0,1). The default value is 0.95.\n\n#### Details\n\nCalculate Conditional Value at Risk (CVaR), or expected shortfall (ES) to estimate the average losses incurred beyond the VaR level.\n\n**Return value**: a DOUBLE value indicating the absolute value of the average losses that exceed the VaR. The value of VaR is returned if there is no return beyond the level.\n\n#### Examples\n\nCalculate CVaR using historical method at a confidence level of 0.9 based on given returns:\n\n```\nreturns = [0.0, -0.0023816107391389394, -0.0028351258634076834, 0.00789570628538656, 0.0022056267475062397, -0.004515475812603498, 0.0031189325339843646, 0.010774648811452205, 0.0030816164453268957, 0.02172541561228001, 0.011106185767699728, -0.005369098699244845, -0.0096490689793588, 0.0025152212699484314, 0.017822140037111668, -0.02837536728283525, 0.018373545076599204, -0.0026401111537113003, 0.019524374522517898, -0.010800546314337627, 0.014073362622486131, -0.00398277532382243, 0.008398647051501285, 0.0024056749358184904, 0.007093080335863512, -0.005332549248384733, -0.008471915938733665, -0.0038788486165083342, -0.01308504169086584, 0.00350496242864784, 0.009036118926745962, 0.0013358223875250545, 0.0036426642608267563, 0.003974568474545581, -0.003944066366522669, -0.011969668605022311, 0.015116930499066374, 0.006931427295653037, -0.0032650627551519267, 0.003407880132851648]\ncondValueAtRisk(returns, 'historical', 0.9);\n//output: 0.016057655973\n```\n\n"
    },
    "eig": {
        "url": "https://docs.dolphindb.com/en/Functions/e/eig.html",
        "signatures": [
            {
                "full": "eig(A)",
                "name": "eig",
                "parameters": [
                    {
                        "full": "A",
                        "name": "A"
                    }
                ]
            }
        ],
        "markdown": "### [eig](https://docs.dolphindb.com/en/Functions/e/eig.html)\n\n\n\n#### Syntax\n\neig(A)\n\n#### Arguments\n\n**A** is a real symmetric matrix or a Hermitian matrix.\n\n#### Details\n\nCalculate the eigenvalues and eigenvectors of *A*.\n\nThe result of `eig` is the same as the result of `numpy.linalg.eigh`.\n\n**Return value**: a dictionary\n\n#### Examples\n\n```\nA = 1 1 2 7 9 3 5 7 0 $ 3:3;\neig(A);\n// output\nvectors->\n#0        #1       #2\n--------- -------- ---------\n0.839752  0.169451 -0.515852\n-0.301349 0.935753 -0.18318\n0.45167   0.309277 0.836864\n\nvalues->[1.716868,10.17262,-1.889488]\n```\n\nFor the eigenvalue of 1.716868, the corresponding eigenvector is:\n\n```\neig(A).vectors[0];\n// output\n[0.839752,-0.301349,0.45167]\n```\n"
    },
    "elasticNet": {
        "url": "https://docs.dolphindb.com/en/Functions/e/elasticNet.html",
        "signatures": [
            {
                "full": "elasticNet(ds, yColName, xColNames, [alpha=1.0], [l1Ratio=0.5], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])",
                "name": "elasticNet",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alpha=1.0]",
                        "name": "alpha",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[l1Ratio=0.5]",
                        "name": "l1Ratio",
                        "optional": true,
                        "default": "0.5"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[positive=false]",
                        "name": "positive",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    },
                    {
                        "full": "[checkInput=true]",
                        "name": "checkInput",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [elasticNet](https://docs.dolphindb.com/en/Functions/e/elasticNet.html)\n\n\n\n#### Syntax\n\nelasticNet(ds, yColName, xColNames, \\[alpha=1.0], \\[l1Ratio=0.5], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[positive=false], \\[swColName], \\[checkInput=true])\n\n#### Arguments\n\n**ds** is an in-memory table or a data source usually generated by the [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html) function.\n\n**yColName** is a string indicating the column name of the dependent variable in *ds*.\n\n**xColNames** is a STRING scalar/vector indicating the column names of the independent variables in *ds*.\n\n**alpha** (optional) is a floating-point number representing the constant that multiplies the L1-norm. The default value is 1.0.\n\n**l1Ratio** (optional) is a floating-point number between 0 and 1 indicating the mixing parameter. For *l1Ratio* = 0 the penalty is an L2 penalty; for *l1Ratio* = 1 it is an L1 penalty; for 0 < *l1Ratio* < 1, the penalty is a combination of L1 and L2. The default value is 0.5.\n\n**intercept** (optional) is a Boolean value indicating whether to include the intercept in the regression. The default value is true.\n\n**normalize** (optional) is a Boolean value. If true, the regressors will be normalized before regression by subtracting the mean and dividing by the L2-norm. If *intercept*=false, this parameter will be ignored. The default value is false.\n\n**maxIter** (optional) is a positive integer indicating the maximum number of iterations. The default value is 1000.\n\n**tolerance** (optional) is a floating-point number. The iterations stop when the improvement in the objective function value is smaller than tolerance. The default value is 0.0001.\n\n**positive** (optional) is a Boolean value indicating whether to force the coefficient estimates to be positive. The default value is false.\n\n**swColName** (optional) is a string indicating a column name of *ds*. The specified column is used as the sample weight. If it is not specified, the sample weight is treated as 1.\n\n**checkInput** (optional) is a Boolean value. It determines whether to enable validation check for parameters *yColName*, *xColNames*, and *swColName*.\n\n* If *checkInput* = true (default), it will check the invalid value for parameters and throw an error if the NULL value exists.\n\n* If *checkInput* = false, the invalid value is not checked.\n\nIt is recommended to specify *checkInput* = true. If it is false, it must be ensured that there are no invalid values in the input parameters and no invalid values will be generated during intermediate calculations, otherwise the returned model may be inaccurate.\n\n#### Details\n\nImplement linear regression with elastic net penalty (combined L1 and L2 priors as regularizer).\n\nMinimize the following objective function:\n\n![](https://docs.dolphindb.com/en/images/elasticnet.png)\n\n#### Examples\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288]\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599]\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219]\nt = table(y, x0, x1)\nelasticNet(t, `y, `x0`x1);\n```\n\nIf t is a DFS table, then the input should be a data source:\n\n```\nelasticNet(sqlDS(<select * from t>), `y, `x0`x1);\n```\n"
    },
    "elasticNetBasic": {
        "url": "https://docs.dolphindb.com/en/Functions/e/elasticnetbasic.html",
        "signatures": [
            {
                "full": "elasticNetBasic(Y, X, [mode], [alpha], [l1Ratio], [intercept], [normalize], [maxIter], [tolerance], [positive], [swColName], [checkInput])",
                "name": "elasticNetBasic",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[mode]",
                        "name": "mode",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    },
                    {
                        "full": "[l1Ratio]",
                        "name": "l1Ratio",
                        "optional": true
                    },
                    {
                        "full": "[intercept]",
                        "name": "intercept",
                        "optional": true
                    },
                    {
                        "full": "[normalize]",
                        "name": "normalize",
                        "optional": true
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[tolerance]",
                        "name": "tolerance",
                        "optional": true
                    },
                    {
                        "full": "[positive]",
                        "name": "positive",
                        "optional": true
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    },
                    {
                        "full": "[checkInput]",
                        "name": "checkInput",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [elasticNetBasic](https://docs.dolphindb.com/en/Functions/e/elasticnetbasic.html)\n\n\n\n#### Syntax\n\nelasticNetBasic(Y, X, \\[mode], \\[alpha], \\[l1Ratio], \\[intercept], \\[normalize], \\[maxIter], \\[tolerance], \\[positive], \\[swColName], \\[checkInput])\n\n#### Details\n\nPerform elastic net regression.\n\nMinimize the following objective function:\n\n![](https://docs.dolphindb.com/en/images/elasticNetBasic.png)\n\n#### Arguments\n\n**Y** is a numeric vector indicating the dependent variable.\n\n**X** is a numeric vector/tuple/matrix/table indicating the independent variable.\n\n* When *X* is a vector/tuple, it must be of the same length as *Y*.\n\n* When *X* is a matrix/table, the number of rows must be the same as the length of *Y*.\n\n**mode**is an integer indicating the contents in the output. It can be:\n\n* 0 (default): a vector of the coefficient estimates.\n\n* 1: a table with coefficient estimates, standard error, t-statistics, and p-values.\n\n* 2: a dictionary with the following keys: ANOVA, RegressionStat, Coefficient, and Residual.\n\n<table id=\"table_n2f_fcz_21c\"><thead><tr><th align=\"left\">\n\nSource of Variance\n\n</th><th align=\"left\">\n\nDF (degree of freedom)\n\n</th><th align=\"left\">\n\nSS (sum of square)\n\n</th><th align=\"left\">\n\nMS (mean of square)\n\n</th><th align=\"left\">\n\nF (F-score)\n\n</th><th align=\"left\">\n\nSignificance\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\nRegression\n\n</td><td align=\"left\">\n\np\n\n</td><td align=\"left\">\n\nsum of squares regression, SSR\n\n</td><td align=\"left\">\n\nregression mean square, MSR=SSR/R\n\n</td><td align=\"left\">\n\nMSR/MSE\n\n</td><td align=\"left\">\n\np-value\n\n</td></tr><tr><td align=\"left\">\n\nResidual\n\n</td><td align=\"left\">\n\nn-p-1\n\n</td><td align=\"left\">\n\nsum of squares error, SSE\n\n</td><td align=\"left\">\n\nmean square error, MSE=MSE/E\n\n</td><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td></tr><tr><td align=\"left\">\n\nTotal\n\n</td><td align=\"left\">\n\nn-1\n\n</td><td align=\"left\">\n\nsum of squares total, SST\n\n</td><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td></tr></tbody>\n</table><table id=\"table_u2f_fcz_21c\"><thead><tr><th align=\"left\">\n\nItem\n\n</th><th align=\"left\">\n\nDescription\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\nR2\n\n</td><td align=\"left\">\n\nR-squared\n\n</td></tr><tr><td align=\"left\">\n\nAdjustedR2\n\n</td><td align=\"left\">\n\nThe adjusted R-squared corrected based on the degrees of freedom by comparing the sample size to the number of terms in the regression model.\n\n</td></tr><tr><td align=\"left\">\n\nStdError\n\n</td><td align=\"left\">\n\nThe residual standard error/deviation corrected based on the degrees of freedom.\n\n</td></tr><tr><td align=\"left\">\n\nObservations\n\n</td><td align=\"left\">\n\nThe sample size.\n\n</td></tr></tbody>\n</table><table id=\"table_x2f_fcz_21c\"><thead><tr><th align=\"left\">\n\nItem\n\n</th><th align=\"left\">\n\nDescription\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\nfactor\n\n</td><td align=\"left\">\n\nIndependent variables\n\n</td></tr><tr><td align=\"left\">\n\nbeta\n\n</td><td align=\"left\">\n\nEstimated regression coefficients\n\n</td></tr><tr><td align=\"left\">\n\nStdError\n\n</td><td align=\"left\">\n\nStandard error of the regression coefficients\n\n</td></tr><tr><td align=\"left\">\n\ntstat\n\n</td><td align=\"left\">\n\nt statistic, indicating the significance of the regression coefficients\n\n</td></tr></tbody>\n</table>Residual: the difference between each predicted value and the actual value.\n\n**alpha**(optional) is a floating number representing the constant that multiplies the L1-norm. The default value is 1.0.\n\n**intercept** (optional) is a Boolean value indicating whether to include the intercept in the regression. The default value is true.\n\n**normalize** (optional) is a Boolean value. If true, the regressors will be normalized before regression by subtracting the mean and dividing by the L2-norm. If *intercept*=false, this parameter will be ignored. The default value is false.\n\n**maxIter** (optional) is a positive integer indicating the maximum number of iterations. The default value is 1000.\n\n**tolerance** (optional) is a floating number. The iterations stop when the improvement in the objective function value is smaller than tolerance. The default value is 0.0001.\n\n**solver** (optional) is a string indicating the solver to use in the computation. It can be either 'svd' or 'cholesky'. It ds is a list of data sources, solver must be 'cholesky'.\n\n**swColName** (optional) is a STRING indicating a column name of *ds*. The specified column is used as the sample weight. If it is not specified, the sample weight is treated as 1.\n"
    },
    "elasticNetCV": {
        "url": "https://docs.dolphindb.com/en/Functions/e/elasticnetcv.html",
        "signatures": [
            {
                "full": "elasticNetCV(ds, yColName, xColNames, [alphas], [l1Ratio], [intercept], [normalize], [maxIter], [tolerance], [positive], [swColName], [checkInput])",
                "name": "elasticNetCV",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alphas]",
                        "name": "alphas",
                        "optional": true
                    },
                    {
                        "full": "[l1Ratio]",
                        "name": "l1Ratio",
                        "optional": true
                    },
                    {
                        "full": "[intercept]",
                        "name": "intercept",
                        "optional": true
                    },
                    {
                        "full": "[normalize]",
                        "name": "normalize",
                        "optional": true
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[tolerance]",
                        "name": "tolerance",
                        "optional": true
                    },
                    {
                        "full": "[positive]",
                        "name": "positive",
                        "optional": true
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    },
                    {
                        "full": "[checkInput]",
                        "name": "checkInput",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [elasticNetCV](https://docs.dolphindb.com/en/Functions/e/elasticnetcv.html)\n\n\n\n#### Syntax\n\nelasticNetCV(ds, yColName, xColNames, \\[alphas], \\[l1Ratio], \\[intercept], \\[normalize], \\[maxIter], \\[tolerance], \\[positive], \\[swColName], \\[checkInput])\n\n#### Arguments\n\nThe `elsticNetCV` function inherits all parameters of function [elasticNet](https://docs.dolphindb.com/en/Functions/e/elasticNet.html), with one added parameter, *alphas*.\n\n**alphas**(optional) is a floating-point scalar or vector that represents the coefficient multiplied by the L1 norm penalty term. The default value is \\[0.01, 0.1, 1.0].\n\n#### Details\n\nImplement linear regression with elastic net penalty using 5-fold cross-validation and return a model corresponding to the optimal parameters.\n\n**Return value**: A dictionary containing the following keys\n\n* modelName: the model name, which is \"elasticNetCV\" for this method\n\n* coefficients: the regression coefficients\n\n* intercept: the intercept\n\n* dual\\_gap: the dual gap\n\n* tolerance: the tolerance for the optimization\n\n* iterations: the number of iterations\n\n* xColNames: the column names of the independent variables in the data source\n\n* predict: the function used for prediction\n\n* alpha: the penalty term for cross-validation\n\n#### Examples\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288]\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599]\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219]\nt = table(y, x0, x1);\n\nelasticNetCV(t, `y, `x0`x1);\n\n// output\nmodelName->elasticNetCV\ncoefficients->[93.8331,13.9105]\nintercept->0.5416\ndual_gap->0.0037\ntolerance->0.0001\niterations->5\nxColNames->[\"x0\",\"x1\"]\npredict->coordinateDescentPredict\nalpha->0.01\n```\n"
    },
    "ema": {
        "url": "https://docs.dolphindb.com/en/Functions/e/ema.html",
        "signatures": [
            {
                "full": "ema(X, window, warmup=false)",
                "name": "ema",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "warmup=false",
                        "name": "warmup=false"
                    }
                ]
            }
        ],
        "markdown": "### [ema](https://docs.dolphindb.com/en/Functions/e/ema.html)\n\n\n\n#### Syntax\n\nema(X, window, warmup=false)\n\nPlease see [TALib](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**warmup** is a Boolean value. The default value is false, indicating that the first (window-1) elements windows return NULL. If set to true, elements in the first (window-1) windows are calculated based on the formula given in the details.\n\n#### Details\n\nCalculate the Exponential Moving Average (ema) for *X* in a count-based sliding window of the given length.\n\nThe calculation formula is as follows:\n\nwarmup=false:\n\n* ![](https://docs.dolphindb.com/en/images/ema_k.png)\n\n* warmup=true:\n\n  ![](https://docs.dolphindb.com/en/images/ema_ktrue.png)\n\n  where *EMAk* is the k-th exponential moving average, *n* is the length of sliding window, *Xk* is the k-th element of the vector *X*.\n\n#### Examples\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\nema(x,3);\n// output\n[,,12.3,12.55,12.225,11.9125,11.55625]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\nema(x,3);\n```\n\n| #0       | #1        |\n| -------- | --------- |\n|          |           |\n|          |           |\n| 12.30    | 15.666667 |\n| 12.55    | 17.333333 |\n| 12.225   | 19.166667 |\n| 11.9125  | 15.583333 |\n| 11.55625 | 12.791667 |\n\nRelated functions: [gema](https://docs.dolphindb.com/en/Functions/g/gema.html), [wilder](https://docs.dolphindb.com/en/Functions/w/wilder.html), [dema](https://docs.dolphindb.com/en/Functions/d/dema.html), [tema](https://docs.dolphindb.com/en/Functions/t/tema.html)\n"
    },
    "enableActivePartition": {
        "url": "https://docs.dolphindb.com/en/Functions/e/enableActivePartition.html",
        "signatures": [
            {
                "full": "enableActivePartition(db, activeDate, siteAlias)",
                "name": "enableActivePartition",
                "parameters": [
                    {
                        "full": "db",
                        "name": "db"
                    },
                    {
                        "full": "activeDate",
                        "name": "activeDate"
                    },
                    {
                        "full": "siteAlias",
                        "name": "siteAlias"
                    }
                ]
            }
        ],
        "markdown": "### [enableActivePartition](https://docs.dolphindb.com/en/Functions/e/enableActivePartition.html)\n\n\n\n#### Syntax\n\nenableActivePartition(db, activeDate, siteAlias)\n\n#### Arguments\n\n**db** is the handle of the historical database.\n\n**activeDate** is the date of the active database.\n\n**setAlias** is the node alias for the active database.\n\n#### Details\n\nEstablish a connection between the active database and the historical database.\n\n#### Examples\n\n```\nhistdb = database(\"C:\\DolphinDBDemo\\example\\data\\dbspace\\historical-A\\Trades2ndDomain\")\nactiveNodeAlias = getNodeAlias()\nactiveDate = today()\nenableActivePartition(histdb, activeDate, activeNodeAlias);\n```\n"
    },
    "enableQueryMonitor": {
        "url": "https://docs.dolphindb.com/en/Functions/e/enableQueryMonitor.html",
        "signatures": [
            {
                "full": "enableQueryMonitor()",
                "name": "enableQueryMonitor",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [enableQueryMonitor](https://docs.dolphindb.com/en/Functions/e/enableQueryMonitor.html)\n\n\n\n#### Syntax\n\nenableQueryMonitor()\n\n#### Arguments\n\nNone\n\n#### Details\n\nEnable the monitor on query status. The monitor is enabled by default.\n\nRelated function: [disableQueryMonitor](https://docs.dolphindb.com/en/Functions/d/disableQueryMonitor.html)\n"
    },
    "enableResourceTracking": {
        "url": "https://docs.dolphindb.com/en/Functions/e/enableresourcetracking.html",
        "signatures": [
            {
                "full": "enableResourceTracking()",
                "name": "enableResourceTracking",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [enableResourceTracking](https://docs.dolphindb.com/en/Functions/e/enableresourcetracking.html)\n\n\n\n#### Syntax\n\nenableResourceTracking()\n\n#### Arguments\n\nNone\n\n#### Details\n\nUse this function to enable resource tracking at runtime. This function can only be called by the administrator on a data node, and it only takes effect when *resourceSamplingInterval*is set to a positive integer.\n\nOnce resource tracking is enabled, the data nodes will track queries at intervals defined by *resourceSamplingInterval*.\n\n*\\<HomeDir>/resource/hardware.log*records the CPU and memory usage in CSV format, including the following information:\n\n* timestamp: the sampling timestamp of NANOTIMESTAMP type.\n\n* userId: the login user ID.\n\n* cpu: the number of CPU threads used by the user.\n\n* memory: the memory used (in bytes) by the user.\n\n*\\<HomeDir>/resource/access.log* records DFS SQL queries in CSV format, including the following information:\n\n* timestamp: the sampling timestamp of NANOTIMESTAMP type. If type is \"sql\", it indicates the start time of the query execution; If type is \"rowCount\" or \"memUsage\", it indicates the time when data is read.\n\n* rootQueryId: the root ID of a DFS query and all its sub-queries split by partition.\n\n* userId: the login user ID.\n\n* database: the queried database.\n\n* table: the queried table.\n\n* type: the message type, which can be sql, rowCount or memUsage.\n\n* value: the message value corresponding to each type.\n\n  * sql: the execution count (always 1).\n\n  * rowCount: the number of rows read.\n\n  * memUsage: the data volume read (in bytes).\n\nNote that the values for *rowCount*and *memUsage*are recorded based on each access. For example, after a dimension table is loaded into memory, the number of rows read and data volume read are logged each time the table is accessed, rather than the amount of data initially loaded into memory.\n\n* script: the SQL query script when type is sql, otherwise an empty string is logged.\n\nNote that for DFS SQL queries, currently only the SELECT statement is supported, and tables in nested table joins that are not compatible with ANSI SQL-92 are not tracked. For example, tables t1 and t2 in the query `ej(ej(t1, t2, `id), t3, `id)` are not sampled.\n\nTo prevent excessive growth of the query logs, log rotation is applied once the log files reach the size threshold. The generated file names contain timestamp prefixes. Logs are automatically removed after the retention period configured with *resourceSamplingLogRetentionTime*regardless of whether tracking is enabled.\n\nRelated function: [disableResourceTracking](https://docs.dolphindb.com/en/Functions/d/disableresourcetracking.html)\n"
    },
    "enableTableCachePurge": {
        "url": "https://docs.dolphindb.com/en/Functions/e/enableTableCachePurge.html",
        "signatures": [
            {
                "full": "enableTableCachePurge(table, [cacheSize],[cachePurgeTimeColumn],[cachePurgeInterval],[cacheRetentionTime])",
                "name": "enableTableCachePurge",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "[cacheSize]",
                        "name": "cacheSize",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeTimeColumn]",
                        "name": "cachePurgeTimeColumn",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeInterval]",
                        "name": "cachePurgeInterval",
                        "optional": true
                    },
                    {
                        "full": "[cacheRetentionTime]",
                        "name": "cacheRetentionTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [enableTableCachePurge](https://docs.dolphindb.com/en/Functions/e/enableTableCachePurge.html)\n\n#### Syntax\n\nenableTableCachePurge(table, \\[cacheSize],\\[cachePurgeTimeColumn],\\[cachePurgeInterval],\\[cacheRetentionTime])\n\n#### Arguments\n\n**table** is an empty stream table.\n\n**tableName** is a string indicating the name of the shared table.\n\n**cacheSize** (optional) is a positive integer used to determine the maximum number of records to retain in memory.\n\n**cachePurgeTimeColumn** (optional) is a STRING scalar indicating the time column in the stream table.\n\n**cachePurgeInterval** (optional) is a DURATION scalar indicating the interval to trigger cache purge.\n\n**cacheRetentionTime** (optional) is a DURATION scalar indicating the retention time of cached data.\n\n#### Details\n\nEnable cache purge for a non-persisted stream table.\n\nCache purge can be configured using either of the following methods:\n\n* **Cache purge by size**: Set *cacheSize*to specify a threshold for the number of records retained. Older records exceeding the threshold will be removed. The threshold is determined as follows:\n  * If the number of records appended in one batchdoes not exceed *cacheSize*, the threshold is 2.5 \\* *cacheSize*.\n  * If the number of records appended in one batch exceeds *cacheSize*, the threshold is 1.2 \\* (appended records + *cacheSize*).\n* **Cache purge by time**: Set *cachePurgeTimeColumn*, *cachePurgeInterval* and *cacheRetentionTime.* The system will clean up data based on the *cachePurgeTimeColumn*. Each time when a new record arrives, the system obtains the time difference between the new record and the oldest record kept in memory. If the time difference exceeds *cachePurgeInterval*, the system will retain only the data with timestamps within *cacheRetentionTime*of the new data.\n\n**Note**: If a record has not been enqueued for publishing, it will not be removed.\n\n#### Examples\n\nExample 1. Set *cacheSize*.\n\n```\nt = streamTable(1000:0, `time`sym`volume, [DATETIME, SYMBOL, INT])\nenableTableCachePurge(table=t, cacheSize=1000)\ntime = datetime(2024.01.01T09:00:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\n\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n// output: 0\n\ntime = datetime(2024.01.01T09:35:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n// output: 500\n```\n\nExample 2. Set *cachePurgeTimeColumn*, *cachePurgeInterval* and *cacheRetentionTime.*\n\n```\nt = streamTable(1000:0, `time`sym`volume, [DATETIME, SYMBOL, INT])\n\nenableTableCachePurge(table=t, cachePurgeTimeColumn=`time, cachePurgeInterval=30m, cacheRetentionTime=20m)\n\ntime = datetime(2024.01.01T09:00:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\n\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n// output: 0\n\ntime = datetime(2024.01.01T09:35:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n// output: 999\n```\n\n"
    },
    "enableTablePersistence": {
        "url": "https://docs.dolphindb.com/en/Functions/e/enableTablePersistence.html",
        "signatures": [
            {
                "full": "enableTablePersistence(table, [asynWrite=true], [compress=true], [cacheSize], [retentionMinutes=1440], [flushMode=0],[cachepurgeTimeColumn],[cachePurgeInterval],[cacheRetentionTime])",
                "name": "enableTablePersistence",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "[asynWrite=true]",
                        "name": "asynWrite",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[compress=true]",
                        "name": "compress",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[cacheSize]",
                        "name": "cacheSize",
                        "optional": true
                    },
                    {
                        "full": "[retentionMinutes=1440]",
                        "name": "retentionMinutes",
                        "optional": true,
                        "default": "1440"
                    },
                    {
                        "full": "[flushMode=0]",
                        "name": "flushMode",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[cachepurgeTimeColumn]",
                        "name": "cachepurgeTimeColumn",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeInterval]",
                        "name": "cachePurgeInterval",
                        "optional": true
                    },
                    {
                        "full": "[cacheRetentionTime]",
                        "name": "cacheRetentionTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [enableTablePersistence](https://docs.dolphindb.com/en/Functions/e/enableTablePersistence.html)\n\n\n\n#### Syntax\n\nenableTablePersistence(table, \\[asynWrite=true], \\[compress=true], \\[cacheSize], \\[retentionMinutes=1440], \\[flushMode=0],\\[cachepurgeTimeColumn],\\[cachePurgeInterval],\\[cacheRetentionTime])\n\n#### Arguments\n\n**table** is an empty shared stream table.\n\n**asynWrite** (optional) is a Boolean value indicating whether persistence is enabled in asynchronous mode. The default value is true, meaning asynchronous persistence is enabled. In this case, once data is written into memory, the write is deemed complete. The data stored in memory is then persisted to disk by another thread.\n\n**compress** (optional) is a Boolean value indicating whether to save a table to disk in compression mode. The default value is true.\n\n**cacheSize** (optional) is an integer specifying the maximum number of rows of the table to keep in memory. If not provided, all rows are kept.\n\n* The minimum valid value for this parameter is 1,000.\n\n* If *cacheSize* is greater than 1,000:\n\n  * When each batch of appended data does not exceed *cacheSize*, the data volume in memory will not exceed 1.5 times of *cacheSize*.\n\n  * When a batch exceeds *cacheSize*, the data volume in memory will not exceed 2 times the maximum number of appended rows.\n\n**retentionMinutes** (optional) is an integer indicating for how long (in minutes) a log file larger than 1GB will be kept after last update. The default value is 1440, which means the log file is kept for 1440 minutes, i.e., 1 day.\n\n**flushMode** (optional) is an integer indicating whether to enable synchronous disk flush. It can be 0 or 1. The persistence process first writes data from memory to the page cache, then flushes the cached data to disk. If *flushMode* is 0 (default), asynchronous disk flushing is enabled. In this case, once data is written from memory to the page cache, the flush is deemed complete and the next batch of data can be written to the table. If *flushMode* is set to 1, the current batch of data must be flushed to disk before the next batch can be written.\n\n**cachePurgeTimeColumn** (optional) is a STRING scalar indicating the time column in the stream table.\n\n**cachePurgeInterval** (optional) is a DURATION scalar indicating the interval to trigger cache purge.\n\n**cacheRetentionTime** (optional) is a DURATION scalar indicating the retention time of cached data.\n\n#### Details\n\nThis command enables a shared stream table to be persisted to disk.\n\nFor this command to work, we need to specify the configuration parameter *persistenceDir* in the configuration file (*dolohindb.cfg* in standalone mode and *cluster.cfg* in cluster mode). For details of this configuration parameter, see [Standalone Mode](https://docs.dolphindb.com/en/Database/Configuration/StandaloneMode.html). The persistence location of the table is *\\<PERSISTENCE\\_DIR>/\\<TABLE\\_NAME>*. The directory contains 2 types of files: data files (named like *data0.log*, *data1.log*...) and an index file *index.log*. The data that has been persisted to disk will be loaded into memory after the system is restarted.\n\nThe parameter *asynWrite* informs the system whether table persistence is in asynchronous mode. With asynchronous mode, new data are pushed to a queue and persistence workers (threads) will write the data to disk later. With synchronous mode, the table append operation keeps running until new data are persisted to the disk. The default value is true (asynchronous mode). In general, asynchronous mode achieves higher throughput.\n\nWith asynchronous mode, table persistence is conducted by a single persistence worker (thread), and the persistence worker may handle multiple tables. If there is only one table to be persisted, an increase in the number of persistence workers doesn't improve performance.\n\nStream tables keep all data in memory by default. To prevent excessive memory usage, you can clear cached data using either of the following methods:\n\n* Set *cacheSize*that specifies the maximum number of rows to be kept in memory. When the row count reaches the *cacheSize* limit, the system will automatically remove the oldest 50% of rows to free up space.\n\n* Set *cachePurgeTimeColumn*, *cachePurgeInterval* and *cacheRetentionTime.* The system will clear data based on the time column specified by *cachePurgeTimeColumn*. Each time when a new record arrives, the system obtains the time difference between the new record and the oldest record kept in memory. If the time difference exceeds *cachePurgeInterval*, the system will retain only the data with timestamps within *cacheRetentionTime*of the new data, and clear the rest.\n\n**Note:**\n\n* It is recommended to invoke command [fflush](https://docs.dolphindb.com/en/Functions/f/fflush.html) to write data in the page cache to disk before you terminate a DolphinDB process (with `kill -15`) and restart it.\n\n* If asynchronous mode is enabled for data persistence or flush, data loss may occur due to server crash.\n\n#### Examples\n\nExample 1:\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt = streamTable(100:0, colName, colType);\nshare t as st\n\nenableTablePersistence(table=st, cacheSize=1200000)\n```\n\n```\nfor(s in 0:200){\n    n=10000\n    time=2019.01.01T00:00:00.000+s*n+1..n\n    x=rand(10.0, n)\n    insert into st values(time, x)\n}\n```\n\n```\ngetPersistenceMeta(st);\n\n// output\npersistenceDir->/data/ssd/DolphinDBDemo/persistence3/st\nretentionMinutes->1440\nhashValue->0\nasynWrite->true\ndiskOffset->0\nsizeInMemory->800000\ncompress->1\nmemoryOffset->1200000\ntotalSize->2000000\nsizeOnDisk->2000000\n```\n\nPlease note that in this example, we shared a stream table before persisting it with the command `enableTablePersistence`. These 2 operations can be achieved with command [enableTableShareAndPersistence](https://docs.dolphindb.com/en/Functions/e/enableTableShareAndPersistence.html).\n\nExample 2: Illustrate how to use *cachePurgeTimeColumn*, *cachePurgeInterval*, and *cacheRetentionTime*.\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt1 = streamTable(100:0, colName, colType);\nshare t1 as st1\n\nenableTablePersistence(table=st1,cachePurgeTimeColumn = `time, cachePurgeInterval = duration(\"7H\"),cacheRetentionTime = duration(\"2H\"))\ngo;\n\ntime=2019.01.01T00:00:00.000\nfor(s in 0:6000){\n  time = temporalAdd(time,1,\"m\");\n  x=rand(10.0, 1)\n  insert into st1 values(time, x)\n}\n\ngetPersistenceMeta(st1);\n\n//Check the stream table metadata. The tables contains 6000 records in total, and only 300 records are retained in memory after purging the cache.\n\n/* output:\nlastLogSeqNum->-1\nsizeInMemory->300\ntotalSize->6000\nasynWrite->true\ncompress->true\nraftGroup->-1\nmemoryOffset->5700\nretentionMinutes->1440\nsizeOnDisk->5973\npersistenceDir->/home/ffliu/jjxu/DolphinDB_Linux64_V3.0/server/persistence/st1\nhashValue->0\ndiskOffset->0\n*/\n```\n\nRelated commands: [disableTablePersistence](https://docs.dolphindb.com/en/Functions/d/disableTablePersistence.html), [clearTablePersistence](https://docs.dolphindb.com/en/Functions/c/clearTablePersistence.html), [enableTablePersistence](https://docs.dolphindb.com/en/Functions/e/enableTablePersistence.html)\n"
    },
    "enableTableShareAndCachePurge": {
        "url": "https://docs.dolphindb.com/en/Functions/e/enableTableShareAndCachePurge.html",
        "signatures": [
            {
                "full": "enableTableShareAndCachePurge(table, tableName, [cacheSize],[cachePurgeTimeColumn],[cachePurgeInterval],[cacheRetentionTime])",
                "name": "enableTableShareAndCachePurge",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[cacheSize]",
                        "name": "cacheSize",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeTimeColumn]",
                        "name": "cachePurgeTimeColumn",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeInterval]",
                        "name": "cachePurgeInterval",
                        "optional": true
                    },
                    {
                        "full": "[cacheRetentionTime]",
                        "name": "cacheRetentionTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [enableTableShareAndCachePurge](https://docs.dolphindb.com/en/Functions/e/enableTableShareAndCachePurge.html)\n\n#### Syntax\n\nenableTableShareAndCachePurge(table, tableName, \\[cacheSize],\\[cachePurgeTimeColumn],\\[cachePurgeInterval],\\[cacheRetentionTime])\n\n#### Arguments\n\n**table** is an empty stream table.\n\n**tableName** is a string indicating the name of the shared table.\n\n**cacheSize** (optional) is a positive integer used to determine the maximum number of records to retain in memory.\n\n**cachePurgeTimeColumn** (optional) is a STRING scalar indicating the time column in the stream table.\n\n**cachePurgeInterval** (optional) is a DURATION scalar indicating the interval to trigger cache purge.\n\n**cacheRetentionTime** (optional) is a DURATION scalar indicating the retention time of cached data.\n\n#### Details\n\nShare a non-persisted stream table with cache purge.\n\nCache purge can be configured using either of the following methods:\n\n* **Cache purge by size**: Set *cacheSize*to specify a threshold for the number of records retained. Older records exceeding the threshold will be removed. The threshold is determined as follows:\n  * If the number of records appended in one batchdoes not exceed *cacheSize*, the threshold is 2.5 \\* *cacheSize*.\n  * If the number of records appended in one batch exceeds *cacheSize*, the threshold is 1.2 \\* (appended records + *cacheSize*).\n* **Cache purge by time**: Set *cachePurgeTimeColumn*, *cachePurgeInterval* and *cacheRetentionTime.* The system will clean up data based on the *cachePurgeTimeColumn*. Each time when a new record arrives, the system obtains the time difference between the new record and the oldest record kept in memory. If the time difference exceeds *cachePurgeInterval*, the system will retain only the data with timestamps within *cacheRetentionTime*of the new data.\n\n**Note**: If a record has not been enqueued for publishing, it will not be removed.\n\n#### Examples\n\nExample 1. Set *cacheSize*.\n\n```\nt = streamTable(1000:0, `time`sym`volume, [DATETIME, SYMBOL, INT])\nenableTableShareAndCachePurge(table=t, tableName=`st, cacheSize=1000)\ntime = datetime(2024.01.01T09:00:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\n\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n// output: 0\n\ntime = datetime(2024.01.01T09:35:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n// output: 500\n```\n\nExample 2. Set *cachePurgeTimeColumn*, *cachePurgeInterval* and *cacheRetentionTime.*\n\n```\nt = streamTable(1000:0, `time`sym`volume, [DATETIME, SYMBOL, INT])\nenableTableShareAndCachePurge(table=t, tableName=`st, cachePurgeTimeColumn=`time,\n cachePurgeInterval=30m, cacheRetentionTime=20m)\n\ntime = datetime(2024.01.01T09:00:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\n\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n// output: 0\n\ntime = datetime(2024.01.01T09:35:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n// output: 999\n```\n\n"
    },
    "enableTableShareAndPersistence": {
        "url": "https://docs.dolphindb.com/en/Functions/e/enableTableShareAndPersistence.html",
        "signatures": [
            {
                "full": "enableTableShareAndPersistence(table, tableName, [asynWrite=true], [compress=true], [cacheSize], [retentionMinutes=1440], [flushMode=0], [preCache], [cachePurgeTimeColumn], [cachePurgeInterval], [cacheRetentionTime])",
                "name": "enableTableShareAndPersistence",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[asynWrite=true]",
                        "name": "asynWrite",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[compress=true]",
                        "name": "compress",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[cacheSize]",
                        "name": "cacheSize",
                        "optional": true
                    },
                    {
                        "full": "[retentionMinutes=1440]",
                        "name": "retentionMinutes",
                        "optional": true,
                        "default": "1440"
                    },
                    {
                        "full": "[flushMode=0]",
                        "name": "flushMode",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[preCache]",
                        "name": "preCache",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeTimeColumn]",
                        "name": "cachePurgeTimeColumn",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeInterval]",
                        "name": "cachePurgeInterval",
                        "optional": true
                    },
                    {
                        "full": "[cacheRetentionTime]",
                        "name": "cacheRetentionTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [enableTableShareAndPersistence](https://docs.dolphindb.com/en/Functions/e/enableTableShareAndPersistence.html)\n\n\n\n#### Syntax\n\nenableTableShareAndPersistence(table, tableName, \\[asynWrite=true], \\[compress=true], \\[cacheSize], \\[retentionMinutes=1440], \\[flushMode=0], \\[preCache], \\[cachePurgeTimeColumn], \\[cachePurgeInterval], \\[cacheRetentionTime])\n\n#### Arguments\n\n**table** is an empty stream table.\n\n**tableName** is a string indicating the name of the shared table.\n\n**asynWrite** (optional) is a Boolean value indicating whether persistence is enabled in asynchronous mode. The default value is true, meaning asynchronous persistence is enabled. In this case, once data is written into memory, the write is deemed complete. The data stored in memory is then persisted to disk by another thread.\n\n**compress** (optional) is a Boolean value indicating whether to save a table to disk in compression mode. The default value is true.\n\n**cacheSize** (optional) is an integer specifying the maximum number of rows of the table to keep in memory. If not provided, all rows are kept.\n\n* The minimum valid value for this parameter is 1,000.\n\n* If *cacheSize* is greater than 1,000:\n\n  * When each batch of appended data does not exceed *cacheSize*, the data volume in memory will not exceed 1.5 times of *cacheSize*.\n\n  * When a batch exceeds *cacheSize*, the data volume in memory will not exceed 2 times the maximum number of appended rows.\n\n**retentionMinutes** (optional) is an integer indicating for how long (in minutes) a log file larger than 1GB will be kept after last update. The default value is 1440, which means the log file is kept for 1440 minutes, i.e., 1 day.\n\n**flushMode** (optional) is an integer indicating whether to enable synchronous disk flush. It can be 0 or 1. The persistence process first writes data from memory to the page cache, then flushes the cached data to disk. If *flushMode* is 0 (default), asynchronous disk flushing is enabled. In this case, once data is written from memory to the page cache, the flush is deemed complete and the next batch of data can be written to the table. If *flushMode* is set to 1, the current batch of data must be flushed to disk before the next batch can be written.\n\n**preCache** (optional) is an integer indicating the number of records to be loaded into memory from the persisted stream table on disk when DolphinDB restarts. If it is not specified, all records are loaded into memory when DolphinDB restarts.\n\n**cachePurgeTimeColumn** (optional) is a STRING scalar indicating the time column in the stream table.\n\n**cachePurgeInterval** (optional) is a DURATION scalar indicating the interval to trigger cache purge.\n\n**cacheRetentionTime** (optional) is a DURATION scalar indicating the retention time of cached data.\n\n#### Details\n\nShare a stream table, and enable it to be persisted to disk.\n\nFor this command to work, we need to specify the configuration parameter *persistenceDir* in the configuration file (*dolohindb.cfg* in standalone mode and *cluster.cfg* in cluster mode). For details of this configuration parameter, see [Standalone Mode](https://docs.dolphindb.com/en/Database/Configuration/StandaloneMode.html). The persistence location of the table is *\\<PERSISTENCE\\_DIR>/\\<TABLE\\_NAME>*. The directory contains 2 types of files: data files (named like *data0.log*, *data1.log*...) and an index file *index.log*. The data that has been persisted to disk will be loaded into memory after the system is restarted.\n\nThe parameter *asynWrite* informs the system whether table persistence is in asynchronous mode. With asynchronous mode, new data are pushed to a queue and persistence workers (threads) will write the data to disk later. With synchronous mode, the table append operation keeps running until new data are persisted to the disk. The default value is true (asynchronous mode). In general, asynchronous mode achieves higher throughput.\n\nWith asynchronous mode, table persistence is conducted by a single persistence worker (thread), and the persistence worker may handle multiple tables. If there is only one table to be persisted, an increase in the number of persistence workers doesn't improve performance.\n\nStream tables keep all data in memory by default. To prevent excessive memory usage, you can clear cached data using either of the following methods:\n\n* Set *cacheSize*that specifies the maximum number of rows to be kept in memory. When the row count reaches the *cacheSize* limit, the system will automatically remove the oldest 50% of rows to free up space.\n\n* Set *cachePurgeTimeColumn*, *cachePurgeInterval* and *cacheRetentionTime.* The system will clear data based on the time column specified by *cachePurgeTimeColumn*. Each time when a new record arrives, the system obtains the time difference between the new record and the oldest record kept in memory. If the time difference exceeds *cachePurgeInterval*, the system will retain only the data with timestamps within *cacheRetentionTime*of the new data, and clear the rest.\n\n**Note:**\n\n* It is recommended to invoke command [fflush](https://docs.dolphindb.com/en/Functions/f/fflush.html) to write data in the page cache to disk before you terminate a DolphinDB process (with `kill -15`) and restart it.\n\n* If asynWrite is set to true, streaming data is written at the fastest speed and data loss may occur due to server crash.\n\n* If asynWrite is set to false and flushMode to 0, data loss may occur due to operating system crash.\n\n* If asynWrite is set to false and flushMode to 1, the streaming data is written at the slowest speed, and server or operating system crash will not cause data loss.\n\n* It is not allowed to share a stream table multiple times by modifying the shared table name.\n\n#### Examples\n\nExample 1:\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt = streamTable(100:0, colName, colType);\nenableTableShareAndPersistence(table=t, tableName=`st, cacheSize=1200000)\ngo;\n```\n\n```\nfor(s in 0:200){\n    n=10000\n    time=2019.01.01T00:00:00.000+s*n+1..n\n    x=rand(10.0, n)\n    insert into st values(time, x)\n}\n```\n\n```\ngetPersistenceMeta(st);\n\n// output\nsizeInMemory->800000\nasynWrite->true\ntotalSize->2000000\ncompress->true\nmemoryOffset->1200000\nretentionMinutes->1440\nsizeOnDisk->2000000\npersistenceDir->/home/llin/hzy/server1/pst/st\nhashValue->0\ndiskOffset->0\n```\n\nExample 2: Illustrate how to use *cachePurgeTimeColumn*, *cachePurgeInterval*, and *cacheRetentionTime*.\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt1 = streamTable(100:0, colName, colType);\n\nenableTableShareAndPersistence(table=t1,tableName=`st1, cachePurgeTimeColumn=`time, cachePurgeInterval=duration(\"7H\"),cacheRetentionTime=duration(\"2H\"))\n\ngo;\n\ntime=2019.01.01T00:00:00.000\nfor(s in 0:6000){\n  time = temporalAdd(time,1,\"m\");\n  x=rand(10.0, 1)\n  insert into st1 values(time, x)\n}\n\ngetPersistenceMeta(st1);\n/* output:\nlastLogSeqNum->-1\nsizeInMemory->300\ntotalSize->12000\nasynWrite->true\ncompress->true\nraftGroup->-1\nmemoryOffset->11700\nretentionMinutes->1440\nsizeOnDisk->11879\npersistenceDir->/home/ffliu/jjxu/DolphinDB_Linux64_V3.0/server/persistence/st1\nhashValue->0\ndiskOffset->0\n*/\n```\n\nRelated commands: [disableTablePersistence](https://docs.dolphindb.com/en/Functions/d/disableTablePersistence.html), [clearTablePersistence](https://docs.dolphindb.com/en/Functions/c/clearTablePersistence.html), [enableTablePersistence](https://docs.dolphindb.com/en/Functions/e/enableTablePersistence.html)\n"
    },
    "enableTSDBAsyncSorting": {
        "url": "https://docs.dolphindb.com/en/Functions/e/enableTSDBAsyncSorting.html",
        "signatures": [
            {
                "full": "enableTSDBAsyncSorting()",
                "name": "enableTSDBAsyncSorting",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [enableTSDBAsyncSorting](https://docs.dolphindb.com/en/Functions/e/enableTSDBAsyncSorting.html)\n\n\n\n#### Syntax\n\nenableTSDBAsyncSorting()\n\n#### Arguments\n\nNone\n\n#### Details\n\nData written to the TSDB cache engine are sorted by *sortColumns*. The tasks of writing and sorting data can be processed synchronously or asynchronously. Execute the command to enable asynchronous sorting mode. The number of asynchronous threads is specified with configuration parameter *TSDBAsyncSortingWorkerNum*. This command can only be executed by an administrator on a data node. Please make sure the parameter *TSDBAsyncSortingWorkerNum* is configured greater than 0 before executing the command.\n\nIt's recommended to enable asynchronous mode for a TSDB engine on a multi-core processor.\n\nRelated function: [disableTSDBAsyncSorting](https://docs.dolphindb.com/en/Functions/d/disableTSDBAsyncSorting.html)\n"
    },
    "encodeShortGenomeSeq": {
        "url": "https://docs.dolphindb.com/en/Functions/e/encodeShortGenomeSeq.html",
        "signatures": [
            {
                "full": "encodeShortGenomeSeq(X)",
                "name": "encodeShortGenomeSeq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [encodeShortGenomeSeq](https://docs.dolphindb.com/en/Functions/e/encodeShortGenomeSeq.html)\n\n#### Syntax\n\nencodeShortGenomeSeq(X)\n\nAlias: encodeSGS\n\n#### Arguments\n\n`X` is a scalar/vector of STRING/CHAR type.\n\n#### Details\n\n`encodeShortGenomeSeq` encodes DNA sequences made up of A, T, C, G letters. The encoding can reduce the storage space needed for DNA sequences and improve performance.\n\n**Note:**\n\n* When *X* is an empty string (\"\"), the function returns 0.\n\n* When *X* contains any character other than A, T, C, G (case-sensitive), the function returns NULL.\n\n* When the length of *X* exceeds 28 characters, the function returns NULL.\n\n**Return Value**: LONG or FAST LONG vector\n\n#### Examples\n\n```\na=encodeShortGenomeSeq(\"TCGATCG\")\na;\n// output\n465691\ntypestr(a)\n// output\nLONG\n\nb=encodeShortGenomeSeq(\"TCGATCG\" \"TCGATCGCCC\")\n// output\n[465691,168216298]\ntypestr(b)\n// output\nFAST LONG VECTOR\n\n//NULL is returned as the input exceeds 28 characters after \"TCGATCG\" is repeated 5 times.\nencodeShortGenomeSeq(repeat(\"TCGATCG\" \"TCGAT\", 5))\n// output\n[,1801916404867712433]\n\ny=toCharArray(\"TCGATCGCCC\")\nencodeShortGenomeSeq(y)\n// output\n168216298\n\n//NULL is returned in the following cases\nencodeShortGenomeSeq(\"TC G\")\nencodeShortGenomeSeq(\"TCtG\")\nencodeShortGenomeSeq(\"NNNNNNNNTCGGGGCAT\")\nencodeShortGenomeSeq(\"TCGGGGCATNGCCCG\")\nencodeShortGenomeSeq(\"GCCCGATNNNNN\")\n```\n\nRelated functions: [decodeShortGenomeSeq](https://docs.dolphindb.com/en/Functions/d/decodeShortGenomeSeq.html), [genShortGenomeSeq](https://docs.dolphindb.com/en/Functions/g/genShortGenomeSeq.html)\n\n"
    },
    "endsWith": {
        "url": "https://docs.dolphindb.com/en/Functions/e/endsWith.html",
        "signatures": [
            {
                "full": "endsWith(X, str)",
                "name": "endsWith",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "str",
                        "name": "str"
                    }
                ]
            }
        ],
        "markdown": "### [endsWith](https://docs.dolphindb.com/en/Functions/e/endsWith.html)\n\n\n\n#### Syntax\n\nendsWith(X, str)\n\n#### Arguments\n\n**X** is a STRING scalar/vector.\n\n**str** is a STRING scalar.\n\n#### Details\n\nCheck if *X* ends with *str*. If yes, return true; otherwise, return false.\n\n#### Examples\n\n```\nendsWith('ABCDEF!', \"F!\");\n// output\ntrue\n\nendsWith('ABCDEF!', \"E!\");\n// output\nfalse\n```\n"
    },
    "enlist": {
        "url": "https://docs.dolphindb.com/en/Functions/e/enlist.html",
        "signatures": [
            {
                "full": "enlist()",
                "name": "enlist",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [enlist](https://docs.dolphindb.com/en/Functions/e/enlist.html)\n\n\n\n#### Syntax\n\nenlist()\n\n#### Arguments\n\n**X** can be of any data form.\n\n#### Details\n\nReturns a vector or tuple composed of *X*.\n\n* If *X* is a scalar, returns a vector.\n\n* If *X* is a vector, tuple or of other data forms, returns a tuple.\n\n#### Examples\n\n```\nenlist(1)\n// output\n[1]\n\nenlist(`aaa)\n// output\n[\"aaa\"]\n\nenlist([2022.01.01,2022.01.02,2022.01.03])\n// output\n([2022.01.01,2022.01.02,2022.01.03])\n\nenlist([\"a\",2,3])\n// output\n((\"a\",2,3))\n\na = array(INT[], 0, 10).append!([1 2 3, 4 5,6 7 8, 9 NULL])\nenlist(a)\n// output\n([[1,2,3],[4,5],[6,7,8],[9,00i]])\n```\n"
    },
    "eq": {
        "url": "https://docs.dolphindb.com/en/Functions/e/eq.html",
        "signatures": [
            {
                "full": "eq(X, Y)",
                "name": "eq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [eq](https://docs.dolphindb.com/en/Functions/e/eq.html)\n\n\n\n#### Syntax\n\neq(X, Y)\n\nor\n\nX==Y\n\n#### Arguments\n\n**X** / **Y** is a scalar/pair/vector/matrix/set. If *X* or *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nIf neither *X* nor *Y* is a set, return the element-by-element comparison of *X* and *Y*.\n\nIf *X* and *Y* are sets, check if *X* and *Y* are identical.\n\n#### Examples\n\n```\n1 2 3 == 2;\n// output\n[0,1,0]\n\n1 2 3==0 2 4;\n// output\n[0,1,0]\n\n1:2==1:6;\n// output\n1 : 0\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 == 4;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 0  | 0  |\n| 0  | 1  | 0  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1==m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 0  | 0  |\n| 0  | 0  | 0  |\n\nSet operation: If *X*==*Y* then *X* and *Y* are identical.\n\n```\nx=set(4 6)\ny=set(4 6 8);\n\nx==y;\n// output\nfalse\nx==x;\n// output\ntrue\n```\n"
    },
    "eqFloat": {
        "url": "https://docs.dolphindb.com/en/Functions/e/eqFloat.html",
        "signatures": [
            {
                "full": "eqFloat(X, Y, [precision=9])",
                "name": "eqFloat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[precision=9]",
                        "name": "precision",
                        "optional": true,
                        "default": "9"
                    }
                ]
            }
        ],
        "markdown": "### [eqFloat](https://docs.dolphindb.com/en/Functions/e/eqFloat.html)\n\n\n\n#### Syntax\n\neqFloat(X, Y, \\[precision=9])\n\n#### Arguments\n\n**X** / **Y** is a numeric scalar/vector/matrix. If *X* or *Y* is a vector/matrix, the other is a scalar or a vector/matrix of the same size.\n\n**precision** is a non-negative integer. FLOAT and DOUBLE types are compared up to precision digits after the decimal point.\n\n#### Details\n\nReturn the element-by-element comparison of *X* and *Y* with the given precision.\n\n#### Examples\n\n```\neqFloat(0.1234567891, 0.123456789);\n// output\ntrue\n\neqFloat(0.123456788, 0.123456789);\n// output\nfalse\n\neqFloat(0.123456788 0.123456789 0.1234567891, 0.123456789);\n// output\n[false,true,true]\n```\n"
    },
    "eqObj": {
        "url": "https://docs.dolphindb.com/en/Functions/e/eqObj.html",
        "signatures": [
            {
                "full": "eqObj(obj1, obj2, [precision])",
                "name": "eqObj",
                "parameters": [
                    {
                        "full": "obj1",
                        "name": "obj1"
                    },
                    {
                        "full": "obj2",
                        "name": "obj2"
                    },
                    {
                        "full": "[precision]",
                        "name": "precision",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [eqObj](https://docs.dolphindb.com/en/Functions/e/eqObj.html)\n\n\n\n#### Syntax\n\neqObj(obj1, obj2, \\[precision])\n\n#### Arguments\n\n**obj1** / **obj2** is a scalar/pair/vector/matrix.\n\n**precision** (optional) is a non-negative integer. FLOAT and DOUBLE types are compared up to precision digits after the decimal point.\n\n#### Details\n\nCheck if the data types and values of two objects are identical. Return true only if both data types and values are identical. Please note that `eqObj` returns false if values are identical but object types are different. This is different from fuction [eq](https://docs.dolphindb.com/en/Functions/e/eq.html).\n\nWhen comparing floating point numbers, function `eqObj` determines whether the values of *obj1* and *obj2* are equal based on the result of `abs(obj1-obj2)<=pow(10,-precision)`.\n\n#### Examples\n\n```\neqObj(2, 2.0);\n// output: false\n\neq(2, 2.0);\n// output: true\n\neqObj(1.1, 1.2, 0);\n// output: true\n\neqObj(1.1, 1.2, 1);\n// output: true\n\neqObj(1 2 3, 1 2 3);\n// output: true\n\neq(1 2 3, 1 2 3);\n// output: [true,true,true]\n```\n\n`eqObj` cannot be used to compare 2 tables directly. However, we can use the template function [each](https://docs.dolphindb.com/en/Functions/Templates/each.html) to compare the values of each column for 2 tables:\n\n```\nt1=table(1 2 3 as x, 4 5 6 as y);\nt2=table(1 2 3 as x, 4 5 6 as y);\n\nt1.values();\n// output: ([1,2,3],[4,5,6])\n\neach(eqObj, t1.values(), t2.values());\n// output: [true,true]\n```\n"
    },
    "eqPercent": {
        "url": "https://docs.dolphindb.com/en/Functions/e/eqPercent.html",
        "signatures": [
            {
                "full": "eqPercent(X, Y, [toleranceLevel=0.0001])",
                "name": "eqPercent",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[toleranceLevel=0.0001]",
                        "name": "toleranceLevel",
                        "optional": true,
                        "default": "0.0001"
                    }
                ]
            }
        ],
        "markdown": "### [eqPercent](https://docs.dolphindb.com/en/Functions/e/eqPercent.html)\n\n\n\n#### Syntax\n\neqPercent(X, Y, \\[toleranceLevel=0.0001])\n\n#### Arguments\n\n* **X** / **Y** are two numbers to compare. They must be scalars, vectors, pairs, or matrices of the same shape. Supported data types include BOOL, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE, DECIMAL. Note: *X* and *Y* must be of the same form, and elements in *X* and *Y* can be of different data types.\n* **toleranceLevel** (optional) is a number in (0, 100), representing the tolerable percentage error. The default value is 0.0001. This means the absolute difference between the two elements must not exceed the *toleranceLevel*percentage of the absolute value of *Y*. For example, if *Y* is 1000 and *toleranceLevel*is 0.0001, the allowable error is 1000 \\* 0.0001% = 0.001. Thus, an *X* value between \\[999.999, 1000.001] will be considered equal to *Y*.\n\n#### Details\n\nCheck element-wise equality of two inputs *X* and *Y* are equal within the specified *toleranceLevel*.\n\n**Return Value**: A Boolean scalar\n\nNote:\n\n* If the type of the input *X* or *Y* is not supported, the function returns the result of `eqObj(X, Y).`\n\n* NULL values are not equal to other values.\n\n* NULL values of different types are considered equal.\n\n#### Examples\n\n```\neqPercent((1.9999 2.9999), (2 3))\n// Output: true\n\neqPercent((1.9 2.9), (2 3), 2)\n// Output: false\n```\n\nElements in *X* and *Y* can be of different data types:\n\n```\neqPercent((1.99f 2.99), (2 3h), 2)\n// Output: true\n```\n\nWhen comparing NULL values:\n\n```\n// NULL values are not equal to other values\neqPercent((1.9999 NULL), (2 3))\n// Output: false\n\n// NULL values of DOUBLE and VOID types are considered equal\na=double(NULL)\neqPercent(a,NULL)\n// Output: true\n```\n\nWhen an unsupported type is passed, the function returns the result of `eqObj(X, Y)`:\n\n```\neqPercent(2012.06M, 2)\n// Output: false\n```\n"
    },
    "erase!": {
        "url": "https://docs.dolphindb.com/en/Functions/e/erase!.html",
        "signatures": [
            {
                "full": "erase!(obj, key|filter)",
                "name": "erase!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "key|filter",
                        "name": "key|filter"
                    }
                ]
            }
        ],
        "markdown": "### [erase!](https://docs.dolphindb.com/en/Functions/e/erase!.html)\n\n\n\n#### Syntax\n\nerase!(obj, key|filter)\n\n#### Arguments\n\n**obj** is a set/dictionary/table.\n\n**key** | **filter** is the elements to be deleted for a set; the keys of the members to be deleted for a dictionary; a piece of meta code with filtering conditions for a table. For details about meta code, please refer to [Metaprogramming](https://docs.dolphindb.com/en/Programming/Metaprogramming/functional_meta.html).\n\n#### Details\n\nEliminate elements from a set, or members from a dictionary, or rows from a table.\n\n#### Examples\n\nOn a set:\n\n```\ny=set(8 9 4 6);\ny;\n// output\nset(6,4,9,8)\ny.erase!(6);\n// output\nset(4,9,8)\nerase!(y, 9 8);\n// output\nset(4)\n```\n\nOn a dictionary:\n\n```\nx=1..6;\ny=11..16;\nz=dict(x,y);\nz;\n// output\n6->16\n5->15\n4->14\n3->13\n2->12\n1->11\n\nerase!(z, 1..4);\n// output\n6->16\n5->15\n```\n\nOn a table:\n\n```\nx=1..10;\ny=11..20;\nt=table(x,y);\n\nerase!(t, <x<=3>);\n```\n\n| x  | y  |\n| -- | -- |\n| 4  | 14 |\n| 5  | 15 |\n| 6  | 16 |\n| 7  | 17 |\n| 8  | 18 |\n| 9  | 19 |\n| 10 | 20 |\n\n```\nerase!(t, <x<=9 and y>=15>);\n```\n\n| x  | y  |\n| -- | -- |\n| 4  | 14 |\n| 10 | 20 |\n"
    },
    "esd": {
        "url": "https://docs.dolphindb.com/en/Functions/e/esd.html",
        "signatures": [
            {
                "full": "esd(data, [hybrid], [maxAnomalies], [alpha])",
                "name": "esd",
                "parameters": [
                    {
                        "full": "data",
                        "name": "data"
                    },
                    {
                        "full": "[hybrid]",
                        "name": "hybrid",
                        "optional": true
                    },
                    {
                        "full": "[maxAnomalies]",
                        "name": "maxAnomalies",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [esd](https://docs.dolphindb.com/en/Functions/e/esd.html)\n\n\n\n#### Syntax\n\nesd(data, \\[hybrid], \\[maxAnomalies], \\[alpha])\n\n#### Arguments\n\n**data** is a numeric vector.\n\n**hybrid** (optional) is a Boolean value indicating whether to use median and median absolute deviation to replace mean and standard deviation. The results are more robust if *hybrid*=true. The default value is false.\n\n**maxAnomalies** (optional) is a positive integer or a floating-point number between 0 and 0.5. The default value is 0.1.\n\n* If *maxAnomalies* is a positive integer, it must be smaller than the size of data. It indicates the upper bound of the number of anomalies.\n\n* If *maxAnomalies* is a floating-point number between 0 and 0.5, the upper bound of the number of anomalies is `int(size(data) * maxAnomalies)`.\n\n**alpha** (optional) is a positive number indicating the significance level of the statistical test. A larger *alpha* means a higher likelihood of detecting anomalies.\n\n#### Details\n\nConduct anomaly detection with the Extreme Studentized Deviate test (ESD).\n\n**Return value**: a table with 2 columns where column index records the subscript of anomalies in data and column anoms are the anomaly values.\n\n#### Examples\n\n```\nn = 1000\nts = rand(10.0, n)\nts[500 600 700 999] += 20\nesd(ts);\n```\n\n| index | anoms     |\n| ----- | --------- |\n| 600   | 29.815742 |\n| 700   | 25.517493 |\n| 500   | 25.17515  |\n| 999   | 24.748516 |\n"
    },
    "euclidean": {
        "url": "https://docs.dolphindb.com/en/Functions/e/euclidean.html",
        "signatures": [
            {
                "full": "euclidean(X, Y)",
                "name": "euclidean",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [euclidean](https://docs.dolphindb.com/en/Functions/e/euclidean.html)\n\n\n\n#### Syntax\n\neuclidean(X, Y)\n\n#### Arguments\n\n**X** and **Y** are numeric scalars, or vectors/matrices of the same size.\n\n#### Details\n\nIf *X* and *Y* are scalars or vectors, return the result of their Euclidean distance.\n\nIf *X* or *Y* is a matrix, return a vector that is the result of the Euclidean distance between elements in each column. Note that if both *X* and *Y* are indexed matrices or indexed series, return the results of rows with the same label. Rows with different labels will be ignored.\n\nAs with all other aggregate functions, NULL values are ignored in the calculation.\n\n#### Examples\n\n```\na=[100, 0, 0]\nb=[0, 51, NULL]\neuclidean(a,b)\n// output\n112.254176\n\ns1=indexedSeries(1 2 4, 10.4 11.2 9)\ns2=indexedSeries(1 2 5, 23.5 31.2 26)\neuclidean(s1,s2)\n// output\n23.9084\n\nm=matrix(23 56 47, 112 94 59)\neuclidean(a,m)\n// output\n[106.1791,111.6288]\n\nm1=matrix(11 15 89, 52 41 63)\neuclidean(m,m1)\n// output\n[59.9083,80.1561]\n\nm.rename!(2020.01.01..2020.01.03, `A`B)\nm.setIndexedMatrix!()\nm1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\nm1.setIndexedMatrix!()\neuclidean(m,m1)\n// output\n[34.176,62.6418]\n```\n\nRelated function: [rowEuclidean](https://docs.dolphindb.com/en/Functions/r/rowEuclidean.html)\n"
    },
    "eval": {
        "url": "https://docs.dolphindb.com/en/Functions/e/eval.html",
        "signatures": [
            {
                "full": "eval(X)",
                "name": "eval",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [eval](https://docs.dolphindb.com/en/Functions/e/eval.html)\n\n\n\n#### Syntax\n\neval(X)\n\n#### Arguments\n\n**X** is metacode.\n\n#### Details\n\nEvaluate the given metacode.\n\n#### Examples\n\n```\neval(<1+2>);\n// output\n3\n\neval(<1+2+3=10>);\n// output\n0\n\neval(expr(6,<,8));\n// output\n1\n\neval(expr(sum, 1 2 3));\n// output\n6\n\na=6; b=9;\neval(expr(<a>,+,<b>));\n// output\n15\n```\n"
    },
    "evalTimer": {
        "url": "https://docs.dolphindb.com/en/Functions/e/evalTimer.html",
        "signatures": [
            {
                "full": "evalTimer(funcs, [count=1])",
                "name": "evalTimer",
                "parameters": [
                    {
                        "full": "funcs",
                        "name": "funcs"
                    },
                    {
                        "full": "[count=1]",
                        "name": "count",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [evalTimer](https://docs.dolphindb.com/en/Functions/e/evalTimer.html)\n\n\n\n#### Syntax\n\nevalTimer(funcs, \\[count=1])\n\n#### Arguments\n\n**funcs** is a function or a tuple of functions with no parameters.\n\n**count** (optional) is a positive number indicating the number of times funcs will be executed. The default value is 1.\n\n#### Details\n\nReturn the execution time of the specified functions in units of milliseconds. If *funcs* is a tuple of functions, return the amount of time to execute these functions consecutively.\n\nThe difference between statement [timer](https://docs.dolphindb.com/en/Programming/ProgrammingStatements/timer.html) and function `evalTimer`:\n\n* the input of `timer` is a statement block while the input of `evalTimer` can only be functions. To use `evalTimer` to get execution time of a statement block, we need to rewrite the statement block as a user-defined function.\n\n* `timer` returns a message which cannot be assigned to a variable; `evalTimer` returns a scalar that can be assigned to a variable.\n\n#### Examples\n\n```\nx=rand(10.0, 1000000)\nevalTimer(dot{x,2},10);\n// output\n39.609375\n\nevalTimer(sort{x},10);\n// output\n837.542702\n\nevalTimer([dot{x,2},sort{x}],10)\n// output\n870.065348\n```\n"
    },
    "ewmCorr": {
        "url": "https://docs.dolphindb.com/en/Functions/e/ewmCorr.html",
        "signatures": [
            {
                "full": "ewmCorr(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [other], [bias=false])",
                "name": "ewmCorr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[com]",
                        "name": "com",
                        "optional": true
                    },
                    {
                        "full": "[span]",
                        "name": "span",
                        "optional": true
                    },
                    {
                        "full": "[halfLife]",
                        "name": "halfLife",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    },
                    {
                        "full": "[minPeriods=0]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[adjust=true]",
                        "name": "adjust",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=false]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[other]",
                        "name": "other",
                        "optional": true
                    },
                    {
                        "full": "[bias=false]",
                        "name": "bias",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [ewmCorr](https://docs.dolphindb.com/en/Functions/e/ewmCorr.html)\n\n\n\n#### Syntax\n\newmCorr(X, \\[com], \\[span], \\[halfLife], \\[alpha], \\[minPeriods=0], \\[adjust=true], \\[ignoreNA=false], \\[other], \\[bias=false])\n\n#### Details\n\nCalculate exponentially weighted moving correlation of *X* and *other*.\n\nExactly one of the parameters *com*, *span*, *halfLife* and *alpha* must be specified.\n\n#### Arguments\n\n**X** is a numeric vector.\n\n**com** (optional) is a non-negative floating number and specifies decay in terms of center of mass. alpha=1/(1+com) where alpha is the decay factor.\n\n**span** (optional) is a positive floating number larger than 1 and specifies decay in terms of span. alpha=2/(span+1).\n\n**halfLife** (optional) is a positive floating number and specifies decay in terms of half-life. alpha=1-exp(log(0.5)/halfLife).\n\n**alpha** (optional) is a floating number between 0 and 1 and directly specifies decay.\n\n**minPeriods** (optional) is an integer indicating the minimum number of observations in window required to have a value (otherwise result is NULL). The default value is 0.\n\n**adjust** (optional) is a Boolean value. The default value is true.\n\n* If *adjust*=true, the weights are (1-alpha)^(n-1), (1-alpha)^(n-2), …, 1-alpha, 1 divided by their sum.\n\n* If *adjust*=false, the weights are (1-alpha)^(n-1), (1-alpha)^(n-2)\\*alpha, (1-alpha)^(n-3)\\*alpha^2,…, (1-alpha)\\*alpha, alpha.\n\n**ignoreNA** (optional) is a Boolean value indicating whether to ignore missing values. The defaut value is false.\n\n**other** (optional) is a numeric vector of the same length as *X*.\n\n**bias** (optional) is a Boolean value indicating whether the result is biased. The default value is false, meaning the bias is corrected.\n\n#### Examples\n\n```\na=[0,1,2,int(),4]\nb=[2,4,3,6,5]\newmCorr(X=a,other=b,com=0.5);\n# output\n[,1.0000,-0.0533,-0.0533,0.9146]\n\newmCorr(X=a,other=b,com=0.5,ignoreNA=true);\n# output\n[,1.0000,-0.0533,-0.0533,0.8934]\n\nn = 20\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt1 = table(n:0, colNames, colTypes)\ninsert into t1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into t1 values(09:30:00.001,`AAPL,200,30.5)\ninsert into t1 values(09:30:00.001,`DELL,150,35.5)\ninsert into t1 values(09:30:00.001,`DELL,170,60.5)\ninsert into t1 values(09:30:00.001,`DELL,130,40.5)\nb=[2,4,3,6,5]\newmCorr(X=t1,other=b,com=0.5);\n```\n\n<table id=\"table_bnp_rxm_hzb\"><tbody><tr><td id=\"example_table_cgw_thn_ryb_entry_1\" align=\"left\">\n\ntime\n\n</td><td id=\"example_table_cgw_thn_ryb_entry_2\" align=\"left\">\n\nsym\n\n</td><td id=\"example_table_cgw_thn_ryb_entry_3\" align=\"left\">\n\nqty\n\n</td><td id=\"example_table_cgw_thn_ryb_entry_4\" align=\"left\">\n\nprice\n\n</td></tr><tr><td align=\"left\">\n\n09:30:00.001\n\n</td><td align=\"left\">\n\nAAPL\n\n</td><td align=\"left\">\n\n \n\n</td><td align=\"left\">\n\n \n\n</td></tr><tr><td align=\"left\">\n\n09:30:00.001\n\n</td><td align=\"left\">\n\nAAPL\n\n</td><td align=\"left\">\n\n1.0000\n\n</td><td align=\"left\">\n\n-1.0000\n\n</td></tr><tr><td align=\"left\">\n\n09:30:00.001\n\n</td><td align=\"left\">\n\nDELL\n\n</td><td align=\"left\">\n\n1.0000\n\n</td><td align=\"left\">\n\n-0.8481\n\n</td></tr><tr><td align=\"left\">\n\n09:30:00.001\n\n</td><td align=\"left\">\n\nDELL\n\n</td><td align=\"left\">\n\n0.5536\n\n</td><td align=\"left\">\n\n0.8747\n\n</td></tr><tr><td align=\"left\">\n\n09:30:00.001\n\n</td><td align=\"left\">\n\nDELL\n\n</td><td align=\"left\">\n\n0.3064\n\n</td><td align=\"left\">\n\n0.7050\n\n</td></tr></tbody>\n</table>\n"
    },
    "ewmCov": {
        "url": "https://docs.dolphindb.com/en/Functions/e/ewmCov.html",
        "signatures": [
            {
                "full": "ewmCov(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [other], [bias=false])",
                "name": "ewmCov",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[com]",
                        "name": "com",
                        "optional": true
                    },
                    {
                        "full": "[span]",
                        "name": "span",
                        "optional": true
                    },
                    {
                        "full": "[halfLife]",
                        "name": "halfLife",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    },
                    {
                        "full": "[minPeriods=0]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[adjust=true]",
                        "name": "adjust",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=false]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[other]",
                        "name": "other",
                        "optional": true
                    },
                    {
                        "full": "[bias=false]",
                        "name": "bias",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [ewmCov](https://docs.dolphindb.com/en/Functions/e/ewmCov.html)\n\n\n\n#### Syntax\n\newmCov(X, \\[com], \\[span], \\[halfLife], \\[alpha], \\[minPeriods=0], \\[adjust=true], \\[ignoreNA=false], \\[other], \\[bias=false])\n\n#### Details\n\nCalculate exponentially weighted moving covariance of *X* and *other*.\n\nExactly one of the parameters *com*, *span*, *halfLife* and *alpha* must be specified.\n\n#### Arguments\n\n**X** is a numeric vector.\n\n**com** (optional) is a non-negative floating number and specifies decay in terms of center of mass. alpha=1/(1+com) where alpha is the decay factor.\n\n**span** (optional) is a positive floating number larger than 1 and specifies decay in terms of span. alpha=2/(span+1).\n\n**halfLife** (optional) is a positive floating number and specifies decay in terms of half-life. alpha=1-exp(log(0.5)/halfLife).\n\n**alpha** (optional) is a floating number between 0 and 1 and directly specifies decay.\n\n**minPeriods** (optional) is an integer indicating the minimum number of observations in window required to have a value (otherwise result is NULL). The default value is 0.\n\n**adjust** (optional) is a Boolean value. The default value is true.\n\n* If *adjust*=true, the weights are (1-alpha)^(n-1), (1-alpha)^(n-2), …, 1-alpha, 1 divided by their sum.\n\n* If *adjust*=false, the weights are (1-alpha)^(n-1), (1-alpha)^(n-2)\\*alpha, (1-alpha)^(n-3)\\*alpha^2,…, (1-alpha)\\*alpha, alpha.\n\n**ignoreNA** (optional) is a Boolean value indicating whether to ignore missing values. The defaut value is false.\n\n**other** (optional) is a numeric vector of the same length as *X*.\n\n**bias** (optional) is a Boolean value indicating whether the result is biased. The default value is false, meaning the bias is corrected.\n\n#### Examples\n\n```\na=[0,1,2,int(),4]\nb=[2,4,3,6,5]\newmCov(X=a,other=b,com=0.5);\n// output\n[,1,-0.038462,-0.038462,2.112637]\n\newmCov(X=a,other=b,com=0.5,ignoreNA=true);\n// output\n[,1,-0.038462,-0.038462,1.969231]\n\nn = 20\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt1 = table(n:0, colNames, colTypes)\ninsert into t1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into t1 values(09:30:00.001,`AAPL,200,30.5)\ninsert into t1 values(09:30:00.001,`DELL,150,35.5)\ninsert into t1 values(09:30:00.001,`DELL,170,60.5)\ninsert into t1 values(09:30:00.001,`DELL,130,40.5)\nb=[2,4,3,6,5]\newmCov(X=t1,other=b,com=0.5);\n```\n\n| time         | sym  | qty     | price   |\n| ------------ | ---- | ------- | ------- |\n| 09:30:00.001 | AAPL |         |         |\n| 09:30:00.001 | AAPL | 100     | -26     |\n| 09:30:00.001 | DELL | 30.7692 | -6.1538 |\n| 09:30:00.001 | DELL | 25.2308 | 29.5346 |\n| 09:30:00.001 | DELL | 9.405   | 10.0012 |\n"
    },
    "ewmMean": {
        "url": "https://docs.dolphindb.com/en/Functions/e/ewmMean.html",
        "signatures": [
            {
                "full": "ewmMean(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false])",
                "name": "ewmMean",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[com]",
                        "name": "com",
                        "optional": true
                    },
                    {
                        "full": "[span]",
                        "name": "span",
                        "optional": true
                    },
                    {
                        "full": "[halfLife]",
                        "name": "halfLife",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    },
                    {
                        "full": "[minPeriods=0]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[adjust=true]",
                        "name": "adjust",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=false]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [ewmMean](https://docs.dolphindb.com/en/Functions/e/ewmMean.html)\n\n\n\n#### Syntax\n\newmMean(X, \\[com], \\[span], \\[halfLife], \\[alpha], \\[minPeriods=0], \\[adjust=true], \\[ignoreNA=false])\n\n#### Details\n\nCalculate exponentially weighted moving average.\n\nExactly one of the parameters *com*, *span*, *halfLife* and *alpha* must be specified.\n\n#### Arguments\n\n**X** is a numeric vector.\n\n**com** (optional) is a non-negative floating number and specifies decay in terms of center of mass. alpha=1/(1+com) where alpha is the decay factor.\n\n**span** (optional) is a positive floating number larger than 1 and specifies decay in terms of span. alpha=2/(span+1).\n\n**halfLife** (optional) is a positive floating number and specifies decay in terms of half-life. alpha=1-exp(log(0.5)/halfLife).\n\n**alpha** (optional) is a floating number between 0 and 1 and directly specifies decay.\n\n**minPeriods** (optional) is an integer indicating the minimum number of observations in window required to have a value (otherwise result is NULL). The default value is 0.\n\n**adjust** (optional) is a Boolean value. The default value is true.\n\n* If *adjust*=true, the weights are (1-alpha)^(n-1), (1-alpha)^(n-2), …, 1-alpha, 1 divided by their sum.\n\n* If *adjust*=false, the weights are (1-alpha)^(n-1), (1-alpha)^(n-2)\\*alpha, (1-alpha)^(n-3)\\*alpha^2,…, (1-alpha)\\*alpha, alpha.\n\n**ignoreNA** (optional) is a Boolean value indicating whether to ignore NULL values when calculating weights. The default value is false.\n\nTake \\[x0, NULL, x2] for example,\n\n* If *ignoreNA* = true,\n\n  * *adjust* = false, the weights of x0 and x2 are 1-α and α.\n\n  * *adjust* = true, the weights of x0 and x2 are 1-α and 1.\n\n* If *ignoreNA* = false,\n\n  * *adjust* = false, the weights of x0 and x2 are (1-α)2 and α.\n\n  * *adjust* = true, the weights of x0 and x2 are (1-α)2 and 1.\n\n#### Examples\n\n```\na=[0,1,2,int(),4]\newmMean(X=a,com=0.5);\n// output\n[0,0.75,1.615385,1.615385,3.670213]\n\newmMean(X=a,com=0.5,ignoreNA=true);\n// output\n[0,0.75,1.615385,1.615385,3.225]\n\nn = 20\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt1 = table(n:0, colNames, colTypes)\ninsert into t1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into t1 values(09:30:00.001,`AAPL,200,30.5)\ninsert into t1 values(09:30:00.001,`DELL,150,35.5)\ninsert into t1 values(09:30:00.001,`DELL,170,60.5)\ninsert into t1 values(09:30:00.001,`DELL,130,40.5)\nb=[2,4,3,6,5]\newmMean(X=t1,com=0.5);\n```\n\n| time         | sym  | qty      | price   |\n| ------------ | ---- | -------- | ------- |\n| 09:30:00.001 | AAPL | 100      | 56.5    |\n| 09:30:00.001 | AAPL | 175      | 37      |\n| 09:30:00.001 | DELL | 157.6923 | 35.9615 |\n| 09:30:00.001 | DELL | 166      | 52.525  |\n| 09:30:00.001 | DELL | 141.9008 | 44.4752 |\n"
    },
    "ewmStd": {
        "url": "https://docs.dolphindb.com/en/Functions/e/ewmStd.html",
        "signatures": [
            {
                "full": "ewmStd(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [bias=false])",
                "name": "ewmStd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[com]",
                        "name": "com",
                        "optional": true
                    },
                    {
                        "full": "[span]",
                        "name": "span",
                        "optional": true
                    },
                    {
                        "full": "[halfLife]",
                        "name": "halfLife",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    },
                    {
                        "full": "[minPeriods=0]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[adjust=true]",
                        "name": "adjust",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=false]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[bias=false]",
                        "name": "bias",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [ewmStd](https://docs.dolphindb.com/en/Functions/e/ewmStd.html)\n\n\n\n#### Syntax\n\newmStd(X, \\[com], \\[span], \\[halfLife], \\[alpha], \\[minPeriods=0], \\[adjust=true], \\[ignoreNA=false], \\[bias=false])\n\n#### Details\n\nCalculate exponentially weighted moving standard deviation.\n\nExactly one of the parameters *com*, *span*, *halfLife* and *alpha* must be specified.\n\n#### Arguments\n\n**X** is a numeric vector.\n\n**com** (optional) is a non-negative floating number and specifies decay in terms of center of mass. alpha=1/(1+com) where alpha is the decay factor.\n\n**span** (optional) is a positive floating number larger than 1 and specifies decay in terms of span. alpha=2/(span+1).\n\n**halfLife** (optional) is a positive floating number and specifies decay in terms of half-life. alpha=1-exp(log(0.5)/halfLife).\n\n**alpha** (optional) is a floating number between 0 and 1 and directly specifies decay.\n\n**minPeriods** (optional) is an integer indicating the minimum number of observations in window required to have a value (otherwise result is NULL). The default value is 0.\n\n**adjust** (optional) is a Boolean value. The default value is true.\n\n* If *adjust*=true, the weights are (1-alpha)^(n-1), (1-alpha)^(n-2), …, 1-alpha, 1 divided by their sum.\n\n* If *adjust*=false, the weights are (1-alpha)^(n-1), (1-alpha)^(n-2)\\*alpha, (1-alpha)^(n-3)\\*alpha^2,…, (1-alpha)\\*alpha, alpha.\n\n**ignoreNA** (optional) is a Boolean value indicating whether to ignore missing values. The defaut value is false.\n\n**other** (optional) is a numeric vector of the same length as *X*.\n\n**bias** (optional) is a Boolean value indicating whether the result is biased. The default value is false, meaning the bias is corrected.\n\n#### Examples\n\n```language-python\na=[0,1,2,int(),4]\newmStd(X=a,com=0.5);\n// output\n[,0.707107,0.919866,0.919866,1.720513]\n\newmStd(X=a,com=0.5,ignoreNA=true);\n// output\n[,0.707107,0.919866,0.919866,1.679057]\n\nn = 20\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt1 = table(n:0, colNames, colTypes)\ninsert into t1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into t1 values(09:30:00.001,`AAPL,200,30.5)\ninsert into t1 values(09:30:00.001,`DELL,150,35.5)\ninsert into t1 values(09:30:00.001,`DELL,170,60.5)\ninsert into t1 values(09:30:00.001,`DELL,130,40.5)\nb=[2,4,3,6,5]\newmStd(X=t1,com=0.5);\n```\n\n| time         | sym  | qty     | price   |\n| ------------ | ---- | ------- | ------- |\n| 09:30:00.001 | AAPL |         |         |\n| 09:30:00.001 | AAPL | 70.7107 | 18.3848 |\n| 09:30:00.001 | DELL | 39.2232 | 9.2487  |\n| 09:30:00.001 | DELL | 23.271  | 17.2418 |\n| 09:30:00.001 | DELL | 27.466  | 12.6944 |\n"
    },
    "ewmVar": {
        "url": "https://docs.dolphindb.com/en/Functions/e/ewmVar.html",
        "signatures": [
            {
                "full": "ewmVar(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [bias=false])",
                "name": "ewmVar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[com]",
                        "name": "com",
                        "optional": true
                    },
                    {
                        "full": "[span]",
                        "name": "span",
                        "optional": true
                    },
                    {
                        "full": "[halfLife]",
                        "name": "halfLife",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    },
                    {
                        "full": "[minPeriods=0]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[adjust=true]",
                        "name": "adjust",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=false]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[bias=false]",
                        "name": "bias",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [ewmVar](https://docs.dolphindb.com/en/Functions/e/ewmVar.html)\n\n\n\n#### Syntax\n\newmVar(X, \\[com], \\[span], \\[halfLife], \\[alpha], \\[minPeriods=0], \\[adjust=true], \\[ignoreNA=false], \\[bias=false])\n\n#### Details\n\nCalculate exponentially weighted moving variance.\n\nExactly one of the parameters *com*, *span*, *halfLife* and *alpha* must be specified.\n\n#### Arguments\n\n**X** is a numeric vector.\n\n**com** (optional) is a non-negative floating number and specifies decay in terms of center of mass. alpha=1/(1+com) where alpha is the decay factor.\n\n**span** (optional) is a positive floating number larger than 1 and specifies decay in terms of span. alpha=2/(span+1).\n\n**halfLife** (optional) is a positive floating number and specifies decay in terms of half-life. alpha=1-exp(log(0.5)/halfLife).\n\n**alpha** (optional) is a floating number between 0 and 1 and directly specifies decay.\n\n**minPeriods** (optional) is an integer indicating the minimum number of observations in window required to have a value (otherwise result is NULL). The default value is 0.\n\n**adjust** (optional) is a Boolean value. The default value is true.\n\n* If *adjust*=true, the weights are (1-alpha)^(n-1), (1-alpha)^(n-2), …, 1-alpha, 1 divided by their sum.\n\n* If *adjust*=false, the weights are (1-alpha)^(n-1), (1-alpha)^(n-2)\\*alpha, (1-alpha)^(n-3)\\*alpha^2,…, (1-alpha)\\*alpha, alpha.\n\n**ignoreNA** (optional) is a Boolean value indicating whether to ignore missing values. The defaut value is false.\n\n**other** (optional) is a numeric vector of the same length as *X*.\n\n**bias** (optional) is a Boolean value indicating whether the result is biased. The default value is false, meaning the bias is corrected.\n\n#### Examples\n\n```\na=[0,1,2,int(),4]\newmVar(X=a,com=0.5);\n// output\n[,0.5,0.846154,0.846154,2.960165]\n\newmVar(X=a,com=0.5,ignoreNA=true);\n// output\n[,0.5,0.846154,0.846154,2.819231]\n\nn = 20\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt1 = table(n:0, colNames, colTypes)\ninsert into t1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into t1 values(09:30:00.001,`AAPL,200,30.5)\ninsert into t1 values(09:30:00.001,`DELL,150,35.5)\ninsert into t1 values(09:30:00.001,`DELL,170,60.5)\ninsert into t1 values(09:30:00.001,`DELL,130,40.5)\nb=[2,4,3,6,5]\newmVar(X=t1,com=0.5);\n```\n\n<table id=\"table_jjk_lym_hzb\"><tbody><tr><td>\n\ntime\n\n</td><td>\n\nsym\n\n</td><td>\n\nqty\n\n</td><td>\n\nprice\n\n</td></tr><tr><td>\n\n30:00.0\n\n</td><td>\n\nAAPL\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n30:00.0\n\n</td><td>\n\nAAPL\n\n</td><td>\n\n5,000\n\n</td><td>\n\n338\n\n</td></tr><tr><td>\n\n30:00.0\n\n</td><td>\n\nDELL\n\n</td><td>\n\n1,538.46\n\n</td><td>\n\n85.5385\n\n</td></tr><tr><td>\n\n30:00.0\n\n</td><td>\n\nDELL\n\n</td><td>\n\n541.5385\n\n</td><td>\n\n297.2808\n\n</td></tr><tr><td>\n\n30:00.0\n\n</td><td>\n\nDELL\n\n</td><td>\n\n754.3802\n\n</td><td>\n\n161.1488\n\n</td></tr></tbody>\n</table>\n"
    },
    "exists": {
        "url": "https://docs.dolphindb.com/en/Functions/e/exists.html",
        "signatures": [
            {
                "full": "exists(path)",
                "name": "exists",
                "parameters": [
                    {
                        "full": "path",
                        "name": "path"
                    }
                ]
            }
        ],
        "markdown": "### [exists](https://docs.dolphindb.com/en/Functions/e/exists.html)\n\n\n\n#### Syntax\n\nexists(path)\n\n#### Arguments\n\n**path** is a STRING scalar/vector, indicating the path of file(s) or folder(s).\n\n#### Details\n\nCheck if the specified file(s) or folder(s) exist. It can be used in the distributed files system to check if the specified folder(s) exist.\n\n#### Examples\n\n```\nt=table(1..10 as ID, rand(1.0, 10) as x);\nsaveText(t, \"C:/DolphinDB/Data/t.txt\");\n\nexists(\"C:/DolphinDB/Data/t.txt\");\n// output\ntrue\nexists(\"C:/DolphinDB/Data/t1.txt\");\n// output\nfalse\nexists(\"C:/DolphinDB/Data\");\n// output\ntrue\n\nexists([\"C:/DolphinDB/Data/t.txt\",\"C:/DolphinDB/Data/t1.txt\",\"C:/DolphinDB/Data\"]);\n// output\n[true,false,true]\n```\n\nTo check if a folder (or folders) exists in the distributed files system (the following script must be executed at a data node in a cluster):\n\n```\nn=1000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt = db.createPartitionedTable(t, `pt, `date);\npt.append!(t);\n\nexists(\"dfs://valueDB/20170807\");\n// output\ntrue\n```\n"
    },
    "existsCatalog": {
        "url": "https://docs.dolphindb.com/en/Functions/e/existsCatalog.html",
        "signatures": [
            {
                "full": "existsCatalog(catalog)",
                "name": "existsCatalog",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    }
                ]
            }
        ],
        "markdown": "### [existsCatalog](https://docs.dolphindb.com/en/Functions/e/existsCatalog.html)\n\n#### Syntax\n\nexistsCatalog(catalog)\n\n#### Arguments\n\n**catalog**is a string specifying the catalog name.\n\n#### Details\n\nCheck whether the specified catalog exists.\n\n**Return value**: A Boolean scalar.\n\n#### Examples\n\n```\nuse CATALOG cat1;\nexistsCatalog(\"cat1\") // Output: true\nexistsCatalog(\"cat2\") // Output: false\n```\n\n"
    },
    "existsDatabase": {
        "url": "https://docs.dolphindb.com/en/Functions/e/existsDatabase.html",
        "signatures": [
            {
                "full": "existsDatabase(dbUrl)",
                "name": "existsDatabase",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    }
                ]
            }
        ],
        "markdown": "### [existsDatabase](https://docs.dolphindb.com/en/Functions/e/existsDatabase.html)\n\n\n\n#### Syntax\n\nexistsDatabase(dbUrl)\n\n#### Arguments\n\n**dbUrl** is a string indicating the path of a database folder.\n\n#### Details\n\nCheck if a database exists under the specified folder.\n\n#### Examples\n\nTo check if a DFS database exists:\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt = db.createPartitionedTable(t, `pt, `date);\npt.append!(t);\n\nexistsDatabase(\"dfs://valueDB\");\n// output\ntrue\n\nexistsDatabase(\"dfs://valueDB/20170807\");\n// output\nfalse\n```\n"
    },
    "existsPartition": {
        "url": "https://docs.dolphindb.com/en/Functions/e/existsPartition.html",
        "signatures": [
            {
                "full": "existsPartition(path, [tableName])",
                "name": "existsPartition",
                "parameters": [
                    {
                        "full": "path",
                        "name": "path"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [existsPartition](https://docs.dolphindb.com/en/Functions/e/existsPartition.html)\n\n\n\n#### Syntax\n\nexistsPartition(path, \\[tableName])\n\n#### Arguments\n\n**path** is a string indicating the path of a partition folder.\n\n**tableName** (optional) is a string indicating the table name. If *chunkGranularity* is set to \"DATABASE\" when creating the database, *tableName* is not required. If *chunkGranularity* is set to \"TABLE\":\n\n* If the parameter path contains the physical index of the table (which can be retrieved with the function `listTables`), *tableName* is not required.\n\n* Otherwise, *tableName* must be specified.\n\n#### Details\n\nCheck if the specified partition exists.\n\n#### Examples\n\nCheck if the specified partition exists. The following scripts must be executed on a data node or compute node.\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt = db.createPartitionedTable(t, `pt, `date);\npt.append!(t);\n\nlistTables(\"dfs://valueDB\")\n```\n\n| tableName | physicalIndex |\n| --------- | ------------- |\n| pt        | s             |\n\n```\nexistsPartition(\"dfs://valueDB/20170807/s\");\n// output\ntrue\n\n//When the chunk granularity of the database is at TABLE level and the parameter path doesn't contain table physicalIndex, the parameter tableName must be specified or the partition cannot be found.\nexistsPartition(\"dfs://valueDB/20170807\", `pt)\n// output\ntrue\n\nexistsPartition(\"dfs://valueDB/20170807\");\n// output\nfalse\n\nexistsPartition(\"dfs://valueDB\");\n// output\nfalse\n\nexistsPartition(\"dfs://valueDB/20170807/s/pt\");\n// output\nfalse\n```\n"
    },
    "existsStreamTable": {
        "url": "https://docs.dolphindb.com/en/Functions/e/existsstreamtable.html",
        "signatures": [
            {
                "full": "existsStreamTable(tableName)",
                "name": "existsStreamTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [existsStreamTable](https://docs.dolphindb.com/en/Functions/e/existsstreamtable.html)\n\n\n\n#### Syntax\n\nexistsStreamTable(tableName)\n\n#### Arguments\n\n**tableName**is a string indicating the name of a stream table. It can be a regular, shared, persisted, or high-availability stream table.\n\n#### Details\n\nCheck if the specified stream table exists.\n\nIf it exists, return true; otherwise, return false.\n\n#### Examples\n\n```\nid=`XOM`GS`AAPL\nx=102.1 33.4 73.6\nrt=streamTable(id, x);\nexistsStreamTable(`rt) \n// output\ntrue\n\nexistsStreamTable(`srt)  \n// output\nfalse\n\nshare rt as srt\nexistsStreamTable(`srt)  \n// output\ntrue\n```\n"
    },
    "existsSubscriptionTopic": {
        "url": "https://docs.dolphindb.com/en/Functions/e/existsSubscriptionTopic.html",
        "signatures": [
            {
                "full": "existsSubscriptionTopic([server], tableName, [actionName])",
                "name": "existsSubscriptionTopic",
                "parameters": [
                    {
                        "full": "[server]",
                        "name": "server",
                        "optional": true
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[actionName]",
                        "name": "actionName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [existsSubscriptionTopic](https://docs.dolphindb.com/en/Functions/e/existsSubscriptionTopic.html)\n\n\n\n#### Syntax\n\nexistsSubscriptionTopic(\\[server], tableName, \\[actionName])\n\nAlias: existSubscriptionTopic\n\n#### Arguments\n\n**server** (optional) is a string indicating the node alias of the subscribed stream table, or the handler of a remote call connection. If *server* is not specified or an empty string, it means the streaming data is from the local server.\n\n**tableName** is a string indicating the name of a shared stream table.\n\n**actionName** (optional) is a string indicating the name of the subscription task. *actionName* can only contain letters, numbers and underscores. If the *actionName* is specified when the subscription is created, it must also be specified here.\n\n#### Details\n\nCheck the existence of a subscription topic of a shared stream table. Return \"true\" if the subscription topic exists, \"false\" if it doesn't.\n\n#### Examples\n\n```\nt=streamTable(1000000:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nshare t as trades\ntrades_1=streamTable(1000000:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nsubscribeTable(tableName=`trades, actionName=`vwap, offset=-1, handler=append!{trades_1})\nexistsSubscriptionTopic(,`trades,`vwap)\n// output\ntrue\n```\n"
    },
    "existsTable": {
        "url": "https://docs.dolphindb.com/en/Functions/e/existsTable.html",
        "signatures": [
            {
                "full": "existsTable(dbUrl, tableName)",
                "name": "existsTable",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [existsTable](https://docs.dolphindb.com/en/Functions/e/existsTable.html)\n\n\n\n#### Syntax\n\nexistsTable(dbUrl, tableName)\n\n#### Arguments\n\n**dbUrl** is a string indicating the path of a database.\n\n**tableName** is a string indicating a table name.\n\n#### Details\n\nCheck if the specified table exists in the specified database.\n\n#### Examples\n\nTo check if a table exists in a DFS database (on a data node or compute node). The following scripts must be executed on a data node or compute node.\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt = db.createPartitionedTable(t, `pt, `date);\npt.append!(t);\n\nexistsTable(\"dfs://valueDB\", `pt);\n// output\ntrue\n\nexistsTable(\"dfs://valueDB/20170807\", `pt);\n// output\ntrue\n```\n"
    },
    "exp": {
        "url": "https://docs.dolphindb.com/en/Functions/e/exp.html",
        "signatures": [
            {
                "full": "exp(X)",
                "name": "exp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [exp](https://docs.dolphindb.com/en/Functions/e/exp.html)\n\n\n\n#### Syntax\n\nexp(X)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix/table.\n\n#### Details\n\nApply the exponential function to all elements of *X*.\n\n#### Examples\n\n```\nexp(1 2 3);\n// output\n[2.718282,7.389056,20.085537]\n\nlog(exp(1));\n// output\n1\n```\n"
    },
    "exp2": {
        "url": "https://docs.dolphindb.com/en/Functions/e/exp2.html",
        "signatures": [
            {
                "full": "exp2(X)",
                "name": "exp2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [exp2](https://docs.dolphindb.com/en/Functions/e/exp2.html)\n\n\n\n#### Syntax\n\nexp2(X)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix.\n\n#### Details\n\nReturn 2 raised to the power of *X*.\n\n**Return value**: DOUBLE type\n\n#### Examples\n\n```\nexp2(3);\n// output\n8\n\nexp2(2 4 NULL 6);\n// output\n[4,16,,64]\n\nexp2(1..4$2:2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 2  | 8  |\n| 4  | 16 |\n"
    },
    "expm1": {
        "url": "https://docs.dolphindb.com/en/Functions/e/expm1.html",
        "signatures": [
            {
                "full": "expm1(X)",
                "name": "expm1",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [expm1](https://docs.dolphindb.com/en/Functions/e/expm1.html)\n\n\n\n#### Syntax\n\nexpm1(X)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix/table.\n\n#### Details\n\nReturn exp(X)-1.\n\n#### Examples\n\n```\nexpm1(5);\n// output\n147.413159\n\nexpm1(1 2 3 NULL);\n// output\n[1.718282,6.389056,19.085537,]\n\nexpm1(1..4$2:2);\n```\n\n| #0       | #1        |\n| -------- | --------- |\n| 1.718282 | 19.085537 |\n| 6.389056 | 53.59815  |\n"
    },
    "expr": {
        "url": "https://docs.dolphindb.com/en/Functions/e/expr.html",
        "signatures": [
            {
                "full": "expr(args...)",
                "name": "expr",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [expr](https://docs.dolphindb.com/en/Functions/e/expr.html)\n\n\n\n#### Syntax\n\nexpr(args...)\n\n#### Arguments\n\n**args...** are objects, operators, or metacode. A metacode block contains objects or expressions enclosed by angle brackets < >. The minimum number of arguments is 2.\n\n#### Details\n\nGenerate metacode from *args*.\n\n#### Examples\n\n```\nexpr(6,<,8);\n// output\n< 6 < 8 >\n\nexpr(sum, 1 2 3);\n// output\n< sum [1,2,3] >\n\na=6;\nexpr(a,+,1);\n// output\n< 6 + 1 >\n\nexpr(<a>,+,1);\n// output\n< a + 1 >\n\nexpr(<a>,+,<b>);\n// output\n< a + b >\n\nexpr(a+7,*,8);\n// output\n< 13 * 8 >\n\nexpr(<a+7>,*,8);\n// output\n< (a + 7) * 8 >\n\nexpr(not, < a >);\n// output\n< ! a >\n```\n"
    },
    "extractTextSchema": {
        "url": "https://docs.dolphindb.com/en/Functions/e/extractTextSchema.html",
        "signatures": [
            {
                "full": "extractTextSchema(filename, [delimiter], [skipRows=0])",
                "name": "extractTextSchema",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    },
                    {
                        "full": "[skipRows=0]",
                        "name": "skipRows",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [extractTextSchema](https://docs.dolphindb.com/en/Functions/e/extractTextSchema.html)\n\n\n\n#### Syntax\n\nextractTextSchema(filename, \\[delimiter], \\[skipRows=0])\n\n#### Arguments\n\n**filename** is the input data file name with its absolute path. Currently only\\*.csv\\* files are supported.\n\n**delimiter** (optional) is a string indicating the table column separator. It can consist of one or more characters, with the default being a comma (',').\n\n**skipRows** (optional) is an integer between 0 and 1024 indicating the rows in the beginning of the text file to be ignored. The default value is 0.\n\n#### Details\n\nGenerate the schema table for the input data file. The schema table has 2 columns: column names and their data types.\n\nWhen the input file contains dates and times:\n\n* For data with delimiters (date delimiters \"-\", \"/\" and \".\", and time delimiter \":\"), it will be converted to the corresponding type. For example, \"12:34:56\" is converted to the SECOND type; \"23.04.10\" is converted to the DATE type.\n* For data without delimiters, data in the format of \"yyMMdd\" that meets 0<=yy<=99, 0<=MM<=12, 1<=dd<=31, will be preferentially parsed as DATE; data in the format of \"yyyyMMdd\" that meets 1900<=yyyy<=2100, 0<=MM<=12, 1<=dd<=31 will be preferentially parsed as DATE.\n\n**Note:**\n\nFrom version 1.30.22/2.00.10 onwards, function `extractTextSchema` supports a data file that contains a record with multiple newlines.\n\n#### Examples\n\n```\nn=1000000\ntimestamp=09:30:00+rand(18000,n)\nID=rand(100,n)\nqty=100*(1+rand(100,n))\nprice=5.0+rand(100.0,n)\nt1 = table(timestamp,ID,qty,price)\nsaveText(t1, \"C:/DolphinDB/Data/t1.txt\")\nschema=extractTextSchema(\"C:/DolphinDB/Data/t1.txt\");\nschema;\n```\n\n| name      | type   |\n| --------- | ------ |\n| timestamp | SECOND |\n| ID        | INT    |\n| qty       | INT    |\n| price     | DOUBLE |\n"
    },
    "eye": {
        "url": "https://docs.dolphindb.com/en/Functions/e/eye.html",
        "signatures": [
            {
                "full": "eye(X)",
                "name": "eye",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [eye](https://docs.dolphindb.com/en/Functions/e/eye.html)\n\n\n\n#### Syntax\n\neye(X)\n\n#### Arguments\n\n**X** is a positive integer.\n\n#### Details\n\nReturn an *X* by *X* indentity matrix.\n\n#### Examples\n\n```\neye(3);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 0  | 0  |\n| 0  | 1  | 0  |\n| 0  | 0  | 1  |\n"
    },
    "hashBucket": {
        "url": "https://docs.dolphindb.com/en/Functions/h/hashBucket.html",
        "signatures": [
            {
                "full": "hashBucket(X, buckets)",
                "name": "hashBucket",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "buckets",
                        "name": "buckets"
                    }
                ]
            }
        ],
        "markdown": "### [hashBucket](https://docs.dolphindb.com/en/Functions/h/hashBucket.html)\n\n\n\n#### Syntax\n\nhashBucket(X, buckets)\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n**buckets** is a positive integer.\n\n#### Details\n\nCompute the hash value of *X*. The HASH partition is based on the hash value of the partitioning column elements.\n\n#### Examples\n\n```\nhashBucket(34 45 67, 10);\n// output\n[4,5,7]\n\nhashBucket(`AAPL`TSLA`GS`MS`GE`BA`UAL`WMT, 10);\n// output\n[9,4,1,8,3,7,5,2]\n```\n"
    },
    "hasNull": {
        "url": "https://docs.dolphindb.com/en/Functions/h/hasNull.html",
        "signatures": [
            {
                "full": "hasNull(X)",
                "name": "hasNull",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [hasNull](https://docs.dolphindb.com/en/Functions/h/hasNull.html)\n\n\n\n#### Syntax\n\nhasNull(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\n* For a scalar, return true if it is NULL.\n* For a vector, return true if at least one element is NULL.\n* For a matrix or a table, return true if at least one element of at least one column is NULL.\n\nPlease refer to related functions: [isNull](https://docs.dolphindb.com/en/Functions/i/isNull.html), [nullFill](https://docs.dolphindb.com/en/Functions/n/nullFill.html).\n\n#### Examples\n\n```\nhasNull NULL;\n// output\ntrue\n\nx=00f;\nhasNull x;\n// output\ntrue\n\nhasNull 5;\n// output\nfalse\n\nhasNull(1 2 NULL 4 NULL 6);\n// output\ntrue\n\nx=((NULL,1),2);\nhasNull x;\n// output\nfalse\n\nm=(1 NULL 3 4 5 6)$2:3;\nhasNull m;\n// output\ntrue\n\nt=table(`AAPL`IBM`MSFT as sym, 2200 NULL 4500 as qty);\nhasNull(t);\n// output\ntrue\n```\n"
    },
    "haStreamTable": {
        "url": "https://docs.dolphindb.com/en/Functions/h/haStreamTable.html",
        "signatures": [
            {
                "full": "haStreamTable(raftGroup, table, tableName, cacheLimit, [keyColumn], [retentionMinutes=1440])",
                "name": "haStreamTable",
                "parameters": [
                    {
                        "full": "raftGroup",
                        "name": "raftGroup"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "cacheLimit",
                        "name": "cacheLimit"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[retentionMinutes=1440]",
                        "name": "retentionMinutes",
                        "optional": true,
                        "default": "1440"
                    }
                ]
            }
        ],
        "markdown": "### [haStreamTable](https://docs.dolphindb.com/en/Functions/h/haStreamTable.html)\n\n\n\n#### Syntax\n\nhaStreamTable(raftGroup, table, tableName, cacheLimit, \\[keyColumn], \\[retentionMinutes=1440])\n\n#### Arguments\n\n**raftGroup** is an integer greater than 1 indicating Raft group ID.\n\n**table** is an empty table object created by function [table](https://docs.dolphindb.com/en/Functions/t/table.html).\n\n**tableName** is a string indicating the name of the high-availability stream table.\n\n**cacheLimit** is an integer representing the maximum number of rows of the high-availability stream table to be kept in memory. If *cacheLimit*>100,000, it is automatically adjusted to 100,000.\n\n**keyColumn** (optional) is a string indicating the name of the primary key column.\n\n**retentionMinutes** (optional) is an integer indicating for how long (in terms of minutes) a log file larger than 1GB will be kept after last update. The default value is 1440, which means the log file only keeps data in the past 24 hours.\n\n#### Details\n\nCreate a high-availability stream table. To use the function, we must enable high availability for streaming by specifying parameters *streamingHAMode* and *streamingRaftGroups* in cluster configuration file *cluster.cfg*.\n\nAs the cluster starts up, the data nodes specified by the configuration parameter *streamingRaftGroups* form Raft groups. In a Raft group, one data node is the Leader and the rest are Followers. There is a copy of the high-availability stream table on each data node in a Raft group.\n\nAfter creating the high-availability stream table, subscribe to the high-availability stream table on any of the data nodes in a Raft group and set parameter *reconnect* of function `subscribeTable` to \"true\". The high-availability stream table on the Leader will publish data. If the Leader node goes down, the system will elect a new Leader to continue publishing data. Subscribers will automatically be connected to the high-availability stream table on the new Leader.\n\nA Raft group can have multiple high-availability streaming tables.\n\n#### Examples\n\nSuppose *streamingRaftGroups*=11:NODE1:NODE2:NODE3. Execute the following script on any data node of the Raft group to create a high-availability stream table trades:\n\n```\ncolNames = `timestamp`sym`qty`price\ncolTypes = [TIMESTAMP,SYMBOL,INT,DOUBLE]\nt=table(1:0,colNames,colTypes)\nhaStreamTable(11,t,`trades,100000);\n```\n\nExecute the followng script on another node that do not belong to the Raft group (NODE4) to subscribe to table trades, and then save the subscribed data to a distributed database.\n\n```\nif(existsDatabase(\"dfs://stock\")){\n   dropDatabase(\"dfs://stock\")\n}\ndb=database(\"dfs://stock\",VALUE,2018.08.01..2019.12.30)\nt=table(1:0,`timestamp`sym`qty`price,[TIMESTAMP,SYMBOL,INT,DOUBLE])\ntrades_slave=db.createPartitionedTable(t,`trades_slave,`timestamp);\nsubscribeTable(NODE2,`trades,`sub_trades,-1,append!{trades_slave},true,1000,1,-1,true);\n```\n\nPlease note that in the script above, the first parameter of function `subscribeTable` can be any of NODE1, NODE2 and NODE3. Paramater *reconnect* must be set to \"true\".\n\nExecute the following script on NODE4 to cancel the subscription.\n\n```\nunsubscribeTable(NODE2,`trades,`sub_trades);\n```\n\nRelated functions: [dropStreamTable](https://docs.dolphindb.com/en/Functions/d/dropStreamTable.html), [getStreamingLeader](https://docs.dolphindb.com/en/Functions/g/getStreamingLeader.html), [getStreamingRaftGroups](https://docs.dolphindb.com/en/Functions/g/getStreamingRaftGroups.html)\n"
    },
    "head": {
        "url": "https://docs.dolphindb.com/en/Functions/h/head.html",
        "signatures": [
            {
                "full": "head(X, [n=1])",
                "name": "head",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [head](https://docs.dolphindb.com/en/Functions/h/head.html)\n\n\n\n#### Syntax\n\nhead(X, \\[n=1])\n\n#### Arguments\n\n**X** is a vector/matrix/table.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the first *n* element(s) of a vector, or the first *n* columns of a matrix, or the first *n* rows of a table.\n\n#### Examples\n\n```\nx=1..10;\nhead(x);\n\n// output\n1\n\nx=1..10$2:5;\nx;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  |\n| 2  | 4  | 6  | 8  | 10 |\n\n```\nx.head();\n\n// output\n[1,2]\n\nhead(x,2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\nx=table(1..5 as a, 6..10 as b);\nx;\n```\n\n| a | b  |\n| - | -- |\n| 1 | 6  |\n| 2 | 7  |\n| 3 | 8  |\n| 4 | 9  |\n| 5 | 10 |\n\n```\nhead(x);\n\n// output\nb->6\na->1\n\nx.head(2);\n```\n\n| a | b |\n| - | - |\n| 1 | 6 |\n| 2 | 7 |\n\nRelated function: [tail](https://docs.dolphindb.com/en/Functions/t/tail.html)\n"
    },
    "hex": {
        "url": "https://docs.dolphindb.com/en/Functions/h/hex.html",
        "signatures": [
            {
                "full": "hex(X, [reverse=false])",
                "name": "hex",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[reverse=false]",
                        "name": "reverse",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [hex](https://docs.dolphindb.com/en/Functions/h/hex.html)\n\n\n\n#### Syntax\n\nhex(X, \\[reverse=false])\n\n#### Arguments\n\n**X** is an integer scalar/vector.\n\n**reverse** (optional) is a Boolean value indicating whether to reverse the order of the result. The default value is false.\n\n#### Details\n\nConvert data of INTEGRAL, FLOAT,COMPLEX, and BINARY types to hexadecimal and return a string. For details, see [Data Types](https://docs.dolphindb.com/en/Programming/DataTypesandStructures/DataTypes/DataTypes.dita).\n\n#### Examples\n\n```\nhex(16 25)\n// Output: [\"00000010\",\"00000019\"]\n\nhex(16 25,true)\n// Output: [\"10000000\",\"19000000\"]\n```\n\n```\nhex(compress(1 2 3))\n// Output: [\"00\",\"05\",\"ff\",\"01\",\"04\",\"04\",\"00\",\"00\",\"ff\",\"ff\",\"ff\",\"ff\",\"03\",\"00\",\"00\",\"00\",\"ff\",\"ff\",\"ff\",\"ff\",\"0d\",\"00\",\"00\",\"80\",\"c0\",\"01\",\"00\",\"00\",\"00\",\"02\",\"00\",\"00\",\"00\",\"03\",\"00\",\"00\",\"00\"]\n```\n\n```\nhex(123.456 3.1415926)\n//output: [\"405edd2f1a9fbe77\",\"400921fb4d12d84a\"]\n```\n"
    },
    "highDouble": {
        "url": "https://docs.dolphindb.com/en/Functions/h/highDouble.html",
        "signatures": [
            {
                "full": "highDouble(X)",
                "name": "highDouble",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [highDouble](https://docs.dolphindb.com/en/Functions/h/highDouble.html)\n\n\n\n#### Syntax\n\nhighDouble(X)\n\n#### Arguments\n\n**X** is a vector/scalar which must be 16-byte data type.\n\n#### Details\n\nIt returns the high-order 8-byte double data of *X*.\n\n#### Example\n\n```\n$ x=1 2 3 4\ny=4 3 2 1\npoints = point(x, y)\nx1 = highDouble(points)\n// output\n[4,3,2,1]\n```\n\nGet the imaginary part of a complex number:\n\n```\na=complex(2, 5)\nhighDouble(a)\n// output\n5\n```\n"
    },
    "highLong": {
        "url": "https://docs.dolphindb.com/en/Functions/h/highlong.html",
        "signatures": [
            {
                "full": "highLong(X)",
                "name": "highLong",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [highLong](https://docs.dolphindb.com/en/Functions/h/highlong.html)\n\n\n\n#### Syntax\n\nhighLong(X)\n\n#### Arguments\n\n**X** is a scalar/vector/table/pair/dictionary which must be 16-byte data type (UUID, IPADDR, INT128, COMPLEX, and POINT are supported).\n\n#### Details\n\nIt returns the high-order 8-byte long integer data of *X*.\n\n#### Examples\n\n```\nx =ipaddr(\"192.168.1.13\")\nx1 = highLong(x)\nprint(x1)\n// output\n0\n```\n\n```\nx=1 2 3 4\ny=4 3 2 1\npoints = point(x, y)\nx1 = highLong(points)\n// output\n[4616189618054758400,4613937818241073152,4611686018427387904,4607182418800017408]\n```\n\nRelated function: [lowLong](https://docs.dolphindb.com/en/Functions/l/lowlong.html)\n"
    },
    "hmac": {
        "url": "https://docs.dolphindb.com/en/Functions/h/hmac.html",
        "signatures": [
            {
                "full": "hmac(key, message, [digest='sha256'])",
                "name": "hmac",
                "parameters": [
                    {
                        "full": "key",
                        "name": "key"
                    },
                    {
                        "full": "message",
                        "name": "message"
                    },
                    {
                        "full": "[digest='sha256']",
                        "name": "digest",
                        "optional": true,
                        "default": "'sha256'"
                    }
                ]
            }
        ],
        "markdown": "### [hmac](https://docs.dolphindb.com/en/Functions/h/hmac.html)\n\n\n\n#### Syntax\n\nhmac(key, message, \\[digest='sha256'])\n\n#### Arguments\n\n**key** is a LITERAL scalar indicating the secret key.\n\n**message**is a LITERAL scalar indicating the message to be encrypted.\n\n**digest**(optional)is a STRING scalar indicating the hash algorithm for encryption, which can be \"sha256\" (default), \"sha1\", \"sha224\", \"sha 384\", \"sha512\", and \"md5\".\n\n#### Details\n\nGenerate and return a hash value using the HMAC (Hash-based Message Authentication Code) mechanism. The value is a STRING scalar generated based on the given secret key and message using the specified hash algorithm.\n\n#### Examples\n\n```\nhmac(key=\"myKey\", message=\"myMessage\", digest=\"sha256\")\n// output:'71e5f5ca5f64550ee4524909f7cead7b81d8674a657383aec1b003a8a3f05b04'\n\nhmac(key=\"myKey\", message=\"myMessage\", digest=\"sha1\")\n// output:'5033197fa89dedf5088eed6100dfa5a0f67ef1ce'\n\nhmac(key=\"myKey2\", message=\"myMessage\", digest=\"sha256\")\n// output:'40e2a700754cec30ace1e82abfe7fd233f8f6c299050cc21b0e0a4ea42428126'\n```\n"
    },
    "hour": {
        "url": "https://docs.dolphindb.com/en/Functions/h/hour.html",
        "signatures": [
            {
                "full": "hour(X)",
                "name": "hour",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [hour](https://docs.dolphindb.com/en/Functions/h/hour.html)\n\n\n\n#### Syntax\n\nhour(X)\n\n#### Arguments\n\n**X** is a temporal scalar/vector.\n\n#### Details\n\nReturn the corresponding hour(s).\n\n**Return value**: an integer.\n\n#### Examples\n\n```\nhour(2012.12.03 01:22:01);\n// output\n1\n```\n\nRelated functions: [date](https://docs.dolphindb.com/en/Functions/d/date.html), [second](https://docs.dolphindb.com/en/Functions/s/second.html), [minute](https://docs.dolphindb.com/en/Functions/m/minute.html), [month](https://docs.dolphindb.com/en/Functions/m/month.html), [year](https://docs.dolphindb.com/en/Functions/y/year.html)\n"
    },
    "hourOfDay": {
        "url": "https://docs.dolphindb.com/en/Functions/h/hourOfDay.html",
        "signatures": [
            {
                "full": "hourOfDay(X)",
                "name": "hourOfDay",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [hourOfDay](https://docs.dolphindb.com/en/Functions/h/hourOfDay.html)\n\n\n\n#### Syntax\n\nhourOfDay(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type TIME, MINUTE, SECOND, DATETIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP.\n\n#### Details\n\nFor each element in *X*, return a number from 0 to 23 indicating which hour of the day it falls in.\n\n#### Examples\n\n```\nhourOfDay(00:46:12);\n// output\n0\n\nhourOfDay([2012.06.12T12:30:00,2012.10.28T17:35:00,2013.01.06T02:36:47,2013.04.06T08:02:14]);\n// output\n[12,17,2,8]\n```\n\nRelated functions: [dayOfYear](https://docs.dolphindb.com/en/Functions/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.com/en/Functions/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.com/en/Functions/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.com/en/Functions/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.com/en/Functions/w/weekOfYear.html), [minuteOfHour](https://docs.dolphindb.com/en/Functions/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.com/en/Functions/m/millisecond.html), [microsecond](https://docs.dolphindb.com/en/Functions/m/microsecond.html), [nanosecond](https://docs.dolphindb.com/en/Functions/n/nanosecond.html)\n"
    },
    "ifirstHit": {
        "url": "https://docs.dolphindb.com/en/Functions/i/ifirstHit.html",
        "signatures": [
            {
                "full": "ifirstHit(func, X, target)",
                "name": "ifirstHit",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "target",
                        "name": "target"
                    }
                ]
            }
        ],
        "markdown": "### [ifirstHit](https://docs.dolphindb.com/en/Functions/i/ifirstHit.html)\n\n\n\n#### Syntax\n\nifirstHit(func, X, target)\n\n#### Arguments\n\n**func** can only be the following operators: `>`, `>=`, `<`, `<=`, `!=`, `<>`, `==`.\n\n**X** is a vector/matrix/table.\n\n**target** is a scalar of the same type as *X* indicating the value to be compared with *X*.\n\n#### Details\n\nReturn the index of the first element in *X* that satisfies the condition `X func target` (e.g. X>5).\n\nIf no element in *X* satisfies the condition, return -1.\n\nNULL values are ignored in `ifirstHit`.\n\n* Use [ifirstNot](https://docs.dolphindb.com/en/Functions/i/ifirstNot.html) to find the index of the first non-NULL value.\n\n* Use [find](https://docs.dolphindb.com/en/Functions/f/find.html) to find the index of the first NULL value.\n\n#### Examples\n\n```\nX = NULL 3.2 4.5 1.2 NULL 7.8 0.6 9.1\nifirstHit(<, X, 2.5)\n// output\n3\n\n // return -1 if no element in X satisfies the condition.\nifirstHit(>, X, 10.0)\n// output\n -1\n```\n\nRelated function: [firstHit](https://docs.dolphindb.com/en/Functions/f/firstHit.html)\n"
    },
    "ifirstNot": {
        "url": "https://docs.dolphindb.com/en/Functions/i/ifirstNot.html",
        "signatures": [
            {
                "full": "ifirstNot(X)",
                "name": "ifirstNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ifirstNot](https://docs.dolphindb.com/en/Functions/i/ifirstNot.html)\n\n\n\n#### Syntax\n\nifirstNot(X)\n\n#### Arguments\n\n**X** is a vector, or a tuple of vectors of equal length, or a matrix.\n\n#### Details\n\nIf *X* is a vector, return the subscript of the first non-NULL element. Return -1 if all elements are NULL.\n\nIf *X* is a tuple of vectors, return the subscript of the first position where the element in all vectors is not NULL.\n\nIf *X* is a matrix, return the subscript of the first non-NULL element within each column. The result is a vector.\n\n#### Examples\n\n```\nifirstNot(NULL NULL 2 4 8 NULL 1);\n// output\n2\n\nifirstNot(take(int(),5));\n// output\n-1\n\nx=NULL NULL 4 7 8 NULL\ny=1 NULL NULL 4 NULL NULL\nifirstNot([x,y]);\n// output\n3\n\nx=NULL NULL 4 7 8 NULL\ny=1 2 NULL NULL NULL 6\nifirstNot([x,y]);\n// output\n-1\n\nm=matrix(0 NULL 1 2 3, NULL 2 NULL 0 3);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 0  |    |\n|    | 2  |\n| 1  |    |\n| 2  | 0  |\n| 3  | 3  |\n\n```\nifirstNot(m);\n// output\n[0,1]\n```\n\nRelated functions: [ilastNot](https://docs.dolphindb.com/en/Functions/i/ilastNot.html), [firstNot](https://docs.dolphindb.com/en/Functions/f/firstNot.html), [lastNot](https://docs.dolphindb.com/en/Functions/l/lastNot.html)\n"
    },
    "ifNull": {
        "url": "https://docs.dolphindb.com/en/Functions/i/ifNull.html",
        "signatures": [
            {
                "full": "ifNull(X, Y)",
                "name": "ifNull",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ifNull](https://docs.dolphindb.com/en/Functions/i/ifNull.html)\n\n\n\n#### Syntax\n\nifNull(X, Y)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix.\n\n**Y** is a scalar/pair/vector/matrix.\n\n*X* and *Y* must have the same data type.\n\n#### Details\n\nDetermine whether *X* is NULL. If it is NULL, return *X*; if not, return *Y*.\n\n#### Examples\n\n```\nx = take(1..5 join NULL 6,7)\ny = 1..7\nifNull(x,y)\n// output\n[1,2,3,4,5,,7]\n```\n\n```\n\ny1 = int(take(1..5 join int(),6))$2:3\nx1 = int(take(100,6))$2:3\nifNull(x1,y1)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 100  | 100  | 100  |\n| 100  | 100  |      |\n\nIf *X* is a vector and *Y* is a matrix with n rows and m columns, the length of *X* is n\\*m.\n\n```\nm=int(take(1..4 join NULL 8,6))\nifNull(m,y1)\n// output\n[100,100,100,100,,100]\n```\n"
    },
    "ifValid": {
        "url": "https://docs.dolphindb.com/en/Functions/i/ifValid.html",
        "signatures": [
            {
                "full": "ifValid(X, Y)",
                "name": "ifValid",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ifValid](https://docs.dolphindb.com/en/Functions/i/ifValid.html)\n\n\n\n#### Syntax\n\nifValid(X, Y)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix.\n\n**Y** is a scalar/pair/vector/matrix.\n\n*X* and *Y* must have the same data type.\n\n#### Details\n\nDetermine whether *X* is valid. If it is valid, the value of *X* is returned; if it is NULL, the value of *Y* is returned.\n\n#### Examples\n\n```\nx = take(1..5 join NULL 6,7)\ny = 1..7\nifValid(x,y)\n// output\n[1,2,3,4,5,6,6]\n\n```\n\n```\n\nx1 = int(take(1..5 join int(),6))$2:3\ny1 = int(take(100,6))$2:3\nifValid(x1,y1)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 3    | 5    |\n| 2    | 4    | 100  |\n\nIf *X* is a vector and *Y* is a matrix with n rows and m columns, the length of *X* is n\\*m.\n\n```\nm=int(take(1..4 join NULL 8,6))\nifValid(m,y1)\n// output\n[1,2,3,4,100,8]\n```\n"
    },
    "iif": {
        "url": "https://docs.dolphindb.com/en/Functions/i/iif.html",
        "signatures": [
            {
                "full": "iif(cond, trueResult, falseResult)",
                "name": "iif",
                "parameters": [
                    {
                        "full": "cond",
                        "name": "cond"
                    },
                    {
                        "full": "trueResult",
                        "name": "trueResult"
                    },
                    {
                        "full": "falseResult",
                        "name": "falseResult"
                    }
                ]
            }
        ],
        "markdown": "### [iif](https://docs.dolphindb.com/en/Functions/i/iif.html)\n\n\n\n#### Syntax\n\niif(cond, trueResult, falseResult)\n\n#### Arguments\n\n**cond** is a Boolean scalar/vector/matrix. It can be an expression returning Boolean values.\n\n**trueResult** and **falseResult** are scalars, or vectors of the same length as *cond*, or matrices of the same dimensions as *cond*.\n\n#### Details\n\nElement-wise conditional operation. *cond* is of Boolean type. If *cond\\[i]* is true, it returns`trueResult(cond[i])`; otherwise it returns `falseResult(cond[i])`. If *cond\\[i]* is NULL, it returns NULL.\n\n**Note:**\n\nThis function first parses the arguments and then returns *trueResult* or *falseResult* based on the result of *cond*.\n\n#### Examples\n\n```\niif(true true true false false false, 1..6, 6..1);\n// output\n[1,2,3,3,2,1]\n\niif(1..6==3, 1, 2);\n// output\n[2,2,1,2,2,2]\n\nx=9 6 8;\niif(x<=8, 10*x, 20*x-80);\n// output\n[100,60,80]\n```\n\nUse function `iif` in a SQL statement:\n\n```\nt=table(1..5 as id, 11..15 as x);\nt1=table(take(12,5) as a, take(14,5) as b);\nt;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n\n```\nt1;\n```\n\n| a  | b  |\n| -- | -- |\n| 12 | 14 |\n| 12 | 14 |\n| 12 | 14 |\n| 12 | 14 |\n| 12 | 14 |\n\n```\nupdate t set x=iif(x<t1.a, t1.a, iif(x>t1.b,t1.b, x));\nt;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 12 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 14 |\n\n```\na = NULL 1 -3 5\niif(a > 0, a, 0)\n// output\n[0, 1, 0, 5]\n\niif(nullCompare(>,a,0), a, 0)\n// output\n[ , 1, 0, 5]\n```\n\n```\nm1=1..6$3:2\nm2=6..1$3:2\niif(m1>m2, m1, m2);\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 6    | 4    |\n| 5    | 5    |\n| 4    | 6    |\n"
    },
    "ilastNot": {
        "url": "https://docs.dolphindb.com/en/Functions/i/ilastNot.html",
        "signatures": [
            {
                "full": "ilastNot(X)",
                "name": "ilastNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ilastNot](https://docs.dolphindb.com/en/Functions/i/ilastNot.html)\n\n\n\n#### Syntax\n\nilastNot(X)\n\n#### Arguments\n\n**X** is a vector, or a tuple of vectors of equal length, or a matrix.\n\n#### Details\n\nIf *X* is a vector, return the subscript of the last non-NULL element. Return -1 if all elements are NULL.\n\nIf *X* is a tuple of vectors, return the subscript of the last position where the element in all vectors is not NULL.\n\nIf *X* is a matrix, return the subscript of the last non-NULL element within each column. The result is a vector.\n\n#### Examples\n\n```\nilastNot(NULL NULL 2 4 8 1 NULL);\n// output\n5\n\nilastNot(take(int(),5));\n// output\n-1\n\nx=NULL NULL 4 7 8 NULL\ny=1 NULL NULL 4 NULL NULL\nilastNot([x,y]);\n// output\n3\n\nx=NULL NULL 4 7 8 NULL\ny=1 2 NULL NULL NULL 6\nilastNot([x,y]);\n// output\n-1\n\nm=matrix(2 NULL 1 0 NULL, NULL 2 NULL 6 0);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 2  |    |\n|    | 2  |\n| 1  |    |\n| 0  | 6  |\n|    | 0  |\n\n```\nilastNot(m);\n// output\n[3,4]\n```\n\nRelated functions: [ifirstNot](https://docs.dolphindb.com/en/Functions/i/ifirstNot.html), [lastNot](https://docs.dolphindb.com/en/Functions/l/lastNot.html), [firstNot](https://docs.dolphindb.com/en/Functions/f/firstNot.html)\n"
    },
    "ilike": {
        "url": "https://docs.dolphindb.com/en/Functions/i/ilike.html",
        "signatures": [
            {
                "full": "ilike(X, pattern)",
                "name": "ilike",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    }
                ]
            }
        ],
        "markdown": "### [ilike](https://docs.dolphindb.com/en/Functions/i/ilike.html)\n\n\n\n#### Syntax\n\nilike(X, pattern)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n**pattern** is a string and is usually used with wildcard character %.\n\n#### Details\n\nReturn a Boolean value scalar or vector indicating whether each element in *X* fits a specific pattern. The comparison is case insensitive.\n\nThe wildcard charater % indicates 0 or more characters.\n\n#### Examples\n\n```\nilike(`ABCDEFG, `de);\n// output\n0\n\nilike(`ABCDEFG, \"%de%\");\n// output\n1\n\na=`IBM`ibm`MSFT`Goog`YHOO`ORCL;\na ilike  \"%OO%\";\n// output\n[0,0,0,1,1,0]\n\na[a ilike  \"%OO%\"];\n// output\n[\"Goog\",\"YHOO\"]\n```\n\nRelated function: [like](https://docs.dolphindb.com/en/Functions/l/like.html)\n"
    },
    "imax": {
        "url": "https://docs.dolphindb.com/en/Functions/i/imax.html",
        "signatures": [
            {
                "full": "imax(X)",
                "name": "imax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [imax](https://docs.dolphindb.com/en/Functions/i/imax.html)\n\n\n\n#### Syntax\n\nimax(X)\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n#### Details\n\nIf *X* is a vector, return the position of the element with the largest value in *X*. If there are multiple identical maximum values, return the position of the first maximum value starting from the left.\n\nIf *X* is a matrix, conduct the aforementioned calculation within each column of *X*. The result is a vector.\n\n#### Examples\n\n```\nx = 1.2 2 NULL 6 -1 6;\nimax(x);\n// output\n3\n\nx = 5 3 1 6 4 6 $ 3:2;\nimax(x);\n// output\n(0,1)\n\nx=array(int,0);\nx;\n// output\n[]\n\nimax(x);\n// output\n-1\n// for an empty vector, imax returns -1.\n\nm=matrix(1 2 3, 6 5 4);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 6  |\n| 2  | 5  |\n| 3  | 4  |\n\n```\nimax(m);\n// output\n[2,0]\n```\n"
    },
    "imaxLast": {
        "url": "https://docs.dolphindb.com/en/Functions/i/imaxlast.html",
        "signatures": [
            {
                "full": "imaxLast(X)",
                "name": "imaxLast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [imaxLast](https://docs.dolphindb.com/en/Functions/i/imaxlast.html)\n\n\n\n#### Syntax\n\nimaxLast(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nIf *X* is a vector, return the position of the element with the largest value. If there are multiple elements with the identical largest value, return the position of the first element from the right. Same as other aggregate functions, NULL values are ignored.\n\nIf *X* is a matrix, return a vector containing the position of the element with the largest value in each column.\n\nIf *X* is a table, return a table. Each column of the table contains the position of the element with the largest value in the corresponding column of *X*.\n\n#### Examples\n\n```\nx = 1.2 2 NULL -1 6 -1\nimaxLast(x);\n// output\n4\n\nm=matrix(3 2 4 4 2, 1 4 2 4 3);\nimaxLast(m) \n// output\n[3,3]\n\nt=table(3 3 2 as c1, 1 4 4 as c2)\nimaxLast(t)\n// output\nc1\tc2\n0\t2\n```\n\nRelated function: [imax](https://docs.dolphindb.com/en/Functions/i/imax.html)\n"
    },
    "imin": {
        "url": "https://docs.dolphindb.com/en/Functions/i/imin.html",
        "signatures": [
            {
                "full": "imin(X)",
                "name": "imin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [imin](https://docs.dolphindb.com/en/Functions/i/imin.html)\n\n\n\n#### Syntax\n\nimin(X)\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n#### Details\n\nIf *X* is a vector, return the position of the minimum value in a vector or a matrix. If there are multiple identical minimum values, return the position of the first minimum value starting from the left. As with all aggregate functions, NULL values are not included in the calculation.\n\nIf *X* is a matrix, conduct the aforementioned calculation within each column of *X*. The result is a vector.\n\n#### Examples\n\n```\nx = 1.2 2 NULL -1 6 -1\nimin(x);\n// output\n3\n\nx = 5 3 1 6 4 1 $ 3:2\nimin(x);\n// output\n[2,2]\n```\n\n```\nm=matrix(1 3 2 4, 4 2 3 1);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 3  | 2  |\n| 2  | 3  |\n| 4  | 1  |\n\n```\nimin(m);\n// output\n[0,3]\n```\n"
    },
    "iminLast": {
        "url": "https://docs.dolphindb.com/en/Functions/i/iminlast.html",
        "signatures": [
            {
                "full": "iminLast(X)",
                "name": "iminLast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [iminLast](https://docs.dolphindb.com/en/Functions/i/iminlast.html)\n\n\n\n#### Syntax\n\niminLast(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nIf *X* is a vector, return the position of the element with the smallest value. If there are multiple elements with the identical smallest value, return the position of the first element from the right. Same as other aggregate functions, NULL values are ignored.\n\nIf *X* is a matrix, return a vector containing the position of the element with the smallest value in each column.\n\nIf *X* is a table, return a table. Each column of the table contains the position of the element with the smallest value in the corresponding column of *X*.\n\n#### Examples\n\n```\nx = 1.2 2 NULL -1 6 -1\niminLast(x);\n// output\n5\n\nm=matrix(3 2 2 4 2, 1 4 2 1 3);\niminLast(m) \n// output\n[4,3]\n\nt=table(3 2 2 as c1, 1 1 4 as c2)\niminLast(t)\n// output\nc1\tc2\n2\t1\n```\n\nRelated function: [imin](https://docs.dolphindb.com/en/Functions/i/imin.html)\n"
    },
    "imr": {
        "url": "https://docs.dolphindb.com/en/Functions/i/imr.html",
        "signatures": [
            {
                "full": "imr(ds, initValue, mapFunc, [reduceFunc], [finalFunc], terminateFunc, [carryover=false])",
                "name": "imr",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "initValue",
                        "name": "initValue"
                    },
                    {
                        "full": "mapFunc",
                        "name": "mapFunc"
                    },
                    {
                        "full": "[reduceFunc]",
                        "name": "reduceFunc",
                        "optional": true
                    },
                    {
                        "full": "[finalFunc]",
                        "name": "finalFunc",
                        "optional": true
                    },
                    {
                        "full": "terminateFunc",
                        "name": "terminateFunc"
                    },
                    {
                        "full": "[carryover=false]",
                        "name": "carryover",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [imr](https://docs.dolphindb.com/en/Functions/i/imr.html)\n\n\n\n#### Syntax\n\nimr(ds, initValue, mapFunc, \\[reduceFunc], \\[finalFunc], terminateFunc, \\[carryover=false])\n\n#### Arguments\n\n**ds** is the list of data sources. It must be a tuple with each element as a data source object. Even if there is only one data source, we still need a tuple to wrap the data source. In iterative computing, data sources are automatically cached and the cache will be cleared after the last iteration.\n\n**initValue** is the initial values of model parameter estimates. The format of the initial values must be the same as the output of the final function.\n\n**mapFunc** is the map function. It has 2 or 3 arguments. The first argument is the data entity represented by the corresponding data source. The second argument is the output of the final function in the previous iteration, which is an updated estimate of the model parameter. For the first iteration, it is the initial values given by the user. The last argument is the carryover object. Please check the explanation for parameter *carryover* for details.\n\n**reduceFunc** (optional) is the binary reduce function combines two map function call results. If there are *M* map calls, the reduce function will be called *M-1* times. The reduce function in most cases is trivial. An example is the addition function.\n\n**finalFunc** is the final function in each iteration. It accepts two arguments. The first argument is the output of the final function in the previous iteration. For the first iteration, it is the initial values given by the user. The second argument is the output of the reduce function call. If the reduce function is not specified, a tuple representing the collection of individual map call results would be the second argument.\n\n**terminateFunc** is either a function that determines if the computation would continue, or a specified number of iterations. The termination function accepts two parameters. The first is the output of the reduce function in the previous iteration and the second is the output of the reduce function in the current iteration. If the function returns a true value, the iterations will end.\n\n**carryover** is a Boolean value indicating whether a map function call produces a carryover object to be passed to the next iteration of the map function call. The default value is false. If it is set to true, the map function has 3 arguments and the last argument is the carryover object, and the map function output is a tuple whose last element is the carryover object. In the first iteration, the carryover object is the NULL object.\n\n#### Details\n\nDolphinDB offers function `imr` for iterative computing based on the map-reduce methodology. Each iteration uses the result from the previous iteration and the input dataset. The input dataset for each iteration is unchanged so that it can be cached. Iterative computing requires initial values for the model parameters and a termination criterion.\n\n#### Examples\n\nThe following is an example of distributed median calculation. The data are distributed on multiple nodes and we would like to calculate the median of a variable. First, for each data source, put the data into buckets and use the map function to count the number of data points in each bucket. Then use the reduce function to merge the bucket counts from multiple data sources. Locate the bucket that contains the median. In the next iteration, the chosen bucket is divided into smaller buckets. The iterations will finish when the size of the chosen bucket is no more than the specified number.\n\n```\ndef medMap(data, range, colName){\n   return bucketCount(data[colName], double(range), 1024, true)\n}\n\ndef medFinal(range, result){\n   x= result.cumsum()\n   index = x.asof(x[1025]/2.0)\n   ranges = range[1] - range[0]\n   if(index == -1)\n      return (range[0] - ranges*32):range[1]\n   else if(index == 1024)\n      return range[0]:(range[1] + ranges*32)\n   else{\n      interval = ranges / 1024.0\n      startValue = range[0] + (index - 1) * interval\n      return startValue : (startValue + interval)\n   }\n}\n\n\ndef medEx(ds, colName, range, precision){\n   termFunc = def(prev, cur): cur[1] - cur[0] <= precision\n   return imr(ds, range, medMap{,,colName}, +, medFinal, termFunc).avg()\n}\n```\n"
    },
    "in": {
        "url": "https://docs.dolphindb.com/en/Functions/i/in.html",
        "signatures": [
            {
                "full": "in(X, Y)",
                "name": "in",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [in](https://docs.dolphindb.com/en/Functions/i/in.html)\n\n\n\n#### Syntax\n\nin(X, Y)\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n**Y** is a scalar, vector, dictionary, in-memory table with one column, keyed table, or indexed table.\n\n#### Details\n\nIf *Y* is a scalar:\n\n* If *Y* is of temporal types, check if each element in *X* is equal to *Y*;\n\n* If *Y* is a scalar of other data types, check if *X* and *Y* are equal.\n\nIf *Y* is a NULL value, return false.\n\nIf *Y* is a vector, check if each element of *X* is an element in *Y*.\n\nIf *Y* is a dictionary, check if each element of *X* is a key in the dictionary *Y*.\n\nIf *Y* is an in-memory table with one column, check if each element of *X* appears in the column of *Y*. Note the column cannot be of array vector form.\n\nIf *Y* is a keyed table or an indexed table, check if each element of *X* is a key of *Y*. The number of elements in *X* must equal the number of key columns of *Y*.\n\n#### Examples\n\n```\nin(3 3 5 2, 2 3);\n// output\n[true,true,false,true]\n\nx=dict(INT,DOUBLE);\nx[1, 2, 3]=[4.5, 6.6, 3.2];\nx;\n// output\n3->3.2\n1->4.5\n2->6.6\n\nin(1..6, x);\n// output\n[true,true,true,false,false,false]\n\nt = table(1 3 5 7 9 as id)\n2 3 in t\n// output\n[false,true]\n\nkt = keyedTable(`name`id,1000:0,`name`id`age`department,[STRING,INT,INT,STRING])\ninsert into kt values(`Tom`Sam`Cindy`Emma`Nick, 1 2 3 4 5, 30 35 32 25 30, `IT`Finance`HR`HR`IT)\nin((`Tom`Cindy, 1 3), kt);\n// output\n[true,true]\n\nt1 = indexedTable(`sym`side, 10000:0, `sym`side`price`qty, [SYMBOL,CHAR,DOUBLE,INT])\ninsert into t1 values(`IBM`MSFT`GOOG, ['B','S','B'], 10.01 10.02 10.03, 10 10 20)\nin((`IBM`MSFT, ['S','S']), t1);\n// output\n[false,true]\n```\n\nWhen *X* is a floating-point number and *Y* is an integer, *X* will be converted to the data type of *Y*.\n\n```\nin(10, NULL)\n// output\nfalse\nin('a', 97)\n// output\ntrue\nin(1, 1.1 1.2 1.3)\n// output\nfalse\nin(float(1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8), 1..9)\n// output\n[true,true,true,true,true,true,true,true]\n```\n\n`in` can be used with `select` for range filtering.\n\n```\nselect * from kt where name in [`Tom, `Cindy];\n```\n\n| name  | id | age | department |\n| ----- | -- | --- | ---------- |\n| Tom   | 1  | 30  | IT         |\n| Cindy | 3  | 32  | HR         |\n\nRelated functions: [find](https://docs.dolphindb.com/en/Functions/f/find.html), [binsrch](https://docs.dolphindb.com/en/Functions/b/binsrch.html).\n"
    },
    "indexedSeries": {
        "url": "https://docs.dolphindb.com/en/Functions/i/indexedSeries.html",
        "signatures": [
            {
                "full": "indexedSeries(index, value)",
                "name": "indexedSeries",
                "parameters": [
                    {
                        "full": "index",
                        "name": "index"
                    },
                    {
                        "full": "value",
                        "name": "value"
                    }
                ]
            }
        ],
        "markdown": "### [indexedSeries](https://docs.dolphindb.com/en/Functions/i/indexedSeries.html)\n\n\n\n#### Syntax\n\nindexedSeries(index, value)\n\n#### Arguments\n\n**index** and **value** are vectors of the same length. *index* must be monotonically increasing with no duplicate values.\n\n#### Details\n\n`indexedSeries` supports alignment operations for panel data. When performing binary operations between matrices or vectors, calculations are performed on the corresponding elements, and the shape of these matrices or vectors must be the same.\n\nBut when performing binary operations between indexed series or between indexed series and indexed matrix, the data is automatically aligned according to the row or column labels (index), and the shape of the matrices or series can be the same or not.\n\nThe following binary operations are supported:\n\n* Arithmetic operators and functions: `+`, `-`, `*`, `/`(exact division), `\\`(`ratio`), `%`(`mod`), `pow`\n\n* Logical operators and functions: `<`, `<=`, `>`, `>=`, `==`, `!=`, `<>`, `&&`, `||`, `&`, `|`, `^`\n\n* Sliding window functions: `mwavg`, `mwsum`, `mbeta`, `mcorr`, `mcovar`\n\n* Cumulative window functions: `cumwavg`, `cumwsum`, `cumbeta`, `cumcorr`, `cumcovar`\n\n* Aggregate functions: `wavg`, `wsum`, `beta`, `corr`, `covar`\n\n#### Examples\n\nExample 1. Length can be equal or unequal in operations between indexed series, The data is aligned according to the *index*.\n\n```\ns1 = indexedSeries(2012.01.01..2012.01.04, [10, 20, 30, 40])\ns2 = indexedSeries(2011.12.30..2012.01.01, [50, 60, 70])\nres = s1 + s2\n```\n\n|            | col1 |\n| ---------- | ---- |\n| 2011.12.30 |      |\n| 2011.12.31 |      |\n| 2012.01.01 | 80   |\n| 2012.01.02 |      |\n| 2012.01.03 |      |\n| 2012.01.04 |      |\n\nExample 2. In a calculation with an indexed series and a vector, the length must be equal.\n\n```\ns1 = indexedSeries(2012.01.01..2012.01.04, [10, 20, 30, 40])\nv = [1,2,3,4]\nres = s1+v\n```\n\n|            | col1 |\n| ---------- | ---- |\n| 2012.01.01 | 11   |\n| 2012.01.02 | 22   |\n| 2012.01.03 | 33   |\n| 2012.01.04 | 44   |\n\nExample 3. In a calculation with an indexed series and an indexed matrix, the inputs are aligned based on the *index*.\n\n```\ns1 = indexedSeries(2012.01.01 2012.01.03 2012.01.04 2012.01.06, [10, 20, 30, 40])\nm = matrix(1..6, 11..16).rename!(2012.01.01..2012.01.06,`x`y).setIndexedMatrix!()\ns1 + m\n```\n\n|            | IBM | MSFT |\n| ---------- | --- | ---- |\n| 2012.01.01 | 11  | 21   |\n| 2012.01.02 |     |      |\n| 2012.01.03 | 23  | 33   |\n| 2012.01.04 | 34  | 44   |\n| 2012.01.05 |     |      |\n| 2012.01.06 | 46  | 56   |\n\nExample 4. In a calculation with an indexed series and a matrix without *index*, they must be of the same length.\n\n```\ns1 = indexedSeries(2012.01.01..2012.01.04, [10, 20, 30, 40])\nm = matrix([1,1,1,1], [2,2,2,2])\nres = s1 pow m\n```\n\n| col1 | col2  |\n| ---- | ----- |\n| 10   | 100   |\n| 20   | 400   |\n| 30   | 900   |\n| 40   | 1,600 |\n"
    },
    "indexedTable": {
        "url": "https://docs.dolphindb.com/en/Functions/i/indexedTable.html",
        "signatures": [
            {
                "full": "indexedTable(keyColumns, X, [X1], [X2], .....)",
                "name": "indexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "indexedTable(keyColumns, capacity:size, colNames, colTypes)",
                "name": "indexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            },
            {
                "full": "indexedTable(keyColumns, table)",
                "name": "indexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [indexedTable](https://docs.dolphindb.com/en/Functions/i/indexedTable.html)\n\n\n\n#### Syntax\n\nindexedTable(keyColumns, X, \\[X1], \\[X2], .....)\n\nor\n\nindexedTable(keyColumns, capacity:size, colNames, colTypes)\n\nor\n\nindexedTable(keyColumns, table)\n\n#### Arguments\n\n**keyColumns** is a string scalar or vector indicating the name(s) of the primary key column(s). The column type must be INTEGRAL, TEMPORAL or LITERAL.\n\nFor the first scenario: *X*, *X1*, .... are vectors.\n\nFor the second scenario:\n\n**capacity** is the amount of memory (in terms of the number of rows) allocated to the table. When the number of rows exceeds *capacity*, the system will first allocate memory of 1.2\\~2 times of *capacity*, copy the data to the new memory space, and release the original memory. For large tables, these steps may use significant amount of memory.\n\n**size** can be 0 or 1, indicating the initial size (in terms of the number of rows) of the table. It must be 0 if the table contains array vector columns.\n\n* If size=0, create an empty table.\n\n* If size=1, create a table with one record, and the initialized values are:\n\n  * false for Boolean type.\n\n  * 0 for numeric, temporal, IPADDR, COMPLEX, and POINT types.\n\n  * NULL for LITERAL and INT128 types.\n\n**colNames** is a string vector of column names.\n\n**colTypes** is a string vector of data types.\n\nFor the third scenario, **table** is a table. Please note that *keyColumns* cannot have duplicate values.\n\n#### Details\n\nCreate an indexed table, which is a special type of in-memory table with primary key. The primary key can be one column or multiple columns. The indexed table uses a red-black tree to store the primary key index. During queries, as long as the query conditions include the first column of the primary key, data can be located through the index without performing a full table scan. It is recommended to use [sliceByKey](https://docs.dolphindb.com/en/Functions/s/sliceByKey.html) to improve query performance.\n\nWhen adding new records to the table, if the primary key of the new record duplicates an existing record, the system updates the record in the table; otherwise, the new record is added to the table.\n\nThe following compares the query optimization techniques for indexed and keyed tables.\n\nFor indexed tables:\n\n* The first column of *keyColumns* must be queried, and filter conditions for this column can only use `=`, `in`, or `and`.\n* Columns other than the first column of *keyColumns* can use range queries through `between`, comparison operators, etc., with higher query efficiency than using the `in` predicate.\n* The number of distinct columns filtered with `in` should not exceed 2.\n\nFor keyed tables:\n\n* All *keyColumns* must be queried. For such queries, key tables show better performance than indexed tables.\n* Filter conditions can only use `=`, `in`, or `and`.\n* The number of distinct columns filtered with `in` should not exceed 2.\n\nQuery Optimization:\n\n1. If the filtering conditions in a SQL statement satisfy the following conditions at the same time, query performance on an indexed table is optimized and is better than that on an ordinary in-memory table:\n\n   * The query contains the first key column in *keyColumns*, the filtering condition for the first key column uses only `=` or `in` operator, and it is not followed by an `or` clause;\n   * There are at most 2 `in` operators\n2. When querying an indexed table, it is recommended to use [sliceByKey](https://docs.dolphindb.com/en/Functions/s/sliceByKey.html) to improve performance.\n3. For comparison, please refer to the optimized SQL query in [keyed table](https://docs.dolphindb.com/en/Functions/k/keyedTable.html).\n\n#### Examples\n\nExample 1. Create an indexed table.\n\nThe first scenario:\n\n```\nsym=`A`B`C`D`E\nid=5 4 3 2 1\nval=52 64 25 48 71\nt=indexedTable(`sym`id,sym,id,val)\nt;\n```\n\n| sym | id | col1 |\n| --- | -- | ---- |\n| A   | 5  | 52   |\n| B   | 4  | 64   |\n| C   | 3  | 25   |\n| D   | 2  | 48   |\n| E   | 1  | 71   |\n\nThe second scenario:\n\n```\nt=indexedTable(`sym`id,1:0,`sym`id`val,[SYMBOL,INT,INT])\ninsert into t values(`A`B`C`D`E,5 4 3 2 1,52 64 25 48 71);\n```\n\nThe third scenario:\n\n```\ntmp=table(sym, id, val)\nt=indexedTable(`sym`id, tmp);\n```\n\nCreate an indexed in-memory partitioned table:\n\n```\nt=indexedTable(`sym`id,sym,id,val)\ndb=database(\"\",VALUE, sym)\npt=db.createPartitionedTable(t,`pt,`sym).append!(t);\n```\n\nExample 2. Update an indexed table.\n\n```\nt=indexedTable(`sym,1:0,`sym`datetime`price`qty,[SYMBOL,DATETIME,DOUBLE,DOUBLE])\ninsert into t values(`APPL`IBM`GOOG,2018.06.08T12:30:00 2018.06.08T12:30:00 2018.06.08T12:30:00,50.3 45.6 58.0,5200 4800 7800)\nt;\n```\n\n| sym  | datetime            | price | qty  |\n| ---- | ------------------- | ----- | ---- |\n| APPL | 2018.06.08T12:30:00 | 50.3  | 5200 |\n| IBM  | 2018.06.08T12:30:00 | 45.6  | 4800 |\n| GOOG | 2018.06.08T12:30:00 | 58    | 7800 |\n\nInsert a new row with duplicate primary key value as an existing row. The existing row will be overwritten:\n\n```\ninsert into t values(`APPL`IBM`GOOG,2018.06.08T12:30:01 2018.06.08T12:30:01 2018.06.08T12:30:01,65.8 45.2 78.6,5800 8700 4600)\nt;\n```\n\n| sym  | datetime            | price | qty  |\n| ---- | ------------------- | ----- | ---- |\n| APPL | 2018.06.08T12:30:01 | 65.8  | 5800 |\n| IBM  | 2018.06.08T12:30:01 | 45.2  | 8700 |\n| GOOG | 2018.06.08T12:30:01 | 78.6  | 4600 |\n\nThe primary key cannot be updated:\n\n```\nupdate t set sym=\"C_\"+sym;\n// Error: Can't update a key column.\n```\n\nExample 3. Query on an indexed table.\n\nIn some cases, queries on an indexed table are optimized. In this section we will compare the performance of queries on indexed tables vs ordinary in-memory tables.\n\nFor the following examples, we first create an ordinary in-memory table *t* and an indexed table *t1* with 1 million records each:\n\n```\nid=shuffle(1..1000000)\ndate=take(2012.06.01..2012.06.10, 1000000)\ntype=take(0..9, 1000000)\nval=rand(100.0, 1000000)\nt=table(id, date, type, val)\nt1=indexedTable(`id`date`type, id, date, type, val);\n```\n\nUse the first key column in the filtering condition:\n\n```\ntimer(100) select * from t where id=500000;\n// Time elapsed: 177.286 ms\n\ntimer(100) select * from t1 where id=500000;\n// Time elapsed: 1.245 ms\n\ntimer(100) sliceByKey(t1, 500000)\n// Time elapsed: 0.742 ms\n\ntimer(100) select * from t where id in [500000, 600000, 700000];\n// Time elapsed: 1134.429 ms\n\ntimer(100) select * from t1 where id in [500000, 600000, 700000];\n// Time elapsed: 1.377 ms\n```\n\nIf the filtering condition for the first key column does not use `=` or the `in` operator, then the performance of a query on an indexed table is not optimized:\n\n```\ntimer(100) select * from t where id between 500000:500010;\n// Time elapsed: 641.544 ms\n\ntimer(100) select * from t1 where id between 500000:500010;\n// Time elapsed: 599.752 ms\n```\n\nUse the first key column and the third key column in the filtering conditions:\n\n```\ntimer(100) select * from t where id=500000, type in [3,6];\n// Time elapsed: 172.808 ms\n\ntimer(100) select * from t1 where id=500000, type in [3,6];\n// Time elapsed: 1.664 ms\n```\n\nIf the filtering conditions do not use the first key column, then the performance of a query on an indexed table is not optimized:\n\n```\ntimer(100) select * from t where date in [2012.06.03, 2012.06.06];\n// Time elapsed: 490.182 ms\n\ntimer(100) select * from t1 where date in [2012.06.03, 2012.06.06];\n// Time elapsed: 544.015 ms\n\ntimer(100) select * from t where date=2012.06.03, type=8;\n// Time elapsed: 205.443 ms\n\ntimer(100) select * from t1 where date=2012.06.03, type=8;\n// Time elapsed: 204.532 ms\n```\n\nWith more than 2 `in` operators in the filtering conditions, the performance of a query on an indexed table is not optimized:\n\n```\ntimer(100) select * from t where id in [100,200], date in [2012.06.03, 2012.06.06], type in [3,6];\n// Time elapsed: 208.714 ms\n\ntimer(100) select * from t1 where id in [100,200], date in [2012.06.03, 2012.06.06], type in [3,6];\n// Time elapsed: 198.674 ms\n```\n\nExample 4. Use an indexed table with array vectors to record the 5 levels of quotes data.\n\n```\nsym=[\"a\",\"b\",\"c \"] \ntime=22:58:52.827 22:58:53.627 22:58:53.827 \nvolume=array(INT[]).append!([[100,110,120,115,125],[200,230,220,225,230],[320,300,310,315,310]])\nprice=array(DOUBLE[]).append!([[10.5,10.6,10.7,10.77,10.85],[8.6,8.7,8.76,8.83,8.9],[6.3,6.37,6.42,6.48,6.52]])\nt=indexedTable(`sym,sym,time,volume,price)\nt;\n```\n\n| sym | time         | volume                     | price                             |\n| --- | ------------ | -------------------------- | --------------------------------- |\n| a   | 22:58:52.827 | \\[100, 110, 120, 115, 125] | \\[10.5, 10.6, 10.7, 10.77, 10.85] |\n| b   | 22:58:53.627 | \\[200, 230, 220, 225, 230] | \\[8.6, 8.7, 8.76, 8.83, 8.9]      |\n| c   | 22:58:53.827 | \\[320, 300, 310, 315, 310] | \\[6.3, 6.37, 6.42, 6.48, 6.52]    |\n\n```\n// latest quote volume and price\nnewVolume=array(INT[]).append!([[130,110,110,115,120]])\nnewPrice= array(DOUBLE[]).append!([[10.55,10.57,10.62,10.68,10.5]])\n// update for stock a\nupdate t set volume=newVolume, price=newPrice where sym=\"a\"\nt;\n```\n\n| sym | time         | volume                     | price                               |\n| --- | ------------ | -------------------------- | ----------------------------------- |\n| a   | 22:58:52.827 | \\[130, 110, 110, 115, 120] | \\[10.55, 10.57, 10.62, 10.68, 10.5] |\n| b   | 22:58:53.627 | \\[200, 230, 220, 225, 230] | \\[8.6, 8.7, 8.76, 8.83, 8.9]        |\n| c   | 22:58:53.827 | \\[320, 300, 310, 315, 310] | \\[6.3, 6.37, 6.42, 6.48, 6.52]      |\n\nNote that when updating the array vector column, the number of elements in each column must be consistent with the original column. For example, if the vector of new record contains 4 elements, while the original contains 5 elements, an error is raised:\n\n```\nnewVolume=array(INT[]).append!([[130,110,110,120]])\nnewPrice= array(DOUBLE[]).append!([[10.55,10.57,10.62,10.5]])\n\nupdate t set volume=newVolume, price=newPrice where sym=\"a\"\n// error: Failed to update column: volume\n```\n\nRelated function: [keyedTable](https://docs.dolphindb.com/en/Functions/k/keyedTable.html)\n"
    },
    "initcap": {
        "url": "https://docs.dolphindb.com/en/Functions/i/initcap.html",
        "signatures": [
            {
                "full": "initcap(X)",
                "name": "initcap",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [initcap](https://docs.dolphindb.com/en/Functions/i/initcap.html)\n\n\n\n#### Syntax\n\ninitcap(X)\n\n#### Parameters\n\n**X** is a STRING scalar/vector, or a SYMBOL vector.\n\n#### Details\n\nThe function returns an object of the same type/form as *X*.\n\nFor words separated by delimiters, the first letter of each word is in uppercase, and all other letters are in lowercase. The delimiters can be any character other than letters or numbers, such as spaces, @, etc.\n\n**Note:**\n\nNumbers are treated as letters.\n\n#### Examples\n\n```\ninitcap(\"hello world\")\n//output\nHello World\n\ninitcap(\"1aBBBBBB\")\n//output\n1abbbbbb\n\ninitcap(\"nihao, hello@you\")\n//output\nNihao, Hello@You\n\ninitcap(\"你好hello\" \"hello You\")\n//output\n[\"你好Hello\",\"Hello You\"]\ninitcap(symbol([\"adhE\",\"\",\"1yI\"]))\n//output\n[\"Adhe\",,\"1yi\"]\n```\n"
    },
    "installPlugin": {
        "url": "https://docs.dolphindb.com/en/Functions/i/installPlugin.html",
        "signatures": [
            {
                "full": "installPlugin(pluginName, [pluginVersion], [pluginServerAddr])",
                "name": "installPlugin",
                "parameters": [
                    {
                        "full": "pluginName",
                        "name": "pluginName"
                    },
                    {
                        "full": "[pluginVersion]",
                        "name": "pluginVersion",
                        "optional": true
                    },
                    {
                        "full": "[pluginServerAddr]",
                        "name": "pluginServerAddr",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [installPlugin](https://docs.dolphindb.com/en/Functions/i/installPlugin.html)\n\n\n\n#### Syntax\n\ninstallPlugin(pluginName, \\[pluginVersion], \\[pluginServerAddr])\n\n#### Arguments\n\n**pluginName** is a string indicating the plugin name.\n\n**pluginVersion** (optional) is a string indicating the plugin version to install. If it is not specified, the latest version will be installed.\n\n**pluginServerAddr** is a string indicating the HTTP address of the DolphinDB plugins repository that the system should use. It is recommended to specify it as \"<http://plugins.dolphindb.com/plugins>\".\n\n#### Details\n\nDownload and extract the shared library and the description file (.txt) of the specified plugin into your DolphinDB plugins directory. It returns the full path of the installed plugin description file, which is required when loading the plugin.\n\n#### Examples\n\nDownload the mysql plugin on Linux:\n\n```\nloadPlugin(\"/home/DolphinDB_Linux64_V2.00.10/server/plugins/mysql/PluginMySQL.txt\")\n// Or\nloadPlugin(\"mysql\")\n\n// output\n/home/DolphinDB_Linux64/server/plugins/mysql/PluginMySQL.txt\n```\n\nLoad the plugin via `loadPlugin`:\n\n```\nloadPlugin(\"/home/DolphinDB_Linux64/server/plugins/mysql/PluginMySQL.txt\")\n// Or you can use plugin name to load the plugin.\nloadPlugin(\"mysql\")\n```\n\nRelated functions: [listRemoteLists](https://docs.dolphindb.com/en/Functions/l/listRemotePlugins.html), [loadPlugin](https://docs.dolphindb.com/en/Functions/l/loadPlugin.html)\n"
    },
    "int": {
        "url": "https://docs.dolphindb.com/en/Functions/i/int.html",
        "signatures": [
            {
                "full": "int(X)",
                "name": "int",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [int](https://docs.dolphindb.com/en/Functions/i/int.html)\n\n\n\n#### Syntax\n\nint(X)\n\n#### Arguments\n\n**X** can be data of any types.\n\n#### Details\n\nConvert X to the data type of INT.\n\n#### Examples\n\n```\nx=int();\nx;\n// output\n00i\ntypestr x;\n// output\nINT\n\nint(`10.9);\n// output\n10\n\nint(2147483647);\n// output\n2147483647\n\nint(2147483648);\n// output\n00i\n// the maximum value for an INT is 2^31-1=2147483647\n```\n"
    },
    "int128": {
        "url": "https://docs.dolphindb.com/en/Functions/i/int128.html",
        "signatures": [
            {
                "full": "int128(X)",
                "name": "int128",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [int128](https://docs.dolphindb.com/en/Functions/i/int128.html)\n\n\n\n#### Syntax\n\nint128(X)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n#### Details\n\nConvert STRING into INT128 data type.\n\n#### Examples\n\n```\na=int128(\"e1671797c52e15f763380b45e841ec32\")\n// output\ne1671797c52e15f763380b45e841ec32\n\ntypestr(a);\n// output\nINT128\n```\n"
    },
    "integral": {
        "url": "https://docs.dolphindb.com/en/Functions/i/integral.html",
        "signatures": [
            {
                "full": "integral(func, start, end, [start2], [end2])",
                "name": "integral",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "start",
                        "name": "start"
                    },
                    {
                        "full": "end",
                        "name": "end"
                    },
                    {
                        "full": "[start2]",
                        "name": "start2",
                        "optional": true
                    },
                    {
                        "full": "[end2]",
                        "name": "end2",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [integral](https://docs.dolphindb.com/en/Functions/i/integral.html)\n\n\n\n#### Syntax\n\nintegral(func, start, end, \\[start2], \\[end2])\n\n#### Arguments\n\n**func** is a unary function.\n\n**start** is a numeric scalar/vector indicating start value. NULL means negative infinity.\n\n**end** is a numeric scalar/vector indicating end value. NULL means positive infinity.\n\n**start2** is a numeric scalar/vector/unary function indicating the start value of the second dimension in double integral. NULL means negative infinity.\n\n**end2** is a numeric scalar/vector/unary function indicating the end value of the second dimension in double integral. NULL means positive infinity.\n\nIf both *start* and *end* are vectors, they must be of the same length.\n\nIf one of *start* and *end* is a scalar and the other is a vector, the scalar is treated as a vector of idential values.\n\n#### Details\n\nReturn the integral of *func* from start to end.\n\nIf the result is infinity or if the calculation involves complex numbers, the result is NULL.\n\n#### Examples\n\n```\nintegral(abs, -10, 10);\n// output\n100\n\nintegral(acos, [0.1, -0.10], [0.3, 0.10]);\n// output\n[0.273816,0.314159]\n\nintegral(acosh, [1, 2, 9, 9], 10);\n// output\n[19.982354,19.080489,2.941187,2.941187]\n\nintegral(pow{,3}, 5, 9);\n// output\n1484\n\nintegral(abs, NULL, NULL);\n// output\n00F\n\ndef f(x1,x2){\n   fx=100*(x2-x1*2)+square(1-x1)\n   return fx\n}\n\nintegral(f,0,1,7,1)\n// output\n-1802\n\nintegral(f,[0,1,2,3],7,2,[0,1,2,3])\n// output\n[8255.333333, 8256, 7856.666667, 7061.333333]\n```\n"
    },
    "interpolate": {
        "url": "https://docs.dolphindb.com/en/Functions/i/interpolate.html",
        "signatures": [
            {
                "full": "interpolate(X, [method='linear'], [limit], [inplace=false], [limitDirection='forward'], [limitArea])",
                "name": "interpolate",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[method='linear']",
                        "name": "method",
                        "optional": true,
                        "default": "'linear'"
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    },
                    {
                        "full": "[inplace=false]",
                        "name": "inplace",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[limitDirection='forward']",
                        "name": "limitDirection",
                        "optional": true,
                        "default": "'forward'"
                    },
                    {
                        "full": "[limitArea]",
                        "name": "limitArea",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [interpolate](https://docs.dolphindb.com/en/Functions/i/interpolate.html)\n\n\n\n#### Syntax\n\ninterpolate(X, \\[method='linear'], \\[limit], \\[inplace=false], \\[limitDirection='forward'], \\[limitArea])\n\n#### Arguments\n\n**X** is a numeric vector.\n\n**method** is a string indicating how to fill the NULL values. It can take the following values and the default value is 'linear'.\n\n* linear: for NULLs surrounded by valid values, fill the NULLs linearly. For NULLs outside valid values, fill the NULLs with the closest valid values.\n\n* pad: fill NULL values with existing values.\n\n* nearest: fill NULL values with the closest valid values.\n\n* krogh: fill NULL values with krogh polynomials.\n\n**limit** is a positive integer indicating the maximum number of consecutive NULL values to fill.\n\n**inplace** is a Boolean value indicating whether to update the input vector array. The default value is false, which means a new vector will be returned.\n\n**limitDirection** is a string indicating the direction to fill NULL values. It can take the following values: 'forward', 'backward' and 'both'. The default value is 'forward'.\n\n**limitArea** is a string indicating restrictions regarding filling NULL values. It can take the following values and the default value is empty string \"\".\n\n* empty string: no restrictions.\n\n* inside: only fill NULLs surrounded by valid values.\n\n* outside: only fill NULLs outside valid values.\n\n#### Details\n\nFill the NULL values in a vector.\n\n#### Examples\n\n```\na=[NULL,NULL,1,2,NULL,NULL,5,6,NULL,NULL];\n\ninterpolate(a);\n// output\n[,,1,2,3,4,5,6,6,6]\n\ninterpolate(X=a, method=\"pad\");\n// output\n[,,1,2,2,2,5,6,6,6]\n\ninterpolate(X=a, limitDirection='both');\n// output\n[1,1,1,2,3,4,5,6,6,6]\n\ninterpolate(X=a, limit=1, limitDirection='both');\n// output\n[,1,1,2,3,4,5,6,6,]\n\ninterpolate(X=a, limitDirection='both', limitArea='outside');\n// output\n[1,1,1,2,,,5,6,6,6]\n\na;\n// output\n[,,1,2,,,5,6,,]\n\ninterpolate(X=a, limitDirection='backward', inplace=true);\n// output\n[1,1,1,2,3,4,5,6,,]\n\na;\n// output\n[1,1,1,2,3,4,5,6,,]\n```\n"
    },
    "intersection": {
        "url": "https://docs.dolphindb.com/en/Functions/i/intersection.html",
        "signatures": [
            {
                "full": "intersection(X, Y)",
                "name": "intersection",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [intersection](https://docs.dolphindb.com/en/Functions/i/intersection.html)\n\n\n\n#### Syntax\n\nintersection(X, Y) or X\\&Y\n\n#### Arguments\n\n**X** and **Y** can be sets, or integer scalars/vectors of the same length.\n\n#### Details\n\nIf both *X* and *Y* are sets, return the intersection of the two sets.\n\nIf *X* and *Y* are integer scalars/vectors, conduct the bitwise operation \"AND\".\n\n#### Examples\n\n```\nx=set([5,5,3,4,6])\ny=set(8 9 4 4 6)\nx & y;\n// output\nset(4,6)\n\n6 7 8 & 4 5 6;\n// output\n[4,5,0]\n```\n"
    },
    "invBeta": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invBeta.html",
        "signatures": [
            {
                "full": "invBeta(alpha, beta, X)",
                "name": "invBeta",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invBeta](https://docs.dolphindb.com/en/Functions/i/invBeta.html)\n\n\n\n#### Syntax\n\ninvBeta(alpha, beta, X)\n\n#### Arguments\n\nThe shape parameters **alpha** and **beta** are positive floating numbers.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of a beta inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvBeta(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0.068102, 0.852866, 0.999994]\n\ninvBeta(2.31, 0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.471316, 0.717156, 0.852866, 0.939378, 0.989912]]\n```\n"
    },
    "invBinomial": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invBinomial.html",
        "signatures": [
            {
                "full": "invBinomial(trials, p, X)",
                "name": "invBinomial",
                "parameters": [
                    {
                        "full": "trials",
                        "name": "trials"
                    },
                    {
                        "full": "p",
                        "name": "p"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invBinomial](https://docs.dolphindb.com/en/Functions/i/invBinomial.html)\n\n\n\n#### Syntax\n\ninvBinomial(trials, p, X)\n\n#### Arguments\n\n**trials** is a positive integer.\n\n**p** is a floating number between 0 and 1.\n\n*trials* and *p* are shape parameters.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of a binomial inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvBinomial(10, 0.1, [0.1, 0.5, 0.9]);\n// output\n[0, 1, 2]\n\ninvBinomial(12,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[5, 7, 8, 8, 10]\n```\n"
    },
    "invChiSquare": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invChiSquare.html",
        "signatures": [
            {
                "full": "invChiSquare(df, X)",
                "name": "invChiSquare",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invChiSquare](https://docs.dolphindb.com/en/Functions/i/invChiSquare.html)\n\n\n\n#### Syntax\n\ninvChiSquare(df, X)\n\n#### Arguments\n\n**df** is a positive integer indicating the degree of freedom of a chi-squared distribution.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of a chi-squared inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvChiSquare(1, [0, 0.05, 0.15, 0.25]);\n// output\n[0, 0.003932, 0.035766, 0.101531]\n\ninvChiSquare(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.015791, 0.148472, 0.454936, 1.074194, 2.705543]\n```\n"
    },
    "inverse": {
        "url": "https://docs.dolphindb.com/en/Functions/i/inverse.html",
        "signatures": [
            {
                "full": "inverse(X)",
                "name": "inverse",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [inverse](https://docs.dolphindb.com/en/Functions/i/inverse.html)\n\n\n\n#### Syntax\n\ninverse(X)\n\n#### Arguments\n\n**X** is a matrix.\n\n#### Details\n\nReturn the inverse matrix of *X* if it is invertible.\n\n#### Examples\n\n```\nx=1..4$2:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\nx.inverse();\n```\n\n| #0 | #1   |\n| -- | ---- |\n| -2 | 1.5  |\n| 1  | -0.5 |\n"
    },
    "invExp": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invExp.html",
        "signatures": [
            {
                "full": "invExp(mean, X)",
                "name": "invExp",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invExp](https://docs.dolphindb.com/en/Functions/i/invExp.html)\n\n\n\n#### Syntax\n\ninvExp(mean, X)\n\n#### Arguments\n\n**mean** is the mean of an exponential distribution.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of an exponential inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvExp(1, [0.05 0.15 0.25 0.35]);\n// output\n[0.051293, 0.162519, 0.287682, 0.430783]\n\ninvExp(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.105361, 0.356675, 0.693147, 1.203973, 2.302585]\n```\n"
    },
    "invF": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invF.html",
        "signatures": [
            {
                "full": "invF(numeratorDF, denominatorDF, X)",
                "name": "invF",
                "parameters": [
                    {
                        "full": "numeratorDF",
                        "name": "numeratorDF"
                    },
                    {
                        "full": "denominatorDF",
                        "name": "denominatorDF"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invF](https://docs.dolphindb.com/en/Functions/i/invF.html)\n\n\n\n#### Syntax\n\ninvF(numeratorDF, denominatorDF, X)\n\n#### Arguments\n\n**numeratorDF** and **denominatorDF** are positive integers indicating degrees of freedom of an F distribution.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of an F inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvF(2.31, 0.627, [0.001, 0.5, 0.7]);\n// output\n[0.002024, 2.69427, 14.992595]\n\ninvF(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.146649, 0.718555, 2.69427, 14.992595, 508.444221]\n```\n"
    },
    "invGamma": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invGamma.html",
        "signatures": [
            {
                "full": "invGamma(shape, scale, X)",
                "name": "invGamma",
                "parameters": [
                    {
                        "full": "shape",
                        "name": "shape"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invGamma](https://docs.dolphindb.com/en/Functions/i/invGamma.html)\n\n\n\n#### Syntax\n\ninvGamma(shape, scale, X)\n\n#### Arguments\n\nThe shape parameter **shape** is a positive floating number.\n\nThe scale parameter **scale** is a positive floating number.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of a gamma inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvGamma(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0.049713, 1.245583, 6.191955]\n\ninvGamma(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.437696, 0.843572, 1.245583, 1.760732, 2.724121]\n```\n"
    },
    "invLogistic": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invLogistic.html",
        "signatures": [
            {
                "full": "invLogistic(mean, s, X)",
                "name": "invLogistic",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "s",
                        "name": "s"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invLogistic](https://docs.dolphindb.com/en/Functions/i/invLogistic.html)\n\n\n\n#### Syntax\n\ninvLogistic(mean, s, X)\n\n#### Arguments\n\n**mean** is the mean of a logistic distribution.\n\n**s** is the scale parameter of a logistic distribution.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of a logistic inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvLogistic( 2.31, 0.627, [0.5, 0.3, 0.5, 0.7, 0.1]);\n// output\n[2.31, 1.778744, 2.31, 2.841256, 0.93234]\n```\n"
    },
    "invNormal": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invNormal.html",
        "signatures": [
            {
                "full": "invNormal(mean, stdev, X)",
                "name": "invNormal",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "stdev",
                        "name": "stdev"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invNormal](https://docs.dolphindb.com/en/Functions/i/invNormal.html)\n\n\n\n#### Syntax\n\ninvNormal(mean, stdev, X)\n\n#### Arguments\n\n**mean** is the mean of a normal distribution.\n\n**stdev** is the standard deviation of a normal distribution.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of a normal inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvNormal(0,1,0.33);\n// output\n-0.439913\n\ninvNormal(10, 20, [0.1 0.2 0.3]);\n// output\n[-15.631031, -6.832425, -0.48801]\n```\n"
    },
    "invPoisson": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invPoisson.html",
        "signatures": [
            {
                "full": "invPoisson(mean, X)",
                "name": "invPoisson",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invPoisson](https://docs.dolphindb.com/en/Functions/i/invPoisson.html)\n\n\n\n#### Syntax\n\ninvPoisson(mean, X)\n\n#### Arguments\n\n**mean** is the mean of a Poisson distribution.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of a Poisson inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvPoisson(1, [0.91, 0.92, 0.93]);\n// output\n[2, 3, 3]\n\ninvPoisson(3, [0.81, 0.83, 0.95, 0.97, 0.99]);\n// output\n[4, 5, 6, 7, 8]\n```\n"
    },
    "invStudent": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invStudent.html",
        "signatures": [
            {
                "full": "invStudent(df, X)",
                "name": "invStudent",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invStudent](https://docs.dolphindb.com/en/Functions/i/invStudent.html)\n\n\n\n#### Syntax\n\ninvStudent(df, X)\n\n#### Arguments\n\n**df** is a positive floating number indicating the degree of freedom of a Student's t-distribution.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of a Student's t inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvStudent(1, [0.15, 0.25, 0.35]);\n// output\n[-1.962611, -1, -0.509525]\n\ninvStudent(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[-3.077684, -0.726543, 0, 0.726543, 3.077684]\n```\n"
    },
    "invUniform": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invUniform.html",
        "signatures": [
            {
                "full": "invUniform(lower, upper, X)",
                "name": "invUniform",
                "parameters": [
                    {
                        "full": "lower",
                        "name": "lower"
                    },
                    {
                        "full": "upper",
                        "name": "upper"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invUniform](https://docs.dolphindb.com/en/Functions/i/invUniform.html)\n\n\n\n#### Syntax\n\ninvUniform(lower, upper, X)\n\n#### Arguments\n\n**lower** and **upper** are numeric scalars indicating the lower bound and upper bound of a continuous uniform distribution.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of an uniform inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvUniform(0.627, 2.31, [0.001, 0.5, 0.999]);\n// output\n[0.628683, 1.4685, 2.308317]\n\ninvUniform(0.627, 2.31, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.7953, 1.1319, 1.4685, 1.8051, 2.1417]\n```\n"
    },
    "invWeibull": {
        "url": "https://docs.dolphindb.com/en/Functions/i/invWeibull.html",
        "signatures": [
            {
                "full": "invWeibull(alpha, beta, X)",
                "name": "invWeibull",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invWeibull](https://docs.dolphindb.com/en/Functions/i/invWeibull.html)\n\n\n\n#### Syntax\n\ninvWeibull(alpha, beta, X)\n\n#### Arguments\n\nThe scale parameter **alpha** and the shape parameter **beta** are both positive floating numbers.\n\n**X** is a floating scalar or vector between 0 and 1.\n\n#### Details\n\nReturn the value of a Weibull inverse cumulative distribution function.\n\n#### Examples\n\n```\ninvWeibull(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0.031525, 0.535009, 1.447494]\n\ninvWeibull(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.236692, 0.401279, 0.535009, 0.679464, 0.899644]\n```\n"
    },
    "ipaddr": {
        "url": "https://docs.dolphindb.com/en/Functions/i/ipaddr.html",
        "signatures": [
            {
                "full": "ipaddr(X)",
                "name": "ipaddr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ipaddr](https://docs.dolphindb.com/en/Functions/i/ipaddr.html)\n\n\n\n#### Syntax\n\nipaddr(X)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n#### Details\n\nConvert STRING into IPADDR (IP address) data type.\n\n#### Examples\n\n```\na=ipaddr(\"192.168.1.13\");\na;\n// output\n192.168.1.13\n\ntypestr(a);\n// output\nIPADDR\n```\n"
    },
    "isAlNum": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isAlNum.html",
        "signatures": [
            {
                "full": "isAlNum(X)",
                "name": "isAlNum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isAlNum](https://docs.dolphindb.com/en/Functions/i/isAlNum.html)\n\n\n\n#### Syntax\n\nisAlNum(X)\n\n#### Arguments\n\n**X** is a STRING scalar or vector.\n\n#### Details\n\nReturn \"true\" if all characters in string X are alphanumeric (either alphabets or numbers).\n\n#### Examples\n\n```\nisAlNum(\"123456\");\n// output\ntrue\n\nisAlNum(\"1And1\");\n// output\ntrue\n\nisAlNum(\"10.05\");\n// output\nfalse\n\nisAlNum(string());\n// output\nfalse\n```\n"
    },
    "isAlpha": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isAlpha.html",
        "signatures": [
            {
                "full": "isAlpha(X)",
                "name": "isAlpha",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isAlpha](https://docs.dolphindb.com/en/Functions/i/isAlpha.html)\n\n\n\n#### Syntax\n\nisAlpha(X)\n\n#### Arguments\n\n**X** is a STRING scalar or vector.\n\n#### Details\n\nReturn \"true\" if all characters in the string are alphabets. For STRING type NULLs, return \"false\".\n\n#### Examples\n\n```\nisAlpha(\"hello\");\n// output\ntrue\n\nisAlpha(\"hello world\");\n// output\nfalse\n\nisAlpha(\"1And1\");\n// output\nfalse\n\nisAlpha(string());\n// output\nfalse\n```\n"
    },
    "isChunkNodeInit": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isChunkNodeInit.html",
        "signatures": [
            {
                "full": "isDataNodeInitialized()",
                "name": "isDataNodeInitialized",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [isChunkNodeInit](https://docs.dolphindb.com/en/Functions/i/isChunkNodeInit.html)\n\nAlias for [isDataNodeInitialized](https://docs.dolphindb.com/en/Functions/i/isDataNodeInitialized.html)\n\n\nDocumentation for the `isDataNodeInitialized` function:\n### [isDataNodeInitialized](https://docs.dolphindb.com/en/Functions/i/isDataNodeInitialized.html)\n\n\n\n#### Syntax\n\nisDataNodeInitialized()\n\nAlias: isChunkNodeInit\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn true if the current node has been started; return false otherwise. The function can only be executed on data nodes or compute nodes and cannot be executed on agent or controller nodes.\n\n#### Examples\n\n```\nisDataNodeInitialized()\n// output\ntrue\n```\n"
    },
    "isColumnarTuple": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isColumnarTuple.html",
        "signatures": [
            {
                "full": "isColumnarTuple(X)",
                "name": "isColumnarTuple",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isColumnarTuple](https://docs.dolphindb.com/en/Functions/i/isColumnarTuple.html)\n\n#### Syntax\n\nisColumnarTuple(X)\n\n#### Arguments\n\n**X** is a tuple.\n\n#### Details\n\nCheck if *X* is a columnar tuple.\n\n#### Examples\n\n```\ntp = [[1,2,3], [4,5,6], [7,8]]\nisColumnarTuple(tp)\n// output    \nfalse\n\ntp.setColumnarTuple!()\nisColumnarTuple(tp)\n// output\ntrue\n```\n\n```\nid = 3 2 1 4\nval = [`aa`bb, `aa`cc`dd, `bb, `cc`dd]\nt = table(id, val)\n\nisColumnarTuple(t.val)\n// output\ntrue\n\nisColumnarTuple(t.id)\n// output\nfalse\n\nexec isColumnarTuple(val) from t\n// output\ntrue\n\nav = array(INT[], 0, 10).append!([1 1 1 3, 2 4 2 5, 8 9 7 1, 5 4 3])\nt = table(id, av)\nisColumnarTuple(t.av)\n// output\nfalse\n```\n\n"
    },
    "isControllerInitialized": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isControllerInitialized.html",
        "signatures": [
            {
                "full": "isControllerInitialized()",
                "name": "isControllerInitialized",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [isControllerInitialized](https://docs.dolphindb.com/en/Functions/i/isControllerInitialized.html)\n\n\n\n#### Syntax\n\nisControllerInitialized()\n\n#### Arguments\n\nNone\n\n#### Details\n\nCheck whether the controller is initialized. True if it is initialized, otherwise false. In a cluster, it is called only on the controller; in a cluster with high-availability enabled, it is called only on the leader.\n\n#### Example\n\n```\nisControllerInitialized()\n// output\ntrue\n```\n\nRelated Functions: [isDataNodeInitialized](https://docs.dolphindb.com/en/Functions/i/isDataNodeInitialized.html)\n"
    },
    "isDataNodeInitialized": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isDataNodeInitialized.html",
        "signatures": [
            {
                "full": "isDataNodeInitialized()",
                "name": "isDataNodeInitialized",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [isDataNodeInitialized](https://docs.dolphindb.com/en/Functions/i/isDataNodeInitialized.html)\n\n\n\n#### Syntax\n\nisDataNodeInitialized()\n\nAlias: isChunkNodeInit\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn true if the current node has been started; return false otherwise. The function can only be executed on data nodes or compute nodes and cannot be executed on agent or controller nodes.\n\n#### Examples\n\n```\nisDataNodeInitialized()\n// output\ntrue\n```\n"
    },
    "isDigit": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isDigit.html",
        "signatures": [
            {
                "full": "isDigit(X)",
                "name": "isDigit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isDigit](https://docs.dolphindb.com/en/Functions/i/isDigit.html)\n\n\n\n#### Syntax\n\nisDigit(X)\n\n#### Arguments\n\n**X** is a STRING scalar or vector.\n\n#### Details\n\nReturn \"true\" if all characters in the string are numbers. For STRING type NULLs, return \"false\".\n\n#### Examples\n\n```\nisDigit(\"123456\");\n// output\ntrue\n\nisDigit(\"1And1\");\n// output\nfalse\n\nisDigit(\"10.05\");\n// output\nfalse\n\nisDigit(string());\n// output\nfalse\n```\n"
    },
    "isDuplicated": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isDuplicated.html",
        "signatures": [
            {
                "full": "isDuplicated(X, [keep=FIRST])",
                "name": "isDuplicated",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[keep=FIRST]",
                        "name": "keep",
                        "optional": true,
                        "default": "FIRST"
                    }
                ]
            }
        ],
        "markdown": "### [isDuplicated](https://docs.dolphindb.com/en/Functions/i/isDuplicated.html)\n\n\n\n#### Syntax\n\nisDuplicated(X, \\[keep=FIRST])\n\n#### Arguments\n\n**X** is a vector or a tuple of vectors of same length.\n\n**keep** can take the value of FIRST, LAST or NONE. It indicates how the system processes duplicate values. The default value is FIRST.\n\n#### Details\n\nReturn a vector or a tuple of vectors of Boolean values. If an element has no duplicate values, it returns 0.\n\n* If keep=FIRST, the first duplicate value returns 0 while all other duplicate values return 1.\n\n* If keep=LAST, the last duplicate value returns 0 while all other duplicate values return 1.\n\n* If keep=NONE, all duplicate values return 1.\n\n#### Examples\n\n```\nv = [1,3,1,-6,NULL,2,NULL,1]\nisDuplicated(v,FIRST);\n// output\n[false,false,true,false,false,false,true,true]\n// 1 appears three time in v, the locations are the 0th, the 2nd and the 7th. Since keep = FIRST, the 0th result is set to false, and the 2nd and 7th results are set to true.\n\nv = [1,3,1,-6,NULL,2,NULL,1]\nisDuplicated(v,LAST);\n// output\n[true,false,true,false,true,false,false,false]\n// 1 appears three time in v, the locations are the the 0th, the 2nd and the 7th. Since keep = LAST, the 7th result is set to false, and the 0th and 2nd results are set to true.\n\nv = [1,3,1,-6,NULL,2,NULL,1]\nisDuplicated(v,NONE);\n// output\n[true,false,true,false,true,false,true,true]\n// 1 appears three time in v, the locations are the 0th, the 2nd and the 7th. Since keep = NONE, the 0th, the 2nd and the 7th result are all set to true.\n```\n\nTo delete duplicate records from a table:\n\n```\nt=table(1 2 4 8 4 2 7 1 as id, 10 20 40 80 40 20 70 10 as val);\nt;\n```\n\n| id | val |\n| -- | --- |\n| 1  | 10  |\n| 2  | 20  |\n| 4  | 40  |\n| 8  | 80  |\n| 4  | 40  |\n| 2  | 20  |\n| 7  | 70  |\n| 1  | 10  |\n\n```\nselect * from t where isDuplicated([id,val],FIRST)=false;\n//Onlt keep the first duplicated record and delete the others.\n```\n\n| id | val |\n| -- | --- |\n| 1  | 10  |\n| 2  | 20  |\n| 4  | 40  |\n| 8  | 80  |\n| 7  | 70  |\n\nSince version 2.00.13/3.00.1, the `isDuplicated` function supports the BLOB data.\n\n```\na=[blob(\"s1\"), blob(\"s2\")]\nisDuplicated(a)\n//output: [false, false]\na1=[blob(\"s1\"), blob(\"s2\"), blob(\"s1\"), blob(\"s2\")]\nisDuplicated(a1)\n//output: [false, false, true, true]\n```\n"
    },
    "isIndexedMatrix": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isIndexedMatrix.html",
        "signatures": [
            {
                "full": "isIndexedMatrix(X)",
                "name": "isIndexedMatrix",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isIndexedMatrix](https://docs.dolphindb.com/en/Functions/i/isIndexedMatrix.html)\n\n\n\n#### Syntax\n\nisIndexedMatrix(X)\n\n#### Arguments\n\n**X** is a matrix.\n\n#### Details\n\nDetermine if *X* is an indexed matrix.\n\n#### Examples\n\n```\nm=matrix(1..10, 11..20)\nm.rename!(2020.01.01..2020.01.10, `A`B);\n\nisIndexedMatrix(m);\n// output\nfalse\n\nm.setIndexedMatrix!()\nisIndexedMatrix(m);\n// output\ntrue\n```\n"
    },
    "isIndexedSeries": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isIndexedSeries.html",
        "signatures": [
            {
                "full": "isIndexedSeries(X)",
                "name": "isIndexedSeries",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isIndexedSeries](https://docs.dolphindb.com/en/Functions/i/isIndexedSeries.html)\n\n\n\n#### Syntax\n\nisIndexedSeries(X)\n\n#### Arguments\n\n**X** is a matrix with only 1 column.\n\n#### Details\n\nDetermine if *X* is an indexed series.\n\n#### Examples\n\n```\ns=matrix(1..10).rename!(2020.01.01..2020.01.10, );\n\nisIndexedSeries(s);\n// output\nfalse\n\ns.setIndexedSeries!()\nisIndexedSeries(s);\n// output\ntrue\n```\n"
    },
    "isLeapYear": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isLeapYear.html",
        "signatures": [
            {
                "full": "isLeapYear(X)",
                "name": "isLeapYear",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isLeapYear](https://docs.dolphindb.com/en/Functions/i/isLeapYear.html)\n\n\n\n#### Syntax\n\nisLeapYear(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nDetermine if each element in *X* is in a leap year.\n\n#### Examples\n\n```\nisLeapYear(2012.06.12T12:30:00);\n// output\ntrue\n\nisLeapYear([2012.01.01,2013.01.01,2014.01.01,2015.01.01]);\n// output\n[true,false,false,false]\n```\n"
    },
    "isLoggedIn": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isLoggedIn.html",
        "signatures": [
            {
                "full": "isLoggedIn(userId)",
                "name": "isLoggedIn",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    }
                ]
            }
        ],
        "markdown": "### [isLoggedIn](https://docs.dolphindb.com/en/Functions/i/isLoggedIn.html)\n\n\n\n#### Syntax\n\nisLoggedIn(userId)\n\n#### Arguments\n\n**userId** a string indicating a user name. It can only contain letters, underscores, or numbers. It cannot start with numbers. The length cannot exceed 30 characters.\n\n#### Details\n\nReturn a Boolean value indicating whether the specified user is logged in.\n\n#### Examples\n\n```\nisLoggedIn(`AlexSmith)\n// output\nfalse\n```\n"
    },
    "isLower": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isLower.html",
        "signatures": [
            {
                "full": "isLower(X)",
                "name": "isLower",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isLower](https://docs.dolphindb.com/en/Functions/i/isLower.html)\n\n\n\n#### Syntax\n\nisLower(X)\n\n#### Arguments\n\n**X** is a STRING scalar or vector.\n\n#### Details\n\nCheck whether all the case-based characters (letters) of the string are lowercase.\n\n#### Examples\n\n```\nisLower(\"this is string example....wow!!!\");\n// output\ntrue\n\nisLower(\"THIS is string example....wow!!!\");\n// output\nfalse\n\nisLower(\"123456abc\");\n// output\ntrue\n\nisLower(\"123\");\n// output\nfalse\n\nisLower([\"  \",string()]);\n// output\n[false,false]\n```\n\nRelated funcitons: [isUpper](https://docs.dolphindb.com/en/Functions/i/isUpper.html), [isTitle](https://docs.dolphindb.com/en/Functions/i/isTitle.html)\n"
    },
    "isMonotonic": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isMonotonic.html",
        "signatures": [
            {
                "full": "isMonotonicIncreasing(X)",
                "name": "isMonotonicIncreasing",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isMonotonic](https://docs.dolphindb.com/en/Functions/i/isMonotonic.html)\n\nAlias for [isMonotonicIncreasing](https://docs.dolphindb.com/en/Functions/i/isMonotonicIncreasing.html)\n\n\nDocumentation for the `isMonotonicIncreasing` function:\n### [isMonotonicIncreasing](https://docs.dolphindb.com/en/Functions/i/isMonotonicIncreasing.html)\n\n\n\n#### Syntax\n\nisMonotonicIncreasing(X)\n\nAlias: isMonotonic\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n#### Details\n\nCheck whether the elements in *X* are monotonically increasing.\n\n#### Examples\n\n```\na = [2023.01M,2023.02M,2023.03M,2023.04M,2023.05M,2023.06M]\nisMonotonicIncreasing(a);\n// output\ntrue\n\na = [1,3,6,5,7,9]\nisMonotonicIncreasing(a);\n// output\nfalse\n\na = [1,3,3,5,7,9]\nisMonotonicIncreasing(a);\n// output\ntrue\n\na = [NULL,1,3,5,7,9]\nisMonotonicIncreasing(a);\n// output\ntrue\n\na = [1,3,5,NULL,7,9]\nisMonotonicIncreasing(a);\n// output\nfalse\n```\n\nRelated functions: [isMonotonicDecreasing](https://docs.dolphindb.com/en/Functions/i/isMonotonicDecreasing.html), [isMonotonic](https://docs.dolphindb.com/en/Functions/i/isMonotonic.html)\n"
    },
    "isMonotonicDecreasing": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isMonotonicDecreasing.html",
        "signatures": [
            {
                "full": "isMonotonicDecreasing(X)",
                "name": "isMonotonicDecreasing",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isMonotonicDecreasing](https://docs.dolphindb.com/en/Functions/i/isMonotonicDecreasing.html)\n\n\n\n#### Syntax\n\nisMonotonicDecreasing(X)\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n#### Details\n\nCheck whether the elements in *X* are monotonically decreasing.\n\n#### Examples\n\n```\na = [10,8,6,4,2]\nisMonotonicDecreasing(a);\n// output\ntrue\n\na = [10,8,6,7,2]\nisMonotonicDecreasing(a);\n// output\nfalse\n\na = [10,8,6,6,4,2]\nisMonotonicDecreasing(a);\n// output\ntrue\n\na = [10,8,6,NULL,4,2]\nisMonotonicDecreasing(a);\n// output\nfalse\n\na = [10,8,6,4,2,NULL]\nisMonotonicDecreasing(a);\n// output\ntrue\n```\n\nRelated functions: [isMonotonicIncreasing](https://docs.dolphindb.com/en/Functions/i/isMonotonicIncreasing.html), [isMonotonic](https://docs.dolphindb.com/en/Functions/i/isMonotonic.html)\n"
    },
    "isMonotonicIncreasing": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isMonotonicIncreasing.html",
        "signatures": [
            {
                "full": "isMonotonicIncreasing(X)",
                "name": "isMonotonicIncreasing",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isMonotonicIncreasing](https://docs.dolphindb.com/en/Functions/i/isMonotonicIncreasing.html)\n\n\n\n#### Syntax\n\nisMonotonicIncreasing(X)\n\nAlias: isMonotonic\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n#### Details\n\nCheck whether the elements in *X* are monotonically increasing.\n\n#### Examples\n\n```\na = [2023.01M,2023.02M,2023.03M,2023.04M,2023.05M,2023.06M]\nisMonotonicIncreasing(a);\n// output\ntrue\n\na = [1,3,6,5,7,9]\nisMonotonicIncreasing(a);\n// output\nfalse\n\na = [1,3,3,5,7,9]\nisMonotonicIncreasing(a);\n// output\ntrue\n\na = [NULL,1,3,5,7,9]\nisMonotonicIncreasing(a);\n// output\ntrue\n\na = [1,3,5,NULL,7,9]\nisMonotonicIncreasing(a);\n// output\nfalse\n```\n\nRelated functions: [isMonotonicDecreasing](https://docs.dolphindb.com/en/Functions/i/isMonotonicDecreasing.html), [isMonotonic](https://docs.dolphindb.com/en/Functions/i/isMonotonic.html)\n"
    },
    "isMonthEnd": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isMonthEnd.html",
        "signatures": [
            {
                "full": "isMonthEnd(X)",
                "name": "isMonthEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isMonthEnd](https://docs.dolphindb.com/en/Functions/i/isMonthEnd.html)\n\n\n\n#### Syntax\n\nisMonthEnd(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nDetermine if each element in *X* is the last day of a month.\n\n#### Examples\n\n```\nisMonthEnd(2012.05.31);\n// output\ntrue\n\nisMonthEnd([2012.05.30,2012.05.31]);\n// output\n[false,true]\n```\n\nRelated function: [isMonthStart](https://docs.dolphindb.com/en/Functions/i/isMonthStart.html)\n"
    },
    "isMonthStart": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isMonthStart.html",
        "signatures": [
            {
                "full": "isMonthStart(X)",
                "name": "isMonthStart",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isMonthStart](https://docs.dolphindb.com/en/Functions/i/isMonthStart.html)\n\n\n\n#### Syntax\n\nisMonthStart(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nDetermine if each element in *X* is the first day of a month.\n\n#### Examples\n\n```\nisMonthStart(2012.05.01);\n// output\ntrue\n\nisMonthStart([2012.05.01,2012.05.02]);\n// output\n[true,false]\n```\n\nRelated function: [isMonthEnd](https://docs.dolphindb.com/en/Functions/i/isMonthEnd.html)\n"
    },
    "isNanInf": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isNanInf.html",
        "signatures": [
            {
                "full": "isNanInf(X, [includeNull=false])",
                "name": "isNanInf",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[includeNull=false]",
                        "name": "includeNull",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [isNanInf](https://docs.dolphindb.com/en/Functions/i/isNanInf.html)\n\n\n\n#### Syntax\n\nisNanInf(X, \\[includeNull=false])\n\n#### Arguments\n\n**X** is a DOUBLE type scalar, vector or matrix.\n\n**includeNull** is a BOOLEAN.\n\n#### Details\n\nCheck each element in *X* to see if it is a NaN/Inf value. Return a BOOLEAN type of the same length as *X*. If *includeNull* is set to true, NULL values will return true. The default value of *includeNull* is false.\n\nRelated function: [countNanInf](https://docs.dolphindb.com/en/Functions/c/countNanInf.html)\n"
    },
    "isNothing": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isNothing.html",
        "signatures": [
            {
                "full": "isNothing(X)",
                "name": "isNothing",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isNothing](https://docs.dolphindb.com/en/Functions/i/isNothing.html)\n\n\n\n#### Syntax\n\nisNothing(X)\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n#### Details\n\n\"Nothing\" is one of the two objects in VOID type.\n\n`isNothing` tests if a function argument is provided by the user.\n\n#### Examples\n\n```\nf=def(x,y): isNothing(y);\nf(5,);\n// output\ntrue\n\nf(5, NULL);\n// output\nfalse\n```\n"
    },
    "isNull": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isNull.html",
        "signatures": [
            {
                "full": "isNull(X)",
                "name": "isNull",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isNull](https://docs.dolphindb.com/en/Functions/i/isNull.html)\n\n\n\n#### Syntax\n\nisNull(X)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix.\n\n#### Details\n\nReturn true if an element is NULL.\n\n#### Examples\n\n```\nisNull(00i);\n// output\ntrue\n\nisNull(1 NULL NULL 6 NULL 7);\n// output\n[false,true,true,false,true,false]\n\nisNull(1/0);\n// output\n1\n\nx=1 NULL 5 NULL 4 6$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 5  | 4  |\n|    |    | 6  |\n\n```\nisNull(x);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 0  | 0  |\n| 1  | 1  | 0  |\n\nRelated functions: [hasNull](https://docs.dolphindb.com/en/Functions/h/hasNull.html), [nullFill](https://docs.dolphindb.com/en/Functions/n/nullFill.html)\n"
    },
    "isNumeric": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isNumeric.html",
        "signatures": [
            {
                "full": "isNumeric(X)",
                "name": "isNumeric",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isNumeric](https://docs.dolphindb.com/en/Functions/i/isNumeric.html)\n\n\n\n#### Syntax\n\nisNumeric(X)\n\n#### Arguments\n\n**X** is a STRING scalar or vector.\n\n#### Details\n\nReturn true if all characters in the string are numbers. For STRING type NULLs, return false.\n\n#### Examples\n\n```\nisNumeric(\"123456\");\n// output\ntrue\n\nisNumeric(\"1And1\");\n// output\nfalse\n\nisNumeric(\"10.05\");\n// output\nfalse\n\nisNumeric(string());\n// output\nfalse\n```\n"
    },
    "isOrderedDict": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isOrderedDict.html",
        "signatures": [
            {
                "full": "isOrderedDict(X)",
                "name": "isOrderedDict",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isOrderedDict](https://docs.dolphindb.com/en/Functions/i/isOrderedDict.html)\n\n\n\n#### Syntax\n\nisOrderedDict(X)\n\n#### Arguments\n\n`X` is a dictionary.\n\n#### Details\n\nThe function returns \"true\" if *X* is an ordered dictionary.\n\n#### Examples\n\n```\nx=1 2 3\ny=4.5 7.8 4.3\nz=dict(x,y);\nisOrderedDict(z)\n// output\nfalse\n\nz1=dict(x,y,true);\nisOrderedDict(z1)\n// output\ntrue\n```\n"
    },
    "isort!": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isort!.html",
        "signatures": [
            {
                "full": "isort!(X, [ascending=true], indices)",
                "name": "isort!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "indices",
                        "name": "indices"
                    }
                ]
            }
        ],
        "markdown": "### [isort!](https://docs.dolphindb.com/en/Functions/i/isort!.html)\n\n\n\n#### Syntax\n\nisort!(X, \\[ascending=true], indices)\n\n#### Arguments\n\n**X** is a vector or a tuple of vectors of the same length.\n\n**ascending** is a Boolean scalar indicating whether to sort *X* (or vectors of *X* sequentially) in ascending order or descending order. The default value is true (ascending order).\n\n**indices** is a vector of the same length as each vector in *X*.\n\n#### Details\n\n`isort!(x, ascending, y)` is equivalent to `y[isort(x,ascending)]`. The result is assigned to *y*.\n\n#### Examples\n\n```\nx=3 1 NULL 2\ny=5 7 8 3\nisort!(x, false, y);\n// output\n[5, 3, 7, 8]\n// after sorted, x is [3, 2, 1, NULL], the first element 3 is corresponding to 5 in y, the second element 2 is corresponding to 3 in y, the third element 1 is corresponding to 7 in y, ... and so on.\n\nx=2 2 1 1\ny=2 1 1 2\nisort!([x,y],[1,0],5 4 3 2);\n// output\n[2,3,5,4]\n```\n"
    },
    "isort": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isort.html",
        "signatures": [
            {
                "full": "isort(X, [ascending=true])",
                "name": "isort",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [isort](https://docs.dolphindb.com/en/Functions/i/isort.html)\n\n\n\n#### Syntax\n\nisort(X, \\[ascending=true])\n\n#### Arguments\n\n**X** is a vector or a tuple of vectors of the same length.\n\n**ascending** is a Boolean scalar or vector indicating whether to sort *X* (or vectors of *X* sequentially) in ascending order or descending order. The default value is true (ascending order).\n\n#### Details\n\nInstead of returning a sorted vector like [sort!](https://docs.dolphindb.com/en/Functions/s/sort!.html), `isort` returns the indexes in the original vector for each element in the sorted vector.\n\n`X[isort X]` is equivalent to `sort!(X)`.\n\n#### Examples\n\n```\nx = 4 1 3 2;\ny = isort(x);\ny;\n// output\n[1,3,2,0]\n// for the sorted x: [1 2 3 4], the first element 1 is from position 1 of the original x, the second element 2 is from position 3 of the original x, ... etc.\nx[y];\n// output\n[1,2,3,4]\n// equivalent to sort!(x)\n\nz=isort(x, false);\nz;\n// output\n[0,2,3,1]\nx[z];\n// output\n[4,3,2,1]\n\nx=2 2 1 1\ny=2 1 1 2\nisort([x,y]);\n// output\n[2,3,1,0]\nisort([x,y],[0,0]);\n// output\n[0,1,3,2]\n```\n\nSort a table based on one of its columns:\n\n```\nt2 = table(4 2 3 1 as x, 9 6 7 3 as y);\nt2;\n```\n\n| x | y |\n| - | - |\n| 4 | 9 |\n| 2 | 6 |\n| 3 | 7 |\n| 1 | 3 |\n\n```\nt2[isort(t2.x)];\n```\n\n| x | y |\n| - | - |\n| 1 | 3 |\n| 2 | 6 |\n| 3 | 7 |\n| 4 | 9 |\n\n```\nt2[isort(t2.x, false)];\n```\n\n| x | y |\n| - | - |\n| 4 | 9 |\n| 3 | 7 |\n| 2 | 6 |\n| 1 | 3 |\n\nSort a table based on multiple columns:\n\n```\na=5 5 5 3 3 8 7 7;\nb=`MSFT`GOOG`IBM`YHOO`X`YHOO`C`ORCL;\nt=table(a,b);\nt;\n```\n\n| a | b    |\n| - | ---- |\n| 5 | MSFT |\n| 5 | GOOG |\n| 5 | IBM  |\n| 3 | YHOO |\n| 3 | X    |\n| 8 | YHOO |\n| 7 | C    |\n| 7 | ORCL |\n\n```\nt[isort([a,b], false true)];\n// first sort descending on a, then sort ascending on b\n```\n\n| a | b    |\n| - | ---- |\n| 8 | YHOO |\n| 7 | C    |\n| 7 | ORCL |\n| 5 | GOOG |\n| 5 | IBM  |\n| 5 | MSFT |\n| 3 | X    |\n| 3 | YHOO |\n\n```\nt[isort([a,b], false)];\n// equivalent to t[isort([a,b], false false)];\n```\n\n| a | b    |\n| - | ---- |\n| 8 | YHOO |\n| 7 | ORCL |\n| 7 | C    |\n| 5 | MSFT |\n| 5 | IBM  |\n| 5 | GOOG |\n| 3 | YHOO |\n| 3 | X    |\n"
    },
    "isortTop": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isortTop.html",
        "signatures": [
            {
                "full": "isortTop(X, top, [ascending=true])",
                "name": "isortTop",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [isortTop](https://docs.dolphindb.com/en/Functions/i/isortTop.html)\n\n\n\n#### Syntax\n\nisortTop(X, top, \\[ascending=true])\n\n#### Arguments\n\n**X** is a vector or a tuple of vectors of the same length.\n\n**top** is a positive integer no more than the size of a vector in *X*.\n\n**ascending** is a Boolean scalar or vector indicating whether to sort *X* (or vectors of *X* sequentially) in ascending order or descending order. The default value is true (ascending order).\n\n#### Details\n\nReturn the first few elements of the result of `isort(X, [ascending])`.\n\n#### Examples\n\n```\nisortTop(2 1 4 3 6 5, 3);\n// output\n[1,0,3]\n\nisortTop(2 1 4 3 6 5, 3, false);\n// output\n[4,5,2]\n```\n\nThe following example first sorts m in descending order. For the identical elements in m, sort them based on descending n values at the corresponding positions. Return the original indices of the first three elements of sorted m.\n\n```\nm=1 1 2 2 3 3\nn=1 2 1 2 1 2\nisortTop([m,n], 3, [false, false]);\n// output\n[5,4,3]\n```\n"
    },
    "isPeak": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isPeak.html",
        "signatures": [
            {
                "full": "isPeak(X, [strict=true])",
                "name": "isPeak",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[strict=true]",
                        "name": "strict",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [isPeak](https://docs.dolphindb.com/en/Functions/i/isPeak.html)\n\n\n\n#### Syntax\n\nisPeak(X, \\[strict=true])\n\n#### Arguments\n\n**X** is a numeric vector/matrix/table.\n\n**strict** is a Boolean value. For a segment of continuous identical numbers forming a local maximum (referred to as a plateau), the value of *strict*determines whether the entire plateau is considered a peak.\n\n* When *strict* = true, the plateau is not considered a peak, meaning all elements in the plateau return false.\n\n* When *strict*= false,\n\n  * If the number of elements in plateau is odd, the element at the middle will return true, while the others return false.\n\n  * If even, the element on the left side of the two middle elements will return true, while the others return false.\n\n#### Details\n\nIf *X* is a vector, check if each element in *X* is the peak.\n\nIf *X* is a matrix, perform the aforementioned calculations on each column and return a matrix of the same size as *X*.\n\nIf *X* is a table, only the numeric columns are involved in the calculations.\n\n#### Examples\n\n```\nv = [1, 2.2, 2.2, 2.2, 2.3, 1, 1.2]\nisPeak(v)\n// output: [false,false,false,false,true,false,false]\n\nv = [1, 2.2, 2.2, 2.2, 1.6, 1, 1.2]\nisPeak(v)\n// output: [false,false,false,false,false,false,false]\n\nisPeak(v, false)\n// output: [false,false,true,false,false,false,false]\n\n// Perform the calculations on each column in a matrix\nm = matrix(3.3 2.8 5.6 NULL 2.5 1.2, 4.5 3.5 4.6 2.8 3.9 NULL)\nisPeak(m)\n```\n\n| #0    | #1    |\n| ----- | ----- |\n| false | false |\n| false | false |\n| false | true  |\n| false | false |\n| false | false |\n| false | false |\n\n```\n// Perform the calculations on the numeric columns in a table\nt = table(`01`01`00`01`02`00 as id, 2022.01.01 + 1..6 as date, 388.3 390.6 390.8 390.6 390.3 391.5 as price)\nisPeak(t)\n```\n\n| id | date  | price |\n| -- | ----- | ----- |\n| 01 | false | false |\n| 01 | false | false |\n| 00 | false | true  |\n| 01 | false | false |\n| 02 | false | false |\n| 00 | false | false |\n\nRelated function: [isValley](https://docs.dolphindb.com/en/Functions/i/isValley.html)\n"
    },
    "isQuarterEnd": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isQuarterEnd.html",
        "signatures": [
            {
                "full": "isQuarterEnd(X)",
                "name": "isQuarterEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isQuarterEnd](https://docs.dolphindb.com/en/Functions/i/isQuarterEnd.html)\n\n\n\n#### Syntax\n\nisQuarterEnd(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nDetermine if each element in *X* is the last day of a quarter.\n\n#### Examples\n\n```\nisQuarterEnd(2012.06.30);\n// output\ntrue\n\nisQuarterEnd([2012.06.30,2012.07.01]);\n// output\n[true,false]\n```\n\nRelated function: [isQuarterStart](https://docs.dolphindb.com/en/Functions/i/isQuarterStart.html)\n"
    },
    "isQuarterStart": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isQuarterStart.html",
        "signatures": [
            {
                "full": "isQuarterStart(X)",
                "name": "isQuarterStart",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isQuarterStart](https://docs.dolphindb.com/en/Functions/i/isQuarterStart.html)\n\n\n\n#### Syntax\n\nisQuarterStart(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nDetermine if each element in *X* is the first day of a quarter.\n\n#### Examples\n\n```\nisQuarterStart(2012.04.01);\n// output\ntrue\n\nisQuarterStart([2012.04.01,2012.05.01]);\n// output\n[true,false]\n```\n\nRelated function: [isQuarterEnd](https://docs.dolphindb.com/en/Functions/i/isQuarterEnd.html)\n"
    },
    "isSorted": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isSorted.html",
        "signatures": [
            {
                "full": "isSorted(X, [ascending=true])",
                "name": "isSorted",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [isSorted](https://docs.dolphindb.com/en/Functions/i/isSorted.html)\n\n\n\n#### Syntax\n\nisSorted(X, \\[ascending=true])\n\n#### Arguments\n\n**X** is a vector.\n\n**ascending** is a Boolean indicating whether *X* is sorted in ascending order(true) or descending order(false). The default value is true.\n\n#### Details\n\nCheck whether a vector is sorted or not.\n\n#### Examples\n\n```\nx=NULL 1 2 3\nisSorted(x);\n// output\ntrue\n\nt=table(9 7 5 3 as x, 1 5 2 4 as y)\nt.x.isSorted(false);\n// output\ntrue\n\nt.y.isSorted();\n// output\nfalse\n```\n"
    },
    "isSpace": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isSpace.html",
        "signatures": [
            {
                "full": "isSpace(X)",
                "name": "isSpace",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isSpace](https://docs.dolphindb.com/en/Functions/i/isSpace.html)\n\n\n\n#### Syntax\n\nisSpace(X)\n\n#### Arguments\n\n**X** is a STRING scalar or vector.\n\n#### Details\n\nCheck whether the string *X* consists of only space. Return \"true\" if all characters in *X* are space, \"\\t\" (tab), \"\\r\" (carriage return) or \"\\n\" (newline escape).\n\n#### Examples\n\n```\nisSpace(\"hello world\");\n// output\nfalse\n\nisSpace(\" \\t \");\n// output\ntrue\n\nisSpace(string());\n// output\nfalse\n```\n"
    },
    "isTitle": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isTitle.html",
        "signatures": [
            {
                "full": "isTitle(X)",
                "name": "isTitle",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isTitle](https://docs.dolphindb.com/en/Functions/i/isTitle.html)\n\n\n\n#### Syntax\n\nisTitle(X)\n\n#### Arguments\n\n**X** is a STRING scalar or vector.\n\n#### Details\n\nCheck if *X* is a titlecased string, which has the first character in each word uppercase and the remaining all characters lowercase alphabets.\n\n#### Examples\n\n```\nisTitle(\"Hello World\");\n// output\ntrue\n\nisTitle(\"Hello world\");\n// output\nfalse\n\nisTitle([\"Hello\",\"468\",\"  \"]);\n// output\n[true,false,false]\n\nisTitle(\"1And1\");\n// output\ntrue\n```\n\nRelated functions: [isLower](https://docs.dolphindb.com/en/Functions/i/isLower.html), [isUpper](https://docs.dolphindb.com/en/Functions/i/isUpper.html)\n"
    },
    "isUpper": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isUpper.html",
        "signatures": [
            {
                "full": "isUpper(X)",
                "name": "isUpper",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isUpper](https://docs.dolphindb.com/en/Functions/i/isUpper.html)\n\n\n\n#### Syntax\n\nisUpper(X)\n\n#### Arguments\n\n**X** is a STRING scalar or vector.\n\n#### Details\n\nCheck whether all the case-based characters (letters) of the string are uppercase.\n\n#### Examples\n\n```\nisUpper(\"THIS IS STRING EXAMPLE....WOW!!!\");\n// output\ntrue\n\nisUpper(\"THIS is string example....wow!!!\");\n// output\nfalse\n\nisUpper(\"123456ABC\");\n// output\ntrue\n\nisUpper(\"123\");\n// output\nfalse\n\nisUpper([\"  \",string()]);\n// output\n[false,false]\n```\n\nRelated functions: [isLower](https://docs.dolphindb.com/en/Functions/i/isLower.html), [isTitle](https://docs.dolphindb.com/en/Functions/i/isTitle.html)\n"
    },
    "isValid": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isValid.html",
        "signatures": [
            {
                "full": "isValid(X)",
                "name": "isValid",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isValid](https://docs.dolphindb.com/en/Functions/i/isValid.html)\n\n\n\n#### Syntax\n\nisValid(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nDetermine if each element of X is NULL. Return true if at least one element is not NULL and false otherwise.\n\n#### Examples\n\n```\nisValid(00i);\n// output\nfalse\n\nisValid(1 NULL NULL 6 NULL 7);\n// output\n[true,false,false,true,false,true]\n\nisValid(1/0);\n// output\nfalse\n```\n"
    },
    "isValley": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isValley.html",
        "signatures": [
            {
                "full": "isValley(X, [strict=true])",
                "name": "isValley",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[strict=true]",
                        "name": "strict",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [isValley](https://docs.dolphindb.com/en/Functions/i/isValley.html)\n\n\n\n#### Syntax\n\nisValley(X, \\[strict=true])\n\n#### Arguments\n\n**X** is a numeric vector/matrix/table.\n\n**strict** is a Boolean value. For a segment of continuous identical numbers forming a local maximum (referred to as a plateau), the value of *strict*determines whether the entire plateau is considered a valley.\n\n* When *strict*= true, the plateau is not considered a valley, meaning all elements in the plateau return false.\n\n* When *strict*= false,\n\n  * If the number of elements in plateau is odd, the element at the middle will return true, while the others return false.\n\n  * If even, the element on the left side of the two middle elements will return true, while the others return false.\n\n#### Details\n\nIf *X* is a vector, check if each element in *X* is the valley.\n\nIf *X* is a matrix, perform the aforementioned calculations on each column and return a matrix of the same size as *X*.\n\nIf *X* is a table, only the numeric columns are involved in the calculations.\n\n#### Examples\n\n```\nv = [3.1, 2.2, 2.2, 2.2, 1.3, 2.1, 1.2]\nisValley(v)\n// output: [false,false,false,false,true,false,false]\n\nv = [3.1, 2.2, 2.2, 2.2, 2.6, 1, 1.2]\nisValley(v)\n// output: [false,false,false,false,false,true,false]\n\nisValley(v, false)\n// output: [false,false,true,false,false,true,false]\n\n// Perform the calculations on each column in a matrix\nm = matrix(5.3 5.8 5.6 NULL 5.7 1.2, 4.5 3.5 4.6 2.8 3.9 NULL)\nisValley(m)\n```\n\n| #0    | #1    |\n| ----- | ----- |\n| false | false |\n| false | true  |\n| false | false |\n| false | true  |\n| false | false |\n| false | false |\n\n```\n// Perform the calculations on the numeric columns in a table\nt = table(`01`01`00`01`02`00 as id, 2022.01.01 + 1..6 as date, 388.3 390.6 390.8 390.6 390.3 391.5 as price)\nisValley(t)\n```\n\n| id | date  | price |\n| -- | ----- | ----- |\n| 01 | false | false |\n| 01 | false | false |\n| 00 | false | false |\n| 01 | false | false |\n| 02 | false | true  |\n| 00 | false | false |\n\nRelated function: [isPeak](https://docs.dolphindb.com/en/Functions/i/isPeak.html)\n"
    },
    "isVoid": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isVoid.html",
        "signatures": [
            {
                "full": "isVoid(X)",
                "name": "isVoid",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isVoid](https://docs.dolphindb.com/en/Functions/i/isVoid.html)\n\n\n\n#### Syntax\n\nisVoid(X)\n\n#### Arguments\n\n**X** can be of any data form.\n\n#### Details\n\nCheck if an object is VOID type. There are two types of objects with VOID type: NULL object and Nothing object. Please see [isNothing](https://docs.dolphindb.com/en/Functions/i/isNothing.html).\n\n#### Examples\n\n```\nisVoid(NULL);\n// output\ntrue\n\nisVoid(1 NULL 2);\n// output\nfalse\n\n// compare with function isNull\nisNull(1 NULL 2);\n// output\n[false,true,false]\n```\n"
    },
    "isYearEnd": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isYearEnd.html",
        "signatures": [
            {
                "full": "isYearEnd(X)",
                "name": "isYearEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isYearEnd](https://docs.dolphindb.com/en/Functions/i/isYearEnd.html)\n\n\n\n#### Syntax\n\nisYearEnd(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nDetermine if each element in *X* is the last day of a year.\n\n#### Examples\n\n```\nisYearEnd(2012.12.31);\n// output\ntrue\n\nisYearEnd([2012.12.30,2012.12.31]);\n// output\n[false,true]\n```\n\nRelated function: [isYearStart](https://docs.dolphindb.com/en/Functions/i/isYearStart.html)\n"
    },
    "isYearStart": {
        "url": "https://docs.dolphindb.com/en/Functions/i/isYearStart.html",
        "signatures": [
            {
                "full": "isYearStart(X)",
                "name": "isYearStart",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isYearStart](https://docs.dolphindb.com/en/Functions/i/isYearStart.html)\n\n\n\n#### Syntax\n\nisYearStart(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nDetermine if each element in *X* is the first day of a year.\n\n#### Examples\n\n```\nisYearStart(2012.01.01);\n// output\ntrue\n\nisYearStart([2012.01.01,2012.02.01]);\n// output\n[true,false]\n```\n\nRelated function: [isYearEnd](https://docs.dolphindb.com/en/Functions/i/isYearEnd.html)\n"
    },
    "iterate": {
        "url": "https://docs.dolphindb.com/en/Functions/i/iterate.html",
        "signatures": [
            {
                "full": "iterate(init, coeffs, input)",
                "name": "iterate",
                "parameters": [
                    {
                        "full": "init",
                        "name": "init"
                    },
                    {
                        "full": "coeffs",
                        "name": "coeffs"
                    },
                    {
                        "full": "input",
                        "name": "input"
                    }
                ]
            }
        ],
        "markdown": "### [iterate](https://docs.dolphindb.com/en/Functions/i/iterate.html)\n\n\n\n#### Syntax\n\niterate(init, coeffs, input)\n\n#### Arguments\n\n**init** a scalar or a vector.\n\n**coeffs** a scalar or a vector. init and coeffs have the same length.\n\n**input** a scalar or a vector. If *input* is a scalar, it must be an integer and it means the number of iterations; if *input* is a vector, its length means the number of iterations and each element of *input* is added to the result of the corresponding iteration.\n\n#### Details\n\nIf *init*, *coeffs* and *input* are all scalars, return a geometric sequence \\[*init\\*coeffs, init\\*coeffs^2, init\\*coeffs^3*, …]. The length of the sequence is *input*.\n\nIf *init* and *coeffs* are scalars and *input* is a vector, return an array x with x\\[0]=`init*coeffs` + *input\\[0]* and x\\[n]=x\\[n-1]\\* *coeffs* + *input\\[n]*.\n\nIf *init* and *coeffs* are vectors and *input* is a scalar, return an array x with x\\[n]=y(n)\\*\\* *coeffs*, y(n)=y(n-1)\\[1:].append!(x\\[n-1]), y(0)= *init*. The length of x is *input*. \\*\\* returns the inner product of 2 vectors.\n\nIf *init*, *coeffs* and *input* are all vectors, return an array x with x\\[n]=y(n)\\*\\* *coeffs* + *input\\[n]*, y(n)=y(n-1)\\[1:].append!(x\\[n-1]), y(0)= *init*. The length of x is *input*. \\*\\* returns the inner product of 2 vectors.\n\n#### Examples\n\n```\niterate(1, 0.8, 3);\n// output\n[0.8,0.64,0.512]\n// 1*0.8=0.8, 0.8*0.8=0.64, 0.64*0.8=0.512\n\niterate(1, 0.8, 0.1 0.2 0.3);\n// output\n[0.9,0.92,1.036]\n// 1*0.8+0.1=0.9, 0.9*0.8+0.2=0.92, 0.92*0.8+0.3=1.036\n\niterate(1 1, 1 1, 10);\n// output\n[2,3,5,8,13,21,34,55,89,144]\n// this is the Fibonacci series: 1*1 + 1*1=2; 1*1+2*1=3; 2*1+3*1=5; 3*1+5*1=8; ... ; 55*1+89*1=144.\n\niterate(1 1, 1 1, 1 2 3 4 5);\n// output\n[3,6,12,22,39]\n// 1*1+1*1+1=3; 1*1+3*1+2=6; 3*1+6*1+3=12; 6*1+12*1+4=22; 12*1+22*1+5=39.\n```\n"
    },
    "join!": {
        "url": "https://docs.dolphindb.com/en/Functions/j/join!.html",
        "signatures": [
            {
                "full": "join!(X, Y)",
                "name": "join!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [join!](https://docs.dolphindb.com/en/Functions/j/join!.html)\n\n\n\n#### Syntax\n\njoin!(X, Y)\n\n#### Arguments\n\n**X** is a vector/tuple/matrix/table.\n\n**Y** is a scalar/vector/tuple/matrix/table.\n\nIf *X* is a vector, *Y* is a scalar/vector/tuple; if *X* is a matrix, *Y* is a vector/matrix; if *X* is a table, *Y* is a vector/table.\n\n#### Details\n\nMerge *X* and *Y*, and assign the result to *X*. The resulting object has the same data type as *X*.\n\n#### Examples\n\nIf *X* is a vector, *Y* must be a scalar, vector, or tuple whose elements all have the same data type as *X*. The result is a vector longer than *X*.\n\n```\nx=[1,2,3]\nx.join!(4)\nx;\n// output\n[1,2,3,4]\n\nx.join!(5 6 7)\nx;\n// output\n[1,2,3,4,5,6,7]\n\n$ x.join!((8,9))\n$ x;\n[1,2,3,4,5,6,7,8,9]\n```\n\nIf *X* is a tuple, *Y* can be a scalar, vector or tuple. The result is a tuple longer than *X*.\n\n```\n$ x = (1,\"A\")\n$ x.join!(2)\n$ x;\n(1,\"A\",2)\n\n$ x.join!([3,4,5])\n$ x;\n(1,\"A\",2,[3,4,5])\n\n$ x.join!((\"B\",\"C\"))\n$ x;\n// when appendTupleAsAWhole = true\n(1,\"A\",2,[3,4,5],(\"B\",\"C\"))\n// when appendTupleAsAWhole = false\n(1,\"A\",2,[3,4,5],\"B\",\"C\")\n```\n\nIf *X* is a matrix, *Y* must be a vector/matrix with the same number of rows as *X*. The result is a matrix with the same number of rows as *X*.\n\n```\nx=1..6$2:3\njoin!(x, [7,8])\nx;\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  |\n| 2  | 4  | 6  | 8  |\n\n```\nx.join!(9..12$2:2)\nx;\n```\n\n| #0 | #1 | #2 | #3 | #4 | #5 |\n| -- | -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  | 11 |\n| 2  | 4  | 6  | 8  | 10 | 12 |\n\nIf *X* is a table, *Y* must be a table or a vector with the same number of rows as *X*. The result is a table with the same number of rows as *X*.\n\n```\na=table(1..3 as x, 4.5 6.7 8.5 as y);\na;\n```\n\n| x | y   |\n| - | --- |\n| 1 | 4.5 |\n| 2 | 6.7 |\n| 3 | 8.5 |\n\n```\nb=table(700 500 800 as z);\nb;\n```\n\n| z   |\n| --- |\n| 700 |\n| 500 |\n| 800 |\n\n```\njoin!(a,b);\na;\n```\n\n| x | y   | z   |\n| - | --- | --- |\n| 1 | 4.5 | 700 |\n| 2 | 6.7 | 500 |\n| 3 | 8.5 | 800 |\n\n```\na=table(1..3 as x, `IBM`C`AAPL as y);\nb=table(172.3 25 106.5 as z);\na.join!(b);\na;\n```\n\n| x | y    | z     |\n| - | ---- | ----- |\n| 1 | IBM  | 172.3 |\n| 2 | C    | 25    |\n| 3 | AAPL | 106.5 |\n"
    },
    "join": {
        "url": "https://docs.dolphindb.com/en/Functions/j/join.html",
        "signatures": [
            {
                "full": "join(X,Y)",
                "name": "join",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [join](https://docs.dolphindb.com/en/Functions/j/join.html)\n\n\n\n#### Syntax\n\njoin(X,Y) or X<-Y\n\n#### Arguments\n\n**X** and **Y** can be scalar/vector/matrix/table.\n\n#### Details\n\nMerge X and Y.\n\n#### Examples\n\nIf X is a scalar, Y can be a scalar/vector. The result is a vector.\n\n```\n1<-3;\n// output\n[1,3]\n\n4<-1 2 3;\n// output\n[4,1,2,3]\n```\n\nIf X is a vector, Y must be a scalar/vector. The result is a vector.\n\n```\n[1,2,3]<-4;\n// output\n[1,2,3,4]\n\n[1,2,3]<-[4,5,6];\n// output\n[1,2,3,4,5,6]\n```\n\nIf X is a matrix, Y must be a vector/matrix with the same number of rows as X. The result is a matrix with the same number of rows as X.\n\n```\n1..6$2:3 <- [7,8];\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  |\n| 2  | 4  | 6  | 8  |\n\n```\n(1..6$2:3) <- (7..12$2:3);\n```\n\n| #0 | #1 | #2 | #3 | #4 | #5 |\n| -- | -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  | 11 |\n| 2  | 4  | 6  | 8  | 10 | 12 |\n\nIf X is a table, Y must be a table or a vector with the same number of rows as X. The result is a table with the same number of rows as X.\n\n```\na=table(1..3 as x, 4.5 6.7 8.5 as y);\na;\n```\n\n| x | y   |\n| - | --- |\n| 1 | 4.5 |\n| 2 | 6.7 |\n| 3 | 8.5 |\n\n```\nb=table(700 500 800 as z);\nb\n```\n\n| z   |\n| --- |\n| 700 |\n| 500 |\n| 800 |\n\n```\nc=join(a,b);\nc;\n```\n\n| x | y   | z   |\n| - | --- | --- |\n| 1 | 4.5 | 700 |\n| 2 | 6.7 | 500 |\n| 3 | 8.5 | 800 |\n\n```\na=table(1..3 as x, `IBM`C`AAPL as y);\nb=table(172.3 25 106.5 as z);\nc=a<-b;\nc\n```\n\n| x | y    | z     |\n| - | ---- | ----- |\n| 1 | IBM  | 172.3 |\n| 2 | C    | 25    |\n| 3 | AAPL | 106.5 |\n\nRelated function: [cj (cross\\_join)](https://docs.dolphindb.com/en/Functions/c/cj.html)\n"
    },
    "JsonExtract": {
        "url": "https://docs.dolphindb.com/en/Functions/j/JsonExtract.html",
        "signatures": [
            {
                "full": "jsonExtract(json, location, type)",
                "name": "jsonExtract",
                "parameters": [
                    {
                        "full": "json",
                        "name": "json"
                    },
                    {
                        "full": "location",
                        "name": "location"
                    },
                    {
                        "full": "type",
                        "name": "type"
                    }
                ]
            }
        ],
        "markdown": "### [JsonExtract](https://docs.dolphindb.com/en/Functions/j/JsonExtract.html)\n\n#### Syntax\n\njsonExtract(json, location, type)\n\n#### Arguments\n\n**json** is a LITERAL scalar or vector indicating the standard JSON string(s) to parse.\n\n**location** is a scalar/vector/tuple. Each element can be a string or a non-zero integer indicating the location at the corresponding dimension.\n\n* String: access element by key.\n* Positive integer: access the n-th element from the beginning.\n* Negative integer: access the n-th element from the end.\n\n**type** is a string specifying the data type of the return value. It can be \"long\", \"int\", \"double\", or \"string\".\n\n#### Details\n\nThis function parses extracted JSON elements into specified data type.\n\n**Return value**:\n\n* If *json* is a scalar, it returns a scalar; If *json* is a vector, it returns a vector.\n* If an element corresponding to *location* does not exist or cannot be parsed into expected data type, NULL is returned.\n\n#### Examples\n\nExample 1. Basic usage\n\n```\nA = '{\"a\": \"hello\", \"b\": [-100, 200.5, 300], \"c\": { \"b\" : 2} }'\njsonExtract(A, [2, 1], \"int\") \n// output: -100\n\njsonExtract(A, 1, \"int\") \n// output: NULL\n\njsonExtract(A, 999, \"int\") \n// output: NULL\n\njsonExtract(A, [\"b\", 2], \"int\") \n// output: 200\n\njsonExtract(A, [\"c\", \"b\"], \"double\") \n// output: 2\n\nB = '{\"a\": \"hello\", \"b\": [200, 300]}'\njsonExtract([A, B], [\"c\", \"b\"], \"int\") \n// output: [2, NULL]\n\njsonExtract([A, B], [2, -1], \"int\") \n// output: [300, 300]\n```\n\nExample 2. Use with SQL queries\n\n```\nA1 = '{\"a\": \"a1\",\"c\": { \"b\" : 2} }'\nA2 = '{\"a\": \"a2\", \"c\": { \"b\" : 3} }'\nB1 = '{\"a\": \"b1\",  \"c\": { \"b\" : 3} }'\nB2 = '{\"a\": \"b2\", \"c\": { \"b\" : 4} }'\nt1 = table([A1, A2] as json, [2,3] as val)\nt2 = table([B1, B2] as json, [3,4] as val)\n\nselect\n    jsonExtract(t1.json, \"a\", \"string\") as json1, \n    jsonExtract(t2.json, \"a\", \"string\") as json2 \nfrom t1 \njoin t2 on t1.val = t2.val\n```\n\n| json1 | json2 |\n| ----- | ----- |\n| a2    | b1    |\n\n"
    },
    "kama": {
        "url": "https://docs.dolphindb.com/en/Functions/k/kama.html",
        "signatures": [
            {
                "full": "kama(X, window)",
                "name": "kama",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [kama](https://docs.dolphindb.com/en/Functions/k/kama.html)\n\n\n\n#### Syntax\n\nkama(X, window)\n\nPlease see [TALib](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the Kaufman Adaptive Moving Average for *X* with a rolling *window*. The length of the window is given by the parameter *window*. The result is of the same length as *X*. The first (*window*-1) elements of the result are NULLs.\n\n#### Examples\n\n```\nx=[51.65, 81.18, 43.37, 11.26, 82.79, 13.4, 81.87, 63.53, 21.28, 94.23]\nkama(x, 5);\n// output\n[,,,,,81.006144,81.009907,80.793626,80.344572,80.456788]\n\nt=table(take(`A`B,10) as sym, rand(100.0,10) as close)\nselect sym, kama(close, 3) as kama from t context by sym;\n```\n\n| sym | kama      |\n| --- | --------- |\n| A   |           |\n| A   |           |\n| A   |           |\n| A   | 66.342572 |\n| A   | 62.500023 |\n| B   |           |\n| B   |           |\n| B   |           |\n| B   | 17.376469 |\n| B   | 42.27882  |\n"
    },
    "kendall": {
        "url": "https://docs.dolphindb.com/en/Functions/k/kendall.html",
        "signatures": [
            {
                "full": "kendall(X, Y)",
                "name": "kendall",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [kendall](https://docs.dolphindb.com/en/Functions/k/kendall.html)\n\n\n\n#### Syntax\n\nkendall(X, Y)\n\n#### Arguments\n\n**X** is a scalar, vector, matrix or in-memory table.\n\n**Y** is a scalar, vector, matrix or in-memory table.\n\n#### Details\n\nCalculate the [Kendall rank correlation coefficient](https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient) between *X* and *Y*. NULL values are ignored in the calculation.\n\nIf *X* or *Y* is a matrix, perform the aforementioned calculation on each column and return a vector.\n\nIf *X* or *Y* is an in-memory table, perform the aforementioned calculation on each numeric column of the table and return a table (where NULLs are returned for non-numeric columns).\n\n#### Examples\n\n```\nx = [33,21,46,-11,78,47,18,20,-5,66]\ny = [1,NULL,10,6,10,3,NULL,NULL,5,3]\nkendall(x, y)\n// output\n0.05\n```\n\nIf *X* is a matrix, *Y* can be a vector of the same length as the number of rows in *X*, or a matrix of the same dimension as *X*. The result is a vector of the same length as the number of columns in *X*.\n\n```\nm=1..20$10:2\nkendall(x,m)\n// output\n[-0.0222,-0.0222]\n\nn=rand(20,20)$10:2\nkendall(m,n)\n// output\n[0.3865,-0.1591]\n```\n\nIf *X* is a table, *Y* can be a vector of the same length as the number of rows in *X*, or a table of the same dimension as *X*. The result is a vector of the same length as the number of columns in *X*.\n\n```\nt=table(2..11 as id, \"a\"+string(2..11) as name)\nkendall(t,x)\n// output\nid\t     name\n-0.0222\t\n\nt1=table(x as col1, y as col2)\nkendall(t,t1)\n// output\nid\t     name\n-0.0222\n```\n"
    },
    "keyedStreamTable": {
        "url": "https://docs.dolphindb.com/en/Functions/k/keyedStreamTable.html",
        "signatures": [
            {
                "full": "keyedStreamTable(keyColumn, X, [X1], [X2], .....)",
                "name": "keyedStreamTable",
                "parameters": [
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "keyedStreamTable(keyColumn, capacity:size, colNames, colTypes)",
                "name": "keyedStreamTable",
                "parameters": [
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            }
        ],
        "markdown": "### [keyedStreamTable](https://docs.dolphindb.com/en/Functions/k/keyedStreamTable.html)\n\n\n\n#### Syntax\n\nkeyedStreamTable(keyColumn, X, \\[X1], \\[X2], .....)\n\nor\n\nkeyedStreamTable(keyColumn, capacity:size, colNames, colTypes)\n\n#### Arguments\n\n**keyColumn** is a string scalar or vector indicating the name of the primary key columns.\n\nFor the first scenario: *X*, *X1*, .... are vectors.\n\nFor the second scenario:\n\n**capacity** is the amount of memory (in terms of the number of rows) allocated to the table. When the number of rows exceeds capacity, the system will first allocate memory of 1.2-2 times of *capacity*, copy the data to the new memory space, and release the original memory. For large tables, these steps may use significant amount of memory.\n\n**size** can be 0 or 1, indicating the initial size (in terms of the number of rows) of the table. If size=0, create an empty table; If size = 1, create a table with one record, and the initialized values are:\n\n* false for Boolean type;\n\n* 0 for numeric, temporal, IPADDR, COMPLEX, and POINT types;\n\n* NULL for Literal, INT128 types.\n\n**colNames** is a string vector of column names.\n\n**colTypes** is a string vector of data types. As of 2.00.11.2, the non-key columns can be specified as array vectors.\n\n#### Details\n\nThis function creates a stream table with one or more columns serving as the primary key. It implements idempotent writes to prevent duplicate primary key insertions due to network issues or high-availability writes.\n\nWhen new records are inserted into a keyed stream table, the system checks the values of primary key.\n\n* If the primary key of a new record is identical to an existing one in memory, the new record is not inserted, and the existing record remains unchanged.\n* If multiple new records with the same primary key (different from those in memory) are written simultaneously, only the first record is successfully inserted.\n\nNote: The uniqueness of the primary key is limited to data in memory. If persistence is enabled for the keyed stream table, a limited number of records are stored in memory, with older data being persisted to disk. The primary key of incoming data could potentially duplicate those on disk.\n\n#### Examples\n\n*Example 1*\n\n```\nid=`A`B`C`D`E\nx=1 2 3 4 5\nt1=keyedStreamTable(`id, id, x)\nt1;\n```\n\n| id | x |\n| -- | - |\n| A  | 1 |\n| B  | 2 |\n| C  | 3 |\n| D  | 4 |\n| E  | 5 |\n\n*Example 2*\n\n```\nt2=keyedStreamTable(`id,100:0,`id`x, [INT,INT])\ninsert into t2 values(1 2 3,10 20 30);\nt2;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 10 |\n| 2  | 20 |\n| 3  | 30 |\n\nIf we try to insert a new row with duplicate primary key value as one of the existing rows, the new row will not be inserted:\n\n```\ninsert into t2 values(3 4 5,35 45 55)\nt2;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 10 |\n| 2  | 20 |\n| 3  | 30 |\n| 4  | 45 |\n| 5  | 55 |\n\nthe record with id=3 has not been overwritten.\n\nThere are multiple columns in the primary key:\n\n```\nt=keyedStreamTable(`sym`id,1:0,`sym`id`val,[SYMBOL,INT,DOUBLE])\ninsert into t values(`A`B`C`D`E,5 4 3 2 1,52.1 64.2 25.5 48.8 71.9);\ninsert into t values(`A`B`R`T`Y,5 8 3 2 1,152.3 164.6 125.5 148.8 171.6);\nt;\n```\n\n| sym | id | val   |\n| --- | -- | ----- |\n| A   | 5  | 52.1  |\n| B   | 4  | 64.2  |\n| C   | 3  | 25.5  |\n| D   | 2  | 48.8  |\n| E   | 1  | 71.9  |\n| B   | 8  | 164.6 |\n| R   | 3  | 125.5 |\n| T   | 2  | 148.8 |\n| Y   | 1  | 171.6 |\n"
    },
    "keyedTable": {
        "url": "https://docs.dolphindb.com/en/Functions/k/keyedTable.html",
        "signatures": [
            {
                "full": "keyedTable(keyColumns, X, [X1], [X2], .....)",
                "name": "keyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "keyedTable(keyColumns, capacity:size, colNames, colTypes)",
                "name": "keyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            },
            {
                "full": "keyedTable(keyColumns, table)",
                "name": "keyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [keyedTable](https://docs.dolphindb.com/en/Functions/k/keyedTable.html)\n\n\n\n#### Syntax\n\nkeyedTable(keyColumns, X, \\[X1], \\[X2], .....)\n\nor\n\nkeyedTable(keyColumns, capacity:size, colNames, colTypes)\n\nor\n\nkeyedTable(keyColumns, table)\n\n#### Arguments\n\n**keyColumn** is a string scalar or vector indicating the name(s) of the primary key column(s). The column type must be INTEGRAL, TEMPORAL or LITERAL.\n\nFor the first scenario: *X*, *X1*, .... are vectors.\n\nFor the second scenario:\n\n**capacity** is the amount of memory (in terms of the number of rows) allocated to the table. When the number of rows exceeds capacity, the system will first allocate memory of 1.2-2 times of *capacity*, copy the data to the new memory space, and release the original memory. For large tables, these steps may use significant amount of memory.\n\n**size** can be 0 or 1, indicating the initial size (in terms of the number of rows) of the table. It must be 0 if the table contains array vector columns.\n\n* If size=0, create an empty table.\n\n* If size=1, create a table with one record, and the initialized values are:\n\n  * false for Boolean type.\n\n  * 0 for numeric, temporal, IPADDR, COMPLEX, and POINT types.\n\n  * NULL for LITERAL and INT128 types.\n\n**colNames** is a string vector of column names.\n\n**colTypes** is a string vector of data types.\n\nFor the third scenario, **table** is a table. Please note that *keyColumns* in *table* cannot have duplicate values.\n\n#### Details\n\nCreate an keyed table, which is a special type of in-memory table with primary key. The primary key can be one column or multiple columns. The keyed table is implemented based on a hash table, storing the combined value of the primary key fields as a key entry, with each key entry corresponding to a record in the table. During queries, by specifying all fields of the primary key, data can be located through the index without performing a full table scan. It is recommended to use [sliceByKey](https://docs.dolphindb.com/en/Functions/s/sliceByKey.html) to improve query performance.\n\nWhen adding new records to the table, if the primary key of the new record duplicates an existing record, the system updates the record in the table; otherwise, the new record is added to the table.\n\nKeyed tables exhibit better performance for single-record updates and queries, making them an ideal choice for data caching. Keyed tables can also serve as output tables for time series engines for real time updates.\n\n**Note:** This function does not support creating a keyed table containing array vector columns.\n\nThe following compares the query optimization techniques for indexed and keyed tables.\n\nFor indexed tables:\n\n* The first column of *keyColumns* must be queried, and filter conditions for this column can only use `=`, `in`, or `and`.\n* Columns other than the first column of *keyColumns* can use range queries through `between`, comparison operators, etc., with higher query efficiency than using the `in` predicate.\n* The number of distinct columns filtered with `in` should not exceed 2.\n\nFor keyed tables:\n\n* All *keyColumns* must be queried. For such queries, key tables show better performance than indexed tables.\n* Filter conditions can only use `=`, `in`, or `and`.\n* The number of distinct columns filtered with `in` should not exceed 2.\n\nPlease refer to the optimized SQL query in [indexedTable](https://docs.dolphindb.com/en/Functions/i/indexedTable.html).\n\n#### Examples\n\n*Example 1. Create a keyed table.*\n\nThe first scenario:\n\n```\nsym=`A`B`C`D`E\nid=5 4 3 2 1\nval=52 64 25 48 71\nt=keyedTable(`sym`id,sym,id,val)\nt;\n```\n\n| id | x | val |\n| -- | - | --- |\n| A  | 5 | 52  |\n| B  | 4 | 64  |\n| C  | 3 | 25  |\n| D  | 2 | 48  |\n| E  | 1 | 71  |\n\nThe second scenario:\n\n```\nt=keyedTable(`sym`id,1:0,`sym`id`val,[SYMBOL,INT,INT])\ninsert into t values(`A`B`C`D`E,5 4 3 2 1,52 64 25 48 71);\n```\n\nThe third scenario:\n\n```\ntmp=table(sym, id, val)\nt=keyedTable(`sym`id, tmp);\n```\n\nCreate a keyed in-memory partitioned table:\n\n```\nsym=`A`B`C`D`E\nid=5 4 3 2 1\nval=52 64 25 48 71\nt=keyedTable(`sym`id,sym,id,val)\ndb=database(\"\",VALUE,sym)\npt=db.createPartitionedTable(t,`pt,`sym).append!(t);\n```\n\n*Example 2. Update a keyed table.*\n\n```\nt=keyedTable(`sym,1:0,`sym`datetime`price`qty,[SYMBOL,DATETIME,DOUBLE,DOUBLE])\ninsert into t values(`APPL`IBM`GOOG,2018.06.08T12:30:00 2018.06.08T12:30:00 2018.06.08T12:30:00,50.3 45.6 58.0,5200 4800 7800)\nt;\n```\n\n| sym  | datetime            | price | qty  |\n| ---- | ------------------- | ----- | ---- |\n| APPL | 2018.06.08T12:30:00 | 50.3  | 5200 |\n| IBM  | 2018.06.08T12:30:00 | 45.6  | 4800 |\n| GOOG | 2018.06.08T12:30:00 | 58    | 7800 |\n\nInsert a new row with duplicate primary key value as an existing row. The existing row will be overwritten:\n\n```\ninsert into t values(`APPL`IBM`GOOG,2018.06.08T12:30:01 2018.06.08T12:30:01 2018.06.08T12:30:01,65.8 45.2 78.6,5800 8700 4600)\nt;\n```\n\n| sym  | datetime            | price | qty  |\n| ---- | ------------------- | ----- | ---- |\n| APPL | 2018.06.08T12:30:01 | 65.8  | 5800 |\n| IBM  | 2018.06.08T12:30:01 | 45.2  | 8700 |\n| GOOG | 2018.06.08T12:30:01 | 78.6  | 4600 |\n\nInsert new rows among which there are duplicate primary key values:\n\n```\ninsert into t values(`MSFT`MSFT,2018.06.08T12:30:01 2018.06.08T12:30:01,45.7 56.9,3600 4500)\nt;\n```\n\n| sym  | datetime            | price | qty  |\n| ---- | ------------------- | ----- | ---- |\n| APPL | 2018.06.08T12:30:01 | 65.8  | 5800 |\n| IBM  | 2018.06.08T12:30:01 | 45.2  | 8700 |\n| GOOG | 2018.06.08T12:30:01 | 78.6  | 4600 |\n| MSFT | 2018.06.08T12:30:01 | 56.9  | 4500 |\n\nThe primary key cannot be updated:\n\n```\nupdate t set sym=\"C_\"+sym;\n// Error: Can't update a key column.\n```\n\n*Example 3. Query on a keyed table.*\n\nIn some cases, queries on a keyed table are optimized. In this section we will compare the performance of queries on keyed tables and ordinary in-memory tables.\n\nFor the following examples, we first create a keyed table and an ordinary in-memory table with 1 million records each:\n\n```\nid=shuffle(1..1000000)\ndate=take(2012.06.01..2012.06.10, 1000000)\ntype=rand(9, 1000000)\nval=rand(100.0, 1000000)\nt=table(id, date, type, val)\nkt=keyedTable(`id`date`type, id, date, type, val);\n```\n\nExample 3.1\n\n```\ntimer(100) select * from t where id=500000, date=2012.06.01, type=0;\n// Time elapsed: 161.574 ms\n\ntimer(100) select * from kt where id=500000, date=2012.06.01, type=0;\n// Time elapsed: 1.483 ms\n\ntimer(100) sliceByKey(t1, (500000, 2012.06.01, 0))\n// Time elapsed: 0.705 ms\n```\n\nExample 3.2\n\n```\ntimer(100) select * from t where id in [1, 500000], date in 2012.06.01..2012.06.05, type=5;\n// Time elapsed: 894.241 ms\n\ntimer(100) select * from kt where id in [1, 500000], date in 2012.06.01..2012.06.05, type=5;\n// Time elapsed: 2.322 ms\n```\n\nWith more than 2 \"in\" operators in the filtering conditions, however, a query on a keyed table is not optimized.\n\nExample 3.3\n\n```\ntimer(100) select * from t where id in [1, 500000], date in 2012.06.01..2012.06.05, type in 1..5;\n// Time elapsed: 801.347 ms\n\ntimer(100) select * from kt where id in [1, 500000], date in 2012.06.01..2012.06.05, type in 1..5;\n// Time elapsed: 834.184 ms\n```\n\nIf the filtering conditions do not include all key columns, a query on a keyed table is not optimized.\n\nExample 3.4\n\n```\ntimer(100) select * from t where id=500000, date in 2012.06.01..2012.06.05;\n// Time elapsed: 177.113 ms\n\ntimer(100) select * from kt where id=500000, date in 2012.06.01..2012.06.05;\n// Time elapsed: 163.265 ms\n```\n\nExample 4. Use a keyed table with array vectors to record the 5 levels of quotes data.\n\n```\nsym=[\"a\",\"b\",\"c \"] \ntime=22:58:52.827 22:58:53.627 22:58:53.827 \nvolume=array(INT[]).append!([[100,110,120,115,125],[200,230,220,225,230],[320,300,310,315,310]])\nprice=array(DOUBLE[]).append!([[10.5,10.6,10.7,10.77,10.85],[8.6,8.7,8.76,8.83,8.9],[6.3,6.37,6.42,6.48,6.52]])\nt=keyedTable(`sym,sym,time,volume,price)\nt;\n```\n\n| sym | time         | volume                     | price                             |\n| --- | ------------ | -------------------------- | --------------------------------- |\n| a   | 22:58:52.827 | \\[100, 110, 120, 115, 125] | \\[10.5, 10.6, 10.7, 10.77, 10.85] |\n| b   | 22:58:53.627 | \\[200, 230, 220, 225, 230] | \\[8.6, 8.7, 8.76, 8.83, 8.9]      |\n| c   | 22:58:53.827 | \\[320, 300, 310, 315, 310] | \\[6.3, 6.37, 6.42, 6.48, 6.52]    |\n\n```\n// latest quote volume and price\nnewVolume=array(INT[]).append!([[130,110,110,115,120]])\nnewPrice= array(DOUBLE[]).append!([[10.55,10.57,10.62,10.68,10.5]])\n// update for stock a\nupdate t set volume=newVolume, price=newPrice where sym=\"a\"\nt;\n```\n\n| sym | time         | volume                     | price                               |\n| --- | ------------ | -------------------------- | ----------------------------------- |\n| a   | 22:58:52.827 | \\[130, 110, 110, 115, 120] | \\[10.55, 10.57, 10.62, 10.68, 10.5] |\n| b   | 22:58:53.627 | \\[200, 230, 220, 225, 230] | \\[8.6, 8.7, 8.76, 8.83, 8.9]        |\n| c   | 22:58:53.827 | \\[320, 300, 310, 315, 310] | \\[6.3, 6.37, 6.42, 6.48, 6.52]      |\n\nNote that when updating the array vector column, the number of elements in each column must be consistent with the original column. For example, if the vector of new record contains 4 elements, while the original contains 5 elements, an error is raised:\n\n```\nnewVolume=array(INT[]).append!([[130,110,110,120]])\nnewPrice= array(DOUBLE[]).append!([[10.55,10.57,10.62,10.5]])\n\nupdate t set volume=newVolume, price=newPrice where sym=\"a\"\n// error: Failed to update column: volume\n```\n\nRelated function: [indexedTable](https://docs.dolphindb.com/en/Functions/i/indexedTable.html)\n"
    },
    "keys": {
        "url": "https://docs.dolphindb.com/en/Functions/k/keys.html",
        "signatures": [
            {
                "full": "keys(X)",
                "name": "keys",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [keys](https://docs.dolphindb.com/en/Functions/k/keys.html)\n\n\n\n#### Syntax\n\nkeys(X)\n\n#### Arguments\n\n**X** is a dictionary/table/set.\n\n#### Details\n\nReturn the keys of a dictionary as a vector, or return the column names of a table as a vector, or convert a set into a vector.\n\n#### Examples\n\n```\nz=dict(`INT,`DOUBLE)\nz[5]=7.9\nz[3]=6\nz.keys();\n// output\n[3,5]\n\nt = table(1 2 3 as id, 4 5 6 as x, `IBM`MSFT`GOOG as name);\nkeys(t);\n// output\n[\"id\",\"x\",\"name\"]\n\na=set(1 2 4)\na.keys();\n// output\n[4,2,1]\n```\n\nRelated function: [values](https://docs.dolphindb.com/en/Functions/v/values.html)\n"
    },
    "kmeans": {
        "url": "https://docs.dolphindb.com/en/Functions/k/kmeans.html",
        "signatures": [
            {
                "full": "kmeans(X, k, [maxIter=300], [randomSeed], [init='random'])",
                "name": "kmeans",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "k",
                        "name": "k"
                    },
                    {
                        "full": "[maxIter=300]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "300"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    },
                    {
                        "full": "[init='random']",
                        "name": "init",
                        "optional": true,
                        "default": "'random'"
                    }
                ]
            }
        ],
        "markdown": "### [kmeans](https://docs.dolphindb.com/en/Functions/k/kmeans.html)\n\n\n\n#### Syntax\n\nkmeans(X, k, \\[maxIter=300], \\[randomSeed], \\[init='random'])\n\n#### Arguments\n\n**X** is a table. Each row is an observation and each column is a feature.\n\n**k** is a positive integer indicating the number of clusters to form.\n\n**maxIter** is a positive integer indicating the maximum number of iterations of the k-means algorithm for a single run. The default value is 300.\n\n**randomSeed** is an integer indicating the seed in the random number generator.\n\n**init** is a STRING scalar or matrix indicating the optional method for initialization. The default value is \"random\".\n\n* If *init* is a STRING scalar, it can be \"random\" or \"k-means++\": \"random\" means to choose observations at random from data for the initial centroids; \"k-means++\" means to generate cluster centroids using the k-means++ algorithm.\n\n* If *init* is a matrix, it indicates the centroid starting locations. The number of columns is the same as *X* and the number of rows is *k*.\n\n#### Details\n\nK-means clustering. Return a dictionary with the following keys:\n\n* centers: a k\\*m (m is the number of columns of *X*) matrix. Each row is the coordinates of a cluster center.\n\n* predict: a clustering function for prediction of FUNCTIONDEF type.\n\n* modelName: string \"KMeans\".\n\n* model: a RESOURCE data type variable. It is an internal binary resource generated by function `kmeans` to be used by function [predict](https://docs.dolphindb.com/en/Functions/p/predict.html).\n\n* labels: a vector indicating which cluster each row of X belongs to.\n\n#### Examples\n\n```\nt = table(100:0, `x0`x1, [DOUBLE, DOUBLE])\nx0 = norm(1.0, 1.0, 50)\nx1 = norm(1.0, 1.5, 50)\ninsert into t values (x0, x1)\nx0 = norm(2.0, 1.0, 50)\nx1 = norm(-1.0, 1.5, 50)\ninsert into t values (x0, x1)\nx0 = norm(-1.0, 1.0, 50)\nx1 = norm(-3.0, 1.5, 50)\ninsert into t values (x0, x1);\n\nmodel = kmeans(t, 3);\nmodel;\n\n// output\ncenters->\n\n0        #1\n--------- ---------\n-1.048027 -3.809539\n1.110899  1.24216\n1.677974  -1.19158\n\npredict->kmeansPredict\nmodelName->KMeans\nmodel->KMeans\nlabels->[2,2,2,2,2,2,3,2,3,2,...]\n```\n"
    },
    "knn": {
        "url": "https://docs.dolphindb.com/en/Functions/k/knn.html",
        "signatures": [
            {
                "full": "knn(Y, X, type, nNeighbor, [power=2])",
                "name": "knn",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "type",
                        "name": "type"
                    },
                    {
                        "full": "nNeighbor",
                        "name": "nNeighbor"
                    },
                    {
                        "full": "[power=2]",
                        "name": "power",
                        "optional": true,
                        "default": "2"
                    }
                ]
            }
        ],
        "markdown": "### [knn](https://docs.dolphindb.com/en/Functions/k/knn.html)\n\n\n\n#### Syntax\n\nknn(Y, X, type, nNeighbor, \\[power=2])\n\n#### Arguments\n\n**Y** is a vector with the same length as the number of rows of *X*. Each element is a label corresponding to each row in *X*.\n\n**X** is a table. Each row is an observation and each column is a feature.\n\n**type** is a string. It can be either \"regressor\" or \"classifier\".\n\n**nNeighbor** is a positive integer indicating the number of nearest neighbors in training.\n\n**power** is a positive integer indicating the parameter of Minkowski distance used in training. The default value is 2 indicating Euclidean distance. If *power*=1, it means Manhattan distance is used in training.\n\n#### Details\n\nImplement the k-nearest neighbors (k-NN) algorithm with a brute-force search for classification and regression. Return a dictionary with the following keys:\n\n* nNeighbor: the number of nearest neighbors in training.\n\n* modelName: string \"KNN\".\n\n* model: the model to be saved.\n\n* power: the parameter of Minkowski distance used in training.\n\n* type: \"regressor\" or \"classifier\".\n\n#### Examples\n\n```\nheight = 158 158 158 160 160 163 163 160 163 165 165 165 168 168 168 170 170 170\nweight = 58 59 63 59 60 60 61 64 64 61 62 65 62 63 66 63 64 68\nt=table(height, weight)\nlabels=take(1,7) join take(2,11)\nmodel = knn(labels,t,\"classifier\", 5);\n```\n"
    },
    "kroghInterpolate": {
        "url": "https://docs.dolphindb.com/en/Functions/k/kroghInterpolate.html",
        "signatures": [
            {
                "full": "kroghInterpolate(X, Y, newX, [der=0])",
                "name": "kroghInterpolate",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "newX",
                        "name": "newX"
                    },
                    {
                        "full": "[der=0]",
                        "name": "der",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [kroghInterpolate](https://docs.dolphindb.com/en/Functions/k/kroghInterpolate.html)\n\n\n\n#### Syntax\n\nkroghInterpolate(X, Y, newX, \\[der=0])\n\n#### Arguments\n\n**X** is a numeric vector indicating the x-coordinates. It must be sorted in increasing order with no NULL values contained.\n\n**Y** is a numeric vector of the same length as *Xi*, indicating the y-coordinates. It cannot contain NULL values.\n\n**newX** is a numeric vector specifying the points at which to evaluate the derivatives.\n\n**der** (optional) is a non-negative integer indicating how many derivatives to evaluate. The default value is 0, meaning the function value is used as the 0th derivative.\n\n#### Details\n\nInterpolating polynomial for a set of points. The polynomial passes through all the pairs `(X, Y)` and returns the derivative interpolated at the x-points.\n\nOne may additionally specify a number of derivatives at each point *Xi*; this is done by repeating the value *Xi* and specifying the derivatives as successive *Yi* values.\n\n* When the vector of *Xi*contains only distinct values, *Yi* represents the function value.\n\n* When an element of *Xi*occurs two or more times in a row, the corresponding *Yi* represents derivative values. For example, if X = \\[0,0,1,1] and Y = \\[1,0,2,3], then Y\\[0]=f(0), Y\\[1]=f'(0), Y\\[2]=f(1) and Y\\[3]=f'(1).\n\n#### Examples\n\nTake `sin` as an example to interpolate the value and first derivative at the point of xx.\n\n```\ndef linspace(start, end, num, endpoint=true){\n\tif(endpoint) return end$DOUBLE\\(num-1), start + end$DOUBLE\\(num-1)*0..(num-1)\n\telse return start + end$DOUBLE\\(num-1)*0..(num-1)\t\n}\n\nx = 0 1 2 3 4 5\ny = sin(x)\nxx = linspace(0.0, 5.0, 10)[1]\nyy=kroghInterpolate(x,y,xx)\nyy;\n// output: [0,0.515119011157387,0.898231239576709,0.998548648650381,0.793484053410063,0.354287125066207,-0.188319604452395,-0.678504737959061,-0.969692008469677,-0.958924274663139]\n\nyy1=kroghInterpolate(x,y,xx,1)\nyy1;\n// output: [0.885486080979582,0.875967413938641,0.459031117252456,-0.103633680213926,-0.612193041424271,-0.92866822117116,-0.976935666075988,-0.742727014588963,-0.273629096989106,0.320916064615744]\n```\n"
    },
    "kroghInterpolateFit": {
        "url": "https://docs.dolphindb.com/en/Functions/k/kroghInterpolateFit.html",
        "signatures": [
            {
                "full": "kroghInterpolateFit(X, Y, [der=0])",
                "name": "kroghInterpolateFit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[der=0]",
                        "name": "der",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [kroghInterpolateFit](https://docs.dolphindb.com/en/Functions/k/kroghInterpolateFit.html)\n\n\n\n#### Syntax\n\nkroghInterpolateFit(X, Y, \\[der=0])\n\n#### Arguments\n\n**X** is a numeric vector representing the x-coordinates of the points to be interpolated. Values in *X* must be in increasing order. NULL values are not allowed.\n\n**Y** is a numeric vector of the same length as *X*, representing the y-coordinates of the points. NULL values are not allowed.\n\n**der** (optional) is a non-negative integer representing the derivative order to compute. The default value is 0, meaning to compute the polynomial's value.\n\n#### Details\n\nThis function performs polynomial interpolation for a given set of points, ensuring the polynomial passes through all points in the set.\n\nMultiple derivative values at each point of *X* can be specified by repeating *X* values and assigning corresponding derivative values as consecutive Y values:\n\n* If an *X* value appears only once, the corresponding *Y* is the value of the polynomial f(X).\n* If an *X* value appears multiple times, the first *Y* is the value of f(X), the second Y is the first derivative f′(X), the third Y is the second derivative f′′(X), and so on. For example, with inputs X=\\[0,0,1,1] and Y=\\[1,0,2,3], the interpretation is Y\\[0]=f(0), Y\\[1]=f′(0), Y\\[2]=f(1), Y\\[3]=f′(1).\n\n**Return value**: A dictionary with the following keys:\n\n* modelName: A string \"kroghInterpolate\" indicating the model name.\n* X: The numeric vector representing the x-coordinates used for interpolation (i.e., the input *X*).\n* der: The non-negative integer representing the derivative order (i.e., the input *der*).\n* coeffs: A numeric vector containing the polynomial coefficients fitted from the input data points.\n* predict: The prediction function of the model. You can call `model.predict(X)` or `predict(model, X)` to make predictions with the generated model. It takes the following parameters:\n  * model: A dictionary, which is the output of `kroghInterpolateFit`.\n  * X: A numeric vector representing the x-coordinates at which to evaluate the polynomial.\n\n#### Examples\n\nPerform polynomial interpolation for the `sin` function and compute the polynomial estimates at specific points:\n\n```\nx = 0 1 2 3 4 5\ny = sin(x)\nmodel = kroghInterpolateFit(x,y)\nmodel\n\n/*\noutput:\nX->[0,1,2,3,4,5]\nder->0\npredict->kroghInterpolateFitPredict\nmodelName->kroghInterpolate\ncoeffs->[0.0,0.841470984807,-0.386822271395,-0.010393219665,0.032025753923,-0.005411092181,0.0]\n*/\n```\n\nPredict with the generated model using a UDF `linspace`:\n\n```\ndef linspace(start, end, num, endpoint=true){\n\tif(endpoint) return end$DOUBLE\\(num-1), start + end$DOUBLE\\(num-1)*0..(num-1)\n\telse return start + end$DOUBLE\\(num-1)*0..(num-1)\t\n}\nxx = linspace(0.0, 5.0, 10)[1]\nmodel.predict(xx)\n\n// output: [0,0.515119011157387,0.898231239576709,0.998548648650381,0.793484053410063,0.354287125066207,-0.188319604452395,-0.678504737959061,-0.969692008469677,-0.958924274663139]\n```\n\n**Related Functions**: [predict](https://docs.dolphindb.com/en/Functions/p/predict.html), [kroghInterpolate](https://docs.dolphindb.com/en/Functions/k/kroghInterpolate.html)\n"
    },
    "ksTest": {
        "url": "https://docs.dolphindb.com/en/Functions/k/ksTest.html",
        "signatures": [
            {
                "full": "ksTest(X, Y)",
                "name": "ksTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ksTest](https://docs.dolphindb.com/en/Functions/k/ksTest.html)\n\n\n\n#### Syntax\n\nksTest(X, Y)\n\n#### Arguments\n\n**X** and **Y** are numeric vectors indicating the samples for the test.\n\n#### Details\n\nConduct Kolmogorov-Smirnov test on *X* and *Y*.\n\n* ksValue: Kolmogorov-Smirnov statistic\n\n* pValue: p-value of the test\n\n* D: D-stat\n\n* method: \"Two-sample Kolmogorov-Smirnov test\"\n\n#### Examples\n\n```\nx = norm(0.0, 1.0, 50)\ny = norm(0.0, 1.0, 20)\nksTest(x, y);\n\n// output\nksValue->0.739301\npValue->0.645199\nD->0.19\nmethod->Two-sample Kolmogorov-Smirnov test\n```\n"
    },
    "kurtosis": {
        "url": "https://docs.dolphindb.com/en/Functions/k/kurtosis.html",
        "signatures": [
            {
                "full": "kurtosis(X, [biased=true])",
                "name": "kurtosis",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [kurtosis](https://docs.dolphindb.com/en/Functions/k/kurtosis.html)\n\n\n\n#### Syntax\n\nkurtosis(X, \\[biased=true])\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n**biased** is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\n#### Details\n\nReturn the kurtosis of *X*. The calculation skips NULL values.\n\nThe calculation uses the following formulas:\n\n* when *biased* =true:\n\n  ![](https://docs.dolphindb.com/en/images/k1.png)\n\n* when *biased*=false:\n\n  ![](https://docs.dolphindb.com/en/images/k0.png)\n\nIf *X* is a matrix, calculate the skewness of each column of *X* and return a vector.\n\nIf *X* is a table, calculate the skewness of each column of *X* and return a table.\n\n`kurtosis` also supports querying partitioned tables and distributed tables with bias correction.\n\nFunction `kurtosis` in DolphinDB returns a biased result by default (*biased* = true), while in pandas and Excel it is unbiased estimation, and the kurtosis value 3 of the normal distribution is subtracted.\n\nRefer to the following example, you can make the kurtosis results of DolphinDB consistent with that of pandas and excel:\n\n```\n// python\nm = [1111, 323, 43, 51]\ndf = pandas.DataFrame(m)\ny = df.kurt()\n// output\n2.504252\n\n// dolphindb\nm=matrix(1111 323 43 51)\nkurtosis(m, false) - 3\n// output\n2.5043\n```\n\n#### Examples\n\nPlease note that as the example below uses the random number generator [norm](https://docs.dolphindb.com/en/Functions/n/norm.html), the result is slightly different each time it is executed.\n\n```\nx=norm(0, 1, 1000000);\nkurtosis(x);\n// output\n3.000249\n\nx[0]=100;\nkurtosis(x);\n// output\n100.626722\n\nm=matrix(1..10, 1 2 3 4 5 6 7 8 9 100);\nm;\n```\n\n| #0 | #1  |\n| -- | --- |\n| 1  | 1   |\n| 2  | 2   |\n| 3  | 3   |\n| 4  | 4   |\n| 5  | 5   |\n| 6  | 6   |\n| 7  | 7   |\n| 8  | 8   |\n| 9  | 9   |\n| 10 | 100 |\n\n```\nkurtosis(m);\n// output\n[1.775757575757576,7.997552566718839]\n```\n"
    },
    "lasso": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lasso.html",
        "signatures": [
            {
                "full": "lasso(ds, yColName, xColNames, [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])",
                "name": "lasso",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alpha=1.0]",
                        "name": "alpha",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[positive=false]",
                        "name": "positive",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    },
                    {
                        "full": "[checkInput=true]",
                        "name": "checkInput",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [lasso](https://docs.dolphindb.com/en/Functions/l/lasso.html)\n\n\n\n#### Syntax\n\nlasso(ds, yColName, xColNames, \\[alpha=1.0], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[positive=false], \\[swColName], \\[checkInput=true])\n\n#### Arguments\n\n**ds** is an in-memory table or a data source usually generated by the [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html) function.\n\n**yColName** is a string indicating the column name of the dependent variable in *ds*.\n\n**xColNames** is a string scalar/vector indicating the column names of the independent variables in *ds*.\n\n**alpha** is a floating number representing the constant that multiplies the L1-norm. The default value is 1.0.\n\n**intercept** is a Boolean value indicating whether to include the intercept in the regression. The default value is true.\n\n**normalize** is a Boolean value. If true, the regressors will be normalized before regression by subtracting the mean and dividing by the L2-norm. If *intercept* =false, this parameter will be ignored. The default value is false.\n\n**maxIter** is a positive integer indicating the maximum number of iterations. The default value is 1000.\n\n**tolerance** is a floating number. The iterations stop when the improvement in the objective function value is smaller than *tolerance*. The default value is 0.0001.\n\n**positive** is a Boolean value indicating whether to force the coefficient estimates to be positive. The default value is false.\n\n**swColName** is a STRING indicating a column name of *ds*. The specified column is used as the sample weight. If it is not specified, the sample weight is treated as 1.\n\n**checkInput** is a BOOLEAN value. It determines whether to enable validation check for parameters *yColName*, *xColNames*, and *swColName*.\n\n* If *checkInput* = true (default), it will check the invalid value for parameters and throw an error if the NULL value exists.\n\n* If *checkInput* = false, the invalid value is not checked.\n\nIt is recommended to specify *checkInput* = true. If it is false, it must be ensured that there are no invalid values in the input parameters and no invalid values are generated during intermediate calculations, otherwise the returned model may be inaccurate.\n\n#### Details\n\nEstimate a Lasso regression that performs L1 regularization.\n\nMinimize the following objective function: ![](https://docs.dolphindb.com/en/images/lasso.png)\n\n#### Examples\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288];\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599];\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219];\nt = table(y, x0, x1);\n\nlasso(t, `y, `x0`x1);\n```\n\nIf *t* is a DFS table, then the input should be a data source:\n\n```\nlasso(sqlDS(<select * from t>), `y, `x0`x1);\n```\n"
    },
    "lassoBasic": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lassoBasic.html",
        "signatures": [
            {
                "full": "lassoBasic(Y, X, [mode=0], [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])",
                "name": "lassoBasic",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[alpha=1.0]",
                        "name": "alpha",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[positive=false]",
                        "name": "positive",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    },
                    {
                        "full": "[checkInput=true]",
                        "name": "checkInput",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [lassoBasic](https://docs.dolphindb.com/en/Functions/l/lassoBasic.html)\n\n\n\n#### Syntax\n\nlassoBasic(Y, X, \\[mode=0], \\[alpha=1.0], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[positive=false], \\[swColName], \\[checkInput=true])\n\n#### Details\n\nPerform lasso regression.\n\nMinimize the following objective function:\n\n![](https://docs.dolphindb.com/en/images/lasso.png)\n\n#### Arguments\n\n**Y** is a numeric vector indicating the dependent variables.\n\n**X** is a numeric vector/tuple/matrix/table, indicating the independent variables.\n\n* When *X* is a vector/tuple, its length must be equal to the length of *Y*.\n\n* When *X* is a matrix/table, its number of rows must be equal to the length of *Y*.\n\n**mode** is an integer that can take the following three values:\n\n* 0 (default) : a vector of the coefficient estimates.\n\n* 1: a table with coefficient estimates, standard error, t-statistics, and p-values.\n\n* 2: a dictionary with the following keys: ANOVA, RegressionStat, Coefficient and Residual\n\n  | Source of Variance | DF (degree of freedom) | SS (sum of square)             | MS (mean of square)               | F (F-score) | Significance |\n  | ------------------ | ---------------------- | ------------------------------ | --------------------------------- | ----------- | ------------ |\n  | Regression         | p                      | sum of squares regression, SSR | regression mean square, MSR=SSR/R | MSR/MSE     | p-value      |\n  | Residual           | n-p-1                  | sum of squares error, SSE      | mean square error, MSE=MSE/E      |             |              |\n  | Total              | n-1                    | sum of squares total, SST      |                                   |             |              |\n\n  | Item         | Description                                                                                                                                   |\n  | ------------ | --------------------------------------------------------------------------------------------------------------------------------------------- |\n  | R2           | R-squared                                                                                                                                     |\n  | AdjustedR2   | The adjusted R-squared corrected based on the degrees of freedom by comparing the sample size to the number of terms in the regression model. |\n  | StdError     | The residual standard error/deviation corrected based on the degrees of freedom.                                                              |\n  | Observations | The sample size.                                                                                                                              |\n\n  | Item     | Description                                                             |\n  | -------- | ----------------------------------------------------------------------- |\n  | factor   | Independent variables                                                   |\n  | beta     | Estimated regression coefficients                                       |\n  | StdError | Standard error of the regression coefficients                           |\n  | tstat    | t statistic, indicating the significance of the regression coefficients |\n\n  Residual: the difference between each predicted value and the actual value.\n\n**alpha** is a floating number representing the constant that multiplies the L1-norm. The default value is 1.0.\n\n**intercept** is a Boolean variable indicating whether the regression includes the intercept. If it is true, the system automatically adds a column of \"1\"s to *X* to generate the intercept. The default value is true.\n\n**normalize** is a Boolean value. If true, the regressors will be normalized before regression by subtracting the mean and dividing by the L2-norm. If *intercept* =false, this parameter will be ignored. The default value is false.\n\n**maxIter** is a positive integer indicating the maximum number of iterations. The default value is 1000.\n\n**tolerance** is a floating number. The iterations stop when the improvement in the objective function value is smaller than *tolerance*. The default value is 0.0001.\n\n**positive** is a Boolean value indicating whether to force the coefficient estimates to be positive. The default value is false.\n\n**swColName** is a STRING indicating a column name of *ds*. The specified column is used as the sample weight. If it is not specified, the sample weight is treated as 1.\n\n**checkInput** is a BOOLEAN value. It determines whether to enable validation check for parameters *yColName*, *xColNames*, and *swColName*.\n\n* If *checkInput* = true (default), it will check the invalid value for parameters and throw an error if the NULL value exists.\n\n* If *checkInput* = false, the invalid value is not checked.\n\n**Note:** It is recommended to specify *checkInput* = true. If it is false, it must be ensured that there are no invalid values in the input parameters and no invalid values are generated during intermediate calculations, otherwise the returned model may be inaccurate.\n\n#### Examples\n\n```\nx1=1 3 5 7 11 16 23\nx2=2 8 11 34 56 54 100\ny=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\n\nprint(lassoBasic(y, (x1,x2), mode = 0));\n// output\n[-9.133706333069543,2.535935196073186,0.189298948643987]\n\n\nprint(lassoBasic(y, (x1,x2), mode = 1));\n// output\nfactor    beta               stdError          tstat              pvalue\n--------- ------------------ ----------------- ------------------ -----------------\nintercept -9.133706333069543 5.247492365971091 -1.740584968222107 0.156730846105191\nx1        2.535935196073186  1.835793667840723 1.38138356205138   0.239309472176311\nx2        0.189298948643987  0.410201227095842 0.461478260277749  0.66843504931137\n\n\nprint(lassoBasic(y, (x1,x2), mode = 2));\n// output\nCoefficient->\nfactor    beta               stdError          tstat              pvalue\n--------- ------------------ ----------------- ------------------ -----------------\nintercept -9.133706333069543 5.247492365971091 -1.740584968222107 0.156730846105191\nx1        2.535935196073186  1.835793667840723 1.38138356205138   0.239309472176311\nx2        0.189298948643987  0.410201227095842 0.461478260277749  0.66843504931137\n\nRegressionStat->\nitem         statistics\n------------ -----------------\nR2           0.931480447323074\nAdjustedR2   0.897220670984611\nStdError     8.195817208870076\nObservations 7\n\nANOVA->\nBreakdown  DF SS                   MS                   F                  Significance\n---------- -- -------------------- -------------------- ------------------ -----------------\nRegression 2  4165.242566095043912 2082.621283047521956 31.004574440904473 0.003672076469395\nResidual   4  268.685678884843582  67.171419721210895\nTotal      6  4471.637142857141952\n\nResidual->\n[6.319173239708383,4.21150915569809,-0.028258082380245,-6.254004293338318,-7.262321947798779,-6.063400030876729,9.077301958987561]\n```\n"
    },
    "lassoCV": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lassocv.html",
        "signatures": [
            {
                "full": "lassoCV(ds, yColName, xColNames, [alphas], [intercept], [normalize], [maxIter], [tolerance], [positive], [swColName], [checkInput])",
                "name": "lassoCV",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alphas]",
                        "name": "alphas",
                        "optional": true
                    },
                    {
                        "full": "[intercept]",
                        "name": "intercept",
                        "optional": true
                    },
                    {
                        "full": "[normalize]",
                        "name": "normalize",
                        "optional": true
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[tolerance]",
                        "name": "tolerance",
                        "optional": true
                    },
                    {
                        "full": "[positive]",
                        "name": "positive",
                        "optional": true
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    },
                    {
                        "full": "[checkInput]",
                        "name": "checkInput",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [lassoCV](https://docs.dolphindb.com/en/Functions/l/lassocv.html)\n\n\n\n#### Syntax\n\nlassoCV(ds, yColName, xColNames, \\[alphas], \\[intercept], \\[normalize], \\[maxIter], \\[tolerance], \\[positive], \\[swColName], \\[checkInput])\n\n#### Arguments\n\nThe `lassoCV` function inherits all parameters of function [lasso](https://docs.dolphindb.com/en/Functions/l/lasso.html), with one added parameter, *alphas*.\n\n**alphas** (optional) is a floating-point scalar or vector that represents the coefficient multiplied by the L1 norm penalty term. The default value is \\[0.01, 0.1, 1.0].\n\n#### Details\n\nEstimate a Lasso regression using 5-fold cross-validation and return a model corresponding to the optimal parameters.\n\n**Return value**: A dictionary containing the following keys\n\n* modelName: the model name, which is \"LassoCV\" for this method\n\n* coefficients: the regression coefficients\n\n* intercept: the intercept\n\n* dual\\_gap: the dual gap\n\n* tolerance: the tolerance for the optimization\n\n* iterations: the number of iterations\n\n* xColNames: the column names of the independent variables in the data source\n\n* predict: the function used for prediction\n\n* alpha: the penalty term for cross-validation\n\n#### Examples\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288]\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599]\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219]\nt = table(y, x0, x1);\n\nlassoCV(t, `y, `x0`x1);\n\n// output\nmodelName->lassoCV\ncoefficients->[94.4493,14.3046]\nintercept->0.0313\ndual_gap->0.0009\ntolerance->0.0001\niterations->5\nxColNames->[\"x0\",\"x1\"]\npredict->coordinateDescentPredict\nalpha->0.01\n```\n"
    },
    "last": {
        "url": "https://docs.dolphindb.com/en/Functions/l/last.html",
        "signatures": [
            {
                "full": "last(X)",
                "name": "last",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [last](https://docs.dolphindb.com/en/Functions/l/last.html)\n\n\n\n#### Syntax\n\nlast(X) / last X\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nReturn the last element of a vector, or the last row of a matrix or table.\n\nIf the last element is NULL, the function returns NULL. To get the last non-NULL element, use [lastNot](https://docs.dolphindb.com/en/Functions/l/lastNot.html).\n\n#### Examples\n\n```\nlast(`hello `world);\n// output\nworld\n\nlast(1..10);\n// output\n10\n\nm = matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nlast(m);\n// output\n[3,6]\n```\n\nRelated function: [first](https://docs.dolphindb.com/en/Functions/f/first.html)\n"
    },
    "lastNot": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lastNot.html",
        "signatures": [
            {
                "full": "lastNot(X, [k])",
                "name": "lastNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k]",
                        "name": "k",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [lastNot](https://docs.dolphindb.com/en/Functions/l/lastNot.html)\n\n\n\n#### Syntax\n\nlastNot(X, \\[k])\n\n#### Arguments\n\n**X** is a vector, a matrix or a table.\n\n**k** (optional) is a scalar.\n\n#### Details\n\nIf *X* is a vector:\n\n* If *k* is not specified: return the last element of *X* that is not NULL.\n\n* If *k* is specified: return the last element of *X* that is neither *k* nor NULL.\n\nIf *X* is a matrix/table, conduct the aforementioned calculation within each column of *X*. The result is a vector.\n\n`lastNot` also supports querying DFS tables and partitioned tables.\n\n#### Examples\n\n```\nlastNot(1 6 0 0 0, 0);\n// output\n6\n\nlastNot(1 6 0 0 0 2 3 0 NULL, 0);\n// output\n3\n\nlastNot(1 6 0 0 0 2 3 0 NULL);\n// output\n0\n\nt=table(1 1 1 1 1 2 2 2 2 2 as id, 1 2 0 0 0 3 NULL NULL 0 0 as x);\nt;\n```\n\n| id | x |\n| -- | - |\n| 1  | 1 |\n| 1  | 2 |\n| 1  | 0 |\n| 1  | 0 |\n| 1  | 0 |\n| 2  | 3 |\n| 2  |   |\n| 2  |   |\n| 2  | 0 |\n| 2  | 0 |\n\n```\nselect lastNot(x, 0) from t group by id;\n```\n\n| id | lastNot\\_x |\n| -- | ---------- |\n| 1  | 2          |\n| 2  | 3          |\n\n```\nm=matrix(2 NULL 1 0 NULL, NULL 2 NULL 6 0);\nm;\n```\n\n| #0 | #1  |\n| -- | --- |\n| 2  | 2   |\n| 1  |     |\n| 0  | 6 0 |\n\n```\nlastNot(m, 0);\n// output\n[1,6]\n```\n"
    },
    "lastWeekOfMonth": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lastWeekOfMonth.html",
        "signatures": [
            {
                "full": "lastWeekOfMonth(X, [weekday=0], [offset], [n=1])",
                "name": "lastWeekOfMonth",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weekday=0]",
                        "name": "weekday",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [lastWeekOfMonth](https://docs.dolphindb.com/en/Functions/l/lastWeekOfMonth.html)\n\n\n\n#### Syntax\n\nlastWeekOfMonth(X, \\[weekday=0], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**weekday** is an integer from 0 to 6. 0 means Monday, 1 means Tuesday, ..., and 6 means Sunday. The default value is 0.\n\n**offset** is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** is a positive integer. The default value is 1.\n\n#### Details\n\nIn the calendar month of *X*, suppose the last \"weekday\" is d.\n\n* If *X* \\<d: return the last \"weekday\" in the previous calendar month.\n\n* If *X* >=d: return the last \"weekday\" in the current calendar month.\n\nIf parameter *offset* is specified, the result is updated every *n* months. Parameter *offset* works only if parameter *n* >1.\n\n#### Examples\n\n```\nlastWeekOfMonth(2019.11.24,2);\n// output\n2019.10.30\n// The last Wednesday of November 2019 is 2019.11.27, 2019.11.24 is before 2019.11.27, so the function returns the last Wednesday of October 2019.\n\nlastWeekOfMonth(2019.11.29,2);\n// output\n2019.11.27\n\ndate=2012.01.02 2012.02.03 2012.03.07 2012.04.08 2012.05.12 2012.06.16 2012.07.18 2012.08.20 2012.09.25 2012.10.28\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by lastWeekOfMonth(date,4,2012.01.01,2);\n```\n\n| lastWeekOfMonth\\_date | avg\\_price | sum\\_qty |\n| --------------------- | ---------- | -------- |\n| 2011.12.30            | 39.53      | 4100     |\n| 2012.02.24            | 29.77      | 5300     |\n| 2012.04.27            | 175.1      | 12200    |\n| 2012.06.29            | 50.54      | 3800     |\n| 2012.08.31            | 51.29      | 8800     |\n| 2012.10.26            | 52.38      | 4500     |\n"
    },
    "latestIndexedTable": {
        "url": "https://docs.dolphindb.com/en/Functions/l/latestIndexedTable.html",
        "signatures": [
            {
                "full": "latestIndexedTable(keyColumns, timeColumn, [X1], [X2], .....)",
                "name": "latestIndexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "latestIndexedTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)",
                "name": "latestIndexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            },
            {
                "full": "latestIndexedTable(keyColumns, timeColumn, table)",
                "name": "latestIndexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [latestIndexedTable](https://docs.dolphindb.com/en/Functions/l/latestIndexedTable.html)\n\n#### Syntax\n\nlatestIndexedTable(keyColumns, timeColumn, \\[X1], \\[X2], .....)\n\nor\n\nlatestIndexedTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)\n\nor\n\nlatestIndexedTable(keyColumns, timeColumn, table)\n\n#### Arguments\n\n`latestIndexedTable` has an additional parameter *timeColumn* compared to the function [indexedTable](https://docs.dolphindb.com/en/Functions/i/indexedTable.html).\n\n**timeColumn** is a string indicating the column name of the time column. The time column can be integral or temporal type.\n\n#### Details\n\nCreate an indexed table, which is a special type of in-memory table with primary key. The primary key can be one column or multiple columns. Compared to the `indexedTable`, `latestIndexedTable` adds a time column to determine whether to update records.\n\nWhen a new record is appended to the indexed table, if its timestamp is smaller than that of the existing row which has the same primary key, it does not overwrite the existing row. `latestIndexedTable` deduplicates records with the same primary key based on the time column, which affects its writing performance (relatively slow compared with `indexedTable`).\n\n**Note:** The primary key cannot be updated.\n\nRefer to `indexedTable` for the optimization of query performance on `latestIndexedTable`.\n\n#### Examples\n\nExample 1. Create an indexed table.\n\nScenario 1:\n\n```\n\n    $ sym=`A`B`C`D`E\n    $ id=5 4 3 2 1\n    $ val=52 64 25 48 71\n    $ timeCol = 2022.12.07T00:00:00.001+0..4\n    $ t=latestIndexedTable(`sym`id,`timeCol,sym,id,timeCol,val)\n    $ t;\n```\n\n| sym | id | timeCol                 | val |\n| --- | -- | ----------------------- | --- |\n| A   | 5  | 2022.12.07T00:00:00.001 | 52  |\n| B   | 4  | 2022.12.07T00:00:00.002 | 64  |\n| C   | 3  | 2022.12.07T00:00:00.003 | 25  |\n| D   | 2  | 2022.12.07T00:00:00.004 | 48  |\n| E   | 1  | 2022.12.07T00:00:00.005 | 71  |\n\nScenario 2:\n\n```\n\n    $ t=latestIndexedTable(`sym`id,1:0,`sym`id`val,[SYMBOL,INT,INT])\n    $ insert into t values(`A`B`C`D`E,5 4 3 2 1,2022.12.07T00:00:00.001+0..4,52 64 25 48 71);\n```\n\nScenario 3:\n\n```\n\n    $ tmp=table(sym, id, timeCol, val)\n    $ t=latestIndexedTable(`sym`id, `timeCol, tmp);\n```\n\nExample 2. Update an indexed table.\n\nIf the new row has the same primary key value as an existing row, whether to update the record is determined by the time column.\n\n```\n\n    $ insert into t values(`A`A`E,5 5 1, 2022.12.07T00:00:00.001 2022.12.07T00:00:00.007 2022.12.07T00:00:00.003, 44 66 28);\n    $ t;\n```\n\n| sym | id | timeCol                 | val |\n| --- | -- | ----------------------- | --- |\n| A   | 5  | 2022.12.07T00:00:00.007 | 66  |\n| B   | 4  | 2022.12.07T00:00:00.002 | 64  |\n| C   | 3  | 2022.12.07T00:00:00.003 | 25  |\n| D   | 2  | 2022.12.07T00:00:00.004 | 48  |\n| E   | 1  | 2022.12.07T00:00:00.005 | 71  |\n\nRelated functions: [keyedTable](https://docs.dolphindb.com/en/Functions/k/keyedTable.html), [indexedTable](https://docs.dolphindb.com/en/Functions/i/indexedTable.html), [latestKeyedTable](https://docs.dolphindb.com/en/Functions/l/latestKeyedTable.html)\n\n"
    },
    "latestKeyedStreamTable": {
        "url": "https://docs.dolphindb.com/en/Functions/l/latestKeyedStreamTable.html",
        "signatures": [
            {
                "full": "latestKeyedStreamTable(keyColumns, timeColumn, [X1], [X2], .....)",
                "name": "latestKeyedStreamTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "latestKeyedStreamTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)",
                "name": "latestKeyedStreamTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            }
        ],
        "markdown": "### [latestKeyedStreamTable](https://docs.dolphindb.com/en/Functions/l/latestKeyedStreamTable.html)\n\n\n\n#### Syntax\n\nlatestKeyedStreamTable(keyColumns, timeColumn, \\[X1], \\[X2], .....)\n\nor\n\nlatestKeyedStreamTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)\n\n#### Arguments\n\n**keyColumns** is a string scalar or vector indicating the names of the primary key columns. The primary key columns must be of INTEGRAL, TEMPORAL, LITERAL, or FLOATING types.\n\n`latestKeyedStreamTable` has an additional parameter *timeColumn*compared to the function[keyedStreamTable](https://docs.dolphindb.com/en/Functions/k/keyedStreamTable.html).\n\n**timeColumn** specifies the time column(s) and can be either:\n\n* A string indicates a single column of integral or temporal type, or\n* A two-element vector indicates two columns that combine to form a unique timestamp: a DATE column and a TIME, SECOND, or NANOTIME column.\n\nFor the first scenario: *X*, *X1*, .... are vectors.\n\nFor the second scenario:\n\n**capacity** is the amount of memory (in terms of the number of rows) allocated to the table. When the number of rows exceeds capacity, the system will first allocate memory of 1.2-2 times of *capacity*, copy the data to the new memory space, and release the original memory. For large tables, these steps may use significant amount of memory.\n\n**size** can be 0 or 1, indicating the initial size (in terms of the number of rows) of the table. If size=0, create an empty table; If size = 1, create a table with one record, and the initialized values are:\n\n* false for Boolean type;\n\n* 0 for numeric, temporal, IPADDR, COMPLEX, and POINT types;\n\n* NULL for Literal, INT128 types.\n\n**colNames** is a string vector of column names.\n\n**colTypes** is a string vector of data types. As of 2.00.11.2, the non-key columns can be specified as array vectors.\n\n#### Details\n\nCreate a keyed stream table with one or more columns serving as the primary key. Compared to the `keyedStreamTable`, `latestKeyedStreamTable`maintains the most up-to-date record for each unique primary key based on a time column. When a new record arrives, the system compares its primary key to existing records in memory:\n\n* If a match is found, check the timestamps:\n  * If the new record's timestamp is more recent, it is inserted and replace the existing record.\n  * If not, the existing record remains unchanged.\n* If no matching primary key is found, add the new record to the table. In cases where multiple new records with the same key are written simultaneously, only the record with the most recent timestamp is inserted.\n\n#### Examples\n\n**Example 1**: Specifying a single primary key column.\n\nMethod 1:\n\n```\nid = `A`B`C`D`E\nx = 1 2 3 4 5\ntimeCol = 2024.09.10T00:00:00.001+0..4\nt1 = latestKeyedStreamTable(`id, `timeCol, id, x, timeCol)\nt1;\n```\n\nOutput:\n\n| id | x | timeCol                 |\n| -- | - | ----------------------- |\n| A  | 1 | 2024.09.10T00:00:00.001 |\n| B  | 2 | 2024.09.10T00:00:00.002 |\n| C  | 3 | 2024.09.10T00:00:00.003 |\n| D  | 4 | 2024.09.10T00:00:00.004 |\n| E  | 5 | 2024.09.10T00:00:00.005 |\n\nMethod 2:\n\n```\nt2=latestKeyedStreamTable(`id, `timeCol, 100:0, `id`x`timeCol, [INT,INT,TIMESTAMP])\ninsert into t2 values(1 2 3, 10 20 30, [2024.09.10T00:00:00.001,\n2024.09.10T00:00:00.002, 2024.09.10T00:00:00.003])\n\nt2\n```\n\nOutput:\n\n| id | x  | timeCol                 |\n| -- | -- | ----------------------- |\n| 1  | 10 | 2024.09.10T00:00:00.001 |\n| 2  | 20 | 2024.09.10T00:00:00.002 |\n| 3  | 30 | 2024.09.10T00:00:00.003 |\n\nInsert new rows to table t1.\n\n```\ninsert into t1 values(`D`E`F, 6 7 8, [2024.09.10T00:00:00.005,\n 2024.09.10T00:00:00.005, 2024.09.10T00:00:00.005])\nt1\n```\n\nOutput:\n\n| id | x | timeCol                 |\n| -- | - | ----------------------- |\n| A  | 1 | 2024.09.10T00:00:00.001 |\n| B  | 2 | 2024.09.10T00:00:00.002 |\n| C  | 3 | 2024.09.10T00:00:00.003 |\n| D  | 4 | 2024.09.10T00:00:00.004 |\n| E  | 5 | 2024.09.10T00:00:00.005 |\n| D  | 6 | 2024.09.10T00:00:00.005 |\n| F  | 8 | 2024.09.10T00:00:00.005 |\n\nWe can see from the output table that new rows are inserted into table t1 based on their id and timestamp. Row with id=D is inserted due to its newer timestamp than the existing D record. Row with id=E is discarded because it has the same timestamp as the existing E record. Row with id=F is inserted since there's no existing F record in the table.\n\n**Example 2**: Specifying multiple primary key columns.\n\n```\nt3 = latestKeyedStreamTable(`id`x, `timeCol, id, x, timeCol)\ninsert into t3 values(`D`E, 4 5, [2024.09.10T00:00:00.004, 2024.09.10T00:00:00.005])\ninsert into t3 values(`D`F, 6 7, [2024.09.10T00:00:00.004, 2024.09.10T00:00:00.005])\nt3\n```\n\nOutput:\n\n| id | x | timeCol                 |\n| -- | - | ----------------------- |\n| A  | 1 | 2024.09.10T00:00:00.001 |\n| B  | 2 | 2024.09.10T00:00:00.002 |\n| C  | 3 | 2024.09.10T00:00:00.003 |\n| D  | 4 | 2024.09.10T00:00:00.004 |\n| E  | 5 | 2024.09.10T00:00:00.005 |\n| D  | 6 | 2024.09.10T00:00:00.004 |\n| F  | 7 | 2024.09.10T00:00:00.005 |\n\n**Example 3**: Specifying two time columns.\n\n```\nid = `A`B`C`D`E\ndateCol = take(2024.09.10, 5)\ntimeCol = 00:00:00.001+0..4\nt4 = latestKeyedStreamTable(`id, `dateCol`timeCol, id, x, dateCol, timeCol)\nt4\n```\n\nOutput:\n\n| id | x | dateCol    | timeCol      |\n| -- | - | ---------- | ------------ |\n| A  | 1 | 2024.09.10 | 00:00:00.001 |\n| B  | 2 | 2024.09.10 | 00:00:00.002 |\n| C  | 3 | 2024.09.10 | 00:00:00.003 |\n| D  | 4 | 2024.09.10 | 00:00:00.004 |\n| E  | 5 | 2024.09.10 | 00:00:00.005 |\n\nInsert new rows to table t4 based on their id and timestamp. The timestamp is created by combining *dateCol* and *timeCol*, i.e.,`concatDateTime(dateCol, timeCol)`.\n\n```\ninsert into t4 values(`D`E, 4 5, [2024.09.10,  2024.09.11], [00:00:00.004, 00:00:00.005]);\nt4\n```\n\nOutput:\n\n| id | x | dateCol    | timeCol      |\n| -- | - | ---------- | ------------ |\n| A  | 1 | 2024.09.10 | 00:00:00.001 |\n| B  | 2 | 2024.09.10 | 00:00:00.002 |\n| C  | 3 | 2024.09.10 | 00:00:00.003 |\n| D  | 4 | 2024.09.10 | 00:00:00.004 |\n| E  | 5 | 2024.09.10 | 00:00:00.005 |\n| E  | 5 | 2024.09.11 | 00:00:00.005 |\n"
    },
    "latestKeyedTable": {
        "url": "https://docs.dolphindb.com/en/Functions/l/latestKeyedTable.html",
        "signatures": [
            {
                "full": "latestKeyedTable(keyColumns, timeColumn, [X1], [X2], .....)",
                "name": "latestKeyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "latestKeyedTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)",
                "name": "latestKeyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            },
            {
                "full": "latestKeyedTable(keyColumns, timeColumn, table)",
                "name": "latestKeyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [latestKeyedTable](https://docs.dolphindb.com/en/Functions/l/latestKeyedTable.html)\n\n#### Syntax\n\nlatestKeyedTable(keyColumns, timeColumn, \\[X1], \\[X2], .....)\n\nor\n\nlatestKeyedTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)\n\nor\n\nlatestKeyedTable(keyColumns, timeColumn, table)\n\n#### Arguments\n\n`latestKeyedTable` has an additional parameter *timeColumn* compare to the function [keyedTable](https://docs.dolphindb.com/en/Functions/k/keyedTable.html).\n\n**timeColumn** is a string indicating the column name of the time column. The time column can be integral or temporal type.\n\n#### Details\n\nCreate a keyed table, which is a special type of in-memory table with primary key. The primary key can be one column or multiple columns. Compared to the `keyedTable`, `latestKeyedTable` adds a time column to determine whether to update records.\n\nWhen a new record is appended to the keyed table, if its timestamp is smaller than that of the existing row which has the same primary key, it does not overwrite the existing row. `latestKeyedTable` deduplicates records with the same primary key based on the time column, which affects its writing performance (relatively slow compared with `keyedTable`).\n\n**Note:** The primary key cannot be modified (with functions `update`, or `replaceColumn!`) or deleted (with functions `alter`, or `dropColumns!`).\n\nRefer to `keyedTable` for the optimization of query performance on `latestKeyedTable`.\n\n#### Examples\n\nExample 1. Create a keyed table.\n\nScenario 1:\n\n```\nsym=`A`B`C`D`E\nid=5 4 3 2 1\nval=52 64 25 48 71\ntimeCol = 2022.12.07T00:00:00.001+0..4\nt=latestKeyedTable(`sym`id,`timeCol,sym,id,timeCol,val)\nt;\n    \n```\n\n| sym | id | timeCol                 | val |\n| --- | -- | ----------------------- | --- |\n| A   | 5  | 2022.12.07T00:00:00.001 | 52  |\n| B   | 4  | 2022.12.07T00:00:00.002 | 64  |\n| C   | 3  | 2022.12.07T00:00:00.003 | 25  |\n| D   | 2  | 2022.12.07T00:00:00.004 | 48  |\n| E   | 1  | 2022.12.07T00:00:00.005 | 71  |\n\nScenario 2:\n\n```\nt=latestKeyedTable(`sym`id,1:0,`sym`id`val,[SYMBOL,INT,INT])\ninsert into t values(`A`B`C`D`E,5 4 3 2 1,2022.12.07T00:00:00.001+0..4,52 64 25 48 71);\n```\n\nScenario 3:\n\n```\ntmp=table(sym, id, timeCol, val)\nt=latestKeyedTable(`sym`id, `timeCol, tmp);\n```\n\nExample 2. Update a keyed table.\n\nIf the new row has the same primary key value as an existing row, whether to update the record is determined by the time column.\n\n```\ninsert into t values(`A`A`E,5 5 1, 2022.12.07T00:00:00.001 2022.12.07T00:00:00.007 2022.12.07T00:00:00.003, 44 66 28);\n t;\n```\n\n| sym | id | timeCol                 | val |\n| --- | -- | ----------------------- | --- |\n| A   | 5  | 2022.12.07T00:00:00.007 | 66  |\n| B   | 4  | 2022.12.07T00:00:00.002 | 64  |\n| C   | 3  | 2022.12.07T00:00:00.003 | 25  |\n| D   | 2  | 2022.12.07T00:00:00.004 | 48  |\n| E   | 1  | 2022.12.07T00:00:00.005 | 71  |\n\nRelated functions: [keyedTable](https://docs.dolphindb.com/en/Functions/k/keyedTable.html), [indexedTable](https://docs.dolphindb.com/en/Functions/i/indexedTable.html), [latestIndexedTable](https://docs.dolphindb.com/en/Functions/l/latestIndexedTable.html)\n\n"
    },
    "le": {
        "url": "https://docs.dolphindb.com/en/Functions/l/le.html",
        "signatures": [
            {
                "full": "le(X, Y)",
                "name": "le",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [le](https://docs.dolphindb.com/en/Functions/l/le.html)\n\n\n\n#### Syntax\n\nle(X, Y) or X<=Y\n\n#### Arguments\n\n**X** / **Y** is a scalar/pair/vector/matrix/set. If *X* or *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nIf neither *X* nor *Y* is a set, return the element-by-element comparison of *X*<=*Y*.\n\nIf both *X* and *Y* are sets, check if *X* is a subset of *Y*.\n\n#### Examples\n\n```\n1 2 3 <= 2;\n// output\n[1,1,0]\n\n1 2 3<=0 2 4;\n// output\n[0,1,1]\n\n2:3<=1:6;\n// output\n0 : 1\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 le 4;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 0  |\n| 1  | 1  | 0  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1<=m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 0  |\n| 1  | 0  | 0  |\n\nSet operation: If *X*<=*Y* then *X* is a subset of *Y*\n\n```\nx=set(4 6);\ny=set(4 6 8);\n\nx<=y;\n// output\n1\nx<=x;\n// output\n1\n```\n"
    },
    "left": {
        "url": "https://docs.dolphindb.com/en/Functions/l/left.html",
        "signatures": [
            {
                "full": "left(X,n)",
                "name": "left",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [left](https://docs.dolphindb.com/en/Functions/l/left.html)\n\n\n\n#### Syntax\n\nleft(X,n)\n\n#### Arguments\n\n**X** is a string scalar or vector.\n\n**n** is a positive integer.\n\n#### Details\n\nReturn the first *n* characters of string *X*.\n\n#### Examples\n\n```\nleft(\"I love this game!\", 6);\n// output\nI love\n```\n"
    },
    "lfill!": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lfill!.html",
        "signatures": [
            {
                "full": "lfill!(obj)",
                "name": "lfill!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    }
                ]
            }
        ],
        "markdown": "### [lfill!](https://docs.dolphindb.com/en/Functions/l/lfill!.html)\n\n\n\n#### Syntax\n\nlfill!(obj)\n\n#### Arguments\n\n**obj** is a vector or a table with only numeric columns.\n\n#### Details\n\nPlease refer to [lfill](https://docs.dolphindb.com/en/Functions/l/lfill.html). The only difference between *lfill* and *lfill!* is that the latter assigns the result to *X* and thus changing the value of *X* after the execution.\n\n#### Examples\n\n```\na= NULL 1.5 NULL NULL 4.5\na.lfill!()\na;\n[NULL,1.5,2.5,3.5,4.5]\n\nb=1 NULL NULL 6\nb.lfill!()\nb;\n[1,3,4,6]\n\nt=table(1 NULL NULL 4 5 6 as id,2.1 2.2 NULL NULL 2.4 2.6 as val);\nlfill!(t);\nt;\n```\n\n| id | val      |\n| -- | -------- |\n| 1  | 2.1      |\n| 2  | 2.2      |\n| 3  | 2.266667 |\n| 4  | 2.333333 |\n| 5  | 2.4      |\n| 6  | 2.6      |\n\nRelated functions: [bfill](https://docs.dolphindb.com/en/Functions/b/bfill.html), [bfill!](https://docs.dolphindb.com/en/Functions/b/bfill!.html), [lfill!](https://docs.dolphindb.com/en/Functions/l/lfill!.html)\n"
    },
    "lfill": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lfill.html",
        "signatures": [
            {
                "full": "lfill(obj)",
                "name": "lfill",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    }
                ]
            }
        ],
        "markdown": "### [lfill](https://docs.dolphindb.com/en/Functions/l/lfill.html)\n\n\n\n#### Syntax\n\nlfill(obj)\n\n#### Arguments\n\n**obj** is a vector or a table with only numeric columns.\n\n#### Details\n\n* If *obj* is a vector: linearly fill the NULL values between 2 non-NULL numeric values in *obj*.\n\n* If *obj* is a table with only numeric columns: for each column of the table, linearly fill the NULL values between 2 non-NULL numeric values.\n\n*lfill* does not change *obj*, whereas *lfill!* changes *obj*.\n\n#### Examples\n\n```\na= NULL 1.5 NULL NULL 4.5\na.lfill();\n// output\n[NULL,1.5,2.5,3.5,4.5]\n\nb=1 NULL NULL 6\nb.lfill();\n// output\n[1,3,4,6]\n\nt=table(1 NULL NULL 4 5 6 as id,2.1 2.2 NULL NULL 2.4 2.6 as val);\nselect * from lfill(t);\n```\n\n| id | val      |\n| -- | -------- |\n| 1  | 2.1      |\n| 2  | 2.2      |\n| 3  | 2.266667 |\n| 4  | 2.333333 |\n| 5  | 2.4      |\n| 6  | 2.6      |\n\nRelated functions: [bfill](https://docs.dolphindb.com/en/Functions/b/bfill.html), [bfill!](https://docs.dolphindb.com/en/Functions/b/bfill!.html), [lfill!](https://docs.dolphindb.com/en/Functions/l/lfill!.html)\n"
    },
    "license": {
        "url": "https://docs.dolphindb.com/en/Functions/l/license.html",
        "signatures": [
            {
                "full": "license([fileName], [pubKeyFile], [read=false])",
                "name": "license",
                "parameters": [
                    {
                        "full": "[fileName]",
                        "name": "fileName",
                        "optional": true
                    },
                    {
                        "full": "[pubKeyFile]",
                        "name": "pubKeyFile",
                        "optional": true
                    },
                    {
                        "full": "[read=false]",
                        "name": "read",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [license](https://docs.dolphindb.com/en/Functions/l/license.html)\n\n\n\n#### Syntax\n\nlicense(\\[fileName], \\[pubKeyFile], \\[read=false])\n\n#### Arguments\n\n**fileName** (optional) is the path of the license.\n\n**pubKeyFile** (optional) is the path of the public key file.\n\n**read** (optional) is a Boolean value indicating whether to disable the license file verification before returning the result. The default value is false.\n\n#### Details\n\nDisplay information regarding the DolphinDB license. If *fileName* is not specified, the license information from memory is obtained by default.\n\nIt returns a dictionary with the following keys:\n\n<table><thead><tr><th align=\"left\">\n\nKeys\n\n</th><th align=\"left\">\n\nMeaning\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\nauthorization\n\n</td><td align=\"left\">\n\nauthorization types: trial/test/commercial\n\n</td></tr><tr><td align=\"left\">\n\nlicenseType\n\n</td><td align=\"left\">\n\nThe license type: -   1: fingerprint authentication;\n\n* 2: online verification;\n* 3: license server;\n* 0: others\n\n</td></tr><tr><td align=\"left\">\n\nmaxMemoryPerNode\n\n</td><td align=\"left\">\n\nthe maximum memory for each node (in GB)\n\n</td></tr><tr><td align=\"left\">\n\nbindCores\n\n</td><td align=\"left\">\n\nCPU ID(s) (starting from 0) that are already bound to the DolphinDB process. Note that it takes effect only when bindCPU is configured to true.\n\n</td></tr><tr><td align=\"left\">\n\nmaxCoresPerNode\n\n</td><td align=\"left\">\n\nthe maximum cores for each node\n\n</td></tr><tr><td align=\"left\">\n\nclientName\n\n</td><td align=\"left\">\n\nthe client name\n\n</td></tr><tr><td align=\"left\">\n\nport\n\n</td><td align=\"left\">\n\nthe port number bound to the node. It is returned only for the license server and its connected nodes.\n\n</td></tr><tr><td align=\"left\">\n\nbindCPU\n\n</td><td align=\"left\">\n\nwhether a DolphinDB process is bound to a CPU\n\n</td></tr><tr><td align=\"left\">\n\nexpiration\n\n</td><td align=\"left\">\n\nthe expiration date of the license\n\n</td></tr><tr><td align=\"left\">\n\nmaxNodes\n\n</td><td align=\"left\">\n\nthe maximum number of nodes for the cluster\n\n</td></tr><tr><td align=\"left\">\n\nversion\n\n</td><td align=\"left\">\n\nthe version number of the server. Only a server that is not higher than the version can be used. If it is empty, there is no restriction on the version.\n\n</td></tr><tr><td align=\"left\">\n\nmodules\n\n</td><td align=\"left\">\n\na decimal converted from 4-bit binary number, indicating the supported modules.\n\n</td></tr><tr><td align=\"left\">\n\nmoduleNames\n\n</td><td align=\"left\">\n\nnames of supported *modules*. Currently, only *orderbook*, *internalFunction*, *cep*, *gpu* will be returned.\n\n</td></tr><tr><td align=\"left\">\n\nproductKey\n\n</td><td align=\"left\">\n\nthe current product. The return value includes DOLPHIN, IOTBASIC, IOTPRO, SHARK, SWORDFISH.\n\n</td></tr></tbody>\n</table>## Examples\n\n```language-python\nlicense();\n/* output\nclientName->internal\nbindCPU->true\nmaxNodes->128\nmoduleNames-> orderbook internalFunction cep gpu\nproductKey->DOLPHIN\nversion->3.10\nmodules->15\nauthorization->trial\nmaxMemoryPerNode->512\nlicenseType->0\nbindCores->\nmaxCoresPerNode->128\nport->0\nexpiration->2024.09.30\n*/\n```\n"
    },
    "like": {
        "url": "https://docs.dolphindb.com/en/Functions/l/like.html",
        "signatures": [
            {
                "full": "like(X, pattern)",
                "name": "like",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    }
                ]
            }
        ],
        "markdown": "### [like](https://docs.dolphindb.com/en/Functions/l/like.html)\n\n\n\n#### Syntax\n\nlike(X, pattern)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n**pattern** is a string and is usually used with a wildcard character such as %.\n\n#### Details\n\nReturn a Boolean value scalar or vector indicating whether each element in *X* fits a specific pattern. The comparison is case sensitive.\n\n#### Examples\n\n```\nlike(`ABCDEFG, `DE);\n// output\nfalse\n\nlike(`ABCDEFG, \"%DE%\");\n// output\ntrue\n\na=`IBM`ibm`MSFT`Goog`YHOO`ORCL;\nlike(a, \"%OO%\");\n// output\n[false,false,false,false,true,false]\n\na[like(a, \"%OO%\")];\n// output\n[\"YHOO\"]\n```\n\n`like` can be used with SQL SELECT to filter columns of STRING type:\n\n```\nt = table(`abb`aac`aaa as sym, 1.8 2.3 3.7 as price);\nselect * from t where sym like \"%aa%\";\n```\n\n| sym | price |\n| --- | ----- |\n| aac | 2.3   |\n| aaa | 3.7   |\n\nRelated function: [ilike](https://docs.dolphindb.com/en/Functions/i/ilike.html)\n"
    },
    "linearInterpolateFit": {
        "url": "https://docs.dolphindb.com/en/Functions/l/linearInterpolateFit.html",
        "signatures": [
            {
                "full": "linearInterpolateFit(X, Y, [fillValue], [sorted=false])",
                "name": "linearInterpolateFit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[fillValue]",
                        "name": "fillValue",
                        "optional": true
                    },
                    {
                        "full": "[sorted=false]",
                        "name": "sorted",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [linearInterpolateFit](https://docs.dolphindb.com/en/Functions/l/linearInterpolateFit.html)\n\n\n\n#### Syntax\n\nlinearInterpolateFit(X, Y, \\[fillValue], \\[sorted=false])\n\n#### Arguments\n\n**X** is a numeric vector indicating the x-coordinates of the points for interpolation. Note that *X* must contain no less than two unique values with no NULLs.\n\n**Y** is a numeric vector indicating the y-coordinates of the points for interpolation. Note that *Y* must be of the same length as *X* with no NULLs.\n\n**fillValue** (optional) specifies how to assign values for the x-coordinate of the points outside the existing data range. The following options are supported:\n\n* A numeric pair in the form `(min, max)`, where `min` and `max` represent the values assigned when the x-coordinate of the point Xnew is smaller than the minimum of *X* or larger than the maximum of *X*, respectively. Specifically:\n  * If Xnew < Xmin, it is assigned `below`.\n  * If Xnew > Xmax, it is assigned `above`.\n* The string \"extrapolate\" (default), which indicates that extrapolation is performed.\n\n**sorted**(optional) is a Boolean scalar indicating whether the input *X* is sorted in ascending order.\n\n* If set to true, *X* must be in ascending order.\n* If set to false (default), the function will sort *X* and adjust the order of *Y* accordingly.\n\n#### Details\n\nPerform linear interpolation/extrapolation on a set of points. Interpolation estimates unknown values that fall between known data points, while extrapolation estimates values beyond the existing data range.\n\n**Return value**: A dictionary containing the following keys:\n\n* modelName: A string indicating the model name, which is \"linearInterpolate\".\n* sortedX: A DOUBLE vector indicating the input *X*sorted in ascending order.\n* sortedY: A DOUBLE vector indicating the input *Y* sorted corresponding to *sortedX*.\n* fillValue: The input *fillValue*.\n* predict: The prediction function of the model, which returns linear interpolation results. It can be called using `model.predict(X)` or `predict(model, X)`, where:\n  * model: A dictionary indicating the output of `linearInterpolateFit`.\n  * X: A numeric vector indicating the x-coordinates of the points to be predicted.\n\n#### Examples\n\n```\ndef linspace(start, end, num, endpoint=true){\n\tif(endpoint) return end$DOUBLE\\(num-1), start + end$DOUBLE\\(num-1)*0..(num-1)\n\telse return start + (end-start)$DOUBLE\\(num)*0..(num-1)\t\n}\nx = 0..9\ny = exp(-x/3.0)\nmodel = linearInterpolateFit(x, y, sorted=true)\n\n/*Output\nsortedX->[0.0,1.000000000000,2.000000000000,3.000000000000,4.000000000000,5.000000000000,6.000000000000,7.000000000000,8.000000000000,9.000000000000]\nmodelName->linearInterpolate\npredict->linearInterpolatePredict\nfillValue->extrapolate\nsortedY->[1.000000000000,0.716531310573,0.513417119032,0.367879441171,0.263597138115,0.188875602837,0.135335283236,0.096971967864,0.069483451222,0.049787068367]\n*/\n\n// Enter new values of X to predict the corresponding Y values\nmodel.predict(xnew)\n\n//Output：[1,0.829918786344274,0.67590847226555,0.554039957340832,0.455202047888132,0.367879441171442,0.305310059338013,0.248652831060094,0.203819909893195,0.167459474997182,0.135335283236613,0.112317294013288,0.091474264536084,0.074981154551122,0.061604898080826]\n```\n"
    },
    "linearTimeTrend": {
        "url": "https://docs.dolphindb.com/en/Functions/l/linearTimeTrend.html",
        "signatures": [
            {
                "full": "linearTimeTrend(X, window)",
                "name": "linearTimeTrend",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [linearTimeTrend](https://docs.dolphindb.com/en/Functions/l/linearTimeTrend.html)\n\n\n\n#### Syntax\n\nlinearTimeTrend(X, window)\n\nPlease see [TALib](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving linear regression for *X*. Return a tuple with 2 elements, alpha (the Linear regression intercept *LINEARREG\\_INTERCEPT*) and beta (the linear regression slope *LINEARREG\\_SLOPE*).\n\n#### Examples\n\n```\nx = 3 3 5 7 8 9 10 11 15 13 12 11 10\nprint linearTimeTrend(x,3)\n// output\n([,,2.666666666666666,3,5.166666666666667,7,8,9,9.5,12,14.833333333333333,13,12],[,,1,2,1.5,1,1,1,2.5,1,-1.5,-1,-1])\n```\n\n```\nn = 10\nt = table(09:00:00 + 1..n as time, rand(`A`B, n) as sym, rand(100.0, n) as val1, rand(1000..2000, n) as val2)\nselect time, sym, linearTimeTrend(val1, 3) as `alpha`beta from t\n```\n\n| time     | sym | alpha   | beta     |\n| -------- | --- | ------- | -------- |\n| 09:00:01 | B   |         |          |\n| 09:00:02 | A   |         |          |\n| 09:00:03 | A   | 85.0844 | -30.0688 |\n| 09:00:04 | B   | 49.3461 | 7.3621   |\n| 09:00:05 | B   | 30.4248 | 28.3589  |\n| 09:00:06 | A   | 83.106  | -7.7515  |\n| 09:00:07 | B   | 78.4412 | -17.7575 |\n| 09:00:08 | A   | 56.8575 | 4.4732   |\n| 09:00:09 | A   | 53.8492 | -6.0653  |\n| 09:00:10 | A   | 61.7888 | -4.5586  |\n"
    },
    "linprog": {
        "url": "https://docs.dolphindb.com/en/Functions/l/linprog.html",
        "signatures": [
            {
                "full": "linprog(f, [A], [b], [Aeq], [beq], [lb], [ub], [method='simplex'])",
                "name": "linprog",
                "parameters": [
                    {
                        "full": "f",
                        "name": "f"
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[b]",
                        "name": "b",
                        "optional": true
                    },
                    {
                        "full": "[Aeq]",
                        "name": "Aeq",
                        "optional": true
                    },
                    {
                        "full": "[beq]",
                        "name": "beq",
                        "optional": true
                    },
                    {
                        "full": "[lb]",
                        "name": "lb",
                        "optional": true
                    },
                    {
                        "full": "[ub]",
                        "name": "ub",
                        "optional": true
                    },
                    {
                        "full": "[method='simplex']",
                        "name": "method",
                        "optional": true,
                        "default": "'simplex'"
                    }
                ]
            }
        ],
        "markdown": "### [linprog](https://docs.dolphindb.com/en/Functions/l/linprog.html)\n\n\n\n#### Syntax\n\nlinprog(f, \\[A], \\[b], \\[Aeq], \\[beq], \\[lb], \\[ub], \\[method='simplex'])\n\n#### Details\n\nSolve the following optimization problem with a linear objective function and a set of linear constraints.\n\n![](https://docs.dolphindb.com/en/images/linprog.png)\n\nThe result is a 2-element tuple. The first element is the minimum value of the objective function. The second element is the value of *x* where the value of the objective function is minimized.\n\n#### Arguments\n\n**A** and **Aeq** must be matrices with the same number of columns.\n\n**f**, **b** and **beq** are vectors.\n\n**lb** and **ub** are scalars or vectors with the same length as *x* indicating the lower bounds and upper bounds of *x*.\n\n* If *lb* or *ub* is a scalar, all elements of *x* are subject to the same lower bound or upper bound constraint.\n\n* If *lb* or *ub* is NULL, there is no lower bound or upper bound constraint for *x*.\n\n* If *lb* or *ub* is a vector, an element of *x* is subject to the lower bound or upper bound constraint specified by the corresponding element of *lb* or *ub*.\n\n**method** is a string indicating the optimization algorithm. It can be either 'simplex' (recommended) or 'interior-point'.\n\n#### Examples\n\nExample 1. Find the minimum of x+2y subject to the constraints of\n\n![](https://docs.dolphindb.com/en/images/linprog1.png)\n\n```\nf = [1, 2];\nA = [-1, -1]$1:2;\nb = [-2];\nub = 2;\nre = linprog(f, A, b, , , , ub);\n\nre[0];\n// output\n2\n\nre[1];\n// output\n[2,0]\n```\n\nExample 2. Find the minimum of -3x1-2x2 subject to the constraints of\n\n![](https://docs.dolphindb.com/en/images/linprog2.png)\n\n```\nf = [-3, -2];\nA = [2, 1, 1, 1]$2:2;\nb = [10, 8];\nub = [4, NULL];\nre = linprog(f, A, b, , , , ub);\n\nre[0];\n// output\n-18\n\nre[1];\n// output\n[2,6]\n```\n\nRelated function: [scs](https://docs.dolphindb.com/en/Functions/s/scs.html), [quadprog](https://docs.dolphindb.com/en/Functions/q/quadprog.html)\n"
    },
    "listRemotePlugins": {
        "url": "https://docs.dolphindb.com/en/Functions/l/listRemotePlugins.html",
        "signatures": [
            {
                "full": "listRemotePlugins([pluginName], [pluginServerAddr])",
                "name": "listRemotePlugins",
                "parameters": [
                    {
                        "full": "[pluginName]",
                        "name": "pluginName",
                        "optional": true
                    },
                    {
                        "full": "[pluginServerAddr]",
                        "name": "pluginServerAddr",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [listRemotePlugins](https://docs.dolphindb.com/en/Functions/l/listRemotePlugins.html)\n\n\n\n#### Syntax\n\nlistRemotePlugins(\\[pluginName], \\[pluginServerAddr])\n\n#### Arguments\n\n**pluginName** (optional) is a string indicating the plugin name.\n\n**pluginServerAddr** (optional) is a string indicating the HTTP address of the DolphinDB plugins repository that the system should use. It is recommended to specify it as \"<http://plugins.dolphindb.com/plugins>\".\n\n#### Details\n\n`listRemotePlugins` returns a table listing the available DolphinDB plugins and their versions.\n\nIf *pluginName* is specified, the function returns the specified plugin. If the specified plugin does not exist, the function returns an empty record. If *pluginName* is not specified, the function returns all the specified plugins.\n\n**Note**: The returned plugin information is based on DolphinDB server version and the operation system.\n\n#### Examples\n\nList all available plugins:\n\n```\nlistRemotePlugins()\n```\n\nReturn a plugin list:\n\n| PluginName  | PluginVersion      |\n| ----------- | ------------------ |\n| hdf5        | *\\<PluginVersion>* |\n| matchEngine | *\\<PluginVersion>* |\n| mongodb     | *\\<PluginVersion>* |\n| mqtt        | *\\<PluginVersion>* |\n| mseed       | *\\<PluginVersion>* |\n| mysql       | *\\<PluginVersion>* |\n| nsq         | *\\<PluginVersion>* |\n| odbc        | *\\<PluginVersion>* |\n| opc         | *\\<PluginVersion>* |\n| opcua       | *\\<PluginVersion>* |\n| zip         | *\\<PluginVersion>* |\n\n*\\<PluginVersion>* refers to the version information of the plugin, such as \"2.00.11\" and \"1.30.23\".\n\nRelated function: [installPlugin](https://docs.dolphindb.com/en/Functions/i/installPlugin.html)\n"
    },
    "listTables": {
        "url": "https://docs.dolphindb.com/en/Functions/l/listTables.html",
        "signatures": [
            {
                "full": "listTables(dbUrl)",
                "name": "listTables",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    }
                ]
            }
        ],
        "markdown": "### [listTables](https://docs.dolphindb.com/en/Functions/l/listTables.html)\n\n\n\n#### Syntax\n\nlistTables(dbUrl)\n\n#### Arguments\n\n**dbUrl** is a string indicating the local path or DFS path of a database.\n\n#### Details\n\nReturn a table of two columns, tableName and physicalIndex. Please note that only the database with chunks of the table level can have physical indices.\n\n#### Examples\n\n```\nlistTables(dbPath)\n```\n\n| tableName | physicalIndex |\n| --------- | ------------- |\n| pt1       | 1By           |\n| pt        | 1Bw           |\n"
    },
    "loadBackup": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadBackup.html",
        "signatures": [
            {
                "full": "loadBackup(backupDir, dbPath, partition, tableName)",
                "name": "loadBackup",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "partition",
                        "name": "partition"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [loadBackup](https://docs.dolphindb.com/en/Functions/l/loadBackup.html)\n\n\n\n#### Syntax\n\nloadBackup(backupDir, dbPath, partition, tableName)\n\n#### Arguments\n\n**backupDir** is a string indicating the directory where the backup is saved.\n\n**dbPath** is a string indicating the path of a DFS database. For example: \"dfs\\://demo\".\n\n**partition** is a string indicating the path of a partition under the database. For example: \"/20190101/GOOG\".\n\n**Note:**\n\nFor versions between 1.30.16/2.00.4 -1.30.18/2.00.6, if *chunkGranularity* is set to \"TABLE\" when creating the database, *partition* must include the physical index (which you can get with the `listTables` function) of the selected partition. For example, if the physical index of the \"/20190101/GOOG\" partition is 8, then specify partition as \"/20190101/GOOG/8\" to load its backup.\n\n**tableName** is a string indicating a distributed table name.\n\n#### Details\n\nLoad the backup of a partition in a distributed table. It must be executed by a logged-in user.\n\nCurrently, this function only supports loading a partition backed up with SQL statement (when the parameter *sqlObj* is specified for function [backup](https://docs.dolphindb.com/en/Functions/b/backup.html)).\n\n#### Examples\n\n```\nloadBackup(\"/home/DolphinDB/backup\",\"dfs://valuedb\", \"/200001M\",\"pt\");\n```\n\n| month    | x   |\n| -------- | --- |\n| 2000.01M | 1   |\n| 2000.01M | 205 |\n| 2000.01M | 409 |\n| 2000.01M | 613 |\n| 2000.01M | 817 |\n"
    },
    "loadDistributedInMemoryTable": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadDistributedInMemoryTable.html",
        "signatures": [
            {
                "full": "loadDistributedInMemoryTable(tableName)",
                "name": "loadDistributedInMemoryTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [loadDistributedInMemoryTable](https://docs.dolphindb.com/en/Functions/l/loadDistributedInMemoryTable.html)\n\n\n\n#### Syntax\n\nloadDistributedInMemoryTable(tableName)\n\n#### Arguments\n\n**tableName** is a STRING scalar indicating column names of a distributed in-memory table.\n\n#### Details\n\nDelete the specified distributed in-memory table. This function can only be executed on a data node or compute node.\n\n#### Examples\n\n```\npt = createDistributedInMemoryTable(`dt, `time`id`value, `DATETIME`INT`LONG, HASH, [INT, 2],`id)\ntime = take(2021.08.20 00:00:00..2021.08.30 00:00:00, 40);\nid = 0..39;\nvalue = rand(100, 40);\ntmp = table(time, id, value);\n\npt = loadDistributedInMemoryTable(`dt)\npt.append!(tmp);\nselect * from pt;\n```\n\nRelated functions: [dropDistributedInMemoryTable](https://docs.dolphindb.com/en/Functions/d/dropDistributedInMemoryTable.html), [createDistributedInMemoryTable](https://docs.dolphindb.com/en/Functions/c/createDistributedInMemoryTable.html)\n"
    },
    "loadIPCInMemoryTable": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadIPCInMemoryTable.html",
        "signatures": [
            {
                "full": "loadIPCInMemoryTable(tableName)",
                "name": "loadIPCInMemoryTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [loadIPCInMemoryTable](https://docs.dolphindb.com/en/Functions/l/loadIPCInMemoryTable.html)\n\n\n\n#### Syntax\n\nloadIPCInMemoryTable(tableName)\n\n#### Arguments\n\n**tableName** is a STRING indicating the name of IPC in-memory table to be loaded.\n\n#### Details\n\nLoad an IPC in-memory table and return its handle.\n\n**Note:** This function only runs on Linux.\n\n#### Examples\n\n```\nipc_t = loadIPCInMemoryTable(\"ipc_table\")\nipc_t\n// output\ntimestamp temperature\n```\n"
    },
    "loadModel": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadModel.html",
        "signatures": [
            {
                "full": "loadModel(file)",
                "name": "loadModel",
                "parameters": [
                    {
                        "full": "file",
                        "name": "file"
                    }
                ]
            }
        ],
        "markdown": "### [loadModel](https://docs.dolphindb.com/en/Functions/l/loadModel.html)\n\n\n\n#### Syntax\n\nloadModel(file)\n\n#### Arguments\n\n**file** is a string indicating the absolute path and name of the output file.\n\n#### Details\n\nLoad the specifications of a trained model into memory as a dictionary.\n\n#### Examples\n\n```\nx1 = rand(100.0, 100)\nx2 = rand(100.0, 100)\nb0 = 6\nb1 = 1\nb2 = -2\nerr = norm(0, 10, 100)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(x1, x2, y)\nmodel = randomForestRegressor(sqlDS(<select * from t>), `y, `x1`x2)\nsaveModel(model, \"C:/DolphinDB/Data/regressionModel.txt\");\n\nmodel = loadModel(\"C:/DolphinDB/Data/regressionModel.txt\")\nyhat = predict(model, t);\n```\n"
    },
    "loadModule": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadModule.html",
        "signatures": [
            {
                "full": "loadModule(name,[moduleDir])",
                "name": "loadModule",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[moduleDir]",
                        "name": "moduleDir",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [loadModule](https://docs.dolphindb.com/en/Functions/l/loadModule.html)\n\n\n\n#### Syntax\n\nloadModule(name,\\[moduleDir])\n\n#### Arguments\n\n**name** is a string indicating the module name.\n\n**moduleDir** is a string indicating the directory where the *.dos* and *.dom* files of modules are located.\n\n#### Details\n\nLoad the functions in a module or plug-in as DolphinDB built-in functions. If the module relies on other modules, the system will also load these modules. It must be executed by a logged-in user.\n\nWhen the system starts up, the configuration parameter *moduleDir* determines the directory where the module is located:\n\n* If the configuration parameter is an absolute path, it is the directory where the search module is located.\n\n* If the configuration parameter is a relative path, the system will search in the three directories: HOMEDIR, WORKDIR and EXECDIR sequentially. If it is found, use the directory as *moduleDir*; if it cannot be found, use `<HOMEDIR> + \"/\" + <moduleDir>` as the absolute path of modules.\n\n* If the configuration parameter *moduleDir* is not set, it is the same as when setting it to a relative path.\n\nIf the module directory contains both a *.dos* file and a *.dom* file with the same name, the system will only load the *.dom* file.\n\n**Note:** *loadModule* can only be used in the initialization script (*dolphindb.dos* as the default file) of the system.\n\nFunction `loadModule` has the same function with the configuration parameter *preloadModules*.\n\n#### Examples\n\nExample 1. Load modules:\n\n```\nloadModule(\"ta\");\n\nloadModule(\"system::log::fileLog\");\n```\n\nExample 2. Load plugins:\n\n```\nloadModule(\"plugins::mysql\");\n\nloadModule(\"plugins::odbc\");\n```\n\nRelated command: [saveModule](https://docs.dolphindb.com/en/Functions/s/saveModule.html)\n"
    },
    "loadModuleFromScript": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadModuleFromScript.html",
        "signatures": [
            {
                "full": "loadModuleFromScript(moduleNamespace, moduleScript, [reload=false])",
                "name": "loadModuleFromScript",
                "parameters": [
                    {
                        "full": "moduleNamespace",
                        "name": "moduleNamespace"
                    },
                    {
                        "full": "moduleScript",
                        "name": "moduleScript"
                    },
                    {
                        "full": "[reload=false]",
                        "name": "reload",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [loadModuleFromScript](https://docs.dolphindb.com/en/Functions/l/loadModuleFromScript.html)\n\n#### Syntax\n\nloadModuleFromScript(moduleNamespace, moduleScript, \\[reload=false])\n\n#### Arguments\n\n* **moduleNamespace** is a STRING scalar or vector indicating the module namespace(s). If there are dependencies between modules, namespaces for all modules must be provided.\n* **moduleScript** is a STRING scalar or vector indicating the module script(s).\n* **reload**(optional) is a Boolean value indicating whether to reload the module. If a module with the same name has been loaded before, this parameter must be set to true to make changes in *moduleScript* take effect. The default value is false.\n\n#### Details\n\nParse scripts containing module definitions and load the modules. If module references are included in the scripts, the order of dependencies in the definition does not need to be considered as they will be automatically resolved.\n\n#### Examples\n\n```\nmoduleName = \"test\"\nmoduleScript = \"module test \\n def testFunc(x,y){ return x+y }\"\nloadModuleFromScript(moduleName,moduleScript)\ngo\ntest::testFunc(2,3)\n// output\n5\n```\n\nIf module references are included:\n\n```\nmoduleNames = [\"test2\",\"test1\"]\nmoduleScripts = [\n\"module test2\nuse test1\ndef func4(x,y){\nreturn func1(x) + func2(y)\n}\n\",\n\"module test1\ndef func1(x){\nreturn x+1\n}\ndef func2(x){\nreturn x+2\n}\ndef func3(x){\nprint(func1(x)+func2(x))\n}\n\"\n]\nloadModuleFromScript(moduleNames,moduleScripts)\ngo\n\ntest1::func3(2)\n// output\n7\ntest2::func4(2,3)\n// output\n8\n```\n\n"
    },
    "loadMvccTable": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadMvccTable.html",
        "signatures": [
            {
                "full": "loadMvccTable(path, tableName)",
                "name": "loadMvccTable",
                "parameters": [
                    {
                        "full": "path",
                        "name": "path"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [loadMvccTable](https://docs.dolphindb.com/en/Functions/l/loadMvccTable.html)\n\n\n\n#### Syntax\n\nloadMvccTable(path, tableName)\n\n#### Arguments\n\n**path** is a string indicating the absolute path of the table.\n\n**tableName** is a string indicating the name of the table on disk.\n\n#### Details\n\nLoad all data of an MVCC table on disk into memory.\n\n#### Examples\n\n```\nn=5\nsyms=`IBM`C`MS`MSFT`JPM`ORCL`FB`GE\ntimestamp=09:30:00+rand(18000,n)\nsym=rand(syms,n)\nqty=100*(1+rand(100,n))\nprice=5.0+rand(100.0,n)\ntemp=table(timestamp,sym,qty,price)\nt1= mvccTable(1:0,`timestamp`sym`qty`price,[TIMESTAMP,SYMBOL,INT,DOUBLE],\"C:/DolphinDB/Data\",\"t1\")\nt1.append!(temp);\n\nloadMvccTable(\"C:/DolphinDB/Data\",t1);\n```\n\n| timestamp               | sym  | qty  | price     |\n| ----------------------- | ---- | ---- | --------- |\n| 1970.01.01T00:00:39.091 | MSFT | 4500 | 99.808702 |\n| 1970.01.01T00:00:35.293 | FB   | 3600 | 26.644715 |\n| 1970.01.01T00:00:36.334 | MSFT | 3800 | 66.754334 |\n| 1970.01.01T00:00:40.362 | ORCL | 4800 | 15.480288 |\n| 1970.01.01T00:00:35.565 | MSFT | 1700 | 23.107408 |\n"
    },
    "loadNpy": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadNpy.html",
        "signatures": [
            {
                "full": "loadNpy(fileName)",
                "name": "loadNpy",
                "parameters": [
                    {
                        "full": "fileName",
                        "name": "fileName"
                    }
                ]
            }
        ],
        "markdown": "### [loadNpy](https://docs.dolphindb.com/en/Functions/l/loadNpy.html)\n\n\n\n#### Syntax\n\nloadNpy(fileName)\n\n#### Arguments\n\n**filename** is a string indicating the path and name of an *.npy* file.\n\n#### Details\n\nLoad an *.npy* (Python Numpy) binary file and convert it into a DolphinDB vector or matrix. NaN in the *.npy* file is converted into NULL in DolphinDB.\n\nRight now the function only works for *.npy* files with numerical data.\n\n#### Examples\n\nSave *.npy* files in Python:\n\n```language-python\nimport numpy as np\nnp.save(\"intVec.npy\", np.array([5,6,1,3,4,8]))\nnp.save(\"doubleMat.npy\", np.array([[1.5,5.6,-7.87],[-1.0,3.4,4.5]]))\n```\n\nLoad *.npy* files in DolphinDB:\n\n```\nloadNpy(\"intVec.npy\");\n// output\n[5,6,1,3,4,8]\n\nloadNpy(\"doubleMat.npy\");\n```\n\n| #0  | #1  | #2    |\n| --- | --- | ----- |\n| 1.5 | 5.6 | -7.87 |\n| -1  | 3.4 | 4.5   |\n\nRelated function: [saveAsNpy](https://docs.dolphindb.com/en/Functions/s/saveAsNpy.html)\n"
    },
    "loadNpz": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadNpz.html",
        "signatures": [
            {
                "full": "loadNpz(fileName)",
                "name": "loadNpz",
                "parameters": [
                    {
                        "full": "fileName",
                        "name": "fileName"
                    }
                ]
            }
        ],
        "markdown": "### [loadNpz](https://docs.dolphindb.com/en/Functions/l/loadNpz.html)\n\n\n\n#### Syntax\n\nloadNpz(fileName)\n\n#### Arguments\n\n**filename** is a STRING indicating the path of *.npz* file.\n\n#### Details\n\nRead an npz binary file from Python NumPy and convert it into DolphinDB objects. NaN in *.npz* file is converted into NULL in DolphinDB.\n\nConversion Table for Python np.array and DolphinDB Objects:\n\n| NumPy array       | DolphinDB Objects                             |\n| ----------------- | --------------------------------------------- |\n| one-dimensional   | vector                                        |\n| two-dimensional   | matrix                                        |\n| three-dimensional | tuple (where each element represents a matrix |\n\nData types supported for conversion are: BOOL, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE and STRING (only one-dimensional array is supported).\n\n#### Examples\n\nSave *.npz* file in Python:\n\n```language-python\nimport numpy as np\na = np.array([[[97, 98]]], dtype=np.int8)\na1 = np.array(['133', '211', '3dds', 'ddd4', 'e5', 'w6'])\nb1 = np.array([[0.7, 0.8, 9.2], [0, np.nan, np.nan], [1.5, 2.8, 0.2]])\nc1 = np.array([[[0.2, 3.3], [1.9, 4.3]], [[5, 6], [1, 2]]])\nnp.savez('my_path/array_save.npz', char=a, a1=a1, b1=b1, c1=c1)\n```\n\nLoad *.npz* file in DolphinDB:\n\n```\npath=\"my_path/array_save.npz\"\nloadNpz(path)\n// output\na1->[133,211,3dds,ddd4,e5,w6]\nchar->(#0  #1\n'a' 'b'\n)\nc1->(#0  #1\n0.2 3.3\n1.9 4.3\n,#0 #1\n5  6\n1  2\n)\nb1->\n#0  #1  #2\n0.7 0.8 9.2\n0\n1.5 2.8 0.2\n```\n\nRelated Function: [loadNpy](https://docs.dolphindb.com/en/Functions/l/loadNpy.html)\n"
    },
    "loadPlugin": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadPlugin.html",
        "signatures": [
            {
                "full": "loadPlugin(metaFile)",
                "name": "loadPlugin",
                "parameters": [
                    {
                        "full": "metaFile",
                        "name": "metaFile"
                    }
                ]
            }
        ],
        "markdown": "### [loadPlugin](https://docs.dolphindb.com/en/Functions/l/loadPlugin.html)\n\n\n\n#### Syntax\n\nloadPlugin(metaFile)\n\n#### Arguments\n\n**metaFile** is the absolute path of a text file that describes a DolphinDB plugin. Since version 2.00.11/1.30.23, it can be specified as the plugin name (case sensitive). The system will load the plugin through the plugin name and the configuration parameter *pluginDir*. Note that the name of a very small number of plugins differs from the name of the folder where it is located. In such cases, loading the plugin through the plugin name will fail due to the non-existent path. To resolve this, modify *metaFile* to the folder name.\n\n#### Details\n\nLoad a plugin into DolphinDB. It must be executed by a logged-in user. Note that for DolphinDB community edition users, paid plugins must be purchased separately.\n\nFor each DolphinDB plugin, there is a text file that describes the plugin. The first line of the text file includes the names of the plugin and the shared library file, separated by comma \",\". Each of the following lines includes the following information: a function in the library file, the corresponding DolphinDB function, function type (operator or system function), the minimal number of parameters, the maximum number of parameters, whether the function is an aggregate function, whether the function is order-sensitive or not.\n\nThe function returns a tuple with the names of the functions in the library file.\n\n#### Examples\n\n* Load the plugin from the Plugin Square\n\n  Take the MQTT plugin as an example. After installing the plugin with`installPlugin`, the plugin can be loaded in two ways:\n\n  * Load the plugin using the absolute path:\n\n    ```\n    installPlugin(\"mqtt\")\n    loadPlugin(\"D:/TEST/DolphinDB_Win64_V2.00.10/server/plugins/mqtt/PluginMQTT.txt\")\n    ```\n\n  **Note**: When loading a plugin with the absolute path on Windows, make sure to use \"/\" in the path, instead of \"\\\\\".\n\n  * Load the plugin by specifying its name:\n\n    ```\n    installPlugin(\"mqtt\")\n    loadPlugin(\"mqtt\")\n    ```\n\n* Load the manually compiled plugin\n\n  The file *odbc.txt* of the DolphinDB odbc plugin:\n\n  ```\n  odbc,libPluginODBC.so,2.00.10\n  odbcQuery,query,system,2,5,0\n  odbcConnect,connect,system,1,2,0\n  odbcClose,close,system,1,1,0\n  odbcExecute,execute,system,2,2,0\n  odbcAppend,append,system,3,5,0\n  ```\n\n  The odbc plugin provides 5 methods, `query`, `connect`, `close`, `execute`, and `append`. Install the plugin to use these methods. The following script shows how to load the odbc plugin and call its methods:\n\n  ```\n  loadPlugin(\"/home/DolphinDB/server/plugins/odbc/odbc.txt\")\n  // Or you can use plugin name to load the plugin.\n  loadPlugin(\"odbc\")\n  use odbc\n  ConnStr=\"Driver=MySQL;Data Source=odbc_test;Server=127.0.0.1;Uid=root;Pwd=123456;Database=odbc_test\"\n  conn=connect(connStr)      // create connection to MySQL\n\n  t=query(conn,\"select * from test\")\n  close(conn)\n  ```\n"
    },
    "loadRecord": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadRecord.html",
        "signatures": [
            {
                "full": "loadRecord(filename, schema, [skipBytes=0], [count])",
                "name": "loadRecord",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "schema",
                        "name": "schema"
                    },
                    {
                        "full": "[skipBytes=0]",
                        "name": "skipBytes",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[count]",
                        "name": "count",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [loadRecord](https://docs.dolphindb.com/en/Functions/l/loadRecord.html)\n\n\n\n#### Syntax\n\nloadRecord(filename, schema, \\[skipBytes=0], \\[count])\n\n#### Arguments\n\n**filename** is a string indicating the path of a file.\n\n**schema** is a tuple of vectors. Each vector of the tuple represents the name and data type of a column. For a string column, we also need to specify the length of the string. If a string is shorter than the specified length, add 0s in the end to reach the specified length.\n\n**skipBytes** is a nonnegative integer indicating the number of bytes to skip in the beginning of the file. The default value is 0.\n\n**count** is a positive integer indicating the number of records to load. If it is not specified, load all records.\n\n#### Details\n\nLoad a binary file with fixed length for each column into memory.\n\n#### Examples\n\nThe following is a binary file *sample.bin*:\n\n```\n// output\n0000000 3036 3131 3737 532e 0048 0000 0000 0000\n0000010 0000 0000 0000 0000 0000 0000 0000 0000\n0000020 16b6 0134 d160 0578 0000 0000 0000 0000\n0000030 0000 0000 3333 4137 0000 0000 0000 0000\n0000040 0000 0000 0000 0000 0000 0000 0000 0000\n0000050 0000 0000 0000 0000 0000 0000 00c8 0000\n0000060 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000080 0000 0000 3333 4137 0000 0000 0000 0000\n0000090 0000 0000 0000 0000 0000 0000 0000 0000\n00000a0 0000 0000 0000 0000 0000 0000 00c8 0000\n00000b0 0384 0000 0000 0000 0000 0000 0000 0000\n00000c0 0000 0000 0000 0000 0000 0000 0000 0000\n00000d0 0000 0000 3036 3131 3737 532e 0048 0000\n00000e0 0000 0000 0000 0000 0000 0000 0000 0000\n00000f0 0000 0000 16b6 0134 ea58 057b 0000 0000\n0000100 0000 0000 0000 0000 3333 4137 0000 0000\n0000110 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000130 00c8 0000 0000 0000 0000 0000 0000 0000\n0000140 0000 0000 0000 0000 0000 0000 0000 0000\n0000150 0000 0000 0000 0000 3333 4137 0000 0000\n0000160 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000180 00c8 0000 0b54 0000 0000 0000 0000 0000\n0000190 0000 0000 0000 0000 0000 0000 0000 0000\n00001a0 0000 0000 0000 0000 3036 3131 3737 532e\n00001b0 0048 0000 0000 0000 0000 0000 0000 0000\n00001c0 0000 0000 0000 0000 16b6 0134 82b0 057c\n00001d0 0000 0000 0000 0000 0000 0000 3333 4137\n00001e0 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000200\n```\n\nUse function `loadRecord` to load the file into DolphinDB. Please note that the column code ia s string with fixed length of 32 in the file.\n\n```\nschema = [(\"code\", SYMBOL, 32),(\"date\", INT),(\"time\", INT),(\"last\", FLOAT),(\"volume\", INT),(\"value\", FLOAT),(\"ask1\", FLOAT),(\"ask2\", FLOAT),(\"ask3\", FLOAT),(\"ask4\", FLOAT),(\"ask5\", FLOAT),(\"ask6\", FLOAT),(\"ask7\", FLOAT),(\"ask8\", FLOAT),(\"ask9\", FLOAT),(\"ask10\", FLOAT),(\"ask_size1\", INT),(\"ask_size2\", INT),(\"ask_size3\", INT),(\"ask_size4\", INT),(\"ask_size5\", INT),(\"ask_size6\", INT),(\"ask_size7\", INT),(\"ask_size8\", INT),(\"ask_size9\", INT),(\"ask_size10\", INT),(\"bid1\", FLOAT),(\"bid2\", FLOAT),(\"bid3\", FLOAT),(\"bid4\", FLOAT),(\"bid5\", FLOAT),(\"bid6\", FLOAT),(\"bid7\", FLOAT),(\"bid8\", FLOAT),(\"bid9\", FLOAT),(\"bid10\", FLOAT),(\"bid_size1\", INT),(\"bid_size2\", INT),(\"bid_size3\", INT),(\"bid_size4\", INT),(\"bid_size5\", INT),(\"bid_size6\", INT),(\"bid_size7\", INT),(\"bid_size8\", INT),(\"bid_size9\", INT),(\"bid_size10\", INT)];\nt=loadRecord(\"/home/DolphinDB/sample.bin\",schema);\nselect code, date,time,last,volume,value,ask1,ask_size1,bid1,bid_size1 from t;\n```\n\n| code      | date     | time     | last | volume | value | ask1  | ask\\_size1 | bid1  | bid\\_size1 |\n| --------- | -------- | -------- | ---- | ------ | ----- | ----- | ---------- | ----- | ---------- |\n| 601177.SH | 20190902 | 91804000 | 0    | 0      | 0     | 11.45 | 200        | 11.45 | 200        |\n| 601177.SH | 20190902 | 92007000 | 0    | 0      | 0     | 11.45 | 200        | 11.45 | 200        |\n"
    },
    "loadTable": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadTable.html",
        "signatures": [
            {
                "full": "loadTable(database, tableName, [partitions], [memoryMode=false])",
                "name": "loadTable",
                "parameters": [
                    {
                        "full": "database",
                        "name": "database"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[partitions]",
                        "name": "partitions",
                        "optional": true
                    },
                    {
                        "full": "[memoryMode=false]",
                        "name": "memoryMode",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [loadTable](https://docs.dolphindb.com/en/Functions/l/loadTable.html)\n\n\n\n#### Syntax\n\nloadTable(database, tableName, \\[partitions], \\[memoryMode=false])\n\n#### Arguments\n\n**database** is either a database handle, or the absolute path of the folder where the database is stored. The database can be located in the local file system, or the distributed file system.\n\n**tableName** is a string indicating the name of the table on disk.\n\n**partitions** is a scalar or vector indicating which partitions of the table to load into memory.\n\n**memoryMode** is a Boolean value indicating whether to load only metadata into memory (*memoryMode* = false). If *memoryMode* = true, load all data or selected partitions into memory. Please note that this parameter only takes effect for local databases on disk. For DFS databases, only the metadata is loaded into memory.\n\n#### Details\n\nFor a DFS table: return a table object with only the metadata.\n\nFor a partitioned table in the local file system: if *memoryMode* = true, load all partitions (or selected partitions if parameter *partitions* is specified) into memory as a partitioned table; if *memoryMode* = false, only load metadata into memory.\n\n#### Examples\n\nIn the distributed file system:\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt1=table(ID, date, x);\n\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID=database(, RANGE, 0 50 100);\ndb = database(\"dfs://compoDB\", COMPO, [dbDate, dbID]);\npt = db.createPartitionedTable(t1, `pt, `date`ID).append!(t1)\n\nt2=table(0..100 as ID,take(2017.08.07..2017.08.11,101) as date)\ndt = db.createDimensionTable(t2, `dt).append!(t2)\n```\n\n* To load a dimension table:\n\n  ```\n  tmp = loadTable(\"dfs://compoDB\", `dt)\n  select count(*) from tmp\n  ```\n\n  | count |\n  | ----- |\n  | 101   |\n\n* To load a partitioned table:\n\n  ```\n  tmp = loadTable(\"dfs://compoDB\", `pt)\n  select count(*) from tmp\n  ```\n\n  | count   |\n  | ------- |\n  | 1000000 |\n\n* For a DFS table, we cannot use *loadTable* to load specified partitions directly. To load specified partitions into memory, we can specify the filtering conditions in the SQL statement.\n\n  ```\n  tmp = loadTable(\"dfs://compoDB\", `pt)\n  select * from tmp where date=2017.08.07\n  ```\n\nWith the in-memory partitioned table, we can execute functions such as [update!](https://docs.dolphindb.com/en/Functions/u/update!.html), [drop!](https://docs.dolphindb.com/en/Functions/d/dropColumns!.html), [rename!](https://docs.dolphindb.com/en/Functions/r/rename!.html), [sortBy!](https://docs.dolphindb.com/en/Functions/s/sortBy!.html) etc.\n"
    },
    "loadTableBySQL": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadTableBySQL.html",
        "signatures": [
            {
                "full": "loadTableBySQL(sql)",
                "name": "loadTableBySQL",
                "parameters": [
                    {
                        "full": "sql",
                        "name": "sql"
                    }
                ]
            }
        ],
        "markdown": "### [loadTableBySQL](https://docs.dolphindb.com/en/Functions/l/loadTableBySQL.html)\n\n\n\n#### Syntax\n\nloadTableBySQL(sql)\n\n#### Arguments\n\n**sql** is a metacode object representing a SQL query. It can use `where` clause to filter partitions or rows and use `SELECT` statement to select columns including calculated columns. However, it cannot use `TOP` clause, `GROUP BY` clause, `ORDER BY` clause, `CONTEXT BY`, and `LIMIT`.\n\n#### Details\n\nLoad only the rows of a partitioned table that satisfy the filtering conditions in a SQL query to memory. The result is a partitioned in-memory table with the same partitioning scheme as the database on disk.\n\n#### Examples\n\n```\nn=1000000\nt=table(rand('A'..'Z',n) as sym, 2000.01.01+rand(365,n) as date, 10.0+rand(2.0,n) as price1, 100.0+rand(20.0,n) as price2, rand(10,n) as qty1, rand(100,n) as qty2)\n\ndb = database(\"dfs://tradeDB\", VALUE, 'A'..'Z')\ntrades=db.createPartitionedTable(t,`trades,`sym).append!(t)\n\nsample=select * from loadTableBySQL(<select * from trades where date between 2000.03.01 : 2000.05.01>)\nsample=select * from loadTableBySQL(<select sym, date, price1, qty1 from trades where date between 2000.03.01 : 2000.05.01>)\n\ndates = 2000.01.16 2000.02.14 2000.08.01\nst = sql(<select sym, date, price1, qty1>, trades, expr(<date>, in, dates))\nsample = select * from loadTableBySQL(st)\n\ncolNames =`sym`date`qty2`price2\nst= sql(sqlCol(colNames), trades)\nsample = select * from loadTableBySQL(st)\n```\n"
    },
    "loadText": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadText.html",
        "signatures": [
            {
                "full": "loadText(filename, [delimiter], [schema], [skipRows=0], [arrayDelimiter], [containHeader], [arrayMarker])",
                "name": "loadText",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    },
                    {
                        "full": "[schema]",
                        "name": "schema",
                        "optional": true
                    },
                    {
                        "full": "[skipRows=0]",
                        "name": "skipRows",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[arrayDelimiter]",
                        "name": "arrayDelimiter",
                        "optional": true
                    },
                    {
                        "full": "[containHeader]",
                        "name": "containHeader",
                        "optional": true
                    },
                    {
                        "full": "[arrayMarker]",
                        "name": "arrayMarker",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [loadText](https://docs.dolphindb.com/en/Functions/l/loadText.html)\n\n\n\n#### Syntax\n\nloadText(filename, \\[delimiter], \\[schema], \\[skipRows=0], \\[arrayDelimiter], \\[containHeader], \\[arrayMarker])\n\n#### Arguments\n\n**filename** is the input text file name with its absolute path. Currently only *.csv* files are supported.\n\n**delimiter** (optional) is a STRING scalar indicating the table column separator. It can consist of one or more characters, with the default being a comma (',').\n\n**schema** (optional) is a table. It can have the following columns, among which \"name\" and \"type\" columns are required.\n\n| Column | Data Type            | Description                    |\n| ------ | -------------------- | ------------------------------ |\n| name   | STRING scalar        | column name                    |\n| type   | STRING scalar        | data type                      |\n| format | STRING scalar        | the format of temporal columns |\n| col    | INT scalar or vector | the columns to be loaded       |\n\n**Note:**\n\nIf \"type\" specifies a temporal data type, the format of the source data must match a DolphinDB temporal data type. If the format of the source data and the DolphinDB temporal data types are incompatible, you can specify the column type as STRING when loading the data and convert it to a DolphinDB temporal data type using the [temporalParse](https://docs.dolphindb.com/en/Functions/t/temporalParse.html) function afterwards.\n\n**skipRows** (optional) is an integer between 0 and 1024 indicating the rows in the beginning of the text file to be ignored. The default value is 0.\n\n**arrayDelimiter** (optional) is a single character indicating the delimiter for columns holding the array vectors in the file. You must use the *schema* parameter to update the data type of the type column with the corresponding array vector data type before import.\n\n**containHeader** (optional) is a Boolean value indicating whether the file contains a header row. The default value is NULL.\n\n**arrayMarker** is a string containing 2 characters or a CHAR pair. These two characters represent the identifiers for the left and right boundaries of an array vector. The default identifiers are double quotes (\").\n\n* It cannot contain spaces, tabs (`\\t`), or newline characters (`\\t` or `\\n`).\n\n* It cannot contain digits or letters.\n\n* If one is a double quote (`\"`), the other must also be a double quote.\n\n* If the identifier is `'`, `\"`, or `\\`, a backslash ( \\ ) escape character should be used as appropriate. For example, `arrayMarker=\"\\\"\\\"\"`.\n\n* If *delimiter*specifies a single character, *arrayMarker* cannot contain the same character.\n\n* If *delimiter*specifies multiple characters, the left boundary of *arrayMarker* cannot be the same as the first character of *delimiter*.\n\n#### Details\n\nLoad a text file into memory as a table. *loadText* loads data in single thread. To load data in multiple threads, use [ploadText](https://docs.dolphindb.com/en/Functions/p/ploadText.html) .\n\n* How a header row is determined:\n\n  * When *containHeader* is NULL, the first row of the file is read in string format, and the column names are parsed from that data.The first row of the file is read in string format, and the column names are parsed from that data.Please note that the upper limit for the first row is 256 KB. If none of the columns in the first row of the file starts with a number, the first row is treated as the header with column names of the text file. If at least one of the columns in the first row of the file starts with a number, the system uses col0, col1, … as the column names;\n\n  * When *containHeader* is true, the first row is determined as the header row, and the column names are parsed from that data;\n\n  * When *containHeader* is false, the system uses col0, col1, … as the column names.\n\n* How the column types are determined:\n\n  * When loading a text file, the system determines the data type of each column based on a random sample of rows. This convenient feature may not always accurately determine the data type of all columns. We recommend users check the data type of each column with the [extractTextSchema](https://docs.dolphindb.com/en/Functions/e/extractTextSchema.html) function after loading.\n  * When the input file contains dates and times:\n    * For data with delimiters (date delimiters \"-\", \"/\" and \".\", and time delimiter \":\"), it will be converted to the corresponding type. For example, \"12:34:56\" is converted to the SECOND type; \"23.04.10\" is converted to the DATE type.\n    * For data without delimiters, data in the format of \"yyMMdd\" that meets 0<=yy<=99, 0<=MM<=12, 1<=dd<=31, will be preferentially parsed as DATE; data in the format of \"yyyyMMdd\" that meets 1900<=yyyy<=2100, 0<=MM<=12, 1<=dd<=31 will be preferentially parsed as DATE.\n  * If a column does not have the expected data type, then we need to enter the correct data type of the column in the schema table. Users can also specify data types for all columns. For a temporal column, if it does not have the expected data type, we also need to specify a format such as \"MM/dd/yyyy\" in the schema table. For details about temporal formats please refer to [Parsing and Format of Temporal Variables](https://docs.dolphindb.com/en/Programming/DataManipulation/TemporalObjects/ParsingandFormatofTemporalVariables.html).\n\nTo load a subset of columns, specify the column index in the \"col\" column of *schema*.\n\nAs string in DolphinDB is encoded in UTF-8, we require input text files be encoded in UTF-8.\n\nColumn names in DolphinDB must only contain letters, numbers or underscores and must start with a letter. If a column name in the text file does not meet the requirements, the system automatically adjusts it:\n\n* If the column name contains characters other than letters, numbers or underscores, these characters are converted into underscores.\n\n* If the column name does not start with a letter, add \"c\" to the column name so that it starts with \"c\".\n\nA few examples:\n\n| Column name in data files | Adjusted column name |\n| ------------------------- | -------------------- |\n| 1\\_test                   | c1\\_test             |\n| test-a!                   | test\\_a\\_            |\n| \\[test]                   | c\\_test\\_            |\n\n**Note:** Starting from version 1.30.22/2.00.10, `loadText` supports files containing multiple line breaks in a single record.\n\n#### Examples\n\nUse the following script to generate the data file to be used for the examples:\n\n```\nn=10\nsym=rand(`AAPL`ORCL`MS`SUN,n)\npermno=take(10001,n)\ndate=rand(2019.06.01..2019.06.10,n)\nopen=rand(100.0,n)\nhigh=rand(200.0,n)\nclose=rand(200.0,n)\npre_close=rand(200.0,n)\nchange=rand(100.0,n)\nvol=rand(10000,n)\namount=rand(100000.0,n)\nt=table(sym,permno,date,open,high,close,pre_close,change,vol,amount)\nsaveText(t,\"C:/DolphinDB/Data/stock.csv\");\n```\n\nExample: Use *loadText* without specifying any optional parameters:\n\n```\ntt=loadText(\"C:/DolphinDB/Data/stock.csv\");\ntt;\n```\n\n| sym  | permno | date       | open      | high       | close      | pre\\_close | change    | vol  | amount       |\n| ---- | ------ | ---------- | --------- | ---------- | ---------- | ---------- | --------- | ---- | ------------ |\n| MS   | 10001  | 2019.06.06 | 90.346594 | 80.530542  | 96.474428  | 146.305659 | 0.720236  | 1045 | 90494.568297 |\n| AAPL | 10001  | 2019.06.07 | 91.165315 | 8.482074   | 85.514922  | 16.259077  | 76.797829 | 7646 | 91623.485996 |\n| AAPL | 10001  | 2019.06.03 | 45.361885 | 14.077451  | 149.848419 | 89.110375  | 45.499145 | 9555 | 98171.601654 |\n| MS   | 10001  | 2019.06.04 | 8.98688   | 0.591778   | 155.54643  | 132.423187 | 69.95799  | 1202 | 3512.927634  |\n| MS   | 10001  | 2019.06.07 | 62.866173 | 33.465237  | 174.20712  | 102.695818 | 74.580523 | 3524 | 61943.64517  |\n| MS   | 10001  | 2019.06.09 | 32.819915 | 13.319577  | 136.729618 | 63.980405  | 60.66375  | 7078 | 85138.216568 |\n| MS   | 10001  | 2019.06.07 | 90.210866 | 22.728777  | 150.212291 | 59.454705  | 73.916303 | 5306 | 19883.845607 |\n| AAPL | 10001  | 2019.06.06 | 83.752686 | 71.3501    | 98.211979  | 145.60098  | 94.428343 | 8852 | 9236.020781  |\n| ORCL | 10001  | 2019.06.01 | 81.64719  | 129.702202 | 182.784373 | 117.575967 | 74.84595  | 2942 | 43394.871242 |\n| AAPL | 10001  | 2019.06.02 | 10.068382 | 80.875383  | 181.674585 | 138.783821 | 25.298267 | 1088 | 82981.043775 |\n\n```\nschema(tt).colDefs;\n```\n\n| name       | typeString | typeInt | comment |\n| ---------- | ---------- | ------- | ------- |\n| sym        | SYMBOL     | 17      |         |\n| permno     | INT        | 4       |         |\n| date       | DATE       | 6       |         |\n| open       | DOUBLE     | 16      |         |\n| high       | DOUBLE     | 16      |         |\n| close      | DOUBLE     | 16      |         |\n| pre\\_close | DOUBLE     | 16      |         |\n| change     | DOUBLE     | 16      |         |\n| vol        | INT        | 4       |         |\n| amount     | DOUBLE     | 16      |         |\n\nExample: Specify the data type of a column before loading the file.\n\nWe may want to change the data type of column \"permno\" to be SYMBOL. For this, we need to use function [extractTextSchema](https://docs.dolphindb.com/en/Functions/e/extractTextSchema.html) to get the schema table, update it, then load the text file with the revised schema table.\n\n```\nschema=extractTextSchema(\"C:/DolphinDB/Data/stock.csv\");\nupdate schema set type=`SYMBOL where name=`permno;\ntt=loadText(\"C:/DolphinDB/Data/stock.csv\",,schema);\nschema(tt).colDefs;\n```\n\n| name       | typeString | typeInt | comment |\n| ---------- | ---------- | ------- | ------- |\n| sym        | SYMBOL     | 17      |         |\n| permno     | SYMBOL     | 17      |         |\n| date       | DATE       | 6       |         |\n| open       | DOUBLE     | 16      |         |\n| high       | DOUBLE     | 16      |         |\n| close      | DOUBLE     | 16      |         |\n| pre\\_close | DOUBLE     | 16      |         |\n| change     | DOUBLE     | 16      |         |\n| vol        | INT        | 4       |         |\n| amount     | DOUBLE     | 16      |         |\n\nYou can also specify the data types of all columns:\n\n```\nschematable=table(`sym`permno`date`open`high`close`pre_close`change`vol`amount as name,`SYMBOL`SYMBOL`DATE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`INT`DOUBLE as type)\ntt=loadText(\"C:/DolphinDB/Data/stock.csv\",,schematable)\nschema(tt).colDefs;\n```\n\n| name       | typeString | typeInt | comment |\n| ---------- | ---------- | ------- | ------- |\n| sym        | SYMBOL     | 17      |         |\n| permno     | SYMBOL     | 17      |         |\n| date       | DATE       | 6       |         |\n| open       | DOUBLE     | 16      |         |\n| high       | DOUBLE     | 16      |         |\n| close      | DOUBLE     | 16      |         |\n| pre\\_close | DOUBLE     | 16      |         |\n| change     | DOUBLE     | 16      |         |\n| vol        | INT        | 4       |         |\n| amount     | DOUBLE     | 16      |         |\n\nExample: Load only a subset of columns.\n\nFor example, we may only need to load the following 7 columns: sym, date, open, high, close, vol, amount. Please note that we cannot change the order of columns when loading data. To change the order of columns in the loaded table, use function [reorderColumns!](https://docs.dolphindb.com/en/Functions/r/reorderColumns!.html).\n\n```\nschema=extractTextSchema(\"C:/DolphinDB/Data/stock.csv\");\nschema=select * from schema where name in `sym`date`open`high`close`vol`amount\nschema[`col]=[0,2,3,4,5,8,9]\n\ntt=loadText(\"C:/DolphinDB/Data/stock.csv\",,schema);\ntt;\n```\n\n| sym  | date       | open      | high       | close      | vol  | amount       |\n| ---- | ---------- | --------- | ---------- | ---------- | ---- | ------------ |\n| SUN  | 2019.06.10 | 18.675316 | 72.754005  | 136.463909 | 1376 | 31371.319038 |\n| AAPL | 2019.06.05 | 42.098717 | 196.873587 | 41.513899  | 3632 | 9950.864129  |\n| ORCL | 2019.06.05 | 62.223474 | 197.099027 | 123.785675 | 3069 | 38035.800937 |\n| SUN  | 2019.06.03 | 0.18163   | 50.669866  | 4.652098   | 6213 | 1842.198893  |\n| SUN  | 2019.06.06 | 32.54134  | 67.012502  | 130.312294 | 4891 | 55744.156823 |\n| SUN  | 2019.06.07 | 56.899091 | 81.709825  | 61.786176  | 1133 | 69057.849515 |\n| AAPL | 2019.06.08 | 77.026838 | 38.504431  | 22.68496   | 3672 | 34420.187073 |\n| ORCL | 2019.06.07 | 62.752656 | 39.33621   | 48.483091  | 4382 | 41601.601639 |\n| AAPL | 2019.06.02 | 8.5487    | 17.623418  | 141.88325  | 8092 | 15449.159988 |\n| AAPL | 2019.06.02 | 26.178685 | 197.320455 | 110.52407  | 5541 | 14616.820449 |\n\nExample: Skip the first 2 rows when loading.\n\nPlease note that as the header is the first line of the text file, it is also skipped.\n\n```\nre=loadText(filename=\"C:/DolphinDB/Data/stock.csv\",skipRows=2)\nselect count(*) from re;\n```\n\n| count |\n| ----- |\n| 9     |\n\nExample: Specify the temporal format when loading the file.\n\nGenerate the text file to be used:\n\n```\ntime=[\"20190623145457\",\"20190623155423\",\"20190623163025\"]\nsym=`AAPL`MS`IBM\nqty=2200 5400 8670\nprice=54.78 59.64 65.23\nt=table(time,sym,qty,price)\nsaveText(t,\"C:/DolphinDB/Data/t2.csv\");\n```\n\nObtain the text schema with [extractTextSchema](https://docs.dolphindb.com/en/Functions/e/extractTextSchema.html) before loading the file:\n\n```\nextractTextSchema(\"C:/DolphinDB/Data/t2.csv\");\n```\n\n| name  | type   |\n| ----- | ------ |\n| time  | LONG   |\n| sym   | SYMBOL |\n| qty   | INT    |\n| price | DOUBLE |\n\nFrom the example above, if we load this text file without specifying the format of column \"time\", column \"time\" is empty as the system cannot parse the raw data correctly. For this scenario we must specify the format of the column.\n\n```\nschema=extractTextSchema(\"C:/DolphinDB/Data/t2.csv\")\nupdate schema set type = \"DATETIME\" where name = \"time\"\nschema[`format]=[\"yyyyMMddHHmmss\",,,];\n\nloadText(\"C:/DolphinDB/Data/t2.csv\",,schema);\n```\n\n| time                | sym  | qty  | price |\n| ------------------- | ---- | ---- | ----- |\n| 2019.06.23T14:54:57 | AAPL | 2200 | 54.78 |\n| 2019.06.23T15:54:23 | MS   | 5400 | 59.64 |\n| 2019.06.23T16:30:25 | IBM  | 8670 | 65.23 |\n\nExample: Load array vectors\n\nCreate a .csv file\n\n```\nbid = array(DOUBLE[], 0, 20).append!([1.4799 1.479 1.4787, 1.4796 1.479 1.4784, 1.4791 1.479 1.4784])\nask = array(DOUBLE[], 0, 20).append!([1.4821 1.4825 1.4828, 1.4818 1.482 1.4821, 1.4814 1.4818 1.482])\nTradeDate = 2022.01.01 + 1..3\nSecurityID = rand(`APPL`AMZN`IBM, 3)\nt = table(SecurityID as `sid, TradeDate as `date, bid as `bid, ask as `ask)\nt;\nsaveText(t,filename=\"/home/t.csv\",delimiter=',',append=true)\n```\n\nLoad with `loadText`\n\n```\npath = \"/home/t.csv\"\nschema=extractTextSchema(path);\nupdate schema set type = \"DOUBLE[]\" where name=\"bid\" or name =\"ask\"\nt = loadText(path, schema=schema, arrayDelimiter=\",\")\nt;\n```\n\n| sid  | date       | bid                    | ask                     |\n| ---- | ---------- | ---------------------- | ----------------------- |\n| AMZN | 2022.01.02 | \\[1.4799,1.479,1.4787] | \\[1.4821,1.4825,1.4828] |\n| AMZN | 2022.01.03 | \\[1.4796,1.479,1.4784] | \\[1.4818,1.482,1.4821]  |\n| IBM  | 2022.01.04 | \\[1.4791,1.479,1.4784] | \\[1.4814,1.4818,1.482]  |\n\nWhen exporting data to a .csv file, the default delimiter for array vectors are double quotes (\"). For example, a default exported *t.csv* would be:\n\n```\nsid,date,bid,ask\nAPPL,2022.01.02,\"1.4799,1.479,1.4787\",\"1.4821,1.4825,1.4828\"\nIBM,2022.01.03,\"1.4796,1.479,1.4784\",\"1.4818,1.482,1.4821\"\nAPPL,2022.01.04,\"1.4791,1.479,1.4784\",\"1.4814,1.4818,1.482\"\n```\n\nIf the boundary identifier is not double quote for array vectors, you can load the file with *arrayMarker*specified. For example, if the *t.csv* is in the following format:\n\n```\nsid,date,bid,ask\nAPPL,2022.01.02,[1.4799,1.479,1.4787],[1.4821,1.4825,1.4828]\nIBM,2022.01.03,[1.4796,1.479,1.4784],[1.4818,1.482,1.4821]\nAPPL,2022.01.04,[1.4791,1.479,1.4784],[1.4814,1.4818,1.482]\n```\n\nLoad it with the following script:\n\n```\npath = \"/home/DolphinDB/Data/t.csv\"\nschema=extractTextSchema(path);\nupdate schema set type = \"DOUBLE[]\" where name=\"bid\" or name =\"ask\"\nt = loadText(path, schema=schema, arrayDelimiter=\",\",arrayMarker=\"[]\")\nt;\n```\n"
    },
    "loadTextEx": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loadTextEx.html",
        "signatures": [
            {
                "full": "loadTextEx(dbHandle, tableName, partitionColumns, filename, [delimiter], [schema], [skipRows=0], [transform], [sortColumns], [atomic=false], [arrayDelimiter], [containHeader], [arrayMarker])",
                "name": "loadTextEx",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "partitionColumns",
                        "name": "partitionColumns"
                    },
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    },
                    {
                        "full": "[schema]",
                        "name": "schema",
                        "optional": true
                    },
                    {
                        "full": "[skipRows=0]",
                        "name": "skipRows",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[transform]",
                        "name": "transform",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns]",
                        "name": "sortColumns",
                        "optional": true
                    },
                    {
                        "full": "[atomic=false]",
                        "name": "atomic",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[arrayDelimiter]",
                        "name": "arrayDelimiter",
                        "optional": true
                    },
                    {
                        "full": "[containHeader]",
                        "name": "containHeader",
                        "optional": true
                    },
                    {
                        "full": "[arrayMarker]",
                        "name": "arrayMarker",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [loadTextEx](https://docs.dolphindb.com/en/Functions/l/loadTextEx.html)\n\n\n\n#### Syntax\n\nloadTextEx(dbHandle, tableName, partitionColumns, filename, \\[delimiter], \\[schema], \\[skipRows=0], \\[transform], \\[sortColumns], \\[atomic=false], \\[arrayDelimiter], \\[containHeader], \\[arrayMarker])\n\n#### Arguments\n\n**dbHandle** the distributed database where the imported data will be saved. The database can be either in the distributed file system or an in-memory database.\n\n**tableName** a string indicating the name of the table with the imported data.\n\n**partitionColumns** a string scalar/vector indicating partitioning column(s). For sequential partition, *partitionColumns* is \"\" as it doesn't need a partitioning column. For composite partition, *partitionColumns* is a string vector.\n\n**filename** is the input text file name with its absolute path. Currently only *.csv* files are supported.\n\n**delimiter** (optional) is a STRING scalar indicating the table column separator. It can consist of one or more characters, with the default being a comma (',').\n\n**schema** (optional) is a table. It can have the following columns, among which \"name\" and \"type\" columns are required.\n\n| Column | Data Type            | Description                    |\n| ------ | -------------------- | ------------------------------ |\n| name   | STRING scalar        | column name                    |\n| type   | STRING scalar        | data type                      |\n| format | STRING scalar        | the format of temporal columns |\n| col    | INT scalar or vector | the columns to be loaded       |\n\n**Note:**\n\nIf \"type\" specifies a temporal data type, the format of the source data must match a DolphinDB temporal data type. If the format of the source data and the DolphinDB temporal data types are incompatible, you can specify the column type as STRING when loading the data and convert it to a DolphinDB temporal data type using the [temporalParse](https://docs.dolphindb.com/en/Functions/t/temporalParse.html) function afterwards.\n\n**skipRows** (optional) is an integer between 0 and 1024 indicating the rows in the beginning of the text file to be ignored. The default value is 0.\n\n**transform** (optional) is a unary function. The parameter of the function must be a table.\n\n**sortColumns** (optional) is a string scalar/vector indicating the columns based on which the table is sorted.\n\n**atomic** (optional) is a Boolean value indicating whether to guarantee atomicity when loading a file with the cache engine enabled. If it is set to true, the entire loading process of a file is a transaction; set to false to split the loading process into multiple transactions.\n\n**Note:**\n\nIt is required to set *atomic* = false if the file to be loaded exceeds the cache engine capacity. Otherwise, a transaction may get stuck: it can neither be committed nor rolled back.\n\n**arrayDelimiter** (optional) is a single character indicating the delimiter for columns holding the array vectors in the file. Since the array vectors cannot be recognized automatically, you must use the *schema* parameter to update the data type of the type column with the corresponding array vector data type before import.\n\n**containHeader** (optional) a Boolean value indicating whether the file contains a header row. The default value is NULL. See [loadText](https://docs.dolphindb.com/en/Functions/l/loadText.html) for the detailed determining rules.\n\n**arrayMarker** is a string containing 2 characters or a CHAR pair. These two characters represent the identifiers for the left and right boundaries of an array vector. The default identifiers are double quotes (\").\n\n* It cannot contain spaces, tabs (`\\t`), or newline characters (`\\t` or `\\n`).\n\n* It cannot contain digits or letters.\n\n* If one is a double quote (`\"`), the other must also be a double quote.\n\n* If the identifier is `'`, `\"`, or `\\`, a backslash ( \\ ) escape character should be used as appropriate. For example, `arrayMarker=\"\\\"\\\"\"`.\n\n* If *delimiter*specifies a single character, *arrayMarker* cannot contain the same character.\n\n* If *delimiter*specifies multiple characters, the left boundary of *arrayMarker* cannot be the same as the first character of *delimiter*.\n\n#### Details\n\nLoad a text file into DolphinDB database.\n\nIf *dbHandle* is specified and is not empty string \"\": load a text file to a distributed database. The result is a table object with metadata of the table.\n\nIf *dbHandle* is empty string \"\" or unspecified: load a text file as a partitioned in-memory table. For this usage, when we define *dbHandle* with function `database`, the parameter directory must also be the empty string \"\" or unspecified.\n\nIf parameter *transform* is specified, we need to first execute *createPartitionedTable* and then load the data. The system will apply the function specified in parameter *transform* and then save the results into the database.\n\nFunction `loadTextEx` and function [loadText](https://docs.dolphindb.com/en/Functions/l/loadText.html) share many common features, such as whether the first row is treated as the header, how the data types of columns are determined, how the system adjusts illegal column names, etc. For more details, please refer to function [loadText](https://docs.dolphindb.com/en/Functions/l/loadText.html).\n\n#### Examples\n\nUse the following script to generate the text file to be used:\n\n```\nn=10000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nvol=rand(1..10 join int(), n)\nt=table(ID, date, vol)\nsaveText(t, \"C:/DolphinDB/Data/t.txt\");\n```\n\n*Example:* Load *t.txt* into a DFS database with a range domain on ID.\n\n```\ndb = database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 51 101)\npt=loadTextEx(dbHandle=db,tableName=`pt, partitionColumns=`ID, filename=\"/home/DolphinDB/Data/t.txt\");\n```\n\n*Example:* For a TSDB engine:\n\n```\ndb = database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 51 101, engine='TSDB')\npt=loadTextEx(dbHandle=db, tableName=`pt, partitionColumns=`ID, filename=\"/home/DolphinDB/Data/t.txt\", sortColumns=`ID`date);\n```\n\n*Example:* To load table pt from the database:\n\n```\ndb = database(\"dfs://rangedb\")\npt = loadTable(db, `pt);\n```\n\n*Example:* Load *t.txt* into a DFS database with a composite domain.\n\n```\ndbDate = database(directory=\"\", partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\ndbID=database(directory=\"\", partitionType=RANGE, partitionScheme=0 51 101)\ndb = database(directory=\"dfs://compoDB\", partitionType=COMPO, partitionScheme=[dbDate, dbID])\npt = loadTextEx(dbHandle=db,tableName=`pt, partitionColumns=`date`ID, filename=\"/home/DolphinDB/Data/t.txt\");\n```\n\n*Example:* Load *t.txt* into a partitioned in-memory table with value domain on date.\n\n```\ndb = database(directory=\"\", partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\npt = db.loadTextEx(tableName=\"\", partitionColumns=`date, filename=\"/home/DolphinDB/Data/t.txt\");\n\npt.sortBy!(`ID`x);\n```\n\n*Example:* Convert all NULL values to 0 and then load the data into a dfs database with a composite domain.\n\n```\ndbDate = database(directory=\"\", partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\ndbID=database(directory=\"\", partitionType=RANGE, partitionScheme=0 51 101)\ndb = database(directory=\"dfs://compoDB\", partitionType=COMPO, partitionScheme=[dbDate, dbID]);\n\npt=db.createPartitionedTable(table=t, tableName=`pt, partitionColumns=`date`ID)\npt=loadTextEx(dbHandle=db, tableName=`pt, partitionColumns=`date`ID, filename=\"/home/DolphinDB/Data/t.txt\", transform=nullFill!{,0});\n```\n\n*Example:* Load array vectors\n\nCreate a csv file:\n\n```\nbid = array(DOUBLE[], 0, 20).append!([1.4799 1.479 1.4787, 1.4796 1.479 1.4784, 1.4791 1.479 1.4784])\nask = array(DOUBLE[], 0, 20).append!([1.4821 1.4825 1.4828, 1.4818 1.482 1.4821, 1.4814 1.4818 1.482])\nTradeDate = 2022.01.01 + 1..3\nSecurityID = rand(`APPL`AMZN`IBM, 3)\nt = table(SecurityID as `sid, TradeDate as `date, bid as `bid, ask as `ask)\nt;\nsaveText(t,filename=\"/home/DolphinDB/Data/t.csv\",delimiter=',',append=true)\n```\n\nLoad the file with `loadTextEx`\n\n```\ndb = database(directory=\"dfs://testDB\", partitionType=VALUE, partitionScheme=`APPL`AMZN`IBM, engine='TSDB')\npath = \"/home/DolphinDB/Data/t.csv\"\nschema = extractTextSchema(path);\nupdate schema set type = \"DOUBLE[]\" where name=\"bid\" or name =\"ask\"\nloadTextEx(dbHandle=db, tableName=`t, partitionColumns=`sid, filename=path, schema=schema, arrayDelimiter=\",\", sortColumns=`sid`date);\nselect * from t;\n```\n\n| sid  | date       | bid                           | ask                           |\n| ---- | ---------- | ----------------------------- | ----------------------------- |\n| AMZN | 2022.01.04 | \\[1.479100,1.479000,1.478400] | \\[1.481400,1.481800,1.482000] |\n| AMZN | 2022.01.03 | \\[1.479600,1.479000,1.478400] | \\[1.481800,1.482000,1.482100] |\n| AMZN | 2022.01.04 | \\[1.479100,1.479000,1.478400] | \\[1.481400,1.481800,1.482000] |\n| APPL | 2022.01.02 | \\[1.479900,1.479000,1.478700] | \\[1.482100,1.482500,1.482800] |\n| APPL | 2022.01.03 | \\[1.479600,1.479000,1.478400] | \\[1.481800,1.482000,1.482100] |\n| APPL | 2022.01.04 | \\[1.479100,1.479000,1.478400] | \\[1.481400,1.481800,1.482000] |\n| IBM  | 2022.01.02 | \\[1.479900,1.479000,1.478700] | \\[1.482100,1.482500,1.482800] |\n| IBM  | 2022.01.03 | \\[1.479600,1.479000,1.478400] | \\[1.481800,1.482000,1.482100] |\n| IBM  | 2022.01.02 | \\[1.479900,1.479000,1.478700] | \\[1.482100,1.482500,1.482800] |\n"
    },
    "loc": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loc.html",
        "signatures": [
            {
                "full": "loc(obj, rowFilter, [colFilter], [view=false])",
                "name": "loc",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "rowFilter",
                        "name": "rowFilter"
                    },
                    {
                        "full": "[colFilter]",
                        "name": "colFilter",
                        "optional": true
                    },
                    {
                        "full": "[view=false]",
                        "name": "view",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [loc](https://docs.dolphindb.com/en/Functions/l/loc.html)\n\n\n\n#### Syntax\n\nloc(obj, rowFilter, \\[colFilter], \\[view=false])\n\n#### Arguments\n\n**obj** is a matrix object. It can be a standard matrix, an indexed series or an indexed matrix.\n\n**rowFilter**/**colFilter** can be:\n\n* a Boolean vector - the rows/columns marked as true will be returned. The length of the vector must match the number of rows/columns of *obj*.\n\n* a scalar, a vector or a pair whose data type is compatible with the row/column labels of obj. A pair indicates the selection range (both upper bound and lower bound are inclusive).\n\n**Note:**\n\n* If *rowFilter/colFilter* is a pair, then *obj* must be an indexed series or an indexed matrix.\n\n* Data type compatibility rules:\n\n  * INT, SHORT, LONG and CHAR are compatible\n\n  * FLOAT and DOUBLE are compatible\n\n  * STRING and SYMBOL are compatible\n\n**view** is a Boolean value. The default value is false indicating the result will be a copy of the original matrix (deep copy). If set to true, the result will be a view on the original matrix (shallow copy) and changes made to the original matrix will be reflected in the view.\n\n#### Details\n\nAccess a group of rows and columns of a matrix by label(s) or a boolean vector. Return a copy or a view of the original matrix.\n\n#### Examples\n\n```\nm=rand(12, 3:4)\nm;\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 3    | 10   | 6    | 5    |\n| 4    | 11   | 6    | 0    |\n| 7    | 2    | 1    | 8    |\n\n```\na = m.loc(colFilter=[true, true, true, false], view=true)\nb = m.loc(colFilter=[true, true, true, false], view=false)\na;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 3    | 10   | 6    |\n| 4    | 11   | 6    |\n| 7    | 2    | 1    |\n\n```\nb;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 3    | 10   | 6    |\n| 4    | 11   | 6    |\n| 7    | 2    | 1    |\n\n```\n// a view reflects changes made to the original matrix whereas a copy doesn't\nm[0,0] = -1\na;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| -1   | 10   | 6    |\n| 4    | 11   | 6    |\n| 7    | 2    | 1    |\n\n```\nb;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 3    | 10   | 6    |\n| 4    | 11   | 6    |\n| 7    | 2    | 1    |\n\n```\nm = rand(48, 6:8)\nm;\n```\n\n| col1 | col2 | col3 | col4 | col5 | col6 | col7 | col8 |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 27   | 31   | 47   | 21   | 12   | 43   | 22   | 11   |\n| 3    | 20   | 13   | 37   | 3    | 46   | 27   | 27   |\n| 13   | 5    | 14   | 11   | 26   | 42   | 4    | 18   |\n| 45   | 9    | 31   | 33   | 12   | 19   | 42   | 17   |\n| 2    | 19   | 30   | 25   | 36   | 27   | 21   | 6    |\n| 9    | 36   | 15   | 10   | 29   | 37   | 31   | 42   |\n\n```\n// filter with Boolean values\nm.loc(rowFilter=[true, true, false, false, true, false])\n```\n\n| col1 | col2 | col3 | col4 | col5 | col6 | col7 | col8 |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 27   | 31   | 47   | 21   | 12   | 43   | 22   | 11   |\n| 3    | 20   | 13   | 37   | 3    | 46   | 27   | 27   |\n| 2    | 19   | 30   | 25   | 36   | 27   | 21   | 6    |\n\n```\nm.loc(colFilter=[true, true, false, false, true, false, false, true])\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 27   | 31   | 12   | 11   |\n| 3    | 20   | 3    | 27   |\n| 13   | 5    | 26   | 18   |\n| 45   | 9    | 12   | 17   |\n| 2    | 19   | 36   | 6    |\n| 9    | 36   | 29   | 42   |\n\n```\n// filter with labels\nm.rename!(`A`A`B`A`B`B, 2022.01.01 + 0..7)\nm;\n```\n\n| label | 2022.01.01 | 2022.01.02 | 2022.01.03 | 2022.01.04 | 2022.01.05 | 2022.01.06 | 2022.01.07 | 2022.01.08 |\n| ----- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |\n| A     | 27         | 31         | 47         | 21         | 12         | 43         | 22         | 11         |\n| A     | 3          | 20         | 13         | 37         | 3          | 46         | 27         | 27         |\n| B     | 13         | 5          | 14         | 11         | 26         | 42         | 4          | 18         |\n| A     | 45         | 9          | 31         | 33         | 12         | 19         | 42         | 17         |\n| B     | 2          | 19         | 30         | 25         | 36         | 27         | 21         | 6          |\n| B     | 9          | 36         | 15         | 10         | 29         | 37         | 31         | 42         |\n\n```\nm.loc(rowFilter=`A);\n```\n\n| label | 2022.01.01 | 2022.01.02 | 2022.01.03 | 2022.01.04 | 2022.01.05 | 2022.01.06 | 2022.01.07 | 2022.01.08 |\n| ----- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |\n| A     | 27         | 31         | 47         | 21         | 12         | 43         | 22         | 11         |\n| A     | 3          | 20         | 13         | 37         | 3          | 46         | 27         | 27         |\n| A     | 45         | 9          | 31         | 33         | 12         | 19         | 42         | 17         |\n\n```\nm.loc(colFilter=2022.01.02);\n```\n\n| label | 2022.01.02 |\n| ----- | ---------- |\n| A     | 31         |\n| A     | 20         |\n| B     | 5          |\n| A     | 9          |\n| B     | 19         |\n| B     | 36         |\n\n```\nm.loc(rowFilter=`B, colFilter=2022.01.03)\n```\n\n| label | 2022.01.03 |\n| ----- | ---------- |\n| B     | 14         |\n| B     | 30         |\n| B     | 15         |\n\nWhen *rowFilter* / *colFilter* is a pair, *obj* must be an indexed matrix, which can be converted using [setIndexedMatrix!](https://docs.dolphindb.com/en/Functions/s/setIndexedMatrix!.html).\n\n```\nm = rand(30, 5:6).rename!(1..5, 2022.01.01 + 0..5)\nm.setIndexedMatrix!()\nm;\n```\n\n| label | 2022.01.01 | 2022.01.02 | 2022.01.03 | 2022.01.04 | 2022.01.05 | 2022.01.06 |\n| ----- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |\n| 1     | 5          | 27         | 26         | 18         | 29         | 3          |\n| 2     | 11         | 12         | 21         | 15         | 3          | 3          |\n| 3     | 1          | 23         | 29         | 17         | 7          | 18         |\n| 4     | 1          | 6          | 12         | 27         | 23         | 23         |\n| 5     | 15         | 7          | 3          | 19         | 4          | 8          |\n\n```\nm.loc(rowFilter=2:4, colFilter=2022.01.03:2022.01.06)\n```\n\n| label | 2022.01.03 | 2022.01.04 | 2022.01.05 | 2022.01.06 |\n| ----- | ---------- | ---------- | ---------- | ---------- |\n| 2     | 21         | 15         | 3          | 3          |\n| 3     | 29         | 17         | 7          | 18         |\n| 4     | 12         | 27         | 23         | 23         |\n\nRelated function: [at](https://docs.dolphindb.com/en/Functions/a/at.html)\n"
    },
    "localtime": {
        "url": "https://docs.dolphindb.com/en/Functions/l/localtime.html",
        "signatures": [
            {
                "full": "localtime(X)",
                "name": "localtime",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [localtime](https://docs.dolphindb.com/en/Functions/l/localtime.html)\n\n\n\n#### Syntax\n\nlocaltime(X)\n\n#### Arguments\n\n**X** is a variable/vector. The data type of *X* can be datetime, timestamp, or nanotimestamp.\n\n#### Details\n\nConvert *X* in GMT (Greenwich Mean Time) to local time zone.\n\n#### Examples\n\nThe following examples were conducted in US Eastern time zone.\n\n```\nlocaltime(2018.01.22T15:20:26);\n// output\n2018.01.22T10:20:26\n\nlocaltime(2017.12.16T18:30:10.001);\n// output\n2017.12.16T13:30:10.001\n```\n"
    },
    "loess": {
        "url": "https://docs.dolphindb.com/en/Functions/l/loess.html",
        "signatures": [
            {
                "full": "loess(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false], [bandwidth=0.3], [robustnessIter=4], [accuracy=1e-12])",
                "name": "loess",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "resampleRule",
                        "name": "resampleRule"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    },
                    {
                        "full": "[outputX=false]",
                        "name": "outputX",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[bandwidth=0.3]",
                        "name": "bandwidth",
                        "optional": true,
                        "default": "0.3"
                    },
                    {
                        "full": "[robustnessIter=4]",
                        "name": "robustnessIter",
                        "optional": true,
                        "default": "4"
                    },
                    {
                        "full": "[accuracy=1e-12]",
                        "name": "accuracy",
                        "optional": true,
                        "default": "1e-12"
                    }
                ]
            }
        ],
        "markdown": "### [loess](https://docs.dolphindb.com/en/Functions/l/loess.html)\n\n\n\n#### Syntax\n\nloess(X, Y, resampleRule, \\[closed='left'], \\[origin='start\\_day'], \\[outputX=false], \\[bandwidth=0.3], \\[robustnessIter=4], \\[accuracy=1e-12])\n\n#### Arguments\n\n**X** is a strictly increasing vector of temporal type.\n\n**Y** is a numeric vector of the same length as *X*.\n\n**resampleRule** is a string. See the parameter *rule* of function [resample](https://docs.dolphindb.com/en/Functions/r/resample.html) for the optional values.\n\n**closed** and **origin** are the same as the parameters *closed* and *origin* of function [resample](https://docs.dolphindb.com/en/Functions/r/resample.html).\n\n**outputX** is a Boolean value indicating whether to output the resampled X. The default value is false.\n\n**bandwidth** is a numeric scalar in (0,1]. when computing the loess fit at a particular point, this fraction of source points closest to the current point is taken into account for computing a least-squares regression.\n\n**robustnessIter** is a postive interger indicating how many robustness iterations are done.\n\n**accuracy** is a number greater than 1. If the median residual at a certain robustness iteration is less than this amount, no more iterations are done.\n\n#### Details\n\nResample *X* based on the specified *resampleRule*, *closed* and *origin*. Implement Local Regression Algorithm (Loess) for interpolation on *Y* based on the resampled *X*.\n\nIf *outputX* is unspecified, return a vector of *Y* after the interpolation.\n\nIf *outputX*=true, return a tuple where the first element is the vector of resampled *X* and the second element is a vector of *Y* after the interpolation.\n\n#### Examples\n\n```\nloess([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min, bandwidth=1)\n\n// output\n[1,1.0521,1.104,1.1558,1.2072,1.2582,1.3086,1.3584,1.4074,1.4556,\n1.5027,1.5488,1.5937,1.6374,1.6795,1.7202,1.7593,1.7966,1.832,1.8655,\n1.897,1.9263,1.9533,1.9779,2,2.0195,2.0366,2.0513,2.0637,2.0739,\n2.082,2.0882,2.0926,2.0952,2.0962,2.0957,2.0938,2.0905,2.0861,2.0806,\n2.0741,2.0667,2.0586,2.0498,2.0405,2.0308,2.0207,2.0104,2]\n```\n"
    },
    "log": {
        "url": "https://docs.dolphindb.com/en/Functions/l/log.html",
        "signatures": [
            {
                "full": "log(X)",
                "name": "log",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [log](https://docs.dolphindb.com/en/Functions/l/log.html)\n\n\n\n#### Syntax\n\nlog(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nReturn the natural logarithm of *X*.\n\n#### Examples\n\n```\nlog(2.718283);\n// output\n1\nlog(0 1 2 3);\n// output\n[,0,0.693147,1.098612]\n```\n"
    },
    "log10": {
        "url": "https://docs.dolphindb.com/en/Functions/l/log10.html",
        "signatures": [
            {
                "full": "log10(X)",
                "name": "log10",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [log10](https://docs.dolphindb.com/en/Functions/l/log10.html)\n\n\n\n#### Syntax\n\nlog10(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nReturn the logarithm of *X* to the base 10.\n\n#### Examples\n\n```\nlog10(100);\n// output\n2\n\nlog10(0 10 100 1000 NULL);\n// output\n[,1,2,3,]\n\nlog10(10 100 1000 10000$2:2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n"
    },
    "log1p": {
        "url": "https://docs.dolphindb.com/en/Functions/l/log1p.html",
        "signatures": [
            {
                "full": "log1p(X)",
                "name": "log1p",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [log1p](https://docs.dolphindb.com/en/Functions/l/log1p.html)\n\n\n\n#### Syntax\n\nlog1p(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nReturn log(1+X).\n\n#### Examples\n\n```\nlog1p(0);\n// output\n0\n\nlog1p([0, e-1, pow(e,2)-1, pow(e,3)-1, NULL]);\n// output\n[0,1,2,3,]\n\nlog1p([0, e-1, pow(e,2)-1, pow(e,3)-1]$2:2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 0  | 2  |\n| 1  | 3  |\n"
    },
    "log2": {
        "url": "https://docs.dolphindb.com/en/Functions/l/log2.html",
        "signatures": [
            {
                "full": "log2(X)",
                "name": "log2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [log2](https://docs.dolphindb.com/en/Functions/l/log2.html)\n\n\n\n#### Syntax\n\nlog2(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nReturn the logarithm of *X* to the base 2.\n\n#### Examples\n\n```\nlog2(4);\n// output\n2\n\nlog2(0 2 4 8 NULL);\n// output\n[,1,2,3,]\n\nlog2(1..4$2:2);\n```\n\n| #0 | #1       |\n| -- | -------- |\n| 0  | 1.584963 |\n| 1  | 2        |\n"
    },
    "login": {
        "url": "https://docs.dolphindb.com/en/Functions/l/login.html",
        "signatures": [
            {
                "full": "login(userId, password, [encrypted=false])",
                "name": "login",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    },
                    {
                        "full": "password",
                        "name": "password"
                    },
                    {
                        "full": "[encrypted=false]",
                        "name": "encrypted",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [login](https://docs.dolphindb.com/en/Functions/l/login.html)\n\n\n\n#### Syntax\n\nlogin(userId, password, \\[encrypted=false])\n\n#### Arguments\n\n**userId** a string indicating a user name. It can only contain letters, underscores, or numbers. It cannot start with numbers. The length cannot exceed 30 characters.\n\n**password** a string indicating the password. It cannot contain space or control characters. The length must be between 6 and 20 characters.\n\n**encrypted** a Boolean value indicating whether to encrypt userId and password with public key.\n\n#### Details\n\nA user logs in to operate on the controller or data nodes.\n\nSince DolphinDB 2.00.10.10, users can determine whether to limit the number of failed login attempts by setting the configuration *enhancedSecurityVerification*. If it is not specified, no limit will be applied; if it is set to true, a user's account will be blocked for 10 minutes if the password is entered wrongly 5 times in a minute.\n\n#### Examples\n\n```\nlogin(`JohnSmith, `Qb0507);\n```\n"
    },
    "logisticRegression": {
        "url": "https://docs.dolphindb.com/en/Functions/l/logisticRegression.html",
        "signatures": [
            {
                "full": "logisticRegression(ds, yColName, xColNames, [intercept=true], [initTheta], [tolerance=1e-3], [maxIter=500], [regularizationCoeff=1.0])",
                "name": "logisticRegression",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[initTheta]",
                        "name": "initTheta",
                        "optional": true
                    },
                    {
                        "full": "[tolerance=1e-3]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "1e-3"
                    },
                    {
                        "full": "[maxIter=500]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "500"
                    },
                    {
                        "full": "[regularizationCoeff=1.0]",
                        "name": "regularizationCoeff",
                        "optional": true,
                        "default": "1.0"
                    }
                ]
            }
        ],
        "markdown": "### [logisticRegression](https://docs.dolphindb.com/en/Functions/l/logisticRegression.html)\n\n\n\n#### Syntax\n\nlogisticRegression(ds, yColName, xColNames, \\[intercept=true], \\[initTheta], \\[tolerance=1e-3], \\[maxIter=500], \\[regularizationCoeff=1.0])\n\n#### Arguments\n\n**ds** is the data source to be trained. It can be generated with function [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html).\n\n**yColName** is a string indicating the category column name.\n\n**xColNames** is a string scalar/vector indicating the names of independent variables.\n\n**intercept** is a Boolean scalar indicating whether the regression uses an intercept. The default value is true, which means that a column of 1s is added to the independent variables.\n\n**initTheta** is a vector indicating the initial values of the parameters when the iterations begin. The default value is a vector of zeroes with the length of *xColNames.size()+intercept*.\n\n**tolerance** is a numeric scalar. If the difference in the value of the log likelihood functions of 2 adjacent iterations is smaller than *tolerance*, the iterations would stop. The default value is 0.001.\n\n**maxIter** is a positive integer indicating the maximum number of iterations. The iterations will stop if the number of iterations reaches *maxIter*. The default value is 500.\n\n**regularizationCoeff** is a positive number indicating the coefficient of the regularization term. The default value is 1.0.\n\n*intercept*, *initTheta*, *tolerance*, *maxIter*, *regularizationCoeff* are optional.\n\n#### Details\n\nFit a logistic regression model. The result is a dictionary with the following keys: *iterations*, *modelName*, *coefficients*, *tolerance*, *logLikelihood*, *xColNames* and *intercept*. *iterations* is the number of iterations, *modelName* is \"Logistic Regression\", *coefficients* is a vector of the parameter estimates, *logLikelihood* is the final value of the log likelihood function.\n\nThe fitted model can be used as an input for function [predict](https://docs.dolphindb.com/en/Functions/p/predict.html).\n\n#### Examples\n\nFit a logistic regression model with simulated data:\n\n```\nt = table(100:0, `y`x0`x1, [INT,DOUBLE,DOUBLE])\ny = take(0, 50)\nx0 = norm(-1.0, 1.0, 50)\nx1 = norm(-1.0, 1.0, 50)\ninsert into t values (y, x0, x1)\ny = take(1, 50)\nx0 = norm(1.0, 1.0, 50)\nx1 = norm(1.0, 1.0, 50)\ninsert into t values (y, x0, x1)\n\nmodel = logisticRegression(sqlDS(<select * from t>), `y, `x0`x1);\n\n// output\nmodelName->Logistic Regression\nlogLikelihood->-23.269132\nintercept->true\ncoefficients->[1.377971,1.914001,-0.305114]\nxColNames->[x0,x1]\niterations->7\ntolerance->0.001\n```\n\nUse the fitted model in forecasting:\n\n```\npredict(model, t);\n```\n\nSave the fitted model to disk:\n\n```\nsaveModel(model, \"C:/DolphinDB/data/logisticModel.txt\");\n```\n\nLoad a saved model:\n\n```\nloadModel(\"C:/DolphinDB/data/logisticModel.txt\");\n```\n"
    },
    "logout": {
        "url": "https://docs.dolphindb.com/en/Functions/l/logout.html",
        "signatures": [
            {
                "full": "logout([userId], [sessionOnly=true])",
                "name": "logout",
                "parameters": [
                    {
                        "full": "[userId]",
                        "name": "userId",
                        "optional": true
                    },
                    {
                        "full": "[sessionOnly=true]",
                        "name": "sessionOnly",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [logout](https://docs.dolphindb.com/en/Functions/l/logout.html)\n\n\n\n#### Syntax\n\nlogout(\\[userId], \\[sessionOnly=true])\n\n#### Arguments\n\n**userId** is a string indicating a user name. It can only contain letters, underscores, or numbers. It cannot start with numbers. Its length cannot exceed 30 characters.\n\n**sessionOnly** is a Boolean value.\n\n#### Details\n\nThis function can be executed on a controller/data/compute node.\n\nIf *userId* is unspecified, the current user logs out.\n\nIf *sessionOnly* is true, the user logs out from the current session.\n\nIf *sessionOnly* is false, the user logs out completely from the current session, all data/compute nodes, and the controller node.\n\nAn administrator can log out another user. If an administrator logs out another user, the user is logged out from the current session, all data nodes, and the controller node.\n\n#### Examples\n\n```\nlogout();\n\nlogout(`TomFord);\n\nlogout(, false);\n```\n"
    },
    "long": {
        "url": "https://docs.dolphindb.com/en/Functions/l/long.html",
        "signatures": [
            {
                "full": "long(X)",
                "name": "long",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [long](https://docs.dolphindb.com/en/Functions/l/long.html)\n\n\n\n#### Syntax\n\nlong(X)\n\n#### Arguments\n\n**X** can be of any data type.\n\n#### Details\n\nConvert the data type of *X* to LONG.\n\n#### Examples\n\n```\nx=long();\nx;\n// output\n00l\ntypestr x;\n// output\nLONG\n\nlong(`10.9);\n// output\n10\n\nlong(9223372036854775807l);\n// output\n9223372036854775807\n\nlong(9223372036854775808l);\n// output\n9223372036854775807\n// maximum value for a LONG is 2^63-1=9223372036854775807\n```\n"
    },
    "lowDouble": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lowDouble.html",
        "signatures": [
            {
                "full": "lowDouble(X)",
                "name": "lowDouble",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [lowDouble](https://docs.dolphindb.com/en/Functions/l/lowDouble.html)\n\n\n\n#### Syntax\n\nlowDouble(X)\n\n#### Arguments\n\n**X** is a vector/scalar which must be 16-byte data type.\n\n#### Details\n\nIt returns the low-order 8-byte double data of *X*.\n\n#### Example\n\n```\nx=1 2 3 4\ny=4 3 2 1\npoints = point(x, y)\nx1 = lowDouble(points)\n// output\n[1,2,3,4]\n```\n\nGet the real part of the complex number:\n\n```\na=complex(2, 5)\nlowDouble(a)\n// output\n2\n```\n"
    },
    "lower": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lower.html",
        "signatures": [
            {
                "full": "lower(X)",
                "name": "lower",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [lower](https://docs.dolphindb.com/en/Functions/l/lower.html)\n\n\n\n#### Syntax\n\nlower(X)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n#### Details\n\nConvert all characters in a string or a list of strings into lower cases.\n\n#### Examples\n\n```\nx= `Ibm`C`AapL;\nx.lower();\n// output\n[\"ibm\",\"c\",\"aapl\"]\n\nlower(`Chloe);\n// output\nchloe\n```\n\nRelated function: [upper](https://docs.dolphindb.com/en/Functions/u/upper.html)\n"
    },
    "lowerBound": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lowerBound.html",
        "signatures": [
            {
                "full": "lowerBound(X,Y)",
                "name": "lowerBound",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [lowerBound](https://docs.dolphindb.com/en/Functions/l/lowerBound.html)\n\n#### Syntax\n\nlowerBound(X,Y)\n\n#### Arguments\n\n**X** is an increasing vector, or an indexed series/matrix.\n\n**Y** is a scalar, vector, array vector, tuple, matrix, dictionary or table.\n\n#### Details\n\nFor each element y in *Y*, get the first element that is greater than or equal to y and return its index in *X*. If no element is found, return the length of *X*.\n\n#### Examples\n\n```\nX = [1,3,5];\nY = [5,6,7];\nZ = lowerBound(X,Y);\nZ\n// output: [2,3,3]\n\nindex = [2023.05.04, 2023.05.06, 2023.05.07, 2023.05.10]\ns = indexedSeries(index, 1..4)\ny=[2023.05.04, 2023.05.06, 2023.05.09]\n\nlowerBound(s,y)\n```\n\n| label      | #0 |\n| ---------- | -- |\n| 2023.05.04 | 1  |\n| 2023.05.06 | 2  |\n| 2023.05.09 | 4  |\n\n"
    },
    "lowLong": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lowlong.html",
        "signatures": [
            {
                "full": "lowLong(X)",
                "name": "lowLong",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [lowLong](https://docs.dolphindb.com/en/Functions/l/lowlong.html)\n\n\n\n#### Syntax\n\nlowLong(X)\n\n#### Arguments\n\n**X** is a scalar/vector/table/data pair/dictionary which must be 16-byte data type (UUID, IPADDR, INT128, COMPLEX, and POINT are supported).\n\n#### Details\n\nIt returns the low-order 8-byte long integer data of *X*.\n\n#### Examples\n\n```\nx =ipaddr(\"192.168.1.13\")\nx1 = lowLong(x)\nprint(x1)\n//output\n3232235789\n```\n\n```\nx=1 2 3 4\ny=4 3 2 1\npoints = point(x, y)\nx1 = lowLong(points)\n//output\n[4607182418800017408,4611686018427387904,4613937818241073152,4616189618054758400]\n```\n\nRelated function: [highLong](https://docs.dolphindb.com/en/Functions/h/highlong.html)\n"
    },
    "lowRange": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lowRange.html",
        "signatures": [
            {
                "full": "lowRange(X)",
                "name": "lowRange",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [lowRange](https://docs.dolphindb.com/en/Functions/l/lowRange.html)\n\n\n\n#### Syntax\n\nlowRange(X)\n\n#### Arguments\n\n**X** is a vector/tuple/matrix/table.\n\n#### Details\n\nFor each element *Xi* in *X*, count the continuous nearest neighbors to its left that are larger than *Xi*.\n\nFor each element in *X*, the function return the maximum length of a window to the left of *X* where it is the max/min. For example, after how many days a stock hits a new high.\n\n#### Examples\n\n```\nlowRange([13.5, 13.6, 13.4, 13.3, 13.5, 13.9, 13.1, 20.1, 20.2, 20.3])\n// output\n[0,0,2,3,0,0,6,0,0,0]\n\nm = matrix(1.5 2.6 3.2 1.4 2.5 2.2 3.7 2.0, 1.6 2.3 4.2 5.6 4.1 3.2 4.4 6.9)\nlowRange(m)\n```\n\n| #0 | #1 |\n| -- | -- |\n| 0  | 0  |\n| 0  | 0  |\n| 0  | 0  |\n| 3  | 0  |\n| 0  | 2  |\n| 1  | 3  |\n| 0  | 0  |\n| 3  | 0  |\n\n```\n//Simulate the stock price of stock A for 8 days. Use lowRange to calculate after how many days the stock hit a new low\ntrades = table(take(`A, 8) as sym,  2022.01.01 + 1..8 as date, 39.70 39.72 39.80 39.78 39.83 39.92 40.00 40.03 as price)\nselect *, lowRange(price) from trades\n```\n\n| id | date       | price | lowRange\\_price |\n| -- | ---------- | ----- | --------------- |\n| A  | 2022.01.02 | 39.7  | 0               |\n| A  | 2022.01.03 | 39.72 | 0               |\n| A  | 2022.01.04 | 39.8  | 0               |\n| A  | 2022.01.05 | 39.78 | 1               |\n| A  | 2022.01.06 | 39.83 | 0               |\n| A  | 2022.01.07 | 39.92 | 0               |\n| A  | 2022.01.08 | 40    | 0               |\n| A  | 2022.01.09 | 40.03 | 0               |\n\nRelated function: [topRange](https://docs.dolphindb.com/en/Functions/t/topRange.html)\n"
    },
    "lpad": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lpad.html",
        "signatures": [
            {
                "full": "lpad(str, length, [pattern])",
                "name": "lpad",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "length",
                        "name": "length"
                    },
                    {
                        "full": "[pattern]",
                        "name": "pattern",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [lpad](https://docs.dolphindb.com/en/Functions/l/lpad.html)\n\n\n\n#### Syntax\n\nlpad(str, length, \\[pattern])\n\n#### Arguments\n\n**str** is a string scalar or vector. It is the string to pad characters to (the left-hand side).\n\n**length** is a positive integer indicating the number of characters to return. If *length* is smaller than the length of *str*, the *lpad* function is equivalent to `left(str, length)`.\n\n**pattern** is a string scalar. It is the string that will be padded to the left-hand side of *str*. If it is unspecified, the *lpad* function will pad spaces to the left-side of *str*.\n\n#### Details\n\nPad the left-side of a string with a specific set of characters.\n\n#### Examples\n\n```\nlpad(\"Hello\",2);\n// output\nHe\n\nlpad(`Hello, 10);\n// output\n   Hello\n\nlpad(`Hello, 12, `0);\n// output\n0000000Hello\n```\n"
    },
    "lshift": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lshift.html",
        "signatures": [
            {
                "full": "lshift(X,bits)",
                "name": "lshift",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "bits",
                        "name": "bits"
                    }
                ]
            }
        ],
        "markdown": "### [lshift](https://docs.dolphindb.com/en/Functions/l/lshift.html)\n\n\n\n#### Syntax\n\nlshift(X,bits) or X<\\<bits\n\n#### Arguments\n\n**X** is an integral scalar/pair/vector/matrix/table.\n\n**bits** is the number of bits to shift.\n\n#### Details\n\nShift the binary representation of *X* to the left by *bits*. The bits on the right are filled with zeros.\n\n#### Examples\n\n```\nlshift(2, 10);\n// output\n2048\n\n1..10 << 1;\n// output\n[2,4,6,8,10,12,14,16,18,20]\n\n1..10 << 10;\n// output\n[1024,2048,3072,4096,5120,6144,7168,8192,9216,10240]\n\n1:10<<10;\n// output\n1024 : 10240\n```\n\nRelated function: [rshift](https://docs.dolphindb.com/en/Functions/r/rshift.html).\n"
    },
    "lt": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lt.html",
        "signatures": [
            {
                "full": "lt(X, Y)",
                "name": "lt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [lt](https://docs.dolphindb.com/en/Functions/l/lt.html)\n\n\n\n#### Syntax\n\nlt(X, Y) or X\\<Y\n\n#### Arguments\n\n**X** / **Y** is a scalar/pair/vector/matrix/set. If *X* or *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nIf neither *X* nor *Y* is a set, return the element-by-element comparison of *X*<*Y*.\n\nIf both *X* and *Y* are sets, check if *X* is a proper subset of *Y*.\n\n#### Examples\n\n```\n1 2 3 < 2;\n// output\n[1,0,0]\n\n1 2 3<0 2 4;\n// output\n[0,0,1]\n\n2:3<1:6;\n// output\n0 : 1\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 lt 4;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 0  |\n| 1  | 0  | 0  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1<m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 0  |\n| 1  | 0  | 0  |\n\nSet operation: If *X*<*Y* then *X* is a proper subset of *Y*\n\n```\nx=set(4 6);\nx;\n// output\nset(6,4)\ny=set(8 9 4 6);\ny;\n// output\nset(6,4,9,8)\n\nx<y;\n// output\n1\n\ny<x;\n// output\n0\n\nx<x;\n// output\n0\n// x is not a proper subset of x\n```\n"
    },
    "ltrim": {
        "url": "https://docs.dolphindb.com/en/Functions/l/ltrim.html",
        "signatures": [
            {
                "full": "ltrim(X)",
                "name": "ltrim",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ltrim](https://docs.dolphindb.com/en/Functions/l/ltrim.html)\n\n\n\n#### Syntax\n\nltrim(X)\n\n#### Arguments\n\n**X** is a string scalar or vector.\n\n#### Details\n\nRemove leading spaces from a character expression.\n\n#### Examples\n\n```\nltrim(\"    I love this game!\");\n// output\nI love this game!\n```\n"
    },
    "lu": {
        "url": "https://docs.dolphindb.com/en/Functions/l/lu.html",
        "signatures": [
            {
                "full": "lu(obj, [permute=false])",
                "name": "lu",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[permute=false]",
                        "name": "permute",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [lu](https://docs.dolphindb.com/en/Functions/l/lu.html)\n\n\n\n#### Syntax\n\nlu(obj, \\[permute=false])\n\n#### Arguments\n\n**obj** is a matrix with no NULL values.\n\n**permute** is a Boolean value. The default value is false.\n\n#### Details\n\nCompute pivoted LU decomposition of a matrix.\n\nIf *permute* is false, return 3 matrices (L, U and P) with *obj* = P'*L*U. P is a permutation matrix, L is a lower triangular matrix with unit diagonal elements, and U is an upper triangular matrix.\n\nIf *permute* is true, return 2 matrices (L and U) with *obj* = L\\*U.\n\n#### Examples\n\n```\nA = matrix([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]]);\n\nP, L, U = lu(A);\nP;\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 0  | 0  | 1  | 0  |\n| 0  | 0  | 0  | 1  |\n| 1  | 0  | 0  | 0  |\n| 0  | 1  | 0  | 0  |\n\n```\nL;\n```\n\n| #0    | #1   | #2       | #3 |\n| ----- | ---- | -------- | -- |\n| 1     | 0    | 0        | 0  |\n| 0.875 | 1    | 0        | 0  |\n| 0.25  | 0.72 | 1        | 0  |\n| 0.625 | 0.12 | 0.233871 | 1  |\n\n```\nU;\n```\n\n| #0 | #1   | #2   | #3       |\n| -- | ---- | ---- | -------- |\n| 8  | 2    | 6    | 4        |\n| 0  | 6.25 | 0.75 | 4.5      |\n| 0  | 0    | 4.96 | 0.76     |\n| 0  | 0    | 0    | 0.782258 |\n\n```\nL, U = lu(A, true);\nL;\n```\n\n| #0    | #1   | #2       | #3 |\n| ----- | ---- | -------- | -- |\n| 0.25  | 0.72 | 1        | 0  |\n| 0.625 | 0.12 | 0.233871 | 1  |\n| 1     | 0    | 0        | 0  |\n| 0.875 | 1    | 0        | 0  |\n\n```\nU;\n```\n\n| #0 | #1   | #2   | #3       |\n| -- | ---- | ---- | -------- |\n| 8  | 2    | 6    | 4        |\n| 0  | 6.25 | 0.75 | 4.5      |\n| 0  | 0    | 4.96 | 0.76     |\n| 0  | 0    | 0    | 0.782258 |\n"
    },
    "ma": {
        "url": "https://docs.dolphindb.com/en/Functions/m/ma.html",
        "signatures": [
            {
                "full": "ma(X, window, maType)",
                "name": "ma",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "maType",
                        "name": "maType"
                    }
                ]
            }
        ],
        "markdown": "### [ma](https://docs.dolphindb.com/en/Functions/m/ma.html)\n\n\n\n#### Syntax\n\nma(X, window, maType)\n\nPlease see [TALib](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**maType** is the type of moving averages. It is an integer in \\[0,8].0= [sma](https://docs.dolphindb.com/en/Functions/s/sma.html) , 1= [ema](https://docs.dolphindb.com/en/Functions/e/ema.html) , 2= [wma](https://docs.dolphindb.com/en/Functions/w/wma.html) , 3= [dema](https://docs.dolphindb.com/en/Functions/d/dema.html) , 4= [tema](https://docs.dolphindb.com/en/Functions/t/tema.html) , 5= [trima](https://docs.dolphindb.com/en/Functions/t/trima.html) , 6= [kama](https://docs.dolphindb.com/en/Functions/k/kama.html) , 7=(mama), 8= [t3](https://docs.dolphindb.com/en/Functions/t/t3.html) .\n\n#### Details\n\nCalculate the moving average (whose type is determined by maType) in a sliding window of the given length.\n"
    },
    "mad": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mad.html",
        "signatures": [
            {
                "full": "mad(X, [useMedian=false])",
                "name": "mad",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[useMedian=false]",
                        "name": "useMedian",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [mad](https://docs.dolphindb.com/en/Functions/m/mad.html)\n\n\n\n#### Syntax\n\nmad(X, \\[useMedian=false])\n\n#### Arguments\n\n**X** is a vector, matrix or table.\n\n**useMedian** is a Boolean value indicating whether the result is generated with the median absolute deviation or the mean absolute deviation. The default value is false and it returns the mean absolute deviation.\n\n* Mean Absolute Deviation: mean(abs(X - mean(X)))\n\n* Median Absolute Deviation: med(abs(X - med(X)))\n\n#### Details\n\nIf *X* is a vector, return the average absolute deviation of *X*.\n\nIf *X* is a matrix, the calculation is based on each column and returns a matrix.\n\nIf *X* is a table, the calculation is based on each column and returns a table.\n\nAs with all aggregate functions, NULL values are not included in the calculation.\n\n#### Examples\n\n```\nmad([85, 90, 95, NULL]);\n// output\n3.333333333333333\n\nm=matrix(85 90 95, 185 190 195);\nm;\n```\n\n| #0 | #1  |\n| -- | --- |\n| 85 | 185 |\n| 90 | 190 |\n| 95 | 195 |\n\n```\nmad m;\n// output\n[3.333333333333333, 3.333333333333333]\n\nmad([0, 19.618568, 67.900707, 71.65218, 73.103952, 58.275308, 18.819054, 36.940571, 48.114366], false)\n// output\n22.204817\n```\n\nRelated function: [mmad](https://docs.dolphindb.com/en/Functions/m/mmad.html)\n"
    },
    "makeCall": {
        "url": "https://docs.dolphindb.com/en/Functions/m/makeCall.html",
        "signatures": [
            {
                "full": "makeCall(F, args...)",
                "name": "makeCall",
                "parameters": [
                    {
                        "full": "F",
                        "name": "F"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [makeCall](https://docs.dolphindb.com/en/Functions/m/makeCall.html)\n\n\n\n#### Syntax\n\nmakeCall(F, args...)\n\n#### Arguments\n\n**F** is a function.\n\n**args** are the required parameters of *F*.\n\n#### Details\n\nCall a function with the specified parameters to generate a piece of script. The difference between [call](https://docs.dolphindb.com/en/Functions/Templates/call.html) and *makeCall* is that *makeCall* doesn't execute the script.\n\n#### Examples\n\nIn the following example, we create a function *generateReport* that reports selected columns from a given table with specified format.\n\n```\ndef generateReport(tbl, colNames, colFormat): sql(sqlColAlias(each(makeCall{format},sqlCol(colNames),colFormat),colNames), tbl).eval();\nt = table(1..100 as id, (1..100 + 2018.01.01) as date, rand(100.0, 100) as price, rand(10000, 100) as qty, rand(`A`B`C`D`E`F`G, 100) as city);\nt;\n```\n\n| id  | date       | price   | qty  | city |\n| --- | ---------- | ------- | ---- | ---- |\n| 1   | 2018.01.02 | 77.9896 | 375  | A    |\n| 2   | 2018.01.03 | 8.1332  | 7864 | F    |\n| 3   | 2018.01.04 | 56.7185 | 4912 | B    |\n| 4   | 2018.01.05 | 72.4173 | 534  | E    |\n| 5   | 2018.01.06 | 8.2019  | 31   | B    |\n| 6   | 2018.01.07 | 74.7275 | 4139 | A    |\n| 7   | 2018.01.08 | 7.5421  | 2725 | D    |\n| 8   | 2018.01.09 | 59.1689 | 3095 | C    |\n| 9   | 2018.01.10 | 55.8454 | 5443 | D    |\n| 10  | 2018.01.11 | 32.1285 | 6998 | G    |\n| ... |            |         |      |      |\n\n```\ngenerateReport(t, [\"id\", \"date\",\"price\",\"qty\"], [\"0\", \"MM/dd/yyyy\", \"0.00\", \"#,###\"]);\n```\n\n| id  | date       | price | qty   |\n| --- | ---------- | ----- | ----- |\n| 1   | 01/02/2018 | 77.99 | 375   |\n| 2   | 01/03/2018 | 8.13  | 7,864 |\n| 3   | 01/04/2018 | 56.72 | 4,912 |\n| 4   | 01/05/2018 | 72.42 | 534   |\n| 5   | 01/06/2018 | 8.20  | 31    |\n| 6   | 1/07/2018  | 74.73 | 4,139 |\n| 7   | 01/08/2018 | 7.54  | 2,725 |\n| 8   | 01/09/2018 | 59.17 | 3,095 |\n| 9   | 01/10/2018 | 55.85 | 5,443 |\n| 10  | 01/11/2018 | 32.13 | 6,988 |\n| ... |            |       |       |\n\nThe equivalent SQL script for the previous execution is:\n\n```\ndef generateReportSQL(tbl, colNames, colFormat): sql(sqlColAlias(each(makeCall{format},sqlCol(colNames),colFormat),colNames), tbl)\ngenerateReportSQL(t, [\"id\", \"date\",\"price\",\"qty\"], [\"0\", \"MM/dd/yyyy\", \"0.00\", \"#,###\"]);\n// output\n< select format(id, \"0\") as id,format(date, \"MM/dd/yyyy\") as date,format(price, \"0.00\") as price,format(qty, \"#,###\") as qty from t >\n```\n"
    },
    "makeKey": {
        "url": "https://docs.dolphindb.com/en/Functions/m/makeKey.html",
        "signatures": [
            {
                "full": "makeKey(args...)",
                "name": "makeKey",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [makeKey](https://docs.dolphindb.com/en/Functions/m/makeKey.html)\n\n\n\n#### Syntax\n\nmakeKey(args...)\n\n#### Arguments\n\n**args** are multiple scalars or vectors of the same length.\n\n#### Details\n\nCombine the specified *args* as a BLOB scalar or vector, so it can used as the key(s) of a dictionary or a set. Compared with *makeSortedKey*, *makeKey* keeps the order of the inputs in the result.\n\n#### Examples\n\n```\nmakeKey(`a1,`b1,`c1)\n// output\na1b1c1\n\nset(makeKey(1 2, 4 5))\n\nre=makeKey(`a1`a2, `_1`_2)\ndict(re,100 200)\n\n// output\na2_2->200\na1_1->100\n```\n\nRelated Function: [makeSortedKey](https://docs.dolphindb.com/en/Functions/m/makeSortedKey.html)\n"
    },
    "makeSortedKey": {
        "url": "https://docs.dolphindb.com/en/Functions/m/makeSortedKey.html",
        "signatures": [
            {
                "full": "makeSortedKey(args...)",
                "name": "makeSortedKey",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [makeSortedKey](https://docs.dolphindb.com/en/Functions/m/makeSortedKey.html)\n\n\n\n#### Syntax\n\nmakeSortedKey(args...)\n\n#### Arguments\n\n**args** are multiple scalars or vectors of the same length.\n\n#### Details\n\nCombine the specified *args* as a BLOB scalar or vector. `makeSortedKey` stores the keys in sorted order internally, while returns the same result as `makeKey`.\n\n#### Examples\n\n```\nmakeSortedKey([`b,`a,`c], [`4,`2,`1])\n// output\n[\"b4\",\"a2\",\"c1\"]\n\nset(makeSortedKey(1 2, 4 5))\n```\n\nRelated Function: [makeKey](https://docs.dolphindb.com/en/Functions/m/makeKey.html)\n"
    },
    "makeUnifiedCall": {
        "url": "https://docs.dolphindb.com/en/Functions/m/makeUnifiedCall.html",
        "signatures": [
            {
                "full": "makeUnifiedCall(func, args)",
                "name": "makeUnifiedCall",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args",
                        "name": "args"
                    }
                ]
            }
        ],
        "markdown": "### [makeUnifiedCall](https://docs.dolphindb.com/en/Functions/m/makeUnifiedCall.html)\n\n\n\n#### Syntax\n\nmakeUnifiedCall(func, args)\n\n#### Arguments\n\n**func** is a function.\n\n**args** is a tuple. Each element is a parameter of *func*. Since version 2.00.11.3, *args* can be metacode with a tuple expression.\n\n#### Details\n\nGenerate metacode for function call. Use function [eval](https://docs.dolphindb.com/en/Functions/e/eval.html) to execute the metacode. The difference between `makeUnifiedCall` and the template function [unifiedCall](https://docs.dolphindb.com/en/Functions/Templates/unifiedCall.html) is that `makeUnifiedCall` doesn't execute the metacode.\n\n#### Examples\n\n```\nmc = makeUnifiedCall(matrix, (1 2 3, 4 5 6));\nmc;\n// output\n< matrix([1,2,3], [4,5,6]) >\nmc.eval();\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 4    |\n| 2    | 5    |\n| 3    | 6    |\n\nSince version 2.00.11.3, *args* can be tuple metacode to be dynamically passed to a function. The following example illustrates the difference between passing *args* as a tuple and tuple metacode.\n\n```\nx=3\ny=5\na = makeUnifiedCall(add, (x,y)) // < add(3, 5) >\nb = makeUnifiedCall(add, <(x,y)>) // < add(x, y) >\n```\n\n* If *args* is a tuple, `makeUnifiedCall` passes the values of the variables in the tuple to *func* and generates `< add(3, 5) >`.\n\n* If *args* is metacode with a tuple expression, `makeUnifiedCall` passes the variables in the tuple expression to *func* and generates `< add(x, y) >`.\n\nWhen the value of *x* or *y* changes, the execution result of `a` remains unchanged while that of `b` changes accordingly as it dynamically passes the values of *x* and *y*.\n\n```\nx = 6\na.eval() // 3+5=8\nb.eval() //  6+5=11\n```\n\n`makeUnifiedCall` can also be used with `sqlTuple` and `sql` to dynamically generate SQL metacode. In the following example, the parameter *args* of `makeUnifiedCall` is tuple metacode generated using `sqlTuple`, and *func* is a user-defined function. The result of `makeUnifiedCall` is passed as the parameter *select* of function `sql` to generate SQL metacode `c`.\n\n```\n// Create a user-defined function\nf = def (x,y)->(x-y)/(x+y)\n\n// Create a table for query\nt = table(1.0 2.0 3.0 as qty1, 1.0 3.0 7.0 as qty2)\n\n// Generate metacode for query\nc = sql(select=makeUnifiedCall(f, sqlTuple(`qty1`qty2)), from=t)\n\n// Execute the corresponding metacode\nc.eval()\n```\n\n<table id=\"table_rg4_dwc_s1c\"><thead><tr><th align=\"left\">\n\n**\\_qty1**\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\n0\n\n</td></tr><tr><td align=\"left\">\n\n-0.2\n\n</td></tr><tr><td align=\"left\">\n\n-0.4\n\n</td></tr></tbody>\n</table>Related Information: [sqlTuple](../s/sqlTuple.md)\n"
    },
    "mannWhitneyUTest": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mannWhitneyUTest.html",
        "signatures": [
            {
                "full": "mannWhitneyUTest(X, Y, [correct=true])",
                "name": "mannWhitneyUTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[correct=true]",
                        "name": "correct",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [mannWhitneyUTest](https://docs.dolphindb.com/en/Functions/m/mannWhitneyUTest.html)\n\n\n\n#### Syntax\n\nmannWhitneyUTest(X, Y, \\[correct=true])\n\n#### Arguments\n\n**X** is a numeric vector.\n\n**Y** is a numeric vector.\n\n**correct** is a Boolean value indicating whether to consider continuity correction when calculating the p-value. The default value is true.\n\n#### Details\n\nPerform the Mann-Whitney U test on *X* and *Y*. It returns a dictionary object with the following keys:\n\n* stat: A table containing p-values under three different alternative hypotheses\n\n* correct: Whether to consider continuity correction when calculating p-value\n\n* method: The string \"Mann-Whitney U test\"\n\n* U: U statistic\n\n#### Examples\n\n```\nmannWhitneyUTest(5 1 4 3 5, 2 4 7 -1 0 4);\n\n// output\nstat->\n\nalternativeHypothesis                 pValue\n------------------------------------- --------\ntrue location shift is not equal to 0 0.518023\ntrue location shift is less than 0    0.259011\ntrue location shift is greater than 0 0.797036\n\ncorrect->true\nmethod->Mann-Whitney U test\nU->11\n```\n"
    },
    "manova": {
        "url": "https://docs.dolphindb.com/en/Functions/m/manova.html",
        "signatures": [
            {
                "full": "manova(X, group)",
                "name": "manova",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "group",
                        "name": "group"
                    }
                ]
            }
        ],
        "markdown": "### [manova](https://docs.dolphindb.com/en/Functions/m/manova.html)\n\n\n\n#### Syntax\n\nmanova(X, group)\n\n#### Arguments\n\n**X** is a matrix or a table whose columns are all of numeric types.\n\n**group** is a vector with the same length as each of the columns of *X* indicating groups.\n\n#### Details\n\nConduct multivariate analysis of variance (MANOVA).\n\n#### Examples\n\n```\na=29.6 24.3 1.5 20.2 2.6 44.5 2.4 20 9.5\nb=27.3 68.4 3.8 34.8 4.6 26.3 5.9 20 5.6\nc=50.8 60.2 1.0 30.1 2.1 27.9 2.3 20 8.8\ng=1 1 2 1 2 1 2 1 2\nt=table(a,b,c,g)\nmanova(select a,b,c from t, t.g);\n\n// output\ndfT->8\ndfB->1\ngnames->[1,2]\ngmdist->\n#0        #1\n--------- ---------\n0         16.458055\n16.458055 0\n\nmdist->[5.35501,5.171516,0.132336,1.335303,0.043425,5.384036,0.07295,2.844008,0.661416]\nchisq->[10.056959]\nB->\n#0          #1          #2\n----------- ----------- -----------\n1250.307556 1601.627111 1805.355556\n1601.627111 2051.662722 2312.636111\n1805.355556 2312.636111 2606.805556\n\nlambda->[0.160648]\nW->\n#0       #1        #2\n-------- --------- --------\n453.968  -151.966  16.31\n-151.966 1477.6995 1008.395\n16.31    1008.395  1182.63\n\nT->\n#0          #1          #2\n----------- ----------- -----------\n1704.275556 1449.661111 1821.665556\n1449.661111 3529.362222 3321.031111\n1821.665556 3321.031111 3789.435556\n\n\nchisqdf->[3]\nP->[0.018088]\ndfW->7\neigenval->[5.224779,2.757998E-16,-1.552556E-15]\neigenvec->\n#0       #1        #2\n-------- --------- ---------\n0.099362 0.08179   0.023313\n0.029973 -0.010892 0.107448\n0.023044 -0.046981 -0.111469\n\n\ncanon->\n#0        #1        #2\n--------- --------- ---------\n2.047837  -0.369203 -2.271294\n2.969714  -1.691977 0.973456\n-2.596193 -0.071875 0.09971\n0.861618  -0.247207 0.622822\n-2.437568 -0.042299 0.088698\n2.970655  1.936238  0.521256\n-2.413867 -0.082213 0.201424\n0.165404  0.372149  0.153761\n-1.567601 0.196387  -0.389832\n```\n"
    },
    "mask": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mask.html",
        "signatures": [
            {
                "full": "mask(X, Y)",
                "name": "mask",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [mask](https://docs.dolphindb.com/en/Functions/m/mask.html)\n\n\n\n#### Syntax\n\nmask(X, Y)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n**Y** is a conditional expression that generates *true* or *false*.\n\n#### Details\n\nApply *Y* on each element of *X*. If the result is *false*, keep the element; if the result is *true*, change it to NULL. The result is of the same length as *X*.\n\n#### Examples\n\n```\nx=1..10\nmask(x, x>6);\n// output\n[1,2,3,4,5,6,,,,]\n\nm=matrix(1 2 3, 4 5 6, 7 8 9);\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 4  | 7  |\n| 2  | 5  | 8  |\n| 3  | 6  | 9  |\n\n```\nmask(m, m<6);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n|    |    | 7  |\n|    |    | 8  |\n|    | 6  | 9  |\n"
    },
    "matrix": {
        "url": "https://docs.dolphindb.com/en/Functions/m/matrix.html",
        "signatures": [
            {
                "full": "matrix(X1, [X2], ...)",
                "name": "matrix",
                "parameters": [
                    {
                        "full": "X1",
                        "name": "X1"
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": "...",
                        "name": "..."
                    }
                ]
            },
            {
                "full": "matrix(dataType, rows, cols, [columnsCapacity], [defaultValue])",
                "name": "matrix",
                "parameters": [
                    {
                        "full": "dataType",
                        "name": "dataType"
                    },
                    {
                        "full": "rows",
                        "name": "rows"
                    },
                    {
                        "full": "cols",
                        "name": "cols"
                    },
                    {
                        "full": "[columnsCapacity]",
                        "name": "columnsCapacity",
                        "optional": true
                    },
                    {
                        "full": "[defaultValue]",
                        "name": "defaultValue",
                        "optional": true
                    }
                ]
            },
            {
                "full": "matrix(X)",
                "name": "matrix",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [matrix](https://docs.dolphindb.com/en/Functions/m/matrix.html)\n\n\n\n#### Syntax\n\nmatrix(X1, \\[X2], ...)\n\nor\n\nmatrix(dataType, rows, cols, \\[columnsCapacity], \\[defaultValue])\n\nor\n\nmatrix(X)\n\n#### Arguments\n\nFor the first case: **X1**, **X2**, **...** can be data objects including vector, matrix, table (without SYMBOL columns), tuple of vectors and their combination.\n\nFor the second case:\n\n* **dataType** is the data type of the matrix. Data types other than INT128, UUID, IPADDR, POINT and DURATION are supported.\n\n* **rows** is the number of rows.\n\n* **cols** is the number of cols.\n\n* **columnsCapacity** is the amount of memory (in terms of the number of columns) allocated to the matrix. When the number of columns exceeds *columnsCapacity*, the system will first allocate memory of 1.2\\~2 times of *capacity*, copy the data to the new memory space, and release the original memory.\n\n* **defaultValue** is the default value for the elements of the matrix. Without specifying *defaultValue*, all elements in the matrix are 0s for integers/doubles and NULLs for symbols.\n\nFor the third case: **X** is an array vector ([arrayVector](https://docs.dolphindb.com/en/Programming/DataTypesandStructures/DataForms/Vector/arrayVector.html)) and each vector in *X* must be of the same length.\n\n#### Details\n\nGenerate a matrix.\n\n#### Examples\n\n```\nx=matrix(INT,3,2, ,1);\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 1  | 1  |\n| 1  | 1  |\n\n```\ny = matrix(DECIMAL32(3),2,3)\ny \n```\n\n| #0    | #1    | #2    |\n| ----- | ----- | ----- |\n| 0.000 | 0.000 | 0.000 |\n| 0.000 | 0.000 | 0.000 |\n\n```\ns=matrix(SYMBOL,2,2, ,`T);\ns;\n```\n\n| #0 | #1 |\n| -- | -- |\n| T  | T  |\n| T  | T  |\n\n```\nmatrix(table(1 2 3 as id, 4 5 6 as value));\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nmatrix([1 2 3, 4 5 6]);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nmatrix([1 2 3, 4 5 6], 7 8 9, table(0.5 0.6 0.7 as id), 1..9$3:3);\n```\n\n| #0 | #1 | #2 | #3  | #4 | #5 | #6 |\n| -- | -- | -- | --- | -- | -- | -- |\n| 1  | 4  | 7  | 0.5 | 1  | 4  | 7  |\n| 2  | 5  | 8  | 0.6 | 2  | 5  | 8  |\n| 3  | 6  | 9  | 0.7 | 3  | 6  | 9  |\n\n```\nmatrix(`AA`BB`CC,`DD`EE`FF)\n```\n\n| #0 | #1 |\n| -- | -- |\n| AA | DD |\n| BB | EE |\n| CC | FF |\n\nError occurs when converting a table with SYMBOL columns to a matrix:\n\n```\nt = table(symbol([\"a\", \"b\"]) as sym, [1, 2] as val)\nmatrix(t)\n// output: matrix(t) => Failed to append a table object to a matrix.\n```\n\nConvert SYMBOL to STRING for matrix conversion:\n\n```\nt = table(string([\"a\", \"b\"]) as sym, [1, 2] as val)\nmatrix(t)\n```\n\n| #1 | #2 |\n| -- | -- |\n| a  | 1  |\n| b  | 2  |\n\nRelated functions: [array](https://docs.dolphindb.com/en/Functions/a/array.html) and [dict](https://docs.dolphindb.com/en/Functions/d/dict.html)\n"
    },
    "matrixRank": {
        "url": "https://docs.dolphindb.com/en/Functions/m/matrixRank.html",
        "signatures": [
            {
                "full": "matrixRank(A, [tol])",
                "name": "matrixRank",
                "parameters": [
                    {
                        "full": "A",
                        "name": "A"
                    },
                    {
                        "full": "[tol]",
                        "name": "tol",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [matrixRank](https://docs.dolphindb.com/en/Functions/m/matrixRank.html)\n\n#### Syntax\n\nmatrixRank(A, \\[tol])\n\n#### Arguments\n\n**A**is a numeric matrix. One-dimensional matrices can be represented by vectors.\n\n**tol** is a numeric scalar. Singular values less than *tol*will be treated as zero, so the rank of the matrix will be the number of singular values greater than *tol*. The default value is the minimum precision of double precision floating-point numbers, DBL\\_EPSILON = 2.22044604925e-16.\n\n#### Details\n\nCalculate the rank of matrix.\n\n#### Examples\n\n```\nm1 = matrix(1..4,1..4*2,3..6)\nmatrixRank(m1) \n// output: 2\n```\n\n"
    },
    "mavg": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mavg.html",
        "signatures": [
            {
                "full": "mavg(X, window|weights, [minPeriods])",
                "name": "mavg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window|weights",
                        "name": "window|weights"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mavg](https://docs.dolphindb.com/en/Functions/m/mavg.html)\n\n\n\n#### Syntax\n\nmavg(X, window|weights, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nIf *X* is a vector, return a vector of the same length as *X*. If the second parameter is:\n\n* *window*: Calculate the moving averages of *X* in a sliding window of length *window*.\n\n* *weights*: Calculate the moving weighted averages of *X* in a sliding window of length *weights*. The length of *weights* (the weight vector) must be in \\[0,1024]. Return NULL for the first *(size(weights) - 1)* elements. The parameter *minPeriods* doesn't take effect.\n\nIf *X* is a matrix/table, conduct the aforementioned calculation within each column of *X*. The result is a matrix with the same shape as *X*.\n\n#### Examples\n\n```\nX = 7 4 6 0 -5 32 9 8;\nY = 7 4 6 NULL -5 32 9 8;\nweight = 2 3 5\n\nmavg(X, 4);\n// output\n[,,,4.25,1.25,8.25,9,11]\n\nmavg(Y, 4);\n// output\n[,,,5.67,1.67,11,12,11]\n\nmavg(Y, weight);\n// output\n[,,5.6,5.2,-1.8571,18.125,13.1,13.1]\n```\n\n```\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(2020.01.06 2020.01.07 2020.01.09 2020.01.11 2020.01.12 2020.01.15, `col1`col2)\nm.setIndexedMatrix!()\nmavg(m, 3d) // equivalent to msum(m, 3)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.01.06 | 1    | 9    |\n| 2020.01.07 | 1    | 9    |\n| 2020.01.09 | 4    |      |\n| 2020.01.11 | 4    | 10   |\n| 2020.01.12 | 8    | 10   |\n| 2020.01.15 | 6    | 2    |\n\n```\nmavg(m, 1w)\n```\n\n| label      | col1   | col2 |\n| ---------- | ------ | ---- |\n| 2020.01.06 | 1      | 9    |\n| 2020.01.07 | 1      | 9    |\n| 2020.01.09 | 2.5    | 9    |\n| 2020.01.11 | 2.5    | 9.5  |\n| 2020.01.12 | 4.3333 | 9.5  |\n| 2020.01.15 | 6      | 6    |\n\nRelated functions: [avg](https://docs.dolphindb.com/en/Functions/a/avg.html)\n"
    },
    "mavgTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mavgTopN.html",
        "signatures": [
            {
                "full": "mavgTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mavgTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mavgTopN](https://docs.dolphindb.com/en/Functions/m/mavgTopN.html)\n\n\n\n#### Syntax\n\nmavgTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the average of the first *top* elements.\n\n#### Examples\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmavgTopN(X, S, 4, 2)\n// output\n[1,1.5,2,3.5,3.5,3.5,5]\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmavgTopN(X, S, 4, 2)\n// output\n[,1,2,2.5,2.5,2.5,3]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmavgTopN(X, S, 3, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n| 1   | 6   |\n| 1.5 | 6.5 |\n| 2   | 7   |\n| 2.5 | 7.5 |\n| 4   | 9   |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmavgTopN(X, S, 3, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n| 1   |     |\n| 1.5 | 7   |\n| 2   | 7.5 |\n| 2.5 | 7.5 |\n| 4   | 8.5 |\n\nA table with columns code, date, close and volume.\n\n```\nt = table(take(`IBM`APPL, 20) as code, 2020.01.01 + 1..20 as date, rand(100,20) + 20 as volume, rand(10,20) + 100.0 as close)\n```\n\n| code | date       | volume | close |\n| ---- | ---------- | ------ | ----- |\n| IBM  | 2020.01.02 | 114    | 107   |\n| APPL | 2020.01.03 | 66     | 106   |\n| IBM  | 2020.01.04 | 36     | 106   |\n| APPL | 2020.01.05 | 52     | 101   |\n| IBM  | 2020.01.06 | 28     | 100   |\n| APPL | 2020.01.07 | 55     | 108   |\n| IBM  | 2020.01.08 | 54     | 106   |\n| APPL | 2020.01.09 | 103    | 106   |\n| IBM  | 2020.01.10 | 94     | 104   |\n| APPL | 2020.01.11 | 82     | 102   |\n| IBM  | 2020.01.12 | 98     | 103   |\n| APPL | 2020.01.13 | 118    | 101   |\n| IBM  | 2020.01.14 | 61     | 105   |\n| APPL | 2020.01.15 | 43     | 105   |\n| IBM  | 2020.01.16 | 41     | 104   |\n| APPL | 2020.01.17 | 111    | 106   |\n| IBM  | 2020.01.18 | 119    | 103   |\n| APPL | 2020.01.19 | 24     | 107   |\n| IBM  | 2020.01.20 | 22     | 109   |\n| APPL | 2020.01.21 | 26     | 103   |\n\nCalculate the average of the closing prices of the top 3 records with the highest trading volume in the window for each stock.\n\n```\nselect code, date, mavgTopN(close, volume, 5, 3, false) from t context by code\n```\n\n| code | date       | mavgTopN\\_close |\n| ---- | ---------- | --------------- |\n| APPL | 2020.01.03 | 106             |\n| APPL | 2020.01.05 | 103.5           |\n| APPL | 2020.01.07 | 105             |\n| APPL | 2020.01.09 | 106.6667        |\n| APPL | 2020.01.11 | 104.6667        |\n| APPL | 2020.01.13 | 103             |\n| APPL | 2020.01.15 | 103             |\n| APPL | 2020.01.17 | 104.3333        |\n| APPL | 2020.01.19 | 103             |\n| APPL | 2020.01.21 | 104             |\n| IBM  | 2020.01.02 | 107             |\n| IBM  | 2020.01.04 | 106.5           |\n| IBM  | 2020.01.06 | 104.3333        |\n| IBM  | 2020.01.08 | 106.3333        |\n| IBM  | 2020.01.10 | 105.6667        |\n| IBM  | 2020.01.12 | 104.3333        |\n| IBM  | 2020.01.14 | 104             |\n| IBM  | 2020.01.16 | 104             |\n| IBM  | 2020.01.18 | 103.3333        |\n| IBM  | 2020.01.20 | 103.6667        |\n\nRelated function: [mavg](https://docs.dolphindb.com/en/Functions/m/mavg.html)\n"
    },
    "max": {
        "url": "https://docs.dolphindb.com/en/Functions/m/max.html",
        "signatures": [
            {
                "full": "max(X)",
                "name": "max",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [max](https://docs.dolphindb.com/en/Functions/m/max.html)\n\n\n\n#### Syntax\n\nmax(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n**Y** (optional) is a scalar, a vector of the same length as *X* or a matrix.\n\n#### Details\n\nFor one input:\n\n* If *X* is a vector, return the maximum in *X*.\n\n* If *X* is a matrix, return a vector composed of the maximum in each column of *X*.\n\n* If *X* is a table, return a table composed of the maximum in each column of *X*.\n\nFor two inputs:\n\n* If *Y* is a scalar, compare it with each element in *X*, replace the element in *X* with the larger value.\n\n* If *Y* and *X* are of the same type and length, compare the corresponding elements of them and return a result containing each larger value.\n\n**Note:**\n\nBefore version 1.30.20/2.00.8, the function `max` compares the values of temporal types by converting them into LONG values;\n\nSince version 1.30.20/2.00.8, DolphinDB has changed the handling of temporal types:\n\n* If *X* and *Y* are temporal scalars with different levels of time granularity, the coarser-grained value is converted to the finer granularity for comparison.\n\n* If *X* and/or *Y* is a vector, matrix, or table, the compared elements must be of the same temporal type.\n\n#### Examples\n\n```\nmax(1 2 3);\n// output\n3\n\nmax(7.8 9 5.4);\n// output\n9\n\n(5 8 2 7).max();\n// output\n8\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nmax(m);\n// output\n[3,6]\n```\n\n```\nmax(1 2 3, 2)\n// output\n2 2 3\n\nn = matrix(1 1 1, 5 5 5)\nn;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 1  | 5  |\n| 1  | 5  |\n\n```\nmax(m, n);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 2  | 5  |\n| 3  | 6  |\n\nUse with SQL SELECT to return the maximum value of a column:\n\n```\nt = table(`abb`aac`aaa as sym, 1.8 2.3 3.7 as price);\nselect max price from t;\n```\n\n| max\\_price |\n| ---------- |\n| 3.7        |\n\n`max` can be applied to strings to return the lexicographically largest string:\n\n```\nselect max sym from t;\n```\n\n| max\\_sym |\n| -------- |\n| abb      |\n\nRelated function: [mmax](https://docs.dolphindb.com/en/Functions/m/mmax.html)\n"
    },
    "maxIgnoreNull": {
        "url": "https://docs.dolphindb.com/en/Functions/m/maxIgnoreNull.html",
        "signatures": [
            {
                "full": "maxIgnoreNull(X, Y)",
                "name": "maxIgnoreNull",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [maxIgnoreNull](https://docs.dolphindb.com/en/Functions/m/maxIgnoreNull.html)\n\n#### Syntax\n\nmaxIgnoreNull(X, Y)\n\n#### Arguments\n\n**X** and **Y** can be a numeric, LITERAL or TEMPORAL scalar, pair, vector or matrix.\n\n#### Details\n\nA binary scalar function that returns the maximum by comparing *X* with *Y*.\n\nDifference between `max` and `maxIgnoreNull`:\n\n* `max`: NULL is treated as the minimum value if \\*nullAsMinValueForComparison=\\*true, otherwise comparison involving NULL returns NULL.\n\n* `maxIgnoreNull`: NULL is ignored in comparison and non-NULL maximum is returned. If both elements in *X* and *Y* are NULL, NULL is returned. This function is not affected by configuration parameter *nullAsMinValueForComparison*.\n\n#### Examples\n\n```\nmaxIgnoreNull(2,matrix(1  NULL 4,-1 4  0)) \n```\n\n| #0 | #1 |\n| -- | -- |\n| 2  | 2  |\n| 2  | 4  |\n| 4  | 2  |\n\n```\nmaxIgnoreNull(matrix(10 3 NULL, 1 7 4),matrix(1  NULL 4,-1 4  0))\n```\n\n<table id=\"table_slz_glq_3bc\"><tbody><tr><td>\n\n\\#0\n\n</td><td>\n\n\\#1\n\n</td></tr><tr><td>\n\n10\n\n</td><td>\n\n1\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n7\n\n</td></tr><tr><td>\n\n-4\n\n</td><td>\n\n4\n\n</td></tr></tbody>\n</table>Use `minIgnoreNull` with `reduce` to calculate the minimum for matrices of the same shape stored in a tuple:\n\n```\nn1 = matrix(1 1 1, 5 5 5)\nn2 = matrix(10 11 12, 0 NULL -5)\nn3 = matrix(-1 1 NULL, -3 0 10)\nreduce(minIgnoreNull, [n1,n2,n3])\n```\n\n| #0 | #1 |\n| -- | -- |\n| 10 | 5  |\n| 11 | 5  |\n| 12 | 10 |\n\n**Related function**: [minIgnoreNull](https://docs.dolphindb.com/en/Functions/m/minIgnoreNull.html)\n\n"
    },
    "maxPositiveStreak": {
        "url": "https://docs.dolphindb.com/en/Functions/m/maxPositiveStreak.html",
        "signatures": [
            {
                "full": "maxPositiveStreak(X)",
                "name": "maxPositiveStreak",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [maxPositiveStreak](https://docs.dolphindb.com/en/Functions/m/maxPositiveStreak.html)\n\n\n\n#### Syntax\n\nmaxPositiveStreak(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nIf *X* is a vector: return the maximum value of of the sum of consecutive positive elements of *X*.\n\nIf *X* is a matrix, return the maximum value of of the sum of consecutive positive elements in each column of *X*.\n\n`maxPositiveStreak(X)` = `max(cumPositiveStreak(X))`\n\n#### Examples\n\n```\nx=1 0 -1 1 2 2 2 1 0 -1 0 2;\ncumPositiveStreak x;\n// output\n[1,0,0,1,3,5,7,8,0,0,0,2]\nmaxPositiveStreak x;\n// output\n8\n\ny=x$6:2;\ny;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 2  |\n| 0  | 1  |\n| -1 | 0  |\n| 1  | -1 |\n| 2  | 0  |\n| 2  | 2  |\n\n```\ncumPositiveStreak(y);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 2  |\n| 0  | 3  |\n| 0  | 0  |\n| 1  | 0  |\n| 3  | 0  |\n| 5  | 2  |\n\n```\nmaxPositiveStreak(y);\n// output\n[5,3]\n```\n\nRelated function: [cumPositiveStreak](https://docs.dolphindb.com/en/Functions/c/cumPositiveStreak.html)\n"
    },
    "mbeta": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mbeta.html",
        "signatures": [
            {
                "full": "mbeta(Y, X, window, [minPeriods])",
                "name": "mbeta",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mbeta](https://docs.dolphindb.com/en/Functions/m/mbeta.html)\n\n\n\n#### Syntax\n\nmbeta(Y, X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the coefficient estimate of an ordinary-least-squares regression of *Y* on *X* in a sliding window.\n\n#### Examples\n\n```\nx=0.011 0.006 -0.008 0.012 -0.016 -0.023 0.018\ny=0.016 0.009 -0.012 0.022 0.003 -0.056 0.002\nmbeta(y, x, 5);\n// output\n[,,,,0.818182,1.692379,1.188532]\n\nmbeta(y, x, 5, 3);\n// output\n[,,1.479381,1.594701,0.818182,1.692379,1.188532]\n```\n\n```\nx1 = indexedSeries(date(2020.06.05)+1..7, x)\ny1 = indexedSeries(date(2020.06.05)+1..7, y)\nmbeta(y1, x1, 5d);\n```\n\n| label      | col1   |\n| ---------- | ------ |\n| 2020.06.06 |        |\n| 2020.06.07 | 1.4    |\n| 2020.06.08 | 1.4794 |\n| 2020.06.09 | 1.5947 |\n| 2020.06.10 | 0.8182 |\n| 2020.06.11 | 1.6924 |\n| 2020.06.12 | 1.1885 |\n\n```\nmbeta(y1, x1, 1w);\n```\n\n| label      | col1   |\n| ---------- | ------ |\n| 2020.06.06 |        |\n| 2020.06.07 | 1.4    |\n| 2020.06.08 | 1.4794 |\n| 2020.06.09 | 1.5947 |\n| 2020.06.10 | 0.8182 |\n| 2020.06.11 | 1.6924 |\n| 2020.06.12 | 1.2659 |\n\nRelated function: [beta](https://docs.dolphindb.com/en/Functions/b/beta.html)\n"
    },
    "mbetaTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mbetaTopN.html",
        "signatures": [
            {
                "full": "mbetaTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mbetaTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mbetaTopN](https://docs.dolphindb.com/en/Functions/m/mbetaTopN.html)\n\n\n\n#### Syntax\n\nmbetaTopN(X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the coefficient estimate ordinary-least-squares regressions of *Y* on *X*.\n\n#### Examples\n\n```\nx = NULL 3 8 4 0\ny = 2 3 1 7 3\ns = 5 NULL 8 9 4\nmbetaTopN(x, y, s, 3, 2)\n// output\n[ , , , -0.66, -4]\n\ns2=2021.01.01 2021.02.03 2021.01.23 2021.04.06 2021.12.29\nmbetaTopN(x, y, s2, 3, 2)\n// output\n[ , , , -2.5, -0.6667]\n\nx1 = matrix(x, 4 3 6 2 3)\ny1=matrix(3 7 9 3 2, y)\ns1=matrix(2 3 1 7 3, s)\n\nmbetaTopN(x, y1, s1, 3, 2)\n```\n\n| col1   | col2 |\n| ------ | ---- |\n|        |      |\n|        |      |\n|        |      |\n| 2.5    | -2.5 |\n| 1.1429 | -4   |\n\n```\nmbetaTopN(x1, y1, s, 3, 2)\n```\n\n| col1   | col2 |\n| ------ | ---- |\n|        |      |\n|        | -1   |\n|        | -1   |\n| 2.5    | -1.5 |\n| 1.1429 | -1.5 |\n\n```\nn = 3000\nids = 1..3000\ndates = take(2021.01.01..2021.10.01,n)\nprices = rand(1000,n)\nvals = rand(1000,n)\nt = table(ids as id,dates as date,prices as price,vals as val)\ndbName = \"dfs://test_mbetaTopN_2\"\nif(existsDatabase(dbName))dropDB(dbName)\ndb = database(dbName,VALUE,1..5000)\npt = db.createPartitionedTable(t,\"pt\",`id).append!(t)\nselect mbetaTopN(price, val, id, 10, 5, true) from pt where date>2021.05.01\n```\n\nRelated function: [mbeta](https://docs.dolphindb.com/en/Functions/m/mbeta.html)\n"
    },
    "mcorr": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mcorr.html",
        "signatures": [
            {
                "full": "mcorr(X, Y, window, [minPeriods])",
                "name": "mcorr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mcorr](https://docs.dolphindb.com/en/Functions/m/mcorr.html)\n\n\n\n#### Syntax\n\nmcorr(X, Y, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the correlation of *X* and *Y* in a sliding window.\n\n#### Examples\n\n```\nx=1..8\ny=9 5 3 4 5 4 7 1\nmcorr(x,y,5);\n// output\n[,,,,-0.624038,0,0.834058,-0.29173]\n\nmcorr(x,y,5,3);\n// output\n[,,-0.981981,-0.834497,-0.624038,0,0.834058,-0.29173]\n\nx1 = indexedSeries(date(2020.06.05)+1..8, x)\ny1 = indexedSeries(date(2020.06.05)+1..6 join 2020.06.15 join 2020.06.16, y)\nmcorr(x1,y1,5d)\n```\n\n| label      | col1    |\n| ---------- | ------- |\n| 2020.06.06 |         |\n| 2020.06.07 | -1      |\n| 2020.06.08 | -0.982  |\n| 2020.06.09 | -0.8345 |\n| 2020.06.10 | -0.624  |\n| 2020.06.11 | 0       |\n| 2020.06.12 | 0.6325  |\n| 2020.06.13 | 0       |\n\n```\nmcorr(x1,y1,1w)\n```\n\n| label      | col1    |\n| ---------- | ------- |\n| 2020.06.06 |         |\n| 2020.06.07 | -1      |\n| 2020.06.08 | -0.982  |\n| 2020.06.09 | -0.8345 |\n| 2020.06.10 | -0.624  |\n| 2020.06.11 | -0.6116 |\n| 2020.06.12 | -0.6116 |\n| 2020.06.13 | 0       |\n\nRelated functions: [corr](https://docs.dolphindb.com/en/Functions/c/corr.html), [mmin](https://docs.dolphindb.com/en/Functions/m/mmin.html), [mmax](https://docs.dolphindb.com/en/Functions/m/mmax.html), [mavg](https://docs.dolphindb.com/en/Functions/m/mavg.html), [msum](https://docs.dolphindb.com/en/Functions/m/msum.html), [mstd](https://docs.dolphindb.com/en/Functions/m/mstd.html), [mvar](https://docs.dolphindb.com/en/Functions/m/mvar.html)\n"
    },
    "mcorrTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mcorrTopN.html",
        "signatures": [
            {
                "full": "mcorrTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mcorrTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mcorrTopN](https://docs.dolphindb.com/en/Functions/m/mcorrTopN.html)\n\n\n\n#### Syntax\n\nmcorrTopN(X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the moving correlation of the first *top* pairs of elements in *X* and *Y*.\n\n#### Examples\n\n```\na =  2 5 3 1 9\nb = 2 3 1 7 13\ns = 6 8 4 2 7\n\nmcorrTopN(a, b, s, 4, 3)\n// output\n[ , 1, 0.6547, -0.9333, 0.7206]\n\ns2=2021.01.01 2021.02.03 2021.01.23 2021.04.06 2021.12.29\nmcorrTopN(a, b, s2, 4, 3)\n// output\n[ , 1, 0.6547, 0.6547, -0.6547]\n\na1 = matrix(a, 4 3 6 2 3)\nb1=matrix(3 7 9 3 2, b)\ns1=matrix(2 3 1 7 3, s)\nmcorrTopN(a, b1, s1, 4, 3)\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n| 1       | 1       |\n| 0.5     | 0.6547  |\n| 0.5     | -0.9333 |\n| -0.9986 | 0.7206  |\n\n```\nmcorrTopN(a1, b1, s, 4, 3)\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n| 1       | -1      |\n| 0.5     | -0.982  |\n| 0.866   | -0.9333 |\n| -0.4018 | -0.7206 |\n\n```\nmcorrTopN(a1, b1, s1, 4, 3)\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n| 1       | -1      |\n| 0.5     | -0.982  |\n| 0.5     | -0.9333 |\n| -0.9986 | -0.7206 |\n\n```\nn = 3000\nids = 1..3000\ndates = take(2021.01.01..2021.10.01,n)\nprices = rand(1000,n)\nvals = rand(1000,n)\nt = table(ids as id,dates as date,prices as price,vals as val)\ndbName = \"dfs://test_mcorrTopN_2\"\nif(existsDatabase(dbName))dropDB(dbName)\ndb = database(dbName,VALUE,1..5000)\npt = db.createPartitionedTable(t,\"pt\",`id).append!(t)\nselect mcorrTopN(price, val, id, 10, 5, true) from pt where date>2021.05.01\n```\n\nRelated function: [mcorr](https://docs.dolphindb.com/en/Functions/m/mcorr.html)\n"
    },
    "mcount": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mcount.html",
        "signatures": [
            {
                "full": "mcount(X, window, [minPeriods=1])",
                "name": "mcount",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods=1]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [mcount](https://docs.dolphindb.com/en/Functions/m/mcount.html)\n\n\n\n#### Syntax\n\nmcount(X, window, \\[minPeriods=1])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nReturn the number of non-NULL values of *X* in a sliding window.\n\n#### Examples\n\n```\nx = 7 4 5 8 9;\nmcount(x, 3);\n// output: [1,2,3,3,3]\n\nmcount(x, 3, minPeriods=2);\n// output: [,2,3,3,3]\n\nx1 =1 2 3 NULL 5;\nmcount(x1, 3);\n// output: [1,2,3,2,2]\n\nmcount(x1, 3, minPeriods=3);\n// output: [,,3,,]\n\nm=matrix(1 2 NULL 4 5, 6 7 8 9 NULL);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 6  |\n| 2  | 7  |\n|    | 8  |\n| 4  | 9  |\n| 5  |    |\n\n```\nmcount(m,3);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 2  | 2  |\n| 2  | 3  |\n| 2  | 3  |\n| 2  | 2  |\n\n```\ns=indexedSeries(date(2020.05.26)+1..8, 3 4 9 NULL 4 6 NULL 8)\nmcount(s,4d)\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2020.05.27 | 1    |\n| 2020.05.28 | 2    |\n| 2020.05.29 | 3    |\n| 2020.05.30 | 3    |\n| 2020.05.31 | 3    |\n| 2020.06.01 | 3    |\n| 2020.06.02 | 2    |\n| 2020.06.03 | 3    |\n\n```\nmcount(s,1w)\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2020.05.27 | 1    |\n| 2020.05.28 | 2    |\n| 2020.05.29 | 3    |\n| 2020.05.30 | 3    |\n| 2020.05.31 | 4    |\n| 2020.06.01 | 5    |\n| 2020.06.02 | 5    |\n| 2020.06.03 | 5    |\n\nRelated functions: [count](https://docs.dolphindb.com/en/Functions/c/count.html)\n"
    },
    "mcovar": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mcovar.html",
        "signatures": [
            {
                "full": "mcovar(X, Y, window, [minPeriods])",
                "name": "mcovar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mcovar](https://docs.dolphindb.com/en/Functions/m/mcovar.html)\n\n\n\n#### Syntax\n\nmcovar(X, Y, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving covariance of *X* and *Y* in a sliding window.\n\n#### Examples\n\n```\nx=1..10;\ny=9 5 3 4 5 4 7 1 3 4;\nmcovar(x,y,5);\n// output\n[,,,,-2.25,0,2,-1,-1.75,-1]\n\nmcovar(x, y, 5, 3);\n// output\n[,,-3,-2.833333,-2.25,0,2,-1,-1.75,-1]\n\nx1 = indexedSeries(date(2020.06.05)+1..10, x)\ny1 = indexedSeries(date(2020.06.05)+1..10, y)\nmcovar(x1,y1,5d)\n```\n\n| label      | col1    |\n| ---------- | ------- |\n| 2020.06.06 |         |\n| 2020.06.07 | -2      |\n| 2020.06.08 | -3      |\n| 2020.06.09 | -2.8333 |\n| 2020.06.10 | -2.25   |\n| 2020.06.11 | 0       |\n| 2020.06.12 | 2       |\n| 2020.06.13 | -1      |\n| 2020.06.14 | -1.75   |\n| 2020.06.15 | -1      |\n\n```\nmcovar(x1,y1,1w)\n```\n\n| label      | col1    |\n| ---------- | ------- |\n| 2020.06.06 |         |\n| 2020.06.07 | -2      |\n| 2020.06.08 | -3      |\n| 2020.06.09 | -2.8333 |\n| 2020.06.10 | -2.25   |\n| 2020.06.11 | -2.4    |\n| 2020.06.12 | -1      |\n| 2020.06.13 | -0.6667 |\n| 2020.06.14 | -0.6667 |\n| 2020.06.15 | -1.6667 |\n\nRelated functions: [covar](https://docs.dolphindb.com/en/Functions/c/covar.html), [mcorr](https://docs.dolphindb.com/en/Functions/m/mcorr.html), [mstd](https://docs.dolphindb.com/en/Functions/m/mstd.html), [mvar](https://docs.dolphindb.com/en/Functions/m/mvar.html)\n"
    },
    "mcovarTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mcovarTopN.html",
        "signatures": [
            {
                "full": "mcovarTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mcovarTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mcovarTopN](https://docs.dolphindb.com/en/Functions/m/mcovarTopN.html)\n\n\n\n#### Syntax\n\nmcovarTopN(X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the moving covariance of the first *top* pairs of elements in *X* and *Y*.\n\n#### Examples\n\n```\nx = NULL 3 8 4 0\ny = 2 3 1 7 3\ns = 5 NULL 8 9 4\n\nmcovarTopN(x, y, s, 3, 2)\n// output\n[ , , , -12, -8]\n\ns2=2021.01.01 2021.02.03 2021.01.23 2021.04.06 2021.12.29\nmcovarTopN(x, y, s2, 3, 2)\n// output\n[ , , , -5, -12]\n\nx1 = matrix(x, 4 3 6 2 3)\ny1=matrix(3 7 9 3 2, y)\ns1=matrix(2 3 1 7 3, s)\n\nmcovarTopN(x, y1, s1, 3, 2)\n```\n\n| col1 | col2 |\n| ---- | ---- |\n|      |      |\n|      |      |\n|      |      |\n| 5    | -5   |\n| 28   | -8   |\n\n```\nmcovarTopN(x1, y1, s, 3, 2)\n```\n\n| col1 | col2 |\n| ---- | ---- |\n|      |      |\n|      | -0.5 |\n|      | -0.5 |\n| 5    | -3   |\n| 28   | -3   |\n\n```\nmcovarTopN(x1, y1, s1, 3, 2)\n```\n\n| col1 | col2 |\n| ---- | ---- |\n|      |      |\n|      | -0.5 |\n|      | -0.5 |\n| 5    | -3   |\n| 28   | -3   |\n\n```\nn = 3000\nids = 1..3000\ndates = take(2021.01.01..2021.10.01,n)\nprices = rand(1000,n)\nvals = rand(1000,n)\nt = table(ids as id,dates as date,prices as price,vals as val)\ndbName = \"dfs://test_mcovarTopN_2\"\nif(existsDatabase(dbName))dropDB(dbName)\ndb = database(dbName,VALUE,1..5000)\npt = db.createPartitionedTable(t,\"pt\",`id).append!(t)\nselect mcovarTopN(price, val, id, 10, 5, true) from pt where date>2021.05.01\n```\n\nRelated function: [mcovar](https://docs.dolphindb.com/en/Functions/m/mcovar.html)\n"
    },
    "md5": {
        "url": "https://docs.dolphindb.com/en/Functions/m/md5.html",
        "signatures": [
            {
                "full": "md5(X)",
                "name": "md5",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [md5](https://docs.dolphindb.com/en/Functions/m/md5.html)\n\n\n\n#### Syntax\n\nmd5(X)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n#### Details\n\nCreate an MD5 hash from STRING. The result is of data type INT128.\n\n#### Examples\n\n```\na=md5(`e`f);\na;\n// output\n[e1671797c52e15f763380b45e841ec32,8fa14cdd754f91cc6554c9e71929cce7]\n\ntypestr(a);\n// output\nINT128\n```\n"
    },
    "mean": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mean.html",
        "signatures": [
            {
                "full": "mean(X)",
                "name": "mean",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [mean](https://docs.dolphindb.com/en/Functions/m/mean.html)\n\n\n\n#### Syntax\n\nmean(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nCalculate the average of *X*.\n\n* If *X* is a matrix, calculate the average of each column and return a vector.\n\n* If *X* is a table, calculate the average of each column and return a table.\n\nThis function is equivalent to [avg](https://docs.dolphindb.com/en/Functions/a/avg.html).\n\nThe calculation skips NULL values.\n\n#### Examples\n\n```\nx=1 5 9;\nmean(x);\n// output\n5\n\nx=1 5 9 NULL;\nmean(x);\n// output\n5\n\navg(x);\n// output\n5\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nmean(m);\n// output\n[2,5]\n```\n\nRelated center data tendency functions: [mode](https://docs.dolphindb.com/en/Functions/m/mode.html), [med](https://docs.dolphindb.com/en/Functions/m/med.html)\n"
    },
    "med": {
        "url": "https://docs.dolphindb.com/en/Functions/m/med.html",
        "signatures": [
            {
                "full": "med(X)",
                "name": "med",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [med](https://docs.dolphindb.com/en/Functions/m/med.html)\n\n\n\n#### Syntax\n\nmed(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nIf *X* is a vector, return the median of all the elements in *X*.\n\nIf *X* is a matrix, calculate the median of each column of *X* and return a vector.\n\nAs with all aggregate functions, NULL values are not included in the calculation.\n\nPlease note that the data type of the result is always DOUBLE.\n\n#### Examples\n\n```\nx=3 6 1 5 9;\nmed x;\n// output\n5\n\nm=matrix(1 2 10, 4 5 NULL);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 10 |    |\n\n```\nmed m;\n// output\n[2,4.5]\n```\n\nRelated center data tendency functions: [mean](https://docs.dolphindb.com/en/Functions/m/mean.html) and [mode](https://docs.dolphindb.com/en/Functions/m/mode.html)\n"
    },
    "mem": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mem.html",
        "signatures": [
            {
                "full": "mem([freeUnusedBlocks=false])",
                "name": "mem",
                "parameters": [
                    {
                        "full": "[freeUnusedBlocks=false]",
                        "name": "freeUnusedBlocks",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [mem](https://docs.dolphindb.com/en/Functions/m/mem.html)\n\n\n\n#### Syntax\n\nmem(\\[freeUnusedBlocks=false])\n\n#### Arguments\n\n**freeUnusedBlocks** is a Boolean value indicating whether to free unused memory blocks. The default value is false.\n\n#### Details\n\nDisplay the memory usage of the current node. If *freeUnusedBlocks*=true, free unused memory blocks.\n\n#### Examples\n\n```\nundef all;\nt1=table(1 2 3 as a, `x`y`z as b, 10.8 7.6 3.5 as c)\nmem();\n```\n\n| blockSize | freeSize | freeBlock | leafSize |\n| --------- | -------- | --------- | -------- |\n| 37748736  | 37616400 | 15        | 144      |\n| 67108864  | 66494464 | 8117      | 8192     |\n\n```\nx=bigarray(int,100000,10000000)\nmem();\n```\n\n| blockSize | freeSize  | freeBlock | leafSize |\n| --------- | --------- | --------- | -------- |\n| 536879104 | 532684736 | 7         | 1048592  |\n| 37748736  | 37618848  | 13        | 144      |\n| 67108864  | 66994176  | 8178      | 8192     |\n\n```\nundef all;\nmem();\n```\n\n| blockSize | freeSize | freeBlock | leafSize |\n| --------- | -------- | --------- | -------- |\n| 37748736  | 37619424 | 14        | 144      |\n| 67108864  | 66994176 | 8178      | 8192     |\n"
    },
    "member": {
        "url": "https://docs.dolphindb.com/en/Functions/m/member.html",
        "signatures": [
            {
                "full": "member(X, Y)",
                "name": "member",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [member](https://docs.dolphindb.com/en/Functions/m/member.html)\n\n\n\n#### Syntax\n\nmember(X, Y) or X.Y\n\n#### Arguments\n\n**X** is a table/dictionary.\n\n**Y** is a member/attribute of *X*.\n\n#### Details\n\nReturn the specified member/attribute of an object.\n\n#### Examples\n\n```\nx=1 2 3\ny=4 5 6\nt=table(x,y);\n\nt.x;\n// output\n[1,2,3]\nt.y;\n// output\n[4,5,6]\n\nt.rows();\n// output\n3\nt.cols();\n// output\n2\nt.size();\n// output\n3\n// a table's size is defined as the number of its rows\n\nd = dict(1 2 3, 4 5 6);\nd;\n// output\n3->6\n1->4\n2->5\n\nd.2;\n// output\n5\n```\n\nSince version 2.00.11.1/1.30.23.1, a line break can be introduced before any member access operators (.) to continue the call on the next line.\n\n```\nt = table(take(1..5,10) as a, take(6..10,10) as b, take(1..2,10) as c)\n\nt.replaceColumn!(\"a\",lpad(string(t.a),6,\"0\"))\n     .replaceColumn!(\"b\",rpad(string(t.b),6,\"0\")).add(100)\n```\n"
    },
    "memSize": {
        "url": "https://docs.dolphindb.com/en/Functions/m/memSize.html",
        "signatures": [
            {
                "full": "memSize(obj)",
                "name": "memSize",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    }
                ]
            }
        ],
        "markdown": "### [memSize](https://docs.dolphindb.com/en/Functions/m/memSize.html)\n\n\n\n#### Syntax\n\nmemSize(obj)\n\n#### Arguments\n\n**obj** is an object.\n\n#### Details\n\nReturn the memory usage (in units of bytes) of a local or shared object.\n\n#### Examples\n\n```\nn=100\nID=rand(100, n)\ndate=rand(2017.08.07..2017.08.11, n)\nx=rand(10.0, n)\nt=table(ID, date, x);\nshare t as tt\nmemSize(t)\n// output\n1952\nmemSize(tt)\n// output\n1952\nmemSize(t[`x])\n// output\n800\nmemSize(select avg(x) as avgx from t)\n// output\n280\n```\n\nRelated functions: [objs](https://docs.dolphindb.com/en/Functions/o/objs.html)\n"
    },
    "merge": {
        "url": "https://docs.dolphindb.com/en/Functions/m/merge.html",
        "signatures": [
            {
                "full": "merge(left, right, [how='inner'])",
                "name": "merge",
                "parameters": [
                    {
                        "full": "left",
                        "name": "left"
                    },
                    {
                        "full": "right",
                        "name": "right"
                    },
                    {
                        "full": "[how='inner']",
                        "name": "how",
                        "optional": true,
                        "default": "'inner'"
                    }
                ]
            }
        ],
        "markdown": "### [merge](https://docs.dolphindb.com/en/Functions/m/merge.html)\n\n\n\n#### Syntax\n\nmerge(left, right, \\[how='inner'])\n\n#### Arguments\n\n**left** and **right** are both indexed series, or are both indexed matrices.\n\n**how** is a string indicating how to merge *left* and *right*. It can take the value of 'inner', 'outer', 'left', 'right', or 'asof'. The default value is 'inner'.\n\n#### Details\n\nMerge 2 indexed series or 2 indexed matrices.\n\n#### Examples\n\n```\na = indexedSeries(2012.01.01..2012.01.04, 1..4)\nb = indexedSeries([2012.01.01, 2012.01.03, 2012.01.05, 2012.01.06], 5..8)\nmerge(a, b);\n```\n\n|            | series1 | series2 |\n| ---------- | ------- | ------- |\n| 2012.01.01 | 1       | 5       |\n| 2012.01.03 | 3       | 6       |\n\n```\nmerge(a, b, 'left');\n```\n\n|            | series1 | series2 |\n| ---------- | ------- | ------- |\n| 2012.01.01 | 1       | 5       |\n| 2012.01.02 | 2       |         |\n| 2012.01.03 | 3       | 6       |\n| 2012.01.04 | 4       |         |\n\n```\nm1 = matrix([1.2, 7.8, 4.6, 5.1, 9.5], [0.15, 1.26, 0.45, 1.02, 0.33]).rename!([2012.01.01, 2015.02.01, 2015.03.01, 2015.04.01, 2015.05.01], `x1`x2).setIndexedMatrix!()\nm2 = matrix([1.0, 2.0, 3.0, 4.0], [0.14, 0.26, 0.35, 0.48]).rename!([2015.02.01, 2015.02.16, 2015.05.01, 2015.05.02], `y1`y2).setIndexedMatrix!()\nm = merge(m1, m2, 'asof');\n```\n\n|            | x1  | x2   | y1 | y2   |\n| ---------- | --- | ---- | -- | ---- |\n| 2012.01.01 | 1.2 | 0.15 |    |      |\n| 2015.02.01 | 7.8 | 1.26 | 1  | 0.14 |\n| 2015.03.01 | 4.6 | 0.45 | 2  | 0.26 |\n| 2015.04.01 | 5.1 | 1.02 | 2  | 0.26 |\n| 2015.05.01 | 9.5 | 0.33 | 3  | 0.35 |\n"
    },
    "mfirst": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mfirst.html",
        "signatures": [
            {
                "full": "mfirst(X, window, [minPeriods])",
                "name": "mfirst",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mfirst](https://docs.dolphindb.com/en/Functions/m/mfirst.html)\n\n\n\n#### Syntax\n\nmfirst(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nReturn the first element of *X* in a sliding window.\n\n#### Examples\n\n```\nindex = second(08:20:00)+1..7\nx = 2 1 3 NULL 6 5 4\nx = index.indexedSeries(x)\nmfirst(x,3s)\n```\n\n| label    | col1 |\n| -------- | ---- |\n| 08:20:01 | 2    |\n| 08:20:02 | 2    |\n| 08:20:03 | 2    |\n| 08:20:04 | 1    |\n| 08:20:05 | 3    |\n| 08:20:06 |      |\n| 08:20:07 | 6    |\n\n```\nm = matrix(1 5 9 0 2, 9 10 2 NULL 2)\nm.rename!((date(2020.09.08)+1..3) join 2020.09.16 join 2020.09.26, `A`B)\nm.setIndexedMatrix!()\nmfirst(m, 3d)\n```\n\n| label      | A | B |\n| ---------- | - | - |\n| 2020.09.09 | 1 | 9 |\n| 2020.09.10 | 1 | 9 |\n| 2020.09.11 | 1 | 9 |\n| 2020.09.16 | 0 |   |\n| 2020.09.26 | 2 | 2 |\n\n```\nmfirst(m, 1w)\n```\n\n| label      | A | B  |\n| ---------- | - | -- |\n| 2020.09.09 | 1 | 9  |\n| 2020.09.10 | 1 | 9  |\n| 2020.09.11 | 1 | 9  |\n| 2020.09.16 | 5 | 10 |\n| 2020.09.26 | 2 | 2  |\n\nRelated functions: [first](https://docs.dolphindb.com/en/Functions/f/first.html), [last](https://docs.dolphindb.com/en/Functions/l/last.html)\n"
    },
    "mfirstNot": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mfirstNot.html",
        "signatures": [
            {
                "full": "mfirstNot(X, window, [k=NULL], [minPeriods=1])",
                "name": "mfirstNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[k=NULL]",
                        "name": "k",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[minPeriods=1]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [mfirstNot](https://docs.dolphindb.com/en/Functions/m/mfirstNot.html)\n\n#### Syntax\n\nmfirstNot(X, window, \\[k=NULL], \\[minPeriods=1])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**k** (optional) is a numeric or string scalar indicating the value to be matched.\n\n#### Details\n\nIf *X* is a vector:\n\n* If *k* is not specified, return the first element of *X* that is not NULL in a sliding window.\n\n* If *k* is specified, return the first element of *X* that is neither *k* nor NULL in the window.\n\nIf *X* is a matrix or table, conduct the aforementioned calculation within each column of *X*. The result is a vector.\n\n#### Examples\n\n```\nmfirstNot(NULL 2 NULL 4 5, window=2)\n// output: [,2,2,4,4]\n```\n\n```\nx = matrix(1..5,2..6,3..7)\nmfirstNot(X=x, window=3, k=1, minPeriods=2)\n```\n\n<table id=\"table_amg_5bd_jbc\"><thead><tr><th>\n\n\\#0\n\n</th><th>\n\n\\#1\n\n</th><th>\n\n\\#2\n\n</th></tr></thead><tbody><tr><td>\n\n</td><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n2\n\n</td><td>\n\n3\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n2\n\n</td><td>\n\n3\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n3\n\n</td><td>\n\n4\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n4\n\n</td><td>\n\n5\n\n</td></tr></tbody>\n</table>```\nx=table([\"s1\", \"s2\", \"\", \"s4\", \"s5\"] as col1, [\"s1\", \"\", \"s3\", \"\", \"s5\"] as col2)\nmfirstNot(X=x, window=2)\n```\n\n<table id=\"table_fmg_5bd_jbc\"><thead><tr><th>\n\n\\#0\n\n</th><th>\n\n\\#1\n\n</th></tr></thead><tbody><tr><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\ns1\n\n</td><td>\n\ns1\n\n</td></tr><tr><td>\n\ns2\n\n</td><td>\n\ns3\n\n</td></tr><tr><td>\n\ns4\n\n</td><td>\n\ns3\n\n</td></tr><tr><td>\n\ns4\n\n</td><td>\n\ns5\n\n</td></tr></tbody>\n</table>```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07, 2022.01.08, 2022.01.10, 2022.01.11]\nX = 1..8\nX1 = indexedSeries(T, X)\nmfirstNot(X=X1, window=3, k=1, minPeriods=1)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2022.01.01 |    |\n| 2022.01.02 | 2  |\n| 2022.01.03 | 2  |\n| 2022.01.06 | 4  |\n| 2022.01.07 | 4  |\n| 2022.01.08 | 4  |\n| 2022.01.10 | 6  |\n| 2022.01.11 | 7  |\n\nRelated function: [mfirst](https://docs.dolphindb.com/en/Functions/m/mfirst.html), [mlastNot](https://docs.dolphindb.com/en/Functions/m/mlastNot.html)\n\n"
    },
    "microsecond": {
        "url": "https://docs.dolphindb.com/en/Functions/m/microsecond.html",
        "signatures": [
            {
                "full": "microsecond(X)",
                "name": "microsecond",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [microsecond](https://docs.dolphindb.com/en/Functions/m/microsecond.html)\n\n\n\n#### Syntax\n\nmicrosecond(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type TIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP.\n\n#### Details\n\nFor each element in *X*, return a number from 0 to 999999 indicating which microsecond of the second it falls in.\n\n#### Examples\n\n```\nmicrosecond(13:30:10.008);\n// output\n8000\n\nmicrosecond([2012.12.03 01:22:01.999999000, 2012.12.03 01:22:01.000456000, 2012.12.03 01:25:08.000000234]);\n// output\n[999999,456,0]\n```\n\nRelated functions: [dayOfYear](https://docs.dolphindb.com/en/Functions/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.com/en/Functions/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.com/en/Functions/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.com/en/Functions/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.com/en/Functions/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.com/en/Functions/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.com/en/Functions/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.com/en/Functions/m/millisecond.html), [nanosecond](https://docs.dolphindb.com/en/Functions/n/nanosecond.html)\n"
    },
    "mifirstNot": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mifirstNot.html",
        "signatures": [
            {
                "full": "mifirstNot(X, window, [minPeriods])",
                "name": "mifirstNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mifirstNot](https://docs.dolphindb.com/en/Functions/m/mifirstNot.html)\n\n\n\n#### Syntax\n\nmifirstNot(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nReturn the index of the first non-NULL element of *X* in a sliding window (based on the number of elements or time).\n\n#### Examples\n\n```\nv = NULL NULL 2 3 4 8 NULL 5 -2 3 -1 0 NULL\nmifirstNot(v, 3)\n// output: [,,2,1,0,0,0,0,1,0,0,0,0]\n\nm = matrix(NULL 1 2 3, 1 NULL 2 3, NULL NULL 3 4, 1 2 3 4)\nn = mifirstNot(m, 2)\nn\n```\n\n| #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- |\n|    |    |    |    |\n| 1  | 0  | -1 | 0  |\n| 0  | 1  | 1  | 0  |\n| 0  | 0  | 0  | 0  |\n\n```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07]\nX = NULL 2 NULL 4 5\nX1 = indexedSeries(T, X)\nmifirstNot(X1, 2, 1)\n```\n\n|            | #1 |\n| ---------- | -- |\n| 2022.01.01 | -1 |\n| 2022.01.02 | 1  |\n| 2022.01.03 | 0  |\n| 2022.01.06 | 0  |\n| 2022.01.07 | 0  |\n\nRelated function: [milastNot](https://docs.dolphindb.com/en/Functions/m/milastNot.html)\n"
    },
    "migrate": {
        "url": "https://docs.dolphindb.com/en/Functions/m/migrate.html",
        "signatures": [
            {
                "full": "migrate(backupDir, [backupDBPath], [backupTableName], [newDBPath=backupDBPath], [newTableName=backupTableName])",
                "name": "migrate",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "[backupDBPath]",
                        "name": "backupDBPath",
                        "optional": true
                    },
                    {
                        "full": "[backupTableName]",
                        "name": "backupTableName",
                        "optional": true
                    },
                    {
                        "full": "[newDBPath=backupDBPath]",
                        "name": "newDBPath",
                        "optional": true,
                        "default": "backupDBPath"
                    },
                    {
                        "full": "[newTableName=backupTableName]",
                        "name": "newTableName",
                        "optional": true,
                        "default": "backupTableName"
                    }
                ]
            }
        ],
        "markdown": "### [migrate](https://docs.dolphindb.com/en/Functions/m/migrate.html)\n\n\n\n#### Syntax\n\nmigrate(backupDir, \\[backupDBPath], \\[backupTableName], \\[newDBPath=backupDBPath], \\[newTableName=backupTableName])\n\n#### Arguments\n\n**backupDir** is a string indicating the directory to save the backup.\n\n**backupDBPath** is a string indicating the path of a database.\n\n**backupTableName** is a string indicating a table name.\n\n**newDBPath** is a string indicating the new database name. If not specified, the default value is *backupDBPath*. To specify the parameter, make sure that the storage engine of the backup database is the same as the engine of *newDBPath*, and the *partitionScheme* must be the same (except for VALUE). For a VALUE partitioned database, the partitioning scheme of the backup database must be a subset of that of the database to be restored.\n\n**newTableName** is a string indicating the new table name. If not specified, the default value is *backupTableName*.\n\n#### Details\n\nRestore the backup. It returns a table containing the restored data of each table. It must be executed by a logged-in user.\n\nThe `migrate` function has the following 3 usages:\n\n* `migrate(backupDir)`: Restore the backup of all databases in this directory. The restored database name and table name are the same as the original ones.\n\n* `migrate(backupDir, backupDBPath)`: Restore the backup of the specified database in this directory. The restored database name and table name are the same as the original ones.\n\n* `migrate(backupDir, backupDBPath, backupTableName, [newDBPath], [newTableName])`: Restore the backup of the specified table of the specified database in the directory.\n\n  * If *newDBPath* and *newTableName* are not specified, the restored database name and table name are the same as the original ones.\n\n  * If *newDBPath* and *newTableName* are specified, the restored database name and table name will be *newDBPath* and *newTableName*, respectively.\n\n#### Examples\n\nCreate two sample databases and back up them to the same directory:\n\n```\nbackupDir=\"/home/DolphinDB/backup\"\n\nn = 1000000\nt1 = table(rand(2012.12.01..2012.12.10, n) as date, rand(`AAPL`IBM`GOOG`MSFT, n) as sym, rand(1000.0,n) as price)\nt2 = table(rand(2012.12.01..2012.12.10, n) as date, rand(`AAPL`IBM`GOOG`MSFT, n) as sym, rand(1000,n) as qty)\ndb1 = database(\"dfs://db1\", VALUE, 2012.12.01..2012.12.10)\ntrades1 = db1.createPartitionedTable(t1, `trades1, `date).append!(t1)\ntrades2 = db1.createPartitionedTable(t2, `trades2, `date).append!(t2)\n\nn = 1000000\nt1 = table(rand(2012.12.01..2012.12.10, n) as date, rand(`AAPL`IBM`GOOG`MSFT, n) as sym, rand(1000.0,n) as price)\nt2 = table(rand(2012.12.01..2012.12.10, n) as date, rand(`AAPL`IBM`GOOG`MSFT, n) as sym, rand(1000,n) as qty)\ndb1 = database(\"dfs://db2\", VALUE, `AAPL`IBM`GOOG`MSFT)\nquotes1 = db1.createPartitionedTable(t1, `quotes1, `sym).append!(t1)\nquotes2 = db1.createPartitionedTable(t2, `quotes2, `sym).append!(t2)\n\nbackup(backupDir, <select * from trades1>, true)\nbackup(backupDir, <select * from trades2>, true)\nbackup(backupDir, <select * from quotes1>, true)\nbackup(backupDir, <select * from quotes2>, true)\n```\n\nDelete the original database:\n\n```\ndropDatabase(\"dfs://db1\")\ndropDatabase(\"dfs://db2\")\n```\n\nExample 1. Restore all databases\n\n```\nmigrate(backupDir);\n```\n\n| dbName     | tableName | success | errorMsg |\n| ---------- | --------- | ------- | -------- |\n| dfs\\://db1 | trades1   | 1       |          |\n| dfs\\://db1 | trades2   | 1       |          |\n| dfs\\://db2 | quotes2   | 1       |          |\n| dfs\\://db2 | quotes1   | 1       |          |\n\nExample 2. Restore all tables in the database *dfs\\://db1*\n\n```\nmigrate(backupDir, \"dfs://db1\");\n```\n\n| dbName     | tableName | success | errorMsg |\n| ---------- | --------- | ------- | -------- |\n| dfs\\://db1 | trades1   | 1       |          |\n| dfs\\://db1 | trades2   | 1       |          |\n\nExample 3. Restore table trades1 in the database *dfs\\://db1*\n\nExample 3.1 When we do not specify the new database name and table name\n\n```\nmigrate(backupDir, \"dfs://db1\", \"trades1\");\n```\n\n| dbName     | tableName | success | errorMsg |\n| ---------- | --------- | ------- | -------- |\n| dfs\\://db1 | trades1   | 1       |          |\n\nExample 3.2 Specify the new database name and table name\n\n```\nmigrate(backupDir, \"dfs://db1\", \"trades1\", \"dfs://db3\", \"trades\");\n```\n\n| dbName     | tableName | success | errorMsg |\n| ---------- | --------- | ------- | -------- |\n| dfs\\://db1 | trades1   | 1       |          |\n\n```\nexec count(*) from loadTable(\"dfs://db3\", \"trades\")\n// output\n1000000\n```\n\nRelated function: [backup](https://docs.dolphindb.com/en/Functions/b/backup.html)\n"
    },
    "milastNot": {
        "url": "https://docs.dolphindb.com/en/Functions/m/milastNot.html",
        "signatures": [
            {
                "full": "milastNot(X, window, [minPeriods])",
                "name": "milastNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [milastNot](https://docs.dolphindb.com/en/Functions/m/milastNot.html)\n\n\n\n#### Syntax\n\nmilastNot(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nReturn the index of the last non-NULL element of *X* in a sliding window (based on the number of elements or time).\n\n#### Examples\n\n```\nv = NULL NULL 2 3 4 8 NULL 5 -2 3 -1 0 NULL\nmilastNot(v, 3)\n// output: [,,2,2,2,2,1,2,2,2,2,2,1]\n\nm = matrix(1 2 3 NULL, 1 2 NULL 3, 1 3 NULL NULL, 1 2 3 4)\nmilastNot(m, 2)\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n|    |    |    |    |\n| 1  | 1  | 1  | 1  |\n| 1  | 0  | 0  | 1  |\n| 0  | 1  | -1 | 1  |\n\n```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07]\nX = NULL 2 NULL 4 5\nX1 = indexedSeries(T, X)\nmilastNot(X1, 2, 1)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2022.01.01 | -1 |\n| 2022.01.02 | 1  |\n| 2022.01.03 | 0  |\n| 2022.01.06 | 0  |\n| 2022.01.07 | 1  |\n\nRelated function: [mifirstNot](https://docs.dolphindb.com/en/Functions/m/mifirstNot.html)\n"
    },
    "millisecond": {
        "url": "https://docs.dolphindb.com/en/Functions/m/millisecond.html",
        "signatures": [
            {
                "full": "millisecond(X)",
                "name": "millisecond",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [millisecond](https://docs.dolphindb.com/en/Functions/m/millisecond.html)\n\n\n\n#### Syntax\n\nmillisecond(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type TIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP.\n\n#### Details\n\nFor each element in *X*, return a number from 0 to 999 indicating which millisecond of the second it falls in.\n\n#### Examples\n\n```\nmillisecond(13:30:10.008);\n// output\n8\n\nmillisecond([2012.12.03 01:22:01.456120300, 2012.12.03 01:25:08.000234000]);\n// output\n[456,0]\n```\n\nRelated functions: [dayOfYear](https://docs.dolphindb.com/en/Functions/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.com/en/Functions/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.com/en/Functions/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.com/en/Functions/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.com/en/Functions/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.com/en/Functions/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.com/en/Functions/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html), [microsecond](https://docs.dolphindb.com/en/Functions/m/microsecond.html), [nanosecond](https://docs.dolphindb.com/en/Functions/n/nanosecond.html)\n"
    },
    "mimax": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mimax.html",
        "signatures": [
            {
                "full": "mimax(X, window, [minPeriods])",
                "name": "mimax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mimax](https://docs.dolphindb.com/en/Functions/m/mimax.html)\n\n\n\n#### Syntax\n\nmimax(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nReturn the position of the element with the largest value in *X* in a sliding window. If there are multiple elements with the identical largest value in a window, return the position of the first element from the left. Same as other aggregate functions, NULL values are ignored.\n\n#### Examples\n\n```\nx = 1.2 2 NULL 6 -1 6\nmimax(x, 3);\n// output: [,,1,2,1,0]\n\nmimax(x, 3, 1);\n// output: [0,1,1,2,1,0]\n```\n\n```\nm=matrix(1 6 2 9 10 3, 9 10 2 6 6 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 9  |\n| 6  | 10 |\n| 2  | 2  |\n| 9  | 6  |\n| 10 | 6  |\n| 3  | 6  |\n\n```\nmimax(m,3);\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 1  | 1  |\n| 2  | 0  |\n| 2  | 1  |\n| 1  | 0  |\n\n```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07, 2022.01.08, 2022.01.10, 2022.01.11]\nX = 1..8\nX1 = indexedSeries(T, X)\nmimax(X1,3)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2022.01.01 | 0  |\n| 2022.01.02 | 1  |\n| 2022.01.03 | 2  |\n| 2022.01.06 | 0  |\n| 2022.01.07 | 1  |\n| 2022.01.08 | 2  |\n| 2022.01.10 | 1  |\n| 2022.01.11 | 1  |\n\n```\nt= 2021.01.02 2021.01.05  2021.01.06  2021.01.09 2021.01.10 2021.01.12\nm=matrix(5 4 NULL -1 2 4, 3 2 8 1 0 5)\nm1=m.rename!(t, `a`b).setIndexedMatrix!()\nmimax(m1,3)\n```\n\n|            | a | b |\n| ---------- | - | - |\n| 2021.01.02 | 0 | 0 |\n| 2021.01.05 | 0 | 0 |\n| 2021.01.06 | 0 | 1 |\n| 2021.01.09 | 0 | 0 |\n| 2021.01.10 | 1 | 0 |\n| 2021.01.12 | 1 | 1 |\n\nRelated functions: [imax](https://docs.dolphindb.com/en/Functions/i/imax.html), [mimin](https://docs.dolphindb.com/en/Functions/m/mimin.html)\n"
    },
    "mimaxLast": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mimaxlast.html",
        "signatures": [
            {
                "full": "mimaxLast(X, window, [minPeriods])",
                "name": "mimaxLast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mimaxLast](https://docs.dolphindb.com/en/Functions/m/mimaxlast.html)\n\n\n\n#### Syntax\n\nmimaxLast(X, window, \\[minPeriods])\n\n#### Arguments\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.dita) for the parameters and windowing logic.\n\n#### Details\n\nReturn the position of the element with the largest value in *X* in a sliding window. If there are multiple elements with the identical largest value in a window, return the position of the first element from the right. Same as other aggregate functions, NULL values are ignored.\n\n#### Examples\n\n```\nx = 1.2 2 NULL -1 6 -1\nmimaxLast(x,3);\n// output: [,,1,0,2,1]\n```\n\n```\nm=matrix(3 2 4 4 2, 1 4 2 4 3);\nmimaxLast(m,3) \n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 2  | 1  |\n| 2  | 2  |\n| 1  | 1  |\n\n```\nt=table(3 3 2 as c1, 1 4 4 as c2)\nmimaxLast(t,3)\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 1  | 2  |\n\n```\nx = [NULL, 2, NULL, NULL, 3.2]\ndate = [0, 1, 3,  8, 9] + 2020.01.01\nX = indexedSeries(date, x) \nmimaxLast(X, 3d)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2020.01.01 | -1 |\n| 2020.01.02 | 1  |\n| 2020.01.04 | 0  |\n| 2020.01.09 | -1 |\n| 2020.01.10 | 1  |\n\nRelated function: [mimax](https://docs.dolphindb.com/en/Functions/m/mimax.html)\n"
    },
    "mimin": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mimin.html",
        "signatures": [
            {
                "full": "mimin(X, window, [minPeriods])",
                "name": "mimin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mimin](https://docs.dolphindb.com/en/Functions/m/mimin.html)\n\n\n\n#### Syntax\n\nmimin(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nReturn the position of the element with the smallest value in *X* in a sliding window. If there are multiple elements with the identical smallest value in a window, return the position of the first element from the left. Same as other aggregate functions, NULL values are ignored.\n\n#### Examples\n\n```\nx = 1.2 2 NULL 6 -1 -1\nmimin(x, 3);\n// output: [,,0,0,2,1]\n\nmimin(x, 3, 1);\n// output: [0,0,0,0,2,1]\n\n```\n\n```\nm=matrix(1 6 2 9 10 3, 9 10 2 6 6 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 9  |\n| 6  | 10 |\n| 2  | 2  |\n| 9  | 6  |\n| 10 | 6  |\n| 3  | 6  |\n\n```\nmimin(m,3);\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 0  | 2  |\n| 1  | 1  |\n| 0  | 0  |\n| 2  | 0  |\n\n```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07, 2022.01.08, 2022.01.10, 2022.01.11]\nX = 1..8\nX1 = indexedSeries(T, X)\nmimin(X1,3)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2022.01.01 | 0  |\n| 2022.01.02 | 0  |\n| 2022.01.03 | 0  |\n| 2022.01.06 | 0  |\n| 2022.01.07 | 0  |\n| 2022.01.08 | 0  |\n| 2022.01.10 | 0  |\n| 2022.01.11 | 0  |\n\n```\nt= 2021.01.02 2021.01.05  2021.01.06  2021.01.09 2021.01.10 2021.01.12\nm=matrix(5 4 NULL -1 2 4, 3 2 8 1 0 5)\nm1=m.rename!(t, `a`b).setIndexedMatrix!()\nmimin(m1,3)\n```\n\n|            | a | b |\n| ---------- | - | - |\n| 2021.01.02 | 0 | 0 |\n| 2021.01.05 | 0 | 0 |\n| 2021.01.06 | 0 | 0 |\n| 2021.01.09 | 0 | 0 |\n| 2021.01.10 | 0 | 1 |\n| 2021.01.12 | 0 | 0 |\n\nRelated functions: [imin](https://docs.dolphindb.com/en/Functions/i/imin.html), [mimax](https://docs.dolphindb.com/en/Functions/m/mimax.html)\n"
    },
    "miminLast": {
        "url": "https://docs.dolphindb.com/en/Functions/m/miminlast.html",
        "signatures": [
            {
                "full": "miminLast(X, window, [minPeriods])",
                "name": "miminLast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [miminLast](https://docs.dolphindb.com/en/Functions/m/miminlast.html)\n\n\n\n#### Syntax\n\nmiminLast(X, window, \\[minPeriods])\n\n#### Arguments\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.dita) for the parameters and windowing logic.\n\n#### Details\n\nReturn the position of the element with the smallest value in *X* in a sliding window. If there are multiple elements with the identical smallest value in a window, return the position of the first element from the right. Same as other aggregate functions, NULL values are ignored.\n\n#### Examples\n\n```\nx = 1.2 2 NULL -1 6 -1\n$miminLast(x,3);\n// output: [,,0,2,1,2]\n```\n\n```\nm=matrix(3 2 2 4 2, 1 4 2 1 3);\nmiminLast(m,3)\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 2  | 0  |\n| 1  | 2  |\n| 2  | 1  |\n\n```\nt=table(3 2 2 as c1, 1 1 4 as c2)\nmiminLast(t,3)\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 2  | 1  |\n\n```\nx = [NULL, 2, NULL, NULL, 3.2]\ndate = [0, 1, 3,  8, 9] + 2020.01.01\nX = indexedSeries(date, x) \nmiminLast(X, 3d)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2020.01.01 | -1 |\n| 2020.01.02 | 1  |\n| 2020.01.04 | 0  |\n| 2020.01.09 | -1 |\n| 2020.01.10 | 1  |\n\nRelated function: [mimin](https://docs.dolphindb.com/en/Functions/m/mimin.html)\n"
    },
    "min": {
        "url": "https://docs.dolphindb.com/en/Functions/m/min.html",
        "signatures": [
            {
                "full": "min(X)",
                "name": "min",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [min](https://docs.dolphindb.com/en/Functions/m/min.html)\n\n\n\n#### Syntax\n\nmin(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n**Y** is an optional parameter, which can be a scalar, a vector of the same length as X or a matrix.\n\n#### Details\n\nFor one input (NULL values will not be compared with other elements):\n\n* If *X* is a vector, return the minimum in *X*.\n\n* If *X* is a matrix, return the minimum in each column of *X* and return a vector.\n\n* If *X* is a table, return the minimum in each column of *X* and return a table.\n\nFor two inputs (NULL values will be compared with other elements):\n\n* If *Y* is a scalar, compare it with each element in *X*, replace the element in *X* with the smaller value.\n\n* If *Y* and *X* are of the same type and length, compare the corresponding elements of them and return a vector containing each smaller value.\n\n**Note:**\n\nBefore version 1.30.20/2.00.8, the function `min` compares the values of temporal types by converting them into LONG values. Since version 1.30.20/2.00.8, DolphinDB has changed the handling of temporal types:\n\n* If *X* and *Y* are temporal scalars with different levels of time granularity, the coarser-grained value is converted to the finer granularity for comparison.\n\n* If *X* and/or *Y* is a vector, matrix, or table, the compared elements must be of the same temporal type.\n\n#### Examples\n\n```\nmin(1 2 3);\n// output\n1;\n\nmin(2.0 1.1 0.1 NULL);\n// output\n0.1\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nmin(m);\n// output\n[1,4]\n```\n\n```\nmin(1 2 3, 2)\n// output\n1 2 2\n\nn = matrix(1 1 1, 5 5 5)\nn;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 1  | 5  |\n| 1  | 5  |\n\n```\nmin(m, n);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 1  | 5  |\n| 1  | 5  |\n\nRelated function: [mmin](https://docs.dolphindb.com/en/Functions/m/mmin.html)\n"
    },
    "minIgnoreNull": {
        "url": "https://docs.dolphindb.com/en/Functions/m/minIgnoreNull.html",
        "signatures": [
            {
                "full": "minIgnoreNull(X, Y)",
                "name": "minIgnoreNull",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [minIgnoreNull](https://docs.dolphindb.com/en/Functions/m/minIgnoreNull.html)\n\n#### Syntax\n\nminIgnoreNull(X, Y)\n\n#### Arguments\n\n**X** and **Y** can be a numeric, LITERAL or TEMPORAL scalar, pair, vector or matrix.\n\n#### Details\n\nA binary scalar function that returns the minimum by comparing *X* with *Y*.\n\nDifference between `min` and `minIgnoreNull`:\n\n* `min`: NULL is treated as the minimum value if \\*nullAsMinValueForComparison=\\*true, otherwise comparison involving NULL returns NULL.\n\n* `minIgnoreNull`: NULL is ignored in comparison and non-NULL minimum is returned. If both elements in *X* and *Y* are NULL, NULL is returned. This function is not affected by configuration parameter *nullAsMinValueForComparison*.\n\n#### Examples\n\n```\nminIgnoreNull(2,matrix(1  NULL -4,-1 -4  0)) \n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | -1 |\n| 2  | -4 |\n| -4 | 0  |\n\n```\nminIgnoreNull(matrix(10 3 NULL, 1 7 4),matrix(1  NULL -4,-1 -4  0))\n```\n\n<table id=\"table_slz_glq_3bc\"><tbody><tr><td>\n\n\\#0\n\n</td><td>\n\n\\#1\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n-1\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n-4\n\n</td></tr><tr><td>\n\n-4\n\n</td><td>\n\n0\n\n</td></tr></tbody>\n</table>Use `minIgnoreNull` with `reduce` to calculate the minimum for matrices of the same shape stored in a tuple:\n\n```\nn1 = matrix(1 1 1, 5 5 5)\nn2 = matrix(10 11 12, 0 NULL -5)\nn3 = matrix(-1 1 NULL, -3 0 10)\nreduce(minIgnoreNull, [n1,n2,n3])\n```\n\n| #0 | #1 |\n| -- | -- |\n| -1 | -3 |\n| 1  | 0  |\n| 1  | -5 |\n\n**Related function**: [maxIgnoreNull](https://docs.dolphindb.com/en/Functions/m/maxIgnoreNull.html)\n\n"
    },
    "minute": {
        "url": "https://docs.dolphindb.com/en/Functions/m/minute.html",
        "signatures": [
            {
                "full": "minute(X)",
                "name": "minute",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [minute](https://docs.dolphindb.com/en/Functions/m/minute.html)\n\n\n\n#### Syntax\n\nminute(X)\n\n#### Arguments\n\n**X** is an integer or temporal scalar/vector.\n\n#### Details\n\nReturn the corresponding minute(s).\n\n#### Examples\n\n```\nminute 2012.12.03 01:22:01;\n// output\n01:22m\n\nminute(61);\n// output\n01:01m\n```\n\nRelated functions: [second](https://docs.dolphindb.com/en/Functions/s/second.html), [month](https://docs.dolphindb.com/en/Functions/m/month.html), [date](https://docs.dolphindb.com/en/Functions/d/date.html), [year](https://docs.dolphindb.com/en/Functions/y/year.html)\n"
    },
    "minuteOfHour": {
        "url": "https://docs.dolphindb.com/en/Functions/m/minuteOfHour.html",
        "signatures": [
            {
                "full": "minuteOfHour(X)",
                "name": "minuteOfHour",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [minuteOfHour](https://docs.dolphindb.com/en/Functions/m/minuteOfHour.html)\n\n\n\n#### Syntax\n\nminuteOfHour(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type TIME, MINUTE, SECOND, DATETIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP.\n\n#### Details\n\nFor each element in *X*, return a number from 0 to 59 indicating which minute of the hour it falls in.\n\n#### Examples\n\n```\nminuteOfHour(12:32:00);\n// output\n32\n\n minuteOfHour([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n// output\n[30,35,36,2]\n```\n\nRelated functions: [dayOfYear](https://docs.dolphindb.com/en/Functions/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.com/en/Functions/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.com/en/Functions/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.com/en/Functions/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.com/en/Functions/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.com/en/Functions/h/hourOfDay.html), [secondOfMinute](https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.com/en/Functions/m/millisecond.html), [microsecond](https://docs.dolphindb.com/en/Functions/m/microsecond.html), [nanosecond](https://docs.dolphindb.com/en/Functions/n/nanosecond.html)\n"
    },
    "mkdir": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mkdir.html",
        "signatures": [
            {
                "full": "mkdir(directory)",
                "name": "mkdir",
                "parameters": [
                    {
                        "full": "directory",
                        "name": "directory"
                    }
                ]
            }
        ],
        "markdown": "### [mkdir](https://docs.dolphindb.com/en/Functions/m/mkdir.html)\n\n\n\n#### Syntax\n\nmkdir(directory)\n\n#### Arguments\n\n**directory** the path of the directory to be created.\n\n#### Details\n\nCreate a directory. It must be executed by a logged-in user.\n\n#### Examples\n\n```\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n\n```\nmkdir(\"/home/test/dir1\");\nmkdir(\"/home/test/dir2\");\nmkdir(\"/home/test/dir3\");\n// output\nThe directory [/home/test/dir3] already exists.\n```\n\n```\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| dir1     | 1     | 0        | 1496651628372 | 1496651628372 |\n| dir2     | 1     | 0        | 1496651645598 | 1496651645598 |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n"
    },
    "mkurtosis": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mkurtosis.html",
        "signatures": [
            {
                "full": "mkurtosis(X, window, [biased=true], [minPeriods])",
                "name": "mkurtosis",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mkurtosis](https://docs.dolphindb.com/en/Functions/m/mkurtosis.html)\n\n\n\n#### Syntax\n\nmkurtosis(X, window, \\[biased=true], \\[minPeriods])\n\n#### Arguments\n\n**biased** is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving kurtosis of *X* in a sliding window.\n\n#### Examples\n\n```\nm=matrix(1 9 3 100 3 2 1 -100 9 10000, 1 2 3 4 5 6 7 8 9 100);\nm.mkurtosis(8);\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n|                   |                   |\n|                   |                   |\n|                   |                   |\n|                   |                   |\n|                   |                   |\n|                   |                   |\n| 3.989653641279048 | 1.761904761904762 |\n| 3.989840910744778 | 1.761904761904762 |\n| 6.140237905908072 | 6.101712240467206 |\n\n```\nm.rename!(date(2020.04.06)+1..10, `col1`col2)\nm.setIndexedMatrix!()\nmkurtosis(m, 8d)\n```\n\n| label      | col1   | col2   |\n| ---------- | ------ | ------ |\n| 2020.04.07 |        |        |\n| 2020.04.08 |        |        |\n| 2020.04.09 | 1.5    | 1.5    |\n| 2020.04.10 | 2.3195 | 1.64   |\n| 2020.04.11 | 3.2251 | 1.7    |\n| 2020.04.12 | 4.163  | 1.7314 |\n| 2020.04.13 | 5.1141 | 1.75   |\n| 2020.04.14 | 3.9897 | 1.7619 |\n| 2020.04.15 | 3.9898 | 1.7619 |\n| 2020.04.16 | 6.1402 | 6.1017 |\n\n```\nmkurtosis(m, 1w)\n```\n\n| label      | col1   | col2   |\n| ---------- | ------ | ------ |\n| 2020.04.07 |        |        |\n| 2020.04.08 |        |        |\n| 2020.04.09 | 1.5    | 1.5    |\n| 2020.04.10 | 2.3195 | 1.64   |\n| 2020.04.11 | 3.2251 | 1.7    |\n| 2020.04.12 | 4.163  | 1.7314 |\n| 2020.04.13 | 5.1141 | 1.75   |\n| 2020.04.14 | 3.4937 | 1.75   |\n| 2020.04.15 | 3.4937 | 1.75   |\n| 2020.04.16 | 5.1645 | 5.145  |\n\nThe default case of kurtosis in DolphinDB is biased (*biased* = true), while in pandas and Excel it is unbiased estimation, and the kurtosis value 3 of the normal distribution is subtracted.\n\nThe following example illustrates the equivalent conversion between the two when using a sliding window:\n\n```\n// python\nm = [[1111,2], [323,9], [43,12], [51,32], [6,400]]\ndf = pandas.DataFrame(m)\ny = df.rolling(4).kurt()\n\n// dolphindb\nm=matrix(1111 323 43 51 6, 2 9 12 32 400)\nm.mkurtosis(4, false)-3\n```\n\n| #0       | #1       |\n| -------- | -------- |\n|          |          |\n|          |          |\n|          |          |\n| 2.504252 | 2.366838 |\n| 3.675552 | 3.941262 |\n\nRelated function: [kurtosis](https://docs.dolphindb.com/en/Functions/k/kurtosis.html)\n"
    },
    "mkurtosisTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mkurtosisTopN.html",
        "signatures": [
            {
                "full": "mkurtosisTopN(X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "mkurtosisTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [mkurtosisTopN](https://docs.dolphindb.com/en/Functions/m/mkurtosisTopN.html)\n\n\n\n#### Syntax\n\nmkurtosisTopN(X, S, window, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**biased** (optional) is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the moving kurtosis of the first *top* elements.\n\n**Return value**: DOUBLE type\n\n#### Examples\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmkurtosisTopN(X, S, 6, 4)\n// output\n[,,1.49,2.23,2.31,2.11,2.27]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\nmkurtosisTopN(X, S, 6, 4)\n\n// output\ncol1   col2\n\n\n1.5\n1.5    1.5\n1.8457 1.5\n1.5734 1.8457\n1.8457 1.2215\n1.64   2\n1.64   1.64\n1.64   1.8457\n\n\n\nsymbol = [\"A\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"B\",\"B\",\"A\",\"B\",\"A\",\"B\",\"B\",\"A\",\"B\",\"A\"]\ntime = temporalAdd(2023.07.05T09:30:00.000,[10,20,40,60,70,80,90,140,160,170,180,190,200,210,220,230,250,360,390,400],\"ms\")\nprice = [28.11,28.25,28.44,52.31,28.98,28.89,52.22,28.16,28.52,52.62,52.56,52.2,28.01,52.43,28.57,52.42,52.19,28.16,52.84,28.18]\nqty = [5000,400,3100,100,2400,3700,700,3700,4600,4700,3100,3300,3900,3500,3000,3000,4000,4700,2000,4400]\nBSFlag = [1,0,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0]\nt = table(time, symbol, price, qty, BSFlag)\nselect time,symbol,mkurtosisTopN(price, qty, 8, 5) as mskewTop5price from t context by symbol\n```\n\n| time                    | symbol | mskewTop5price |\n| ----------------------- | ------ | -------------- |\n| 2023.07.05T09:30:00.010 | A      |                |\n| 2023.07.05T09:30:00.020 | A      |                |\n| 2023.07.05T09:30:00.040 | A      | 1.5            |\n| 2023.07.05T09:30:00.070 | A      | 2.0147         |\n| 2023.07.05T09:30:00.080 | A      | 1.3355         |\n| 2023.07.05T09:30:00.140 | A      | 1.2976         |\n| 2023.07.05T09:30:00.160 | A      | 1.2976         |\n| 2023.07.05T09:30:00.200 | A      | 1.2976         |\n| 2023.07.05T09:30:00.220 | A      | 2.2021         |\n| 2023.07.05T09:30:00.360 | A      | 1.656          |\n| 2023.07.05T09:30:00.400 | A      | 1.351          |\n| 2023.07.05T09:30:00.060 | B      |                |\n| 2023.07.05T09:30:00.090 | B      |                |\n| 2023.07.05T09:30:00.170 | B      | 1.5            |\n| 2023.07.05T09:30:00.180 | B      | 1.1993         |\n| 2023.07.05T09:30:00.190 | B      | 1.289          |\n| 2023.07.05T09:30:00.210 | B      | 1.7383         |\n| 2023.07.05T09:30:00.230 | B      | 1.8183         |\n| 2023.07.05T09:30:00.250 | B      | 1.8183         |\n| 2023.07.05T09:30:00.390 | B      | 1.923          |\n\nRelated function: [mkurtosis](https://docs.dolphindb.com/en/Functions/m/mkurtosis.html)\n"
    },
    "mlast": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mlast.html",
        "signatures": [
            {
                "full": "mlast(X, window, [minPeriods])",
                "name": "mlast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mlast](https://docs.dolphindb.com/en/Functions/m/mlast.html)\n\n\n\n#### Syntax\n\nmlast(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nReturn the last element of *X* in a sliding window.\n\n#### Examples\n\n```\nindex = second(08:20:00)+1..7\nx = 2 1 3 NULL 6 5 4\nx = index.indexedSeries(x)\nmlast(x,3s)\n```\n\n| label    | col1 |\n| -------- | ---- |\n| 08:20:01 | 2    |\n| 08:20:02 | 1    |\n| 08:20:03 | 3    |\n| 08:20:04 |      |\n| 08:20:05 | 6    |\n| 08:20:06 | 5    |\n| 08:20:07 | 4    |\n\n```\nm = matrix(1 5 9 0 2, 9 10 2 NULL 2)\nm.rename!((date(2020.09.08)+1..3) join 2020.09.16 join 2020.09.26, `A`B)\nm.setIndexedMatrix!()\nmlast(m, 3d)\n```\n\n| label      | A | B  |\n| ---------- | - | -- |\n| 2020.09.09 | 1 | 9  |\n| 2020.09.10 | 5 | 10 |\n| 2020.09.11 | 9 | 2  |\n| 2020.09.16 | 0 |    |\n| 2020.09.26 | 2 | 2  |\n\n```\nmlast(m, 1w)\n```\n\n| label      | A | B  |\n| ---------- | - | -- |\n| 2020.09.09 | 1 | 9  |\n| 2020.09.10 | 5 | 10 |\n| 2020.09.11 | 9 | 2  |\n| 2020.09.16 | 0 |    |\n| 2020.09.26 | 2 | 2  |\n\nRelated functions: [last](https://docs.dolphindb.com/en/Functions/l/last.html), [first](https://docs.dolphindb.com/en/Functions/f/first.html)\n"
    },
    "mlastNot": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mlastNot.html",
        "signatures": [
            {
                "full": "mlastNot(X, window, [k=NULL], [minPeriods=1])",
                "name": "mlastNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[k=NULL]",
                        "name": "k",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[minPeriods=1]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [mlastNot](https://docs.dolphindb.com/en/Functions/m/mlastNot.html)\n\n#### Syntax\n\nmlastNot(X, window, \\[k=NULL], \\[minPeriods=1])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**k** (optional) is a numeric or string scalar indicating the value to be matched.\n\n#### Details\n\nIf *X* is a vector:\n\n* If *k* is not specified, return the last element of *X* that is not NULL in a sliding window.\n\n* If *k* is specified, return the last element of *X* that is neither *k* nor NULL in the window.\n\nIf *X* is a matrix or table, conduct the aforementioned calculation within each column of *X*. The result is a matrix or table.\n\n#### Examples\n\n```\nmlastNot(NULL 2 NULL 4 5, 2)\n// output: [,2,2,4,5]\n```\n\n```\nmlastNot(X=matrix(1..5,2..6,3..7), window=2, k=4, minPeriods=2)\n```\n\n<table id=\"table_fct_wcd_jbc\"><thead><tr><th>\n\n\\#0\n\n</th><th>\n\n\\#1\n\n</th><th>\n\n\\#2\n\n</th></tr></thead><tbody><tr><td>\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n3\n\n</td><td>\n\n3\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n3\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n5\n\n</td><td>\n\n6\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n6\n\n</td><td>\n\n7\n\n</td></tr></tbody>\n</table>```\nx=table([\"s1\", \"s2\", \"\", \"s4\", \"s5\"] as col1, [\"s1\", \"\", \"s3\", \"\", \"s5\"] as col2)\nmlastNot(X=x, window=2)\n```\n\n<table id=\"table_twv_xcd_jbc\"><thead><tr><th>\n\n\\#0\n\n</th><th>\n\n\\#1\n\n</th></tr></thead><tbody><tr><td>\n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\ns2\n\n</td><td>\n\ns1\n\n</td></tr><tr><td>\n\ns2\n\n</td><td>\n\ns3\n\n</td></tr><tr><td>\n\ns4\n\n</td><td>\n\ns3\n\n</td></tr><tr><td>\n\ns5\n\n</td><td>\n\ns5\n\n</td></tr></tbody>\n</table>```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07, 2022.01.08, 2022.01.10, 2022.01.11]\nX = 1..8\nX1 = indexedSeries(T, X)\nmlastNot(X=X1, window=3, k=1, minPeriods=1)\n```\n\n<table id=\"table_jmg_5bd_jbc\"><tbody><tr><td>\n\n</td><td>\n\n\\#0\n\n</td></tr><tr><td>\n\n2022.01.01\n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n2022.01.02\n\n</td><td>\n\n2\n\n</td></tr><tr><td>\n\n2022.01.03\n\n</td><td>\n\n2\n\n</td></tr><tr><td>\n\n2022.01.06\n\n</td><td>\n\n4\n\n</td></tr><tr><td>\n\n2022.01.07\n\n</td><td>\n\n4\n\n</td></tr><tr><td>\n\n2022.01.08\n\n</td><td>\n\n4\n\n</td></tr><tr><td>\n\n2022.01.10\n\n</td><td>\n\n6\n\n</td></tr><tr><td>\n\n2022.01.11\n\n</td><td>\n\n7\n\n</td></tr></tbody>\n</table>Related functions: [mlast](mlast.md), [mfirstNot](mfirstNot.md)\n\n"
    },
    "mLowRange": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mLowRange.html",
        "signatures": [
            {
                "full": "mLowRange(X, window, [minPeriods])",
                "name": "mLowRange",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mLowRange](https://docs.dolphindb.com/en/Functions/m/mLowRange.html)\n\n#### Syntax\n\nmLowRange(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nFor each element *Xi* in a sliding window of *X*, count the continuous nearest neighbors to its left that are larger than *Xi*. NULLs are treated as the minimum values.\n\nIf *X* is a matrix, conduct the aforementioned calculation within each column of *X*.\n\n#### Examples\n\n```\nx = [NULL, 3.1, NULL, 3.0, 2.9, 2.8, 3.1, NULL, 3.2]\nmLowRange(x, window=3) \n// output: [,,1,0,1,2,0,2,0]\n\nmLowRange(x, window=3, minPeriods=1) \n// output: [,0,1,0,1,2,0,2,0]\n\nmLowRange(x, window=3, minPeriods=2) \n// output: [,,,0,1,2,0,2,0]\n\ndate = [0, 1, 2, 3, 7, 8, 9, 10, 11] + 2020.01.01\nX = indexedSeries(date, x)\nmLowRange(X, 3d)\n```\n\n<table id=\"table_wpt_cmr_jbc\"><thead><tr><th>\n\n \n\n</th><th>\n\n\\#0\n\n</th></tr></thead><tbody><tr><td>\n\n2020.01.01\n\n</td><td>\n\n</td></tr><tr><td>\n\n2020.01.02\n\n</td><td>\n\n0\n\n</td></tr><tr><td>\n\n2020.01.03\n\n</td><td>\n\n1\n\n</td></tr><tr><td>\n\n2020.01.04\n\n</td><td>\n\n0\n\n</td></tr><tr><td>\n\n2020.01.08\n\n</td><td>\n\n0\n\n</td></tr><tr><td>\n\n2020.01.09\n\n</td><td>\n\n1\n\n</td></tr><tr><td>\n\n2020.01.10\n\n</td><td>\n\n0\n\n</td></tr><tr><td>\n\n2020.01.11\n\n</td><td>\n\n2\n\n</td></tr><tr><td>\n\n2020.01.12\n\n</td><td>\n\n0\n\n</td></tr></tbody>\n</table>```\nm = matrix(1 2 3 NULL, 1 2 NULL 3, 1 3 NULL NULL, 1 2 3 4)\nmLowRange(m, 2)\n```\n\n<table id=\"table_grx_dmr_jbc\"><thead><tr><th>\n\n\\#0\n\n</th><th>\n\n\\#1\n\n</th><th>\n\n\\#2\n\n</th><th>\n\n\\#3\n\n</th></tr></thead><tbody><tr><td>\n\n</td><td>\n\n</td><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n0\n\n</td><td>\n\n0\n\n</td><td>\n\n0\n\n</td><td>\n\n0\n\n</td></tr><tr><td>\n\n0\n\n</td><td>\n\n1\n\n</td><td>\n\n1\n\n</td><td>\n\n0\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n0\n\n</td><td>\n\n</td><td>\n\n0\n\n</td></tr></tbody>\n</table>**Parent topic:**[Functions](../../Functions/category.md)\n"
    },
    "mmad": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mmad.html",
        "signatures": [
            {
                "full": "mmad(X, window, [useMedian=false], [minPeriods])",
                "name": "mmad",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[useMedian=false]",
                        "name": "useMedian",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mmad](https://docs.dolphindb.com/en/Functions/m/mmad.html)\n\n\n\n#### Syntax\n\nmmad(X, window, \\[useMedian=false], \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**useMedian** is a Boolean value. The default value is false and it returns the mean absolute deviation, otherwise returns the median absolute deviation.\n\n* mean absolute deviation: mean(abs(X - mean(X)))\n\n* median absolute deviation: med(abs(X - med(X)))\n\n#### Details\n\nCalculate the average absolute deviation of *X* in a sliding window.\n\n#### Examples\n\n```\nx = 7 4 6 0 -5 32;\nmmad(x, window=3);\n// output: [,,1.11,2.22,3.78,15.33]\n\nmmad(x, window=3, useMedian=true)\n// output: [,,1,2,5,5]\n\ny = NULL NULL 2 5 1 7 -3 0\nmmad(y, window=3, minPeriods=2);\n// output: [,,,1.5,1.56,2.22,3.56,3.78]\n```\n\n```\nm=matrix(85 90 95, 185 190 195);\nm;\n```\n\n| #0 | #1  |\n| -- | --- |\n| 85 | 185 |\n| 90 | 190 |\n| 95 | 195 |\n\n```\nmmad(m, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n|     |     |\n| 2.5 | 2.5 |\n| 2.5 | 2.5 |\n\nRelated function: [mad](https://docs.dolphindb.com/en/Functions/m/mad.html)\n"
    },
    "mmax": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mmax.html",
        "signatures": [
            {
                "full": "mmax(X, window, [minPeriods])",
                "name": "mmax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mmax](https://docs.dolphindb.com/en/Functions/m/mmax.html)\n\n\n\n#### Syntax\n\nmmax(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving maximums of *X* in a sliding window.\n\n#### Examples\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmmax(X, 3);\n// output\n[,,3,7,7,7,6]\n\nmmax(Y, 3);\n// output\n[,,3,3,6,6,6]\n\nmmax(Y, 3, minPeriods=1);\n// output\n[2,2,3,3,6,6,6]\n```\n\n```\nm = matrix(1 5 9 0 2, 9 10 2 NULL 2)\nm.rename!(date(2020.09.08)+1..5, `A`B)\nm.setIndexedMatrix!()\nm.mmax(3d)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 1    | 9    |\n| 2020.09.10 | 5    | 10   |\n| 2020.09.11 | 9    | 10   |\n| 2020.09.12 | 9    | 10   |\n| 2020.09.13 | 9    | 2    |\n\n```\nm.mmax(1w)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 1    | 9    |\n| 2020.09.10 | 5    | 10   |\n| 2020.09.11 | 9    | 10   |\n| 2020.09.12 | 9    | 10   |\n| 2020.09.13 | 9    | 10   |\n\nRelated functions: [max](https://docs.dolphindb.com/en/Functions/m/max.html)\n"
    },
    "mmaxPositiveStreak": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mmaxPositiveStreak.html",
        "signatures": [
            {
                "full": "mmaxPositiveStreak(X, window)",
                "name": "mmaxPositiveStreak",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [mmaxPositiveStreak](https://docs.dolphindb.com/en/Functions/m/mmaxPositiveStreak.html)\n\n\n\n#### Syntax\n\nmmaxPositiveStreak(X, window)\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nObtain the maximum value of the sum of consecutive positive numbers in *X* within a sliding window of given size (based on the number of elements).\n\n#### Examples\n\n```\nx = 1 -1 1 -2 10 3 3 9 0 6 5\nw = 5\nmmaxPositiveStreak(x, w)\n// output\n[,,,,10,13,16,25,25,15,12]\n\nx = 5 NULL 3 2 1 5 10 9 NULL 9 10 -1 NULL\nw = 5\nmmaxPositiveStreak(x, w)\n// output\n[,,,,6,11,21,27,25,24,19,19,19]\n\n// use the signum function to count the maximum number of consecutive positive numbers\nmmaxPositiveStreak(signum(x), w)\n// output\n[,,,,3,4,5,5,4,3,2,2,2]\n```\n"
    },
    "mmed": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mmed.html",
        "signatures": [
            {
                "full": "mmed(X, window, [minPeriods])",
                "name": "mmed",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mmed](https://docs.dolphindb.com/en/Functions/m/mmed.html)\n\n\n\n#### Syntax\n\nmmed(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving median of *X* in a sliding window.\n\n#### Examples\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmmed(X, 3);\n// output\n[,,2,3,6,6,5]\n\nmmed(Y, 3);\n// output\n[,,2,2,4.5,5.5,5]\n\nmmed(Y, 3, minPeriods=1);\n// output\n[2,1.5,2,2,4.5,5.5,5]\n```\n\n```\nm = matrix(1 5 9 0 2, 9 10 2 NULL 2)\nm.rename!(date(2020.09.08)+1..5, `A`B)\nm.setIndexedMatrix!()\nm.mmed(3d)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 1    | 9    |\n| 2020.09.10 | 3    | 9.5  |\n| 2020.09.11 | 5    | 9    |\n| 2020.09.12 | 5    | 6    |\n| 2020.09.13 | 2    | 2    |\n\n```\nm.mmed(1w)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 1    | 9    |\n| 2020.09.10 | 3    | 9.5  |\n| 2020.09.11 | 5    | 9    |\n| 2020.09.12 | 3    | 9    |\n| 2020.09.13 | 2    | 5.5  |\n\nRelated functions: [med](https://docs.dolphindb.com/en/Functions/m/med.html)\n"
    },
    "mmin": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mmin.html",
        "signatures": [
            {
                "full": "mmin(X, window, [minPeriods])",
                "name": "mmin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mmin](https://docs.dolphindb.com/en/Functions/m/mmin.html)\n\n\n\n#### Syntax\n\nmmin(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving minimums of *X* in a sliding window.\n\n#### Examples\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmmin(X, 3);\n// output\n[,,1,1,3,5,4]\n\nmmin(Y, 3);\n// output\n[,,1,1,3,5,4]\n\nmmin(Y, 3, minPeriods=1);\n// output\n[2,1,1,1,3,5,4]\n```\n\n```\nm = matrix(1 5 9 0 2 8 -1 5, 9 10 2 NULL -1 10 2 3)\nm.rename!(date(2020.09.10)+1..8, `A`B)\nm.setIndexedMatrix!()\nm.mmin(3d)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.11 | 1    | 9    |\n| 2020.09.12 | 1    | 9    |\n| 2020.09.13 | 1    | 2    |\n| 2020.09.14 | 0    | 2    |\n| 2020.09.15 | 0    | (1)  |\n| 2020.09.16 | 0    | (1)  |\n| 2020.09.17 | (1)  | (1)  |\n| 2020.09.18 | (1)  | 2    |\n\n```\nm.mmin(1w)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.11 | 1    | 9    |\n| 2020.09.12 | 1    | 9    |\n| 2020.09.13 | 1    | 2    |\n| 2020.09.14 | 0    | 2    |\n| 2020.09.15 | 0    | (1)  |\n| 2020.09.16 | 0    | (1)  |\n| 2020.09.17 | (1)  | (1)  |\n| 2020.09.18 | (1)  | (1)  |\n\nRelated function: [min](https://docs.dolphindb.com/en/Functions/m/min.html)\n"
    },
    "mmse": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mmse.html",
        "signatures": [
            {
                "full": "mmse(Y, X, window, [minPeriods])",
                "name": "mmse",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mmse](https://docs.dolphindb.com/en/Functions/m/mmse.html)\n\n\n\n#### Syntax\n\nmmse(Y, X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for windowing logic.\n\n#### Arguments\n\n**Y** is a vector indicating the dependent variable.\n\n**X** is a vector indicating the independent variable.\n\n**window** is an integer no smaller than 2 or a scalar of DURATION type indicating the size of the sliding window. Note: The window size is capped at 102400 when m-functions are used in the streaming engines.\n\n**minPeriods** (optional) is a positive integer indicating the minimum number of observations in a window required to be not NULL (otherwise the result is NULL).\n\n#### Details\n\nReturn the coefficient estimates of *X* and mean square errors of an ordinary-least-squares regression of *Y* on *X* with intercept with a rolling window. The length of the window is given by the parameter *window*.\n\nThe mean square error (MSE) is calculated with the following formula:\n\n![](https://docs.dolphindb.com/en/images/mmse.png)\n\nThe result is a tuple with 2 vectors. The first vector is the coefficient estimates and the second vector is the mean square errors. Each vector is of the same length as *X* and *Y*.\n\n#### Examples\n\n```\nx=0.011 0.006 -0.008 0.012 -0.016 -0.023 0.018\ny=0.016 0.009 -0.012 0.022 0.003 -0.056 0.002;\n\nmmse(y, x, 5)[0];\n// output\n[,,,,0.818182,1.692379,1.188532]\n\nmmse(y, x, 5)[1];\n// output\n[,,,,0.000055,0.000231,0.000332]\n\nselect y, x, mmse(y,x,5,3) as `mbeta`mmse from table(x,y);\n```\n\n| y      | x      | mbeta    | mmse        |\n| ------ | ------ | -------- | ----------- |\n| 0.016  | 0.011  |          |             |\n| 0.009  | 0.006  |          |             |\n| -0.012 | -0.008 | 1.479381 | 2.806415E-8 |\n| 0.022  | 0.012  | 1.594701 | 0.000003    |\n| 0.003  | -0.016 | 0.818182 | 0.000055    |\n| -0.056 | -0.023 | 1.692379 | 0.000231    |\n| 0.002  | 0.018  | 1.188532 | 0.000332    |\n"
    },
    "mod": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mod.html",
        "signatures": [
            {
                "full": "mod(X, Y)",
                "name": "mod",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [mod](https://docs.dolphindb.com/en/Functions/m/mod.html)\n\n\n\n#### Syntax\n\nmod(X, Y)\n\n#### Arguments\n\n**X** / **Y** is a scalar/pair/vector/matrix. If *X* or *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\n`Mod` means modulus. It returns the element-by-element remainder of *X* divided by *Y*. When *Y* is a positive integer, the modulus is always non-negative, e.g., -10 % 3 is 2. When *Y* is a negative integer, the modulus is always non-positive, e.g., -10 % -3 is -1. `mod` is often used to group data. For example, \\[5,4,3,3,5,6]%3 is \\[2,1,0,0,2,0]; data can thereby be divided into three groups.\n\n#### Examples\n\n```\nx=1 2 3;\nx % 2;\n// output\n[1,0,1]\n\n2 % x;\n// output\n[0,0,2]\n\ny=4 5 6;\nx mod y;\n// output\n[1,2,3]\nmod(y, x);\n// output\n[0,1,0]\n\nm=1..6$2:3;\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm mod 3;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 0  | 2  |\n| 2  | 1  | 0  |\n\n```\nx=-1 2 3;\nx%-5;\n// output\n[-1,-3,-2]\n\n-1%5;\n// output\n4\n```\n"
    },
    "mode": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mode.html",
        "signatures": [
            {
                "full": "mode(X)",
                "name": "mode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [mode](https://docs.dolphindb.com/en/Functions/m/mode.html)\n\n\n\n#### Syntax\n\nmode(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nIf *X* is a vector, calculate the most frequently occurring value in *X*.\n\nIf *X* is a matrix/table, calculate the most frequently occurring value in each column of *X* and return a vector/table.\n\nThis function counts the occurrences of unique values (keys) in *X* using a hash table. If there are multiple keys with the highest count, the function returns the first key in the hash table. Note that the hash algorithm used by this function varies for different data types, so the output results may differ.\n\nAs with all aggregate functions, NULL values are not included in the calculation.\n\n#### Examples\n\n```\nmode 2;\n// output\n2\n\nmode 1 3 3 3 4 5 5;\n// output\n3\n\nmode `test;\n// output\ntest\n\nm=matrix(1 1 2 2 2 3, 4 4 5 6 6 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 1  | 4  |\n| 2  | 5  |\n| 2  | 6  |\n| 2  | 6  |\n| 3  | 6  |\n\n```\nmode m;\n// output\n[2,6]\n```\n\nRelated functions: [mean](https://docs.dolphindb.com/en/Functions/m/mean.html) and [med](https://docs.dolphindb.com/en/Functions/m/med.html)\n"
    },
    "month": {
        "url": "https://docs.dolphindb.com/en/Functions/m/month.html",
        "signatures": [
            {
                "full": "month(X)",
                "name": "month",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [month](https://docs.dolphindb.com/en/Functions/m/month.html)\n\n\n\n#### Syntax\n\nmonth(X)\n\n#### Arguments\n\n**X** is a temporal scalar/vector.\n\n#### Details\n\nReturn the corresponding month(s).\n\n#### Examples\n\n```\nmonth(2012.12.03);\n// output\n2012.12M\n```\n\nRelated functions: [second](https://docs.dolphindb.com/en/Functions/s/second.html), [minute](https://docs.dolphindb.com/en/Functions/m/minute.html), [hour](https://docs.dolphindb.com/en/Functions/h/hour.html), [date](https://docs.dolphindb.com/en/Functions/d/date.html), [year](https://docs.dolphindb.com/en/Functions/y/year.html).\n"
    },
    "monthBegin": {
        "url": "https://docs.dolphindb.com/en/Functions/m/monthBegin.html",
        "signatures": [
            {
                "full": "monthBegin(X, [offset], [n=1])",
                "name": "monthBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [monthBegin](https://docs.dolphindb.com/en/Functions/m/monthBegin.html)\n\n\n\n#### Syntax\n\nmonthBegin(X, \\[offset], \\[n=1])\n\nAlias: monthStart\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**offset** is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the first day of the month that *X* belongs to.\n\nIf parameter *offset* is specified, the result is updated every *n* months. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nmonthBegin(2016.12.06);\n// output\n2016.12.01\n\ndate=2016.04.12 2016.04.25 2016.05.12 2016.06.28 2016.07.10 2016.07.18 2016.08.02 2016.08.16 2016.09.26 2016.09.30\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2016.05.12 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2016.06.11 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2016.07.11 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2016.08.10 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.09.09 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2016.10.09 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2016.11.08 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2016.12.08 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2017.01.07 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2017.02.06 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by monthBegin(date,2016.01.01,2);\n```\n\n| monthBegin\\_date | avg\\_price | sum\\_qty |\n| ---------------- | ---------- | -------- |\n| 2016.03.01       | 39.53      | 4100     |\n| 2016.05.01       | 29.77      | 5300     |\n| 2016.07.01       | 112.82     | 16000    |\n| 2016.09.01       | 51.835     | 13300    |\n\nRelated functions: [monthEnd](https://docs.dolphindb.com/en/Functions/m/monthEnd.html), [businessMonthBegin](https://docs.dolphindb.com/en/Functions/b/businessMonthBegin.html), [businessMonthEnd](https://docs.dolphindb.com/en/Functions/b/businessMonthEnd.html), [semiMonthBegin](https://docs.dolphindb.com/en/Functions/s/semiMonthBegin.html), [semiMonthEnd](https://docs.dolphindb.com/en/Functions/s/semiMonthEnd.html)\n"
    },
    "monthEnd": {
        "url": "https://docs.dolphindb.com/en/Functions/m/monthEnd.html",
        "signatures": [
            {
                "full": "monthEnd(X, [offset], [n=1])",
                "name": "monthEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [monthEnd](https://docs.dolphindb.com/en/Functions/m/monthEnd.html)\n\n\n\n#### Syntax\n\nmonthEnd(X, \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**offset** is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the last day of the month that *X* belongs to.\n\nIf parameter *offset* is specified, the result is updated every *n* months. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nmonthEnd(2012.06.12);\n// output\n2012.07.31\n\ndate=2016.04.12+(1..10)*30\ntime = take(09:30:00, 10)\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2016.05.12 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2016.06.11 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2016.07.11 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2016.08.10 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.09.09 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2016.10.09 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2016.11.08 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2016.12.08 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2017.01.07 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2017.02.06 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by monthEnd(date,2016.01.31,2);\n```\n\n| monthEnd\\_date | avg\\_price | sum\\_qty |\n| -------------- | ---------- | -------- |\n| 2016.05.31     | 49.6       | 2200     |\n| 2016.07.31     | 29.49      | 4000     |\n| 2016.09.30     | 102.495    | 10000    |\n| 2016.11.30     | 112.995    | 6700     |\n| 2017.01.31     | 50.805     | 11300    |\n| 2017.03.31     | 52.38      | 4500     |\n\nRelated functions: [monthBegin](https://docs.dolphindb.com/en/Functions/m/monthBegin.html), [businessMonthBegin](https://docs.dolphindb.com/en/Functions/b/businessMonthBegin.html), [businessMonthEnd](https://docs.dolphindb.com/en/Functions/b/businessMonthEnd.html), [semiMonthBegin](https://docs.dolphindb.com/en/Functions/s/semiMonthBegin.html), [semiMonthEnd](https://docs.dolphindb.com/en/Functions/s/semiMonthEnd.html)\n"
    },
    "monthOfYear": {
        "url": "https://docs.dolphindb.com/en/Functions/m/monthOfYear.html",
        "signatures": [
            {
                "full": "monthOfYear(X)",
                "name": "monthOfYear",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [monthOfYear](https://docs.dolphindb.com/en/Functions/m/monthOfYear.html)\n\n\n\n#### Syntax\n\nmonthOfYear(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, MONTH, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nFor each element in *X*, return a number from 1 to 12 indicating which month of the year it falls in.\n\n#### Examples\n\n```\nmonthOfYear(2012.07.02);\n// output\n7\n\nmonthOfYear([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n// output\n[6,10,1,4]\n```\n\nRelated functions: [dayOfYear](https://docs.dolphindb.com/en/Functions/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.com/en/Functions/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.com/en/Functions/q/quarterOfYear.html), [weekOfYear](https://docs.dolphindb.com/en/Functions/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.com/en/Functions/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.com/en/Functions/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.com/en/Functions/m/millisecond.html), [microsecond](https://docs.dolphindb.com/en/Functions/m/microsecond.html), [nanosecond](https://docs.dolphindb.com/en/Functions/n/nanosecond.html)\n"
    },
    "move": {
        "url": "https://docs.dolphindb.com/en/Functions/m/move.html",
        "signatures": [
            {
                "full": "move(X, steps)",
                "name": "move",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "steps",
                        "name": "steps"
                    }
                ]
            }
        ],
        "markdown": "### [move](https://docs.dolphindb.com/en/Functions/m/move.html)\n\n\n\n#### Syntax\n\nmove(X, steps)\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n**steps** is an integer indicating how many positions to shift the elements of *X*.\n\n* If *steps* is positive, *X* is moved to the right for *steps* positions;\n* If *steps* is negative, *X* is moved to the left for *steps* positions;\n* If *steps* is 0, *X* does not move;\n* If *steps* is a DURATION, *X* must be an indexed matrix or indexed series with temporal values as its row index.\n\n#### Details\n\n`move` is the general form of [prev](https://docs.dolphindb.com/en/Functions/p/prev.html) and [next](https://docs.dolphindb.com/en/Functions/n/next.html).\n\n#### Examples\n\n```\nx=3 9 5 1 4 9;\nmove(x,3);\n// output\n[,,,3,9,5]\n\nmove(x,-2);\n// output\n[5,1,4,9,,]\n\nindex = (second(08:20:00)+1..4) join 08:21:01 join 08:21:02\nx = index.indexedSeries(x)\nmove(x,3s)\n```\n\n| label    | col1 |\n| -------- | ---- |\n| 08:20:01 |      |\n| 08:20:02 |      |\n| 08:20:03 |      |\n| 08:20:04 | 3    |\n| 08:21:01 | 1    |\n| 08:21:02 | 1    |\n\n```\nmove(x,1m)\n```\n\n| label    | col1 |\n| -------- | ---- |\n| 08:20:01 |      |\n| 08:20:02 |      |\n| 08:20:03 |      |\n| 08:20:04 |      |\n| 08:21:01 | 3    |\n| 08:21:02 | 9    |\n"
    },
    "moveChunksAcrossVolume": {
        "url": "https://docs.dolphindb.com/en/Functions/m/moveChunksAcrossVolume.html",
        "signatures": [
            {
                "full": "moveChunksAcrossVolume(srcPath, destPath, chunkIds, [isDelSrc=true])",
                "name": "moveChunksAcrossVolume",
                "parameters": [
                    {
                        "full": "srcPath",
                        "name": "srcPath"
                    },
                    {
                        "full": "destPath",
                        "name": "destPath"
                    },
                    {
                        "full": "chunkIds",
                        "name": "chunkIds"
                    },
                    {
                        "full": "[isDelSrc=true]",
                        "name": "isDelSrc",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [moveChunksAcrossVolume](https://docs.dolphindb.com/en/Functions/m/moveChunksAcrossVolume.html)\n\n**Note:** This function will be deprecated in a future version. We recommend you use the function [moveReplicas](https://docs.dolphindb.com/en/Functions/m/moveReplicas.html).\n\n\n\n#### Syntax\n\nmoveChunksAcrossVolume(srcPath, destPath, chunkIds, \\[isDelSrc=true])\n\n#### Arguments\n\n**srcPath** is a string in the format of *volumeA/CHUNKS*, indicating the source volume of the chunks.\n\n**destPath** is a string in the format of *volumeB/CHUNKS*, indicating the destination volume of the chunks.\n\n**chunkIds** is a string scalar or vector, indicating the chunk IDs to be moved.\n\n**isDelSrc** is a Boolean value indicating whether to delete the source volume after copying the chunks. The default value is true.\n\nNote: *srcPath*, *destPath*, and *chunkIds* can be obtained with function [getChunksMeta](https://docs.dolphindb.com/en/Functions/g/getChunksMeta.html).\n\n#### Details\n\nMove the chunks from the source volume to the destination volume on the same node. When *isDelSrc* = true, chunks are moved to the destination volume, otherwise they are copied. If the transfer fails, all chunks of the source volume are retained, and chunks that have been copied are removed from the destination volume.\n\n**Note:**\n\n* Chunks can only be moved within the same node.\n\n* Before moving the chunks, make sure that there is no writing process on the current node, all transactions have been completed, and all buffers have been synchronized to the disk.\n\n* The configuration parameter *volumes* must contain the volumes specified by parameters *scrPath* and *destPath*. The server must be rebooted after the configuration parameters are modified for them to take effect.\n\n* The volume specified by *destPath* must be empty.\n"
    },
    "moveHotDataToColdVolume": {
        "url": "https://docs.dolphindb.com/en/Functions/m/moveHotDataToColdVolume.html",
        "signatures": [
            {
                "full": "moveHotDataToColdVolume([checkRange=240])",
                "name": "moveHotDataToColdVolume",
                "parameters": [
                    {
                        "full": "[checkRange=240]",
                        "name": "checkRange",
                        "optional": true,
                        "default": "240"
                    }
                ]
            }
        ],
        "markdown": "### [moveHotDataToColdVolume](https://docs.dolphindb.com/en/Functions/m/moveHotDataToColdVolume.html)\n\n#### Syntax\n\nmoveHotDataToColdVolume(\\[checkRange=240])\n\n#### Arguments\n\n`checkRange` is an integer indicating the time range (in hours). The default value is 240, i.e., 10 days. If the parameter is specified, data within the range of \\[current time-hoursToColdVolumes-checkRange, current time-hoursToColdVolumes) will be migrated to *coldVolumes*.\n\n#### Details\n\nMigrate the specified data to *coldVolumes*.\n\nThe migration policy of `moveHotDataToColdVolume` is different from [setRetentionPolicy](https://docs.dolphindb.com/en/Functions/s/setRetentionPolicy.html). See [Tiered Storage](https://docs.dolphindb.com/en/Database/tiered_storage.html) for more information.\n\n"
    },
    "moveReplicas": {
        "url": "https://docs.dolphindb.com/en/Functions/m/moveReplicas.html",
        "signatures": [
            {
                "full": "moveReplicas(srcNode, destNode, chunkId, [destVolumes])",
                "name": "moveReplicas",
                "parameters": [
                    {
                        "full": "srcNode",
                        "name": "srcNode"
                    },
                    {
                        "full": "destNode",
                        "name": "destNode"
                    },
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    },
                    {
                        "full": "[destVolumes]",
                        "name": "destVolumes",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [moveReplicas](https://docs.dolphindb.com/en/Functions/m/moveReplicas.html)\n\n\n\n#### Syntax\n\nmoveReplicas(srcNode, destNode, chunkId, \\[destVolumes])\n\n#### Arguments\n\n**srcNode** is a string indicating the alias of origination node.\n\n**destNode** is a string indicating the alias of destination node.\n\n**chunkId** is a string/UUID scalar or vector indicating ID of chunks.\n\n**destVolumes** (optional) is a STRING scalar or vector indicating the dest volume(s) on the target node. The directories must be included in the configured *volumes*. If a vector is provided, replicas will preferentially be moved to the volume at the beginning of the vector.\n\n#### Details\n\nMove replicas of one or multiple chunks from the source node to the destination node. If the destination node already has the chunk, the command is skipped.\n\nThis command can only be executed by an administrator on a controller node.\n\nWe can check the execution status with function [getRecoveryTaskStatus](https://docs.dolphindb.com/en/Functions/g/getRecoveryTaskStatus.html).\n\n#### Examples\n\nMove replicas of all chunks on \"node1\" to \"node2\".\n\n```\nchunkIds=exec chunkId from pnodeRun(getChunksMeta) where node=\"node1\"\nmoveReplicas(srcNode=\"node1\",destNode=\"node2\",chunkId=chunkIds,destVolumes=\"/ddb/server/clusterDemo/data/node2/storage\");\n```\n"
    },
    "movingTopNIndex": {
        "url": "https://docs.dolphindb.com/en/Functions/m/movingTopNIndex.html",
        "signatures": [
            {
                "full": "movingTopNIndex(X, window, top, [ascending=true], [fixed=false], [tiesMethod='oldest'])",
                "name": "movingTopNIndex",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[fixed=false]",
                        "name": "fixed",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [movingTopNIndex](https://docs.dolphindb.com/en/Functions/m/movingTopNIndex.html)\n\n\n\n#### Syntax\n\nmovingTopNIndex(X, window, top, \\[ascending=true], \\[fixed=false], \\[tiesMethod='oldest'])\n\n#### Arguments\n\n**X** is a numeric/temporal vector. Note: Starting from version 2.00.10, the NULL values in X do not participate in data sorting.\n\n**window** is an integer no less than 2, indicating the window size.\n\n**top** is an integer greater than 1 and no greater than *window*.\n\n**ascending** is a Boolean value indicating whether the data within a window is sorted in ascending order. True means ascending order and false means descending order.\n\n**fixed** is a Boolean value, indicating whether the length of each row in the output array vector is fixed to be *top*. The default value is false. When *fixed* = true, all rows are of the same length. For the first (*top* - 1) windows, the indices of missing elements are replaced with NULL.\n\n**tiesMethod** is a string that specifies how to select elements if there are more elements with the same value than spots available in the top N after sorting *X* within a sliding window. It can be:\n\n* 'oldest': select elements starting from the earliest entry into the window;\n\n* 'latest': select elements starting from the latest entry into the window.\n\n#### Details\n\nReturn an array vector indicating the indices of the first *top* elements of *X* after sorted within each sliding window.\n\n#### Examples\n\n```\nS = 2 5 6 1 2 4 5 6 9 0\nm1 = movingTopNIndex(X=S, window=4, top=2, ascending=true, fixed=true)\nm1;\n// output\n[[00i,0],[0,1],[0,1],[3,0],[3,4],[3,4],[3,4],[4,5],[5,6],[9,6]]\n\nm2 = movingTopNIndex(X=S, window=4, top=2, ascending=false, fixed=true)\nm2;\n// output\n[[00i,0],[1,0],[2,1],[2,1],[2,1],[2,5],[6,5],[7,6],[8,7],[8,7]]\n\nm3 = movingTopNIndex(X=S, window=4, top=2, ascending=true, fixed=false)\nprint m3;\n// output\n[[0],[0,1],[0,1],[3,0],[3,4],[3,4],[3,4],[4,5],[5,6],[9,6]]\n\nS[m1[0]]\n// output\n[,2,2,1,1,1,1,2,4,0]\n\nS[m3[0]]\n// output\n[2,2,2,1,1,1,1,2,4,0]\n```\n\n```\nX = [5, 8, 1, 9, 7, 3, 1, NULL, 0, 8, 7, 7]\nmovingTopNIndex(X=X, window=4, top=2, ascending=true, fixed=true)\n// Before version 2.00.10, the NULL values in X are involved in data sorting.\n// output\n[[00i,0],[0,1],[2,0],[2,0],[2,4],[2,5],[6,5],[7,6],[7,8],[7,8],[7,8],[8,10]]\n// As of version 2.00.10, the NULL values in X are ignored in data sorting.\n// output\n[[00i,0],[0,1],[2,0],[2,0],[2,4],[2,5],[6,5],[6,5],[8,6],[8,6],[8,10],[8,10]]\n\nX = [2, 1, 4, 3, 4, 3, 4]\n// For the sixth window, the sorted X is 1 2 3 3 4 4.\n// As tiesMethod is not specified, the default 'oldest' is used, meaning the first occurrence of 3 (at index 3) is selected.\nmovingTopNIndex(X,6,3)\n// output\n[[0],[1,0],[1,0,2],[1,0,3],[1,0,3],[1,0,3],[1,3,5]]]\n\n// As tiesMethod is set to 'latest', the latest occurrence of 3 (at index 5) is selected.\nmovingTopNIndex(X,6,3,tiesMethod=\"latest\")\n// output\n[[0],[1,0],[1,0,2],[1,0,3],[1,0,3],[1,0,5],[1,3,5]]\n```\n"
    },
    "movingWindowData": {
        "url": "https://docs.dolphindb.com/en/Functions/m/movingWindowData.html",
        "signatures": [
            {
                "full": "movingWindowData(X, window, [fixed=false])",
                "name": "movingWindowData",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[fixed=false]",
                        "name": "fixed",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [movingWindowData](https://docs.dolphindb.com/en/Functions/m/movingWindowData.html)\n\n#### Syntax\n\nmovingWindowData(X, window, \\[fixed=false])\n\n#### Arguments\n\n`X` is a vector.\n\n`window` is an integer greater than or equal to 2. It indicates the size of a count-based window.\n\n`fixed` is a Boolean specifying whether the size of each row of the result must be fixed to *window*. When *fixed*=true, the missing elements in the first (window-1) windows are filled with NULL. The default value is false.\n\n#### Details\n\nReturn an array vector where each row indicates the elements of a window sliding over *X*.\n\n#### Examples\n\n```\nS = -1 3 -4 0 5 10 9 7\n m = movingWindowData(X=S,window=3);\n m;\n// output\n[[-1],[-1,3],[-1,3,-4],[3,-4,0],[-4,0,5],[0,5,10],[5,10,9],[10,9,7]]\n\nmi = movingWindowData(X=S,window=3,fixed=true);\nmi;\n// output\n[[00i,00i,-1],[00i,-1,3],[-1,3,-4],[3,-4,0],[-4,0,5],[0,5,10],[5,10,9],[10,9,7]]\n    \n// get the value of the first element in each window\nm[0]\n// output\n[-1,-1,-1,3,-4,0,5,10]\n\nmi[0]\n// output\n[,,-1,3,-4,0,5,10]\n\n//Get the data with a sliding window of length 5 in the reactive state engine\nn = 100\nDateTime = 2023.01.01T09:00:00 + rand(10000, n).sort!()\nSecurityID = take(`600021`600022`600023`600024`600025, n)\nPrice = 1.0 + rand(1.0, n) \nt = table(1:0, `DateTime`SecurityID`Price, [TIMESTAMP, SYMBOL, DOUBLE])\ntableInsert(t, DateTime, SecurityID, Price)\noutput = table(100:0, `SecurityID`DateTime`PriceNew, [SYMBOL, DATETIME, DOUBLE[]])\n\nengine = createReactiveStateEngine(name=\"rseEngine\", metrics=[<DateTime>, <movingWindowData(Price,5)>], dummyTable=t, outputTable=output, keyColumn=`SecurityID, keepOrder=true)\nengine.append!(t)\ndropStreamEngine(`rseEngine)\n```\n\n"
    },
    "movingWindowIndex": {
        "url": "https://docs.dolphindb.com/en/Functions/m/movingWindowIndex.html",
        "signatures": [
            {
                "full": "movingWindowIndex(X, window, [fixed=false])",
                "name": "movingWindowIndex",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[fixed=false]",
                        "name": "fixed",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [movingWindowIndex](https://docs.dolphindb.com/en/Functions/m/movingWindowIndex.html)\n\n\n\n#### Syntax\n\nmovingWindowIndex(X, window, \\[fixed=false])\n\n#### Arguments\n\n**X** is a vector.\n\n**window** is an integer no less than 2 indicating the window size.\n\n**fixed** is a Boolean value, indicating whether the length of each row in the output array vector is fixed to be *window*. The default value is false. When *fixed* = true, all rows are of the same length. For the first (*window* - 1) windows, the indices of missing elements are filled with NULL.\n\n#### Details\n\nReturn an array vector indicating the indices of the elements of *X* within each sliding window.\n\n#### Examples\n\n```\nS = 1 2 3 4 5 6 7 8 9 0;\nm = movingWindowIndex(X=S,window=3);\nm;\n// output\n[[0],[0,1],[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9]]\n\nmi = movingWindowIndex(X=S,window=3,fixed=true);\nmi;\n// output\n[[,,0],[,0,1],[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9]]\n\n// obtain the first element from each window\nS[m[0]]\n// output\n[1,1,1,2,3,4,5,6,7,8]\n\nS[mi[0]]\n// output\n[,,1,2,3,4,5,6,7,8]\n```\n"
    },
    "mpercentile": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mpercentile.html",
        "signatures": [
            {
                "full": "mpercentile(X, percent, window, [interpolation='linear'], [minPeriods])",
                "name": "mpercentile",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "percent",
                        "name": "percent"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mpercentile](https://docs.dolphindb.com/en/Functions/m/mpercentile.html)\n\n\n\n#### Syntax\n\nmpercentile(X, percent, window, \\[interpolation='linear'], \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**percent** is an integer or floating value between 0 and 100.\n\n**interpolation** is a string indicating the interpolation method to use if the specified percentile is between two elements in *X* (assuming the ith and (i+1)th element in the sorted *X*) . It can take the following values:\n\n* 'linear': Return ![](https://docs.dolphindb.com/en/images/linear.png), where ![](https://docs.dolphindb.com/en/images/fraction.png)\n\n* 'lower': Return ![](https://docs.dolphindb.com/en/images/lower.png)\n\n* 'higher': Return ![](https://docs.dolphindb.com/en/images/higher.png)\n\n* 'nearest': Return ![](https://docs.dolphindb.com/en/images/nearest.png) that is closest to the specified percentile\n\n* 'midpoint': Return ![](https://docs.dolphindb.com/en/images/midpoint.png)\n\nThe default value of *interpolation* is 'linear'.\n\n**minPeriods** is a positive integer indicating the minimum number of observations in a window required to be not NULL (otherwise the result is NULL).\n\n#### Details\n\nReturn the percentile rank of each element of *X* in a sliding window.\n\n#### Examples\n\n```\nx=2 1 3 7 6 5 4;\nmpercentile(x, percent=50, window=3);\n// output\n[,,2,3,6,6,5]\n\nmpercentile(x, percent=25, window=3, interpolation=\"lower\");\n// output\n[,,1,1,3,5,4]\n\nmpercentile(x, percent=75, window=3, interpolation=\"higher\")\n// output\n[,,3,7,7,7,6]\n\nmpercentile(x, percent=5, window=3, interpolation=\"nearest\")\n// output\n[,,1,1,3,5,4]\n\nmpercentile(x, percent=15, window=3, interpolation=\"midpoint\")\n// output\n[,,1.5,2,4.5,5.5,4.5]\n\nmpercentile(x, percent=50, window=3, interpolation=\"linear\", minPeriods=1);\n// output\n[2,1.5,2,3,6,6,5]\n\nm=matrix(2 1 3 7 6 5 4, 1..7);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 2  | 1  |\n| 1  | 2  |\n| 3  | 3  |\n| 7  | 4  |\n| 6  | 5  |\n| 5  | 6  |\n| 4  | 7  |\n\n```\nmpercentile(m, percent=50, window=3, interpolation=\"linear\", minPeriods=1);\n```\n\n| #0  | #1  |\n| --- | --- |\n| 2   | 1   |\n| 1.5 | 1.5 |\n| 2   | 2   |\n| 3   | 3   |\n| 6   | 4   |\n| 6   | 5   |\n| 5   | 6   |\n\n```\nm.rename!(date(2020.09.08)+1..7, `A`B)\nm.setIndexedMatrix!()\nmpercentile(m, percent=50, window=3d, interpolation=\"linear\", minPeriods=1);\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 2    | 1    |\n| 2020.09.10 | 1.5  | 1.5  |\n| 2020.09.11 | 2    | 2    |\n| 2020.09.12 | 3    | 3    |\n| 2020.09.13 | 6    | 4    |\n| 2020.09.14 | 6    | 5    |\n| 2020.09.15 | 5    | 6    |\n\n```\nmpercentile(m, percent=50, window=1w, interpolation=\"linear\", minPeriods=1);\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 2    | 1    |\n| 2020.09.10 | 1.5  | 1.5  |\n| 2020.09.11 | 2    | 2    |\n| 2020.09.12 | 2.5  | 2.5  |\n| 2020.09.13 | 3    | 3    |\n| 2020.09.14 | 4    | 3.5  |\n| 2020.09.15 | 4    | 4    |\n\nRelated functions: [percentile](https://docs.dolphindb.com/en/Functions/p/percentile.html)\n"
    },
    "mpercentileTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mpercentileTopN.html",
        "signatures": [
            {
                "full": "mpercentileTopN(X, S, percent, window, top, [interpolation], [ascending], [tiesMethod='oldest'])",
                "name": "mpercentileTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "percent",
                        "name": "percent"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[interpolation]",
                        "name": "interpolation",
                        "optional": true
                    },
                    {
                        "full": "[ascending]",
                        "name": "ascending",
                        "optional": true
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mpercentileTopN](https://docs.dolphindb.com/en/Functions/m/mpercentileTopN.html)\n\n#### Syntax\n\nmpercentileTopN(X, S, percent, window, top, \\[interpolation], \\[ascending], \\[tiesMethod='oldest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**X** is a numeric vector, matrix or table.\n\n**S** is a numeric/temporal vector, matrix or table, based on which *X* are sorted.\n\n**percent** is an integer or floating value between 0 and 100.\n\n**interpolation** (optional) is a string indicating the interpolation method to use if the specified percentile is between two elements in *X* (assuming the ith and (i+1)th element in the sorted *X*) . It can take the following values:\n\n* 'linear' (default): Return Xi+ (Xi+1 - Xi)\\* fraction, where ![](https://docs.dolphindb.com/en/images/fraction.png)\n\n* 'lower': Return Xi\n\n* 'higher': Return Xi+1\n\n* 'nearest': Return Xi+1 or Xithat is closest to the specified percentile\n\n* 'midpoint': Return (Xi+1 + Xi)/2\n\n#### Details\n\n* When *X*is a vector, within a sliding window of given length (measured by the number of elements), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the moving percentile rank of the first *top* elements.\n\n* When *X*is a matrix or table, conduct the aforementioned calculation within each column of *X*. The result is a matrix/table with the same shape as *X*.\n\n#### Examples\n\nWhen *X* is a vector:\n\n```\nx =  [2,,8,0,4,,6,3,5,7] \ns = [,1,8,7,9,6,5,0,4,3]\nmpercentileTopN(x, s, percent=25, window=6, top=3, interpolation=\"lower\")\n// output: [,,8,0,0,0,6,3,3,3]\n\nmpercentileTopN(x, s, percent=75, window=6, top=3, interpolation=\"higher\")\n// output: [,,8,8,8,0,6,6,6,7]\n\nmpercentileTopN(x, s, percent=5, window=6, top=3, interpolation=\"nearest\")\n// output: [,,8,0,0,0,6,3,3,3]\n\nmpercentileTopN(x, s, percent=15, window=6, top=3, interpolation=\"midpoint\")\n// output: [,,8,4,4,0,6,4.5,4,4]\n\nmpercentileTopN(x, s, percent=50, window=6, top=3, interpolation=\"linear\")\n// output: [,,8,4,4,0,6,4.5,5,5]\n```\n\nWhen *X* is a matrix:\n\n```\nx = [8,,1,6,9,2,0,,5,3,2,,8,0,4,,6,3,5,7]$10:2\ns = [,1,8,7,9,6,5,0,4,3]\nmpercentileTopN(x, s, percent=15, window=6, top=3, interpolation=\"midpoint\")\n```\n\nOutput:\n\n| #0  | #1  |\n| --- | --- |\n|     |     |\n|     |     |\n| 1   | 8   |\n| 3.5 | 4   |\n| 3.5 | 4   |\n| 4   | 0   |\n| 1   | 6   |\n| 1   | 4.5 |\n| 2.5 | 4   |\n| 4   | 4   |\n\n"
    },
    "mprod": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mprod.html",
        "signatures": [
            {
                "full": "mprod(X, window, [minPeriods])",
                "name": "mprod",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mprod](https://docs.dolphindb.com/en/Functions/m/mprod.html)\n\n\n\n#### Syntax\n\nmprod(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving products of *X* in a sliding window.\n\n#### Examples\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmprod(X, 3);\n// output\n[,,6,21,126,210,120]\n\nmprod(Y, 3);\n// output\n[,,6,3,18,30,120]\n\nmprod(Y, 3, minPeriods=1);\n// output\n[2,2,6,3,18,30,120]\n```\n\n```\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmprod(m, 3d)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.04.07 | 1    | 9    |\n| 2020.04.08 | 1    | 9    |\n| 2020.04.09 | 4    | 9    |\n| 2020.04.10 | 4    | 10   |\n| 2020.04.11 | 32   | 10   |\n| 2020.04.12 | 48   | 20   |\n\n```\nmprod(m, 1w)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.04.07 | 1    | 9    |\n| 2020.04.08 | 1    | 9    |\n| 2020.04.09 | 4    | 9    |\n| 2020.04.10 | 4    | 90   |\n| 2020.04.11 | 32   | 90   |\n| 2020.04.12 | 192  | 180  |\n\nRelated functions: [prod](https://docs.dolphindb.com/en/Functions/p/prod.html)\n"
    },
    "mr": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mr.html",
        "signatures": [
            {
                "full": "mr(ds, mapFunc, [reduceFunc], [finalFunc], [parallel=true])",
                "name": "mr",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "mapFunc",
                        "name": "mapFunc"
                    },
                    {
                        "full": "[reduceFunc]",
                        "name": "reduceFunc",
                        "optional": true
                    },
                    {
                        "full": "[finalFunc]",
                        "name": "finalFunc",
                        "optional": true
                    },
                    {
                        "full": "[parallel=true]",
                        "name": "parallel",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [mr](https://docs.dolphindb.com/en/Functions/m/mr.html)\n\n\n\n#### Syntax\n\nmr(ds, mapFunc, \\[reduceFunc], \\[finalFunc], \\[parallel=true])\n\n#### Arguments\n\n**ds** is the list of data sources. This required parameter must be a tuple and each element of the tuple is a data source object. Even if there is only one data source, we still need a tuple to wrap the data source.\n\n**mapFunc** is the map function. It accepts one and only one argument, which is the materialized data entity from a data source. If we would like the map function to accept more parameters in addition to the materialized data source, we can use a [PartialApplication](https://docs.dolphindb.com/en/Programming/FunctionalProgramming/PartialApplication.html) to convert a multiple-parameter function to a unary function. The number of map function calls is the same as the number of data sources. The map function returns a regular object (scalar, pair, array, matrix, table, set, or dictionary) or a tuple (containing multiple regular objects).\n\n**reduceFunc** (optional) is the binary reduce function that combines two map function call results. The reduce function in most cases is trivial. An example is the addition function. The reduce function is optional. If the reduce function is not specified, the system returns all individual map call results to the final function.\n\n**finalFunc** (optional) is the final function which accepts one and only one parameter. The output of the last reduce function call is the input of the final function. If it is not specified, the system returns the individual map function call results.\n\n**parallel** (optional) is a boolean flag indicating whether to execute the map function in parallel locally. The default value is true, i.e., enabling parallel computing. When there is very limited available memory and each map call needs a large amount of memory, we can disable parallel computing to prevent the out-of-memory problem. We may also want to disable the parallel option in other scenarios. For example, we may need to disable the parallel option to prevent multiple threads from writing to the same partition simultaneously.\n\n#### Details\n\nThe Map-Reduce function is the core function of DolphinDB's generic distributed computing framework.\n\n#### Examples\n\nThe following is an example of distributed linear regression. Suppose *X* is the matrix of independent variables and *y* is the dependent variable. *X* and *y* are stored in multiple data sources. To estimate the ordinary least square parameters, we need to calculate X TX and X Ty. We can calculate the tuple of (X TX, X Ty) from each data source, then aggregate the results from all data sources to get X TX and XT y for the entire dataset.\n\n```\ndef myOLSMap(table, yColName, xColNames, intercept){\n    if(intercept)\n        x = matrix(take(1.0, table.rows()), table[xColNames])\n    else\n        x = matrix(table[xColNames])\n    xt = x.transpose();\n    return xt.dot(x), xt.dot(table[yColName])\n}\n\ndef myOLSFinal(result){\n    xtx = result[0]\n    xty = result[1]\n    return xtx.inv().dot(xty)[0]\n}\n\ndef myOLSEx(ds, yColName, xColNames, intercept){\n    return mr(ds, myOLSMap{, yColName, xColNames, intercept}, +, myOLSFinal)\n}\n```\n\nIn the example above, we define the map function and final function. In practice, we may define transformation functions for data sources as well. These functions only need to be defined in the local instance. Users don't need to compile them or deploy them to the remote instances. The distributed computing framework in DolphinDB handles these complicated issues for end users on the fly.\n\nAs a frequently used analytics tool, the distributed ordinary least square linear regression is implemented in the core library of DolphinDB already. The built-in version ([olsEx](https://docs.dolphindb.com/en/Functions/o/olsEx.html)) provides more features.\n"
    },
    "mrank": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mrank.html",
        "signatures": [
            {
                "full": "mrank(X, ascending, window, [ignoreNA=true], [tiesMethod='min'], [percent=false], [minPeriods])",
                "name": "mrank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "ascending",
                        "name": "ascending"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='min']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'min'"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mrank](https://docs.dolphindb.com/en/Functions/m/mrank.html)\n\n\n\n#### Syntax\n\nmrank(X, ascending, window, \\[ignoreNA=true], \\[tiesMethod='min'], \\[percent=false], \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**ascending** is a Boolean value indicating whether the sorting direction is ascending.\n\n**ignoreNA** is a Boolean value indicating whether NULL values are ignored in ranking. The default value is true. If NULL values participate in the ranking, they are ranked the lowest.\n\n**tiesMethod** is a string indicating how to rank the group of records with the same value (i.e., ties):\n\n* 'min': lowest rank of the group\n\n* 'max': highest rank of the group\n\n* 'average': average rank of the group\n\n**percent** is a Boolean value, indicating whether to display the returned rankings in percentile form. The default value is false.\n\n#### Details\n\nReturn the rank of each element of *X* in a sliding window.\n\n#### Examples\n\n```\nX = 3 2 4 4 4 NULL 1\n\nmrank(X, ascending=false, window=3, ignoreNA=true);\n// output: [,,0,0,0,,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=true, minPeriods=2);\n// output: [,1,0,0,0,,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='max');\n// output: [,,0,1,2,2,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='max', minPeriods=2);\n// output: [,1,0,1,2,2,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='min');\n// output: [,,0,0,0,2,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='min', minPeriods=3);\n// output: [,,0,0,0,,]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='average');\n// output: [,,0,0.5,1,2,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='average', minPeriods=2);\n// output: [,1,0,0.5,1,2,1]\n```\n\n```\nm=matrix(1 2 5 3 4, 5 4 1 2 3);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 2  | 4  |\n| 5  | 1  |\n| 3  | 2  |\n| 4  | 3  |\n\n```\nmrank(m, true, 3);\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 2  | 0  |\n| 1  | 1  |\n| 1  | 2  |\n\n```\nmrank(m, true, 3, percent=true);\n```\n\n| #0     | #1     |\n| ------ | ------ |\n|        |        |\n|        |        |\n| 1      | 0.3333 |\n| 0.6667 | 0.6667 |\n| 0.6667 | 1      |\n\nWhen window is the time offset of DURATION type:\n\n```\nm=matrix([1 4 2 4 5 7 4 3 2 5])\nm.rename!(2020.01.01..2020.01.10, [`A])\nm.setIndexedMatrix!()\nmrank(m, window=3d, percent = 1)\n```\n\n| label      | A      |\n| ---------- | ------ |\n| 2020.01.01 | 1      |\n| 2020.01.02 | 1      |\n| 2020.01.03 | 0.6667 |\n| 2020.01.04 | 0.6667 |\n| 2020.01.05 | 1      |\n| 2020.01.06 | 1      |\n| 2020.01.07 | 0.3333 |\n| 2020.01.08 | 0.3333 |\n| 2020.01.09 | 0.3333 |\n| 2020.01.10 | 1      |\n\n```\nmrank(m, window=1w, percent = 1)\n```\n\n| label      | A      |\n| ---------- | ------ |\n| 2020.01.01 | 1      |\n| 2020.01.02 | 1      |\n| 2020.01.03 | 0.6667 |\n| 2020.01.04 | 0.75   |\n| 2020.01.05 | 1      |\n| 2020.01.06 | 1      |\n| 2020.01.07 | 0.4286 |\n| 2020.01.08 | 0.2857 |\n| 2020.01.09 | 0.1429 |\n| 2020.01.10 | 0.7143 |\n\nRelated functions: [rank](https://docs.dolphindb.com/en/Functions/r/rank.html)\n"
    },
    "mskew": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mskew.html",
        "signatures": [
            {
                "full": "mskew(X, window, [biased=true], [minPeriods])",
                "name": "mskew",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mskew](https://docs.dolphindb.com/en/Functions/m/mskew.html)\n\n\n\n#### Syntax\n\nmskew(X, window, \\[biased=true], \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**biased** is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\n#### Details\n\nCalculate the moving skewness of *X* in a sliding window.\n\n#### Examples\n\n```\nmskew(1 2 3 10 100 4 3, 3);\n// output\n[,,0,0.665469,0.693810, 0.697217,0.706851]\n```\n\n```\nm=matrix(1 6 2 9 4 5 100, 100 11 12 18 23 21 10);\nm;\n```\n\n| #0  | #1  |\n| --- | --- |\n| 1   | 100 |\n| 6   | 11  |\n| 2   | 12  |\n| 9   | 18  |\n| 4   | 23  |\n| 5   | 21  |\n| 100 | 10  |\n\n```\nmskew(m,3);\n```\n\n| #0                 | #1                 |\n| ------------------ | ------------------ |\n|                    |                    |\n|                    |                    |\n| 0.595170064139498  | 0.706802122668126  |\n| -0.172800544078651 | 0.65201211704403   |\n| 0.470330460336986  | -0.110780117654834 |\n| 0.595170064139498  | -0.239063146929565 |\n| 0.706845142811354  | -0.642723256123865 |\n\n```\nm.rename!(date(2020.04.06)+1..7, `col1`col2)\nm.setIndexedMatrix!()\nmskew(m, 3d)\n```\n\n| label      | col1    | col2    |\n| ---------- | ------- | ------- |\n| 2020.04.07 |         |         |\n| 2020.04.08 | 0       | 0       |\n| 2020.04.09 | 0.5952  | 0.7068  |\n| 2020.04.10 | -0.1728 | 0.652   |\n| 2020.04.11 | 0.4703  | -0.1108 |\n| 2020.04.12 | 0.5952  | -0.2391 |\n| 2020.04.13 | 0.7068  | -0.6427 |\n\n```\nmskew(m, 1w)\n```\n\n| label      | col1   | col2   |\n| ---------- | ------ | ------ |\n| 2020.04.07 |        |        |\n| 2020.04.08 | 0      | 0      |\n| 2020.04.09 | 0.5952 | 0.7068 |\n| 2020.04.10 | 0.2743 | 1.1373 |\n| 2020.04.11 | 0.4079 | 1.4398 |\n| 2020.04.12 | 0.3298 | 1.7107 |\n| 2020.04.13 | 2.0188 | 1.9363 |\n\nRelated function: [skew](https://docs.dolphindb.com/en/Functions/s/skew.html)\n"
    },
    "mskewTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mskewTopN.html",
        "signatures": [
            {
                "full": "mskewTopN(X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "mskewTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [mskewTopN](https://docs.dolphindb.com/en/Functions/m/mskewTopN.html)\n\n\n\n#### Syntax\n\nmskewTopN(X, S, window, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**biased** (optional) is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the moving skewness of the first *top* elements.\n\n**Return value**: DOUBLE type.\n\n#### Examples\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmskewTopN(X, S, 6, 4)\n// output\n[,0,0,1.01,1.13,0.79,1.08]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\nmskewTopN(X, S, 6, 4)\n\n// output\ncol1  col2\n\n0\n0       0\n0       0\n0.4347  0\n-0.278  0.4347\n-0.4347 0\n0       -0.6872\n0       0\n0       0.4347\n\n\nsymbol = [\"A\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"B\",\"B\",\"A\",\"B\",\"A\",\"B\",\"B\",\"A\",\"B\",\"A\"]\ntime = temporalAdd(2023.07.03T09:30:00.000,[10,20,40,60,70,80,90,140,160,170,180,190,200,210,220,230,250,360,390,400],\"ms\")\nprice = [28.11,28.25,28.44,52.31,28.98,28.89,52.22,28.16,28.52,52.62,52.56,52.2,28.01,52.43,28.57,52.42,52.19,28.16,52.84,28.18]\nqty = [1900,3300,100,3000,3500,800,3400,4400,3900,4600,2200,2100,2300,4100,400,300,3100,2500,1000,2700]\nBSFlag = [1,0,1,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1]\nt = table(time, symbol, price, qty, BSFlag)\nselect time,symbol,BSFlag,mskewTopN(price, qty, 8, 5) as mskewTop5Price from t context by symbol,BSFlag\n```\n\n| time                    | symbol | BSFlag | mskewTop5Price |\n| ----------------------- | ------ | ------ | -------------- |\n| 2023.07.03T09:30:00.020 | A      | 0      |                |\n| 2023.07.03T09:30:00.070 | A      | 0      | 0              |\n| 2023.07.03T09:30:00.080 | A      | 0      | -0.6667        |\n| 2023.07.03T09:30:00.140 | A      | 0      | 0              |\n| 2023.07.03T09:30:00.160 | A      | 0      | 0.0904         |\n| 2023.07.03T09:30:00.200 | A      | 0      | -0.0986        |\n| 2023.07.03T09:30:00.220 | A      | 0      | -0.1794        |\n| 2023.07.03T09:30:00.010 | A      | 1      |                |\n| 2023.07.03T09:30:00.040 | A      | 1      | 0              |\n| 2023.07.03T09:30:00.360 | A      | 1      | 0.6448         |\n| 2023.07.03T09:30:00.400 | A      | 1      | 1.0153         |\n| 2023.07.03T09:30:00.170 | B      | 0      |                |\n| 2023.07.03T09:30:00.180 | B      | 0      | 0              |\n| 2023.07.03T09:30:00.230 | B      | 0      | -0.4451        |\n| 2023.07.03T09:30:00.060 | B      | 1      |                |\n| 2023.07.03T09:30:00.090 | B      | 1      | 0              |\n| 2023.07.03T09:30:00.190 | B      | 1      | 0.6156         |\n| 2023.07.03T09:30:00.210 | B      | 1      | 0.5605         |\n| 2023.07.03T09:30:00.250 | B      | 1      | 0.8565         |\n| 2023.07.03T09:30:00.390 | B      | 1      | 1.3966         |\n\nRelated function: [mskew](https://docs.dolphindb.com/en/Functions/m/mskew.html)\n"
    },
    "mslr": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mslr.html",
        "signatures": [
            {
                "full": "mslr(Y, X, window, [minPeriods])",
                "name": "mslr",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mslr](https://docs.dolphindb.com/en/Functions/m/mslr.html)\n\n\n\n#### Syntax\n\nmslr(Y, X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nConduct the simple least-squares regressions of *Y* on *X* in a sliding window.\n\nThe result is a tuple of two vectors. The first vector is the intercepts and the second vector is the coefficient estimates of *X*.\n\n#### Examples\n\n```\nY=1 4 3 9 5 4\nX=12 31 29 88 67 76\nmslr(Y,X,4);\n// output\n([,,,0.177052,0.712557,0.15],[,,,0.101824,0.084418,0.078462])\n```\n"
    },
    "mstd": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mstd.html",
        "signatures": [
            {
                "full": "mstd(X,window,[minPeriods])",
                "name": "mstd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mstd](https://docs.dolphindb.com/en/Functions/m/mstd.html)\n\n\n\n#### Syntax\n\nmstd(X,window,\\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the standard deviation of *X* in a sliding window.\n\n#### Examples\n\n```language-python\nmstd(1 2 5 4 3, 3);\n// output\n[,,2.081666,1.527525,1]\n\nmstd(1 2 5 4 3, 3, 2);\n// output\n[,0.707107,2.081666,1.527525,1]\n```\n\n```language-python\nm=matrix(1 6 2 9 4 5, 11 12 18 23 21 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 11 |\n| 6  | 12 |\n| 2  | 18 |\n| 9  | 23 |\n| 4  | 21 |\n| 5  | 10 |\n\n```language-python\nmstd(m,3);\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n|                   |                   |\n| 2.645751311064591 | 3.78593889720018  |\n| 3.511884584284247 | 5.507570547286101 |\n| 3.605551275463989 | 2.516611478423591 |\n| 2.645751311064591 | 7                 |\n\n```language-python\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmstd(m,4d)\n```\n\n| label      | col1   | col2   |\n| ---------- | ------ | ------ |\n| 2020.04.07 |        |        |\n| 2020.04.08 |        |        |\n| 2020.04.09 | 2.1213 |        |\n| 2020.04.10 | 2.1213 | 0.7071 |\n| 2020.04.11 | 2.8284 |        |\n| 2020.04.12 | 2      | 5.6569 |\n\n```language-python\nmstd(m,1w)\n```\n\n| label      | col1   | col2   |\n| ---------- | ------ | ------ |\n| 2020.04.07 |        |        |\n| 2020.04.08 |        |        |\n| 2020.04.09 | 2.1213 |        |\n| 2020.04.10 | 2.1213 | 0.7071 |\n| 2020.04.11 | 3.5119 | 0.7071 |\n| 2020.04.12 | 2.9861 | 4.3589 |\n\nRelated functions: [mmin](https://docs.dolphindb.com/en/Functions/m/mmin.html), [mmax](https://docs.dolphindb.com/en/Functions/m/mmax.html), [mavg](https://docs.dolphindb.com/en/Functions/m/mavg.html), [msum](https://docs.dolphindb.com/en/Functions/m/msum.html), [mvar](https://docs.dolphindb.com/en/Functions/m/mvar.html)\n"
    },
    "mstdp": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mstdp.html",
        "signatures": [
            {
                "full": "mstdp(X, window, [minPeriods])",
                "name": "mstdp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mstdp](https://docs.dolphindb.com/en/Functions/m/mstdp.html)\n\n\n\n#### Syntax\n\nmstdp(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the population standard deviation of *X* in a sliding window.\n\n#### Examples\n\n```\nmstdp(1 2 5 4 3, 3);\n// output\n[,,1.699673171197595,1.247219128924647,0.816496580927726]\n\nmstdp(1 2 5 4 3, 3, 2);\n// output\n[,0.5,1.699673171197595,1.247219128924647,0.816496580927726]\n\nm=matrix(1 6 2 9 4 5, 11 12 18 23 21 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 11 |\n| 6  | 12 |\n| 2  | 18 |\n| 9  | 23 |\n| 4  | 21 |\n| 5  | 10 |\n\n```\nmstdp(m,3);\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n|                   |                   |\n| 2.160246899469287 | 3.091206165165233 |\n| 2.867441755680875 | 4.496912521077346 |\n| 2.943920288775949 | 2.054804667656331 |\n| 2.160246899469287 | 5.715476066494082 |\n\n```\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmstdp(m,4d)\n```\n\n| label      | col1  | col2 |\n| ---------- | ----- | ---- |\n| 2020.04.07 | 0     | 0    |\n| 2020.04.08 | 0     | 0    |\n| 2020.04.09 | 1.5   | 0    |\n| 2020.04.10 | 1.5   | 0.5  |\n| 2020.04.11 | 2     | 0    |\n| 2020.04.12 | 1.633 | 4    |\n\n```\nmstdp(m,1w)\n```\n\n| label      | col1   | col2  |\n| ---------- | ------ | ----- |\n| 2020.04.07 | 0      | 0     |\n| 2020.04.08 | 0      | 0     |\n| 2020.04.09 | 1.5    | 0     |\n| 2020.04.10 | 1.5    | 0.5   |\n| 2020.04.11 | 2.8674 | 0.5   |\n| 2020.04.12 | 2.586  | 3.559 |\n\nRelated function: [mstd](https://docs.dolphindb.com/en/Functions/m/mstd.html)\n"
    },
    "mstdpTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mstdpTopN.html",
        "signatures": [
            {
                "full": "mstdpTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mstdpTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mstdpTopN](https://docs.dolphindb.com/en/Functions/m/mstdpTopN.html)\n\n\n\n#### Syntax\n\nmstdpTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the population standard deviation of the first *top* elements.\n\n#### Examples\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmstdTopN(X, S, 4, 2)\n// output\n[,0.707106781186548,1.414213562373095,0.707106781186548,0.707106781186548,0.707106781186548,1.414213562373095]\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmstdTopN(X, S, 4, 2)\n// output\n[,,,0.707106781186548,0.707106781186548,0.707106781186548,]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmstdTopN(X, S, 3, 2)\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n| 0.707106781186548 | 0.707106781186548 |\n| 1.414213562373095 | 1.414213562373095 |\n| 0.707106781186548 | 0.707106781186548 |\n| 1.414213562373095 | 1.414213562373095 |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmstdpTopN(X, S, 3, 2)\n```\n\n| #0     | #1     |\n| ------ | ------ |\n|        |        |\n| 0.7071 |        |\n| 1.4142 | 0.7071 |\n| 0.7071 | 0.7071 |\n| 1.4142 | 0.7071 |\n\nRelated function: [mstdp](https://docs.dolphindb.com/en/Functions/m/mstdp.html)\n"
    },
    "mstdTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mstdTopN.html",
        "signatures": [
            {
                "full": "mstdTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mstdTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mstdTopN](https://docs.dolphindb.com/en/Functions/m/mstdTopN.html)\n\n\n\n#### Syntax\n\nmstdTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the unbiased sample standard deviation of the first *top* elements.\n\n#### Examples\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmstdTopN(X, S, 4, 2)\n// output\n[,0.707106781186548,1.414213562373095,0.707106781186548,0.707106781186548,0.707106781186548,1.414213562373095]\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmstdTopN(X, S, 4, 2)\n// output\n[,,,0.707106781186548,0.707106781186548,0.707106781186548,]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmstdTopN(X, S, 3, 2)\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n| 0.707106781186548 | 0.707106781186548 |\n| 1.414213562373095 | 1.414213562373095 |\n| 0.707106781186548 | 0.707106781186548 |\n| 1.414213562373095 | 1.414213562373095 |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmstdTopN(X, S, 3, 2)\n```\n\n| #0     | #1     |\n| ------ | ------ |\n|        |        |\n| 0.7071 |        |\n| 1.4142 | 0.7071 |\n| 0.7071 | 0.7071 |\n| 1.4142 | 0.7071 |\n\nRelated function: [mstd](https://docs.dolphindb.com/en/Functions/m/mstd.html)\n"
    },
    "msum": {
        "url": "https://docs.dolphindb.com/en/Functions/m/msum.html",
        "signatures": [
            {
                "full": "msum(X, window, [minPeriods])",
                "name": "msum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [msum](https://docs.dolphindb.com/en/Functions/m/msum.html)\n\n\n\n#### Syntax\n\nmsum(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving sum of *X* in a sliding window.\n\n#### Examples\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmsum(X, 3);\n// output\n[,,6,11,16,18,15]\n\nmsum(Y, 3);\n// output\n[,,6,4,9,11,15]\n\nmsum(Y, 3, minPeriods=1);\n// output\n[2,3,6,4,9,11,15]\n```\n\n```\nm = matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmsum(m, 3d) // equivalent to msum(m, 3)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.04.07 | 1    | 9    |\n| 2020.04.08 | 1    | 9    |\n| 2020.04.09 | 5    | 9    |\n| 2020.04.10 | 4    | 10   |\n| 2020.04.11 | 12   | 10   |\n| 2020.04.12 | 14   | 12   |\n\n```\nmsum(m, 1w)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.04.07 | 1    | 9    |\n| 2020.04.08 | 1    | 9    |\n| 2020.04.09 | 5    | 9    |\n| 2020.04.10 | 5    | 19   |\n| 2020.04.11 | 13   | 19   |\n| 2020.04.12 | 19   | 21   |\n\nRelated functions: [sum](https://docs.dolphindb.com/en/Functions/s/sum.html)\n"
    },
    "msum2": {
        "url": "https://docs.dolphindb.com/en/Functions/m/msum2.html",
        "signatures": [
            {
                "full": "msum2(X, window, [minPeriods])",
                "name": "msum2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [msum2](https://docs.dolphindb.com/en/Functions/m/msum2.html)\n\n\n\n#### Syntax\n\nmsum2(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the sum of squares of all elements of *X* in a sliding window (based on the number of elements or time). Please note that the return is always of DOUBLE type.\n\n#### Examples\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmsum2(X, 3)\n// output\n[,,14,59,94,110,77]\n\nmsum2(Y, 3)\n// output\n[,,14,10,45,61,77]\n\nmsum2(Y, 3, minPeriods=1)\n// output\n[4,5,14,10,45,61,77]\n\nm = matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2021.08.16)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmsum2(m, 3d)  // equivalent to msum2(m, 3)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2021.08.17 | 1    | 81   |\n| 2021.08.18 | 1    | 81   |\n| 2021.08.19 | 17   | 81   |\n| 2021.08.20 | 16   | 100  |\n| 2021.08.21 | 80   | 100  |\n| 2021.08.22 | 100  | 104  |\n\nRelated functions: [sum2](https://docs.dolphindb.com/en/Functions/s/sum2.html)\n"
    },
    "msumTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/msumTopN.html",
        "signatures": [
            {
                "full": "msumTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "msumTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [msumTopN](https://docs.dolphindb.com/en/Functions/m/msumTopN.html)\n\n\n\n#### Syntax\n\nmsumTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* by *S* in the order specified by *ascending*, then sums up the first *top* elements.\n\n#### Examples\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmsumTopN(X, S, 4, 2)\n// output\n[1,3,4,7,7,7,10]\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmsumTopN(X, S, 4, 2)\n// output\n[,1,2,5,5,5,3]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmsumTopN(X, S, 3, 2)\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 6  |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n| 8  | 18 |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmsumTopN(X, S, 3, 2)\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 3  | 7  |\n| 4  | 15 |\n| 5  | 15 |\n| 8  | 17 |\n\nA table with columns code, date, close and volume.\n\n```\nt = table(take(`IBM`APPL, 20) as code, 2020.01.01 + 1..20 as date, rand(100,20) + 20 as volume, rand(10,20) + 100.0 as close)\n```\n\n| code | date       | volume | close |\n| ---- | ---------- | ------ | ----- |\n| IBM  | 2020.01.02 | 50     | 107   |\n| APPL | 2020.01.03 | 55     | 100   |\n| IBM  | 2020.01.04 | 75     | 100   |\n| APPL | 2020.01.05 | 84     | 108   |\n| IBM  | 2020.01.06 | 46     | 103   |\n| APPL | 2020.01.07 | 100    | 101   |\n| IBM  | 2020.01.08 | 96     | 100   |\n| APPL | 2020.01.09 | 84     | 102   |\n| IBM  | 2020.01.10 | 60     | 107   |\n| APPL | 2020.01.11 | 40     | 103   |\n| IBM  | 2020.01.12 | 92     | 105   |\n| APPL | 2020.01.13 | 61     | 106   |\n| IBM  | 2020.01.14 | 86     | 107   |\n| APPL | 2020.01.15 | 41     | 102   |\n| IBM  | 2020.01.16 | 85     | 103   |\n| APPL | 2020.01.17 | 72     | 105   |\n| IBM  | 2020.01.18 | 46     | 108   |\n| APPL | 2020.01.19 | 25     | 100   |\n| IBM  | 2020.01.20 | 114    | 102   |\n| APPL | 2020.01.21 | 50     | 104   |\n\nCalculate the sum of the closing prices of the top 3 records with the highest trading volume in the window for each stock.\n\n```\nselect code, date, msumTopN(close, volume, 5, 3, false) from t context by code\n```\n\n| code | date       | msumTopN\\_close |\n| ---- | ---------- | --------------- |\n| APPL | 2020.01.03 | 100             |\n| APPL | 2020.01.05 | 208             |\n| APPL | 2020.01.07 | 309             |\n| APPL | 2020.01.09 | 311             |\n| APPL | 2020.01.11 | 311             |\n| APPL | 2020.01.13 | 311             |\n| APPL | 2020.01.15 | 309             |\n| APPL | 2020.01.17 | 313             |\n| APPL | 2020.01.19 | 313             |\n| APPL | 2020.01.21 | 315             |\n| IBM  | 2020.01.02 | 107             |\n| IBM  | 2020.01.04 | 207             |\n| IBM  | 2020.01.06 | 310             |\n| IBM  | 2020.01.08 | 307             |\n| IBM  | 2020.01.10 | 307             |\n| IBM  | 2020.01.12 | 305             |\n| IBM  | 2020.01.14 | 312             |\n| IBM  | 2020.01.16 | 312             |\n| IBM  | 2020.01.18 | 315             |\n| IBM  | 2020.01.20 | 314             |\n\nRelated function: [msum](https://docs.dolphindb.com/en/Functions/m/msum.html)\n"
    },
    "mTopRange": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mTopRange.html",
        "signatures": [
            {
                "full": "mTopRange(X, window, [minPeriods])",
                "name": "mTopRange",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mTopRange](https://docs.dolphindb.com/en/Functions/m/mTopRange.html)\n\n#### Syntax\n\nmTopRange(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nFor each element *Xi* in a sliding window of *X*, count the continuous nearest neighbors to its left that are smaller than *Xi*. NULLs are treated as the minimum values.\n\nIf *X* is a matrix, conduct the aforementioned calculation within each column of *X*.\n\n#### Examples\n\n```\nx = [NULL, 3.1, NULL, 3.0, 2.9, 2.8, 3.1, NULL, 3.2]\nmTopRange(x, window=3)\n// output: [,,0,1,0,0,2,0,2]\n\nmTopRange(x, window=3, minPeriods=1)\n// output: [,1,0,1,0,0,2,0,2]\n\nx = [NULL, NULL, NULL, NULL, NULL, 2, NULL, NULL, 3.2]\ndate = [0, 1, 2, 3, 7, 8, 9, 10, 11] + 2020.01.01\nX = indexedSeries(date, x) \nmTopRange(X, 3d)\n```\n\n<table id=\"table_ir1_5mr_jbc\"><thead><tr><th>\n\n \n\n</th><th>\n\n\\#0\n\n</th></tr></thead><tbody><tr><td>\n\n2020.01.01\n\n</td><td>\n\n</td></tr><tr><td>\n\n2020.01.02\n\n</td><td>\n\n</td></tr><tr><td>\n\n2020.01.03\n\n</td><td>\n\n</td></tr><tr><td>\n\n2020.01.04\n\n</td><td>\n\n</td></tr><tr><td>\n\n2020.01.08\n\n</td><td>\n\n</td></tr><tr><td>\n\n2020.01.09\n\n</td><td>\n\n1\n\n</td></tr><tr><td>\n\n2020.01.10\n\n</td><td>\n\n0\n\n</td></tr><tr><td>\n\n2020.01.11\n\n</td><td>\n\n0\n\n</td></tr><tr><td>\n\n2020.01.12\n\n</td><td>\n\n2\n\n</td></tr></tbody>\n</table>```\nm = matrix(1 2 3 NULL, 1 2 NULL 3, 1 3 NULL NULL, 1 2 3 4)\nmTopRange(m, 2)\n```\n\n<table id=\"table_dyy_vmr_jbc\"><thead><tr><th>\n\n\\#0\n\n</th><th>\n\n\\#1\n\n</th><th>\n\n\\#2\n\n</th><th>\n\n\\#3\n\n</th></tr></thead><tbody><tr><td>\n\n</td><td>\n\n</td><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n1\n\n</td><td>\n\n1\n\n</td><td>\n\n1\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n0\n\n</td><td>\n\n0\n\n</td><td>\n\n1\n\n</td></tr><tr><td>\n\n0\n\n</td><td>\n\n1\n\n</td><td>\n\n</td><td>\n\n1\n\n</td></tr></tbody>\n</table>**Parent topic:**[Functions](../../Functions/category.md)\n"
    },
    "mul": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mul.html",
        "signatures": [
            {
                "full": "mul(X, Y)",
                "name": "mul",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [mul](https://docs.dolphindb.com/en/Functions/m/mul.html)\n\n\n\n#### Syntax\n\nmul(X, Y) or X\\*Y\n\n#### Arguments\n\n**X** and **Y** is a scalar/pair/vector/matrix. If one of *X* and *Y* is a pair/vector/matrix, the other must be a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nReturn the element-by-element product of *X* and *Y*.\n\n#### Examples\n\n```\n1:2*3;\n// output\n3 : 6\n\n1:2*3:4;\n// output\n3 : 8\n\nx=1 2 3;\nx * 2;\n// output\n[2,4,6]\n\ny=4 5 6;\nx * y;\n// output\n[4,10,18]\n```\n\n```\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1*2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 2  | 6  | 10 |\n| 4  | 8  | 12 |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1*m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 12 | 10 |\n| 10 | 12 | 6  |\n"
    },
    "multinomialNB": {
        "url": "https://docs.dolphindb.com/en/Functions/m/multinomialNB.html",
        "signatures": [
            {
                "full": "multinomialNB(Y, X, [varSmoothing=1.0])",
                "name": "multinomialNB",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[varSmoothing=1.0]",
                        "name": "varSmoothing",
                        "optional": true,
                        "default": "1.0"
                    }
                ]
            }
        ],
        "markdown": "### [multinomialNB](https://docs.dolphindb.com/en/Functions/m/multinomialNB.html)\n\n\n\n#### Syntax\n\nmultinomialNB(Y, X, \\[varSmoothing=1.0])\n\n#### Arguments\n\n**Y** is a vector with the same length as table *X*. Each element of labels indicates the class that the correponding row in *X* belongs to.\n\n**X** is a table indicating the training set. Each row is a sample and each column is a feature.\n\n**varSmoothing** is a positive floating number between 0 and 1 indicating the additive (Laplace/Lidstone) smoothing parameter (0 for no smoothing).\n\n#### Details\n\nConduct the multinomial Naive Bayesian classification. Return a dictionary with the following keys:\n\n* *model*: a RESOURCE data type variable. It is an internal binary resource generated by function `multinomialNB` and to be used by function [predict](https://docs.dolphindb.com/en/Functions/p/predict.html).\n\n* *modelName*: string \"multinomialNB\".\n\n* *varSmoothing*: varSmoothing parameter value.\n\n#### Examples\n\nThe dataset *iris.data* used in the following example can be downloaded from <https://archive.ics.uci.edu/ml/datasets/iris>.\n\n```\nDATA_DIR = \"C:/DolphinDB/Data\"\nt = loadText(DATA_DIR+\"/iris.data\")\nt.rename!(`col0`col1`col2`col3`col4, `sepalLength`sepalWidth`petalLength`petalWidth`class)\nt[`classType] = take(0, t.size())\nupdate t set classType = 1 where class = \"Iris-versicolor\"\nupdate t set classType = 2 where class = \"Iris-virginica\"\n\ntraining = select sepalLength, sepalWidth, petalLength, petalWidth from t\nlabels = t.classType\n\nmodel = multinomialNB(labels, training);\n\npredict(model, training);\n```\n"
    },
    "multiTableRepartitionDS": {
        "url": "https://docs.dolphindb.com/en/Functions/m/multiTableRepartitionDS.html",
        "signatures": [
            {
                "full": "multiTableRepartitionDS(query, [column], [partitionType], [partitionScheme], [local=true])",
                "name": "multiTableRepartitionDS",
                "parameters": [
                    {
                        "full": "query",
                        "name": "query"
                    },
                    {
                        "full": "[column]",
                        "name": "column",
                        "optional": true
                    },
                    {
                        "full": "[partitionType]",
                        "name": "partitionType",
                        "optional": true
                    },
                    {
                        "full": "[partitionScheme]",
                        "name": "partitionScheme",
                        "optional": true
                    },
                    {
                        "full": "[local=true]",
                        "name": "local",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [multiTableRepartitionDS](https://docs.dolphindb.com/en/Functions/m/multiTableRepartitionDS.html)\n\n\n\n#### Syntax\n\nmultiTableRepartitionDS(query, \\[column], \\[partitionType], \\[partitionScheme], \\[local=true])\n\n#### Arguments\n\n**query** is metacode of SQL statements or a tuple of metacode of SQL statements.\n\n**column** is a string indicating a column name in *query*. Function `multiTableRepartitionDS` deliminates data sources based on column.\n\n**partitionType** means the type of partition. It can take the value of VALUE or RANGE.\n\n**partitionScheme** is a vector indicating the partitioning scheme. For details please refer to [DistributedComputing](https://docs.dolphindb.com/en/Database/DatabaseandDistributedComputing/DistributedComputing.html).\n\n**local** is a Boolean value indicating whether to move the data sources to the local node for computing. The default value is true.\n\n#### Details\n\nGenerate a tuple of data sources from multiple tables with a new partitioning design.\n\nIf *query* is metacode of SQL statements, the parameter *column* must be specified. *partitionType* and *partitionScheme* can be unspecified for a partitioned table with a COMPO domain. In this case, the data sources will be determined based on the original *partitionType* and *partitionScheme* of *column*.\n\nIf *query* is a tuple of metacode of SQL statements, *column*, *partitionType* and *partitionScheme* should be unspecified. The function returns a tuple with the same length as *query*. Each element of the result is a data source corresponding to a piece of metacode in *query*.\n\n#### Examples\n\n```\nn=100000\ndate=rand(2019.06.01..2019.06.05,n)\nsym=rand(`AAPL`MSFT`GOOG,n)\nprice=rand(1000.0,n)\nt1=table(date,sym,price)\ndb=database(\"dfs://value\",VALUE,2019.06.01..2019.06.05)\ndb.createPartitionedTable(t1,`pt1,`date).append!(t1);\n\nn=100000\ndate=rand(2019.06.01..2019.06.05,n)\nsym=rand(`AAPL`MSFT`GOOG,n)\nprice=rand(1000.0,n)\nqty=rand(500,n)\nt2=table(date,sym,price,qty)\ndb1=database(\"\",VALUE,2019.06.01..2019.06.05)\ndb2=database(\"\",VALUE,`AAPL`MSFT`GOOG)\ndb=database(\"dfs://compo\",COMPO,[db1,db2])\ndb.createPartitionedTable(t2,`pt2,`date`sym).append!(t2);\n\npt1=loadTable(\"dfs://value\",\"pt1\")\npt2=loadTable(\"dfs://compo\",\"pt2\");\n```\n\nExample 1. Delineate data sources based on the original partitioning scheme. *column*, *partitionType* and *partitionScheme* are unspecified.\n\n```\nds=multiTableRepartitionDS([<select * from pt1>,<select date,sym,price from pt2>]);\n// output\n(DataSource< select [7] * from pt1 [partition = /value/20190601] >,DataSource< select [7] * from pt1 [partition = /value/20190602] >, ...... ,DataSource< select [7] date,sym,price from pt2 [partition = /compo/20190605/GOOG] >,DataSource< select [7] date,sym,price from pt2 [partition = /compo/20190605/MSFT] >)\n```\n\nExample 2. Delineate data sources based on stock symbols.\n\n```\nds=multiTableRepartitionDS([<select * from pt1>,<select date,sym,price from pt2>],`sym,VALUE,`AAPL`MSFT`GOOG);\n// output\n(DataSource< select [4] * from pt1 where sym == \"AAPL\" >,DataSource< select [4] * from pt1 where sym == \"MSFT\" >,DataSource< select [4] * from pt1 where sym == \"GOOG\" >,DataSource< select [4] date,sym,price from pt2 where sym == \"AAPL\" >,DataSource< select [4] date,sym,price from pt2 where sym == \"MSFT\" >,DataSource< select [4] date,sym,price from pt2 where sym == \"GOOG\" >)\n```\n\nExample 3. Delineate data sources based on dates.\n\n```\nds=multiTableRepartitionDS([<select * from pt1>,<select date,sym,price from pt2>],`date,RANGE,2019.06.01 2019.06.03 2019.06.05);\n// output\n(DataSource< select [4] * from pt1 where date >= 2019.06.01,date < 2019.06.03 >,DataSource< select [4] * from pt1 where date >= 2019.06.03,date < 2019.06.05 >,DataSource< select [4] date,sym,price from pt2 where date >= 2019.06.01,date < 2019.06.03 >,DataSource< select [4] date,sym,price from pt2 where date >= 2019.06.03,date < 2019.06.05 >)\n```\n\nRelated function: [repartitionDS](https://docs.dolphindb.com/en/Functions/r/repartitionDS.html)\n"
    },
    "mutualInfo": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mutualInfo.html",
        "signatures": [
            {
                "full": "mutualInfo(X, Y)",
                "name": "mutualInfo",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [mutualInfo](https://docs.dolphindb.com/en/Functions/m/mutualInfo.html)\n\n\n\n#### Syntax\n\nmutualInfo(X, Y)\n\nAlias: infoGain\n\n#### Arguments\n\n**X** is a scalar/vector/ matrix.\n\n**Y** is a scalar/vector/ matrix.\n\n*X* and *Y* can be integral or symbol types.\n\n#### Details\n\nCalculate the mutual information of *X* and *Y*.\n\nThe calculation uses the following formula:\n\n![](https://docs.dolphindb.com/en/images/mutualInfo.png)\n\nIf *X* or *Y* is a matrix, calculate the mutual information of each column and return a vector.\n\nPlease note that the natural logarithm is used in this formula. If base is set to 2 or 10, please divide the result by log 2 or log 10.\n\n#### Examples\n\n```\na = [NULL,4,NULL,NULL,-82,97,NULL,56,5,-92]\nb = [NULL,53,NULL,18,97,-4,-73,NULL,NULL,24]\nmutualInfo(a, b)\n// output\n2.302585\n\nt=table(take(1..10,10000000) as id, rand(10,10000000) as x, rand(10,10000000) as y);\nmutualInfo(t.x, t.y)\n// output\n0.000004\n\nm1 = 1..12$3:4\nm2 = 1..3\nmutualInfo(m1, m2)\n// output\n[1.0986, 1.0986, 1.0986, 1.0986]\n```\n\nIf *X* is a matrix, *Y* can be a vector/matrix with the same row number as *X*.\n\n```\nm1 = [27,29,NULL,56,57,-2,68,38,100,55,94,87,2,29,-5,34,32,86,-4,13,66,28,33,87,20,88,13,51,13,79]$6:5\nm2 = [44,29,44,NULL,36,57,48,71,39,6,30,NULL,42,NULL,95,55,22,93,70,27,51,24,63,45,-10,87,44,92,69,100]$6:5\nmutualInfo(m1, m2)\n```\n"
    },
    "mvar": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mvar.html",
        "signatures": [
            {
                "full": "mvar(X, window, [minPeriods])",
                "name": "mvar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mvar](https://docs.dolphindb.com/en/Functions/m/mvar.html)\n\n\n\n#### Syntax\n\nmvar(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving variances of *X* in a sliding window.\n\n#### Examples\n\n```\nmvar(1..6, 5);\n// output\n[,,,,2.5,2.5]\n\nmvar(1..6, 5, 2);\n// output\n[,0.5,1,1.666667,2.5,2.5]\n```\n\n```\nm=matrix(1 6 2 9 4 5, 11 12 18 23 21 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 11 |\n| 6  | 12 |\n| 2  | 18 |\n| 9  | 23 |\n| 4  | 21 |\n| 5  | 10 |\n\n```\nmvar(m,3);\n```\n\n| #0                 | #1                 |\n| ------------------ | ------------------ |\n|                    |                    |\n|                    |                    |\n| 7                  | 14.333333333333314 |\n| 12.333333333333335 | 30.333333333333314 |\n| 13                 | 6.333333333333372  |\n| 7                  | 49                 |\n\n```\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmvar(m,4d)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.04.07 |      |      |\n| 2020.04.08 |      |      |\n| 2020.04.09 | 4.5  |      |\n| 2020.04.10 | 4.5  | 0.5  |\n| 2020.04.11 | 8    |      |\n| 2020.04.12 | 4    | 32   |\n\n```\nmvar(m,1w)\n```\n\n| label      | col1    | col2 |\n| ---------- | ------- | ---- |\n| 2020.04.07 |         |      |\n| 2020.04.08 |         |      |\n| 2020.04.09 | 4.5     |      |\n| 2020.04.10 | 4.5     | 0.5  |\n| 2020.04.11 | 12.3333 | 0.5  |\n| 2020.04.12 | 8.9167  | 19   |\n\nRelated functions: [var](https://docs.dolphindb.com/en/Functions/v/var.html)\n"
    },
    "mvarp": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mvarp.html",
        "signatures": [
            {
                "full": "mvarp(X, window, [minPeriods])",
                "name": "mvarp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mvarp](https://docs.dolphindb.com/en/Functions/m/mvarp.html)\n\n\n\n#### Syntax\n\nmvarp(X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving population variances of *X* in a sliding window.\n\n#### Examples\n\n```\nmvarp(1..6, 5);\n// output\n[,,,,2,2]\n\nmvarp(1..6, 5, 2);\n// output\n[,0.25,0.666666666666667,1.25,2,2]\n\nm=matrix(1 6 2 9 4 5, 11 12 18 23 21 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 11 |\n| 6  | 12 |\n| 2  | 18 |\n| 9  | 23 |\n| 4  | 21 |\n| 5  | 10 |\n\n```\nmvarp(m,3);\n```\n\n| #0                | #1                 |\n| ----------------- | ------------------ |\n|                   |                    |\n|                   |                    |\n| 4.666666666666667 | 9.555555555555542  |\n| 8.222222222222223 | 20.22222222222221  |\n| 8.666666666666666 | 4.222222222222248  |\n| 4.666666666666667 | 32.666666666666664 |\n\n```\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmvarp(m,4d)\n```\n\n| label      | col1   | col2 |\n| ---------- | ------ | ---- |\n| 2020.04.07 | 0      | 0    |\n| 2020.04.08 | 0      | 0    |\n| 2020.04.09 | 2.25   | 0    |\n| 2020.04.10 | 2.25   | 0.25 |\n| 2020.04.11 | 4      | 0    |\n| 2020.04.12 | 2.6667 | 16   |\n\n```\nmvarp(m,1w)\n```\n\n| label      | col1   | col2    |\n| ---------- | ------ | ------- |\n| 2020.04.07 | 0      | 0       |\n| 2020.04.08 | 0      | 0       |\n| 2020.04.09 | 2.25   | 0       |\n| 2020.04.10 | 2.25   | 0.25    |\n| 2020.04.11 | 8.2222 | 0.25    |\n| 2020.04.12 | 6.6875 | 12.6667 |\n\nRelated function: [mvar](https://docs.dolphindb.com/en/Functions/m/mvar.html)\n"
    },
    "mvarpTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mvarpTopN.html",
        "signatures": [
            {
                "full": "mvarpTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mvarpTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mvarpTopN](https://docs.dolphindb.com/en/Functions/m/mvarpTopN.html)\n\n\n\n#### Syntax\n\nmvarpTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the population variance of the first *top* elements.\n\n#### Examples\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmvarpTopN(X, S, 4, 2)\n// output\n[0,0.25,1,0.25,0.25,0.25,1]\n\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmvarpTopN(X, S, 4, 2)\n// output\n[,0,0,0.25,0.25,0.25,0]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmvarpTopN(X, S, 3, 2)\n```\n\n| #0   | #1   |\n| ---- | ---- |\n| 0    | 0    |\n| 0.25 | 0.25 |\n| 1    | 1    |\n| 0.25 | 0.25 |\n| 1    | 1    |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmvarpTopN(X, S, 3, 2)\n```\n\n| #0   | #1   |\n| ---- | ---- |\n| 0    |      |\n| 0.25 | 0    |\n| 1    | 0.25 |\n| 0.25 | 0.25 |\n| 1    | 0.25 |\n\nRelated function: [mvarp](https://docs.dolphindb.com/en/Functions/m/mvarp.html)\n"
    },
    "mvarTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mvarTopN.html",
        "signatures": [
            {
                "full": "mvarTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mvarTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mvarTopN](https://docs.dolphindb.com/en/Functions/m/mvarTopN.html)\n\n\n\n#### Syntax\n\nmvarTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the unbiased sample variance of the first *top* elements.\n\n#### Examples\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmvarTopN(X, S, 4, 2)\n// output\n[,0.5,2,0.5,0.5,0.5,2]\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmvarTopN(X, S, 4, 2)\n// output\n[,,,0.5,0.5,0.5,]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmvarTopN(X, S, 3, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n|     |     |\n| 0.5 | 0.5 |\n| 2   | 2   |\n| 0.5 | 0.5 |\n| 2   | 2   |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmvarTopN(X, S, 3, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n|     |     |\n| 0.5 |     |\n| 2   | 0.5 |\n| 0.5 | 0.5 |\n| 2   | 0.5 |\n\nRelated function: [mvar](https://docs.dolphindb.com/en/Functions/m/mvar.html)\n"
    },
    "mvccTable": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mvccTable.html",
        "signatures": [
            {
                "full": "mvccTable(X, [X1], [X2], .....)",
                "name": "mvccTable",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "mvccTable(capacity:size, colNames, colTypes, [path], [tableName], [defaultValues], [allowNull])",
                "name": "mvccTable",
                "parameters": [
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    },
                    {
                        "full": "[path]",
                        "name": "path",
                        "optional": true
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    },
                    {
                        "full": "[defaultValues]",
                        "name": "defaultValues",
                        "optional": true
                    },
                    {
                        "full": "[allowNull]",
                        "name": "allowNull",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mvccTable](https://docs.dolphindb.com/en/Functions/m/mvccTable.html)\n\n\n\n#### Syntax\n\nmvccTable(X, \\[X1], \\[X2], .....)\n\nor\n\nmvccTable(capacity:size, colNames, colTypes, \\[path], \\[tableName], \\[defaultValues], \\[allowNull])\n\n#### Arguments\n\nFor the first scenario:\n\n**X**, **X1**, **X2** ...are vectors.\n\nFor the second scenario:\n\n**capacity** is the amount of memory (in terms of the number of rows) allocated to the table. When the number of rows exceeds *capacity*, the system will first allocate memory of 1.2\\~2 times of capacity, copy the data to the new memory space, and release the original memory. For large tables, these steps may use significant amount of memory.\n\n**size** is an integer no less than 0 indicating the initial size (in terms of the number of rows) of the table. If size=0, create an empty table. If size>0, the initialized values are determined by *defaultValues*.\n\n**colNames** is a string vector of column names.\n\n**colTypes** is a string vector of column types.\n\n**path** is a string indicating the absolute path of the table on disk. The DFS path is not supported.\n\n**tableName** is a string indicating the name of the table on disk.\n\n**defaultValues** is a tuple that has the same length as *colNames*. It specifies the default values for all columns. If it is not specified, then the initialized values are:\n\n* false for Boolean type;\n\n* 0 for numeric, temporal, IPADDR, COMPLEX, and POINT types;\n\n* NULL for Literal, INT128 types.\n\n**allowNull** is a Boolean vector that has the same length as *colNames*. It specifies whether to allow NULL values in each column. By default, elements of the Boolean vector are all true, meaning NULL values are allowed.\n\n#### Details\n\nCreate an MVCC (Multi Version Concurrency Control) table. When appending, updating or deleting rows of a table, another version of the table is created so that concurrent read will not be blocked. The mvcc table is optimal for the use case with frequent read and append, but few update and delete operations.\n\nIf parameters *path* and *tableName* are specified, the table will be persisted to disk. The table on disk can be loaded into memory with function [loadMvccTable](https://docs.dolphindb.com/en/Functions/l/loadMvccTable.html).\n\n**Note:**\n\n* When *size* is set to 0, if NULL values are disallowed for a column, an MVCC table can be created but NULL values cannot be appended to the column.\n\n* The MVCC table does not support `addColumn`, `reorderColumns!`, `upsert!`, `drop`, `erase!`.\n\n**Note:**\n\n* The MVCC table does not support `addColumn`, `dropColumns!`, `replaceColumn!`, `reorderColumns!`, `upsert!`, `drop`, `erase!`.\n\n#### Examples\n\nExample1. Create an MVCC table by two methods:\n\nMethod 1:\n\n```\nid=`XOM`GS`AAPL\nx=102.1 33.4 73.6\nmvccTable(id, x);\n```\n\n| id   | x     |\n| ---- | ----- |\n| XOM  | 102.1 |\n| GS   | 33.4  |\n| AAPL | 73.6  |\n\nMethod 2:\n\n```\nmvccTable(200:10, `name`id`value, [STRING,INT,DOUBLE],\"C:/DolphinDB/Data\",\"t1\");\n```\n\n| name | id | value |\n| ---- | -- | ----- |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n\nThere will be files named *t1.tbl*, *t1.sym* and a folder named *t1* under path *C:/DolphinDB/Data*. You should delete all these files before deleting a disk table.\n\nExample 2. Create a partitioned MVCC table:\n\n```\nn=200000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\ntrades_mvcc1 = mvccTable(n:0, colNames, colTypes)\ntrades_mvcc2 = mvccTable(n:0, colNames, colTypes)\ndb=database(, VALUE, `A`D)\ntrades = createPartitionedTable(db,table=[trades_mvcc1, trades_mvcc2], tableName=\"\", partitionColumns=`sym)\n```\n\nBefore version 2.00.10.4, the update, appending and deletion operations are not supported on partitioned MVCC tables. You can only operate on the tablets trades\\_mvcc1 and trades\\_mvcc2 to modify the partitioned MVCC table trades.\n\n```\ninsert into trades_mvcc1 values(09:30:00.001,`A,100,56.5)\ninsert into trades_mvcc2 values(09:30:01.001,`D,100,15.5)\n\ninsert into trades values(09:30:00.001,`D,100,26.5)\nError: Can't append data to a segmented table that contains external partitions.\n\nselect * from trades;\n```\n\n| time         | sym | qty | price |\n| ------------ | --- | --- | ----- |\n| 09:30:00.001 | A   | 100 | 56.5  |\n| 09:30:01.001 | D   | 100 | 15.5  |\n\nSince 2.00.10.4, the update, appending and deletion operations can be directly applied to partitioned MVCC tables.\n\n```\ninsert into trades values(09:30:00.001,`D,100,26.5)\nselect * from trades;\n```\n\n| time         | sym | qty | price |\n| ------------ | --- | --- | ----- |\n| 09:30:00.001 | A   | 100 | 56.5  |\n| 09:30:01.001 | D   | 100 | 15.5  |\n| 09:30:01.001 | D   | 100 | 26.5  |\n\n```\ndelete from trades where sym=`A\nselect * from trades;\n```\n\n| time         | sym | qty | price |\n| ------------ | :-- | :-- | :---- |\n| 09:30:01.001 | D   | 100 | 15.5  |\n| 09:30:01.001 | D   | 100 | 26.5  |\n\n```\nupdate trades set price=price*10 where sym=`D\nselect * from trades;\n```\n\n| time         | sym | qty | price |\n| :----------- | :-- | :-- | :---- |\n| 09:30:01.001 | D   | 100 | 155   |\n| 09:30:01.001 | D   | 100 | 265   |\n\nNote that when appending data to a tablet of a partitioned MVCC table, the system would not validate whether the data matches the table schema. If an out-of-scope record is appended to a tablet, it can lead to data corruption in the partitioned MVCC table. Therefore, it is more recommended to operate directly on the table instead of its tablets.\n"
    },
    "mwavg": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mwavg.html",
        "signatures": [
            {
                "full": "mwavg(Y, X, window, [minPeriods])",
                "name": "mwavg",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mwavg](https://docs.dolphindb.com/en/Functions/m/mwavg.html)\n\n\n\n#### Syntax\n\nmwavg(Y, X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving averages of *X* with *Y* as weights in a sliding window.\n\n**Note:**\n\nDifferent from `mavg` that is based on a window of size (weight) length, `mwavg` must use *X* and *Y* of the same length.\n\nThe weights in a rolling window are automatically adjusted so that the sum of weights for all non-NULL elements in the rolling window is 1.\n\n#### Examples\n\nFunction `mwavg` can be used to calculate VWAP (volume-weighted average price):\n\n```\nprice=2.1 2.2 2.3 2.5 2.6 2.8 2.7 2.5;\nvolume=10 20 10 40 10 40 10 20;\nmwavg(price, volume, 4);\n// output\n[,,,2.35,2.4125,2.61,2.65,2.6875]\n\nmwavg(price, volume, 4, 2);\n// output\n[,2.166667,2.2,2.35,2.4125,2.61,2.65,2.6875]\n```\n\n```\nprice1 = indexedSeries(date(2020.06.05)+1..8, price)\nvolume1 = indexedSeries(date(2020.06.05)+1..8, volume)\nmwavg(price1,volume1, 4d)\n```\n\n| label      | col1   |\n| ---------- | ------ |\n| 2020.06.06 | 2.1    |\n| 2020.06.07 | 2.1667 |\n| 2020.06.08 | 2.2    |\n| 2020.06.09 | 2.35   |\n| 2020.06.10 | 2.4125 |\n| 2020.06.11 | 2.61   |\n| 2020.06.12 | 2.65   |\n| 2020.06.13 | 2.6875 |\n\n```\nmwavg(price1,volume1, 1w)\n```\n\n| label      | col1   |\n| ---------- | ------ |\n| 2020.06.06 | 2.1    |\n| 2020.06.07 | 2.1667 |\n| 2020.06.08 | 2.2    |\n| 2020.06.09 | 2.35   |\n| 2020.06.10 | 2.3788 |\n| 2020.06.11 | 2.5077 |\n| 2020.06.12 | 2.5214 |\n| 2020.06.13 | 2.5467 |\n\nRelated functions: [wavg](https://docs.dolphindb.com/en/Functions/w/wavg.html), [mavg](https://docs.dolphindb.com/en/Functions/m/mavg.html).\n"
    },
    "mwsum": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mwsum.html",
        "signatures": [
            {
                "full": "mwsum(Y, X, window, [minPeriods])",
                "name": "mwsum",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mwsum](https://docs.dolphindb.com/en/Functions/m/mwsum.html)\n\n\n\n#### Syntax\n\nmwsum(Y, X, window, \\[minPeriods])\n\nPlease see [mFunctions](https://docs.dolphindb.com/en/Functions/Themes/mFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving sums of *X* with *Y* as weights in a sliding window.\n\nThe weights in a rolling window are automatically adjusted so that the sum of weights for all non-NULL elements in the rolling window is 1.\n\n#### Examples\n\n```\nX = 2 1 3 7 6 5 4\nX1 = 2 1 3 NULL 6 5 4\nY = 1 0.5 1 1 2 2.1\n\nmwsum(X, Y, 3);\n// output\n[,,5.5,10.5,22,29.5,24.5]\n\nmwsum(X1, Y, 3)\n// output\n[,,5.5,3.5,15,22.5,24.5]\n\nmwsum(X1, Y, 3, minPeriods=1)\n// output\n[2,2.5,5.5,3.5,15,22.5,24.5]\n```\n\n```\nX = 1..10;\nY = 9 5 3 4 5 4 7 1 3 4;\nX1 = indexedSeries(date(2020.06.05)+1..10, X)\nY1 = indexedSeries(date(2020.06.05)+1..10, Y)\nmwsum(X1, Y1, 5d)\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2020.06.06 | 9    |\n| 2020.06.07 | 19   |\n| 2020.06.08 | 28   |\n| 2020.06.09 | 44   |\n| 2020.06.10 | 69   |\n| 2020.06.11 | 84   |\n| 2020.06.12 | 123  |\n| 2020.06.13 | 122  |\n| 2020.06.14 | 133  |\n| 2020.06.15 | 148  |\n\n```\nmwsum(X1, Y1, 1w)\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2020.06.06 | 9    |\n| 2020.06.07 | 19   |\n| 2020.06.08 | 28   |\n| 2020.06.09 | 44   |\n| 2020.06.10 | 69   |\n| 2020.06.11 | 93   |\n| 2020.06.12 | 142  |\n| 2020.06.13 | 141  |\n| 2020.06.14 | 158  |\n| 2020.06.15 | 189  |\n\nRelated functions: [wsum](https://docs.dolphindb.com/en/Functions/w/wsum.html), [msum](https://docs.dolphindb.com/en/Functions/m/msum.html).\n"
    },
    "mwsumTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/m/mwsumTopN.html",
        "signatures": [
            {
                "full": "mwsumTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mwsumTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mwsumTopN](https://docs.dolphindb.com/en/Functions/m/mwsumTopN.html)\n\n\n\n#### Syntax\n\nmwsumTopN(X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\nPlease see [mTopN](https://docs.dolphindb.com/en/Functions/Themes/mTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by the number of elements), the function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the moving sums of *X* with *Y* as weights.\n\n#### Examples\n\n```\nx = NULL 3 8 4 0 7 4\ny = 2 3 1 7 3 6 1\ns = 5 NULL 8 9 9 4 4\n\nmwsumTopN(x, y, s, 4, 3)\n// output\n[,,8,36,36,78,74]\n\ns2=2021.01.01 2021.02.03 2021.01.23 2021.04.06 2021.12.29 2021.04.16 2021.10.29\nmwsumTopN(x, y, s2, 3, 2)\n// output\n[ , 9, 8, 17, 36, 70, 46]\n\nx1 = matrix(x, 4 3 6 2 3 1 3)\ny1=matrix(3 7 9 3 2 4 6, y)\ns1=matrix(2 3 1 7 3 NULL 1, s)\n\nmwsumTopN(x1,y1,s1,4,3)\n```\n\n| #1 | #2 |\n| -- | -- |\n|    | 8  |\n| 21 | 8  |\n| 93 | 14 |\n| 93 | 28 |\n| 93 | 29 |\n| 84 | 26 |\n| 36 | 23 |\n\n```\nmwsumTopN(x1, y1, s, 4, 3)\n```\n\n| #1  | #2 |\n| --- | -- |\n|     | 8  |\n|     | 8  |\n| 72  | 14 |\n| 84  | 28 |\n| 84  | 29 |\n| 112 | 26 |\n| 64  | 23 |\n\n```\nn = 3000\nids = 1..3000\ndates = take(2021.01.01..2021.10.01,n)\nprices = rand(1000,n)\nvals = rand(1000,n)\nt = table(ids as id,dates as date,prices as price,vals as val)\ndbName = \"dfs://test_mwsumTopN_2\"\nif(existsDatabase(dbName))dropDB(dbName)\ndb = database(dbName,VALUE,1..5000)\npt = db.createPartitionedTable(t,\"pt\",`id).append!(t)\nselect mwsumTopN(price, val, id, 10, 5, true) from pt where date>2021.05.01\n```\n\nRelated function: [mwsum](https://docs.dolphindb.com/en/Functions/m/mwsum.html)\n"
    },
    "nanInfFill": {
        "url": "https://docs.dolphindb.com/en/Functions/n/nanInfFill.html",
        "signatures": [
            {
                "full": "nanInfFill(X,Y)",
                "name": "nanInfFill",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [nanInfFill](https://docs.dolphindb.com/en/Functions/n/nanInfFill.html)\n\n#### Syntax\n\nnanInfFill(X,Y)\n\n#### Arguments\n\n`X` is a floating-point number of any data form except for set.\n\n`Y` is a floating-point number.\n\n#### Details\n\nIn DolphinDB, NaN and Inf values of floating-point numbers are replaced with NULL values. Nan and Inf values can arise in the course of data import, or during calculations involving external data sources.\n\nThis function replaces the NaN/Inf value in *X* with the specified *Y*.\n\n**Note:**\n\nWhen *X* is a dictionary, only dictionary values are replaced.\n\n#### Examples\n\n```\nx = [float(`inf), 2, 3, float(`nan), 5, 6, 7]\nnanInfFill (x, 2.2)\n\nx = matrix(1..3, [float(`inf), float(`nan), 1.0])\nnanInfFill(x, 1.2)\n```\n\nRelated functions: [isNanInf](https://docs.dolphindb.com/en/Functions/i/isNanInf.html), [countNanInf](https://docs.dolphindb.com/en/Functions/c/countNanInf.html)\n\n"
    },
    "nanosecond": {
        "url": "https://docs.dolphindb.com/en/Functions/n/nanosecond.html",
        "signatures": [
            {
                "full": "nanosecond(X)",
                "name": "nanosecond",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [nanosecond](https://docs.dolphindb.com/en/Functions/n/nanosecond.html)\n\n\n\n#### Syntax\n\nnanosecond(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type TIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP.\n\n#### Details\n\nFor each element in *X*, return a number indicating which nanosecond of the second it falls in.\n\n#### Examples\n\n```\nnanosecond(13:30:10.008);\n// output\n8000000\n\nnanosecond([2012.12.03 01:22:01.999999999, 2012.12.03 01:25:08.000000234]);\n// output\n[999999999,234]\n```\n\nRelated functions: [dayOfYear](https://docs.dolphindb.com/en/Functions/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.com/en/Functions/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.com/en/Functions/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.com/en/Functions/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.com/en/Functions/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.com/en/Functions/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.com/en/Functions/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.com/en/Functions/m/millisecond.html), [microsecond](https://docs.dolphindb.com/en/Functions/m/microsecond.html)\n"
    },
    "nanotime": {
        "url": "https://docs.dolphindb.com/en/Functions/n/nanotime.html",
        "signatures": [
            {
                "full": "nanotime(X)",
                "name": "nanotime",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [nanotime](https://docs.dolphindb.com/en/Functions/n/nanotime.html)\n\n\n\n#### Syntax\n\nnanotime(X)\n\n#### Arguments\n\n**X** is an integer or temporal scalar/vector.\n\n#### Details\n\nConvert the data type of X to NANOTIME.\n\n#### Examples\n\n```\nnanotime(1000000000);\n// output\n00:00:01.000000000\n\nnanotime(12:06:09 13:08:01);\n// output\n[12:06:09.000000000,13:08:01.000000000]\n\nnanotime(2012.12.03 01:22:01.123456789);\n// output\n01:22:01.123456789\n\nnanotime('13:30:10.008007006');\n// output\n13:30:10.008007006\n```\n\nRelated function: [nanotimestamp](https://docs.dolphindb.com/en/Functions/n/nanotimestamp.html)\n"
    },
    "nanotimestamp": {
        "url": "https://docs.dolphindb.com/en/Functions/n/nanotimestamp.html",
        "signatures": [
            {
                "full": "nanotimestamp(X)",
                "name": "nanotimestamp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [nanotimestamp](https://docs.dolphindb.com/en/Functions/n/nanotimestamp.html)\n\n\n\n#### Syntax\n\nnanotimestamp(X)\n\n#### Arguments\n\n**X** is an integer or temporal scalar/vector.\n\n#### Details\n\nConvert the data type of X to NANOTIMESTAMP. If there is no date in the argument X, return a timestamp from 1970.01.01 00:00:00.000000000 + *X* (nanoseconds).\n\nSince version 2.00.12, converting MONTH into NANOTIMESTAMP is allowed.\n\n#### Examples\n\n```\nnanotimestamp(1000000000);\n// output: 1970.01.01T00:00:01.000000000\n\nnanotimestamp(2012.12.03 12:06:09 2012.12.03 13:08:01);\n// output: [2012.12.03T12:06:09.000000000,2012.12.03T13:08:01.000000000]\n\nnanotimestamp(2012.12.03 01:22:01.123456789);\n// output: 2012.12.03T01:22:01.123456789\n\nnanotimestamp('2012.12.03 13:30:10.008007006');\n// output: 2012.12.03T13:30:10.008007006\n\nnanotimestamp(2012.01M)\n// output: 2012.01.01T00:00:00.000000000\n```\n\nRelated function: [nanotime](https://docs.dolphindb.com/en/Functions/n/nanotime.html)\n"
    },
    "ne": {
        "url": "https://docs.dolphindb.com/en/Functions/n/ne.html",
        "signatures": [
            {
                "full": "ne(X, Y)",
                "name": "ne",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ne](https://docs.dolphindb.com/en/Functions/n/ne.html)\n\n\n\n#### Syntax\n\nne(X, Y) or X!=Y\n\n#### Arguments\n\n**X** and **Y** is a scalar/pair/vector/matrix/set. If *X* or *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nIf neither *X* nor *Y* is a set, conduct the element-by-element comparison of *X* and *Y*; return 1 if the elements in *X* and *Y* are not the same.\n\nIf both *X* and *Y* are sets, check if *X* and *Y* are not identical.\n\n#### Examples\n\n```\n1 2 3 != 2;\n// output\n[1,0,1]\n\n1 2 3 ne 0 2 4;\n// output\n[1,0,1]\n\n1:2 != 1:6;\n// output\n0 : 1\n```\n\n```\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 != 4\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 1  | 0  | 1  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1 ne m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 1  | 1  | 1  |\n\nSet operation: If X!=Y then X and Y are not identical.\n\n```\nx=set(4 6);\ny=set(4 6 8);\n\nx!=y;\n// output\n1\n\nx!=x;\n// output\n0\n```\n"
    },
    "neg": {
        "url": "https://docs.dolphindb.com/en/Functions/n/neg.html",
        "signatures": [
            {
                "full": "neg(X)",
                "name": "neg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [neg](https://docs.dolphindb.com/en/Functions/n/neg.html)\n\n\n\n#### Syntax\n\nneg(X)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix.\n\nThough `neg` and the `-` operator often serve analogous purposes, precedence behavior differs:\n\n* The `neg` function, when parenthesized carries the highest priority, e.g., neg(3) + 5 is -3 + 5. Without parentheses, `neg` has lower precedence than the following expression, e.g., neg 3 + 5 is treated as -(3 + 5) resulting -8.\n\n* The `-` operator always follows the precedence rule. For example: -3 + 5 results in 2.\n\n#### Details\n\nReturn the negative of *X*.\n\n#### Examples\n\n```\nx=1:2;\n-x;\n// output\n-1 : -2\n\nx=1 0 1;\n-x;\n// output\n[-1,0,-1]\n```\n\n```\nm=1 1 1 0 0 0 $ 2:3;\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 0  |\n| 1  | 0  | 0  |\n\n```\n-m\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| -1 | -1 | 0  |\n| -1 | 0  | 0  |\n"
    },
    "neville": {
        "url": "https://docs.dolphindb.com/en/Functions/n/neville.html",
        "signatures": [
            {
                "full": "neville(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false])",
                "name": "neville",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "resampleRule",
                        "name": "resampleRule"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    },
                    {
                        "full": "[outputX=false]",
                        "name": "outputX",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [neville](https://docs.dolphindb.com/en/Functions/n/neville.html)\n\n\n\n#### Syntax\n\nneville(X, Y, resampleRule, \\[closed='left'], \\[origin='start\\_day'], \\[outputX=false])\n\n#### Arguments\n\n**X** is a strictly increasing vector of temporal type.\n\n**Y** is a numeric vector of the same length as *X*.\n\n**resampleRule** is a string. See the parameter *rule* of function [resample](https://docs.dolphindb.com/en/Functions/r/resample.html) for the optional values.\n\n**closed** and **origin** are the same as the parameters *closed* and *origin* of function [resample](https://docs.dolphindb.com/en/Functions/r/resample.html).\n\n**outputX** is a Boolean value indicating whether to output the resampled *X*. The default value is false.\n\n#### Details\n\nResample *X* based on the specified *resampleRule*, *closed* and *origin*. Perform neville interpolation on *Y* based on the resampled *X*.\n\nIf *outputX* is unspecified, return a vector of *Y* after the interpolation.\n\nIf *outputX*=true, return a tuple where the first element is the vector of resampled *X* and the second element is a vector of *Y* after the interpolation.\n\n#### Examples\n\n```\nneville([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min);\n\n// output\n[1,1.0217,1.0451,1.0703,1.0972,1.1259,1.1562,1.1884,1.2222,1.2578,\n1.2951,1.3342,1.375,1.4175,1.4618,1.5078,1.5556,1.605,1.6562,1.7092,\n1.7639,1.8203,1.8785,1.9384,2,2.0634,2.1285,2.1953,2.2639,2.3342,\n2.4062,2.48,2.5556,2.6328,2.7118,2.7925,2.875,2.9592,3.0451,3.1328,\n3.2222,3.3134,3.4062,3.5009,3.5972,3.6953,3.7951,3.8967,4]\n```\n"
    },
    "next": {
        "url": "https://docs.dolphindb.com/en/Functions/n/next.html",
        "signatures": [
            {
                "full": "next(X)",
                "name": "next",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [next](https://docs.dolphindb.com/en/Functions/n/next.html)\n\n\n\n#### Syntax\n\nnext(X)\n\n#### Arguments\n\n**X** is a vector.\n\n#### Details\n\nShift the elements of a vector to the left for one position. In comparison, [prev](https://docs.dolphindb.com/en/Functions/p/prev.html) shifts the elements of a vector to the right for one position; [move](https://docs.dolphindb.com/en/Functions/m/move.html) shifts the elements of a vector for multiple positions.\n\n#### Examples\n\n```\nx = 1..5;\nx;\n// output\n[1,2,3,4,5]\n\nnext(x);\n// output\n[2,3,4,5,]\n```\n"
    },
    "nextState": {
        "url": "https://docs.dolphindb.com/en/Functions/n/nextState.html",
        "signatures": [
            {
                "full": "nextState(X)",
                "name": "nextState",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [nextState](https://docs.dolphindb.com/en/Functions/n/nextState.html)\n\n\n\n#### Syntax\n\nnextState(X)\n\n#### Arguments\n\n**X** is a vector or matrix of temporal/Boolean/numeric type.\n\n#### Details\n\nConsecutive elements in *X* with the same value feature the same state, and a NULL value has no state. The state of each element is equal to its value. Return the next state of the current state for each element in *X*. If it is NULL, return the next adjacent state.\n\nIf *X* is a matrix, return the next state for each column of the matrix.\n\n#### Examples\n\n```\nX = [1, 2.2, NULL, 2.2, 2.3, 1, 1.2]\nnext(X)\n// output\n[2.2,,2.2,2.3,1,1.2,]\n\nnextState(X)\n// output\n[2.2,2.2,2.2,2.3,1,1.2,]\n\nX = matrix([1.0, 1.1, 1.0, 0.9], [NULL, 1.3, 2.5, 5.5], [5.5, 4.2, 1.6, 1.8])\nnextState(X)\n```\n\n| #0  | #1  | #2  |\n| --- | --- | --- |\n| 1.1 | 1.3 | 4.2 |\n| 1   | 2.5 | 1.6 |\n| 0.9 | 5.5 | 1.8 |\n|     |     |     |\n\nRelated function: [prevState](https://docs.dolphindb.com/en/Functions/p/prevState.html)\n"
    },
    "norm": {
        "url": "https://docs.dolphindb.com/en/Functions/n/norm.html",
        "signatures": [
            {
                "full": "norm(mean, std, count)",
                "name": "norm",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "std",
                        "name": "std"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [norm](https://docs.dolphindb.com/en/Functions/n/norm.html)\n\n\n\n#### Syntax\n\nnorm(mean, std, count)\n\nAlias: normal\n\n#### Arguments\n\n**mean** is a numeric scalar indicating the mean of a normal distribution.\n\n**std** is a numeric scalar indicating standard deviation of a normal distribution.\n\n**count** is an integral scalar/pair. A scalar indicates the length of the output vector. A pair indicates the dimension of the output matrix.\n\n#### Details\n\nReturn a vector (matrix) that follows a normal distribution.\n\n#### Examples\n\n```\nnorm(2.0,0.1,3);\n// output\n[2.026602,1.988621,2.101107]\n\nmean norm(3,1,10000);\n// output\n3.007866\n\nstd norm(10000);\n// output\n0.995806\n\n//Generate a random matrix\nnorm(0, 1, 3:2)\n```\n\n| col1     | col2     |\n| -------- | -------- |\n| (0.5399) | (0.8475) |\n| (1.0029) | 1.811    |\n| (0.0485) | (0.4339) |\n"
    },
    "normal": {
        "url": "https://docs.dolphindb.com/en/Functions/n/normal.html",
        "signatures": [
            {
                "full": "norm(mean, std, count)",
                "name": "norm",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "std",
                        "name": "std"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [normal](https://docs.dolphindb.com/en/Functions/n/normal.html)\n\nAlias for [norm](https://docs.dolphindb.com/en/Functions/n/norm.html)\n\n\nDocumentation for the `norm` function:\n### [norm](https://docs.dolphindb.com/en/Functions/n/norm.html)\n\n\n\n#### Syntax\n\nnorm(mean, std, count)\n\nAlias: normal\n\n#### Arguments\n\n**mean** is a numeric scalar indicating the mean of a normal distribution.\n\n**std** is a numeric scalar indicating standard deviation of a normal distribution.\n\n**count** is an integral scalar/pair. A scalar indicates the length of the output vector. A pair indicates the dimension of the output matrix.\n\n#### Details\n\nReturn a vector (matrix) that follows a normal distribution.\n\n#### Examples\n\n```\nnorm(2.0,0.1,3);\n// output\n[2.026602,1.988621,2.101107]\n\nmean norm(3,1,10000);\n// output\n3.007866\n\nstd norm(10000);\n// output\n0.995806\n\n//Generate a random matrix\nnorm(0, 1, 3:2)\n```\n\n| col1     | col2     |\n| -------- | -------- |\n| (0.5399) | (0.8475) |\n| (1.0029) | 1.811    |\n| (0.0485) | (0.4339) |\n"
    },
    "not": {
        "url": "https://docs.dolphindb.com/en/Functions/n/not.html",
        "signatures": [
            {
                "full": "not(X)",
                "name": "not",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [not](https://docs.dolphindb.com/en/Functions/n/not.html)\n\n\n\n#### Syntax\n\nnot(X) or !(X)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix.\n\n#### Details\n\nReturn NOT of each element of *X*. Returned values are 0, 1, or NULL. NOT of 0 is 1; NOT of NULL is still NULL; NOT of all other values is 0.\n\nThough `not` and the `!` operator often serve analogous purposes, precedence behavior differs:\n\n* The `not` function, when parenthesized carries the highest priority. Without parentheses, `not` has lower precedence than the following expression, e.g., `not false and false` is equivalent to `not(false and false)`, which returns true.\n\n* The `!` operator always follows the precedence rule. For example: `！false and false` is equivalent to `(!false) and false`, which returns false.\n\n#### Examples\n\n```\n!1.5;\n// output\n0\n\nnot 0;\n// output\n1\n\nx=1 0 2;\nnot x;\n// output\n[0,1,0]\n```\n\n```\nm=1 1 1 1 1 0 0 0 0 0$2:5;\nm;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 1  | 1  | 0  | 0  |\n| 1  | 1  | 0  | 0  | 0  |\n\n```\nnot m;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 0  | 0  | 0  | 1  | 1  |\n| 0  | 0  | 1  | 1  | 1  |\n\n```\n(1).not();\n// output\n0\n\n(!NULL)==NULL;\n// output\n1\n```\n\nRelated functions: [and](https://docs.dolphindb.com/en/Functions/a/and.html), [or](https://docs.dolphindb.com/en/Programming/Operators/OperatorReferences/or.html)\n"
    },
    "now": {
        "url": "https://docs.dolphindb.com/en/Functions/n/now.html",
        "signatures": [
            {
                "full": "now([nanoSecond=false])",
                "name": "now",
                "parameters": [
                    {
                        "full": "[nanoSecond=false]",
                        "name": "nanoSecond",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [now](https://docs.dolphindb.com/en/Functions/n/now.html)\n\n\n\n#### Syntax\n\nnow(\\[nanoSecond=false])\n\n#### Arguments\n\n**nanoSecond** a Boolean value indicating whether to display the result with nanosecond precision.\n\n#### Details\n\nReturn the current timestamp.\n\n#### Examples\n\n```\nnow();\n// output\n2016.05.12T19:32:49.613\n\nnow(true);\n// output\n2016.05.12T19:32:49.614243000\n```\n"
    },
    "ns": {
        "url": "https://docs.dolphindb.com/en/Functions/n/ns.html",
        "signatures": [
            {
                "full": "ns(maturity, yield, [method='nm'], [maxIter], [bounds], [initialGuess], [seed])",
                "name": "ns",
                "parameters": [
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "yield",
                        "name": "yield"
                    },
                    {
                        "full": "[method='nm']",
                        "name": "method",
                        "optional": true,
                        "default": "'nm'"
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[bounds]",
                        "name": "bounds",
                        "optional": true
                    },
                    {
                        "full": "[initialGuess]",
                        "name": "initialGuess",
                        "optional": true
                    },
                    {
                        "full": "[seed]",
                        "name": "seed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ns](https://docs.dolphindb.com/en/Functions/n/ns.html)\n\n\n\n#### Syntax\n\nns(maturity, yield, \\[method='nm'], \\[maxIter], \\[bounds], \\[initialGuess], \\[seed])\n\n#### Arguments\n\n**maturity** is a numeric vector with non-negative elements, indicating the maturity (in years) of a bond.\n\n**yield** is a numeric vector of the same length as *maturity*, indicating the bond yield.\n\n**method** (optional) is a string indicating the model used. It can be:\n\n* 'nm' (default): Nelder-Mead simplex algorithm.\n* 'bfgs': BFGS algorithm.\n* 'lbfgs': LBFGS algorithm.\n* 'slsqp': Sequential Least Squares Programming algorithm.\n* 'de': Differential Evolution algorithm.\n\n**maxIter** (optional) is an integral scalar or vector indicating the maximum number of iterations for the optimization algorithm during the fitting process.\n\n**bounds** (optional) is a numeric matrix in the shape of (N,2), where N is the number of parameters to be optimized. The two elements of each row defines the bounds (min, max) on that parameter. Note that *bounds* only takes effect when method is 'lbfgs', ‘slsqp’ or ‘de’.\n\n**initialGuess** (optional) is a numeric vector indicating the initial guess for the parameters that optimize the function.\n\nNS model: The vector contains 4 elements: initial guess of β0, β1, β2, λ, with the default value \\[0.01, 0.01, 0.01, 1.0].\n\nNSS model: The vector contains 6 elements: initial guess of β0, β1, β2, β3, λ0, λ1, with the default value \\[0.01, 0.01, 0.01, 0.01, 1.0, 1.0].\n\n**seed** (optional) is an integer indicating the random number seed used in the differential evolution algorithm to ensure the reproducibility of results. It only takes effect when *method*='de'. If not specified, a non-deterministic random number generator is used.\n\n#### Details\n\nFit yield curve using NS (Nelson-Siegel) model.\n\n**Return value**: A dictionary with the following keys:\n\n* modelName: The model used.\n* params: The fitted model parameters.\n  * NS model: a vector of length 4, containing β0, β1, β2, λ.\n  * NSS model: a vector of length 6, containing β0, β1, β2, β3, λ0, λ1.\n* fminResult: The optimization result.\n  * 'nm' : See fmin.\n  * 'bfgs': See fminBFGS.\n  * 'lbfgs': See fminLBFGSB.\n  * 'slsqp': See fminSLSQP.\n  * 'de': See differentialEvolution.\n* predict: The prediction function of the model, which returns the predicted yield with this model. It can be called using `model.predict(T)` or `predict(model, T)`, where T is the maturity in years.\n\n#### Examples\n\nUse the bfgs method to fit yield curve based on NS (Nelson-Siegel) model.\n\n```\nmaturity = [1,2,3,4,5,8,10,15,20,25,30]\nyield = [0.0039,0.0061,NULL,NULL,0.0166,NULL,0.0258,NULL,NULL,0.0332,NULL]\nmodel = ns(maturity, yield, method='bfgs');\nmodel;\n/*Output\nmodelName->ns\nparams->[0.037907009765789,-0.032345632006991,-0.048221596538028,1.48711064869407]\nfminResult->xopt->[0.037907009765789,-0.032345632006991,-0.048221596538028,1.48711064869407]\nfopt->7.682740281926149E-8\ngopt->[0.000007050477817,-0.000001557728067,8.217072418048589E-7,-7.435919702203364E-8]\niterations->29\nHinv->#0                  #1                    #2                   #3                   \n------------------- --------------------- -------------------- ---------------------\n1.046957491287936   -2.422265785994416    4.016547235964936    174.575362711334378  \n-2.422265785994413  20.767722224747515    -55.516118469836506  -1160.911707217612729\n4.016547235964929   -55.516118469836506   162.441840532431541  3127.297987855009978 \n174.575362711334378 -1160.911707217613638 3127.297987855011797 72743.950482441126951\n\nwarnFlag->0\nfcalls->165\ngcalls->33\n\npredict->nssPredict\n*/\n```\n\nUse the nm method to fit yield curve based on NS (Nelson-Siegel) model.\n\n```\nmodel = ns(maturity, yield, method='nm');\nmodel;\n/*Output\nmodelName->ns\nmodelName->ns\nparams->[-0.017297505365068,0.016544815374471,0.142682692134247,14.720778706012911]\nfminResult->xopt->[-0.017297505365068,0.016544815374471,0.142682692134247,14.720778706012911]\nfopt->0.000001443427918\niterations->446\nfcalls->740\nwarnFlag->0\n\npredict->nssPredict\n*/\n```\n\nRelated Function: [nss](https://docs.dolphindb.com/en/Functions/n/nss.html)\n"
    },
    "nss": {
        "url": "https://docs.dolphindb.com/en/Functions/n/nss.html",
        "signatures": [
            {
                "full": "nss(maturity, yield, [method='nm'], [maxIter], [bounds], [initialGuess], [seed])",
                "name": "nss",
                "parameters": [
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "yield",
                        "name": "yield"
                    },
                    {
                        "full": "[method='nm']",
                        "name": "method",
                        "optional": true,
                        "default": "'nm'"
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[bounds]",
                        "name": "bounds",
                        "optional": true
                    },
                    {
                        "full": "[initialGuess]",
                        "name": "initialGuess",
                        "optional": true
                    },
                    {
                        "full": "[seed]",
                        "name": "seed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [nss](https://docs.dolphindb.com/en/Functions/n/nss.html)\n\n\n\n#### Syntax\n\nnss(maturity, yield, \\[method='nm'], \\[maxIter], \\[bounds], \\[initialGuess], \\[seed])\n\n#### Arguments\n\n**maturity** is a numeric vector with non-negative elements, indicating the maturity (in years) of a bond.\n\n**yield** is a numeric vector of the same length as *maturity*, indicating the bond yield.\n\n**method** (optional) is a string indicating the model used. It can be:\n\n* 'nm' (default): Nelder-Mead simplex algorithm.\n* 'bfgs': BFGS algorithm.\n* 'lbfgs': LBFGS algorithm.\n* 'slsqp': Sequential Least Squares Programming algorithm.\n* 'de': Differential Evolution algorithm.\n\n**maxIter** (optional) is an integral scalar or vector indicating the maximum number of iterations for the optimization algorithm during the fitting process.\n\n**bounds** (optional) is a numeric matrix in the shape of (N,2), where N is the number of parameters to be optimized. The two elements of each row defines the bounds (min, max) on that parameter. Note that *bounds* only takes effect when method is 'lbfgs', ‘slsqp’ or ‘de’.\n\n**initialGuess** (optional) is a numeric vector indicating the initial guess for the parameters that optimize the function.\n\nNS model: The vector contains 4 elements: initial guess of β0, β1, β2, λ, with the default value \\[0.01, 0.01, 0.01, 1.0].\n\nNSS model: The vector contains 6 elements: initial guess of β0, β1, β2, β3, λ0, λ1, with the default value \\[0.01, 0.01, 0.01, 0.01, 1.0, 1.0].\n\n**seed** (optional) is an integer indicating the random number seed used in the differential evolution algorithm to ensure the reproducibility of results. It only takes effect when *method*='de'. If not specified, a non-deterministic random number generator is used.\n\n#### Details\n\nFit yield curve using NSS (Nelson-Siegel-Svensson) model.\n\n**Return value**: A dictionary with the following keys:\n\n* modelName: The model used.\n* params: The fitted model parameters.\n  * NS model: a vector of length 4, containing β0, β1, β2, λ.\n  * NSS model: a vector of length 6, containing β0, β1, β2, β3, λ0, λ1.\n* fminResult: The optimization result.\n  * 'nm' : See fmin.\n  * 'bfgs': See fminBFGS.\n  * 'lbfgs': See fminLBFGSB.\n  * 'slsqp': See fminSLSQP.\n  * 'de': See differentialEvolution.\n* predict: The prediction function of the model, which returns the predicted yield with this model. It can be called using `model.predict(T)` or `predict(model, T)`, where T is the maturity in years.\n\n#### Examples\n\nUse the bfgs method to fit yield curve based on NSS (Nelson-Siegel-Svensson) model.\n\n```\nmaturity = [1,2,3,4,5,8,10,15,20,25,30]\nyield = [0.0039,0.0061,NULL,NULL,0.0166,NULL,0.0258,NULL,NULL,0.0332,NULL]\nmodel = nss(maturity, yield, method='bfgs');\nmodel;\n\n/*Output\nmodelName->nss\nparams->[0.036140551464406,-0.017389058792285,-0.039552798745696,-0.039554933812457,1.001838685848857,1.000930288743548]\nfminResult->xopt->[0.036140551464406,-0.017389058792285,-0.039552798745696,-0.039554933812457,1.001838685848857,1.000930288743548]\nfopt->0.000003185056025\ngopt->[4.415407204305666E-7,8.382398277717584E-7,-2.683916591195157E-7,-4.651950860079524E-7,-0.000008569511408,-0.000008564345961]\niterations->10\nHinv->#0                 #1                 #2                 #3                 #4                 #5                \n------------------ ------------------ ------------------ ------------------ ------------------ ------------------\n0.492426526437359  0.696702464055202  -1.643864246164442 -1.644086017367336 0.08871259052824   0.037055616913674 \n0.696702464055203  9.022078200827937  -9.027640937693616 -9.027654505585944 0.659730122918773  0.302144825834614 \n-1.643864246164441 -9.027640937693616 12.179963755936533 11.180865226841653 -0.737531568671335 -0.323934330889313\n-1.644086017367337 -9.027654505585944 11.180865226841657 12.181767428775573 -0.737537584440894 -0.32392102429678 \n0.08871259052824   0.659730122918772  -0.737531568671335 -0.737537584440894 1.053013492023418  0.024560701245749 \n0.037055616913674  0.302144825834614  -0.323934330889313 -0.32392102429678  0.024560701245749  1.011692492570688 \n\nwarnFlag->0\nfcalls->84\ngcalls->12\n\npredict->nssPredict\n*/\n```\n\nUse the nm method to fit yield curve based on NSS (Nelson-Siegel-Svensson) model.\n\n```\nmodel = ns(maturity, yield, method='nm');\nmodel;\n/*Output\nmodelName->nss\nparams->[0.038184469794996,-0.048575389082029,-0.022287414169806,0.047523360012739,1.873046195772644,0.161159907274023]\nfminResult->xopt->[0.038184469794996,-0.048575389082029,-0.022287414169806,0.047523360012739,1.873046195772644,0.161159907274023]\nfopt->5.456415848001168E-9\niterations->541\nfcalls->860\nwarnFlag->0\n\npredict->nssPredict\n*/\n```\n\nRelated Functions: [nsspredict](https://docs.dolphindb.com/en/Functions/n/nssPredict.html), [ns](https://docs.dolphindb.com/en/Functions/n/ns.html)\n"
    },
    "nssPredict": {
        "url": "https://docs.dolphindb.com/en/Functions/n/nssPredict.html",
        "signatures": [
            {
                "full": "nssPredict(model, maturity)",
                "name": "nssPredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    }
                ]
            }
        ],
        "markdown": "### [nssPredict](https://docs.dolphindb.com/en/Functions/n/nssPredict.html)\n\n#### Syntax\n\nnssPredict(model, maturity)\n\n#### Arguments\n\n**model** is a dictionary with the following key-value pairs:\n\n* modelName: A string \"ns\" (Nelson-Siegel) or \"nss\" (Nelson-Siegel-Svensson).\n\n* params: A numeric vector indicating the fitted model parameters.\n\n  * NS model: a vector of length 4, containing β0, β1, β2, λ.\n\n  * NSS model: a vector of length 6, containing β0, β1, β2, β3, λ0, λ1.\n\n**maturity** is a numeric vector with positive elements, indicating the maturity (in years) of a bond.\n\n#### Details\n\nPredict yield using the NS/NSS model.\n\n**Examples**\n\n```\nmodel = dict(STRING, ANY)\nmodel[`modelName] = `nss\nmodel[`params] = [0.038184469794996,-0.048575389082029,-0.022287414169806,0.047523360012739,1.873046195772644,0.161159907274023]\nmaturity = [3,1]\nnssPredict(model, maturity)\n//output: [0.009904201306,0.003891991292041]\n```\n\n"
    },
    "nullFill!": {
        "url": "https://docs.dolphindb.com/en/Functions/n/nullFill!.html",
        "signatures": [
            {
                "full": "nullFill!(X, newValue)",
                "name": "nullFill!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "newValue",
                        "name": "newValue"
                    }
                ]
            }
        ],
        "markdown": "### [nullFill!](https://docs.dolphindb.com/en/Functions/n/nullFill!.html)\n\n\n\n#### Syntax\n\nnullFill!(X, newValue)\n\n#### Details\n\nPlease refer to [nullFill](https://docs.dolphindb.com/en/Functions/n/nullFill.html). The only difference between `nullFill` and `nullFill!` is that the latter assigns the result to *X* and thus changing the value of *X* after the execution.\n"
    },
    "nullFill": {
        "url": "https://docs.dolphindb.com/en/Functions/n/nullFill.html",
        "signatures": [
            {
                "full": "nullFill(X, Y)",
                "name": "nullFill",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [nullFill](https://docs.dolphindb.com/en/Functions/n/nullFill.html)\n\n\n\n#### Syntax\n\nnullFill(X, Y)\n\n#### Arguments\n\n**X** is a vector/matrix/table.\n\n**Y** is either a scalar, or a vector/matrix with the same dimension as *X*.\n\n#### Details\n\nWhen *X* is a vector/matrix:\n\n* If *Y* is a scalar: replace the NULLs in *X* with *Y*.\n\n* If *Y* is a vector/matrix : replace the NULLs in *X* with the values of corresponding elements in *Y*.\n\nWhen *X* is a table, *Y* must be a scalar, and the function replaces all NULLs in *X* with *Y*. It is especially useful when we would like to replace all NULLs in a table with a certain value, such as -999999. Note that the system will convert the data type of *Y* to the specified column during the replacement. If *Y* cannot be converted, an error is raised.\n\nThe function always returns a new object. Input *X* is not altered.\n\n#### Examples\n\nEx 1. For vectors:\n\n```\nx=1 NULL NULL 6 NULL 7;\nnullFill(x,0);\n// output\n[1,0,0,6,0,7]\n\ny=1..6\nnullFill(x,y);\n// output\n[1,2,3,6,5,7]\n```\n\nUse function `nullFill` on a vector in a table in a SQL statement:\n\n```\nID=take(1,6) join take(2,6)\ndate=take(2018.01.01..2018.01.06, 12)\nx=3.2 5.2 NULL 7.4 NULL NULL NULL NULL 8 NULL NULL 11\nt=table(ID, date, x)\nt;\n```\n\n| ID | date       | x   |\n| -- | ---------- | --- |\n| 1  | 2018.01.01 | 3.2 |\n| 1  | 2018.01.02 | 5.2 |\n| 1  | 2018.01.03 |     |\n| 1  | 2018.01.04 | 7.4 |\n| 1  | 2018.01.05 |     |\n| 1  | 2018.01.06 |     |\n| 2  | 2018.01.01 |     |\n| 2  | 2018.01.02 |     |\n| 2  | 2018.01.03 | 8   |\n| 2  | 2018.01.04 |     |\n| 2  | 2018.01.05 |     |\n| 2  | 2018.01.06 | 11  |\n\n```\nupdate t set x=x.nullFill(avg(x)) context by id;\nt;\n```\n\n| ID | date       | x        |\n| -- | ---------- | -------- |\n| 1  | 2018.01.01 | 3.2      |\n| 1  | 2018.01.02 | 5.2      |\n| 1  | 2018.01.03 | 5.266667 |\n| 1  | 2018.01.04 | 7.4      |\n| 1  | 2018.01.05 | 5.266667 |\n| 1  | 2018.01.06 | 5.266667 |\n| 2  | 2018.01.01 | 9.5      |\n| 2  | 2018.01.02 | 9.5      |\n| 2  | 2018.01.03 | 8        |\n| 2  | 2018.01.04 | 9.5      |\n| 2  | 2018.01.05 | 9.5      |\n| 2  | 2018.01.06 | 11       |\n\nEx 2. For matrices:\n\n```\nx=1 NULL 2 NULL 3 4 $ 3:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n|    | 3  |\n| 2  | 4  |\n\n```\nx.nullFill(0);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 0  |\n| 0  | 3  |\n| 2  | 4  |\n\nEx 3. For tables:\n\n```\nt=table(1..6 as id, 2.1 2.2 NULL NULL 2.4 2.6 as x, 4.3 NULL 3.6 6.7 8.8 NULL as y);\nnullFill(t, -999999);\n```\n\n| id | x       | y       |\n| -- | ------- | ------- |\n| 1  | 2.1     | 4.3     |\n| 2  | 2.2     | -999999 |\n| 3  | -999999 | 3.6     |\n| 4  | -999999 | 6.7     |\n| 5  | 2.4     | 8.8     |\n| 6  | 2.6     | -999999 |\n\nRelated functions: [isNull](https://docs.dolphindb.com/en/Functions/i/isNull.html), [hasNull](https://docs.dolphindb.com/en/Functions/h/hasNull.html), [bfill](https://docs.dolphindb.com/en/Functions/b/bfill.html), [ffill](https://docs.dolphindb.com/en/Functions/f/ffill.html), [lfill](https://docs.dolphindb.com/en/Functions/l/lfill.html)\n"
    },
    "nunique": {
        "url": "https://docs.dolphindb.com/en/Functions/n/nunique.html",
        "signatures": [
            {
                "full": "nunique(X, [ignoreNull=false])",
                "name": "nunique",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ignoreNull=false]",
                        "name": "ignoreNull",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [nunique](https://docs.dolphindb.com/en/Functions/n/nunique.html)\n\n\n\n#### Syntax\n\nnunique(X, \\[ignoreNull=false])\n\n#### Arguments\n\n**X** is a vector/array vector or a tuple composed of multiple vectors with same length.\n\n**ignoreNull** (optional) is a Boolean value. If set to true, only non-NULL elements will be included in the calculation. The default value is false. Note that if *X* is a tuple or array vector, *ignoreNull* must be set to false.\n\n#### Details\n\nIf *X* is a vector/array vector, return the number of unique elements in *X*.\n\nIf *X* is a tuple, elements of each vector at the same position forms a key, and this function returns the number of unique keys.\n\n#### Examples\n\n```\nv = [1,3,1,-6,NULL,2,NULL,1];\nnunique(v);\n// output: 5\n\n// set ignoreNull=true\nnunique(v,true);\n// output: 4\n```\n\n```\na = array(INT[], 0, 10).append!([1 2 3, 3 5, 6 8 8, 9 10])\nnunique(a)\n// output: 8\n```\n\n```\nt=table(1 2 4 8 4 2 7 1 as id, 10 20 40 80 40 20 70 10 as val);\nselect nunique([id,val]) from t;\n```\n\n| nunique |\n| ------- |\n| 5       |\n\n```\ndbName = \"dfs://testdb\"\nif(existsDatabase(dbName)){\n   dropDatabase(dbName)\n}\n\ndb=database(\"dfs://testdb\", VALUE, 2012.01.11..2012.01.29)\n\nn=100\nt=table(take(2012.01.11..2012.01.29, n) as date, symbol(take(\"A\"+string(21..60), n)) as sym, take(100, n) as val)\n\npt=db.createPartitionedTable(t, `pt, `date).append!(t)\nselect nunique(date) from pt group by sym\n```\n\n```\ndbName = \"dfs://testdb\"\nif(existsDatabase(dbName)){\ndropDatabase(dbName)\n}\n\ndb=database(\"dfs://testdb\", VALUE, 2012.01.11..2012.01.29)\n\nn=100\nt=table(take(2012.01.11..2012.01.29, n) as date, symbol(take(\"A\"+string(21..60), n)) as sym, take(100, n) as val)\n\npt=db.createPartitionedTable(t, `pt, `date).append!(t)\nselect nunique(date) from pt group by sym\n```\n"
    },
    "objByName": {
        "url": "https://docs.dolphindb.com/en/Functions/o/objByName.html",
        "signatures": [
            {
                "full": "objByName(name, [sharedVar])",
                "name": "objByName",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[sharedVar]",
                        "name": "sharedVar",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [objByName](https://docs.dolphindb.com/en/Functions/o/objByName.html)\n\n\n\n#### Syntax\n\nobjByName(name, \\[sharedVar])\n\n#### Arguments\n\n**name** is a string indicating a table name.\n\n**sharedVar** is a Boolean value.\n\n#### Details\n\nDolphinDB parses script before execution. The parsing procedure checks if a variable has been defined locally. If not, it will throw an exception. Assume we execute a locally defined function at remote nodes and the function queries a shared table that exists at remote nodes but not at the local node. If we directly call the table name in SQL statements, the system will fail to parse.\n\nTo address this issue, we introduce function `objByName` which returns an object by name at runtime.\n\nIf *sharedVar* is not specified, the system searches in local variables before searching in shared variables. If *sharedVar* = true, the system only searches in shared variables; if *sharedVar* = false, the system only searches in local variables.\n\n#### Examples\n\nAt the local node we have a table EarningsDates with 2 columns: *TICKER* and *date*. *date* is the earning announcement date. There is a table USPrices at a remote node with machine name \"localhost\" and port number 8081. It contains daily stock prices for all US stocks. We would like to get the stock prices from the remote node for all stocks in EarningsDates for the week after they announced earnings.\n\nAt the remote node, we import the data file to create the table USPrices, and then share it across all nodes as sharedUSPrices.\n\n```\nUSPrices = loadText(\"c:/DolphinDB/Data/USPrices.csv\")\nshare USPrices as sharedUSPrices;\n```\n\nAt the local node, we create the table EarningsDates, and send the table with the script over to the remote node. After the execution, the result is sent back to the local node.\n\n```\nEarningsDates=table(`XOM`AAPL`IBM as TICKER, 2006.10.26 2006.10.19 2006.10.17 as date)\ndef loadDailyPrice(data){\n   dateDict = dict(data.TICKER, data.date)\n   return select date, TICKER, PRC from objByName(\"sharedUSPrices\") where dateDict[TICKER]<date<=dateDict[TICKER]+7\n}\nconn = xdb(\"localhost\",8081)\nprices = conn(loadDailyPrice, EarningsDates);\n\nprices;\n```\n\n| date       | TICKER | PRC   |\n| ---------- | ------ | ----- |\n| 2006.10.27 | XOM    | 71.46 |\n| 2006.10.30 | XOM    | 70.84 |\n| 2006.10.31 | XOM    | 71.42 |\n| 2006.11.01 | XOM    | 71.06 |\n| 2006.11.02 | XOM    | 71.19 |\n| 2006.10.18 | IBM    | 89.82 |\n| 2006.10.19 | IBM    | 89.86 |\n| 2006.10.20 | IBM    | 90.48 |\n| 2006.10.23 | IBM    | 91.56 |\n| 2006.10.24 | IBM    | 91.49 |\n| 2006.10.20 | AAPL   | 79.95 |\n| 2006.10.23 | AAPL   | 81.46 |\n| 2006.10.24 | AAPL   | 81.05 |\n| 2006.10.25 | AAPL   | 81.68 |\n| 2006.10.26 | AAPL   | 82.19 |\n"
    },
    "objectChecksum": {
        "url": "https://docs.dolphindb.com/en/Functions/o/objectChecksum.html",
        "signatures": [
            {
                "full": "objectChecksum(vector, [prev])",
                "name": "objectChecksum",
                "parameters": [
                    {
                        "full": "vector",
                        "name": "vector"
                    },
                    {
                        "full": "[prev]",
                        "name": "prev",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [objectChecksum](https://docs.dolphindb.com/en/Functions/o/objectChecksum.html)\n\n\n\n#### Syntax\n\nobjectChecksum(vector, \\[prev])\n\n#### Arguments\n\n**vector** is a vector that is used for calculating checksums.\n\n**prev** is an integer. If the vector is too long, the checksum can be computed iteratively by specifying *prev* which represents the checksum of the previous segment of data during iteration.\n\n#### Details\n\nCalculate the checksum of a vector. The result is an integer. It is often used to verify data integrity.\n\n#### Examples\n\n```\nprint objectChecksum(take(`A`B`C, 10))\n// output\n-268298654\n\nprint objectChecksum(2.3 6.5 7.8)\n// output\n-430996932\n\n//calculate checksum section by section\nprint objectChecksum(1..15)\n// output\n-1877567753\n\nt0 = objectChecksum(1..5)\nt1 = objectChecksum(6..10, t0)\nt2 = objectChecksum(11..15, t1)\nprint t2\n// output\n-1877567753\n```\n"
    },
    "objs": {
        "url": "https://docs.dolphindb.com/en/Functions/o/objs.html",
        "signatures": [
            {
                "full": "objs([shared=false])",
                "name": "objs",
                "parameters": [
                    {
                        "full": "[shared=false]",
                        "name": "shared",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [objs](https://docs.dolphindb.com/en/Functions/o/objs.html)\n\n\n\n#### Syntax\n\nobjs(\\[shared=false])\n\n#### Arguments\n\n**shared** is Boolean variable.\n\n* false (default): return info on all variables in the current session\n\n* true: return info on all variables in the current session and variables shared by other sessions\n\n#### Details\n\nObtain the information on the variables in memory. Return a table with the following columns:\n\n* name: variable name\n\n* type: data type\n\n* form: data form\n\n* rows:\n\n  * If the data form is vector/dictionary/set, return the number of all elements (including NULL values);\n\n  * If the data form is matrix/table, return the number of rows.\n\n* columns:\n\n  * If the data form is vector/dictionary/set, return 1;\n\n  * If the data form is matrix/table, return the number of columns.\n\n* bytes: the memory (in bytes) used by the variable\n\n* shared: whether it is a shared variable\n\n* extra: the logical path to the DFS table, in the format of \"dfs\\://dbName/tableName\"\n\n* owner: the creator of shared variables. This column will only be displayed when *shared* is set to true. It will be left empty for local variables.\n\nPlease note that the function does not return the function definitions. You can use defs to check function definitions, or [memSize](https://docs.dolphindb.com/en/Functions/m/memSize.html) for the memory usage.\n\n#### Examples\n\n```\n//create a DFS database\nif(existsDatabase(\"dfs://listdb\")){\n        dropDatabase(\"dfs://listdb\")\n}\nn=1000000\nticker = rand(`MSFT`GOOG`FB`ORCL`IBM,n);\nticker[0..5]\nx=rand(1.0, n)\nt=table(ticker, x)\ndb=database(directory=\"dfs://listdb\", partitionType=HASH, partitionScheme=[STRING, 5])\npt=db.createPartitionedTable(t, `pt, `ticker)\npt.append!(t)\n\n// shared in-memory table\ntime = take(2021.08.20 00:00:00..2021.08.30 00:00:00, 40);\nid = 0..39;\nvalue = rand(100, 40);\ntmp = table(time, id, value);\nshare tmp as st\n\n// create set\ns = set([1,2,3,4,5])\n\n// create dict\nx=1 2 3\ny=4.5 7.8 4.3\nz=dict(x,y);\n\n// create matrix\nm = matrix(1 2 3, 4 5 6)\n\n// create pair\np = 1:2\n```\n\n```\nobjs(true)\n```\n\n| name   | type     | form       | rows      | columns | bytes      | shared | extra            | owner |\n| ------ | -------- | ---------- | --------- | ------- | ---------- | ------ | ---------------- | ----- |\n| n      | INT      | SCALAR     | 1         | 1       | 16         | false  |                  |       |\n| ticker | SYMBOL   | VECTOR     | 1,000,000 | 1       | 4,000,000  | false  |                  |       |\n| x      | INT      | VECTOR     | 3         | 1       | 12         | false  |                  |       |\n| t      | BASIC    | TABLE      | 1,000,000 | 2       | 12,000,312 | false  |                  |       |\n| db     | HANDLE   | SCALAR     | 1         | 1       | 24         | false  |                  |       |\n| pt     | ALIAS    | TABLE      | 0         | 2       | 12,000,000 | false  | dfs\\://listdb/pt |       |\n| time   | DATETIME | VECTOR     | 40        | 1       | 160        | false  |                  |       |\n| id     | INT      | VECTOR     | 40        | 1       | 160        | false  |                  |       |\n| value  | INT      | VECTOR     | 40        | 1       | 160        | false  |                  |       |\n| tmp    | BASIC    | TABLE      | 40        | 3       | 832        | false  |                  |       |\n| s      | INT      | SET        | 5         | 1       | 28         | false  |                  |       |\n| y      | DOUBLE   | VECTOR     | 3         | 1       | 24         | false  |                  |       |\n| z      | DOUBLE   | DICTIONARY | 3         | 1       | 199        | false  |                  |       |\n| m      | INT      | MATRIX     | 3         | 2       | 24         | false  |                  |       |\n| p      | INT      | PAIR       | 2         | 1       | 8          | false  |                  |       |\n| st     | BASIC    | TABLE      | 40        | 3       | 832        | true   |                  | admin |\n"
    },
    "ols": {
        "url": "https://docs.dolphindb.com/en/Functions/o/ols.html",
        "signatures": [
            {
                "full": "ols(Y, X, [intercept=true], [mode=0], [method='default'],[usePinv=true])",
                "name": "ols",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[method='default']",
                        "name": "method",
                        "optional": true,
                        "default": "'default'"
                    },
                    {
                        "full": "[usePinv=true]",
                        "name": "usePinv",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [ols](https://docs.dolphindb.com/en/Functions/o/ols.html)\n\n\n\n#### Syntax\n\nols(Y, X, \\[intercept=true], \\[mode=0], \\[method='default'],\\[usePinv=true])\n\n#### Arguments\n\n**Y** is the dependent variable; **X** is the independent variable(s).\n\n**Y** is a vector; **X** is a vector/matrix/table/tuple.\n\nWhen *X* is a matrix,\n\n* If the number of rows equals the length of *Y*, each column of *X* is a factor;\n* If the number of rows is not the same as the length of *Y*, and the number of columns equals the length of *Y*, each row of *X* is a factor.\n\n**intercept** is a Boolean variable indicating whether the regression includes the intercept. If it is true, the system automatically adds a column of 1's to *X* to generate the intercept. The default value is true.\n\n**mode** is an integer indicating the contents in the output. It can be:\n\n* 0 (default): a vector of the coefficient estimates.\n\n* 1: a table with coefficient estimates, standard error, t-statistics, and p-values.\n\n* 2: a dictionary with the following keys: ANOVA, RegressionStat, Coefficient and Residual\n\n| Source of Variance | DF (degree of freedom) | SS (sum of square)             | MS (mean of square)               | F (F-score) | Significance |\n| ------------------ | ---------------------- | ------------------------------ | --------------------------------- | ----------- | ------------ |\n| Regression         | p                      | sum of squares regression, SSR | regression mean square, MSR=SSR/R | MSR/MSE     | p-value      |\n| Residual           | n-p-1                  | sum of squares error, SSE      | mean square error, MSE=MSE/E      |             |              |\n| Total              | n-1                    | sum of squares total, SST      |                                   |             |              |\n\n| Item         | Description                                                                                                                                   |\n| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------- |\n| R2           | R-squared                                                                                                                                     |\n| AdjustedR2   | The adjusted R-squared corrected based on the degrees of freedom by comparing the sample size to the number of terms in the regression model. |\n| StdError     | The residual standard error/deviation corrected based on the degrees of freedom.                                                              |\n| Observations | The sample size.                                                                                                                              |\n\n| Item     | Description                                                             |\n| -------- | ----------------------------------------------------------------------- |\n| factor   | Independent variables                                                   |\n| beta     | Estimated regression coefficients                                       |\n| StdError | Standard error of the regression coefficients                           |\n| tstat    | t statistic, indicating the significance of the regression coefficients |\n\nResidual: the difference between each predicted value and the actual value.\n\n**method** (optional) is a string indicating the method for the ordinary-least-squares regression problem.\n\n* When set to \"default\" (by default), `ols` solves the problem by constructing coefficient matrices and inverse matrices.\n\n* When set to \"svd\", `ols` solves the problem by using singular value decomposition.\n\n**usePinv** (optional) is a Boolean value indicating whether to use pseudo-inverse method to calculate inverse of a matrix.\n\n* true (default): computing the pseudo-inverse of the matrix. It must be true for singular matrices.\n\n* false: computing the inverse of the matrix, which is only applicable to non-singular matrices.\n\n#### Details\n\nReturn the result of an ordinary-least-squares regression of *Y* on *X*.\n\nNote that NULL values in *X* and *Y* are treated as 0 in calculations.\n\n#### Examples\n\n```\nx1=1 3 5 7 11 16 23\nx2=2 8 11 34 56 54 100\ny=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\n\nols(y, x1);\n// output\n[-9.912821,3.378632]\n\nols(y, (x1,x2));\n// output\n[-9.494813,2.806426,0.13147]\n```\n\n```\nols(y, (x1,x2), 1, 1);\n```\n\n| factor    | beta      | stdError | tstat     | pvalue   |\n| --------- | --------- | -------- | --------- | -------- |\n| intercept | -9.494813 | 5.233168 | -1.814353 | 0.143818 |\n| x1        | 2.806426  | 1.830782 | 1.532911  | 0.20007  |\n| x2        | 0.13147   | 0.409081 | 0.321379  | 0.764015 |\n\n```\nols(y, (x1,x2), 1, 2);\n// output\nANOVA->\nBreakdown  DF SS          MS          F         Significance\n---------- -- ----------- ----------- --------- ------------\nRegression 2  4204.416396 2102.208198 31.467739 0.003571\nResidual   4  267.220747  66.805187\nTotal      6  4471.637143\n\nRegressionStat->\nitem         statistics\n------------ ----------\nR2           0.940241\nAdjustedR2   0.910361\nStdError     8.173444\nObservations 7\n\nCoefficient->\nfactor    beta      stdError tstat     pvalue\n--------- --------- -------- --------- --------\nintercept -9.494813 5.233168 -1.814353 0.143818\nx1        2.806426  1.830782 1.532911  0.20007\nx2        0.13147   0.409081 0.321379  0.764015\n```\n\n```\nx=matrix(1 4 8 2 3, 1 4 2 3 8, 1 5 1 1 5);\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 4  | 4  | 5  |\n| 8  | 2  | 1  |\n| 2  | 3  | 1  |\n| 3  | 8  | 5  |\n\n```\nols(1..5, x);\n// output\n[1.156537,0.105505,0.91055,-0.697821]\n\nols(1..5, x.transpose());\n// output\n[1.156537,0.105505,0.91055,-0.697821]\n// the system adjusts the dimensions of the dependent variable and the independent variables for the regression to go through.\n```\n\n```\nx = table([13.9782,13.4688,13.4336,12.9642,12.7905,13.4771,13.0423,12.6588,13.8933,13.9006] as col0, [195.3904,181.4090,180.4627,168.0723,163.5973,181.6342,170.1017,160.2477,193.0241,193.2270] as col1, [2731.2089,2443.3656,2424.2715,2178.9356,2092.4947,2447.9167,2218.5185,2028.5594,2681.7456,2685.9754] as col2)\ny = [-0.4002,-0.8004,-0.2002,-1.0002,-0.2001,-0.5001,-0.2501,0.0000,0.0000,0.0000]\n\nols(y, x, true, 0, \"default\")\n// output\n[2.968166,13.023638,-2.016390,0.076485]\n\nols(y, x, true, 0, \"svd\")\n//output\n[3266.457957,-722.195120,53.157806,-1.302769]\n```\n"
    },
    "olsEx": {
        "url": "https://docs.dolphindb.com/en/Functions/o/olsEx.html",
        "signatures": [
            {
                "full": "olsEx(ds, Y, X, [intercept=true], [mode=0])",
                "name": "olsEx",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [olsEx](https://docs.dolphindb.com/en/Functions/o/olsEx.html)\n\n\n\n#### Syntax\n\nolsEx(ds, Y, X, \\[intercept=true], \\[mode=0])\n\n#### Details\n\nReturn the result of an ordinary-least-squares regression of *Y* on *X*. *Y* and *X* are columns in a partitioned table.\n\nNote that NULL values in *X* and *Y* are treated as 0 in calculations.\n\n#### Arguments\n\n**ds** a set of data sources stored in a tuple. It is usually generated by the function [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html).\n\n**Y** a string indicating the column name of the dependent variable from the table represented by *ds*.\n\n**X** a string scalar/vector indicating the column name(s) of independent variable(s) from the table represented by *ds*.\n\n**intercept** is a boolean variable indicating whether the regression includes the intercept. If it is true, the system automatically adds a column of 1's to *X* to generate the *intercept*. The default value is true.\n\n**mode** is an integer that could be 0,1,2. It indicates the contents in the output. The default value is 0.\n\n* 0: a vector of the coefficient estimates\n\n* 1: a table with coefficient estimates, standard error, t-statistics, and p-value\n\n* 2: a dictionary with all statistics\n\n#### Examples\n\n```\nn=10000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nvol=rand(1..10 join int(), n)\nprice=rand(100,n)\nt=table(ID, date, vol,price)\nsaveText(t, \"D:/DolphinDB/Data/t.txt\");\nif(existsDatabase(\"dfs://rangedb\")){\n  dropDatabase(\"dfs://rangedb\")\n}\ndb = database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 51 101)\nUSPrices=loadTextEx(dbHandle=db,tableName=`USPrices, partitionColumns=`ID, filename=\"/home/DolphinDB/Data/t.txt\");\n\nds=sqlDS(<select vol as VS, price as SBA from USPrices where vol>5>)\nrs=olsEx(ds, `VS, `SBA, true, 2)\nrs;\n\n// output\nRegressionStat->\nitem         statistics\n------------ ----------\nR2           0.000848\nAdjustedR2   0.000628\nStdError     1.404645\nObservations 4535\n\nANOVA->\nBreakdown  DF   SS          MS       F        Significance\n---------- ---- ----------- -------- -------- ------------\nRegression 1    7.592565    7.592565 3.848178 0.049861\nResidual   4533 8943.739298 1.973029\nTotal      4534 8951.331863\n\nCoefficient->\nfactor    beta     stdError tstat      pvalue\n--------- -------- -------- ---------- --------\nintercept 7.953084 0.04185  190.039423 0\nSBA       0.001422 0.000725 1.961677   0.049861\n```\n"
    },
    "oneHot": {
        "url": "https://docs.dolphindb.com/en/Functions/o/oneHot.html",
        "signatures": [
            {
                "full": "oneHot(obj, encodingColumns)",
                "name": "oneHot",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "encodingColumns",
                        "name": "encodingColumns"
                    }
                ]
            }
        ],
        "markdown": "### [oneHot](https://docs.dolphindb.com/en/Functions/o/oneHot.html)\n\n\n\n#### Syntax\n\noneHot(obj, encodingColumns)\n\n#### Arguments\n\n**obj** is an in-memory table.\n\n**encodingColumns** is a STRING scalar or vector, indicating the columns for one-hot encoding.\n\n#### Details\n\nPerform one-hot encoding on the specified columns in an in-memory table. It returns a table with columns in the order of encoded columns and non-encoded columns. The name of the encoded columns is \"original column name\\_value\".\n\n#### Examples\n\n```\nt = table( take(`Tom`Lily`Jim, 10) as name, take(true false, 10) as gender, take(21..23,10) as age);\noneHot(t, `name`gender);\n```\n\n| name\\_Tom | name\\_Lily | name\\_Jim | gender\\_1 | gender\\_0 | age |\n| --------- | ---------- | --------- | --------- | --------- | --- |\n| 1         | 0          | 0         | 1         | 0         | 21  |\n| 0         | 1          | 0         | 0         | 1         | 22  |\n| 0         | 0          | 1         | 1         | 0         | 23  |\n| 1         | 0          | 0         | 0         | 1         | 21  |\n| 0         | 1          | 0         | 1         | 0         | 22  |\n| 0         | 0          | 1         | 0         | 1         | 23  |\n| 1         | 0          | 0         | 1         | 0         | 21  |\n| 0         | 1          | 0         | 0         | 1         | 22  |\n| 0         | 0          | 1         | 1         | 0         | 23  |\n| 1         | 0          | 0         | 0         | 1         | 21  |\n"
    },
    "osqp": {
        "url": "https://docs.dolphindb.com/en/Functions/o/osqp.html",
        "signatures": [
            {
                "full": "osqp(q, [P], [A], [lb], [ub])",
                "name": "osqp",
                "parameters": [
                    {
                        "full": "q",
                        "name": "q"
                    },
                    {
                        "full": "[P]",
                        "name": "P",
                        "optional": true
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[lb]",
                        "name": "lb",
                        "optional": true
                    },
                    {
                        "full": "[ub]",
                        "name": "ub",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [osqp](https://docs.dolphindb.com/en/Functions/o/osqp.html)\n\n\n\n#### Syntax\n\nosqp(q, \\[P], \\[A], \\[lb], \\[ub])\n\n#### Arguments\n\n**q** is a vector indicating the linear coefficient of the objective function.\n\n**P** (optional) is a positive semi-definite matrix indicating the quadratic coefficients of the objective function.\n\n**A** (optional) is the coefficient matrix of linear inequality constraints.\n\n**lb** (optional) is the left-hand-side vector of the linear inequality constraint.\n\n**ub**(optional) is the right-hand-side vector of the linear inequality constraint.\n\n*A*, *lb*, and *ub* must be all specified or not.\n\n*lb* and *ub* can contain NULLs, but their length must match the number of rows in *A*. NULLs in *ub* and *lb* are treated as positive/negative infinity and take ±1030 during computation.\n\n#### Details\n\nSolve the following optimization problem with a quadratic objective function and a set of linear constraints.\n\n![](https://docs.dolphindb.com/en/images/osqp.png)\n\nReturn value: A 2-element tuple:\n\n* The first element is a string indicating the state of the solution:\n\n  * solved: solution found;\n\n  * solved inaccurate: solution found but the result is inaccurate;\n\n  * primal infeasible: no feasible solution to the primal;\n\n  * dual infeasible: no feasible solution to the dual;\n\n  * maximum iterations reached: reach the maximum number of iterations;\n\n  * run time limit reached: execution timeout;\n\n  * problem non convex: the problem is non-convex;\n\n  * interrupted: solution interrupted;\n\n  * unsolved: solution not found.\n\n* The second element is the value of x where the value of the objective function is minimized.\n\n#### Examples\n\n```\nP = matrix(4e-2 6e-3 -4e-3 0.0, 6e-3 1e-2 0.0 0.0, -4e-3 0.0 2.5e-3 0.0, 0.0 0.0 0.0 0.0)\nq = [-2, -4, 2, 3]\nA = [1,3,3,-2,2,-1,1,-4,1,2,-1,-5,1,1,1,1]$4:4\nl = [,,,1.0]\nu = [3.0,2.0,-1.0,1.0]\nres = osqp(q, P, newA, l, u)\nprint(res)\n// output\n(\"solved\",[-64.364818313795097,368.910318139716082,-548.041799338347459,244.496302999333039])\n```\n"
    },
    "pack": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pack.html",
        "signatures": [
            {
                "full": "pack(format, args…)",
                "name": "pack",
                "parameters": [
                    {
                        "full": "format",
                        "name": "format"
                    },
                    {
                        "full": "args…",
                        "name": "args…"
                    }
                ]
            }
        ],
        "markdown": "### [pack](https://docs.dolphindb.com/en/Functions/p/pack.html)\n\n\n\n#### Syntax\n\npack(format, args…)\n\n#### Arguments\n\n**format** is a format string. See **Appendix: Format Characters**.\n\n* A format character may be preceded by an integral repeat count. For example, the format string *4h* means exactly the same as *hhhh*.\n\n* Whitespace characters between formats are ignored; a count and its format must not contain whitespace though.\n\n* For the *s* format character, the count is interpreted as the length of the bytes, not a repeat count like for the other format characters; for example, *10s* means a single 10-byte string, while *10c* means 10 characters. If a count is not given, it defaults to 1. The string is truncated or padded with null bytes as appropriate to make it fit.\n\n**args...** The data to be packed. The arguments must match the values required by the format exactly.\n\n#### Details\n\nReturn a bytes object packed according to the format string format.\n\n#### Examples\n\n```\nres = pack(\"N\",1);\nres1 = unpack(\"N\", res);\nprint(res1)\n// output\n(1)\n\nres = pack(\"iii\", 1, 2, 3)\nres1 = unpack(\"iii\",  res);\nprint(res1)\n// output\n(1,2,3)\n\nres = pack(\"x\",NULL)\nres = unpack(\"x\",pack(\"x\",NULL))\ntypestr(res[0])\n// output\nVOID\n\nres = pack(\"3si\", `123, 3)\nres1 = unpack(\"3si\",  res);\nprint(res1)\n// output\n(\"123\",3)\n```\n\n#### Appendix\n\nPlease see [Appendix: Format Characters](https://docs.dolphindb.com/en/Functions/appendix.html) for the format mapping.\n\nThe first character of the format string can be used to indicate the byte order, size and alignment of the packed data, see [Appendix: Byte Order, Size and Alignment](https://docs.dolphindb.com/en/Functions/appendix.md#). If the first character is not one of these characters, '@' is assumed.\n\nRelated functions: [unpack](https://docs.dolphindb.com/en/Functions/u/unpack.html)\n"
    },
    "pair": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pair.html",
        "signatures": [
            {
                "full": "pair(a, b)",
                "name": "pair",
                "parameters": [
                    {
                        "full": "a",
                        "name": "a"
                    },
                    {
                        "full": "b",
                        "name": "b"
                    }
                ]
            }
        ],
        "markdown": "### [pair](https://docs.dolphindb.com/en/Functions/p/pair.html)\n\n\n\n#### Syntax\n\npair(a, b) or a:b\n\n#### Arguments\n\n**a** and **b** must be scalar.\n\n#### Details\n\nReturn a data pair.\n\n#### Examples\n\n```\n1:3+1;\n// output\n2:4\n\n1:3<0:6;\n// output\n0 : 1\n```\n"
    },
    "panel": {
        "url": "https://docs.dolphindb.com/en/Functions/p/panel.html",
        "signatures": [
            {
                "full": "panel(row, col, metrics, [rowLabel], [colLabel], [parallel=false])",
                "name": "panel",
                "parameters": [
                    {
                        "full": "row",
                        "name": "row"
                    },
                    {
                        "full": "col",
                        "name": "col"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "[rowLabel]",
                        "name": "rowLabel",
                        "optional": true
                    },
                    {
                        "full": "[colLabel]",
                        "name": "colLabel",
                        "optional": true
                    },
                    {
                        "full": "[parallel=false]",
                        "name": "parallel",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [panel](https://docs.dolphindb.com/en/Functions/p/panel.html)\n\n\n\n#### Syntax\n\npanel(row, col, metrics, \\[rowLabel], \\[colLabel], \\[parallel=false])\n\n#### Arguments\n\n**row** is a vector. Each element corresponds to a row in a matrix in the result.\n\n**col** is a vector. Each element corresponds to a column in a matrix in the result.\n\n**metrics** is one or multiple vectors. Each vector in metrics corresponds to a matrix in the result.\n\n**rowLabel** is a vector of row labels for the matrix (or matrices) in the result. It is composed of distinct values in ascending order. The result only includes the rows specified in *rowLabel*.\n\n**colLabel** is a vector of column labels for the matrix (or matrices) in the result. It is composed of distinct values in ascending order. The result only includes the columns specified in *colLabel*.\n\n**parallel** is a Boolean value indicating whether to conduct parallel computing. The default value is false.\n\n#### Details\n\nRearrange *metrics* as a matrix (or multiple matrices). For each vector in *metrics*, return a matrix.\n\nFunction `panel` is similar to SQL [pivotBy](https://docs.dolphindb.com/en/Programming/SQLStatements/pivotBy.html) clause in that they can both rearrange data as a matrix based on 2 dimensions. The difference is that `exec... pivot by...` can only convert one column into a matrix whereas function `panel` can convert one or multiple columns into one or multiple matrices.\n\n#### Examples\n\n```\nt = table(1 1 2 2 2 3 3 as id, 2020.09.01 + 1 3 1 2 3 2 3 as date, 1..7 as value);\n// output\nt;\n```\n\n| id | date       | value |\n| -- | ---------- | ----- |\n| 1  | 2020.09.02 | 1     |\n| 1  | 2020.09.04 | 2     |\n| 2  | 2020.09.02 | 3     |\n| 2  | 2020.09.03 | 4     |\n| 2  | 2020.09.04 | 5     |\n| 3  | 2020.09.03 | 6     |\n| 3  | 2020.09.04 | 7     |\n\n```\npanel(t.date, t.id, t.value);\n```\n\n|            | 1 | 2 | 3 |\n| ---------- | - | - | - |\n| 2020.09.02 | 1 | 3 |   |\n| 2020.09.03 |   | 4 | 6 |\n| 2020.09.04 | 2 | 5 | 7 |\n\n```\npanel(t.date, t.id, t.value, 2020.09.02 2020.09.03, 1 2);\n```\n\n|            | 1 | 2 |\n| ---------- | - | - |\n| 2020.09.02 | 1 | 3 |\n| 2020.09.03 |   | 4 |\n\n```\npanel(t.date, t.id, [t.value, t.value>0], 2020.09.02 2020.09.03, 1 2);\n```\n\n|            | 1 | 2 |\n| ---------- | - | - |\n| 2020.09.02 | 1 | 3 |\n| 2020.09.03 |   | 4 |\n\n|            | 1 | 2 |\n| ---------- | - | - |\n| 2020.09.02 | 1 | 1 |\n| 2020.09.03 |   | 1 |\n\nCalculate the cumulative maximum price of each stock from the matrix generated by function `panel`.\n\n```\nsyms = \"sym\"+string(1..2)\ndates = 2021.12.07..2021.12.11\nt = table(loop(take{, size(syms)}, dates).flatten() as trade_date,  take(syms, size(syms)*size(dates)) as code, rand(1000, (size(syms)*size(dates))) as volume)\nvolume = panel(t.trade_date, t.code, t.volume, dates)\ncummax(volume)\n```\n"
    },
    "parseExpr": {
        "url": "https://docs.dolphindb.com/en/Functions/p/parseExpr.html",
        "signatures": [
            {
                "full": "parseExpr(X, [varDict], [modules], [overloadedOperators])",
                "name": "parseExpr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[varDict]",
                        "name": "varDict",
                        "optional": true
                    },
                    {
                        "full": "[modules]",
                        "name": "modules",
                        "optional": true
                    },
                    {
                        "full": "[overloadedOperators]",
                        "name": "overloadedOperators",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [parseExpr](https://docs.dolphindb.com/en/Functions/p/parseExpr.html)\n\n\n\n#### Syntax\n\nparseExpr(X, \\[varDict], \\[modules], \\[overloadedOperators])\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n**varDict** is an optional parameter, which is a dictionary. If *varDict* is specified, while parsing by function [eval](https://docs.dolphindb.com/en/Functions/e/eval.html) , the variable in *X* will be parsed as the key of *varDict*. And the value of this variable is the value of *varDict*.\n\n**modules** is an optional parameter which can be a string or an array of strings, indicating the name of the module to be loaded.\n\n**overloadedOperators** is an optional parameter, which is a dictionary. The operators are mapped to a function. The key must be a string scalar, and the value must be a binary function.\n\n#### Details\n\nConvert string into metacode, which can be executed by function [eval](https://docs.dolphindb.com/en/Functions/e/eval.html).\n\n#### Examples\n\n```\na=parseExpr(\"1+2\")\na;\n// output\n< 1 + 2 >\n\ntypestr(a);\n// output\nCODE\n\na.eval();\n// output\n3\n```\n\nParse JSON strings into dictionaries:\n\n```\njson1 = '{\"f2\":10.71,\"f12\":\"000001\"},{\"f2\":7.24,\"f12\":\"000002\"}'\nparseExpr(json1).eval()\n\n/*\noutput:\nf2->10.71\nf12->000001\n*/\n```\n\n```\nt=table(1 2 3 4 as id, 5 6 7 8 as value, `IBM`MSFT`IBM`GOOG as name);\nparseExpr(\"select * from t where name='IBM'\").eval();\n```\n\n| id | value | name |\n| -- | ----- | ---- |\n| 1  | 3     | IBM  |\n| 3  | 7     | IBM  |\n\nWhen function `parseExpr` parses variables, it first searches local variables, and then searches shared variables. It does not, however, search local variables within function definition.\n\n```\ndef myfunc(){\n    t3 = table(1..100 as id)\n    return parseExpr(\"select * from t3 where id in 1..5\").eval()\n}\n\nmyfunc()\n```\n\nThe script above produces the following error message:\n\n```\nmyfunc() => myfunc: return ::evaluate(parseExpr(\"select * from t3 where id in 1..5\")) => Can't find the object with name t3\n```\n\nFor this issue, we can use function [sql](https://docs.dolphindb.com/en/Functions/s/sql.html) to dynamically generate SQL statements:\n\n```\ndef myfunc(){\nt3 = table(1..100 as id)\nreturn sql(sqlCol(\"*\"), t3, <id in 1..5>).eval()\n}\nmyfunc();\n```\n\n| id |\n| -- |\n| 1  |\n| 2  |\n| 3  |\n| 4  |\n| 5  |\n\nPass in the variables and values in the expression in the form of a dictionary, and assigning a value to the key of this dict is equivalent to assign a value to the variable.\n\n```\nd = dict(`a`b`c, (1, 2, 3))\nparseExpr(\"a + b*c\", d).eval()\n// output\n7\nd[`a] = 5;\nparseExpr(\"a + b*c\", d).eval()\n// output\n11\n```\n\nThe following example explains how to use functions in expressions. Because the variable \"first\" is not stored in dict, \"first\" is directly treated as a function when parsed.\n\n```\nindex = [2000.01.01, 2000.01.31, 2000.02.15, 2000.02.20, 2000.03.12, 2000.04.16, 2000.05.06, 2000.08.30]\ns = indexedSeries(index, 1..8)\nd1 =  dict(STRING, ANY)\nd1[\"S\"] = s\nparseExpr(\"resample(S, `M, first)\", d1).eval()\n```\n\nFunction `add` is defined in the test module under the modules directory. It is used to call the function in the module and map the binary operator \"+\" to a new function by specifying the parameter *overloadedOperators* at the same time. When the code is executed, the expression with operator \"+\" will be calculated according to the new definition.\n\n```\nparseExpr(\"test::add(1,2)+2\", modules=\"test\", overloadedOperators={\"+\": def(a, b){return a - b}}).eval()\n// output\n1\n```\n\nRelated functions: [expr](https://docs.dolphindb.com/en/Functions/e/expr.html), [eval](https://docs.dolphindb.com/en/Functions/e/eval.html)\n"
    },
    "parseInteger": {
        "url": "https://docs.dolphindb.com/en/Functions/p/parseInteger.html",
        "signatures": [
            {
                "full": "parseInteger(X, type, [radix=10])",
                "name": "parseInteger",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "type",
                        "name": "type"
                    },
                    {
                        "full": "[radix=10]",
                        "name": "radix",
                        "optional": true,
                        "default": "10"
                    }
                ]
            }
        ],
        "markdown": "### [parseInteger](https://docs.dolphindb.com/en/Functions/p/parseInteger.html)\n\n#### Syntax\n\nparseInteger(X, type, \\[radix=10])\n\nAlias: parseInt\n\n#### Arguments\n\n**X** is a STRING scalar, vector, pair or matrix.\n\n**type** specifies the data type of the integer, which can be CHAR, SHORT, INT or LONG.\n\n**radix** (optional) is an integer in \\[2, 16] that represents the radix (the base in mathematical numeral systems) of the integer. The default value is 10.\n\n* For *radix* 2, only '0' and '1' are allowed.\n* For *radix* 11-16, 'A'/'a' to 'F'/'f' (case insensitive) are used for 10-15.\n* Specifically for *radix* 16, leading '0x' or '0X' is allowed.\n\n#### Details\n\n`parseInteger` parses *X* into an integer of the specified *type* in specified *radix*. If it encounters a character that is not a numeral in the specified *radix*, it ignores it and all succeeding characters and returns the integer value parsed up to that point. An exception will be thrown if the first character is invalid.\n\n**Return value**: A CHAR/SHORT/INT/LONG scalar/vector/pair/matrix of the same shape as *X*.\n\n**Note:**\n\n* Leading whitespaces or zeros are ignored during parsing.\n* Decimal values are not supported, i.e., the point `.` is considered illegal.\n* An empty string is parsed as NULL.\n* The sign character `+/-` indicates positive or negative only if it appears after a leading whitespace, otherwise it is considered illegal.\n\n#### Examples\n\n```\nparseInteger([\" \", \"000\", \"012\", \" 12\",\"12a\", \"1a2\",\"+12a\", \"-12\"], INT)\n//output: [ , 0, 12, 12, 12, 1, 12, -12]\n\nparseInteger(\"a12\", INT)\n//Error: 'Invalid string to parse.'\n\nparseInteger([\"012\", \" 12\",\"12a\", \"1a2\",\"1A2\", \"-1A2\"], INT, 11)\n//output: [13, 13, 153, 233, 233, -233]\n\nparseInteger(\"0X16\", INT)\n//output:0\n\nparseInteger([\"0x16\", \"3F\"], INT, 16)\n//output:[22, 63]\n\nparseInteger( \"9\" , INT, 8)\n//Error: 'Invalid string to parse.'\n```\n\n"
    },
    "parseJsonTable": {
        "url": "https://docs.dolphindb.com/en/Functions/p/parseJsonTable.html",
        "signatures": [
            {
                "full": "parseJsonTable(json, [schema], [keyCaseSensitive=true])",
                "name": "parseJsonTable",
                "parameters": [
                    {
                        "full": "json",
                        "name": "json"
                    },
                    {
                        "full": "[schema]",
                        "name": "schema",
                        "optional": true
                    },
                    {
                        "full": "[keyCaseSensitive=true]",
                        "name": "keyCaseSensitive",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [parseJsonTable](https://docs.dolphindb.com/en/Functions/p/parseJsonTable.html)\n\n\n\n#### Syntax\n\nparseJsonTable(json, \\[schema], \\[keyCaseSensitive=true])\n\n#### Arguments\n\n**json** is a STRING scalar or vector containing JSON objects. If it is a STRING scalar, it can contain one or more JSON objects. JSON arrays and recursive JSON objects are not supported yet.\n\n**schema** (optional) is a table that specifies the column names and types. It can contain the following columns:\n\n<table id=\"table_ul4_bnx_3zb\"><thead><tr><th align=\"left\">\n\n**Column**\n\n</th><th align=\"left\">\n\n**Description**\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\nname\n\n</td><td align=\"left\">\n\na string representing the column name\n\n</td></tr><tr><td align=\"left\">\n\ntype\n\n</td><td align=\"left\">\n\na string representing the column type.\n\n</td></tr><tr><td align=\"left\">\n\nformat\n\n</td><td align=\"left\">\n\na string specifying the format of date or time columns.\n\n</td></tr></tbody>\n</table>If *schema* is not specified, the function will automatically parse the schema based on the first 10 JSON objects.\n\n**keyCaseSensitive** (optional) indicates whether keys are case-sensitive. true (default) means case sensitive, false means case insensitive.\n\n#### Details\n\nParses JSON objects into an in-memory table. An empty JSON object will parsed as an empty row of the table.\n\n* When *json* is a string containing multiple JSON objects, each object will be converted to a row in the table.\n* When *json* is a vector of strings, each element will be converted to a row in the table.\n\n#### Examples\n\n```\njson1='{\"ID\":1, \"NAME\":\"cc\"}{\"NAME\":\"dd\"}'\nparseJsonTable(json1)\n```\n\n| ID | NAME |\n| -- | ---- |\n| 1  | cc   |\n|    | dd   |\n\n```\njson2 = '{\"col_test\":\"20190522150407\"}'\nschemaTB = table([\"col_test\"] as name, [\"DATETIME\"] as type, [\"yyyyMMddHHmmss\"] as format)\nparseJsonTable(json2, schemaTB)\n```\n\n| col\\_test           |\n| ------------------- |\n| 2019.05.22T15:04:07 |\n\njson is a string containing two JSON objects:\n\n```\njson3='{\"ID\":11, \"NAME\":\"dd\"}'\nschemaTB1 = table([\"ID\", \"NAME\", \"col_test\"] as name, [\"INT\", \"STRING\", \"DATETIME\"] as type, [,,\"yyyyMMddHHmmss\"] as format)\nparseJsonTable(concat([json2,json3]),schemaTB1)\n```\n\n| ID | NAME | col\\_test           |\n| -- | ---- | ------------------- |\n|    |      | 2019.05.22T15:04:07 |\n| 11 | dd   |                     |\n\njson is a STRING vector:\n\n```\nparseJsonTable([json2,json3],schemaTB1)\n```\n\n| ID | NAME | col\\_test           |\n| -- | ---- | ------------------- |\n|    |      | 2019.05.22T15:04:07 |\n| 11 | dd   |                     |\n"
    },
    "partial": {
        "url": "https://docs.dolphindb.com/en/Functions/p/partial.html",
        "signatures": [
            {
                "full": "partial(func, args...)",
                "name": "partial",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [partial](https://docs.dolphindb.com/en/Functions/p/partial.html)\n\n\n\n#### Syntax\n\npartial(func, args...)\n\n#### Arguments\n\n**func** is a function.\n\n**args...** are an incomplete list of the arguments of *func*.\n\n#### Details\n\nCreate a partial application.\n\n#### Examples\n\n```\npartial(add,1)(2);\n// output\n3\n\ndef f(a,b):a pow b\ng=partial(f, 2)\ng(3);\n// output\n8\n```\n"
    },
    "pca": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pca.html",
        "signatures": [
            {
                "full": "pca(X, [colNames], [k], [normalize], [maxIter], [svdSolver], [randomState])",
                "name": "pca",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[colNames]",
                        "name": "colNames",
                        "optional": true
                    },
                    {
                        "full": "[k]",
                        "name": "k",
                        "optional": true
                    },
                    {
                        "full": "[normalize]",
                        "name": "normalize",
                        "optional": true
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[svdSolver]",
                        "name": "svdSolver",
                        "optional": true
                    },
                    {
                        "full": "[randomState]",
                        "name": "randomState",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [pca](https://docs.dolphindb.com/en/Functions/p/pca.html)\n\n\n\n#### Syntax\n\npca(X, \\[colNames], \\[k], \\[normalize], \\[maxIter], \\[svdSolver], \\[randomState])\n\n#### Arguments\n\n**ds** is one or multiple data source. It is usually generated by function [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html).\n\n**colNames** is a string vector indicating column names. The default value is the names of all columns in *ds*.\n\n**k** is a positive integer indicating the number of principal components. The default value is the number of columns in *ds*.\n\n**normalize** is a Boolean value indicating whether to normalize each column. The default value is false.\n\n**maxIter** is a positive integer indicating the number of iterations when *svdSolver*=\"randomized\". If it is not specified, *maxIter*=7 if *k*<0.1\\*cols and *maxIter*=7 otherwise. Here cols means the number of columns in *ds*.\n\n**svdSolver** is a string. It can take the value of \"full\", \"randomized\" or \"auto\". *svdSolver*=\"full\" is suitable for situations where *k* is close to size(*colNames*); *svdSolver*=\"randomized\" is suitable for situations where *k* is much smaller than size(*colNames*). The default value is \"auto\", which means the system automatically determines whether to use \"full\" or \"randomized\".\n\n**randomState** is an integer indicating the random seed. It only takes effect when set *svdSolver*=\"randomized\". The default value is `int(time(now()))`.\n\n#### Details\n\nConduct principal component analysis for the specified columns of the data source. Return a dictionary with the following keys:\n\n* components: the matrix of principal component coefficients with size(*colNames*) rows and *k* columns.\n\n* explainedVarianceRatio: a vector of length *k* with the percentage of the total variance explained by each of the first *k* principal component.\n\n* singularValues: a vector of length *k* with the principal component variances (eigenvalues of the covariance matrix).\n\n#### Examples\n\n```\nx = [7,1,1,0,5,2]\ny = [0.7, 0.9, 0.01, 0.8, 0.09, 0.23]\nt=table(x, y)\nds = sqlDS(<select * from t>);\n\npca(ds);\n\n// output\ncomponents->\n#0        #1\n--------- ---------\n-0.999883 0.015306\n-0.015306 -0.999883\n```\n\n```\nexplainedVarianceRatio->[0.980301,0.019699]\n// output\nsingularValues->[6.110802,0.866243]\n```\n"
    },
    "pdfChiSquare": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pdfChiSquare.html",
        "signatures": [
            {
                "full": "pdfChiSquare(df, X)",
                "name": "pdfChiSquare",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [pdfChiSquare](https://docs.dolphindb.com/en/Functions/p/pdfChiSquare.html)\n\n#### Syntax\n\npdfChiSquare(df, X)\n\n#### Arguments\n\n**df** is a numeric scalar representing the degrees of freedom.\n\n**X** is a numeric scalar or vector representing the points at which to compute the probability density.\n\n#### Details\n\nCalculate the probability density of the specified chi-square distribution at *X*.\n\nIts functionality and usage are the same as `scipy.stats.chi2.pdf`.\n\n#### Examples\n\n```\npdfChiSquare(df=3, X=[1,2,3])\n// output: [0.241970724519143,0.207553748710297,0.154180329803769]\n```\n\n"
    },
    "pdfF": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pdfF.html",
        "signatures": [
            {
                "full": "pdfF(numeratorDF, denominatorDF, X)",
                "name": "pdfF",
                "parameters": [
                    {
                        "full": "numeratorDF",
                        "name": "numeratorDF"
                    },
                    {
                        "full": "denominatorDF",
                        "name": "denominatorDF"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [pdfF](https://docs.dolphindb.com/en/Functions/p/pdfF.html)\n\n#### Syntax\n\npdfF(numeratorDF, denominatorDF, X)\n\n#### Arguments\n\n**numeratorDF** is a numeric scalar representing the degrees of freedom for the numerator.\n\n**denominatorDF** is a numeric scalar representing the degrees of freedom for the denominator.\n\n**X** is a numeric scalar or vector representing the points at which to compute the probability density.\n\n#### Details\n\nCalculate the probability density of the specified F distribution at *X*.\n\nIts functionality and usage are the same as `scipy.stats.f.pdf`.\n\n#### Examples\n\n```\npdfF(numeratorDF=2, denominatorDF=19, X=[1,2,3])\n// output: [0.34963122778983,0.134514942963846,0.056045754350634]\n```\n\n"
    },
    "pdfNormal": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pdfNormal.html",
        "signatures": [
            {
                "full": "pdfNormal(mean, stdev, X)",
                "name": "pdfNormal",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "stdev",
                        "name": "stdev"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [pdfNormal](https://docs.dolphindb.com/en/Functions/p/pdfNormal.html)\n\n#### Syntax\n\npdfNormal(mean, stdev, X)\n\n#### Arguments\n\n**mean** is a numeric scalar representing the mean of the normal distribution.\n\n**stdev** is a numeric scalar representing the standard deviation of the normal distribution.\n\n**X** is a numeric scalar or vector representing the points at which to compute the probability density.\n\n#### Details\n\nCalculate the probability density of the specified normal distribution at *X*.\n\nIts functionality and usage are the same as `scipy.stats.norm.pdf`.\n\n#### Examples\n\nCalculate the probability density value of the standard normal distribution at *X*=1:\n\n```\npdfNormal(mean=0, stdev=1, X=1)\n// output: 0.24197072451914337\n```\n\nCalculate the probability density values of a normal distribution with mean 1 and variance 1.5 at *X*=1, 2, 3:\n\n```\npdfNormal(mean=1, stdev=1.5, X=[1,2,3])\n// output: [0.265961520267622,0.212965337014901,0.109340049783996]\n```\n\n"
    },
    "percentChange": {
        "url": "https://docs.dolphindb.com/en/Functions/p/percentChange.html",
        "signatures": [
            {
                "full": "percentChange(X, [n])",
                "name": "percentChange",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[n]",
                        "name": "n",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [percentChange](https://docs.dolphindb.com/en/Functions/p/percentChange.html)\n\n\n\n#### Syntax\n\npercentChange(X, \\[n])\n\n#### Arguments\n\n**X** is a vector or matrix.\n\n**n** (optional) is an integer specifying the step to shift when comparing elements in *X*. The default value is 1, meaning to compare the current element with the adjacent element at left.\n\n#### Details\n\nFor each element *Xi* in *X*, return *(Xi/ Xi-n) - 1*, representing the percentage changes between elements.\n\n**Return value**: A vector or matrix with the same shape as *X*.\n\n#### Examples\n\n```\npercentChange([1,2,3]);\n// output: [,1,0.5]\n\npercentChange(85 90 95);\n// output: [,0.058824,0.055556]\n```\n\n```\nm=matrix(100 105 109 112 108 116, 200 212 208 199 206 210);\nm\n```\n\n| #0  | #1  |\n| --- | --- |\n| 100 | 200 |\n| 105 | 212 |\n| 109 | 208 |\n| 112 | 199 |\n| 108 | 206 |\n| 116 | 210 |\n\n```\npercentChange(m);\n```\n\n| #0                 | #1                 |\n| ------------------ | ------------------ |\n|                    |                    |\n| 0.05               | 0.06               |\n| 0.038095238095238  | -0.018867924528302 |\n| 0.027522935779817  | -0.043269230769231 |\n| -0.035714285714286 | 0.035175879396985  |\n| 0.074074074074074  | 0.019417475728155  |\n\nWhen *n*is positive:\n\n```\nr = percentChange(1..10,3);\nr;\n// output: [,,,3,1.5,1,0.75,0.6,0.5,0.43]\n```\n\n```\nm=matrix(1 3 2 NULL 6 9 3, 0 8 NULL 7 6 2 8);\nr = percentChange(m,2);\nr;\n```\n\n| 0    | 1     |\n| ---- | ----- |\n|      |       |\n|      |       |\n| 1    |       |\n|      | -0.13 |\n| 2    |       |\n|      | -0.71 |\n| -0.5 | 0.33  |\n\nWhen *n*is negative:\n\n```\nm = 3 4 6 9\nr2= percentChange(m,-2)\nr2; \n// output: [-0.5,-0.56,,]\n```\n"
    },
    "percentile": {
        "url": "https://docs.dolphindb.com/en/Functions/p/percentile.html",
        "signatures": [
            {
                "full": "percentile(X, percent, [interpolation='linear'])",
                "name": "percentile",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "percent",
                        "name": "percent"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    }
                ]
            }
        ],
        "markdown": "### [percentile](https://docs.dolphindb.com/en/Functions/p/percentile.html)\n\n\n\n#### Syntax\n\npercentile(X, percent, \\[interpolation='linear'])\n\n#### Arguments\n\n**X** is a vector, a matrix or a table.\n\n**percent** is an integer or a floating number between 0 and 100.\n\n**interpolation** is a string indicating the interpolation method to use if the specified percentile is between two elements in *X* (assuming the ith and (i+1)th element in the sorted *X*) . It can take the following values:\n\n* 'linear': Return ![](https://docs.dolphindb.com/en/images/linear.png), where ![](https://docs.dolphindb.com/en/images/fraction.png)\n\n* 'lower': Return ![](https://docs.dolphindb.com/en/images/xi.png)\n\n* 'higher': Return ![](https://docs.dolphindb.com/en/images/higher.png)\n\n* 'nearest': Return ![](https://docs.dolphindb.com/en/images/xi.png) or ![](https://docs.dolphindb.com/en/images/higher.png) that is closest to the specified percentile\n\n* 'midpoint': Return ![](https://docs.dolphindb.com/en/images/midpoint.png)\n\nThe default value of interpolation is 'linear'.\n\n#### Details\n\nIf *X* is a vector, return the given percentile of *X*. The calculation ignores NULL values.\n\nIf *X* is a matrix, conduct the aforementioned calculation within each column of *X*. The result is a vector\n\nIf *X* is a table, conduct the aforementioned calculation within each column of *X*. The result is a table.\n\n#### Examples\n\n```\na=[6, 47, 49, 15, 42, 41, 7, 39, 43, 40, 36];\n\npercentile(a,50);\n// output\n40\n\npercentile(a,54);\n// output\n40.4\n\npercentile(a,25,\"lower\");\n// output\n15\n\npercentile(a,75,\"higher\");\n// output\n43\n\npercentile(a,5,\"midpoint\");\n// output\n6.5\n\npercentile(a,5,\"nearest\");\n// output\n6\n```\n\n```\nm=matrix(1 2 5 3 4, 5 4 1 2 3);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 2  | 4  |\n| 5  | 1  |\n| 3  | 2  |\n| 4  | 3  |\n\n```\npercentile(m, 75);\n[4,4]\n```\n"
    },
    "percentileRank": {
        "url": "https://docs.dolphindb.com/en/Functions/p/percentileRank.html",
        "signatures": [
            {
                "full": "percentileRank(X, score, [method='excel'])",
                "name": "percentileRank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "score",
                        "name": "score"
                    },
                    {
                        "full": "[method='excel']",
                        "name": "method",
                        "optional": true,
                        "default": "'excel'"
                    }
                ]
            }
        ],
        "markdown": "### [percentileRank](https://docs.dolphindb.com/en/Functions/p/percentileRank.html)\n\n\n\n#### Syntax\n\npercentileRank(X, score, \\[method='excel'])\n\n#### Arguments\n\n**X** is a numeric vector/matrix/table. If it is a matrix, calculate the percentile for each column and output a vector. If it is a table, calculate the percentile for each column and output a table.\n\n**score** is a scalar. The function will calculate the rank of the score according to the X.\n\n**method** is a string indicating the method to calculate the percentline. It can be:\n\n* \"excel\" (default): The proportion of the number of elements smaller than *score* to the number of elements not equal to *score*. If *score* is not equal to any element in *X*, then percentile calculation formula will be as below:\n\n  ![](https://docs.dolphindb.com/en/images/pscore.png)\n\n  In the formula, Xi is the maximum less than score and Xi+1 is the minimum greater than score. Pi and Pi+1 is the percentile of Xi and Xi+1.\n\n* \"rank\": The percentage of the number of elements not greater than *score* to the number of elements in *X*. If there are multiple elements in *X* that is equal to *score*, take the average of their percentiles as the result.\n\n* \"strict\": The percentage of the number of elements smaller than *score* to the number of elements in *X*.\n\n* \"weak\": The percentage of the number of elements not greater than *score* to the number of elements in *X*.\n\n* \"mean\": The average value of \"strict\" and \"weak\".\n\n#### Details\n\nCalculate the percentile (0-100) of a *score* in a vector with NULL values ignored.\n\n#### Examples\n\n```\na = 2 3 4 4 5;\npercentileRank(a, 4);\n// output\n66.666667\npercentileRank(a, 3);\n// output\n25\npercentileRank(a, 4, \"rank\");\n// output\n70\npercentileRank(a,75,\"weak\");\n// output\n80\npercentileRank(a,5,\"strict\");\n// output\n40\npercentileRank(a,5,\"mean\");\n// output\n60\n\npercentileRank(1 5 8, 6, \"excel\")\n// output\n66.666667\n```\n"
    },
    "piecewiseLinFit": {
        "url": "https://docs.dolphindb.com/en/Functions/p/piecewiseLinFit.html",
        "signatures": [
            {
                "full": "piecewiseLinFit(X, Y, numSegments, [XC], [YC], [bounds], [lapackDriver='gelsd'], [degree=1], [weights], [method='de'], [maxIter], [initialGuess], [seed])",
                "name": "piecewiseLinFit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "numSegments",
                        "name": "numSegments"
                    },
                    {
                        "full": "[XC]",
                        "name": "XC",
                        "optional": true
                    },
                    {
                        "full": "[YC]",
                        "name": "YC",
                        "optional": true
                    },
                    {
                        "full": "[bounds]",
                        "name": "bounds",
                        "optional": true
                    },
                    {
                        "full": "[lapackDriver='gelsd']",
                        "name": "lapackDriver",
                        "optional": true,
                        "default": "'gelsd'"
                    },
                    {
                        "full": "[degree=1]",
                        "name": "degree",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[weights]",
                        "name": "weights",
                        "optional": true
                    },
                    {
                        "full": "[method='de']",
                        "name": "method",
                        "optional": true,
                        "default": "'de'"
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[initialGuess]",
                        "name": "initialGuess",
                        "optional": true
                    },
                    {
                        "full": "[seed]",
                        "name": "seed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [piecewiseLinFit](https://docs.dolphindb.com/en/Functions/p/piecewiseLinFit.html)\n\n\n\n#### Syntax\n\npiecewiseLinFit(X, Y, numSegments, \\[XC], \\[YC], \\[bounds], \\[lapackDriver='gelsd'], \\[degree=1], \\[weights], \\[method='de'], \\[maxIter], \\[initialGuess], \\[seed])\n\n#### Arguments\n\n**X** is a numeric vector indicating the data point locations of x. NULL value is not allowed.\n\n**Y** is a numeric vector indicating the data point locations of y. NULL value is not allowed.\n\n**numSegments** is a positive integer indicating the desired number of line segments.\n\n**XC** (optional) is a numeric vector indicating the x locations of the data points that the piecewise linear function will be forced to go through. It only takes effect when *method*='de'.\n\n**YC** (optional) is a numeric vector indicating the y locations of the data points that the piecewise linear function will be forced to go through. It only takes effect when *method*='de'.\n\n**bounds** (optional) is a numeric matrix of shape (*numSegments*-1, 2), indicating the bounds for each breakpoint location within the optimization.\n\n**lapackDriver** (optional) is a string indicating which LAPACK driver is used to solve the least-squares problem. It can be 'gelsd' (default), 'gelsy' and 'gelss'.\n\n**degree** (optional) is a non-negative integer indicating the degree of polynomial to use. The default is 1 for linear models. Use 0 for constant models.\n\n**weights** (optional) is a numeric vector indicating the weights used in least-squares algorithms. The individual weights are typically the reciprocal of the standard deviation for each data point, where *weights\\[i]* corresponds to one over the standard deviation of the ith data point. NULL value is not allowed.\n\n**method** (optional) is a string indicating the model used. It can be:\n\n* 'nm' (default): Nelder-Mead simplex algorithm.\n* 'bfgs': BFGS algorithm.\n* 'lbfgs': LBFGS algorithm.\n* 'slsqp': Sequential Least Squares Programming algorithm.\n* 'de': Differential Evolution algorithm.\n\n**maxIter** (optional) is an integral scalar or vector indicating the maximum number of iterations for the optimization algorithm during the fitting process.\n\n**initialGuess** (optional) is a numeric vector indicating the initial guess for the parameters that optimize the function. Its length is *numSegments*-1.\n\n**seed** (optional) is an integer indicating the random number seed used in the differential evolution algorithm to ensure the reproducibility of results. It only takes effect when *method*='de' or *initialGuess* is NULL. If not specified, a non-deterministic random number generator is used.\n\n#### Details\n\nFit a continuous piecewise linear function for a specified number of line segments. Use differential evolution to find the optimal location of breakpoints for a given number of line segments by minimizing the sum of the square error. Note: Due to the randomness of the differential evolution, the results of this function may vary slightly each time.\n\nThe fitted model can be used as an input for function `pwlfPredict`.\n\n**Return value**: A dictionary with the following keys:\n\n* breaks: A floating-point vector indicating the breakpoint locations.\n\n* beta: A floating-point vector indicating the beta parameter for the linear fit.\n\n* xData: A floating-point vector indicating the input data point locations of x.\n\n* yData: A floating-point vector indicating the input data point locations of y.\n\n* XC: A floating-point vector indicating the x locations of the data points that the piecewise linear function will be forced to go through.\n\n* YC: A floating-point vector indicating the y locations of the data points that the piecewise linear function will be forced to go through.\n\n* weights: A floating-point vector indicating the weights used in least-squares algorithms.\n\n* degree: A non-negative integer indicating the degree of polynomial.\n\n* lapackDriver: A string indicating the LAPACK driver used to solve the least-squares problem.\n\n* numParameters: An integer indicating the number of parameters.\n\n* predict: The function used for prediction. The method is called by `model.predict(X, [beta], [breaks])`. See pwlfPredict.\n\n* modelName: A string \"Piecewise Linear Regression\" indicating the model name.\n\n#### Examples\n\n```\ndef linspace(start, end, num, endpoint=true){\n\tif(endpoint) return end$DOUBLE\\(num-1), start + end$DOUBLE\\(num-1)*0..(num-1)\n\telse return start + end$DOUBLE\\(num-1)*0..(num-1)\t\n}\nX = linspace(0.0, 1.0, 10)[1]\nY = [0.41703981, 0.80028691, 0.12593987, 0.58373723, 0.77572962, 0.41156172, 0.72300284, 0.32559528, 0.21812564, 0.41776427]\nmodel = piecewiseLinFit(X, Y, 3)\nmodel;\n```\n\nOutput:\n\n```\nbreaks->[0.0,0.258454644769,0.366954310101,1.000000000000]\nnumParameters->4\ndegree->1\nxData->[0.0,0.111111111111,0.222222222222,0.333333333333,0.444444444444,0.555555555555,0.666666666666,0.777777777777,0.888888888888,1.000000000000]\npredict->pwlfPredict\nyData->[0.417039810000,0.800286910000,0.125939870000,0.583737230000,0.775729620000,0.411561720000,0.723002840000,0.325595280000,0.218125640000,0.417764270000]\nyC->\nxC->\nweights->\nbeta->[0.593305500750,-1.309949743583,5.703647584013,-5.105351630664]\nlapackDriver->gelsd\n```\n\n`piecewiseLinFit` can be used with `pwlfPredict` for predication based on the model:\n\n```\nxHat = linspace(0.0, 1.0, 20)[1]\nmodel.predict(xHat)\n\n// Output: [0.593305499919518 0.524360777381737 0.455416054843957 0.386471332306177 0.317526609768396 0.368043438179296 0.529813781212159 0.691584124245021 0.69295837868457  0.655502915538459 0.618047452392347 0.580591989246236 0.543136526100125 0.505681062954014 0.468225599807903 0.430770136661792 0.393314673515681 0.35585921036957  0.318403747223459 0.280948284077348]\n```\n\n**Related function**: [pwlfPredict](https://docs.dolphindb.com/en/Functions/p/pwlfPredict.html)\n"
    },
    "pinverse": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pinverse.html",
        "signatures": [
            {
                "full": "pinverse(X)",
                "name": "pinverse",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [pinverse](https://docs.dolphindb.com/en/Functions/p/pinverse.html)\n\n#### Syntax\n\npinverse(X)\n\n#### Arguments\n\n**X** is a matrix.\n\n#### Details\n\nCalculate the pseudo-inverse matrix of *X*.\n\n**Return Value**: a FAST DOUBLE MATRIX\n\n#### Example\n\n```\nx=1..4$2:2;\nx.pinverse()\n```\n\n<table id=\"table_nqs_twr_z1c\"><thead><tr><th>\n\ncol1\n\n</th><th>\n\ncol2\n\n</th></tr></thead><tbody><tr><td>\n\n-2\n\n</td><td>\n\n1.5\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n-0.5\n\n</td></tr></tbody>\n</table>```\ny=1..8$2:4\ny.pinverse(); \n```\n\n<table id=\"table_qqs_twr_z1c\"><thead><tr><th>\n\ncol1\n\n</th><th>\n\ncol2\n\n</th></tr></thead><tbody><tr><td>\n\n-1\n\n</td><td>\n\n0.85\n\n</td></tr><tr><td>\n\n-0.5\n\n</td><td>\n\n0.45\n\n</td></tr><tr><td>\n\n0\n\n</td><td>\n\n0.05\n\n</td></tr><tr><td>\n\n0.5\n\n</td><td>\n\n-0.35\n\n</td></tr></tbody>\n</table>```\ns1 = indexedSeries(2012.01.01..2012.01.04, [10, 20, 30, 40])\npinv(s1)\n```\n\n<table id=\"table_uqs_twr_z1c\"><thead><tr><th>\n\ncol1\n\n</th><th>\n\ncol2\n\n</th><th>\n\ncol3\n\n</th><th>\n\ncol4\n\n</th></tr></thead><tbody><tr><td>\n\n0.0033\n\n</td><td>\n\n0.0067\n\n</td><td>\n\n0.01\n\n</td><td>\n\n0.0133\n\n</td></tr></tbody>\n</table>```\nm=matrix(1..10, 11..20)\nm.rename!(2020.01.01..2020.01.10, `A`B);\nm.setIndexedMatrix!()\npinv(m)\n```\n\n<table id=\"table_zqs_twr_z1c\"><thead><tr><th>\n\ncol1\n\n</th><th>\n\ncol2\n\n</th><th>\n\ncol3\n\n</th><th>\n\ncol4\n\n</th><th>\n\ncol5\n\n</th><th>\n\ncol6\n\n</th><th>\n\ncol7\n\n</th><th>\n\ncol8\n\n</th><th>\n\ncol9\n\n</th><th>\n\ncol10\n\n</th></tr></thead><tbody><tr><td>\n\n-0.0945\n\n</td><td>\n\n-0.0758\n\n</td><td>\n\n-0.057\n\n</td><td>\n\n-0.0382\n\n</td><td>\n\n-0.0194\n\n</td><td>\n\n-0.0006\n\n</td><td>\n\n0.0182\n\n</td><td>\n\n0.037\n\n</td><td>\n\n0.0558\n\n</td><td>\n\n0.0745\n\n</td></tr><tr><td>\n\n0.04\n\n</td><td>\n\n0.0333\n\n</td><td>\n\n0.0267\n\n</td><td>\n\n0.02\n\n</td><td>\n\n0.0133\n\n</td><td>\n\n0.0067\n\n</td><td>\n\n0\n\n</td><td>\n\n-0.0067\n\n</td><td>\n\n-0.0133\n\n</td><td>\n\n-0.02\n\n</td></tr></tbody>\n</table>For a matrix without a full rank, calculating the inverse will raise an error. The pseudo inverse can be calculated.\n\n```\nx=1 2 3 1 2 3$2:3\ninverse(x) // Error: The argument of 'inverse' must be a square matrix.\npinverse(x)\n```\n\n| col1    | col2    |\n| ------- | ------- |\n| -0.1067 | 0.2267  |\n| 0.4133  | -0.2533 |\n| -0.0667 | 0.2667  |\n\nRelated function: [inverse](https://docs.dolphindb.com/en/Functions/i/inverse.html)\n\n"
    },
    "pipeline": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pipeline.html",
        "signatures": [
            {
                "full": "pipeline(initTasks, followers, [queueDepth=2])",
                "name": "pipeline",
                "parameters": [
                    {
                        "full": "initTasks",
                        "name": "initTasks"
                    },
                    {
                        "full": "followers",
                        "name": "followers"
                    },
                    {
                        "full": "[queueDepth=2]",
                        "name": "queueDepth",
                        "optional": true,
                        "default": "2"
                    }
                ]
            }
        ],
        "markdown": "### [pipeline](https://docs.dolphindb.com/en/Functions/p/pipeline.html)\n\n\n\n#### Syntax\n\npipeline(initTasks, followers, \\[queueDepth=2])\n\n#### Arguments\n\n**initTasks** is the collection of the initial steps of all tasks, which is represented by a zero-argument function. For example, if we have 10 tasks then *initialTasks* is a tuple of 10 zero-argument functions.\n\n**followers** is a set of unary functions, each of which represents a step of the task after the initial step. If a task consists of N steps, followers should have N-1 unary functions. The output of a follower is the input of the next follower. The last follower may or may not return an object. The initial step of tasks is executed in the main thread (the thread that accepted the tasks) and the remaining steps will be executed in separate threads. To execute tasks of N steps, the system creates N-1 threads and these threads will be destroyed upon completion of the job.\n\n**queueDepth** is the maximum depth of the queue for the next step. The intermediate result of each step is stored in the queue for the next follower. When the queue is full, the execution will stop when the next step comsumes data from the queue. The deeper the queue, the less waiting time for the next step. However, a deeper queue consumes more memory. *queueDepth* is optional and the default value is 2.\n\n#### Details\n\nOptimize tasks that meet the following conditions through multithreading:\n\n1. Can be decomposed into multiple sub-tasks.\n\n2. Each subtask contains multiple steps.\n\n3. The kth step of the ith subtask can only be executed after the (k-1)th step of the ith subtask and the kth step of the (i-1)th subtask are completed.\n\nIf the last step (follower) returns an object, the `pipeline` function returns a tuple. Otherwise, it returns nothing.\n\n#### Examples\n\nIn the following example, we need to convert the partitioned table stockData into a CSV file. This table contains data from 2008 to 2018 and exceeds the available memory of the system, so we cannot load the entire table into memory and then converted it into a CSV file. The task can be divided into multiple sub-tasks, each of which consists of two steps: load one month of data into memory, and then store the data in the CSV file. To store the data of a month in the CSV file, it must be ensured that the data of the month has been loaded into the memory, and the that data of the previous month has been stored in the CSV file.\n\n```\nv = 2000.01M..2018.12M\ndef loadData(m){\nreturn select * from loadTable(\"dfs://stockDB\", \"stockData\") where TradingTime between datetime(date(m)) : datetime(date(m+1))\n}\n\ndef saveData(tb){\ntb.saveText(\"/hdd/hdd0/data/stockData.csv\",',', true)\n}\n\npipeline(each(partial{loadData}, v),saveData);\n```\n"
    },
    "ploadText": {
        "url": "https://docs.dolphindb.com/en/Functions/p/ploadText.html",
        "signatures": [
            {
                "full": "ploadText(filename, [delimiter], [schema], [skipRows=0], [arrayDelimiter], [containHeader], [arrayMarker])",
                "name": "ploadText",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    },
                    {
                        "full": "[schema]",
                        "name": "schema",
                        "optional": true
                    },
                    {
                        "full": "[skipRows=0]",
                        "name": "skipRows",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[arrayDelimiter]",
                        "name": "arrayDelimiter",
                        "optional": true
                    },
                    {
                        "full": "[containHeader]",
                        "name": "containHeader",
                        "optional": true
                    },
                    {
                        "full": "[arrayMarker]",
                        "name": "arrayMarker",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ploadText](https://docs.dolphindb.com/en/Functions/p/ploadText.html)\n\n\n\n#### Syntax\n\nploadText(filename, \\[delimiter], \\[schema], \\[skipRows=0], \\[arrayDelimiter], \\[containHeader], \\[arrayMarker])\n\n#### Arguments\n\nPlease refer to function [loadText](https://docs.dolphindb.com/en/Functions/l/loadText.html).\n\n#### Details\n\nLoad a text data file in parallel as an in-memory partitioned table. When the file is greater than 16 MB, it returns a in-memory table with sequential partitions. A regular in-memory table is returned otherwise.\n\n**Note:**\n\n* The partitioned table returned by `ploadText` distributes data evenly across all partitions. Each partition holds between 8-16 MB of data.\n* `ploadText` is faster than `loadText` with concurrent data loading.\n* From version 1.30.22/2.00.10 onwards, `ploadText` supports loading a data file that contains a record with multiple newlines.\n\n#### Examples\n\n```\nn=1000000\ntimestamp=09:30:00+rand(18000,n)\nID=rand(100,n)\nqty=100*(1+rand(100,n))\nprice=5.0+rand(100.0,n)\nt1 = table(timestamp,ID,qty,price)\nsaveText(t1, \"C:/DolphinDB/Data/t1.txt\");\n\ntimer tt1=loadText(\"C:/DolphinDB/Data/t1.txt\");\n// output\nTime elapsed: 437.236 ms\n\ntimer tt2=ploadText(\"C:/DolphinDB/Data/t1.txt\");\nTime elapsed: 241.126 ms\n\ntypestr(tt2);\nSEGMENTED IN-MEMORY TABLE\n```\n\nFor more examples please refer to [loadText](https://docs.dolphindb.com/en/Functions/l/loadText.html).\n"
    },
    "plot": {
        "url": "https://docs.dolphindb.com/en/Functions/p/plot.html",
        "signatures": [
            {
                "full": "plot(data, [labels], [title], [chartType=LINE], [stacking=false], [extras])",
                "name": "plot",
                "parameters": [
                    {
                        "full": "data",
                        "name": "data"
                    },
                    {
                        "full": "[labels]",
                        "name": "labels",
                        "optional": true
                    },
                    {
                        "full": "[title]",
                        "name": "title",
                        "optional": true
                    },
                    {
                        "full": "[chartType=LINE]",
                        "name": "chartType",
                        "optional": true,
                        "default": "LINE"
                    },
                    {
                        "full": "[stacking=false]",
                        "name": "stacking",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[extras]",
                        "name": "extras",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [plot](https://docs.dolphindb.com/en/Functions/p/plot.html)\n\n\n\n#### Syntax\n\nplot(data, \\[labels], \\[title], \\[chartType=LINE], \\[stacking=false], \\[extras])\n\n#### Arguments\n\n**data** could be a vector, tuple, matrix, or table.\n\n* If input is a vector, it produces a single series chart and the vector name is the series name.\n\n* If input is a tuple, each element of the tuple is viewed as a series. The elements of the tuple must all be vectors of the same length. Vectors' names are the series' names.\n\n* If input is a matrix, each column of the matrix is a series and the column labels of the matrix are the series names. If the matrix has row labels, they will serve as data point labels.\n\n* If input is a table, each column of the table is a series and the column names are the series names.\n\n**labels** are the label for each data point. All series of a chart share the same data labels. If input is a matrix, we can set matrix's row labels as data point labels. Otherwise, we need to specify data point labels here if necessary.\n\n**title** could be a string scalar/vector. If *title* is a scalar, it is the chart title; if it is a vector, the first element is the chart title, the second is X axis title, and the third is Y axis title.\n\n**chartType** is the chart type. The default type is LINE. Other options available now are PIE, COLUMN, BAR, AREA, and SCATTER.\n\n**stacking** indicates whether the chart is stacked. This parameter is valid when *chartType* is set to LINE or BAR.\n\n**extras** is an optional parameter to extend the properties of `plot`. *extras* must be a dictionary, and its key must be a string.\n\n**Note:**\n\n* Currently, *extras* only supports multiYAxes attribute: {multiYAxes: true}. Set to true to support multiple Y-axis, and set to false to use a shared Y-axis. If you need to use *extras* to add new attribute names and types, please contact us.\n\n* When *charType*=LINE, the multiYAxes attribute must be specified.\n\n#### Details\n\nGenerate a chart object.\n\n#### Examples\n\nExample 1: plot a table\n\n```\nx=0.1*(1..100)\ny=0.1*(100..1)\nt=table(x,y)\nplot(t,extras={multiYAxes: true})\n```\n\n![](https://docs.dolphindb.com/en/images/plot01.png)\n\nThe graph above can also be generated by `plot(t[`x`y],extras={multiYAxes: true})`\n\nExample 2: plot a matrix\n\n```\nplot([sin,cos](x),x,\"cos and sin curve\",extras={multiYAxes: false})\n```\n\n![](https://docs.dolphindb.com/en/images/plot02.png)\n\nNote that function names are used as series names, and we specify data labels and the graph title.\n\nExample 3: plot a vector\n\n```\nplot(cumsum(x) as cumsumX, 2012.10.01+1..100, \"cumulative sum of x\")\n```\n\n![](https://docs.dolphindb.com/en/images/plot03.png)\n\ncumsumX are used as series names.\n\nExample 4: plot a tuple\n\n```\nplot([1..10 as x, 10..1 as y], 1..10, extras={multiYAxes: false})\n```\n\n![](https://docs.dolphindb.com/en/images/plot04.png)\n\nx and y are used as series names.\n\nExample 5: plot a bar graph\n\n```\nplot(1..5 as value, `IBM`MSFT`GOOG`XOM`C, `rank, BAR)\n```\n\n![](https://docs.dolphindb.com/en/images/plot05.png)\n\nExample 6: plot a column graph\n\n```\nplot(99 128 196 210 312 as sales, `IBM`MSFT`GOOG`XOM`C, `sales, COLUMN)\n```\n\n![](https://docs.dolphindb.com/en/images/plot06.png)\n\nExample 7: plot a pie graph\n\n```\nplot(99 128 196 210 312 as sales, `IBM`MSFT`GOOG`XOM`C, `sales, PIE)\n```\n\n![](https://docs.dolphindb.com/en/images/plot07.png)\n\nExample 8: scatter plot\n\n```\nx=rand(1.0, 1000);\ny=x+norm(0.0, 0.2, 1000);\nplot(x, y, ,SCATTER)\n```\n\n![](https://docs.dolphindb.com/en/images/plot08.png)\n\nExample 9: Set {multiYAxes : true} and y1, y2, y3 represent different Y axis.\n\n```\nt = table(1 2 3 4 5 as y1, 1200 1300 1400 1500 1600 as y2, 100 300 500 800 900 as y3, 10 20 30 40 50 as date)\nplot([t.y1, t.y2,t.y3], t.date, , LINE, ,  {multiYAxes : true})\n```\n\n![](https://docs.dolphindb.com/en/images/plot09.png)\n"
    },
    "plotHist": {
        "url": "https://docs.dolphindb.com/en/Functions/p/plotHist.html",
        "signatures": [
            {
                "full": "plotHist(data, [binNum], [range], [title])",
                "name": "plotHist",
                "parameters": [
                    {
                        "full": "data",
                        "name": "data"
                    },
                    {
                        "full": "[binNum]",
                        "name": "binNum",
                        "optional": true
                    },
                    {
                        "full": "[range]",
                        "name": "range",
                        "optional": true
                    },
                    {
                        "full": "[title]",
                        "name": "title",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [plotHist](https://docs.dolphindb.com/en/Functions/p/plotHist.html)\n\n\n\n#### Syntax\n\nplotHist(data, \\[binNum], \\[range], \\[title])\n\n#### Arguments\n\n**data** is a vector, or a matrix column, or a table column.\n\n**binNum** is the number of bins the histogram shows.\n\n**range** is the data range in the histogram.\n\n**title** is graph title.\n\n#### Details\n\nGenerate a histogram chart object.\n\n#### Examples\n\n```\nx=norm(0.0, 1.0, 10000);\nplotHist(x, 10)\n```\n\n![](https://docs.dolphindb.com/en/images/plotHist01.png)\n\n```\nplotHist(x, 10, -2:2)\n```\n\n![](https://docs.dolphindb.com/en/images/plotHist02.png)\n"
    },
    "pnodeRun": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pnodeRun.html",
        "signatures": [
            {
                "full": "pnodeRun(function,[nodes],[addNodeAlias=true])",
                "name": "pnodeRun",
                "parameters": [
                    {
                        "full": "function",
                        "name": "function"
                    },
                    {
                        "full": "[nodes]",
                        "name": "nodes",
                        "optional": true
                    },
                    {
                        "full": "[addNodeAlias=true]",
                        "name": "addNodeAlias",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [pnodeRun](https://docs.dolphindb.com/en/Functions/p/pnodeRun.html)\n\n\n\n#### Syntax\n\npnodeRun(function,\\[nodes],\\[addNodeAlias=true])\n\n#### Arguments\n\n**function** is the local function to call. It must not be quoted. It can be a function with no parameters by definition, or a partial application that wraps the orginal function and its parameters to a function with no parameters. It can be a built-in function or a user-defined function.\n\n**nodes** is aliases of nodes. It is an optional parameter. If it is not specified, the system will call the function on all live data nodes and compute nodes in the cluster.\n\n**addNodeAlias** specifies whether to add aliases of nodes to results. It is an optional parameter. The default value is true. You can set it to false if the result from each node already contains the node alias.\n\n#### Details\n\nCall a local function on all data nodes and compute nodes in a cluster in parallel and then merge the results.\n\n#### Examples\n\nEx. 1 Call function `getChunksMeta` without specifying parameters\n\n```\npnodeRun(getChunksMeta,,false);\n```\n\n| site      | chunkId                              | path                                                                      | dfsPath              | type | flag | size | version | state | versionList              |\n| --------- | ------------------------------------ | ------------------------------------------------------------------------- | -------------------- | ---- | ---- | ---- | ------- | ----- | ------------------------ |\n| local8848 | bd13090e-7177-01a7-4ac4-840e1b977dcf | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190605/GOOG | /compo/20190605/GOOG | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6729; # |\n| local8848 | b4935730-6372-b2a1-4f24-6c323037e576 | e:data/CHUNKS/compo/20190605/AAPL                                         | /compo/20190605/AAPL | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6613; # |\n| local8848 | f8ee72c9-dad3-f49e-430e-5ddb3c61ae18 | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190604/MSFT | /compo/20190604/MSFT | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6664; # |\n| local8848 | 08e26b5a-dfac-799f-4979-0dd3902eae6e | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190604/GOOG | /compo/20190604/GOOG | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6635; # |\n| local8848 | f9e53a3d-af3e-018d-4bfa-a2b4980f3561 | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190604/AAPL | /compo/20190604/AAPL | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6783; # |\n| local8848 | 417e49e9-5c61-cf9e-4b21-4b35f8e57273 | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190601/MSFT | /compo/20190601/MSFT | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6602; # |\n| local8848 | 3ee64942-1d72-bea7-4bc1-f720132d9288 | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190602/AAPL | /compo/20190602/AAPL | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6749; # |\n\nEx. 2 In the following example, the function `sum` and arguments 1..10 are wrapped into a partial application `sum{1..10}`.\n\n```\npnodeRun(sum{1..10}, `nodeA`nodeB);\n```\n\n| Node       | Value |\n| ---------- | ----- |\n| DFS\\_NODE2 | 55    |\n| DFS\\_NODE3 | 55    |\n\nEx. 3 `pnodeRun` is a very convenient tool for cluster management. For example, in a cluster of 4 nodes: \"DFS\\_NODE1\", \"DFS\\_NODE2\", \"DFS\\_NODE3\", and \"DFS\\_NODE4\", run the following script on each of the node:\n\n```\ndef jobDemo(n){\n    s = 0\n    for (x in 1 : n) {\n        s += sum(sin rand(1.0, 100000000)-0.5)\n        print(\"iteration \" + x + \" \" + s)\n    }\n    return s\n};\n\nsubmitJob(\"jobDemo1\",\"job demo\", jobDemo, 10);\nsubmitJob(\"jobDemo2\",\"job demo\", jobDemo, 10);\nsubmitJob(\"jobDemo3\",\"job demo\", jobDemo, 10);\n```\n\nTo check the status of the most recent 2 completed batch jobs on each of the 4 nodes in the cluster:\n\n```\npnodeRun(getRecentJobs{2});\n```\n\n| Node       | UserID | JobID    | JobDesc  | ReceivedTime            | StartTime               | EndTime                 | ErrorMsg |\n| ---------- | ------ | -------- | -------- | ----------------------- | ----------------------- | ----------------------- | -------- |\n| DFS\\_NODE1 | root   | jobDemo2 | job demo | 2017.11.16T13:04:38.841 | 2017.11.16T13:04:38.841 | 2017.11.16T13:04:51.660 |          |\n| DFS\\_NODE1 | root   | jobDemo3 | job demo | 2017.11.16T13:04:38.841 | 2017.11.16T13:04:38.843 | 2017.11.16T13:04:51.447 |          |\n| DFS\\_NODE2 | root   | jobDemo2 | job demo | 2017.11.16T13:04:56.431 | 2017.11.16T13:04:56.432 | 2017.11.16T13:05:11.992 |          |\n| DFS\\_NODE2 | root   | jobDemo3 | job demo | 2017.11.16T13:04:56.432 | 2017.11.16T13:04:56.434 | 2017.11.16T13:05:11.670 |          |\n| DFS\\_NODE3 | root   | jobDemo2 | job demo | 2017.11.16T13:05:08.418 | 2017.11.16T13:05:08.419 | 2017.11.16T13:05:29.176 |          |\n| DFS\\_NODE3 | root   | jobDemo3 | job demo | 2017.11.16T13:05:08.419 | 2017.11.16T13:05:08.421 | 2017.11.16T13:05:29.435 |          |\n| DFS\\_NODE4 | root   | jobDemo2 | job demo | 2017.11.16T13:05:16.324 | 2017.11.16T13:05:16.325 | 2017.11.16T13:05:34.729 |          |\n| DFS\\_NODE4 | root   | jobDemo3 | job demo | 2017.11.16T13:05:16.325 | 2017.11.16T13:05:16.328 | 2017.11.16T13:05:34.716 |          |\n\n```\npnodeRun(getRecentJobs{2}, `DFS_NODE3`DFS_NODE4);\n```\n\n| Node       | UserID | JobID    | JobDesc  | ReceivedTime            | StartTime               | EndTime                 | ErrorMsg |\n| ---------- | ------ | -------- | -------- | ----------------------- | ----------------------- | ----------------------- | -------- |\n| DFS\\_NODE3 | root   | jobDemo2 | job demo | 2017.11.16T13:05:08.418 | 2017.11.16T13:05:08.419 | 2017.11.16T13:05:29.176 |          |\n| DFS\\_NODE3 | root   | jobDemo3 | job demo | 2017.11.16T13:05:08.419 | 2017.11.16T13:05:08.421 | 2017.11.16T13:05:29.435 |          |\n| DFS\\_NODE4 | root   | jobDemo2 | job demo | 2017.11.16T13:05:16.324 | 2017.11.16T13:05:16.325 | 2017.11.16T13:05:34.729 |          |\n| DFS\\_NODE4 | root   | jobDemo3 | job demo | 2017.11.16T13:05:16.325 | 2017.11.16T13:05:16.328 | 2017.11.16T13:05:34.716 |          |\n\nHow does `pnodeRun` merge the results from multiple nodes:\n\n1. If *function* returns a scalar:\n\n   Return a table with 2 columns: node alias and function results.\n\n   Continuing with the example above:\n\n   ```\n   pnodeRun(getJobReturn{`jobDemo1});\n   ```\n\n   | Node       | Value         |\n   | ---------- | ------------- |\n   | DFS\\_NODE3 | 2,123.5508    |\n   | DFS\\_NODE2 | (42,883.5404) |\n   | DFS\\_NODE1 | 3,337.4107    |\n   | DFS\\_NODE4 | (2,267.3681)  |\n\n2. If *function* returns a vector:\n\n   Return a matrix. Each column of the matrix would be the function returns from nodes. The column label of the matrix would be the nodes.\n\n3. If *function* returns a key-value dictionary:\n\n   Return a table with each row representing the function return from one node.\n\n4. If *function* returns a table:\n\n   Return a table which is the union of individual tables from multiple nodes.\n\n5. If *function* is a command (a command returns nothing):\n\n   Return nothing\n\n6. For all other cases:\n\n   Return a dictionary. The key is node alias and the value is the function return.\n"
    },
    "point": {
        "url": "https://docs.dolphindb.com/en/Functions/p/point.html",
        "signatures": [
            {
                "full": "point(X, Y)",
                "name": "point",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [point](https://docs.dolphindb.com/en/Functions/p/point.html)\n\n\n\n#### Syntax\n\npoint(X, Y)\n\n#### Arguments\n\n**X** and **Y** are numeric scalars, pairs, vectors or matrices. They can be of integral (compress or INT128 not included) or floating type.\n\n#### Details\n\nGenerate a POINT type data to store the location of a midpoint in the coordinate system.\n\nThe length of a POINT type is 16 bytes. The low 8 bytes are stored in *X* and the high 8 bytes are stored in *Y*.\n\n#### Examples\n\n```\npoint(117.60972, 24.118418)\n// output\n(117.60972, 24.118418)\n\npoint(1..5,6..10)\n```\n\n| 0          | 1          | 2          | 3          | 4           |\n| ---------- | ---------- | ---------- | ---------- | ----------- |\n| (1.0, 6.0) | (2.0, 7.0) | (3.0, 8.0) | (4.0, 9.0) | (5.0, 10.0) |\n"
    },
    "poly1d": {
        "url": "https://docs.dolphindb.com/en/Functions/p/poly1d.html",
        "signatures": [
            {
                "full": "polyPredict(model, X)",
                "name": "polyPredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [poly1d](https://docs.dolphindb.com/en/Functions/p/poly1d.html)\n\nAlias for [polyPredict](https://docs.dolphindb.com/en/Functions/p/polyPredict.html)\n\n\nDocumentation for the `polyPredict` function:\n### [polyPredict](https://docs.dolphindb.com/en/Functions/p/polyPredict.html)\n\n\n\n#### Syntax\n\npolyPredict(model, X)\n\nAlias: poly1d\n\n#### Arguments\n\n**model** is a numeric vector indicating the polynomial coefficients in ascending powers. It must not contain NULL values.\n\n**X** is a numeric scalar or vector indicating the independent variable. It must not contain NULL values.\n\n#### Details\n\nCalculate the value of the dependent variable for a one-dimensional polynomial based on the given coefficients and independent variable.\n\nReturn value: A numeric vector of the same length as *X*.\n\n#### Examples\n\nFor a third-degree polynomial `2x^3+3x^2+4x+5` with coefficients \\[5,4,3,2] in ascending powers, the value of the dependent variable can be calculated:\n\n```\nmodel = [5,4,3,2]\nx = [2.0,5.0,3.0,3.0,4.0,5.0]\ny = poly1d(model,x)\ny\n//output: [41,350,98,98,197,350]\n```\n\nWith the model and y in the above example, the coefficients can be calculated with `polyFit`:\n\n```\npolyFit(x,y,3)\n// output\n[5,4,3,2]\n```\n\nRelated function: [polyFit](https://docs.dolphindb.com/en/Functions/p/polyFit.html)\n"
    },
    "polyFit": {
        "url": "https://docs.dolphindb.com/en/Functions/p/polyFit.html",
        "signatures": [
            {
                "full": "polyFit(X, Y, n, mode)",
                "name": "polyFit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    },
                    {
                        "full": "mode",
                        "name": "mode"
                    }
                ]
            }
        ],
        "markdown": "### [polyFit](https://docs.dolphindb.com/en/Functions/p/polyFit.html)\n\n\n\n#### Syntax\n\npolyFit(X, Y, n, mode)\n\n#### Arguments\n\n**X**is a numeric vector specifying the query points. The points in *X*correspond to the fitted function values contained in *Y*.\n\n**Y** is a numeric vector of the same length as X, which specifies the fitted values at query points. It must not contain NULL values.\n\n**n** is a non-negative scalar indicating the degree of polynomial fit.\n\n**mode** is a Boolean scalar indicating whether to return a dictionary of a vector. Defaults to 0, meaning to return a vector.\n\n#### Details\n\nReturn a vector indicating the least-squares fit polynomial coefficients in ascending powers for a polynomial `p(X)` of degree *n* that is a best fit (in a least-squares sense) for the data in *Y*.\n\n#### Examples\n\n```\nx = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\ny = [0.0, 0.8, 0.9, 0.1, -0.8, -1.0]\nz = polyFit(x, y, 3)\nz\n// output: [-0.0397,1.6931,-0.8135,0.087]\n\nz = polyFit(x, y, 3, 1)\n/*output: \nmodelName->polyFit\nz->[-0.039682539682536,1.693121693121692,-0.813492063492063,0.087037037037037]\npredict->polyPredict\n*/\n```\n\nRelated Function: [polyPredict](https://docs.dolphindb.com/en/Functions/p/polyPredict.html)\n"
    },
    "polynomial": {
        "url": "https://docs.dolphindb.com/en/Functions/p/polynomial.html",
        "signatures": [
            {
                "full": "polynomial(X, coeffs)",
                "name": "polynomial",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "coeffs",
                        "name": "coeffs"
                    }
                ]
            }
        ],
        "markdown": "### [polynomial](https://docs.dolphindb.com/en/Functions/p/polynomial.html)\n\n\n\n#### Syntax\n\npolynomial(X, coeffs)\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n**coeffs** is a vector indicating the coefficients of a polynomial.\n\n#### Details\n\nApply the polynomial coefficient vector coeffs on each element of *X*. Return a vector of the same length as *X*.\n\n#### Examples\n\nThe following example calculates ![](https://docs.dolphindb.com/en/images/polynomial.png) for each number from 1 to 10.\n\n```\npolynomial(1..10, 1 2 3);\n// output\n[6,17,34,57,86,121,162,209,262,321]\n```\n"
    },
    "polyPredict": {
        "url": "https://docs.dolphindb.com/en/Functions/p/polyPredict.html",
        "signatures": [
            {
                "full": "polyPredict(model, X)",
                "name": "polyPredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [polyPredict](https://docs.dolphindb.com/en/Functions/p/polyPredict.html)\n\n\n\n#### Syntax\n\npolyPredict(model, X)\n\nAlias: poly1d\n\n#### Arguments\n\n**model** is a numeric vector indicating the polynomial coefficients in ascending powers. It must not contain NULL values.\n\n**X** is a numeric scalar or vector indicating the independent variable. It must not contain NULL values.\n\n#### Details\n\nCalculate the value of the dependent variable for a one-dimensional polynomial based on the given coefficients and independent variable.\n\nReturn value: A numeric vector of the same length as *X*.\n\n#### Examples\n\nFor a third-degree polynomial `2x^3+3x^2+4x+5` with coefficients \\[5,4,3,2] in ascending powers, the value of the dependent variable can be calculated:\n\n```\nmodel = [5,4,3,2]\nx = [2.0,5.0,3.0,3.0,4.0,5.0]\ny = poly1d(model,x)\ny\n//output: [41,350,98,98,197,350]\n```\n\nWith the model and y in the above example, the coefficients can be calculated with `polyFit`:\n\n```\npolyFit(x,y,3)\n// output\n[5,4,3,2]\n```\n\nRelated function: [polyFit](https://docs.dolphindb.com/en/Functions/p/polyFit.html)\n"
    },
    "pop!": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pop!.html",
        "signatures": [
            {
                "full": "pop!(X)",
                "name": "pop!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [pop!](https://docs.dolphindb.com/en/Functions/p/pop!.html)\n\n\n\n#### Syntax\n\npop!(X)\n\n#### Arguments\n\n**X** is a vector.\n\n#### Details\n\nRemove the last element of *X*.\n\n#### Examples\n\n```\nx = 1 2 3;\npop!(x);\n// output\n3\n\nx;\n// output\n[1,2]\n```\n"
    },
    "pow": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pow.html",
        "signatures": [
            {
                "full": "pow(X, Y)",
                "name": "pow",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [pow](https://docs.dolphindb.com/en/Functions/p/pow.html)\n\n\n\n#### Syntax\n\npow(X, Y)\n\nAlias: power\n\n#### Arguments\n\n**X** and **Y** is a scalar/vector/matrix.\n\n#### Details\n\nRaise all elements of *X* to the power of *Y*.\n\nPlease note that the data type of the result is always DOUBLE, even if both *X* and *Y* are integers.\n\n#### Examples\n\n```\nx=1 2 3;\npow(x,3);\n// output\n[1,8,27]\npow(3,x);\n// output\n[3,9,27]\n\ny=4.5 5.5 6.5;\npow(x,y);\n// output\n[1,45.254834,1262.665039]\n\npow(y,x);\n// output\n[4.5,30.25,274.625]\n```\n\n```\nm=1..10$2:5;\nm;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  |\n| 2  | 4  | 6  | 8  | 10 |\n\n```\ntypestr(pow(3,4));\n// output\nDOUBLE\n```\n"
    },
    "power": {
        "url": "https://docs.dolphindb.com/en/Functions/p/power.html",
        "signatures": [
            {
                "full": "pow(X, Y)",
                "name": "pow",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [power](https://docs.dolphindb.com/en/Functions/p/power.html)\n\nAlias for [pow](https://docs.dolphindb.com/en/Functions/p/pow.html)\n\n\nDocumentation for the `pow` function:\n### [pow](https://docs.dolphindb.com/en/Functions/p/pow.html)\n\n\n\n#### Syntax\n\npow(X, Y)\n\nAlias: power\n\n#### Arguments\n\n**X** and **Y** is a scalar/vector/matrix.\n\n#### Details\n\nRaise all elements of *X* to the power of *Y*.\n\nPlease note that the data type of the result is always DOUBLE, even if both *X* and *Y* are integers.\n\n#### Examples\n\n```\nx=1 2 3;\npow(x,3);\n// output\n[1,8,27]\npow(3,x);\n// output\n[3,9,27]\n\ny=4.5 5.5 6.5;\npow(x,y);\n// output\n[1,45.254834,1262.665039]\n\npow(y,x);\n// output\n[4.5,30.25,274.625]\n```\n\n```\nm=1..10$2:5;\nm;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  |\n| 2  | 4  | 6  | 8  | 10 |\n\n```\ntypestr(pow(3,4));\n// output\nDOUBLE\n```\n"
    },
    "predict": {
        "url": "https://docs.dolphindb.com/en/Functions/p/predict.html",
        "signatures": [
            {
                "full": "predict(model, X)",
                "name": "predict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [predict](https://docs.dolphindb.com/en/Functions/p/predict.html)\n\n\n\n#### Syntax\n\npredict(model, X)\n\n#### Arguments\n\n**model** is a dictionary of the specifications of a prediction model. It is generated by functions such as [randomForestClassifier](https://docs.dolphindb.com/en/Functions/r/randomForestClassifier.html) or [randomForestRegressor](https://docs.dolphindb.com/en/Functions/r/randomForestRegressor.html).\n\n**X** is a table. The column names must be the same as the column names in the table used to train the prediction model.\n\n#### Details\n\nMake a prediction with the specified prediction model and data. The result is a vector with the same number of elements as the the number of rows in *X*. Each element of the vector corresponds to the predicted value of a row in *X*.\n\n#### Examples\n\nThe following example uses the model generated by randomForestRegressor for prediction.\n\n```\nx1 = rand(100.0, 100)\nx2 = rand(100.0, 100)\nb0 = 6\nb1 = 1\nb2 = -2\nerr = norm(0, 10, 100)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(x1, x2, y)\nmodel = randomForestRegressor(sqlDS(<select * from t>), `y, `x1`x2)\nyhat = predict(model, t);\n// output\n[-93.733842,2.213932,5.39619,-47.817339,-38.655786,-75.772237,-45.817417,43.412841,-87.333214,-51.275368,32.41792,-45.797275,-152.075001,-83.423919,-21.154954,-65.734012,58.088571,-30.00795,-149.71085,-18.699006,-82.023643,-140.455355,-43.629218,65.832865,-79.411508,-65.625276,-17.466925,-43.469005,44.639384,31.686378...]\n\nplot(y, yhat, ,SCATTER);\n```\n\n![](https://docs.dolphindb.com/en/images/predict01.png)\n"
    },
    "prev": {
        "url": "https://docs.dolphindb.com/en/Functions/p/prev.html",
        "signatures": [
            {
                "full": "prev(X)",
                "name": "prev",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [prev](https://docs.dolphindb.com/en/Functions/p/prev.html)\n\n\n\n#### Syntax\n\nprev(X)\n\n#### Arguments\n\n**X** is a vector.\n\n#### Details\n\nShift the elements of a vector to the right for one position. In comparison, [next](https://docs.dolphindb.com/en/Functions/n/next.html) shifts the elements of a vector to the left for one position; [move](https://docs.dolphindb.com/en/Functions/m/move.html) shifts the elements of a vector for multiple positions.\n\n#### Examples\n\n```\nx=3 9 5 1 4;\nprev(x);\n// output\n[,3,9,5,1]\n```\n"
    },
    "prevState": {
        "url": "https://docs.dolphindb.com/en/Functions/p/prevState.html",
        "signatures": [
            {
                "full": "prevState(X)",
                "name": "prevState",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [prevState](https://docs.dolphindb.com/en/Functions/p/prevState.html)\n\n\n\n#### Syntax\n\nprevState(X)\n\n#### Arguments\n\n**X** is a vector or matrix of temporal/Boolean/numeric type.\n\n#### Details\n\nConsecutive elements in *X* with the same value feature the same state, and a NULL value has no state. The state of each element refers to its value. Return the previous state of the current element. If it is NULL, return the previous adjacent state.\n\nIf *X* is a matrix, return the previous state for each column of the matrix.\n\n#### Examples\n\n```\nX = [1, 2.2, NULL, 2.2, 2.3, 1, 1.2]\nprev(X)\n// output\n[,1,2.2,,2.2,2.3,1]\n\nprevState(X)\n// output\n[,1,2.2,2.2,2.2,2.3,1]\n\nX = matrix([1.0, 1.1, 1.0, 0.9], [NULL, 1.3, 2.5, 5.5], [5.5, 4.2, 1.6, 1.8])\nprevState(X)\n```\n\n| #0  | #1  | #2  |\n| --- | --- | --- |\n|     |     |     |\n| 1   |     | 5.5 |\n| 1.1 | 1.3 | 4.2 |\n| 1   | 2.5 | 1.6 |\n\nRelated function: [nextState](https://docs.dolphindb.com/en/Functions/n/nextState.html)\n"
    },
    "print": {
        "url": "https://docs.dolphindb.com/en/Functions/p/print.html",
        "signatures": [
            {
                "full": "print(X)",
                "name": "print",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [print](https://docs.dolphindb.com/en/Functions/p/print.html)\n\n\n\n#### Syntax\n\nprint(X)\n\n#### Arguments\n\n**X** is arbitrary data.\n\n#### Details\n\nPrint out results and variable contents.\n\n#### Examples\n\n```\nx=rand(10000,10);\nprint x;\n// output\n[9786,9501,8116,1266,1719,789,8162,3113,2740,6323]\n```\n"
    },
    "prod": {
        "url": "https://docs.dolphindb.com/en/Functions/p/prod.html",
        "signatures": [
            {
                "full": "prod(X)",
                "name": "prod",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [prod](https://docs.dolphindb.com/en/Functions/p/prod.html)\n\n\n\n#### Syntax\n\nprod(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nIf *X* is a vector, return the product of all the elements in *X*.\n\nIf *X* is a matrix, calculate the product of all the elements in each column of *X* and return a vector.\n\nIf *X* is a table, calculate the product of all the elements in each column of *X* and return a table.\n\nAs with all aggregate functions, NULL values are not included in the calculation.\n\n#### Examples\n\n```\nprod(1 2 NULL 3);\n// output\n6\n```\n\n```\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nprod(m);\n// output\n[6,120]\n```\n"
    },
    "purgeCacheEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/p/purgeCacheEngine.html",
        "signatures": [
            {
                "full": "purgeCacheEngine()",
                "name": "purgeCacheEngine",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [purgeCacheEngine](https://docs.dolphindb.com/en/Functions/p/purgeCacheEngine.html)\n\nAlias for [flushOLAPCache](https://docs.dolphindb.com/en/Functions/f/flushOLAPCache.html)\n\n\n\n#### Syntax\n\npurgeCacheEngine()\n\n#### Arguments\n\nNone\n\n#### Details\n\nForcibly flush the data of completed transactions cached in the OLAP cache engine to the database. Specify the configuration parameter *chunkCacheEngineMemSize* and set *dataSync* = 1 before execution.\n"
    },
    "push!": {
        "url": "https://docs.dolphindb.com/en/Functions/p/push!.html",
        "signatures": [
            {
                "full": "append!(obj, newData)",
                "name": "append!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "newData",
                        "name": "newData"
                    }
                ]
            }
        ],
        "markdown": "### [push!](https://docs.dolphindb.com/en/Functions/p/push!.html)\n\nAlias for [append!](https://docs.dolphindb.com/en/Functions/a/append!.html)\n\n\nDocumentation for the `append!` function:\n### [append!](https://docs.dolphindb.com/en/Functions/a/append!.html)\n\n\n\n#### Syntax\n\nappend!(obj, newData)\n\nAlias: push!\n\n#### Arguments\n\n**obj** is a local variable, and it must be a vector/tuple/matrix/table/set.\n\n**newData** is a scalar/vector/tuple/table/set.\n\n* If *obj* is a vector, *newData* is a scalar, vector, or tuple whose elements are of the same type as *obj*. The result is a vector longer than *obj*.\n\n* If *obj* is a tuple, *newData* is a scalar, vector or tuple:\n  * If *newData* is a vector, it is appended to *obj* as one tuple element;\n\n  * If *newData* is a tuple, the *appendTupleAsAWhole* configuration parameter controls whether it is appended to *obj* as one tuple element (true) or each of its elements is appended independently (false).\n\n* If *obj* is a matrix, *newData* is a vector whose length must be a multiple of the number of rows of *obj*. The result is a matrix with the same number of rows as *obj* but with more columns.\n\n* If *obj* is a table, *newData* is a table with the same number of columns as *obj*. The result is a table with the same number and name of columns as *obj* but with more rows.\n\n* If *newData* and *obj* are of different data forms, `append!` will attempt to convert *newData* to the same data form as *obj*. If it is not possible, return an error message.\n\n#### Details\n\nAppend *newData* to *obj*. The exclamation mark (!) means in-place change in DolphinDB.\n\nNote: In most cases, the column names and orders in the tables should be consistent. Please first check whether the corresponding columns in *obj* and *newData* have the same names and are arranged in the same order before executing `append!`. The function does not check the consistency of column names or align the columns if they are not arranged in the same order. It is executed as long as the corresponding columns are of the same data types.\n\n#### Examples\n\n```\nx = 1 2 3\nx.append!(4)\nx\n// output\n[1,2,3,4]\n\nappend!(x, 5 6)\nx\n//output\n[1,2,3,4,5,6]\n\nx.append!(7.2)\nx\n//output\n[1,2,3,4,5,6,7]\n// converted DOUBLE 7.2 to INT 7\n\nx.append!(`XOM)\n// Error: Incompatible type. Expected: INT, Actual: STRING\n\nx=array(int, 0, 10) // x is an empty vector\nx\n//output\n[]\n\nx.append!(1)\nx\n//output\n[]\n\nx=array(symbol, 0, 100)\nappend!(x, `TEST)\nx\n//output\n[\"TEST\"]\n\nx=1..6$3:2\nx\n\nx = (1,\"X\")\ny = (2,\"Y\")\nx.append!(y)\nprint(x)\n// when appendTupleAsAWhole = true\n(1,\"X\",(2,\"Y\"))\n// when appendTupleAsAWhole = false\n(1,\"X\",2,\"Y\")\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\nx.append!(7..12)\nx\n```\n\n| 0 | 1 | 2 | 3  |\n| - | - | - | -- |\n| 1 | 4 | 7 | 10 |\n| 2 | 5 | 8 | 11 |\n| 3 | 6 | 9 | 12 |\n\n```\nx=set(1 2 3 4)\nx.append!(6)\nx\n// output\nset(6,1,2,3,4)\n\nt1=table(1 2 3 as x, 4 5 6 as y)\nt2=table(1.1 2.2 3.3 as a, 4.4 5.5 6.6 as b)\nt1.append!(t2)\nt1\n```\n\n| x | y |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n| 1 | 4 |\n| 2 | 6 |\n| 3 | 7 |\n\nUse `append!` to add data to a DFS table. The following example should be executed in a DFS cluster.\n\n```\nn=1000000\nt=table(rand(`IBM`MS`APPL`AMZN,n) as symbol, rand(10.0, n) as value)\ndb = database(\"dfs://rangedb_tradedata\", RANGE, `A`F`M`S`ZZZZ)\nTrades = db.createPartitionedTable(t, \"Trades\", \"symbol\")\n```\n\nWe have created an empty table Trades with the schema of t. Next, we append the empty table Trades with data from table t.\n\n```\nTrades.append!(t)\nselect count(*) from Trades;\n// output\n1000000\n```\n\nTo append table Trades with another table:\n\n```\nn=500000\nt1=table(rand(`FB`GE`MSFT,n) as symbol, rand(100.0, n) as value)\nTrades.append!(t1)\nselect count(*) from Trades\n// output\n1500000\n```\n"
    },
    "pwlfPredict": {
        "url": "https://docs.dolphindb.com/en/Functions/p/pwlfPredict.html",
        "signatures": [
            {
                "full": "pwlfPredict(model, X, [beta], [breaks])",
                "name": "pwlfPredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[beta]",
                        "name": "beta",
                        "optional": true
                    },
                    {
                        "full": "[breaks]",
                        "name": "breaks",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [pwlfPredict](https://docs.dolphindb.com/en/Functions/p/pwlfPredict.html)\n\n\n\n#### Syntax\n\npwlfPredict(model, X, \\[beta], \\[breaks])\n\n#### Arguments\n\n**model** is a dictionary returned by `piecewiseLinFit`.\n\n**X** is a numeric vector indicating the x locations to predict the output of the fitted continuous piecewise linear function. NULL value is not allowed.\n\n**beta** (optional) is a numeric vector indicating the model parameters for the continuous piecewise linear fit. NULL value is not allowed.\n\n**breaks** (optional) is a numeric vector indicating the x locations where each line segment terminates. These are referred to as breakpoints for each line segment. NULL value is not allowed.\n\n#### Details\n\nEvaluate the fitted continuous piecewise linear function at untested points.\n\n**Return value**: A floating-point vector.\n\n#### Examples\n\n```\ndef linspace(start, end, num, endpoint=true){\n\tif(endpoint) return end$DOUBLE\\(num-1), start + end$DOUBLE\\(num-1)*0..(num-1)\n\telse return start + end$DOUBLE\\(num-1)*0..(num-1)\t\n}\nX = linspace(0.0, 1.0, 10)[1]\nY = [0.41703981, 0.80028691, 0.12593987, 0.58373723, 0.77572962, 0.41156172, 0.72300284, 0.32559528, 0.21812564, 0.41776427]\n// Fit a continuous piecewise linear function\nmodel = piecewiseLinFit(X, Y, 3)\n// Pass x locations\nxHat = linspace(0.0, 1.0, 20)[1]\n// Evaluate xHat using the model\npwlfPredict(model, xHat)\n\n// output: [0.593305499919518 0.524360777381737 0.455416054843957 0.386471332306177 0.317526609768396 0.368043438179296 0.529813781212159 0.691584124245021 0.69295837868457  0.655502915538459 0.618047452392347 0.580591989246236 0.543136526100125 0.505681062954014 0.468225599807903 0.430770136661792 0.393314673515681 0.35585921036957  0.318403747223459 0.280948284077348]\n```\n\n**Related function**: [piecewiseLinFit](https://docs.dolphindb.com/en/Functions/p/piecewiseLinFit.html)\n"
    },
    "gaussianKde": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gaussianKde.html",
        "signatures": [
            {
                "full": "gaussianKde(X,[weights],[bwMethod=\"scott\"])",
                "name": "gaussianKde",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weights]",
                        "name": "weights",
                        "optional": true
                    },
                    {
                        "full": "[bwMethod=\"scott\"]",
                        "name": "bwMethod",
                        "optional": true,
                        "default": "\"scott\""
                    }
                ]
            }
        ],
        "markdown": "### [gaussianKde](https://docs.dolphindb.com/en/Functions/g/gaussianKde.html)\n\n\n\n#### Syntax\n\ngaussianKde(X,\\[weights],\\[bwMethod=\"scott\"])\n\n#### Arguments\n\n**X** is a numeric vector, matrix, tuple, or table indicating the input dataset. Each row in *X* corresponds to a data point with consistent dimensions and a minimum of 2 elements (i.e., a data point must have at least 2 dimensions). The dataset must contain more rows than columns. Distributed tables are currently not supported.\n\n**weights** (optional) is a numeric vector indicating the weight of each data point. By default, all data points are equally weighted. The values in *weights* must be non-negative and not all zeros. The length of *weights* must be the same as the number of rows in *X*.\n\n**bwMethod**(optional) indicates the method for generating the bandwidth. It can be:\n\n* A STRING scalar, \"scott\" (default) or \"silverman\"\n\n* A numeric scalar indicating the bandwidth size\n\n* A function used to calculate the bandwidth based on *X* and return a numeric scalar.\n\n#### Details\n\nEstimate the probability density of the random variable using the Gaussian kernel from kernel density estimation (KDE).\n\nThe generated model can be used as the input for the `gaussianKdePredict` function.\n\n**Return value**: A dictionary with the following keys:\n\n* **X** is a floating-point vector or matrix indicating the input dataset *X*.\n\n* **cov** is a floating-point matrix indicating the Cholesky decomposition of the covariance matrix generated from *weights*, *X*, and bandwidth.\n\n* **weights** is a floating-point vector indicating the corresponding weight of each data point.\n\n* **predict** is a function pointer indicating the corresponding prediction function. It is used with the syntax `model.gaussianKdePredict(model, X)`. For details, see [gaussianKdePredict](https://docs.dolphindb.com/en/Functions/g/gaussianKdePredict.html).\n\n* **bandwidth** is a floating-point scalar indicating the generated bandwidth.\n\n#### Examples\n\nEstimate the probability density of the input file *trainset.txt*.\n\n```\ntrainData = loadText(\"trainset.txt\",\" \");\nmodel = gaussianKde(trainData)\nmodel\n```\n\nOutput:\n\n```\nX->\n#0      #1     \n0.1460  -0.1659\n-1.3717 -1.6650\n-1.6957 -1.1680\n-0.7976 0.6081 \n0.1088  2.5113 \n-0.0724 -0.8210\n-1.7548 -0.3485\n1.1202  0.9004 \n1.0234  0.7907 \n-0.4256 0.7169 \n\npredict->gaussianKdePredict\ncov->\n#0     #1    \n0.7040 0.0   \n0.4921 0.6700\n\nweights->[0.1000,0.1000,0.1000,0.1000,0.1000,0.1000,0.1000,0.1000,0.1000,0.1000]\nbandwidth->0.6812\n```\n\n`gaussianKde` can also be used with the `gaussianKdePredict` function to predict the probability density of another input file, *testset.txt*, as shown below.\n\n```\ntestData = loadText(\"testset.txt\",\" \");\nmodel.predict(testData)\n```\n\nOutput:\n\n```\n->[0.0623,0.0730,0.0336,0.0030,0.0001,0.0552....]\n```\n\nRelated Function: [gaussianKdePredict](https://docs.dolphindb.com/en/Functions/g/gaussianKdePredict.html)\n\n#### Appendix\n\n[trainset.txt](https://docs.dolphindb.com/en/Functions/resources/trainset.txt)\n\n[testset.txt](https://docs.dolphindb.com/en/Functions/resources/testset.txt)\n"
    },
    "gaussianKdePredict": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gaussianKdePredict.html",
        "signatures": [
            {
                "full": "gaussianKdePredict(model,X)",
                "name": "gaussianKdePredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [gaussianKdePredict](https://docs.dolphindb.com/en/Functions/g/gaussianKdePredict.html)\n\n\n\n#### Syntax\n\ngaussianKdePredict(model,X)\n\n#### Arguments\n\n**model** is a dictionary indicating the model generated by `gaussianKde`.\n\n**X** is a numeric vector, matrix, tuple, or table indicating the data to be predicted. Its dimensions must be the same as those of the dataset used in `gaussianKde`.\n\n#### Details\n\nPredict the probability density of the input data based on the model generated by `gaussianKde`.\n\n**Return value**: A floating-point vector of the same size as the number of rows in *X*, indicating the prediction result of each data point in *X*.\n\n#### Examples\n\nThe following example first uses the `gaussianKde` function to estimate the probability density of the input *trainset.txt*. based on the Gaussian kernel estimation and generate a model. Then, the `gaussianKdePredict` function is called to apply this model to another input file, *testset.txt*, to predict its probability density results.\n\n```\ntrainData = loadText(\"trainset.txt\",\" \");\ntestData = loadText(\"testset.txt\",\" \");\nmodel = gaussianKde(trainData)\ngaussianKdePredict(model, testData)\n```\n\nOutput:\n\n```\n->[0.0623,0.0730,0.0336,0.0030,0.0001,0.0552....]\n```\n\nRelated Function: [gaussianKde](https://docs.dolphindb.com/en/Functions/g/gaussianKde.html)\n\n#### Appendix\n\n[trainset.txt](https://docs.dolphindb.com/en/Functions/resources/trainset.txt)\n\n[testset.txt](https://docs.dolphindb.com/en/Functions/resources/testset.txt)\n"
    },
    "gaussianNB": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gaussianNB.html",
        "signatures": [
            {
                "full": "gaussianNB(Y, X, [varSmoothing=1e-9])",
                "name": "gaussianNB",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[varSmoothing=1e-9]",
                        "name": "varSmoothing",
                        "optional": true,
                        "default": "1e-9"
                    }
                ]
            }
        ],
        "markdown": "### [gaussianNB](https://docs.dolphindb.com/en/Functions/g/gaussianNB.html)\n\n\n\n#### Syntax\n\ngaussianNB(Y, X, \\[varSmoothing=1e-9])\n\n#### Arguments\n\n**Y** is a vector with the same length as table *X*. Each element of labels indicates the class that the correponding row in *X* belongs to.\n\n**X** is a table indicating the training set. Each row is a sample and each column is a feature.\n\n**varSmoothing** (optional) is a positive floating number indicating the portion of the largest variance of all features that is added to variances for calculation stability. The default value is 1e-9.\n\n#### Details\n\nConduct the Naive Bayesian classification. Return a dictionary with the following keys:\n\n* model: a RESOURCE data type variable. It is an internal binary resource generated by function `gaussianNB` and to be used by function [predict](https://docs.dolphindb.com/en/Functions/p/predict.html).\n\n* modelName: string \"GaussianNB\".\n\n* varSmoothing: varSmoothing parameter value.\n\n#### Examples\n\nThe dataset iris.data used in the following example can be downloaded from <https://archive.ics.uci.edu/ml/datasets/iris>.\n\n```\nDATA_DIR = \"C:/DolphinDB/Data\"\nt = loadText(DATA_DIR+\"/iris.data\")\nt.rename!(`col0`col1`col2`col3`col4, `sepalLength`sepalWidth`petalLength`petalWidth`class)\nt[`classType] = take(0, t.size())\nupdate t set classType = 1 where class = \"Iris-versicolor\"\nupdate t set classType = 2 where class = \"Iris-virginica\"\n\ntraining = select sepalLength, sepalWidth, petalLength, petalWidth from t\nlabels = t.classType\n\nmodel = gaussianNB(labels, training);\n\npredict(model, training);\n```\n"
    },
    "ge": {
        "url": "https://docs.dolphindb.com/en/Functions/g/ge.html",
        "signatures": [
            {
                "full": "ge(X, Y)",
                "name": "ge",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ge](https://docs.dolphindb.com/en/Functions/g/ge.html)\n\n\n\n#### Syntax\n\nge(X, Y)\n\nor\n\nX>=Y\n\n#### Arguments\n\n**X** / **Y** can be a scalar/pair/vector/matrix/set. If X or Y is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nIf neither *X* nor *Y* is a set, return the element-by-element comparison of *X*>=*Y*.\n\nIf both *X* and *Y* are sets, check if *Y* is a subset of *X*.\n\n#### Examples\n\n```\n1 2 3 >= 2;\n// output\n[false,true,true]\n\n1 2 3 >= 0 2 4;\n// output\n[true,true,false]\n\n2:3>=1:6;\n// output\n[true,false]\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 ge 4;\n```\n\n| #0    | #1    | #2   |\n| ----- | ----- | ---- |\n| false | false | true |\n| false | true  | true |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1>=m2;\n```\n\n| #0    | #1    | #2   |\n| ----- | ----- | ---- |\n| false | false | true |\n| false | true  | true |\n\nSet operation: If X>=Y then Y is a subset of X\n\n```\nx=set(4 6);\nx;\n// output\nset(6,4)\ny=set(8 9 4 6);\ny;\n// output\nset(6,4,9,8)\n\ny>=x;\n// output\ntrue\n\nx>=y;\n// output\nfalse\n\nx>=x;\n// output\ntrue  // x is a subset of x\n```\n"
    },
    "gema": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gema.html",
        "signatures": [
            {
                "full": "gema(X, window, alpha)",
                "name": "gema",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "alpha",
                        "name": "alpha"
                    }
                ]
            }
        ],
        "markdown": "### [gema](https://docs.dolphindb.com/en/Functions/g/gema.html)\n\n\n\n#### Syntax\n\ngema(X, window, alpha)\n\nPlease see [TA-Lib Functions](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**alpha** is a floating-point number in (0,1) indicating the smoothing factor alpha.\n\n#### Details\n\nCalculate the Exponential Moving Average (ema) for *X* in a sliding window of the given length.\n\nDifferent from [ema](https://docs.dolphindb.com/en/Functions/e/ema.html), the function `gema` uses a smoothing factor alpha for EMA. The formula is:\n\n![](https://docs.dolphindb.com/en/images/gema.png)\n\nwhere ![](https://docs.dolphindb.com/en/images/gema_k.png) is the *k-th* exponential moving average, *alpha* is the smoothing factor, and Xk is the *k-th* element of the vector *X*.\n\n#### Examples\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\ngema(x,3,0.5);\n// output\n[,,12.299999999999998,12.55,12.225000000000001,11.912500000000001,11.55625]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\ngema(x,3,0.1);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n| 12.3    | 15.6667 |\n| 12.35   | 16      |\n| 12.305  | 16.5    |\n| 12.2345 | 16.05   |\n| 12.131  | 15.445  |\n\nRelated functions: [ema](https://docs.dolphindb.com/en/Functions/e/ema.html), [wilder](https://docs.dolphindb.com/en/Functions/w/wilder.html), [tema](https://docs.dolphindb.com/en/Functions/t/tema.html)\n"
    },
    "genericStateIterate": {
        "url": "https://docs.dolphindb.com/en/Functions/g/genericStateIterate.html",
        "signatures": [
            {
                "full": "genericStateIterate(X, initial, window, func)",
                "name": "genericStateIterate",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "initial",
                        "name": "initial"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    }
                ]
            }
        ],
        "markdown": "### [genericStateIterate](https://docs.dolphindb.com/en/Functions/g/genericStateIterate.html)\n\n#### Syntax\n\ngenericStateIterate(X, initial, window, func)\n\n#### Arguments\n\n**X** can be column(s) from the input table, or the calculation results by applying a vector function to the column(s). You can set *X* to \\[] to leave it unspecified; or use a tuple to specify multiple columns for *X*.\n\n**initial** can be a column from the input table, or the calculation results by applying a vector function to it. It is used to fill the first to window-th records in the output table.\n\n**window** is a non-negative integeran integer greater than 1that specifies the window size (measured by the number of records).\n\n**func** is a stateless user-defined function with one scalar as the return value. Arguments passed to *func* are as follows:\n\n* The first argument is a vector containing the previous window resultsif *window*>0, or the previous result if *window*=0.\n\n* Then followed by columns specified in *X*.\n\n* \\[Optional] Other fixed constants to be passed to *func*. In this case, you can fix the arguments with partial application.\n\n#### Details\n\nThis function performs calculation with count-based sliding windows iteratively.\n\nSuppose *X* is specified as \\[X1, X2, ..., Xn], column \"factor\" in the output table holds the calculation results, column \"initial\" is the initial column, *window* is set to \"w\", and the iterate function is \"func\". For the k-th record, the calculation rule is:\n\n* k <= w: factor\\[k-1] = initial\\[k-1]\n\n* k > w: factor\\[k-1] = func(factor\\[(k-1-w):k-1], X1\\[k-1], X2\\[k-1], … , Xn\\[k-1])\n\n* When w-0:\n\n  * k=1: factor\\[0] = func(initial\\[0], X1\\[0], X2\\[0], … , Xn\\[0])\n\n  * k>1: factor\\[k-1] = func(factor\\[(k-2)], X1\\[k-1], X2\\[k-1], … , Xn\\[k-1])\n\n* When w>0:\n\n  * k <= w: factor\\[k-1] = initial\\[k-1]\n\n  * k > w: factor\\[k-1] = func(factor\\[(k-1-w):k-1], X1\\[k-1], X2\\[k-1], … , Xn\\[k-1])\n\nNote that when a pair is used to indicate index, the right boundary is not inclusive, i.e., the range of (k-1-w):k-1 is \\[k-1-w, k-1).\n\n#### Examples\n\n```\n// define a function\ndef myfunc(x, w){\n    re = sum(x*w)\n    return re\n}\n\ndateTime = 2021.09.09T09:30:00.000 2021.09.09T09:31:00.000 2021.09.09T09:32:00.000 2021.09.09T09:33:00.000 2021.09.09T09:34:00.000\nsecurityID = `600021`600021`600021`600021`600021\nvolume = 310 280 300 290 240\nprice = 1.5 1.6 1.7 1.6 1.5\nt = table(1:0, `dateTime`securityID`volume`price, [TIMESTAMP, SYMBOL, INT, DOUBLE])\ntableInsert(t, dateTime, securityID, volume, price)\noutput = table(100:0, `securityID`dateTime`factor1, [SYMBOL, TIMESTAMP, DOUBLE])\n\nengine = createReactiveStateEngine(name=\"test\", metrics=[<dateTime>, <genericStateIterate(volume,price,3,myfunc{,})>], dummyTable=t, outputTable=output, keyColumn=`SecurityID, keepOrder=true)\nengine.append!(t)\ndropStreamEngine(`test)\n```\n\n| securityID | dateTime                | factor1 |\n| ---------- | ----------------------- | ------- |\n| 600021     | 2021.09.09T09:30:00.000 | 1.5     |\n| 600021     | 2021.09.09T09:31:00.000 | 1.6     |\n| 600021     | 2021.09.09T09:32:00.000 | 1.7     |\n| 600021     | 2021.09.09T09:33:00.000 | 1,392   |\n| 600021     | 2021.09.09T09:34:00.000 | 334,872 |\n\nThe above example is calculated as follows:\n\n* As *window* is set to 3, the first 3 records of factor1 in the initial window take the corresponding values of column price.\n\n* When the 4th record arrives, the initial window \\[1.5, 1.6, 1.7] and the current value of volume 290 are used for iteration. The result of myfunc(\\[1.5, 1.6, 1.7], 290) is 1392.\n\n* When the 5th record arrives, the previous \\[1.6, 1.7, 1392] and the current value of volume 240 are used for iteration. The result of myfunc(\\[1.6, 1.7, 1392], 240) is 334872.\n\nThe calculation process is preceded in the same way if data ingestion continues.\n\nRelated function: [genericTStateIterate](https://docs.dolphindb.com/en/Functions/g/genericTStateIterate.html)\n\n"
    },
    "genericTStateIterate": {
        "url": "https://docs.dolphindb.com/en/Functions/g/genericTStateIterate.html",
        "signatures": [
            {
                "full": "genericTStateIterate(T, X, initial, window, func, [leftClosed=false])",
                "name": "genericTStateIterate",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "initial",
                        "name": "initial"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "[leftClosed=false]",
                        "name": "leftClosed",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [genericTStateIterate](https://docs.dolphindb.com/en/Functions/g/genericTStateIterate.html)\n\n#### Syntax\n\ngenericTStateIterate(T, X, initial, window, func, \\[leftClosed=false])\n\n#### Arguments\n\n**T** is a non-strictly increasing vector of temporal or integral type. It cannot contain NULL values. Note that out-of-order data is discarded in the calculation.\n\n**X** can be column(s) from the input table, or the calculation results by applying a vector function to the column(s). You can set *X* to \\[] to leave it unspecified; or use a tuple to specify multiple columns for *X*.\n\n**initial** is the column used to fill the initial window in the result column of the output table. It can be a column from the input table, or the calculation results by applying a vector function to it. Suppose the timestamp of the first record is t0, the initial window is \\[t0, t0 + window), measured by time interval.\n\n**window** is a positive integer or a DURATION scalar that specifies the window size. When window is an integer, it has the same time unit as *T*.\n\n**func** is a stateless user-defined function with one scalar as the return value. Arguments passed to *func* are as follows:\n\n* The first argument is a vector containing the previous window results.\n\n* Then followed by columns specified in *X*.\n\n* \\[Optional] Other fixed constants to be passed to func. In this case, you can fix the arguments with partial application.\n\n**leftClosed** (optional) is a Boolean value indicating whether the left boundary of the window is inclusive. The default value is false.\n\n#### Details\n\nThis function performs calculation with time-based windows iteratively.\n\nSuppose T is a time column, X is \\[X1, X2, ..., Xn], column \"factor\" in the output table holds the calculation results, column \"initial\" is the initial column, window is set to \"w\", and the iterate function is \"func\".\n\nFor the k-th record (with its timestamp Tk), the calculation rule is:\n\n* Tk ∈ \\[T1, T1+w): factor\\[k] = initial\\[k]\n\n* factor\\[k] = func(subFactor, X1\\[k], X2\\[k], … , Xn\\[k]), where\n\n  * *subFactor* is the value of factor in the current window\n\n  * the window for the (k+1)th record is (Tk-w, Tk] (when leftClosed=false) or \\[Tk-w, Tk] (when leftClosed=true).\n\n#### Examples\n\nExample 1. When *leftClosed* is set to false:\n\n```\n// define a function\ndef myfunc(x, w){\nre = sum(x*w)\nreturn re\n}\n\ndateTime = 2021.09.09T09:28:00.000 2021.09.09T09:28:30.000 2021.09.09T09:30:00.000 2021.09.09T09:31:00.000 2021.09.09T09:32:00.000\nsecurityID = `600021`600021`600021`600021`600021\nvolume = 310 280 300 290 240\nprice = 1.5 1.6 1.7 1.6 1.5\nt = table(1:0, `dateTime`securityID`volume`price, [TIMESTAMP, SYMBOL, INT, DOUBLE])\ntableInsert(t, dateTime, securityID, volume, price)\noutput = table(100:0, `securityID`dateTime`factor1, [SYMBOL, TIMESTAMP, DOUBLE])\n\nengine = createReactiveStateEngine(name=\"test\", metrics=[<dateTime>, <genericTStateIterate(dateTime,volume,price,2m,myfunc{,})>], dummyTable=t, outputTable=output, keyColumn=`SecurityID, keepOrder=true)\nengine.append!(t)\ndropStreamEngine(`test)\n```\n\n| securityID | dateTime                | factor1    |\n| ---------- | ----------------------- | ---------- |\n| 600021     | 2021.09.09T09:28:00.000 | 1.5        |\n| 600021     | 2021.09.09T09:28:30.000 | 1.6        |\n| 600021     | 2021.09.09T09:30:00.000 | 930        |\n| 600021     | 2021.09.09T09:31:00.000 | 270,164    |\n| 600021     | 2021.09.09T09:32:00.000 | 65,062,560 |\n\nThe above example is calculated as follows:\n\n* As the timestamp of the first record is 09:28:00.000 and window size is 2 min, the initial window is \\[2021.09.09T09:28:00.000, 2021.09.09T09:30:00.000). For the first 2 records are included in the window, corresponding values of price are output to factor1 directly.\n\n* The 3rd record belongs to window (2021.09.09T09:26:30.000, 2021.09.09T09:28:30.000]. Data in the previous window \\[1.5, 1.6] and volume 300 are used for iteration. The result of myfunc(\\[1.5, 1.6], 300) is 930.\n\n* The 4th record belongs to window (2021.09.09T09:28:00.000, 2021.09.09T09:30:00.000]. Data in the previous window \\[1.6, 930] and volume 290 are used for iteration. The result of myfunc(\\[1.6, 930], 290) is 270164.\n\nThe calculation process is preceded in the same way if data ingestion continues.\n\nExample 2. When *leftClosed* is set to true:\n\n```\n$ engine = createReactiveStateEngine(name=\"test\", metrics=[<dateTime>, <genericTStateIterate(dateTime,volume,price,2m,myfunc{,},true)>], dummyTable=t, outputTable=output, keyColumn=`SecurityID, keepOrder=true)\n```\n\n| securityID | dateTime                | factor1    |\n| ---------- | ----------------------- | ---------- |\n| 600021     | 2021.09.09T09:28:00.000 | 1.5        |\n| 600021     | 2021.09.09T09:28:30.000 | 1.6        |\n| 600021     | 2021.09.09T09:30:00.000 | 930        |\n| 600021     | 2021.09.09T09:31:00.000 | 270,599    |\n| 600021     | 2021.09.09T09:32:00.000 | 65,166,960 |\n\nThe above example is calculated as follows:\n\n* As the timestamp of the first record is 09:28:00.000 and window size is 2 min, the initial window is \\[2021.09.09T09:28:00.000, 2021.09.09T09:30:00.000). For the first 2 records are included in the window, corresponding values of price are output to factor1 directly.\n\n* The 3rd record belongs to window \\[2021.09.09T09:26:30.000, 2021.09.09T09:28:30.000]. Data in the previous window is \\[1.5, 1.6] and volume is 300. The result of myfunc(\\[1.5, 1.6], 300) is 930.\n\n* The 4th record belongs to window \\[2021.09.09T09:28:00.000, 2021.09.09T09:30:00.000]. Data in the previous window \\[1.5, 1.6, 930] and volume 290 are used for iteration. The result of myfunc(\\[1.5, 1.6, 930], 290) is 270599.\n\nThe calculation process is preceded in the same way if data ingestion continues.\n\nRelated function: [genericStateIterate](https://docs.dolphindb.com/en/Functions/g/genericStateIterate.html)\n\n"
    },
    "genShortGenomeSeq": {
        "url": "https://docs.dolphindb.com/en/Functions/g/genShortGenomeSeq.html",
        "signatures": [
            {
                "full": "genShortGenomeSeq(X, window)",
                "name": "genShortGenomeSeq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [genShortGenomeSeq](https://docs.dolphindb.com/en/Functions/g/genShortGenomeSeq.html)\n\n#### Syntax\n\ngenShortGenomeSeq(X, window)\n\nAlias: genSGS\n\n#### Arguments\n\n**X** is a STRING scalar or CHAR vector.\n\n**window** is a positive integer in \\[2,28].\n\n#### Details\n\nThis function slides a window of fixed size (based on the number of characters) over the input DNA sequence. It encodes the characters in each window and returns an integral vector containing the encoded values. The returned vector has the same length as the number of characters in *X*.\n\n**Note**:\n\n* This function adopts a forward sliding window approach, starting from the first character of the sequence. The sliding window moves by one character at a time. It first takes the current character, then the next character, continuing until window characters are included.\n\n* If *window* exceeds the total length of *X*, an empty integral vector is returned.\n\n**Return value**:\n\n| *window* Range | Return Type       |\n| -------------- | ----------------- |\n| \\[2,4]         | FAST SHORT VECTOR |\n| \\[5,12]        | FAST INT VECTOR   |\n| \\[13,28]       | FAST LONG VECTOR  |\n\n#### Examples\n\n```\ngenShortGenomeSeq(\"NNNNNNNNTCGGGGCAT\",3)\n// output\n[,,,,,,,,795,815,831,831,830,824,801,,]\n\ngenShortGenomeSeq(\"TCGGGGCATNGCCCG\",4)\n// output\n[1135,1215,1279,1278,1272,1249,,,,,1258,1195,,,]\n\ngenShortGenomeSeq(\"GCCCGATNNNNN\",6)\n// output\n[396972,395953,,,,,,,,,,]\n\ngenShortGenomeSeq(\"TCGATCGTCGATCGTCGATCGTCGATCGG\",5)\n// output\n[328113,328390,328475,327789,328118,328411,328556,328113,328390,328475,327789,328118,328411,328556,328113,328390,328475,327789,328118,328411,328556,328113,328390,328475,327791,,,,]\n\ngenShortGenomeSeq(\"ACTT\",8)\n// output\n[,,,]\n```\n\nRelated functions: [encodeShortGenomeSeq](https://docs.dolphindb.com/en/Functions/e/encodeShortGenomeSeq.html), [decodeShortGenomeSeq](https://docs.dolphindb.com/en/Functions/d/decodeShortGenomeSeq.html)\n\n"
    },
    "geoWithin": {
        "url": "https://docs.dolphindb.com/en/Functions/g/geoWithin.html",
        "signatures": [
            {
                "full": "geoWithin(X, polygonVertices, [containBoundary=true])",
                "name": "geoWithin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "polygonVertices",
                        "name": "polygonVertices"
                    },
                    {
                        "full": "[containBoundary=true]",
                        "name": "containBoundary",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [geoWithin](https://docs.dolphindb.com/en/Functions/g/geoWithin.html)\n\n#### Syntax\n\ngeoWithin(X, polygonVertices, \\[containBoundary=true])\n\n#### Arguments\n\n**X** is a POINT scalar/vector, indicating one or multiple points.\n\n**polygonVertices** is a POINT vector, indicating a polygon.\n\n**containBoundary** (optional) is a Boolean scalar, indicating whether the points on the polygon boundary are considered inside. The default value is true.\n\n#### Details\n\nDetermine whether *X* lies inside or outside *polygonVertices*.\n\n#### Examples\n\n```\npoint1 = point(1,1)\npoint2 = point(2,3)\npoint3 = point(2,1)\npolygon = [point(0,0),point(0,2),point(2,2),point(2,0)]\ngeoWithin([point1,point2],polygon)\n// output: [true,false,true]\ngeoWithin([point1,point2,point3],polygon,false)\n// output: [true,false,false]\n```\n\n"
    },
    "getActiveMaster": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getActiveMaster.html",
        "signatures": [
            {
                "full": "getActiveMaster()",
                "name": "getActiveMaster",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getActiveMaster](https://docs.dolphindb.com/en/Functions/g/getActiveMaster.html)\n\n\n\n#### Syntax\n\ngetActiveMaster()\n\n#### Arguments\n\nNone.\n\n#### Details\n\nReturn the alias of the controller node of a cluster. For a cluster with multiple controller nodes, return the alias of the Leader controller node. Please note that this function can only be executed on the controller.\n\n#### Examples\n\n```\ngetActiveMaster();\n// output\ncontroller1\n```\n"
    },
    "getAggregator": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getAggregator.html",
        "signatures": [
            {
                "full": "getStreamEngine(name)",
                "name": "getStreamEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [getAggregator](https://docs.dolphindb.com/en/Functions/g/getAggregator.html)\n\nAlias for [getStreamEngine](https://docs.dolphindb.com/en/Functions/g/getStreamEngine.html)\n\n\nDocumentation for the `getStreamEngine` function:\n### [getStreamEngine](https://docs.dolphindb.com/en/Functions/g/getStreamEngine.html)\n\n\n\n#### Syntax\n\ngetStreamEngine(name)\n\n#### Arguments\n\n**name** is a string indicating the name of the stream engine. It is the only identifier of the stream engine. It can have letter, number and \"\\_\". It must start with a letter.\n\n#### Details\n\nReturn the handle of a stream engine. It can be used as the handler of [subscribeTable](https://docs.dolphindb.com/en/Functions/s/subscribeTable.html).\n\n#### Examples\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\noutputTable = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\ntradesAggregator = createTimeSeriesEngine(\"StreamAggregatorDemo\",3, 3, <[sum(qty)]>, trades, outputTable, `time, false,`sym, 50)\nsubscribeTable(, \"trades\", \"tradesAggregator\", 0, append!{tradesAggregator}, true)\n\ndef writeData(n){\n   timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n   symv =take(`A`B, n)\n   qtyv = take(1, n)\n   insert into trades values(timev, symv, qtyv)\n}\n\nwriteData(6);\nh = getStreamEngine(\"StreamAggregatorDemo\")\n```\n"
    },
    "getAggregatorStat": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getAggregatorStat.html",
        "signatures": [
            {
                "full": "getStreamEngineStat()",
                "name": "getStreamEngineStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getAggregatorStat](https://docs.dolphindb.com/en/Functions/g/getAggregatorStat.html)\n\nAlias for [getStreamEngineStat](https://docs.dolphindb.com/en/Functions/g/getStreamEngineStat.html)\n\n\nDocumentation for the `getStreamEngineStat` function:\n### [getStreamEngineStat](https://docs.dolphindb.com/en/Functions/g/getStreamEngineStat.html)\n\n\n\n#### Syntax\n\ngetStreamEngineStat()\n\nAlias: getAggregatorStat\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn a dictionary of tables with various metrics about all stream engines.\n\n* Table *TimeSeriesEngine* returns the following columns about time-series engines:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | windowTime        | the length of the data window                                                       |\n  | step              | the duration between 2 adjacent calculations                                        |\n  | useSystemTime     | whether the stream engine is triggered as soon as data are injested into the system |\n  | garbageSize       | the threshold of the number of records in memory that triggers memory cleaning      |\n  | numGroups         | the number of groups that the stream engine has handled                             |\n  | numRows           | the number of records that has entered the stream engine                            |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n  | snapshotDir       | the directory to save engine snapshot                                               |\n  | snapshotInterval  | the interval to save snapshot                                                       |\n  | snapshotMsgId     | the msgId of engine snapshot                                                        |\n  | snapshotTimestamp | the timestamp of snapshot                                                           |\n\n* Table *CrossSectionalEngine* returns the following columns about cross-sectional engines:\n\n  | Column Name        | Description                                                                  |\n  | ------------------ | ---------------------------------------------------------------------------- |\n  | name               | name of the stream engine                                                    |\n  | user               | name of the user who created the stream engine                               |\n  | status             | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable |\n  | lastErrMsg         | the latest error message                                                     |\n  | numRows            | the number of records that has entered the stream engine                     |\n  | numMetrics         | the number of metrics calculated by the stream engine                        |\n  | metrics            | the metacode of the metrics calculated by the stream engine                  |\n  | triggeringPattern  | how calculations are triggered                                               |\n  | triggeringInterval | the duration in milliseconds between 2 adjacent calculations                 |\n  | memoryUsed         | the amount of memory used                                                    |\n\n* Table *AnomalyDetectionEngine* returns the following columns about the anomaly detection engines:\n\n  | Column Name       | Description                                                                    |\n  | ----------------- | ------------------------------------------------------------------------------ |\n  | name              | name of the stream engine                                                      |\n  | user              | name of the user who created the stream engine                                 |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable   |\n  | lastErrMsg        | the latest error message                                                       |\n  | numGroups         | the number of groups that the stream engine has handled                        |\n  | numRows           | the number of records that has entered the stream engine                       |\n  | numMetrics        | the number of metrics calculated by the stream engine                          |\n  | metrics           | the metacode of the metrics calculated by the stream engine                    |\n  | snapshotDir       | the directory to save engine snapshot                                          |\n  | snapshotInterval  | the interval to save snapshot                                                  |\n  | snapshotMsgId     | the msgId of engine snapshot                                                   |\n  | snapshotTimestamp | the timestamp of snapshot                                                      |\n  | garbageSize       | the threshold of the number of records in memory that triggers memory cleaning |\n  | memoryUsed        | the amount of memory used                                                      |\n\n* Table *ReactiveStateEngine* returns the following columns about the reactive state engines:\n\n  | Column Name                | Description                                                                                                                                              |\n  | -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n  | name                       | name of the reactive state engine                                                                                                                        |\n  | metrics                    | the metacode specifying the formulas for calculation                                                                                                     |\n  | dummyTable                 | a table object whose schema must be the same as the subscribed stream table                                                                              |\n  | outputTable                | the output table for the results                                                                                                                         |\n  | keyColumn                  | the grouping column(s)                                                                                                                                   |\n  | filter                     | the metacode indicating the filtering conditions in the form of expression                                                                               |\n  | snapshotDir                | the number of metrics calculated by the stream engine                                                                                                    |\n  | snapshotIntervalInMsgCount | the number of messages to receive before the next snapshot is saved                                                                                      |\n  | keepOrder                  | whether to preserve the insertion order of the records in the output table                                                                               |\n  | keyPurgeFilter             | the filtering conditions that identify the data to be purged from the cache                                                                              |\n  | keyPurgeFreqInSecond       | the time interval (in seconds) to trigger a purge                                                                                                        |\n  | raftGroup                  | the ID of the raft group on the high-availability streaming subscriber specified by the configuration parameter *streamingRaftGroups*                    |\n  | outputElapsedMicroseconds  | whether to output the elapsed time (in microseconds) from the ingestion of data to the output of result in each batch and the total number of each batch |\n\n* Table *SessionWindowEngine* returns the following columns about the session window engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | sessionGap        | gap between 2 session windows                                                       |\n  | useSystemTime     | whether the stream engine is triggered as soon as data are ingested into the system |\n  | numGroups         | the number of groups that the stream engine has handled                             |\n  | numRows           | the number of records that has entered the stream engine                            |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | Metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n  | snapshotDir       | the directory to save snapshot                                                      |\n  | snapshotInterval  | the interval to save snapshot                                                       |\n  | snapshotMsgId     | the message ID (msgId) of engine snapshot                                           |\n  | snapshotTimestamp | the timestamp of snapshot                                                           |\n\n* Table *DailyTimeSeriesEngine* returns the following columns about the daily time series engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | windowTime        | the length of the window                                                            |\n  | step              | the duration between 2 adjacent calculations                                        |\n  | useSystemTime     | whether the stream engine is triggered as soon as data are injected into the system |\n  | garbageSize       | the threshold of the number of records in memory that triggers memory cleaning      |\n  | numGroups         | the number of groups that the stream engine has handled                             |\n  | numRows           | the number of records that has entered the stream engine                            |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n  | snapshotDir       | the directory to save snapshot                                                      |\n  | snapshotInterval  | the interval to save snapshot                                                       |\n  | snapshotMsgId     | the message ID (msgId) of engine snapshot                                           |\n  | snapshotTimestamp | the timestamp of snapshot                                                           |\n\n* Table *AsofJoinEngine* returns the following columns about the as of join engine:\n\n  | Column Name       | Description                                                                    |\n  | ----------------- | ------------------------------------------------------------------------------ |\n  | name              | name of the stream engine                                                      |\n  | user              | name of the user who created the stream engine                                 |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable   |\n  | lastErrMsg        | the latest error message                                                       |\n  | useSystemTime     | the value of parameter useSystemTime in function createAsofJoinEngine          |\n  | delayedTime       | the value of parameter delayedTime in function createAsofJoinEngine            |\n  | garbageSize       | the threshold of the number of records in memory that triggers memory cleaning |\n  | leftTableNumRows  | the number of records in the left table of stream engine                       |\n  | rightTableNumRows | the number of records in the right table of stream engine                      |\n  | numMetrics        | the number of metrics calculated by the stream engine                          |\n  | metrics           | the metacode of the metrics calculated by the stream engine                    |\n  | memoryUsed        | the amount of memory used                                                      |\n\n* Table *EquiJoinEngine* returns the following columns about the equi join engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | garbageSize       | whether the stream engine is triggered as soon as data are ingested into the system |\n  | leftTableNumRows  | the number of records that has entered the left table of the stream engine          |\n  | rightTableNumRows | the number of records that has entered the right table of the stream engine         |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n\n* Table *WindowJoinEngine* returns the following columns about the window join engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | garbageSize       | whether the stream engine is triggered as soon as data are ingested into the system |\n  | leftTableNumRows  | the number of records that has entered the left table of the stream engine          |\n  | rightTableNumRows | the number of records that has entered the right table of the stream engine         |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n\n* Table *LookupJoinEngine* returns the following columns about the lookup join engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | garbageSize       | whether the stream engine is triggered as soon as data are ingested into the system |\n  | leftTableNumRows  | the number of records that has entered the left table of the stream engine          |\n  | rightTableNumRows | the number of records that has entered the right table of the stream engine         |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n\n* Table *LeftSemiJoinEngine* returns the following columns about the left semi join engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | garbageSize       | whether the stream engine is triggered as soon as data are ingested into the system |\n  | leftTableNumRows  | the number of records that has entered the left table of the stream engine          |\n  | rightTableNumRows | the number of records that has entered the right table of the stream engine         |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n\n* Table *DualOwnershipReactiveStateEngine* returns the following columns about the dual ownership reactive state engine:\n\n  | Column Name                | Description                                                                                                                                              |\n  | -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n  | name                       | name of the engine                                                                                                                                       |\n  | metrics                    | the metacode specifying the formulas for calculation                                                                                                     |\n  | dummyTable                 | a table object whose schema must be the same as the subscribed stream table                                                                              |\n  | outputTable                | the output table for the results                                                                                                                         |\n  | keyColumn                  | the grouping column(s)                                                                                                                                   |\n  | filter                     | the metacode indicating the filtering conditions in the form of expression                                                                               |\n  | snapshotDir                | the number of metrics calculated by the stream engine                                                                                                    |\n  | snapshotIntervalInMsgCount | the number of messages to receive before the next snapshot is saved                                                                                      |\n  | keepOrder                  | whether to preserve the insertion order of the records in the output table                                                                               |\n  | keyPurgeFilter             | the filtering conditions that identify the data to be purged from the cache                                                                              |\n  | keyPurgeFreqInSecond       | the time interval (in seconds) to trigger a purge                                                                                                        |\n  | raftGroup                  | the ID of the raft group on the high-availability streaming subscriber specified by the configuration parameter *streamingRaftGroups*                    |\n  | outputElapsedMicroseconds  | whether to output the elapsed time (in microseconds) from the ingestion of data to the output of result in each batch and the total number of each batch |\n\n* Table *NarrowReactiveStateEngine* returns the following columns about the narrow reactive state engine:\n\n  | Column Name               | Description                                                                                                                                               |\n  | ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n  | name                      | name of the engine                                                                                                                                        |\n  | metrics                   | metacode or a tuple of metacode containing columns from the input table (excluding *keyColumn*, optional) or factors (formulas for calculation, required) |\n  | metricNames               | the name for each factor specified in *metrics*                                                                                                           |\n  | dummyTable                | a table object whose schema must be the same as the subscribed stream table                                                                               |\n  | outputTable               | the output table for the results                                                                                                                          |\n  | keyColumn                 | the grouping column(s)                                                                                                                                    |\n  | filter                    | the metacode indicating the filtering conditions in the form of expression                                                                                |\n  | keepOrder                 | whether to preserve the insertion order of the records in the output table                                                                                |\n  | keyPurgeFilter            | the filtering conditions that identify the data to be purged from the cache                                                                               |\n  | keyPurgeFreqInSecond      | the time interval (in seconds) to trigger a purge                                                                                                         |\n  | outputElapsedMicroseconds | whether to output the elapsed time (in microseconds) from the ingestion of data to the output of result in each batch and the total number of each batch  |\n\n* Table *StreamFilter* returns the following columns about stream filter:\n\n  | Column Name | Description                                                                  |\n  | ----------- | ---------------------------------------------------------------------------- |\n  | name        | name of the stream engine                                                    |\n  | user        | name of the user who created the stream engine                               |\n  | status      | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable |\n  | lastErrMsg  | the latest error message                                                     |\n  | numRows     | the number of records that has entered the stream engine                     |\n  | filters     | the filtering condition                                                      |\n\n* Table *StreamDispatchEngine* returns the following columns about stream dispatch engines:\n\n  | Column Name | Description                                                                  |\n  | ----------- | ---------------------------------------------------------------------------- |\n  | name        | name of the stream engine                                                    |\n  | user        | name of the user who created the stream engine                               |\n  | status      | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable |\n  | lastErrMsg  | the latest error message                                                     |\n  | numRows     | the number of records that has entered the stream engine                     |\n  | memoryUsed  | the amount of memory used                                                    |\n\n#### Examples\n\n```\nshare streamTable(10:0,`time`sym`price`qty,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades\noutputTable1 = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\noutputTable2 = table(1:0, `time`avgPrice`sumqty`Total, [TIMESTAMP,DOUBLE,INT,DOUBLE])\ntradesTsEngine = createTimeSeriesEngine(name=\"TimeSeriesDemo\", windowSize=3, step=3, metrics=<[sum(qty)]>, dummyTable=trades, outputTable=outputTable1, timeColumn=`time, keyColumn=`sym, garbageSize=50)\ntradesCsEngine=createCrossSectionalEngine(name=\"CrossSectionalDemo\", metrics=<[avg(price), sum(qty), sum(price*qty)]>, dummyTable=trades, outputTable=outputTable2, keyColumn=`sym, triggeringPattern=`perRow)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesTsEngine\", offset=0, handler=append!{tradesTsEngine}, msgAsTable=true)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesCsEngine\", offset=0, handler=append!{tradesCsEngine}, msgAsTable=true)\n\ndef writeData(n){\n   timev = 2000.10.08T01:01:01.001 + timestamp(1..n)\n   symv =take(`A`B, n)\n   pricev=take(102.1 33.4 73.6 223,n)\n   qtyv = take(60 74 82 59, n)\n   insert into trades values(timev, symv, pricev,qtyv)\n}\n\nwriteData(4);\n\ngetStreamEngineStat().TimeSeriesEngine;\ngetStreamEngineStat().CrossSectionalEngine;\n```\n"
    },
    "getAllCatalogs": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getAllCatalogs.html",
        "signatures": [
            {
                "full": "getAllCatalogs()",
                "name": "getAllCatalogs",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getAllCatalogs](https://docs.dolphindb.com/en/Functions/g/getAllCatalogs.html)\n\n#### Syntax\n\ngetAllCatalogs()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet all available catalogs.\n\n**Return value**: A STRING vector containing all catalog names.\n\n#### Examples\n\n```\ngetAllCatalogs()\n//Output: [\"catalog1\", \"catalog2\", \"catalog3\"]\n```\n\n"
    },
    "getAllDBGranularity": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getAllDBGranularity.html",
        "signatures": [
            {
                "full": "getAllDBGranularity()",
                "name": "getAllDBGranularity",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getAllDBGranularity](https://docs.dolphindb.com/en/Functions/g/getAllDBGranularity.html)\n\n#### Syntax\n\ngetAllDBGranularity()\n\n#### Arguments\n\nNone\n\n#### Details\n\nThis function can only be executed on a data node. It returns the chunk granularity of all databases on the current node.\n\n**Return value**: a dictionary, where\n\n* key: the database name;\n\n* value: the chunk granularity (TABLE or DATABASE). Refer to parameter *chunkGranularity* of function [database](https://docs.dolphindb.com/en/Functions/d/database.html) for details.\n\n#### Examples\n\n```\ngetAllDBGranularity()\n// output\n/valuedb->TABLE\n```\n\n"
    },
    "getAllDBs": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getAllDBs.html",
        "signatures": [
            {
                "full": "getAllDBs()",
                "name": "getAllDBs",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getAllDBs](https://docs.dolphindb.com/en/Functions/g/getAllDBs.html)\n\n\n\n#### Syntax\n\ngetAllDBs()\n\n#### Arguments\n\nNone\n\n#### Details\n\nThe function returns a dictionary containing the information of DFS databases on the current node. The keys are the database names and the values are the table names, and the following numbers indicates the number of the table in this database (starting from 1), whether it has been deleted (1 means it has been deleted).\n\nFrom version 1.30.21/2.00.9 onwards,\n\n* For an administrator or a non-admin user granted with DB\\_MANAGE privilege, the function returns all DFS databases on the current node;\n\n* Otherwise, the function returns DFS databases to which the user is granted with the DB\\_OWNER privilege.\n\n#### Examples\n\n```\ngetAllDBs();\n```\n\n| key     | value         |\n| ------- | ------------- |\n| /listdb | pt:2:0:pt\\_2; |\n"
    },
    "getAuditLog": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getAuditLog.html",
        "signatures": [
            {
                "full": "getAuditLog([userId], [startTime], [endTime], [opType])",
                "name": "getAuditLog",
                "parameters": [
                    {
                        "full": "[userId]",
                        "name": "userId",
                        "optional": true
                    },
                    {
                        "full": "[startTime]",
                        "name": "startTime",
                        "optional": true
                    },
                    {
                        "full": "[endTime]",
                        "name": "endTime",
                        "optional": true
                    },
                    {
                        "full": "[opType]",
                        "name": "opType",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getAuditLog](https://docs.dolphindb.com/en/Functions/g/getAuditLog.html)\n\n#### Syntax\n\ngetAuditLog(\\[userId], \\[startTime], \\[endTime], \\[opType])\n\n#### Arguments\n\n**userId** (optional) is a STRING scalar or vector indicating the user ID. If it is not provided (left as the default value of NULL), it means that DDL operations of all users are obtained.\n\n**startTime**(optional) is an integral scalar or temporal scalar of DATE, MONTH, DATETIME, TIMESTAMP, DATEHOUR, or NANOTIMESTAMP type. It is the start time of the log. The default value is 1970.01.01.\n\n**endTime**(optional) is an integral scalar or temporal scalar of DATE, MONTH, DATETIME, TIMESTAMP, DATEHOUR, or NANOTIMESTAMP type. It is the end time of the log. The default value is NULL, indicating the current time. Note that *endTime* must be greater than *startTime*.\n\n**opType**(optional) is a STRING scalar or vector indicating the operation type. If it is not provided (left as the default value of NULL), it means that all DDL operations are obtained. For *opType* options, see the descriptions in the table following this discussion of Arguments.\n\n#### Details\n\nObtain the DDL operations of specific *opType* executed by user *userId* between *startTime* and *endTime* (exclusive).\n\nIt returns a table containing the following columns:\n\n* userId: The ID of the user perform the operation.\n* startTime: The time when the transaction started.\n* endTime: The time when the transaction ended.\n* dbName: The database name.\n* tbName: The table name.\n* opType: The operation type.\n* opDetail: The detailed operation.\n* tid: The transaction ID.\n* cid: The commit ID.\n* remoteIp: The IP address of the client that submits the operation.\n* remotePort: The port of the client that submits the operation.\n\nThe corresponding *opDetail* of each *opType*are shown below:\n\n| opType                     | opDetail                                          | Description                                                                                                |\n| -------------------------- | ------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |\n| CREATE\\_DB                 |                                                   | create databases                                                                                           |\n| DROP\\_DB                   |                                                   | drop databases                                                                                             |\n| CREATE\\_TABLE              |                                                   | create dimension tables                                                                                    |\n| CREATE\\_PARTITIONED\\_TABLE |                                                   | create partitioned tables                                                                                  |\n| DROP\\_TABLE                |                                                   | drop tables                                                                                                |\n| DROP\\_PARTITION            | deletedPartitions=xxx                             | drop partitions                                                                                            |\n| RENAME\\_TABLE              | tableName=\\[xxx], newTableName=\\[xxx]             | rename tables                                                                                              |\n| SQL\\_DELETE                | script=\\[xxx], deletedRows=xxx                    | SQL delete                                                                                                 |\n| SQL\\_UPDATE                | script=\\[xxx], updatedRows=xxx                    | SQL update                                                                                                 |\n| UPSERT                     | insertedRows=xxx, updatedRows=xxx                 | update data with `upsert!`                                                                                 |\n| ADD\\_COLUMN                | colName=\\[xxx], colType=\\[xxx]                    | add columns                                                                                                |\n| SET\\_COLUMN\\_COMMENT       | colName=\\[xxx], colComment=\\[xxx]                 | set column comment                                                                                         |\n| TRUNCATE\\_TABLE            |                                                   | truncate tables                                                                                            |\n| RENAME\\_COLUMN             | colName=\\[xxx], newColName=\\[xxx]                 | rename columns                                                                                             |\n| REPLACE\\_COLUMN            | colName=\\[xxx], colType=\\[xxx], newColType=\\[xxx] | replace columns with `replaceColumn!`                                                                      |\n| DROP\\_COLUMN               | columnName=\\[xxx]                                 | drop columns                                                                                               |\n| ADD\\_RANGE\\_PARTITION      |                                                   | add RANGE partitions with `addRangePartitions`                                                             |\n| ADD\\_VALUE\\_PARTITION      |                                                   | add VALUE partitions with `addValuePartitions`                                                             |\n| APPEND                     | appendedRows=xxx                                  | append data to databases (with *atomic*='TRANS') or dimension tables of databases (with *atomic*='CHUNKS') |\n| APPEND\\_CHUNK\\_GRANULARITY | appendedRows=xxx                                  | append data to partitioned tables of databases (with *atomic*='CHUNKS')                                    |\n\n#### Examples\n\n```\n// Perform DDL operations\nlogin(\"admin\",\"123456\")\nn = 3\nid = rand(`st0001`st0002`st0003`st0004`st0005, n)\nsym = rand(`A`B, n)\ntradeDate = take(2022.01.01..2022.01.10, 3)\nval = 1..n\ndummyTb = table(id, sym,tradeDate, val)\n\ndbPath = \"dfs://auditTest\"\nif(existsDatabase(dbPath)){dropDatabase(dbPath)}\ndb = database(directory=dbPath, partitionType=VALUE, partitionScheme=2022.01.01..2022.01.05, engine='TSDB')\npt = createPartitionedTable(dbHandle=db, table=dummyTb, tableName=\"snap\", partitionColumns=`TradeDate, sortColumns=`id`tradeDate, keepDuplicates=ALL)\npt.append!(dummyTb)\n\nrenameTable(db, `snap, `snap_2)\n\n// Get the log of the above operations\ngetAuditLog()\n```\n\nOutput:\n\n| userName | startTime                     | endTime                       | dbName           | tbName | opType                     | opDetail                                   | tid | cid | remoteIp      |\n| -------- | ----------------------------- | ----------------------------- | ---------------- | ------ | -------------------------- | ------------------------------------------ | --- | --- | ------------- |\n| admin    | 2024.03.26 14:40:43.659196080 | 2024.03.26 14:40:43.676082419 | dfs\\://auditTest |        | CREATE\\_DB                 |                                            | 1   | 1   | 192.168.0.140 |\n| admin    | 2024.03.26 14:40:43.676154581 | 2024.03.26 14:40:43.687319577 | dfs\\://auditTest | snap   | CREATE\\_PARTITIONED\\_TABLE |                                            | 2   | 2   | 192.168.0.140 |\n| admin    | 2024.03.26 14:40:45.135000207 | 2024.03.26 14:40:45.160530442 | dfs\\://auditTest | snap   | RENAME\\_TABLE              | tableName=\\[snap], newTableName=\\[snap\\_2] | 4   | 4   | 192.168.0.14  |\n\n"
    },
    "getAuthenticatedUsers": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getAuthenticatedUsers.html",
        "signatures": [
            {
                "full": "getAuthenticatedUsers()",
                "name": "getAuthenticatedUsers",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getAuthenticatedUsers](https://docs.dolphindb.com/en/Functions/g/getAuthenticatedUsers.html)\n\n\n\n#### Syntax\n\ngetAuthenticatedUsers()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn a list of users who are currently logged in on all nodes.\n\n#### Examples\n\n```\ngetAuthenticatedUsers()\n// output\n[\"admin\",\"a1\",\"a3\",\"a2\",\"a4\"]\n```\n"
    },
    "getBackupList": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getBackupList.html",
        "signatures": [
            {
                "full": "getBackupList(backupDir, dbPath, tableName)",
                "name": "getBackupList",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [getBackupList](https://docs.dolphindb.com/en/Functions/g/getBackupList.html)\n\n\n\n#### Syntax\n\ngetBackupList(backupDir, dbPath, tableName)\n\n#### Arguments\n\n**backupDir** is a string indicating the directory where the backup is saved.\n\n**dbPath** is a string indicating the path of a distributed database.\n\n**tableName** is a string indicating a distributed table name.\n\n#### Details\n\nReturn a table with information about the backups of a DFS table. Each row of the table corresponds to a backed-up partition. The table contains the following columns:\n\n* chunkID: the chunk ID\n\n* chunkPath: the DFS path to database chunks\n\n* cid: the commit ID\n\n* rows: the number of records in a chunk\n\n* updateTime: the last update time\n\n#### Examples\n\n```\nif(existsDatabase(\"dfs://valuedb\")){\n   dropDatabase(\"dfs://valuedb\")\n}\nn=3000000\nmonth=take(2000.01M..2000.04M, n);\nx=1..n\nt=table(month,x);\n\n\ndb=database(\"dfs://valuedb\", VALUE, 2000.01M..2000.04M)\npt = db.createPartitionedTable(t, `pt, `month);\npt.append!(t);\nbackup(\"/home/DolphinDB/backup\",\"dfs://valuedb\",tableName=\"pt\");\ngetBackupList(\"/home/DolphinDB/backup\",\"dfs://valuedb\",\"pt\");\n```\n\n| chunkID                              | chunkPath                  | cid    | rows    | updateTime              |\n| ------------------------------------ | -------------------------- | ------ | ------- | ----------------------- |\n| 0061427c-4b24-e3b6-425c-c0e1553d3c35 | dfs\\://valuedb/200001M/b39 | 13,348 | 750,000 | 2022.09.21T15:45:50.931 |\n| dabbd90d-6001-f8a9-4d3e-8000d96eba68 | dfs\\://valuedb/200002M/b39 | 13,348 | 750,000 | 2022.09.21T15:45:50.931 |\n| f5c259b4-4be3-f385-46d4-1a1a2d224e9d | dfs\\://valuedb/200003M/b39 | 13,348 | 750,000 | 2022.09.21T15:45:50.931 |\n| 6ed58eb9-a2ae-6197-4f81-3186ca1e8b20 | dfs\\://valuedb/200004M/b39 | 13,348 | 750,000 | 2022.09.21T15:45:50.931 |\n"
    },
    "getBackupMeta": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getBackupMeta.html",
        "signatures": [
            {
                "full": "getBackupMeta(backupDir, dbPath, partition, tableName)",
                "name": "getBackupMeta",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "partition",
                        "name": "partition"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [getBackupMeta](https://docs.dolphindb.com/en/Functions/g/getBackupMeta.html)\n\n\n\n#### Syntax\n\ngetBackupMeta(backupDir, dbPath, partition, tableName)\n\n#### Arguments\n\n**backupDir** is a string indicating the directory where the backup is saved.\n\n**dbPath** is a string indicating the path of a DFS database. For example: \"dfs\\://demo\".\n\n**partition** is a string indicating the path of a partition under the database. For example: \"/20190101/GOOG\".\n\n**Note**: For versions 1.30.16/2.00.4 -1.30.18/2.00.6, if *chunkGranularity* is set to \"TABLE\" when creating the database, *partition* must include the physical index (which you can get with the `listTables` function) of the selected partition. For example, if the physical index of the \"/20190101/GOOG\" partition is 8, then specify partition as \"/20190101/GOOG/8\" to load its backup information.\n\n**tableName** is a string indicating a distributed table name.\n\n#### Details\n\nReturn a dictionary with information about the backup of a partition in a DFS table, which contains the following keys:\n\n* schema: the schema of the table\n\n* dfsPath: the DFS path to database chunks\n\n* rows: the number of records in a chunk\n\n* chunkID: the chunk ID\n\n* cid: the commit ID\n\n#### Examples\n\n```\ngetBackupMeta(\"/home/DolphinDB/backup\",\"dfs://valuedb\", \"/200001M\",\"pt\")\n// output\nschema->\nname  typeString typeInt extra comment\n----- ---------- ------- ----- -------\nmonth MONTH      7\nx     INT        4\n\ndfsPath->dfs://valuedb/200001M/b39\nrows->750000\nchunkID->0061427c-4b24-e3b6-425c-c0e1553d3c35\ncid->13349\n```\n"
    },
    "getBackupStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getBackupStatus.html",
        "signatures": [
            {
                "full": "getBackupStatus([userName])",
                "name": "getBackupStatus",
                "parameters": [
                    {
                        "full": "[userName]",
                        "name": "userName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getBackupStatus](https://docs.dolphindb.com/en/Functions/g/getBackupStatus.html)\n\n\n\n#### Syntax\n\ngetBackupStatus(\\[userName])\n\n#### Arguments\n\n**userName** is a string indicating the user name.\n\n#### Details\n\nGet the status of backup/restore tasks. Return a table where each row represents the information of a task.\n\n* userName: user name\n\n* type: backup/restore types.\n\n* BACKUP\\_BY\\_SQL/RESTORE\\_BY\\_SQL: backup/restore by SQL statement\n\n* BACKUP\\_BY\\_COPY\\_FILE/RESTORE\\_BY\\_COPY\\_FILE: backup/restore by copying files\n\n* startTime: when the task starts\n\n* dbName: database path\n\n* tableName: table name\n\n* totalPartitions: the number of partitions to be backed up/restored\n\n* completedPartitions: the number of partitions have been backed up/restored\n\n* percentComplete: the completion percentage\n\n* endTime: return the end time of a task if it has ended, otherwise return the estimated completion time\n\n* completed: whether the task is completed. Return 1 if it is completed, otherwise 0.\n\n**Note:**\n\n* The number of tasks generated for a backup statement is the same as the number of the backup partitions.\n\n* Administrators can check the tasks submitted by all users, or the tasks submitted by a specified user by specifying a *userName*.\n\n* When a non-administrator executes the function, return the status of backup/restore tasks submitted by the current user.\n\n#### Examples\n\n```\ngetBackupStatus()\n```\n\n| userName type | startTime                                      | dbName         | tableName | totalPartitions | completedPartitions | percentComplete | endTime                 | completed |\n| ------------- | ---------------------------------------------- | -------------- | --------- | --------------- | ------------------- | --------------- | ----------------------- | --------- |\n| u1            | BACKUP\\_BY\\_COPY\\_FILE 2022.09.21T17:18:04.264 | dfs\\://valuedb | pt        | 1               | 1                   | 100             | 2022.09.21T17:18:04.269 | 1         |\n| u1            | BACKUP 2022.09.21T17:13:04.344                 | dfs\\://valuedb | pt        | 4               | 4                   | 100             | 2022.09.21T17:13:04.413 | 1         |\n| u1            | BACKUP\\_BY\\_COPY\\_FILE 2022.09.21T17:18:04.264 | dfs\\://valuedb | pt1       | 1               | 1                   | 100             | 2022.09.21T17:18:04.265 | 1         |\n| admin         | BACKUP\\_BY\\_COPY\\_FILE 2022.09.21T16:47:42.798 | dfs\\://valuedb | pt        | 4               | 4                   | 100             | 2022.09.21T16:47:42.859 | 1         |\n| admin         | BACKUP\\_BY\\_COPY\\_FILE 2022.09.21T16:37:33.725 | dfs\\://valuedb | pt        | 4               | 4                   | 100             | 2022.09.21T16:37:33.790 | 1         |\n| admin         | BACKUP 2022.09.21T15:10:05.016                 | dfs\\://compoDB | pt2       | 10              | 10                  | 100             | 2022.09.21T15:10:05.075 | 1         |\n"
    },
    "getCachedSymbolBaseMemSize": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getCachedSymbolBaseMemSize.html",
        "signatures": [
            {
                "full": "getCachedSymbolBaseMemSize()",
                "name": "getCachedSymbolBaseMemSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getCachedSymbolBaseMemSize](https://docs.dolphindb.com/en/Functions/g/getCachedSymbolBaseMemSize.html)\n\n\n\n#### Syntax\n\ngetCachedSymbolBaseMemSize()\n\n#### Arguments\n\nNone\n\n#### Details\n\nObtain the cache size (in Bytes) of SYMBOL base (i.e., a dictionary that stores integers encoded from the data of SYMBOL type) of the storage engine.\n"
    },
    "getCacheEngineMemSize": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getCacheEngineMemSize.html",
        "signatures": [
            {
                "full": "getCacheEngineMemSize()",
                "name": "getCacheEngineMemSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getCacheEngineMemSize](https://docs.dolphindb.com/en/Functions/g/getCacheEngineMemSize.html)\n\n\n\n#### Syntax\n\ngetCacheEngineMemSize()\n\n#### Arguments\n\nNone\n\n#### Details\n\nObtain the memory status (in Byte) of the OLAP cache engine on the current node.\n\nIt returns a tuple:\n\n* The 1st element indicates the memory occupied by the cache engine;\n* The 2nd element indicates the memory occupied by the column files stored in the cache engine;\n* The 3rd element indicates the memory occupied by the column file pointers;\n* The 4th element indicates the maximum memory allocated to the cache engine.\n\n#### Examples\n\n```\nsetCacheEngineMemSize(0.4)\ngetCacheEngineMemSize()\n// output\n(0,0,0,429496729)\n```\n\nRelated function: [setCacheEngineMemSize](https://docs.dolphindb.com/en/Functions/s/setCacheEngineMemSize.html)\n"
    },
    "getCacheEngineStat": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getCacheEngineStat.html",
        "signatures": [
            {
                "full": "getCacheEngineStat()",
                "name": "getCacheEngineStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getCacheEngineStat](https://docs.dolphindb.com/en/Functions/g/getCacheEngineStat.html)\n\n\n\n#### Syntax\n\ngetCacheEngineStat()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the status of the OLAP cache engine on the current node. The function can only be called on the data node.\n\nReturn a table containing the following columns:\n\n* chunkId: the chunk ID\n\n* physicalName: the physical name of the table to which the chunk belongs\n\n* timeSinceLastWrite: the time elapsed (in milliseconds) since last write\n\n* cachedRowsOfCompletedTxn: the number of cached records of completed transactions\n\n* cachedRowsOfUncompletedTxn: the number of cached records of uncompleted transactions. Note: For each chunk, only the last transaction may not have been completed.\n\n* cachedMemOfCompletedTxn: the memory usage (in Bytes) of completed transactions\n\n* cachedMemOfUncompletedTxn: the memory usage (in Bytes) of uncompleted transactions\n\n* cachedTids: list of transaction IDs (tid)\n\n#### Examples\n\n```\ngetCacheEngineStat()\n```\n\n| chunkId                              | physicalName | timeSinceLastWrite | cachedRowsOfCompletedTxn | cachedRowsOfUncompletedTxn | cachedMemOfCompletedTxn | cachedMemOfUncompletedTxn | cachedTids |\n| ------------------------------------ | ------------ | ------------------ | ------------------------ | -------------------------- | ----------------------- | ------------------------- | ---------- |\n| e4558d3c-fa41-52b5-418b-94e26cb70a75 | pt\\_2        | 1056               | 222,386                  | 0                          | 3,558,176               | 0                         | 2052       |\n"
    },
    "getChunkPath": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getChunkPath.html",
        "signatures": [
            {
                "full": "getChunkPath(ds)",
                "name": "getChunkPath",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    }
                ]
            }
        ],
        "markdown": "### [getChunkPath](https://docs.dolphindb.com/en/Functions/g/getChunkPath.html)\n\n\n\n#### Syntax\n\ngetChunkPath(ds)\n\n#### Arguments\n\n**ds** is one or multiple data sources.\n\n#### Details\n\nReturn the paths of the chunks that the given data sources represent.\n\n#### Examples\n\n```\nif(existsDatabase(\"dfs://valuedb\")){\n  dropDatabase(\"dfs://valuedb\")\n}\n\ndb=database(\"dfs://valuedb\", VALUE, 1..10)\nn=1000000\nt=table(rand(1..10, n) as id, rand(100.0, n) as val)\npt=db.createPartitionedTable(t, `pt, `id).append!(t);\nds=sqlDS(<select * from pt where id in 1..3>)\ngetChunkPath(ds);\n\n// output\n[\"/valuedb/1\",\"/valuedb/2\",\"/valuedb/3\"]\n```\n"
    },
    "getChunksMeta": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getChunksMeta.html",
        "signatures": [
            {
                "full": "getChunksMeta([chunkPath], [top=1024])",
                "name": "getChunksMeta",
                "parameters": [
                    {
                        "full": "[chunkPath]",
                        "name": "chunkPath",
                        "optional": true
                    },
                    {
                        "full": "[top=1024]",
                        "name": "top",
                        "optional": true,
                        "default": "1024"
                    }
                ]
            }
        ],
        "markdown": "### [getChunksMeta](https://docs.dolphindb.com/en/Functions/g/getChunksMeta.html)\n\n\n\n#### Syntax\n\ngetChunksMeta(\\[chunkPath], \\[top=1024])\n\n#### Arguments\n\n**chunkPath** (optional) is the DFS path to one or multiple database chunks. It supports wildcards %, \\* and ?.\n\n**top** (optional) is a positive number indicating the maximum number of chunks in the output. The default value is 1024. If it is set to -1, the number of returned chunks is not limited.\n\n#### Details\n\nReturn metadata of specified database chunks on the local datanode. If *chunkPath* is not specified, return metadata of all database chunks on the local data node.\n\nIt returns a table containing the following columns:\n\n* site: Alias of the node\n* chunkId: The chunk ID\n* path: The path to database chunks\n* dfsPath: The DFS path to database chunks\n* type: The partition type. 0 for file chunk; 1 for tablet chunk.\n* flag: Flag for deletion.\n  * flag=0: The chunk can be queried and accessed.\n  * flag=1: The chunk has been logically marked as deleted and cannot be queried, but it has not been removed from disk.\n* size: The disk space (in bytes) occupied by the file chunk. It returns 0 for tablet chunks. Use the [getTabletsMeta](https://docs.dolphindb.com/en/Functions/g/getTabletsMeta.html) function to check the disk space tablet chunk occupies.\n* version: the version number\n* state: Chunk state.\n  * 0 (final state): Transaction has been completed or rolled back.\n  * 1 (before-commit state): The transaction is being executed on the chunk, such as writing or deleting data.\n  * 2 (after-commit state): The transaction has been committed.\n  * 3 (waiting-for-recovery state): When there is a version conflict or data corruption, this state occurs after the data node sends a recovery request to the controller and before the controller initiates the recovery.\n  * 4 (in-recovery state): This state occurs after the controller receives the recovery request and initiates the recovery. Upon the completion of recovery, the chunk reverts to the final state (0).\n* versionList: version list.\n* resolved: Whether the transaction of the chunk is in the commit phase that needs to be resolved. True indicates the transaction is in the resolution phase or needs to be resolved; False indicates the transaction has already completed the resolution phase or it is not required.\n\n#### Examples\n\n```\nif(existsDatabase(\"dfs://testDB\")){\n  dropDatabase(\"dfs://testDB\")\n}\ndb=database(\"dfs://testDB\", VALUE, 1..10)\n\nn=1000000\nt=table(rand(1..10, n) as id, rand(100.0, n) as x)\ndb.createPartitionedTable(t, `p1, `id).append!(t)\n\nn=2000000\nt=table(rand(1..10, n) as id, rand(100.0, n) as x, rand(100, n) as y)\ndb.createPartitionedTable(t, `pt2, `id).append!(t)\ngetChunksMeta(\"/testDB%\");\n```\n\n| site     | chunkId                              | path             | dfsPath         | type | flag | size | version | state | versionList     | resolved |\n| -------- | ------------------------------------ | ---------------- | --------------- | ---- | ---- | ---- | ------- | ----- | --------------- | -------- |\n| P2-node1 | 092d5e12-e595-6f9e-b049-83cba1716997 | /ssd/ssd5/jzVol… | /testDB/pt2.tbl | 0    | 0    | 49   | 1       | 0     | 2052:49;        | false    |\n| P2-node1 | d31e6b47-18f0-37a6-0146-45bf6e266c56 | /ssd/ssd6/jzVol… | /testDB/7       | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1… | false    |\n| P2-node1 | cd99d9ef-d864-f3bc-4945-f97017d43bf1 | /ssd/ssd5/jzVol… | /testDB/2       | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1… | false    |\n| P2-node1 | 8da4bea8-31d0-31b5-784f-67aa6339633d | /ssd/ssd5/jzVol… | /testDB/pt1.tbl | 0    | 0    | 41   | 1       | 0     | 2050:41;        | false    |\n| P2-node1 | dd5fc885-f6a6-bfae-8543-254f9fb92484 | /ssd/ssd6/jzVol… | /testDB/10      | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1… | false    |\n| P2-node1 | 4b8aaed1-2dd6-acb7-5148-4add878c3b33 | /ssd/ssd6/jzVol… | /testDB/domain  | 0    | 0    | 88   | 1       | 0     | 2049:88;        | false    |\n| P2-node1 | 28cb59ec-185a-0ebf-a849-267e769936af | /ssd/ssd6/jzVol… | /testDB/8       | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1… | false    |\n| P2-node1 | b2facbd2-e301-428f-f94f-8579023f78af | /ssd/ssd6/jzVol… | /testDB/3       | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1… | false    |\n| P2-node1 | 8bec6445-bc6d-3693-7f46-d1bcdd350182 | /ssd/ssd6/jzVol… | /testDB/5       | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1… | false    |\n"
    },
    "getClusterChunksStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getClusterChunksStatus.html",
        "signatures": [
            {
                "full": "getClusterChunksStatus()",
                "name": "getClusterChunksStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getClusterChunksStatus](https://docs.dolphindb.com/en/Functions/g/getClusterChunksStatus.html)\n\n#### Syntax\n\ngetClusterChunksStatus()\n\n#### Details\n\nThis function obtains the metadata about all database chunks (file chunks and tablet chunks) on the data nodes in a cluster. It can be executed only on a controller. It returns a table containing the following columns:\n\n* chunkId: the chunk ID.\n\n* file: the chunk path.\n\n* size: The disk space occupied by the file chunk (in Bytes). Return 0 for a tablet chunk. Use [getTabletsMeta](https://docs.dolphindb.com/en/Functions/g/getTabletsMeta.html) to check the disk usage of a tablet chunk.\n\n* version: the version number of the current chunk.\n\n* vcLength: length of the version chain.\n\n* versionChain: version chain of the chunk, e.g. \"18441:76:1:346 -> 18441:0:0:346 -> \", where\n\n  | 18441          | 76         | 1              | 346               |\n  | -------------- | ---------- | -------------- | ----------------- |\n  | cid (chunk ID) | chunk size | version number | sid (snapshot ID) |\n\n* state: the chunk state. It can be\n\n  * CONSTRUCTING: in transaction;\n\n  * RECOVERING: recovering;\n\n  * COMPLETE: transaction completed.\n\n* replicas: the replica information of the chunk, e.g., \"local8848:1:0:false:1671075776643574000\", where\n\n  | local8848                               | 1              | 0                                | false                                  | 1671075776643574000                     |\n  | --------------------------------------- | -------------- | -------------------------------- | -------------------------------------- | --------------------------------------- |\n  | node alias where the replica is located | version number | whether the replica is corrupted | whether a transaction is in resolution | the latest report timestamp on the node |\n\n* replicaCount: the number of replica(s).\n\n* lastUpdated: the timestamp for last update. Note that lastUpdated column is supported since version 1.30.20/2.00.1. For a chunk created before, it returns a NULL value.\n\n* permission: the chunk permission. It can be READ\\_WRITE (default), READ\\_ONLY, WRITE\\_ONLY, and UNKNOWN. Chunks that are being transferred or stored in S3 are READ\\_ONLY.\n\nFor READ\\_ONLY chunks:\n\n* Data cannot be appended or updated. Only drop operations can be performed to delete records. Transaction is supported in the READ\\_ONLY chunks (except for those stored in S3).\n* Operations such as recovery and rebalance cannot be performed.\n* Level files in the TSDB engine cannot be merged.\n\n#### Examples\n\n```\nrpc(getControllerAlias(), getClusterChunksStatus);\n```\n\n| chunkId           | file            | size | version | vcLength | versionChain      | state    | replicas          | replicaCount | lastUpdated             | permission  |\n| ----------------- | --------------- | ---- | ------- | -------- | ----------------- | -------- | ----------------- | ------------ | ----------------------- | ----------- |\n| 092d5e12-e595-6f… | /testDB/pt2.tbl | 49   | 1       | 1        | 2052:49:1 ->      | COMPLETE | P1-node1:1:0,P2-… | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n| 42936e31-8be0-fa… | /testDB/9/i     | 0    | 2       | 2        | 2053:0:2 -> 2051… | COMPLETE | P3-node1:2:0,P1-… | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n| d31e6b47-18f0-37… | /testDB/7/i     | 0    | 2       | 2        | 2053:0:2 -> 2051… | COMPLETE | P1-node1:2:0,P2-… | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n| 647a5fd6-cd85-3b… | /testDB/6/i     | 0    | 2       | 2        | 2053:0:2 -> 2051… | COMPLETE | P1-node1:2:0,P3-… | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n| 8bec6445-bc6d-36… | /testDB/5/i     | 0    | 2       | 2        | 2053:0:2 -> 2051… | COMPLETE | P2-node1:2:0,P3-… | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n| ca690ba5-be73-a6… | /testDB/4/i     | 0    | 2       | 2        | 2053:0:2 -> 2051… | COMPLETE | P3-node1:2:0,P1-… | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n\n"
    },
    "getClusterDFSDatabases": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getClusterDFSDatabases.html",
        "signatures": [
            {
                "full": "getClusterDFSDatabases()",
                "name": "getClusterDFSDatabases",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getClusterDFSDatabases](https://docs.dolphindb.com/en/Functions/g/getClusterDFSDatabases.html)\n\n\n\n#### Syntax\n\ngetClusterDFSDatabases()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn a list of the DFS databases in the cluster.\n\n#### Examples\n\n```\ngetClusterDFSDatabases()\n// output\n[\"dfs://demohash\",\"dfs://myDataYesDB\",\"dfs://testDB\"]\n```\n"
    },
    "getClusterDFSTables": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getClusterDFSTables.html",
        "signatures": [
            {
                "full": "getClusterDFSTables()",
                "name": "getClusterDFSTables",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getClusterDFSTables](https://docs.dolphindb.com/en/Functions/g/getClusterDFSTables.html)\n\n\n\n#### Syntax\n\ngetClusterDFSTables()\n\n#### Arguments\n\nNone\n\n#### Details\n\nThe function returns a vector that lists DFS tables in the cluster.\n\nFrom version 1.30.212.00.9 onwards,\n\n* For an administrator, the function returns all DFS tables in the cluster;\n\n* For a non-admin user, the function returns DFS tables that can be accessed by the user, i.e., the user has at least one of the following privileges: DB\\_OWNER, TABLE\\_READ, TABLE\\_WRITE, TABLE\\_INSERT, TABLE\\_UPDATE, TABLE\\_DELETE, DB\\_READ, DB\\_WRITE, DB\\_INSERT, DB\\_UPDATE, and DB\\_DELETE.\n\nStarting from version 2.00.10.2, this function returns all DFS tables created by the user regardless of the table permissions.\n\nStarting from version 1.30.23, this function returns all DFS tables created by the user regardless of the table permissions.\n\n#### Examples\n\n```\ngetClusterDFSTables()\n// output\n[\"dfs://demohash/pt\",\"dfs://myDataYesDB/tick\",\"dfs://testDB/pt1\",\"dfs://testDB/pt2\"]\n```\n"
    },
    "getClusterPerf": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getClusterPerf.html",
        "signatures": [
            {
                "full": "getClusterPerf([includeMaster=false])",
                "name": "getClusterPerf",
                "parameters": [
                    {
                        "full": "[includeMaster=false]",
                        "name": "includeMaster",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [getClusterPerf](https://docs.dolphindb.com/en/Functions/g/getClusterPerf.html)\n\n#### Syntax\n\ngetClusterPerf(\\[includeMaster=false])\n\n#### Arguments\n\n**includeMaster** (optional) indicates whether to include the controller information in the output.\n\n#### Details\n\nReturns configurations and performance measures for each node in the cluster. It can only be executed on the controller. It returns a table with the following columns:\n\n| Field                 | Description                                                                                                                                                                 | Unit      |\n| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------- |\n| host                  | Host name                                                                                                                                                                   |           |\n| port                  | Port number                                                                                                                                                                 |           |\n| site                  | (LAN) site                                                                                                                                                                  |           |\n| mode                  | Node type or deployment mode. 0: data node;1: agent; 2: controller; 3: standalone mode; 4: compute node.                                                                    |           |\n| state                 | A Boolean value indicating whether the node is alive.                                                                                                                       |           |\n| agentSite             | Agent information of the current node.                                                                                                                                      |           |\n| maxConnections        | The maximum number of connections (from GUI, API, other nodes, etc.) to the local node.                                                                                     |           |\n| maxMemSize            | The maximum memory allocated to DolphinDB.                                                                                                                                  | GB        |\n| workerNum             | The size of worker pool for regular interactive jobs. The default value is the number of CPU cores                                                                          |           |\n| executorNum           | The number of local executors. The default value is the number of CPU cores - 1                                                                                             |           |\n| connectionNum         | The number of connections to a local node. Note that the return value for the agent is a random number.                                                                     |           |\n| name                  | Node alias                                                                                                                                                                  |           |\n| memoryUsed            | Memory used by the node                                                                                                                                                     | Bytes     |\n| memoryAlloc           | Total memory allocated to DolphinDB on the node.                                                                                                                            | Bytes     |\n| cpuUsage              | CPU usage                                                                                                                                                                   |           |\n| avgLoad               | Average CPU load                                                                                                                                                            |           |\n| maxRunningQueryTime   | The maximum elapsed time of the queries that are currently running.                                                                                                         | ns        |\n| runningJobs           | The number of running jobs                                                                                                                                                  |           |\n| queuedJobs            | The number of jobs in queue                                                                                                                                                 |           |\n| runningTasks          | The number of running tasks                                                                                                                                                 |           |\n| queuedTasks           | The number of tasks in queue                                                                                                                                                |           |\n| jobLoad               | CPU load of a job                                                                                                                                                           |           |\n| diskCapacity          | Disk capacity                                                                                                                                                               | Bytes     |\n| diskFreeSpace         | Available disk space                                                                                                                                                        | Bytes     |\n| diskFreeSpaceRatio    | Available space ratio                                                                                                                                                       |           |\n| diskWriteRate         | The rate at which data are written to disk.                                                                                                                                 | Bytes/sec |\n| diskReadRate          | The rate at which data are read from disk.                                                                                                                                  | Bytes/sec |\n| lastMinuteWriteVolume | The data written to disk in the last minute.                                                                                                                                | Bytes     |\n| lastMinuteReadVolume  | The data read from disk in the last minute.                                                                                                                                 | Bytes     |\n| networkSendRate       | The rate at which data are sent.                                                                                                                                            | Bytes/sec |\n| networkRecvRate       | The rate at which data are received.                                                                                                                                        | Bytes/sec |\n| lastMinuteNetworkSend | Data sent in the last minute                                                                                                                                                | Byte      |\n| lastMinuteNetworkRecv | Data received in the last minute                                                                                                                                            | Byte      |\n| publicName            | Returns publicName for a controller configured with publicName;Otherwise returns the MAC (Media Access Control) Address of the server for a controller, data node or agent. |           |\n| lastMsgLatency        | Latency of the last received message                                                                                                                                        | ns        |\n| cumMsgLatency         | Cumulative latency of the messages                                                                                                                                          | ns        |\n| isLeader              | Whether it is the leader of a raft group. It only returns for a raft group of controllers. Note that it will return NULL for a raft group with crashed node.                |           |\n\nThe following measures are displayed only when the configuration parameter *perfMonitoring* is set to 1.\n\n| Field               | Description                                                      | Unit |\n| ------------------- | ---------------------------------------------------------------- | ---- |\n| medLast10QueryTime  | The median execution time of the previous 10 finished queries.   | ns   |\n| maxLast10QueryTime  | The maximum execution time of the previous 10 finished queries.  | ns   |\n| medLast100QueryTime | The median execution time of the previous 100 finished queries.  | ns   |\n| maxLast100QueryTime | The maximum execution time of the previous 100 finished queries. | ns   |\n\n#### Examples\n\n```\nrpc(getControllerAlias(), getClusterPerf,true)\n```\n\n| host         | port  | site                        | mode | state | agentSite                | maxConnections | maxMemSize | workerNum | executorNum | connectionNum | name      | memoryUsed | memoryAlloc | cpuUsage | avgLoad | medLast10QueryTime | maxLast10QueryTime | medLast100QueryTime | maxLast100QueryTime | maxRunningQueryTime | runningJobs | queuedJobs | runningTasks | queuedTasks | jobLoad | diskCapacity      | diskFreeSpace   | diskFreeSpaceRatio | diskWriteRate | diskReadRate | lastMinuteWriteVolume | lastMinuteReadVolume | networkSendRate | networkRecvRate | lastMinuteNetworkSend | lastMinuteNetworkRecv | publicName | lastMsgLatency | cumMsgLatency |\n| ------------ | ----- | --------------------------- | ---- | ----- | ------------------------ | -------------- | ---------- | --------- | ----------- | ------------- | --------- | ---------- | ----------- | -------- | ------- | ------------------ | ------------------ | ------------------- | ------------------- | ------------------- | ----------- | ---------- | ------------ | ----------- | ------- | ----------------- | --------------- | ------------------ | ------------- | ------------ | --------------------- | -------------------- | --------------- | --------------- | --------------------- | --------------------- | ---------- | -------------- | ------------- |\n| 192.168.1.48 | 8,894 | 192.168.1.48:8894:datanode3 | 0    | 1     | 192.168.1.48:8891:agent1 | 192            | 16         | 16        | 15          | 4             | datanode3 | 9,073,704  | 12,648,448  | 1.0309   | 0.0103  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 1,000,068,870,144 | 941,631,864,832 | 0.9416             | 0             | 0            | 1,058 0               | 0                    | 0               | 0               | 0                     | 0                     | 127.0.0.1  | 0              | 0             |\n| 192.168.1.48 | 8,895 | 192.168.1.48:8895:datanode4 | 0    | 1     | 192.168.1.48:8891:agent1 | 192            | 16         | 16        | 15          | 4             | datanode4 | 8,862,912  | 9,502,720   | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 1,000,068,870,144 | 941,631,864,832 | 0.9416             | 0             | 0            | 1,058 0               | 0                    | 0               | 0               | 0                     | 0                     | 127.0.0.1  | 0              | 0             |\n| 192.168.1.48 | 8,891 | 192.168.1.48:8891:agent1    | 1    | 1     | 192.168.1.48:8891:agent1 | 32             | 12         | 4         | 15          | 0             | agent1    | 0          | 0           | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                 | 0               | 0                  | 0             | 0            | 0                     | 0                    | 0               | 0               | 0                     | 0                     |            | 0              | 0             |\n| 192.168.1.48 | 8,892 | 192.168.1.48:8892:datanode1 | 0    | 1     | 192.168.1.48:8891:agent1 | 192            | 16         | 16        | 15          | 4             | datanode1 | 8,976,200  | 10,551,296  | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 1,000,068,870,144 | 941,631,864,832 | 0.9416             | 0             | 0            | 1,058 0               | 0                    | 0               | 0               | 0                     | 0                     | 127.0.0.1  | 0              | 0             |\n| 192.168.1.48 | 8,893 | 192.168.1.48:8893:datanode2 | 0    | 1     | 192.168.1.48:8891:agent1 | 192            | 16         | 16        | 15          | 5             | datanode2 | 9,290,232  | 11,599,872  | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 1,000,068,870,144 | 941,631,864,832 | 0.9416             | 0             | 0            | 1,058 0               | 0                    | 0               | 0               | 0                     | 0                     | 127.0.0.1  | 0              | 0             |\n\n```\nrpc(getControllerAlias(), getClusterPerf).keys()\n[\"host\",\"port\",\"site\",\"mode\",\"state\",\"agentSite\",\"maxConnections\",\"maxMemSize\",\"workerNum\",\"executorNum\",\"connectionNum\",\"name\",\"memoryUsed\",\"memoryAlloc\",\"cpuUsage\",\"avgLoad\",\"medLast10QueryTime\",\"maxLast10QueryTime\",\"medLast100QueryTime\",\"maxLast100QueryTime\",\"maxRunningQueryTime\",\"runningJobs\",\"queuedJobs\",\"runningTasks\",\"queuedTasks\",\"jobLoad\",\"diskCapacity\",\"diskFreeSpace\",\"diskFreeSpaceRatio\",\"diskWriteRate\",\"diskReadRate\",\"lastMinuteWriteVolume\",\"lastMinuteReadVolume\",\"networkSendRate\",\"networkRecvRate\",\"lastMinuteNetworkSend\",\"lastMinuteNetworkRecv\",\"publicName\",\"lastMsgLatency\",\"cumMsgLatency\"]\n```\n\nFor a high-availability cluster:\n\n```\nrpc(getControllerAlias(), getClusterPerf)\n```\n\n| host           | port   | site                                    | mode | state | agentSite                            | maxConnections | maxMemSize | workerNum | executorNum | connectionNum | name               | memoryUsed | memoryAlloc | cpuUsage | avgLoad | medLast10QueryTime | maxLast10QueryTime | medLast100QueryTime | maxLast100QueryTime | maxRunningQueryTime | runningJobs | queuedJobs | runningTasks | queuedTasks | jobLoad | diskCapacity       | diskFreeSpace      | diskFreeSpaceRatio | diskWriteRate | diskReadRate | lastMinuteWriteVolume | lastMinuteReadVolume | networkSendRate | networkRecvRate | lastMinuteNetworkSend | lastMinuteNetworkRecv | publicName                                    | lastMsgLatency | cumMsgLatency | isLeader |\n| -------------- | ------ | --------------------------------------- | ---- | ----- | ------------------------------------ | -------------- | ---------- | --------- | ----------- | ------------- | ------------------ | ---------- | ----------- | -------- | ------- | ------------------ | ------------------ | ------------------- | ------------------- | ------------------- | ----------- | ---------- | ------------ | ----------- | ------- | ------------------ | ------------------ | ------------------ | ------------- | ------------ | --------------------- | -------------------- | --------------- | --------------- | --------------------- | --------------------- | --------------------------------------------- | -------------- | ------------- | -------- |\n| 192.168.100.10 | 17,000 | 192.168.100.10:17000:master3            | 2    | 1     |                                      | 512            | 16         | 64        | 3           | 1             | master3            | 23,449,272 | 24,133,632  | 0.7788   | 0.0037  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 4,658        | 2,736                 | 102,468              | 59,193          | 78,351          | 8,012,182             | 2,378,846             | 192.198.1.10;172.17.0.1;10.244.5.0;10.244.5.1 | 0              | 0             | false    |\n| 192.168.100.11 | 17,000 | 192.168.100.11:17000:master2            | 2    | 1     |                                      | 512            | 16         | 64        | 3           | 2             | master2            | 23,527,872 | 24,133,632  | 11.5625  | 0.3219  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 4,670        | 2,785                 | 116,733              | 62,402          | 56,160          | 1,366,293             | 1,398,238             | 192.198.1.11;172.17.0.1;10.244.4.0;10.244.4.1 | 0              | 0             | false    |\n| 192.168.100.12 | 17,000 | 192.168.100.12:17000:master1            | 2    | 1     |                                      | 512            | 16         | 64        | 3           | 20            | master1            | 25,002,792 | 46,538,752  | 14.0406  | 0.1136  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 4,671        | 13,546,528            | 19,964,606           | 53,206          | 56,891          | 22,543,771            | 8,226,278             | 192.198.1.12;172.17.0.1;10.244.3.0;10.244.3.1 | 0              | 0             | true     |\n| 192.168.100.12 | 17,102 | 192.168.100.12:17102:server19-datanode1 | 0    | 1     | 192.168.100.12:17101:server19-agent1 | 254            | 120        | 5         | 31          | 1             | server19-datanode1 | 23,118,960 | 24,133,632  | 13.928   | 0.1136  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 17,790,585,659,392 | 16,826,060,464,128 | 0.9458             | 0             | 4,687        | 1,289                 | 23,477               | 44,197          | 55,104          | 352,258               | 6,163,159             | 192.198.1.12;172.17.0.1;10.244.3.0;10.244.3.1 | 0              | 0             |          |\n| 192.168.100.11 | 17,102 | 192.168.100.11:17102:server18-datanode1 | 0    | 1     | 192.168.100.11:17101:server18-agent1 | 254            | 120        | 5         | 31          | 1             | server18-datanode1 | 23,111,912 | 24,133,632  | 14.1066  | 0.3219  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 17,790,585,659,392 | 16,714,392,956,928 | 0.9395             | 0             | 4,698        | 1,989                 | 23,530               | 40,896          | 50,706          | 243,008               | 250,727               | 192.198.1.11;172.17.0.1;10.244.4.0;10.244.4.1 | 0              | 0             |          |\n| 192.168.100.11 | 17,101 | 192.168.100.11:17101:server18-agent1    | 1    | 1     | 192.168.100.11:17101:server18-agent1 | 304            | 4          | 4         | 63          | 0             | server18-agent1    | 0          | 0           | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 0            | 0                     | 0                    | 0               | 0               | 0                     | 0                     | 192.198.1.11;172.17.0.1;10.244.4.0;10.244.4.1 | 0              | 0             |          |\n| 192.168.100.10 | 17,102 | 192.168.100.10:17102:server17-datanode1 | 0    | 1     | 192.168.100.10:17101:server17-agent1 | 254            | 120        | 5         | 31          | 1             | server17-datanode1 | 40,872,496 | 52,445,184  | 0.7788   | 0.0037  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 53,783,736,754,176 | 50,336,934,432,768 | 0.9359             | 0             | 4,699        | 13,900,218            | 18,835               | 118,935         | 109,862         | 6,170,512             | 408,018               | 192.198.1.10;172.17.0.1;10.244.5.0;10.244.5.1 | 0              | 0             |          |\n| 192.168.100.12 | 17,101 | 192.168.100.12:17101:server19-agent1    | 1    | 1     | 192.168.100.12:17101:server19-agent1 | 304            | 4          | 4         | 63          | 0             | server19-agent1    | 0          | 0           | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 0            | 0                     | 0                    | 0               | 0               | 0                     | 0                     | 192.198.1.12;172.17.0.1;10.244.3.0;10.244.3.1 | 0              | 0             |          |\n| 192.168.100.10 | 17,101 | 192.168.100.10:17101:server17-agent1    | 1    | 1     | 192.168.100.10:17101:server17-agent1 | 304            | 4          | 4         | 63          | 0             | server17-agent1    | 0          | 0           | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 0            | 0                     | 0                    | 0               | 0               | 0                     | 0                     | 192.198.1.10;172.17.0.1;10.244.5.0;10.244.5.1 | 0              | 0             |          |\n\n"
    },
    "getCompletedQueries": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getCompletedQueries.html",
        "signatures": [
            {
                "full": "getCompletedQueries([top])",
                "name": "getCompletedQueries",
                "parameters": [
                    {
                        "full": "[top]",
                        "name": "top",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getCompletedQueries](https://docs.dolphindb.com/en/Functions/g/getCompletedQueries.html)\n\n\n\n#### Syntax\n\ngetCompletedQueries(\\[top])\n\n#### Arguments\n\n**top** (optional) is a positive integer. The default value is 10.\n\n#### Details\n\nReturn descriptive information about the most recently finished *top* SQL queries on DFS databases at the local node. It returns a table with the following columns:\n\n| Name      | Meaning                                                                                                                                              |\n| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| userID    | the user ID                                                                                                                                          |\n| sessionID | the session ID                                                                                                                                       |\n| jobID     | the job ID                                                                                                                                           |\n| rootID    | the root job ID                                                                                                                                      |\n| level     | the level of jobs. The root job starts from level 0, the tasks broken down from the root job are marked as level 1, and subtasks level 2, and so on. |\n| startTime | the start time of a query (of NANOTIMESTAMP type)                                                                                                    |\n| endTime   | the end time of a query (of NANOTIMESTAMP type)                                                                                                      |\n| jobDesc   | the job description                                                                                                                                  |\n| errorMsg  | error messages                                                                                                                                       |\n| remoteIP  | the IP address of the client that initiates a query                                                                                                  |\n\nOnly administrators can use this function. Before using the function, set the configuration parameter *perfMonitoring*=1 to enable performance monitoring.\n\n#### Examples\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x)\ndb=database(\"dfs://rangedb16\", RANGE,  0 5 10)\npt = db.createPartitionedTable(t, `pt, `ID)\npt.append!(t)\nt1 = select count(x) from pt;\nt2 = select * from pt where ID=1;\nt3 = select * from pt where ID=5;\n\ngetCompletedQueries()\n```\n\n| userID | sessionID  | jobID                                | rootID                               | level | startTime                     | endTime                       | jobDesc                             | errorMsg | remoteIP  |\n| ------ | ---------- | ------------------------------------ | ------------------------------------ | ----- | ----------------------------- | ----------------------------- | ----------------------------------- | -------- | --------- |\n| admin  | 1166953221 | 4be0f403-a62d-7bae-4ded-43938cc2b4e9 | 4be0f403-a62d-7bae-4ded-43938cc2b4e9 | 0     | 2021.06.28T18:05:34.366483000 | 2021.06.28T18:05:34.372467000 | select ID,x from pt where ID == 1   |          | 127.0.0.1 |\n| admin  | 1166953221 | 9e9132c5-60c2-b3ab-41da-039ad2dcb6ff | 4be0f403-a62d-7bae-4ded-43938cc2b4e9 | 0     | 2021.06.28T18:05:34.366483000 | 2021.06.28T18:05:34.372467000 | select ID,x from pt where ID == 5   |          | 127.0.0.1 |\n| admin  | 1166953221 | 98275891-9c9b-948e-425c-6c3083713d84 | 98275891-9c9b-948e-425c-6c3083713d84 | 0     | 2021.06.28T18:05:34.344272000 | 2021.06.28T18:05:34.359201000 | select count(x) as count\\_x from pt |          | 127.0.0.1 |\n\n```\ngetCompletedQueries().keys()\n// output\n[\"userID\",\"sessionID\",\"jobID\",\"rootID\",\"level\",\"startTime\",\"endTime\",\"jobDesc\",\"errorMsg\"]\n\ngetCompletedQueries().ErrorMsg\n// output\n[,,]\n\ngetCompletedQueries().jobDesc\n// output\n[\"select ID,x from pt where ID == 5\",\"select ID,x from pt where ID == 1\",\"select count(x) as count_x from pt\"]\n```\n"
    },
    "getConfig": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getConfig.html",
        "signatures": [
            {
                "full": "getConfigure([key])",
                "name": "getConfigure",
                "parameters": [
                    {
                        "full": "[key]",
                        "name": "key",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getConfig](https://docs.dolphindb.com/en/Functions/g/getConfig.html)\n\n\n\n#### Syntax\n\ngetConfigure(\\[key])\n\n#### Arguments\n\n**key** (optional) is a string indicating the name of a configuration parameter.\n\n#### Details\n\n* If *key* is not specified, return a dictionary with all configuration information of the system.\n\n* If *key* is a valid configuration parameter, return a scalar or vector indicating the value(s) of the parameter.\n\n* If *key* is not a configuration parameter, return NULL value.\n\nFor more information on the returned configuration parameters, see [Configuration](https://docs.dolphindb.com/en/Database/Configuration/configuration.html) .\n"
    },
    "getConnections": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getConnections.html",
        "signatures": [
            {
                "full": "getConnections()",
                "name": "getConnections",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getConnections](https://docs.dolphindb.com/en/Functions/g/getConnections.html)\n\n\n\n#### Syntax\n\ngetConnections()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn information about all network connections on the local node. It can be executed on all nodes.\n\nThe result has three columns:\n\n* The first column (server) is the IP address and port number of the local node.\n\n* The second column (client) is the IP address and port number of a remote node.\n\n* The third column (startTime) is timestamp when the connection was established.\n\n#### Examples\n\n```\ngetConnections()\n```\n\n| server         | client          | startTime               |\n| -------------- | --------------- | ----------------------- |\n| localhost:8848 | 127.0.0.1:62546 | 2021.09.02T16:50:57.814 |\n| localhost:8848 | 127.0.0.1:63081 | 2021.09.02T10:50:16.350 |\n| localhost:8848 | 127.0.0.1:57559 | 2021.09.02T16:50:57.736 |\n"
    },
    "getConsoleJobs": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getConsoleJobs.html",
        "signatures": [
            {
                "full": "getConsoleJobs()",
                "name": "getConsoleJobs",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getConsoleJobs](https://docs.dolphindb.com/en/Functions/g/getConsoleJobs.html)\n\n\n\n#### Syntax\n\ngetConsoleJobs()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn the descriptive information about the running interactive jobs of the local node.\n\nIt returns a table with the following columns:\n\n| Name                | Meaning                                                                                                                                                      |\n| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| node                | the alias of the local node                                                                                                                                  |\n| userID              | the user ID                                                                                                                                                  |\n| rootJobId           | the root job ID                                                                                                                                              |\n| jobType             | the job type                                                                                                                                                 |\n| desc                | the job description                                                                                                                                          |\n| priority            | priority of the job which is marked as integers ranging from 0 to 9                                                                                          |\n| parallelism         | the parallelism, i.e., the maximum number of jobs that can run in parallel                                                                                   |\n| receiveTime         | the time when a job is received by the node                                                                                                                  |\n| sessionId           | the ID of the session where the job is submitted                                                                                                             |\n| remoteIP            | the IP address of the client where the job is submitted                                                                                                      |\n| remotePort          | the port number of the client where the job is submitted                                                                                                     |\n| totalTasks          | the total tasks broken down from the job                                                                                                                     |\n| finishedTasks       | the number of finished tasks                                                                                                                                 |\n| runningTask         | the number of running tasks                                                                                                                                  |\n| firstTaskStartTime  | the start time of the first task                                                                                                                             |\n| latestTaskStartTime | the start time of the latest task                                                                                                                            |\n| queue               | the task queues: The value can be normal queue (for level 0 workers); web queue (for web workers); local task queue (for level 1-5 workers); batch job queue |\n\n#### Examples\n\n```\ngetConsoleJobs()\n```\n\n| node     | userID | rootJobId                            | jobType | desc             | priority | parallelism | receiveTime             | sessionId  | remoteIP  | remotePort | totalTasks | finishedTasks | runningTask | firstTaskStartTime      | latestTaskStartTime     | queue        |\n| -------- | ------ | ------------------------------------ | ------- | ---------------- | -------- | ----------- | ----------------------- | ---------- | --------- | ---------- | ---------- | ------------- | ----------- | ----------------------- | ----------------------- | ------------ |\n| P2-node1 | admin  | 26681f9c-f914-81ae-47dd-8b8e6e106c48 | script  | getConsoleJobs() | 4        | 2           | 2022.01.05T11:05:06.778 | 1823289176 | 127.0.0.1 | 50595      | 1          | 0             | 1           | 2022.01.05T11:05:06.778 | 2022.01.05T11:05:06.778 | normal queue |\n"
    },
    "getControllerAlias": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getControllerAlias.html",
        "signatures": [
            {
                "full": "getControllerAlias()",
                "name": "getControllerAlias",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getControllerAlias](https://docs.dolphindb.com/en/Functions/g/getControllerAlias.html)\n\n\n\n#### Syntax\n\ngetControllerAlias()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the alias of the controller. The controller alias is specified by *localSite* in the configuration file *controller.cfg* by default.\n\n#### Examples\n\n```language-python\ngetControllerAlias();\n// output\nmaster\n```\n\nRelated: [getNodeAlias](https://docs.dolphindb.com/en/Functions/g/getNodeAlias.html)\n"
    },
    "getControllerElectionTick": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getControllerElectionTick.html",
        "signatures": [
            {
                "full": "getControllerElectionTick()",
                "name": "getControllerElectionTick",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getControllerElectionTick](https://docs.dolphindb.com/en/Functions/g/getControllerElectionTick.html)\n\n\n\n#### Syntax\n\ngetControllerElectionTick()\n\n#### Arguments\n\nNone\n\n#### Details\n\nObtain the election tick in the raft group composed of controllers. The election tick is specified by the parameter *tickCount* of command [setRaftElectionTick](https://docs.dolphindb.com/en/Functions/s/setRaftElectionTick.html) or the configuration parameter *raftElectionTick*.\n\nRelated Functions: [setRaftElectionTick](https://docs.dolphindb.com/en/Functions/s/setRaftElectionTick.html), [getRaftElectionTick](https://docs.dolphindb.com/en/Functions/g/getRaftElectionTick.html)\n"
    },
    "getCurrentCatalog": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getCurrentCatalog.html",
        "signatures": [
            {
                "full": "getCurrentCatalog()",
                "name": "getCurrentCatalog",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getCurrentCatalog](https://docs.dolphindb.com/en/Functions/g/getCurrentCatalog.html)\n\n#### Syntax\n\ngetCurrentCatalog()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the catalog used for the current session.\n\n**Return value**: A STRING scalar.\n\n#### Examples\n\n```\nuse CATALOG cat1;\nselect * from db1.table1 \ngetCurrentCatalog() \n// Output: \"cat1\"\n```\n\n"
    },
    "getCurrentSessionAndUser": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getCurrentSessionAndUser.html",
        "signatures": [
            {
                "full": "getCurrentSessionAndUser()",
                "name": "getCurrentSessionAndUser",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getCurrentSessionAndUser](https://docs.dolphindb.com/en/Functions/g/getCurrentSessionAndUser.html)\n\n\n\n#### Syntax\n\ngetCurrentSessionAndUser()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the session ID, username (\"guest\" if not logged in), remote IP address, and remote port number of the current session.\n\n**Return value**: A tuple containing the above-mentioned elements.\n\n#### Examples\n\n```\ngetCurrentSessionAndUser()  \n\n// Output: (2333906441, \"admin\", \"127.0.0.1\", 60302)\n```\n"
    },
    "getDatabaseClusterReplicationStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getDatabaseClusterReplicationStatus.html",
        "signatures": [
            {
                "full": "getDatabaseClusterReplicationStatus()",
                "name": "getDatabaseClusterReplicationStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDatabaseClusterReplicationStatus](https://docs.dolphindb.com/en/Functions/g/getDatabaseClusterReplicationStatus.html)\n\n#### Syntax\n\ngetDatabaseClusterReplicationStatus()\n\n#### Arguments\n\nNone\n\n#### Details\n\nThis function checks whether asynchronous replication is enabled in all databases. It can only be executed by an administrator on the data node of a master cluster.\n\nIt returns a table containing the following columns:\n\n* dbName: the database name.\n\n* enabled: a Boolean value indicating whether asynchronous replication is enabled.\n\n* executionSet: the execution set ID to which the task belongs.\n\nRelated functions: [setDatabaseForClusterReplication](https://docs.dolphindb.com/en/Functions/s/setDatabaseForClusterReplication.html)\n\n"
    },
    "getDatanodeRestartInterval": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getdatanoderestartinterval.html",
        "signatures": [
            {
                "full": "getDatanodeRestartInterval()",
                "name": "getDatanodeRestartInterval",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDatanodeRestartInterval](https://docs.dolphindb.com/en/Functions/g/getdatanoderestartinterval.html)\n\n\n\n#### Syntax\n\ngetDatanodeRestartInterval()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the value of *datanodeRestartInterval*. It can only be executed by an administrator on the controller.\n\nRelated function: [setDatanodeRestartInterval](https://docs.dolphindb.com/en/Functions/s/setdatanoderestartinterval.html)\n"
    },
    "getDBAccess": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getDBAccess.html",
        "signatures": [
            {
                "full": "getDBAccess(dbUrl)",
                "name": "getDBAccess",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    }
                ]
            }
        ],
        "markdown": "### [getDBAccess](https://docs.dolphindb.com/en/Functions/g/getDBAccess.html)\n\n\n\n#### Syntax\n\ngetDBAccess(dbUrl)\n\n#### Arguments\n\n**dbUrl** is a string indicating the database URL.\n\n#### Details\n\nAllow users to get a detailed view of users and groups with privileges of the specified database.\n\n\\*\\*Note:\\*\\*This function can only be invoked by administrators or by users with DB\\_OWNER or DB\\_MANAGE privileges of the database.\n\n**Return value**: A table with the following columns:\n\n* name: The user or group name.\n* type: User or group.\n* DB\\_READ, DB\\_INSERT, DB\\_UPDATE, DB\\_DELETE, DBOBJ\\_CREATE, DBOBJ\\_DELETE, DB\\_MANAGE: The specific privileges. The states can be ALLOW, DENY, or NONE. For more information on user access privileges, please refer to [User Access Control](https://docs.dolphindb.com/en/Tutorials/access_control.html).\n\n#### Examples\n\nUser1 with the DB\\_OWNER privilege creates the database dfs\\://testDB with following settings:\n\n* Grants DB\\_READ privilege to user2.\n* Denies DB\\_INSERT privilege to user3.\n* Grants DBOBJ\\_CREATE privilege to group1.\n\nUse getDBAccess to view the permission set of testDB.\n\n```\nlogin(`user1, `123456)\ngetDBAccess(\"dfs://testDB\")\n```\n\nOutput:\n\n| name   | type  | DB\\_READ | DB\\_INSERT | DB\\_UPDATE | DB\\_DELETE | DBOBJ\\_CREATE | DBOBJ\\_DELETE | DB\\_MANAGE |\n| :----- | :---- | :------- | :--------- | :--------- | :--------- | :------------ | :------------ | :--------- |\n| group1 | group | NONE     | NONE       | NONE       | NONE       | ALLOW         | NONE          | NONE       |\n| user3  | user  | NONE     | DENY       | NONE       | NONE       | NONE          | NONE          | NONE       |\n| user2  | user  | ALLOW    | NONE       | NONE       | NONE       | NONE          | NONE          | NONE       |\n| admin  | user  | ALLOW    | ALLOW      | ALLOW      | ALLOW      | ALLOW         | ALLOW         | ALLOW      |\n\nRelated functions: [getTableAccess](https://docs.dolphindb.com/en/Functions/g/getTableAccess.html)\n"
    },
    "getDFSDatabases": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getDFSDatabases.html",
        "signatures": [
            {
                "full": "getDFSDatabases()",
                "name": "getDFSDatabases",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDFSDatabases](https://docs.dolphindb.com/en/Functions/g/getDFSDatabases.html)\n\n\n\n#### Syntax\n\ngetDFSDatabases()\n\n#### Arguments\n\nNone\n\n#### Details\n\nThis function returns a vector that lists DFS databases on the current node.\n\nFrom version 1.30.21/2.00.9 onwards,\n\n* For an administrator or a non-admin user granted with DB\\_MANAGE privilege, the function returns all DFS databases on the current node;\n\n* Otherwise, the function returns DFS databases to which the user is granted with the DB\\_OWNER privilege.\n\n#### Examples\n\n```\ngetDFSDatabases()\n```\n"
    },
    "getDfsRebalanceConcurrency": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getDfsRebalanceConcurrency.html",
        "signatures": [
            {
                "full": "getDfsRebalanceConcurrency()",
                "name": "getDfsRebalanceConcurrency",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDfsRebalanceConcurrency](https://docs.dolphindb.com/en/Functions/g/getDfsRebalanceConcurrency.html)\n\n#### Syntax\n\ngetDfsRebalanceConcurrency()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the number of worker threads used by the current node for chunk rebalance. It can only be executed by an administrator on the controller.\n\n#### Examples\n\n```\ngetDfsRecoveryConcurrency()\n```\n\nRelated functions: [resetDfsRebalanceConcurrency](https://docs.dolphindb.com/en/Functions/r/resetDfsRebalanceConcurrency.html)\n\n"
    },
    "getDfsRecoveryConcurrency": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getDfsRecoveryConcurrency.html",
        "signatures": [
            {
                "full": "getDfsRecoveryConcurrency()",
                "name": "getDfsRecoveryConcurrency",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDfsRecoveryConcurrency](https://docs.dolphindb.com/en/Functions/g/getDfsRecoveryConcurrency.html)\n\n#### Syntax\n\ngetDfsRecoveryConcurrency()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the number of worker threads used by the current node for chunk recovery. It can only be executed by an administrator on the controller.\n\n#### Examples\n\n```\ngetDfsRecoveryConcurrency()\n```\n\nRelated functions: [resetDfsRecoveryConcurrency](https://docs.dolphindb.com/en/Functions/r/resetDfsRecoveryConcurrency.html)\n\n"
    },
    "getDFSTablesByDatabase": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getDFSTablesByDatabase.html",
        "signatures": [
            {
                "full": "getDFSTablesByDatabase(directory)",
                "name": "getDFSTablesByDatabase",
                "parameters": [
                    {
                        "full": "directory",
                        "name": "directory"
                    }
                ]
            }
        ],
        "markdown": "### [getDFSTablesByDatabase](https://docs.dolphindb.com/en/Functions/g/getDFSTablesByDatabase.html)\n\n\n\n#### Syntax\n\ngetDFSTablesByDatabase(directory)\n\n#### Arguments\n\n**directory** is the directory where a DFS database is located.\n\n#### Details\n\nThis functions returns a vector that lists tables under the specified DFS directory.\n\nFrom version 1.30.21/2.00.9 onwards,\n\n* For an administrator or a non-admin user granted with DB\\_MANAGE privilege, the function returns all DFS tables on the current node;\n\n* Otherwise, the function returns DFS tables in the databases to which the user is granted with DB\\_OWNER privilege.\n\n#### Examples\n\n```\ngetDFSTablesByDatabase(\"dfs://db\")\n// output\n[\"dfs://db1/dt\", \"dfs://db1/dt1\"]\n```\n"
    },
    "getDiskIOStat": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getDiskIOStat.html",
        "signatures": [
            {
                "full": "getDiskIOStat()",
                "name": "getDiskIOStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDiskIOStat](https://docs.dolphindb.com/en/Functions/g/getDiskIOStat.html)\n\n\n\n#### Syntax\n\ngetDiskIOStat()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn a dictionary with 2 pairs.\n\n* *diskIOQueueDepths* is a vector indicating the length of each I/O queue. All I/O tasks in the same DolphinDB instance belong to the same I/O queue.\n\n* *diskIOConcurrnecyLevel* is an integer indicating the number of I/O queues.\n\n#### Examples\n\n```\ngetDiskIOStat()\n// output\ndiskIOQueueDepths->[0]\ndiskIOConcurrnecyLevel->1\n```\n"
    },
    "getDynamicConfig": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getDynamicConfig.html",
        "signatures": [
            {
                "full": "getDynamicConfig()",
                "name": "getDynamicConfig",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDynamicConfig](https://docs.dolphindb.com/en/Functions/g/getDynamicConfig.html)\n\n#### Syntax\n\ngetDynamicConfig()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturns all configuration parameters that can be modified by function `setDynamicConfig`.\n\n#### Return Value\n\nA vector.\n\n#### Examples\n\n```\ngetDynamicConfig();\t\t\n// output: [\"dfsChunkNodeHeartBeatTimeout\",\"OLAPCacheEngineSize\",\"memLimitOfTempResult\",\"maxPartitionNumPerQuery\",\"TSDBCacheEngineSize\",\"memLimitOfTaskGroupResult\",\"recoveryWorkers\",\"memLimitOfQueryResult\",\"maxConnections\",\"maxBlockSizeForReservedMemory\",\"logLevel\",\"reservedMemSize\",\"maxMemSize\",\"enableMultiThreadMerge\"]\t\t\t\n```\n\n"
    },
    "getEnv": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getEnv.html",
        "signatures": [
            {
                "full": "getEnv(name, [default])",
                "name": "getEnv",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[default]",
                        "name": "default",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getEnv](https://docs.dolphindb.com/en/Functions/g/getEnv.html)\n\n\n\n#### Syntax\n\ngetEnv(name, \\[default])\n\n#### Arguments\n\n**name** is a STRING scalar indicating the name of an environment variable.\n\n**default** is a STRING scalar indicating the value to be returned when the environment variable does not exist. If it is unspecified, return an empty string.\n\n#### Details\n\nReturn the value of the specified environment variable. Otherwise return *default*.\n\n#### Examples\n\n```\ngetEnv(\"path\")\n// output\nC:\\ProgramData\\DockerDesktop\\version-bin;C:\\Program Files\\Docker\\Docker\\Resources\\bin;\n\ngetEnv(\"JAVA_HOME\");\n// output\nC:\\Program Files\\Java\\jdk1.8.0_191\n\ngetEnv(\"not_exist\",\"not exist\")\n// output\nnot exist\n```\n"
    },
    "getFunctionViews": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getFunctionViews.html",
        "signatures": [
            {
                "full": "getFunctionViews()",
                "name": "getFunctionViews",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getFunctionViews](https://docs.dolphindb.com/en/Functions/g/getFunctionViews.html)\n\n\n\n#### Syntax\n\ngetFunctionViews()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn a list of function views.\n\nIt returns a table with the following columns:\n\n* name: the function name.\n\n* body: the function body. For function views created from a *.dom* module file, this column only displays the function name, not the function body.\n\nWhen this function is executed by an administrator, it returns all the function views. When executed by a user with VIEW\\_OWNER permission, it only returns the function views created by the user.\n\n#### Examples\n\n```\ngetFunctionViews()\n```\n\n| name          | body          |\n| ------------- | ------------- |\n| countTradeAll | countTradeAll |\n"
    },
    "getGroupAccess": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getGroupAccess.html",
        "signatures": [
            {
                "full": "getGroupAccess(groupIds)",
                "name": "getGroupAccess",
                "parameters": [
                    {
                        "full": "groupIds",
                        "name": "groupIds"
                    }
                ]
            }
        ],
        "markdown": "### [getGroupAccess](https://docs.dolphindb.com/en/Functions/g/getGroupAccess.html)\n\n\n\n#### Syntax\n\ngetGroupAccess(groupIds)\n\n#### Arguments\n\n**groupIds** is a STRING scalar/vector indicating one or multiple group names.\n\n#### Details\n\nReturn a table of privileges for one or multiple groups. It can only be executed by an administrator.\n"
    },
    "getGroupList": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getGroupList.html",
        "signatures": [
            {
                "full": "getGroupList()",
                "name": "getGroupList",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getGroupList](https://docs.dolphindb.com/en/Functions/g/getGroupList.html)\n\n\n\n#### Syntax\n\ngetGroupList()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn a list of group names. It can only be executed by an administrator.\n"
    },
    "getGroupsByUserId": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getGroupsByUserId.html",
        "signatures": [
            {
                "full": "getGroupsByUserId(userId)",
                "name": "getGroupsByUserId",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    }
                ]
            }
        ],
        "markdown": "### [getGroupsByUserId](https://docs.dolphindb.com/en/Functions/g/getGroupsByUserId.html)\n\n\n\n#### Syntax\n\ngetGroupsByUserId(userId)\n\n#### Arguments\n\n**userId** is a string indicating a user name.\n\n#### Details\n\nReturn a STRING vector of the group names that the user belongs to. It can only be executed by an administrator.\n\n#### Examples\n\n```\ngetGroupsByUserId(\"admin\")\n// output\n[\"MVP\",\"MYMVP\"]\n```\n"
    },
    "getHomeDir": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getHomeDir.html",
        "signatures": [
            {
                "full": "getHomeDir()",
                "name": "getHomeDir",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getHomeDir](https://docs.dolphindb.com/en/Functions/g/getHomeDir.html)\n\n\n\n#### Syntax\n\ngetHomeDir()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn the home directory of the local node, which is defined in the configuration file *dolphindb.cfg*.\n\n#### Examples\n\n```\ngetHomeDir()\n// output\n/data/ddb/server\n```\n"
    },
    "getJobMessage": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getJobMessage.html",
        "signatures": [
            {
                "full": "getJobMessage(jobId)",
                "name": "getJobMessage",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    }
                ]
            }
        ],
        "markdown": "### [getJobMessage](https://docs.dolphindb.com/en/Functions/g/getJobMessage.html)\n\n\n\n#### Syntax\n\ngetJobMessage(jobId)\n\n#### Arguments\n\n**jobId** is a string indicating the batch job ID.\n\n#### Details\n\nRetrieve the intermediate messages from a batch job. For details about batch jobs please refer to [Batch Job Management](https://docs.dolphindb.com/en/Maintenance/BatchJobManagement.html).\n\n#### Examples\n\n```\ndef job1(n){\n   s = 0\n   for (x in 1 : n) {\n       s += sum(sin rand(1.0, 100000000)-0.5)\n       print(\"iteration \" + x + \" \" + s)\n   }\n   return s\n}\n// output\njob1_ID=submitJob(\"job1_ID\",\"\", job1, 100);\n```\n\nRun the following command after the job is completed.\n\n```\ngetJobMessage(job1_ID);\n\n// output\n2021-04-27 11:29:59.488488 Start the job [job1_ID]: job1\n2021-04-27 11:30:01.379568 iteration 1 1850.532362292674861\n2021-04-27 11:30:02.905145 iteration 2 3481.051082793509067\n2021-04-27 11:30:04.506399 iteration 3 6338.637607451696567\n2021-04-27 11:30:05.918307 iteration 4 6683.476434419478209\n2021-04-27 11:30:07.375599 iteration 5 2530.259402850952938\n2021-04-27 11:30:08.786317 iteration 6 3703.629418401157636\n2021-04-27 11:30:10.194354 iteration 7 2813.420082343553985\n2021-04-27 11:30:11.598985 iteration 8 4933.850209294281739\n2021-04-27 11:30:13.002326 iteration 9 5154.255793881513454\n2021-04-27 11:30:14.412271 iteration 10 -3309.722440538816954\n2021-04-27 11:30:15.823373 iteration 11 -1659.488479800297909\n2021-04-27 11:30:17.242967 iteration 12 -3625.982445703876692\n2021-04-27 11:30:18.825975 iteration 13 -631.335252897485588\n2021-04-27 11:30:20.484410 iteration 14 1624.923506700145026\n2021-04-27 11:30:21.908811 iteration 15 59.809027080983469\n2021-04-27 11:30:23.423718 iteration 16 -1876.258259260708655\n2021-04-27 11:30:24.894356 iteration 17 -1311.358522160356187\n2021-04-27 11:30:26.314293 iteration 18 393.578971401109583\n2021-04-27 11:30:27.777455 iteration 19 -138.581585426370565\n2021-04-27 11:30:29.247481 iteration 20 4898.050366365572699\n```\n"
    },
    "getJobReturn": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getJobReturn.html",
        "signatures": [
            {
                "full": "getJobReturn(jobId, [blocking=false])",
                "name": "getJobReturn",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    },
                    {
                        "full": "[blocking=false]",
                        "name": "blocking",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [getJobReturn](https://docs.dolphindb.com/en/Functions/g/getJobReturn.html)\n\n\n\n#### Syntax\n\ngetJobReturn(jobId, \\[blocking=false])\n\n#### Arguments\n\n**jobId** is a string indicating the batch job ID.\n\n**blocking** (optional) is a Boolean value indicating whether the blocking mode is enabled. If *blocking* is false (default), the function will return an exception if the job is not completed. If *blocking* is true, the function will not return a value until the job is completed.\n\n#### Details\n\nRetrieve the batch job result. For details about batch jobs please refer to [Batch Job Management](https://docs.dolphindb.com/en/Maintenance/BatchJobManagement.html).\n\n#### Examples\n\n```\ndef job1(n){\n   s = 0\n   for (x in 1 : n) {\n       s += sum(sin rand(1.0, 100000000)-0.5)\n       print(\"iteration \" + x + \" \" + s)\n   }\n   return s\n}\n\njob1_ID=submitJob(\"job1_ID\",\"\", job1, 100);\ngetJobReturn(job1_ID);\n// output\nThe job [job1_ID20210428] is not complete yet.\n```\n\nRerun the `getJobReturn` command after the job is completed:\n\n```\ngetJobReturn(job1_ID);\n// output\n-13318.181243\n```\n\nIf we would like `getJobReturn` to hold off returning results until the job is completed, we can set the optional parameter *blocking* to true. This feature is useful in handling batch job dependencies.\n\n```\njob1_ID = submitJob(\"job1_ID\",\"\", job1, 100)\ngetJobReturn(job1_ID, true);\n// output\n-31900.013922\n```\n"
    },
    "getJobStat": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getJobStat.html",
        "signatures": [
            {
                "full": "getJobStat()",
                "name": "getJobStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getJobStat](https://docs.dolphindb.com/en/Functions/g/getJobStat.html)\n\n\n\n#### Syntax\n\ngetJobStat()\n\n#### Arguments\n\nNone\n\n#### Details\n\nMonitor the number of jobs and tasks that are are running or in the job queue.\n\nIt returns a dictionary with the following keys:\n\n| Keys              | Meaning                                         |\n| ----------------- | ----------------------------------------------- |\n| queuedLocalTasks  | the number of local tasks waiting in the queue  |\n| runningLocalTasks | the number of running local tasks               |\n| queuedJobs        | the number of jobs in the queue                 |\n| runningJobs       | the number of running jobs                      |\n| queuedRemoteTasks | the number of remote tasks waiting in the queue |\n\n#### Examples\n\n```\ngetJobStat();\n\n// output\nqueuedLocalTasks->0\nrunnningJobs->0\nqueuedRemoteTasks->0\nqueuedJobs->0\nrunningLocalTasks->0\n```\n"
    },
    "getJobStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getJobStatus.html",
        "signatures": [
            {
                "full": "getJobStatus(jobId)",
                "name": "getJobStatus",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    }
                ]
            }
        ],
        "markdown": "### [getJobStatus](https://docs.dolphindb.com/en/Functions/g/getJobStatus.html)\n\n\n\n#### Syntax\n\ngetJobStatus(jobId)\n\n#### Arguments\n\n**jobId** is a string indicating the batch job ID.\n\n#### Details\n\nRetrieve the status of a batch job. It returns a table with the following columns:\n\n| Name         | Meaning                                                                    |\n| ------------ | -------------------------------------------------------------------------- |\n| node         | the alias of the local node                                                |\n| userID       | the user ID                                                                |\n| jobId        | the job ID                                                                 |\n| rootJobId    | the root job ID                                                            |\n| jobDesc      | the job description                                                        |\n| priority     | priority of the job which is marked as integers ranging from 0 to 9        |\n| parallelism  | the parallelism, i.e., the maximum number of jobs that can run in parallel |\n| clientIp     | the IP address of the client where the job is submitted                    |\n| clientPort   | the port number of the client where the job is submitted                   |\n| receivedTime | the time (of TIMESTAMP type) when a job is received by the node            |\n| startTime    | the start time of jobs (of TIMESTAMP type)                                 |\n| endTime      | the end time of jobs (of TIMESTAMP type)                                   |\n| errorMessage | error messages                                                             |\n\nFor details about batch jobs please refer to [Batch Job Management](https://docs.dolphindb.com/en/Maintenance/BatchJobManagement.html).\n\n#### Examples\n\n```\ndef job1(n){\n   s = 0\n   for (x in 1 : n) {\n       s += sum(sin rand(1.0, 100000000)-0.5)\n       print(\"iteration \" + x + \" \" + s)\n   }\n   return s\n}\n\njob1_ID=submitJob(\"job1_ID\",\"\", job1, 100);\ngetJobStatus(job1_ID);\n```\n\n| node        | userID | jobId               | rootJobId                            | jobDesc | priority | parallelism | clientIP       | clientPort | receivedTime            | startTime | endTime | errorMsg |\n| ----------- | ------ | ------------------- | ------------------------------------ | ------- | -------- | ----------- | -------------- | ---------- | ----------------------- | --------- | ------- | -------- |\n| controller2 | guest  | job1\\_ID20210428... | b9263bfd-50b8-70b3-9845-e595f9b0c506 | job1    | 4        | 1           | 115.204.199.28 | 61537      | 2023.12.12T02:50:32.598 |           |         |          |\n\n*endTime* is empty. This means the job is still running. After the job is completed, rerun `getJobStatus`:\n\n```\ngetJobStatus(job1_ID);\n```\n\n<table><tbody><tr><td>\n\nnode\n\n</td><td>\n\nuserID\n\n</td><td>\n\njobId\n\n</td><td>\n\nrootJobId\n\n</td><td>\n\njobDesc\n\n</td><td>\n\npriority\n\n</td><td>\n\nparallelism\n\n</td><td>\n\nclientIP\n\n</td><td>\n\nclientPort\n\n</td><td>\n\nreceivedTime\n\n</td><td>\n\nstartTime\n\n</td><td>\n\nendTime\n\n</td><td>\n\nerrorMsg\n\n</td></tr><tr><td>\n\ncontroller2\n\n</td><td>\n\nguest\n\n</td><td>\n\njob1\\_ID20210428...\n\n</td><td>\n\nb9263bfd-50b8-70b3-9845-e595f9b0c506\n\n</td><td>\n\njob1\n\n</td><td>\n\n4\n\n</td><td>\n\n1\n\n</td><td>\n\n115.204.199.28\n\n</td><td>\n\n61537\n\n</td><td>\n\n2023.12.12T02:50:32.598\n\n</td><td>\n\n2023.12.12T02:50:32.599\n\n</td><td>\n\n2023.12.12T02:52:32.477\n\n</td><td>\n\n</td></tr></tbody>\n</table>\n"
    },
    "getLeftStream": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getLeftStream.html",
        "signatures": [
            {
                "full": "getLeftStream(joinEngine)",
                "name": "getLeftStream",
                "parameters": [
                    {
                        "full": "joinEngine",
                        "name": "joinEngine"
                    }
                ]
            }
        ],
        "markdown": "### [getLeftStream](https://docs.dolphindb.com/en/Functions/g/getLeftStream.html)\n\n\n\n#### Syntax\n\ngetLeftStream(joinEngine)\n\n#### Arguments\n\n**joinEngine** is a table object returned by creating a join engine. The join engines currently supported by DolphinDB are:\n\n* createAsofJoinEngine\n\n* createEquiJoinEngine\n\n* createLookupJoinEngine\n\n* createWindowJoinEngine\n\n* createLeftSemiJoinEngine\n\n#### Details\n\nReturn the schema of the left table of the join engine. The data ingested into this schema will be ingested into *joinEngine*.\n\nThe result of an engine can be ingested into the join engine to realize the cascade between engines.\n\n#### Examples\n\n```\nshare streamTable(1000:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\n\noutput=table(100:0, `timestamp`sym`price1`price2, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE])\n\nleftTable=table(1:0, `sym`timestamp`price, [SYMBOL, TIMESTAMP, DOUBLE])\nrightTable=table(1:0, `sym`timestamp`price, [SYMBOL, TIMESTAMP, DOUBLE])\n\najEngine = createAsofJoinEngine(\"asofjoin_engine\", leftTable, rightTable, output, <[leftTable.price, rightTable.price]>, `sym, `timestamp)\n\nleftEngine = createReactiveStateEngine(name=`left_reactive_engine, metrics=<[time,msum(price,3)]>, dummyTable=trades, outputTable=getLeftStream(ajEngine), keyColumn=\"sym\")\nrightEngine = createReactiveStateEngine(name=`right_reactive_engine, metrics=<[time,mfirst(price,3)]>, dummyTable=trades, outputTable=getRightStream(ajEngine), keyColumn=\"sym\")\n\nsubscribeTable(, \"trades\", \"left_reactive_engine\", 0, append!{leftEngine}, true)\nsubscribeTable(, \"trades\", \"right_reactive_engine\", 0, append!{rightEngine}, true)\n\nt = table(2022.01.01 + 1..20 as time, take(`AMZN`IBM`APPL, 20) as sym, rand(100.0, 20) as price)\ntrades.append!(t)\nselect * from output order by timestamp,sym\n```\n\n| timestamp               | sym  | price1   | price2  |\n| ----------------------- | ---- | -------- | ------- |\n| 2022.01.02T00:00:00.000 | AMZN |          |         |\n| 2022.01.03T00:00:00.000 | IBM  |          |         |\n| 2022.01.04T00:00:00.000 | APPL |          |         |\n| 2022.01.05T00:00:00.000 | AMZN |          |         |\n| 2022.01.06T00:00:00.000 | IBM  |          |         |\n| 2022.01.07T00:00:00.000 | APPL |          |         |\n| 2022.01.08T00:00:00.000 | AMZN | 102.192  | 26.2273 |\n| 2022.01.09T00:00:00.000 | IBM  | 152.2704 | 43.6296 |\n| 2022.01.10T00:00:00.000 | APPL | 126.1056 | 74.929  |\n| 2022.01.11T00:00:00.000 | AMZN | 137.4656 | 57.6015 |\n| 2022.01.12T00:00:00.000 | IBM  | 116.7775 | 54.2854 |\n| 2022.01.13T00:00:00.000 | APPL | 58.8909  | 49.3149 |\n| 2022.01.14T00:00:00.000 | AMZN | 148.5405 | 18.3633 |\n| 2022.01.15T00:00:00.000 | IBM  | 141.0848 | 54.3554 |\n| 2022.01.16T00:00:00.000 | APPL | 93.9003  | 1.8618  |\n| 2022.01.17T00:00:00.000 | AMZN | 210.4329 | 61.5008 |\n| 2022.01.18T00:00:00.000 | IBM  | 88.7772  | 8.1367  |\n\nRelated function: [getRightStream](https://docs.dolphindb.com/en/Functions/g/getRightStream.html).\n"
    },
    "getLevelFileIndexCacheStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getLevelFileIndexCacheStatus.html",
        "signatures": [
            {
                "full": "getLevelFileIndexCacheStatus()",
                "name": "getLevelFileIndexCacheStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getLevelFileIndexCacheStatus](https://docs.dolphindb.com/en/Functions/g/getLevelFileIndexCacheStatus.html)\n\n\n\n#### Syntax\n\ngetLevelFileIndexCacheStatus()\n\n#### Arguments\n\nNone\n\n#### Details\n\nObtain the memory usage of the indexes of all level files. Return a dictionary with the following keys:\n\n* capacity: is the maximum size of level file index in the TSDB engine.\n\n* usage: is the size of the memory used (in bytes).\n\n#### Examples\n\n```\ngetLevelFileIndexCacheStatus()\n// output\nusage->0\ncapacity->429496729\n```\n"
    },
    "getLicenseExpiration": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getLicenseExpiration.html",
        "signatures": [
            {
                "full": "getLicenseExpiration()",
                "name": "getLicenseExpiration",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getLicenseExpiration](https://docs.dolphindb.com/en/Functions/g/getLicenseExpiration.html)\n\n\n\n#### Syntax\n\ngetLicenseExpiration()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn the expiration date of the license on the current node. It can be used to verify whether the license file has been updated.\n\n#### Examples\n\n```\ngetLicenseExpiration()\n// output\n2021.09.30\n```\n"
    },
    "getLicenseServerResourceInfo": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getLicenseServerResourceInfo.html",
        "signatures": [
            {
                "full": "getLicenseServerResourceInfo()",
                "name": "getLicenseServerResourceInfo",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getLicenseServerResourceInfo](https://docs.dolphindb.com/en/Functions/g/getLicenseServerResourceInfo.html)\n\n#### Syntax\n\ngetLicenseServerResourceInfo()\n\n#### Arguments\n\nNone\n\n#### Details\n\nA license server is a standalone server that communicates with other nodes and controls node startup. It receives requests for resources (memory and CPU cores) from other nodes. A node can only be started if its requested resources are available.\n\nYou can configure *localSite* and *licenseServerSite* to enable/disable a license server. This function can only be executed by an administrator on a license server.\n\nThis function obtains information regarding DolphinDB license managed by the license server and returns a dictionary:\n\n* expiration: license expiration date\n\n* availableCores: number of available CPU cores\n\n* availableMemory: available memory (in GB)\n\n* maxNodes: maximum number of nodes\n\n* maxMemory: maximum memory (in GB)\n\n* maxCores: maximum number of CPU cores\n\n#### Examples\n\n```\ngetLicenseServerResourceInfo()\n// output\nexpiration->2023.03.10\navailableCores->10\navailableMemory->52\nmaxNodes->4\nmaxMemory->64\nmaxCores->16\n```\n"
    },
    "getLoadedPlugins": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getLoadedPlugins.html",
        "signatures": [
            {
                "full": "getLoadedPlugins()",
                "name": "getLoadedPlugins",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getLoadedPlugins](https://docs.dolphindb.com/en/Functions/g/getLoadedPlugins.html)\n\n\n\n#### Syntax\n\ngetLoadedPlugins()\n\n#### Arguments\n\nNone\n\n#### Details\n\nThis function retrieves a list of plugins loaded on the node.\n\n**Return value:** A table containing the following columns:\n\n* plugin: name of the plugin.\n* version: plugin version as specified in the *Plugin\\<name>.txt* file.\n* user: name of the user who loaded the plugin.\n* time: date and time when the plugin was loaded.\n\n#### Examples\n\n```\nlogin(\"admin\",\"123456\")\nloadPlugin(\"zip\")\nlogin(\"user1\",\"123456\")\nloadPlugin(\"httpclient\")\n\ngetLoadedPlugins()\n```\n\nOutput:\n\n| plugin     | version | user  | time                    |\n| ---------- | ------- | ----- | ----------------------- |\n| zip        | 3.00.1  | admin | 2024.09.01T10:00:01.000 |\n| httpClient | 3.00.1  | user1 | 2024.09.01T10:00:02.000 |\n"
    },
    "getMarketCalendar": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getMarketCalendar.html",
        "signatures": [
            {
                "full": "getMarketCalendar(marketName, [startDate], [endDate])",
                "name": "getMarketCalendar",
                "parameters": [
                    {
                        "full": "marketName",
                        "name": "marketName"
                    },
                    {
                        "full": "[startDate]",
                        "name": "startDate",
                        "optional": true
                    },
                    {
                        "full": "[endDate]",
                        "name": "endDate",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getMarketCalendar](https://docs.dolphindb.com/en/Functions/g/getMarketCalendar.html)\n\n#### Syntax\n\ngetMarketCalendar(marketName, \\[startDate], \\[endDate])\n\n#### Arguments\n\n**marketName** is a STRING scalar, indicating the identifier of the trading calendar, e.g., the Market Identifier Code of an exchange, or a user-defined calendar name. It must exist in the directory specified by configuration parameter *marketHolidayDir*, otherwise an error will be reported.\n\n**startDate** (optional) is a scalar of DATE type. If it is not specified, the default value is January 1st of the earliest year in the file named *marketName*.\n\n**endDate** (optional) is a scalar of DATE type. If it is not specified, the default value is December 31st of the latest year in the file named *marketName*.\n\n#### Details\n\nDolphinDB provides trading calendars of more than 50 exchanges (with corresponding CSV files stored in *marketHolidayDir*). This function is used to get the trading calendar in the time interval determined by *startDate* and *endDate*.\n\n#### Examples\n\n```\naddMarketHoliday(\"CFFEX\",2022.01.03 2022.01.05)\ngetMarketCalendar(\"CFFEX\",2022.01.01, 2022.01.10)\n// output\n[2022.01.04,2022.01.06,2022.01.07,2022.01.10]\n```\n\nRelated functions: [addMarketHoliday](https://docs.dolphindb.com/en/Functions/a/addMarketHoliday.html), [updateMarketHoliday](https://docs.dolphindb.com/en/Functions/u/updateMarketHoliday.html)\n\n"
    },
    "getMasterReplicationStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getMasterReplicationStatus.html",
        "signatures": [
            {
                "full": "getMasterReplicationStatus([limit=-1])",
                "name": "getMasterReplicationStatus",
                "parameters": [
                    {
                        "full": "[limit=-1]",
                        "name": "limit",
                        "optional": true,
                        "default": "-1"
                    }
                ]
            }
        ],
        "markdown": "### [getMasterReplicationStatus](https://docs.dolphindb.com/en/Functions/g/getMasterReplicationStatus.html)\n\n#### Syntax\n\ngetMasterReplicationStatus(\\[limit=-1])\n\n#### Arguments\n\n**limit** (optional) is an integer that specifies the maximum tasks that can be returned in the result. The default value is -1, meaning no limit is placed.\n\n#### Details\n\nThis function displays the cluster replication task status in the master cluster. It returns a table where finished tasks are listed first, then followed by unfinished tasks.\n\n* If *limit* is not specified, there is no limit on the number of tasks returned.\n\n* If *limit* is specified, up to *limit* records (including finished and unfinished tasks) can be returned.\n\nA maximum of 10,000 records of finished tasks are returned, and the unfinished tasks are displayed from the earliest time until the specified number of records is met.\n\nIt can only be executed by an administrator on the controller of a master cluster.\n\nIt returns a table containing the following columns:\n\n* taskId: ID of replication task.\n\n* tid: transaction ID.\n\n* groupId: ID of the group to which the replication task belongs to.\n\n* operationType: the operation type.\n\n* submitTime: task submission time (of NANOTIMESTAMP type).\n\n* dbName: the database name.\n\n* tableName: the table name.\n\n* srcIP: IP of the data node where data of write tasks is stored.\n\n* srcPort: port of the data node where data of write tasks is stored.\n\n* isTruncated: whether the task has been finished and garbage-collected from the push queue.\n\n#### Examples\n\n```\ngetMasterReplicationStatus();\n```\n\n| taskId | tid | groupId | operationType              | submitTime                    | dbName                          | tableName | srcIP     | srcPort | isTruncated |\n| ------ | --- | ------- | -------------------------- | ----------------------------- | ------------------------------- | --------- | --------- | ------- | ----------- |\n| 1      | 1   | 1       | CREATE\\_DB                 | 2022.11.08T10:50:35.442141722 | db://test\\_dropPartition\\_value |           | 127.0.0.1 | 8002    | true        |\n| 2      | 2   | 2       | CREATE\\_PARTITIONED\\_TABLE | 2022.11.08T10:50:35.447716190 | db://test\\_dropPartition\\_value | pt        | 127.0.0.1 | 8002    | true        |\n| 3      | 3   | 3       | APPEND                     | 2022.11.08T10:50:35.584920262 | db://test\\_dropPartition\\_value | pt        | 127.0.0.1 | 8002    | true        |\n| 4      | 4   | 4       | DROP\\_PARTITION            | 2022.11.08T10:50:35.632575800 |                                 | pt        | 127.0.0.1 | 8002    | false       |\n\nRelated functions: [getSlaveReplicationStatus](https://docs.dolphindb.com/en/Functions/g/getSlaveReplicationStatus.html)\n\n"
    },
    "getMemLimitOfAllTempResults": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getMemLimitOfAllTempResults.html",
        "signatures": [
            {
                "full": "getMemLimitOfAllTempResults()",
                "name": "getMemLimitOfAllTempResults",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getMemLimitOfAllTempResults](https://docs.dolphindb.com/en/Functions/g/getMemLimitOfAllTempResults.html)\n\n\n\n#### Syntax\n\ngetMemLimitOfAllTempResults()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the value of *memLimitOfAllTempResults*. It can only be executed by an administrator on the data node or compute node.\n\n#### Examples\n\n```\ngetMemLimitOfAllTempResults ()\n// output: 3.0\n```\n"
    },
    "getMemLimitOfQueryResult": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getMemLimitOfQueryResult.html",
        "signatures": [
            {
                "full": "getMemLimitOfQueryResult()",
                "name": "getMemLimitOfQueryResult",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getMemLimitOfQueryResult](https://docs.dolphindb.com/en/Functions/g/getMemLimitOfQueryResult.html)\n\n\n\n#### Syntax\n\ngetMemLimitOfQueryResult()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the memory limit (in units of bytes) for the result of each query.\n\n**Return value**: DOUBLE type.\n\n#### Examples\n\n```\nsetMemLimitOfQueryResult(0.2)\ngetMemLimitOfQueryResult() / 1024 / 1024 / 1024\n// output\n0.2\n```\n\nRelated function: [setMemLimitOfQueryResult](https://docs.dolphindb.com/en/Functions/s/setMemLimitOfQueryResult.html)\n"
    },
    "getMemLimitOfTaskGroupResult": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getMemLimitOfTaskGroupResult.html",
        "signatures": [
            {
                "full": "getMemLimitOfTaskGroupResult()",
                "name": "getMemLimitOfTaskGroupResult",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getMemLimitOfTaskGroupResult](https://docs.dolphindb.com/en/Functions/g/getMemLimitOfTaskGroupResult.html)\n\n\n\n#### Syntax\n\ngetMemLimitOfTaskGroupResult()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the memory limit of a task group sent from the current node.\n\n**Return value**: DOUBLE type.\n\n#### Examples\n\n```\nsetMemLimitOfTaskGroupResult(10)\ngetMemLimitOfTaskGroupResult() / 1024 / 1024 / 1024\n// output\n10\n```\n\nRelated function: [setMemLimitOfTaskGroupResult](https://docs.dolphindb.com/en/Functions/s/setMemLimitOfTaskGroupResult.html)\n"
    },
    "getMemoryStat": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getMemoryStat.html",
        "signatures": [
            {
                "full": "getMemoryStat()",
                "name": "getMemoryStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getMemoryStat](https://docs.dolphindb.com/en/Functions/g/getMemoryStat.html)\n\n\n\n#### Syntax\n\ngetMemoryStat()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn the allocated memory and the unused memory. It returns a dictionary with the following keys:\n\n* freeBytes: the allocated memory (in Bytes) for the current node.\n\n* allocatedBytes: the unused memory (in Bytes) for the current node.\n\n#### Examples\n\n```\ngetMemoryStat();\n// output\nfreeBytes->6430128\nallocatedBytes->35463168\n```\n"
    },
    "getNodeAlias": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getNodeAlias.html",
        "signatures": [
            {
                "full": "getNodeAlias()",
                "name": "getNodeAlias",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getNodeAlias](https://docs.dolphindb.com/en/Functions/g/getNodeAlias.html)\n\n\n\n#### Syntax\n\ngetNodeAlias()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn the alias of the local node, which is defined in the configuration file *dolphindb.cfg*.\n\n#### Examples\n\n```\ngetNodeAlias();\n// output\ncontroller2\n```\n"
    },
    "getNodeHost": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getNodeHost.html",
        "signatures": [
            {
                "full": "getNodeHost()",
                "name": "getNodeHost",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getNodeHost](https://docs.dolphindb.com/en/Functions/g/getNodeHost.html)\n\n\n\n#### Syntax\n\ngetNodeHost()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn the host name of the local node, which is defined in the configuration file *dolphindb.cfg*.\n\n#### Examples\n\n```\ngetNodeHost();\n// output\n10.6.0.6\n```\n"
    },
    "getNodePort": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getNodePort.html",
        "signatures": [
            {
                "full": "getNodePort()",
                "name": "getNodePort",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getNodePort](https://docs.dolphindb.com/en/Functions/g/getNodePort.html)\n\n\n\n#### Syntax\n\ngetNodePort()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn the port number of the local node, which is defined in the configuration file *dolphindb.cfg*.\n\n#### Examples\n\n```\ngetNodePort();\n// output\n8081\n```\n"
    },
    "getNodeType": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getNodeType.html",
        "signatures": [
            {
                "full": "getNodeType()",
                "name": "getNodeType",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getNodeType](https://docs.dolphindb.com/en/Functions/g/getNodeType.html)\n\n\n\n#### Syntax\n\ngetNodeType()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn the type of the node.\n\n0: data node\n\n1: agent\n\n2: controller\n\n3: standalone mode\n\n4: compute node\n\n#### Examples\n\n```\ngetNodeType();\n// output\n2\n```\n"
    },
    "getOLAPCachedSymbolBaseMemSize": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getOLAPCachedSymbolBaseMemSize.html",
        "signatures": [
            {
                "full": "getOLAPCachedSymbolBaseMemSize()",
                "name": "getOLAPCachedSymbolBaseMemSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getOLAPCachedSymbolBaseMemSize](https://docs.dolphindb.com/en/Functions/g/getOLAPCachedSymbolBaseMemSize.html)\n\n#### Syntax\n\ngetOLAPCachedSymbolBaseMemSize()\n\n#### Arguments\n\nNone\n\n#### Details\n\nObtain the cache size (in Bytes) of SYMBOL base (i.e., a dictionary that stores integers encoded from the data of SYMBOL type) of the OLAP engine.\n\n"
    },
    "getOLAPCacheEngineSize": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getOLAPCacheEngineSize.html",
        "signatures": [
            {
                "full": "getOLAPCacheEngineSize()",
                "name": "getOLAPCacheEngineSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getOLAPCacheEngineSize](https://docs.dolphindb.com/en/Functions/g/getOLAPCacheEngineSize.html)\n\n\n\n#### Syntax\n\ngetOLAPCacheEngineSize()\n\nAlias: getCacheEngineMemSize\n\n#### Arguments\n\nNone\n\n#### Details\n\nObtain the memory status (in Byte) of the OLAP cache engine on the current node.\n\nIt returns a tuple:\n\nThe 1st element indicates the memory occupied by the cache engine;\n\nThe 2nd element indicates the memory occupied by the column files stored in the cache engine;\n\nThe 3rd element indicates the memory occupied by the column file pointers;\n\nThe 4th element indicates the maximum memory allocated to the cache engine.\n\n#### Examples\n\n```\nsetOLAPCacheEngineSize(0.4)\ngetOLAPCacheEngineSize()\n// output\n(0,0,0,429496729)\n```\n\nRelated Function: [setOLAPCacheEngineSize](https://docs.dolphindb.com/en/Functions/s/setOLAPCacheEngineSize.html)\n"
    },
    "getOLAPCacheEngineStat": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getOLAPCacheEngineStat.html",
        "signatures": [
            {
                "full": "getOLAPCacheEngineStat()",
                "name": "getOLAPCacheEngineStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getOLAPCacheEngineStat](https://docs.dolphindb.com/en/Functions/g/getOLAPCacheEngineStat.html)\n\n\n\n#### Syntax\n\ngetOLAPCacheEngineStat()\n\nAlias: getCacheEngineStat\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the status of the OLAP cache engine on the current node. The function can only be called on the data node.\n\nReturn a table containing the following columns:\n\n* chunkId: the chunk ID.\n\n* physicalName: the physical name of the table to which the chunk belongs.\n\n* timeSinceLastWrite: the time elapsed (in milliseconds) since last write.\n\n* cachedRowsOfCompletedTxn: the number of cached records of completed transactions.\n\n* cachedRowsOfUncompletedTxn: the number of cached records of uncompleted transactions. For each chunk, only the last transaction may not have been completed.\n\n* cachedMemOfCompletedTxn: the memory usage (in Bytes) of completed transactions.\n\n* cachedMemOfUncompletedTxn: the memory usage (in Bytes) of uncompleted transactions.\n\n* cachedTids: list of transaction IDs (tid).\n\n#### Examples\n\n```\ngetOLAPCacheEngineStat()\n```\n\n| chunkId                              | physicalName | timeSinceLastWrite | cachedRowsOfCompletedTxn | cachedRowsOfUncompletedTxn | cachedMemOfCompletedTxn | cachedMemOfUncompletedTxn | cachedTids |\n| ------------------------------------ | ------------ | ------------------ | ------------------------ | -------------------------- | ----------------------- | ------------------------- | ---------- |\n| e4558d3c-fa41-52b5-418b-94e26cb70a75 | pt\\_2        | 1056               | 222,386                  | 0                          | 3,558,176               | 0                         | 2052       |\n"
    },
    "getOS": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getOS.html",
        "signatures": [
            {
                "full": "getOS()",
                "name": "getOS",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getOS](https://docs.dolphindb.com/en/Functions/g/getOS.html)\n\n\n\n#### Syntax\n\ngetOS()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn the operating system where DolphinDB is running.\n\n#### Examples\n\n```\ngetOS();\n// output\nlinux\n```\n"
    },
    "getOSBit": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getOSBit.html",
        "signatures": [
            {
                "full": "getOSBit()",
                "name": "getOSBit",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getOSBit](https://docs.dolphindb.com/en/Functions/g/getOSBit.html)\n\n\n\n#### Syntax\n\ngetOSBit()\n\n#### Arguments\n\nNone\n\n#### Details\n\nIndicate whether the operating system is 32-bit or 64-bit.\n\n#### Examples\n\n```\ngetOSBit();\n// output\n64\n```\n"
    },
    "getPerf": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getPerf.html",
        "signatures": [
            {
                "full": "getPerf()",
                "name": "getPerf",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getPerf](https://docs.dolphindb.com/en/Functions/g/getPerf.html)\n\n\n\n#### Syntax\n\ngetPerf()\n\n#### Arguments\n\nNone\n\n#### Details\n\n`getPerf` returns various performance monitoring metrics of the local node as a dictionary.\n\nThe dictionary contains the following fields:\n\n* runningJobs: The number of running jobs.\n\n* jobLoad: The CPU load of a job.\n\n* avgLoad: average CPU load.\n\n* queuedJobs: The number of jobs in queue.\n\n* lastMinuteNetworkSend: The data (in bytes) sent in the last minute.\n\n* lastMinuteNetworkRecv: The data (in bytes) received in the last minute.\n\n* lastMinuteReadVolume: The data (in bytes) read from disk in the last minute.\n\n* lastMinuteWriteVolume: The data (in bytes) written to disk in the last minute.\n\n* lastMsgLatency: The latency (in ns) of the last received message.\n\n* cumMsgLatency: The cumulative latency (in ns) of the messages.\n\n* maxLast10QueryTime: The maximum execution time (in ns) of the previous 10 finished queries.\n\n* maxLast100QueryTime: The maximum execution time (in ns) of the previous 100 finished queries.\n\n* medLast10QueryTime: The median execution time (in ns) of the previous 10 finished queries.\n\n* medLast100QueryTime: The median execution time (in ns) of the previous 100 finished queries.\n\n* maxRunningQueryTime: The maximum elapsed time (in ns) of the queries that are currently running.\n\n* diskFreeSpaceRatio: The available space ratio.\n\n* diskReadRate: The rate (in bytes/s) at which data are read from disk.\n\n* diskWriteRate: The rate (in bytes/s) at which data are written to disk.\n\n* diskFreeSpace: The available disk space (in bytes).\n\n* diskCapacity: The disk capacity (in bytes).\n\n* cpuUsage: CPU usage.\n\n* memoryAlloc: The total memory (in bytes) allocated to DolphinDB on the node.\n\n* memoryUsed: The memory (in bytes) used by the node.\n\n* networkSendRate: The rate at which data are sent (in bytes/s).\n\n* networkRecvRate: The rate at which data are received (in bytes/s).\n\n* connectionNum: The number of connections to the local node.\n\n#### Examples\n\n```\ngetPerf();\n// output\nlastMinuteWriteVolume->684\nrunningJobs->0\nlastMsgLatency->0\nmaxLast100QueryTime->0\navgLoad->0.0040625\ndiskWriteRate->144\nlastMinuteNetworkSend->228528\nqueuedJobs->0\nlastMinuteNetworkRecv->525533\nmaxLast10QueryTime->0\nmedLast100QueryTime->0\nmaxRunningQueryTime->0\ndiskReadRate->2663\ncumMsgLatency->0\nmedLast10QueryTime->0\ndiskFreeSpaceRatio->0\ncpuUsage->0.306748466257669\nmemoryUsed->29053456\njobLoad->0\nnetworkSendRate->4460\nmemoryAlloc->35463168\nlastMinuteReadVolume->159940\nnetworkRecvRate->8950\ndiskCapacity->0\ndiskFreeSpace->0\n```\n"
    },
    "getPersistenceMeta": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getPersistenceMeta.html",
        "signatures": [
            {
                "full": "getPersistenceMeta(table)",
                "name": "getPersistenceMeta",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [getPersistenceMeta](https://docs.dolphindb.com/en/Functions/g/getPersistenceMeta.html)\n\n\n\n#### Syntax\n\ngetPersistenceMeta(table)\n\n#### Arguments\n\n**table** is a table object.\n\n#### Details\n\nGet metadata of a persistent stream table.\n\nReturn a dictionary with the following keys:\n\n* lastLogSeqNum: the latest log sequence number of raft log.\n\n* sizeInMemory: the number of records in memory.\n\n* asynWrite: whether to persist data with asynchronous mode.\n\n* totalSize: the total number of records in the stream table.\n\n* compress: whether to save compressed data.\n\n* memoryOffset: the offset position of the first message in memory relative to all records in the stream table. memoryOffset = totalSize - sizeInMemory.\n\n* sizeOnDisk: the number of records that have been persisted to disk.\n\n* retentionMinutes: how long (in terms of minutes) the log file will be kept. The default value is 1440 minutes (1 day).\n\n* persistenceDir: the path to the persistent data.\n\n* hashValue: the identifier of the thread responsible for persisting the table to disk. If persistenceWorkerNum>1, hashValue may not be 0.\n\n* diskOffset: the offset position of the first message on disk relative to all records in the stream table.\n\n#### Examples\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt = streamTable(100:0, colName, colType);\nenableTableShareAndPersistence(table=t, tableName=`st, cacheSize=1200000)\ngo;\n\nfor(s in 0:200){\n   n=10000\n   time=2019.01.01T00:00:00.000+s*n+1..n\n   x=rand(10.0, n)\n   insert into st values(time, x)\n}\n\ngetPersistenceMeta(st);\n\n// output\nastLogSeqNum->-1\nsizeInMemory->800000\nasynWrite->true\ntotalSize->2000000\nraftGroup->-1\ncompress->true\nmemoryOffset->1200000\nretentionMinutes->1440\nsizeOnDisk->2000000\npersistenceDir->/dolphindb/server/streamPersistDir/st\nhashValue->0\ndiskOffset->0\n```\n"
    },
    "getPKEYCompactionTaskStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getPKEYCompactionTaskStatus.html",
        "signatures": [
            {
                "full": "getPKEYCompactionTaskStatus([count])",
                "name": "getPKEYCompactionTaskStatus",
                "parameters": [
                    {
                        "full": "[count]",
                        "name": "count",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getPKEYCompactionTaskStatus](https://docs.dolphindb.com/en/Functions/g/getPKEYCompactionTaskStatus.html)\n\n\n\n#### Syntax\n\ngetPKEYCompactionTaskStatus(\\[count])\n\n#### Arguments\n\n**count** (optional) is a non-negative integer that specifies how many recent completed compaction tasks (successful or failed) to report per volume. The default value is 0, indicating that all completed compaction tasks are returned.\n\n#### Details\n\nObtain the status of PKEY level file compaction tasks, including all pending tasks and completed tasks.The optional *count* limits the number of completed tasks returned. The function can only be executed on a data node.\n\n**Return value**: A table with the following columns:\n\n* volume: the volume where the compaction is performed. It is set by the configuration parameter *volumes*.\n* level: the level of files that are involved in the current compaction. An empty cell means the compaction hasn’t started, is ongoing, or failed.A compaction involves up to two levels at a time.\n* chunkId: the ID of chunk where the compaction is performed.\n* tableName: the physical name of the table where the compaction is performed.\n* files: the level files involved in the current compaction. An empty cell means the compaction hasn’t started, is ongoing, or failed.\n* force: whether the compaction is triggered by `triggerPKEYCompaction`.\n* receivedTime: the timestamp when the compaction task enqueued.\n* startTime: the timestamp when the compaction task started.\n* endTime: the timestamp when the compaction task ended.\n* errorMessage: If a task failed, the column displays the failure cause; otherwise it is left empty.\n\n#### Examples\n\n```\ngetPKEYCompactionTaskStatus()\n```\n\n| volume                                   | level | chunkId                              | tableName | files           | force | receivedTime            | startTime               | endTime                 | errorMessage |\n| ---------------------------------------- | ----- | ------------------------------------ | --------- | --------------- | ----- | ----------------------- | ----------------------- | ----------------------- | ------------ |\n| /home/dolphindb/server/local8848/storage | 2     | ac872f06-abed-339c-8642-ce7dcf415691 | pt1\\_2    | 2-000000046-002 | true  | 2024.09.24 13:52:37.746 | 2024.09.24 13:52:37.746 | 2024.09.24 13:52:37.816 |              |\n| /home/dolphindb/server/local8848/storage | 1     | ac872f06-abed-339c-8642-ce7dcf415691 | pt1\\_2    | 1-000000046-001 | true  | 2024.09.24 13:52:32.431 | 2024.09.24 13:52:32.431 | 2024.09.24 13:52:32.437 |              |\n| /home/dolphindb/server/local8848/storage | 0     | ac872f06-abed-339c-8642-ce7dcf415691 | pt1\\_2    | 0-000000046-000 | true  | 2024.09.24 11:58:42.006 | 2024.09.24 11:58:42.006 | 2024.09.24 11:58:42.011 |              |\n| /home/dolphindb/server/local8848/storage | 0     | 62ab7ebb-03f2-10a5-5445-c537512aee06 | pt1\\_2    | 0-000000045-000 | true  | 2024.09.24 11:57:13.596 | 2024.09.24 11:57:13.596 | 2024.09.24 11:57:13.601 |              |\n"
    },
    "getPKEYMetaData": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getPKEYMetaData.html",
        "signatures": [
            {
                "full": "getPKEYMetaData()",
                "name": "getPKEYMetaData",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getPKEYMetaData](https://docs.dolphindb.com/en/Functions/g/getPKEYMetaData.html)\n\n\n\n#### Syntax\n\ngetPKEYMetaData()\n\n#### Arguments\n\nNone.\n\n#### Details\n\nObtain the metadata of all chunks in the PKEY engine. The function can only be executed on a data node.\n\n**Return value**: A table with the following columns:\n\n* chunkId: the chunk ID\n* chunkPath: the physical path of the chunk\n* level: the file level\n* table: the table name\n* files: the level file name\n\n#### Examples\n\n```\ngetPKEYMetaData()\n```\n\n| chunkId                              | chunkPath                                                                     | level | table  | files           |\n| ------------------------------------ | ----------------------------------------------------------------------------- | ----- | ------ | --------------- |\n| a0a7b031-15b8-32be-664b-21b156dc94c0 | /home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200102/Key94/1B8 | 0     | pt1\\_2 | 0-000000006-000 |\n| b3307046-77cb-bbb4-2244-dc4dcdd4c4e2 | /home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200104/Key39/1B8 | 0     | pt1\\_2 | 0-000000009-000 |\n| 1b47193f-39a4-8b93-3f44-d1b32b892126 | /home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200105/Key94/1B8 | 0     | pt1\\_2 | 0-000000007-000 |\n| 65ac20af-e1ea-21a6-254a-0c7a1f4a1bcf | /home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200102/Key39/1B8 | 0     | pt1\\_2 | 0-000000003-000 |\n| 600e024e-e280-62bb-084d-b440f7ccc349 | /home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200101/Key94/1B8 | 0     | pt1\\_2 | 0-000000002-000 |\n| 4f33838b-1b90-3f84-6943-e0da5fda3e10 | /home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200104/Key94/1B8 | 0     | pt1\\_2 | 0-000000005-000 |\n| e625607d-03ce-00bc-ab47-a419ae5af3f3 | /home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200103/Key94/1B8 | 0     | pt1\\_2 | 0-000000004-000 |\n| 9e0004ea-33b5-b2b4-d947-065c9333709f | /home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200101/Key39/1B8 | 0     | pt1\\_2 | 0-000000001-000 |\n| 595d1703-88b4-4397-4b46-281eb8014251 | /home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200103/Key39/1B8 | 0     | pt1\\_2 | 0-000000008-000 |\n| 280b3b44-8006-52a8-694e-1133e8740c07 | /home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200105/Key39/1B8 | 0     | pt1\\_2 | 0-000000010-000 |\n"
    },
    "getQueryStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getQueryStatus.html",
        "signatures": [
            {
                "full": "getQueryStatus()",
                "name": "getQueryStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getQueryStatus](https://docs.dolphindb.com/en/Functions/g/getQueryStatus.html)\n\n\n\n#### Syntax\n\ngetQueryStatus()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the status of a running query initialized on the current node. Return a table with the following columns:\n\n* id: The total count of the query tasks that have been executed.\n\n* sessionId: ID of the session where the query is initialized. Please note that sessionId of the jobs submitted with `submitJob` cannot be obtained.\n\n* userId: The user who initialized the task.\n\n* query: The query statement.\n\n* startTime: The timestamp when the query starts.\n\n* elapsedTimeInMs: The elapsed time (in ms) of the query.\n\n* memoryUsage: The memory used by the variables and results of the query (in bytes).\n\n* totalTaskCount: Total count of tasks.\n\n* completedTaskCount: Count of completed tasks.\n\n* percentComplete: The completion percentage of the query.\n\nThe function can only be called on the node where a query is initialized.\n\n#### Examples\n\n```\ngetQueryStatus();\n```\n\n| id | sessionId  | userId | query                        | startTime               | elapsedTimeInMs | memoryUsage | totalTaskCount | completedTaskCount | percentComplete |\n| -- | ---------- | ------ | ---------------------------- | ----------------------- | --------------- | ----------- | -------------- | ------------------ | --------------- |\n| 2  | 1166953221 | admin  | select ticker, id, x from pt | 2022.06.14 08:15:00.606 | 1052            | 184550000   | 4              | 1                  | 0.25            |\n"
    },
    "getRaftElectionTick": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getRaftElectionTick.html",
        "signatures": [
            {
                "full": "getRaftElectionTick(groupId)",
                "name": "getRaftElectionTick",
                "parameters": [
                    {
                        "full": "groupId",
                        "name": "groupId"
                    }
                ]
            }
        ],
        "markdown": "### [getRaftElectionTick](https://docs.dolphindb.com/en/Functions/g/getRaftElectionTick.html)\n\n\n\n#### Syntax\n\ngetRaftElectionTick(groupId)\n\n#### Arguments\n\n**groupId** is a positive integer indicating the raft group ID. Currently it can only be 1, referring to the ID of the raft group composed of controllers.\n\n#### Details\n\nObtain the election tick in the specified raft group. The election tick is specified by the parameter *tickCount* of command `setRaftElectionTick` or the configuration parameter *raftElectionTick*.\n\nRelated Functions: [setRaftElectionTick](https://docs.dolphindb.com/en/Functions/s/setRaftElectionTick.html), [getControllerElectionTick](https://docs.dolphindb.com/en/Functions/g/getControllerElectionTick.html)\n"
    },
    "getReactiveMetrics": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getReactiveMetrics.html",
        "signatures": [
            {
                "full": "getReactiveMetrics(name)",
                "name": "getReactiveMetrics",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [getReactiveMetrics](https://docs.dolphindb.com/en/Functions/g/getReactiveMetrics.html)\n\n\n\n#### Syntax\n\ngetReactiveMetrics(name)\n\n#### Arguments\n\n**name**is a string indicating the engine name.\n\n#### Details\n\nGet factors specified in *metric*s of the engine generated by `createNarrowReactiveStateEngine`.\n\nIt returns a table cotaining two columns:\n\n* metricName: the name of factors.\n\n* metricCode: the detailed formula for calculations.\n\n#### Examples\n\n```\ndummy = streamTable(1:0, [\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"upToDatePrice\",\"qty\",\"value\"], [STRING,STRING,STRING,TIMESTAMP,TIMESTAMP,DOUBLE,DOUBLE,INT]) \noutputTable = streamTable(1:0,[\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"metricNames\",\"factorValue\"], [STRING,STRING,STRING, TIMESTAMP,TIMESTAMP,STRING,DOUBLE])\nfactor = [<createTime>, <updateTime>,<cumsum(qty)>]\nNarrowtest = createNarrowReactiveStateEngine(name=\"narrowtest1\",metrics=factor,metricNames=\"factor1\",dummyTable=dummy,outputTable=outputTable,keyColumn=[\"securityID1\",\"securityID2\",\"securityID3\"])\ngetReactiveMetrics(\"narrowtest1\")\n\nmetricName\tmetricCode\nfactor1     cumsum(qty)\n```\n\nRelated functions: [createNarrowReactiveStateEngine](https://docs.dolphindb.com/en/Functions/c/createNarrowReactiveStateEngine.html),[addReactiveMetrics](https://docs.dolphindb.com/en/Functions/a/addReactiveMetrics.html)\n"
    },
    "getRecentJobs": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getRecentJobs.html",
        "signatures": [
            {
                "full": "getRecentJobs(n)",
                "name": "getRecentJobs",
                "parameters": [
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [getRecentJobs](https://docs.dolphindb.com/en/Functions/g/getRecentJobs.html)\n\n\n\n#### Syntax\n\ngetRecentJobs(n)\n\n#### Arguments\n\n**n** is a positive integer. If it is unspecified, return all batch jobs since the session is started.\n\n#### Details\n\nRetrieve the status of most recent n batch jobs on the local node.\n\nIt returns a table with the following columns:\n\n| Name         | Meaning                                                                    |\n| ------------ | -------------------------------------------------------------------------- |\n| node         | the alias of the local node                                                |\n| userID       | the user ID                                                                |\n| jobId        | the job ID                                                                 |\n| rootJobId    | the root job ID                                                            |\n| jobDesc      | the job description                                                        |\n| priority     | priority of the job which is marked as integers ranging from 0 to 9        |\n| parallelism  | the parallelism, i.e., the maximum number of jobs that can run in parallel |\n| clientIp     | the IP address of the client where the job is submitted                    |\n| clientPort   | the port number of the client where the job is submitted                   |\n| receivedTime | the time (of TIMESTAMP type) when a job is received by the node            |\n| startTime    | the start time of jobs (of TIMESTAMP type)                                 |\n| endTime      | the end time of jobs (of TIMESTAMP type)                                   |\n| errorMessage | error messages                                                             |\n\nFor details please refer to [Batch Job Management](https://docs.dolphindb.com/en/Maintenance/BatchJobManagement.html).\n\n#### Examples\n\n```\ndef jobDemo(n){\n   s = 0\n   for (x in 1 : n) {\n       s += sum(sin rand(1.0, 100000000)-0.5)\n       print(\"iteration \" + x + \" \" + s)\n   }\n   return s\n};\n\nsubmitJob(\"jobDemo1\",\"job demo\", jobDemo, 100);\nsubmitJob(\"jobDemo2\",, jobDemo, 10);\ngetRecentJobs(10);\n```\n\n| node      | userID | jobId    | jobDesc  | priority | parallelism | receivedTime            | startTime               | ... |\n| --------- | ------ | -------- | -------- | -------- | ----------- | ----------------------- | ----------------------- | --- |\n| local8848 | guest  | jobDemo1 | job demo | 0        | 1           | 2021.04.28T14:20:24.879 | 2021.04.28T14:20:24.886 | ... |\n| local8848 | guest  | jobDemo2 | jobDemo  | 0        | 1           | 2021.04.28T14:20:24.886 | 2021.04.28T14:20:24.886 | ... |\n"
    },
    "getRecentSlaveReplicationInfo": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getRecentSlaveReplicationInfo.html",
        "signatures": [
            {
                "full": "getRecentSlaveReplicationInfo()",
                "name": "getRecentSlaveReplicationInfo",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getRecentSlaveReplicationInfo](https://docs.dolphindb.com/en/Functions/g/getRecentSlaveReplicationInfo.html)\n\n#### Syntax\n\ngetRecentSlaveReplicationInfo()\n\n#### Arguments\n\nNone\n\n#### Details\n\nThis function displays the latest task in each slave cluster where cluster replication is enabled. It can only be executed by an administrator on the controller of a master cluster.\n\nIt returns a table containing the following columns:\n\n* connectedController: ip:port of the controller of slave cluster.\n\n* allControllersInRaft: ip:port of each controller in a raft group for a HA cluster.\n\n* lastFinishedTaskId: ID of the last finished task.\n\n* lastPullTime: the last time when the slave cluster pulls tasks from the master cluster.\n\n#### Examples\n\n```\ngetRecentSlaveReplicationInfo()\n```\n\n| connectedController | allControllersInRaft                               | lastFinishedTaskId | lastPullTime        |\n| ------------------- | -------------------------------------------------- | ------------------ | ------------------- |\n| 192.168.2.2:1111    | 192.168.2.2:1111,192.168.2.2:1112,192.168.2.2:1113 | 233                | 2022.11.11T11:11:11 |\n\n"
    },
    "getRecoveryTaskStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getRecoveryTaskStatus.html",
        "signatures": [
            {
                "full": "getRecoveryTaskStatus()",
                "name": "getRecoveryTaskStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getRecoveryTaskStatus](https://docs.dolphindb.com/en/Functions/g/getRecoveryTaskStatus.html)\n\n\n\n#### Syntax\n\ngetRecoveryTaskStatus()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the status of recovery tasks. This function can only be executed on a controller.\n\nReturn a table containing the following columns:\n\n* TaskId: The job ID of the recovery task.\n\n* TaskType: The type of the recovery task. It can be \"LoadRebalance\" and \"ChunkRecovery\".\n\n* ChunkId: The chunk ID.\n\n* ChunkPath: The DFS path of the chunk.\n\n* Source: The source node for data recovery.\n\n* Dest: The destination node for data recovery.\n\n* Status: The status of the recovery task. It can be \"Waiting\", \"In-Progress\", and \"Finished\" or \"Aborted\".\n\n* AttemptCount: The number of recovery attempts that have been made.\n\n* DeleteSource: Whether to delete the replica on the source node. When *TaskType* is \"ChunkRecovery\", it is false. When *TaskType* is \"LoadRebalance\", it can be true or false.\n\n* StartTime: The time when the recovery task is created.\n\n* LastDequeueTime: The last time when the recovery task is dequeued.\n\n* LastStartTime: The last time when the recovery task started.\n\n* FinishTime: The time when the recovery task was finished.\n\n* IsIncrementalRecovery: Whether incremental replication is enabled.\n\n* IsAsyncRecovery: Whether asynchronous replication is enabled.\n\n* ChangeFromIncrementalToFull: Whether incremental replication has been changed to full replication. The recovery will be automatically changed to full recovery after multiple attempts for incremental recovery fail.\n\n* ChangeToSyncTime: The time when the online recovery is changed from asynchronous to synchronous.\n\n* FailureReason: The reason for the failure of the recovery tasks.\n\n#### Examples\n\n```\ngetRecoveryTaskStatus();\n```\n"
    },
    "getRecoveryWorkerNum": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getRecoveryWorkerNum.html",
        "signatures": [
            {
                "full": "getRecoveryWorkerNum()",
                "name": "getRecoveryWorkerNum",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getRecoveryWorkerNum](https://docs.dolphindb.com/en/Functions/g/getRecoveryWorkerNum.html)\n\n\n\n#### Syntax\n\ngetRecoveryWorkerNum()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the number of worker threads used by the current node for chunk recovery. It can only be executed on the data node.\n\n#### Examples\n\n```\nresetRecoveryWorkerNum(2)\ngetRecoveryWorkerNum()\n// output\n2\n```\n\nRelated functions: [resetRecoveryWorkerNum](https://docs.dolphindb.com/en/Functions/r/resetRecoveryWorkerNum.html)\n"
    },
    "getRedoLogGCStat": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getRedoLogGCStat.html",
        "signatures": [
            {
                "full": "getRedoLogGCStat()",
                "name": "getRedoLogGCStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getRedoLogGCStat](https://docs.dolphindb.com/en/Functions/g/getRedoLogGCStat.html)\n\n\n\n#### Syntax\n\ngetRedoLogGCStat()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the status of garbage collection of the redo log. Return a table containing the following columns:\n\n* physicalName: physical name of the table in the format of */\\<databaseName>/\\<physicalName>*.\n\n* txnCount: the number of transactions that have not been garbage-collected.\n\n* numOfTxnPendingGC: the number of transactions that can be garbage-collected.\n\n* minTidPendingGC: the minimum tid (transaction ID) of the transactions that can be garbage-collected.\n\n* numOfTxnPendingFlush: the number of transactions that can be flushed to disk from the cache engine.\n\n* minTidPendingFlush: the minimum tid of the transactions that can be flushed to disk from the cache engine.\n\n#### Examples\n\n```\ngetRedoLogGCStat()\n```\n\n| physicalName  | txnCount | numOfTxnPendingGC | minTidPendingGC | numOfTxnPendingFlush | minTidPendingFlush |\n| ------------- | -------- | ----------------- | --------------- | -------------------- | ------------------ |\n| /test/pt\\_2   | 2        | 0                 |                 | 2                    | 1031               |\n| /listdb/pt\\_2 | 1        | 1                 | 1033            | 0                    |                    |\n"
    },
    "getRegisteredNodeInfo": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getRegisteredNodeInfo.html",
        "signatures": [
            {
                "full": "getRegisteredNodeInfo()",
                "name": "getRegisteredNodeInfo",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getRegisteredNodeInfo](https://docs.dolphindb.com/en/Functions/g/getRegisteredNodeInfo.html)\n\n#### Syntax\n\ngetRegisteredNodeInfo()\n\n#### Arguments\n\nNone\n\n#### Details\n\nThis function obtains information regarding nodes registered on the license server and the physical machine on which the node resides. This function can only be executed on a license server. It returns a table with the following columns:\n\n* type: node or machine.\n\n* host: the host address.\n\n* port: the port number of the node (or empty for a machine).\n\n* alias: the node alias (or empty for a machine).\n\n* usedMem: memory (in GB) already used on the node or machine.\n\n* usedCores: CPU cores that are already bound on the node or machine.\n\n* bindCores: CPU ID(s) that are already bound on the node or machine.\n\n* lastUpdate: the last time when resources are allocated to the node (or nodes on the machine).\n\n#### Examples\n\n```\ngetRegisteredNodeInfo()\n// output\ntype        host            port    alias           usedMem      usedCores  bindCores       lastUpdate\nnode        10.6.0.12       33,795  test33          4            2                          2023.02.15T15:23:54.487\nnode        10.6.0.12       33,785  datanode3       4            2                          2023.02.15T15:11:48.454\nmachine     10.6.0.12                               8            4                          2023.02.15T15:23:54.487\nnode        10.6.0.11       33,782  datanode1       4            2                          2023.02.15T11:47:27.534\nnode        10.6.0.11       33,780  controller1     4            2                          2023.02.15T11:30:07.358\nmachine     10.6.0.11                               8            4                          2023.02.15T11:47:27.534\n```\n"
    },
    "getRightStream": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getRightStream.html",
        "signatures": [
            {
                "full": "getRightStream(joinEngine)",
                "name": "getRightStream",
                "parameters": [
                    {
                        "full": "joinEngine",
                        "name": "joinEngine"
                    }
                ]
            }
        ],
        "markdown": "### [getRightStream](https://docs.dolphindb.com/en/Functions/g/getRightStream.html)\n\n\n\n#### Syntax\n\ngetRightStream(joinEngine)\n\n#### Arguments\n\n**joinEngine** is a table object returned by creating a join engine. The join engines currently supported by DolphinDB are:\n\n* createAsofJoinEngine\n\n* createEquiJoinEngine\n\n* createLookupJoinEngine\n\n* createWindowJoinEngine\n\n* createLeftSemiJoinEngine\n\n#### Details\n\nReturn the schema of the right table of the join engine. The data ingested into this schema will be inserted into *joinEngine*.\n\nThe result of an engine can be directly ingested into the join engine to realize the cascade between engines.\n\nPlease refer to [getLeftStream](https://docs.dolphindb.com/en/Functions/g/getLeftStream.html) for specific examples.\n"
    },
    "getRules": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getRules.html",
        "signatures": [
            {
                "full": "getRules([engineName])",
                "name": "getRules",
                "parameters": [
                    {
                        "full": "[engineName]",
                        "name": "engineName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getRules](https://docs.dolphindb.com/en/Functions/g/getRules.html)\n\n\n\n#### Syntax\n\ngetRules(\\[engineName])\n\n#### Arguments\n\n**engineName** (optional) is a STRING vector indicating the rule engine name(s). If unspecified, the function returns the rules of all rule engines on the current node.\n\n#### Details\n\nGet the rules of the specified rule engine, including the rule set, checking policy, and callback function.\n\n**Return value**: A dictionary whose key is the engine name and value is another dictionary containing:\n\n* ruleSets: A dictionaryindicating the rule sets of the engine, where:\n  * key: Rule name. Return a default rule set with the key “Default“.\n  * value: Specific rules.\n* policy: The checking policy of the engine.\n* callback: The callback function of the engine. If unspecified, it is an empty string.\n\n#### Examples\n\n```\n// Specify the rule set\nx = [1, 2, NULL]\ny = [ [ < value > 1 > ], [ < price < 2 >, < price > 6 > ], [ < value*price > 10 > ] ]\nruleSets = dict(x, y)\n\n// Create rule engines\nnames = `sym`value`price`quantity\ntypes = [INT, DOUBLE, DOUBLE, DOUBLE]\ndummy = table(1:0, names, types)\noutputNames = `sym`value`price`rule\noutputTypes = [INT, DOUBLE, DOUBLE, BOOL[]]\noutputTable = table(10:0, outputNames, outputTypes)\ntest = createRuleEngine(name=\"ruleEngineTest\", ruleSets=ruleSets, dummyTable=dummy, outputColumns=[\"sym\",\"value\",\"price\"], outputTable=outputTable, policy=\"all\", ruleSetColumn=\"sym\")\ntest2 = createRuleEngine(name=\"ruleEngineTest2\", ruleSets=ruleSets, dummyTable=dummy, outputColumns=[\"sym\",\"value\",\"price\"], outputTable=outputTable, policy=\"all\", ruleSetColumn=\"sym\")\n\n// Query the rules of the specified engine\ngetRules([\"ruleEngineTest\"])\n/*\nruleEngineTest->\n    ruleSets->\n        Default->(value * price > 10)\n        1->(value > 1)\n        2->(price < 2, price > 6)\n\n    policy->all\n    callback->\n*/\n\n// Update the rules of the specified engine\nupdateRule(\"ruleEngineTest\", 1, [<value > 2>])\n\n// Query the rules again after update\ngetRules()\n/*\nruleEngineTest->\n    ruleSets->\n        Default->(value * price > 10)\n        1->(value > 2)\n        2->(price < 2, price > 6)\n\n    policy->all\n    callback->\n*/\n```\n\nRelated functions: [createRuleEngine](https://docs.dolphindb.com/en/Functions/c/createRuleEngine.html), [updateRule](https://docs.dolphindb.com/en/Functions/u/updateRule.html), and [deleteRule](https://docs.dolphindb.com/en/Functions/d/deleteRule.html).\n"
    },
    "getRunningQueries": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getRunningQueries.html",
        "signatures": [
            {
                "full": "getRunningQueries()",
                "name": "getRunningQueries",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getRunningQueries](https://docs.dolphindb.com/en/Functions/g/getRunningQueries.html)\n\n\n\n#### Syntax\n\ngetRunningQueries()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn descriptive information about the SQL queries that are being executed on the local node. It returns a table with the following columns:\n\n| Name      | Meaning                                                                                                                                              |\n| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| userID    | the user ID                                                                                                                                          |\n| sessionID | the session ID                                                                                                                                       |\n| jobID     | the job ID                                                                                                                                           |\n| rootID    | the root job ID                                                                                                                                      |\n| level     | the level of jobs. The root job starts from level 0, the tasks broken down from the root job are marked as level 1, and subtasks level 2, and so on. |\n| startTime | the start time of a query (of NANOTIMESTAMP type)                                                                                                    |\n| endTime   | the end time of a query (of NANOTIMESTAMP type)                                                                                                      |\n| jobDesc   | the job description                                                                                                                                  |\n| errorMsg  | error messages                                                                                                                                       |\n| remoteIP  | the IP address of the client that initiates a query                                                                                                  |\n\nTo use this function, we must set *perfMonitoring*=1 in the configuration file to enable performance monitoring.\n\n#### Examples\n\n```\ngetRunningQueries();\n```\n\n| userID | sessionID | jobID                                | rootID                               | level | startTime                     | endTime | jobDesc                           | errorMsg | remoteIP      |\n| ------ | --------- | ------------------------------------ | ------------------------------------ | ----- | ----------------------------- | ------- | --------------------------------- | -------- | ------------- |\n| admin  | 738481026 | 88e738a8-a749-4dcb-9cfe-740df2d9ce7d | 88e738a8-a749-4dcb-9cfe-740df2d9ce7d | 0     | 2019.02.07T19:02:26.809905612 |         | select count(\\*) as count from pt |          | 192.168.1.106 |\n"
    },
    "getScheduledJobs": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getScheduledJobs.html",
        "signatures": [
            {
                "full": "getScheduledJobs([jobIdPattern])",
                "name": "getScheduledJobs",
                "parameters": [
                    {
                        "full": "[jobIdPattern]",
                        "name": "jobIdPattern",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getScheduledJobs](https://docs.dolphindb.com/en/Functions/g/getScheduledJobs.html)\n\n\n\n#### Syntax\n\ngetScheduledJobs(\\[jobIdPattern])\n\n#### Arguments\n\n**jobIdPattern** is a string indicating a job ID or a pattern of job ID. It supports wildcard characters (% and ?).\n\n#### Details\n\nReturn a table of scheduled jobs. If *jobIdPattern* is not specified, return all scheduled jobs.\n\nIt returns a table with the following columns:\n\n| Name          | Meaning                                                                         |\n| ------------- | ------------------------------------------------------------------------------- |\n| userId        | the user ID                                                                     |\n| jobId         | the job ID                                                                      |\n| jobDesc       | the job description                                                             |\n| startDate     | the start date of the scheduled job (of DATE type)                              |\n| endDate       | the end date of the scheduled job (of DATE type)                                |\n| frequency     | the frequency to execute the scheduled job                                      |\n| scheduledTime | the specified time to execute each job (of MINUTE type)                         |\n| days          | the specified days to execute the scheduled job when *frequency* is 'W' or 'M'. |\n\n#### Examples\n\n```\ngetScheduledJobs();\n```\n\n| userId | jobId   | jobDesc     | startDate  | endDate    | frequency | scheduleTime | days |\n| ------ | ------- | ----------- | ---------- | ---------- | --------- | ------------ | ---- |\n| root   | monthly | Monthly Job | 2018.01.01 | 2018.12.31 | M         | 17:00m       | 1    |\n| root   | weekly  | Weekly Job  | 2018.01.01 | 2018.12.31 | W         | 17:30m       | 2    |\n| root   | daily   | Daily Job   | 2018.01.01 | 2018.12.31 | D         | 18:00m       |      |\n"
    },
    "getSchemaByCatalog": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getSchemaByCatalog.html",
        "signatures": [
            {
                "full": "getSchemaByCatalog(catalog)",
                "name": "getSchemaByCatalog",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    }
                ]
            }
        ],
        "markdown": "### [getSchemaByCatalog](https://docs.dolphindb.com/en/Functions/g/getSchemaByCatalog.html)\n\n#### Syntax\n\ngetSchemaByCatalog(catalog)\n\n#### Arguments\n\n**catalog**is a string specifying the catalog name.\n\n#### Details\n\nGet schemas within a catalog.\n\n**Return value**: A table containing the schema name and dbUrl.\n\n#### Examples\n\n```\ngetSchemasByCatalog(\"catalog1\")\n```\n\n| schema  | dbUrl      |\n| ------- | ---------- |\n| schema1 | dfs\\://db1 |\n| schema2 | dfs\\://db2 |\n\n"
    },
    "getSessionMemoryStat": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getSessionMemoryStat.html",
        "signatures": [
            {
                "full": "getSessionMemoryStat()",
                "name": "getSessionMemoryStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getSessionMemoryStat](https://docs.dolphindb.com/en/Functions/g/getSessionMemoryStat.html)\n\n\n\n#### Syntax\n\ngetSessionMemoryStat()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn information about memory usage of all sessions on the current node. It returns a table containing the following columns:\n\n* userId: the user ID or the cache type (in the format of \\_\\_xxx\\_\\_).\n\n* sessionId: the session ID.\n\n* memSize: memory usage of all sessions (in Bytes).\n\n* remoteIP: the IP address of the client that initiates the session.\n\n* remotePort: the port number of the client that initiates the session.\n\n* createTime: the creation time (of TIMESTAMP data type) of session.\n\n* lastActiveTime: last timestamp of the execution.\n\nThe cache type can be:\n\n| Cache Types                  | Meaning                                                            |\n| ---------------------------- | ------------------------------------------------------------------ |\n| \\_\\_DimensionalTable\\_\\_     | the cache of dimension tables (in Bytes)                           |\n| \\_\\_SharedTable\\_\\_          | the cache of shared tables (in Bytes)                              |\n| \\_\\_OLAPTablet\\_\\_           | the cache of the OLAP databases (in Bytes)                         |\n| \\_\\_OLAPCacheEngine\\_\\_      | the memory usage of OLAP cache engine (in Bytes)                   |\n| \\_\\_OLAPCachedSymbolBase\\_\\_ | the cache of SYMBOL base in OLAP engine (in Bytes)                 |\n| \\_\\_DFSMetadata\\_\\_          | the memory usage of DFS metadata in distributed storage (in Bytes) |\n| \\_\\_TSDBCacheEngine\\_\\_      | the cache of the TSDB engine (in Bytes)                            |\n| \\_\\_TSDBLevelFileIndex\\_\\_   | the cache of level file index in the TSDB engine (in Bytes)        |\n| \\_\\_TSDBCachedSymbolBase\\_\\_ | the cache of SYMBOL base in TSDB engine (in Bytes)                 |\n| \\_\\_StreamingPubQueue\\_\\_    | the unprocessed messages in a publisher queue                      |\n| \\_\\_StreamingSubQueue\\_\\_    | the unprocessed messages in a subscriber queue                     |\n\nNote:\n\n* This function does not return the memory occupied by tasks being executed in the session.\n\n* For the columns *createTime* and *lastActiveTime* in the result table, versions before 1.30.21.4/2.00.9.4 return GMT time. From version 1.30.21.4/2.00.9.4 onwards, these columns return time in your current time zone.\n\n#### Examples\n\n```\nt = getSessionMemoryStat();\nt;\n```\n\n| userId                       | sessionId  | memSize | remoteIP     | remotePort | createTime              | lastActiveTime          |\n| ---------------------------- | ---------- | ------- | ------------ | ---------- | ----------------------- | ----------------------- |\n| \\_\\_DimensionalTable\\_\\_     | 0          | 0.0.0.0 |              |            |                         |                         |\n| \\_\\_SharedTable\\_\\_          | 0          | 0.0.0.0 |              |            |                         |                         |\n| \\_\\_OLAPTablet\\_\\_           | 0          | 0.0.0.0 |              |            |                         |                         |\n| \\_\\_OLAPCacheEngine\\_\\_      | 0          | 0.0.0.0 |              |            |                         |                         |\n| \\_\\_OLAPCachedSymbolBase\\_\\_ | 0          | 0.0.0.0 |              |            |                         |                         |\n| \\_\\_DFSMetadata\\_\\_          | 2769       | 0.0.0.0 |              |            |                         |                         |\n| \\_\\_TSDBCacheEngine\\_\\_      | 0          | 0.0.0.0 |              |            |                         |                         |\n| \\_\\_TSDBLevelFileIndex\\_\\_   | 0          | 0.0.0.0 |              |            |                         |                         |\n| \\_\\_TSDBCachedSymbolBase\\_\\_ | 0          | 0.0.0.0 |              |            |                         |                         |\n| \\_\\_StreamingPubQueue\\_\\_    | 0          | 0.0.0.0 |              |            |                         |                         |\n| \\_\\_StreamingSubQueue\\_\\_    | 0          | 0.0.0.0 |              |            |                         |                         |\n| admin                        | 2882591513 | 1416    | 60.176.105.0 | 20861      | 2023.02.15T02:15:22.384 | 2023.02.15T02:24:16.307 |\n"
    },
    "getSlaveReplicationQueueStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getSlaveReplicationQueueStatus.html",
        "signatures": [
            {
                "full": "getSlaveReplicationQueueStatus()",
                "name": "getSlaveReplicationQueueStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getSlaveReplicationQueueStatus](https://docs.dolphindb.com/en/Functions/g/getSlaveReplicationQueueStatus.html)\n\n#### Syntax\n\ngetSlaveReplicationQueueStatus()\n\n#### Arguments\n\nNone\n\n#### Details\n\nThe function obtains the status of each execution queue in the slave cluster of asynchronous replication, and returns a table containing the following columns:\n\n* executionSet: the execution set ID to which the task belongs.\n\n* queueId: ID of the execution queue to which the replication task belongs.\n\n* unfinishedTasks: the number of unfinished tasks in the queue.\n\n* executionGroupId: ID of the group to which the running replication task belongs.\n\n* executionNode: the data node where the task is executed.\n\n* executionTime: the time spent by the current group executing replication tasks.\n\n* status: the task status, including EXECUTING, FINISHED, STOPPED and FAILED.\n\n#### Examples\n\n```\ngetSlaveReplicationQueueStatus()\n```\n\n| queueId | unfinishedTasks | executionGroupId | executionNode | executionTime | status   |\n| :------ | :-------------- | :--------------- | :------------ | :------------ | :------- |\n| 0       | 0               | -1               | dnode1        | 00:00:00.000  | FINISHED |\n| 1       | 0               | -1               | dnode2        | 00:00:00.000  | FINISHED |\n\nRelated functions: [getSlaveReplicationStatus](https://docs.dolphindb.com/en/Functions/g/getSlaveReplicationStatus.html), [getMasterReplicationStatus](https://docs.dolphindb.com/en/Functions/g/getMasterReplicationStatus.html)\n\n"
    },
    "getSlaveReplicationStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getSlaveReplicationStatus.html",
        "signatures": [
            {
                "full": "getSlaveReplicationStatus([limit=-1])",
                "name": "getSlaveReplicationStatus",
                "parameters": [
                    {
                        "full": "[limit=-1]",
                        "name": "limit",
                        "optional": true,
                        "default": "-1"
                    }
                ]
            }
        ],
        "markdown": "### [getSlaveReplicationStatus](https://docs.dolphindb.com/en/Functions/g/getSlaveReplicationStatus.html)\n\n#### Syntax\n\ngetSlaveReplicationStatus(\\[limit=-1])\n\n#### Arguments\n\n**limit** (optional) is an integer that specifies the maximum tasks that can be returned in the result. The default value is -1, meaning no limit is placed.\n\n#### Details\n\nThis function displays the cluster replication task status in the slave cluster. It returns a table where finished tasks are listed first, then followed by unfinished tasks.\n\n* If *limit* is not specified, there is no limit on the number of tasks returned.\n\n* If *limit* is specified, up to *limit* records (including finished and unfinished tasks) can be returned.\n\nA maximum of 10,000 records of finished tasks are returned, and the unfinished tasks are displayed from the earliest time until the specified number of records is met.\n\nIt can only be executed by an administrator on the controller of a slave cluster.\n\nIt returns a table containing the following columns:\n\n* taskId: ID of asynchronous replication task.\n\n* masterTid: transaction ID in the master cluster.\n\n* groupId: ID of the group to which the asynchronous replication task belongs.\n\n* queueId: ID of the execution queue to which the replication task belongs.\n\n* operationType: operation type of the replication task.\n\n* createTime: the time (of NANOTIMESTAMP type) when the slave cluster receives the task from the master cluster.\n\n* dbName: the database name where the task is executed.\n\n* tableName: the table name where the task is executed.\n\n* srcIP: IP of the data node where data of write tasks is stored.\n\n* srcPort: port of the data node where data of write tasks is stored.\n\n* finishTime: the time (of NANOTIMESTAMP type) when the task is finished.\n\n* executionNode: the data node where the task is executed.\n\n* state: the task state, including WAITING, EXECUTING, FINISHED, and FAILED.\n\n* details: If state = FAILED, returns the failure cause; If state = FINISHED, provides additional description on the task.\n\n#### Examples\n\n```\ngetSlaveReplicationStatus();\n```\n\n| taskId | masterTid | groupId | queueId | operationType              | createTime                    | dbName                          | tableName | srcIP     | srcPort | finishTime                    | executionNode | state    | details |\n| ------ | --------- | ------- | ------- | -------------------------- | ----------------------------- | ------------------------------- | --------- | --------- | ------- | ----------------------------- | ------------- | -------- | ------- |\n| 1      | 1         | 1       | 0       | CREATE\\_DOMAIN             | 2022.11.08T10:50:37.425056956 | db://test\\_dropPartition\\_value |           | localhost | 8002    | 2022.11.08T10:50:37.452792885 | NODE2         | FINISHED |         |\n| 2      | 2         | 2       | 1       | CREATE\\_PARTITIONED\\_TABLE | 2022.11.08T10:50:37.425056988 | db://test\\_dropPartition\\_value | pt        | localhost | 8002    | 2022.11.08T10:50:37.479906033 | NODE3         | FINISHED |         |\n| 3      | 3         | 3       | 2       | APPEND                     | 2022.11.08T10:50:37.425057012 | db://test\\_dropPartition\\_value | pt        | localhost | 8002    | 2022.11.08T10:50:37.638746819 | NODE1         | FINISHED |         |\n| 4      | 4         | 4       | 3       | DROP\\_PARTITION            | 2022.11.08T10:50:37.425057037 |                                 | pt        | localhost | 8002    | 2022.11.08T10:50:37.869783336 | NODE2         | FINISHED |         |\n\nRelated functions: [getMasterReplicationStatus](https://docs.dolphindb.com/en/Functions/g/getMasterReplicationStatus.html)\n\n"
    },
    "getSnapshotMsgId": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getSnapshotMsgId.html",
        "signatures": [
            {
                "full": "getSnapshotMsgId(engine)",
                "name": "getSnapshotMsgId",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    }
                ]
            }
        ],
        "markdown": "### [getSnapshotMsgId](https://docs.dolphindb.com/en/Functions/g/getSnapshotMsgId.html)\n\n\n\n#### Syntax\n\ngetSnapshotMsgId(engine)\n\n#### Arguments\n\n**engine** is a built-in streaming engine, i.e., the abstract table object return by functions such as [createReactiveStateEngine](https://docs.dolphindb.com/en/Functions/c/createReactiveStateEngine.html).\n\n#### Details\n\nGet the message ID (msgId) of the last snapshot of the specified streaming engine when resubscibing after an interruption of subscription. If snapshot is enabled, during resubscription the parameter *offset* of function [subscribeTable](https://docs.dolphindb.com/en/Functions/s/subscribeTable.html) is set to `getSnapshotMsgId(engine)+1`. The streaming engine will load the snapshot and start to subcribe from the next message after `getSnapshotMsgId(engine)`.\n"
    },
    "getStreamEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getStreamEngine.html",
        "signatures": [
            {
                "full": "getStreamEngine(name)",
                "name": "getStreamEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [getStreamEngine](https://docs.dolphindb.com/en/Functions/g/getStreamEngine.html)\n\n\n\n#### Syntax\n\ngetStreamEngine(name)\n\n#### Arguments\n\n**name** is a string indicating the name of the stream engine. It is the only identifier of the stream engine. It can have letter, number and \"\\_\". It must start with a letter.\n\n#### Details\n\nReturn the handle of a stream engine. It can be used as the handler of [subscribeTable](https://docs.dolphindb.com/en/Functions/s/subscribeTable.html).\n\n#### Examples\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\noutputTable = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\ntradesAggregator = createTimeSeriesEngine(\"StreamAggregatorDemo\",3, 3, <[sum(qty)]>, trades, outputTable, `time, false,`sym, 50)\nsubscribeTable(, \"trades\", \"tradesAggregator\", 0, append!{tradesAggregator}, true)\n\ndef writeData(n){\n   timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n   symv =take(`A`B, n)\n   qtyv = take(1, n)\n   insert into trades values(timev, symv, qtyv)\n}\n\nwriteData(6);\nh = getStreamEngine(\"StreamAggregatorDemo\")\n```\n"
    },
    "getStreamEngineList": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getStreamEngineList.html",
        "signatures": [
            {
                "full": "getStreamEngineList()",
                "name": "getStreamEngineList",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getStreamEngineList](https://docs.dolphindb.com/en/Functions/g/getStreamEngineList.html)\n\n\n\n#### Syntax\n\ngetStreamEngineList()\n\n#### Arguments\n\nNone.\n\n#### Details\n\nGet information about all streaming engines on the current node. Return a table with the following columns:\n\n* engineType: the type of the engine.\n* engineName: the name of the engine.\n* user: the engine creator.\n\n#### Examples\n\nIf the current node contains three engines - one time-series engine and one window join engine created by admin, and one reactive state engine created by user1 - `getStreamEngineList` will return info of all three engines as follows.\n\n```\ngetStreamEngineList()\n```\n\n| engineType           | engineName   | user  |\n| -------------------- | ------------ | ----- |\n| ReactiveStreamEngine | reactiveDemo | user1 |\n| WindowJoinEngine     | test1        | admin |\n| TimeSeriesEngine     | engine1      | admin |\n"
    },
    "getStreamEngineStat": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getStreamEngineStat.html",
        "signatures": [
            {
                "full": "getStreamEngineStat()",
                "name": "getStreamEngineStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getStreamEngineStat](https://docs.dolphindb.com/en/Functions/g/getStreamEngineStat.html)\n\n\n\n#### Syntax\n\ngetStreamEngineStat()\n\nAlias: getAggregatorStat\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn a dictionary of tables with various metrics about all stream engines.\n\n* Table *TimeSeriesEngine* returns the following columns about time-series engines:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | windowTime        | the length of the data window                                                       |\n  | step              | the duration between 2 adjacent calculations                                        |\n  | useSystemTime     | whether the stream engine is triggered as soon as data are injested into the system |\n  | garbageSize       | the threshold of the number of records in memory that triggers memory cleaning      |\n  | numGroups         | the number of groups that the stream engine has handled                             |\n  | numRows           | the number of records that has entered the stream engine                            |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n  | snapshotDir       | the directory to save engine snapshot                                               |\n  | snapshotInterval  | the interval to save snapshot                                                       |\n  | snapshotMsgId     | the msgId of engine snapshot                                                        |\n  | snapshotTimestamp | the timestamp of snapshot                                                           |\n\n* Table *CrossSectionalEngine* returns the following columns about cross-sectional engines:\n\n  | Column Name        | Description                                                                  |\n  | ------------------ | ---------------------------------------------------------------------------- |\n  | name               | name of the stream engine                                                    |\n  | user               | name of the user who created the stream engine                               |\n  | status             | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable |\n  | lastErrMsg         | the latest error message                                                     |\n  | numRows            | the number of records that has entered the stream engine                     |\n  | numMetrics         | the number of metrics calculated by the stream engine                        |\n  | metrics            | the metacode of the metrics calculated by the stream engine                  |\n  | triggeringPattern  | how calculations are triggered                                               |\n  | triggeringInterval | the duration in milliseconds between 2 adjacent calculations                 |\n  | memoryUsed         | the amount of memory used                                                    |\n\n* Table *AnomalyDetectionEngine* returns the following columns about the anomaly detection engines:\n\n  | Column Name       | Description                                                                    |\n  | ----------------- | ------------------------------------------------------------------------------ |\n  | name              | name of the stream engine                                                      |\n  | user              | name of the user who created the stream engine                                 |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable   |\n  | lastErrMsg        | the latest error message                                                       |\n  | numGroups         | the number of groups that the stream engine has handled                        |\n  | numRows           | the number of records that has entered the stream engine                       |\n  | numMetrics        | the number of metrics calculated by the stream engine                          |\n  | metrics           | the metacode of the metrics calculated by the stream engine                    |\n  | snapshotDir       | the directory to save engine snapshot                                          |\n  | snapshotInterval  | the interval to save snapshot                                                  |\n  | snapshotMsgId     | the msgId of engine snapshot                                                   |\n  | snapshotTimestamp | the timestamp of snapshot                                                      |\n  | garbageSize       | the threshold of the number of records in memory that triggers memory cleaning |\n  | memoryUsed        | the amount of memory used                                                      |\n\n* Table *ReactiveStateEngine* returns the following columns about the reactive state engines:\n\n  | Column Name                | Description                                                                                                                                              |\n  | -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n  | name                       | name of the reactive state engine                                                                                                                        |\n  | metrics                    | the metacode specifying the formulas for calculation                                                                                                     |\n  | dummyTable                 | a table object whose schema must be the same as the subscribed stream table                                                                              |\n  | outputTable                | the output table for the results                                                                                                                         |\n  | keyColumn                  | the grouping column(s)                                                                                                                                   |\n  | filter                     | the metacode indicating the filtering conditions in the form of expression                                                                               |\n  | snapshotDir                | the number of metrics calculated by the stream engine                                                                                                    |\n  | snapshotIntervalInMsgCount | the number of messages to receive before the next snapshot is saved                                                                                      |\n  | keepOrder                  | whether to preserve the insertion order of the records in the output table                                                                               |\n  | keyPurgeFilter             | the filtering conditions that identify the data to be purged from the cache                                                                              |\n  | keyPurgeFreqInSecond       | the time interval (in seconds) to trigger a purge                                                                                                        |\n  | raftGroup                  | the ID of the raft group on the high-availability streaming subscriber specified by the configuration parameter *streamingRaftGroups*                    |\n  | outputElapsedMicroseconds  | whether to output the elapsed time (in microseconds) from the ingestion of data to the output of result in each batch and the total number of each batch |\n\n* Table *SessionWindowEngine* returns the following columns about the session window engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | sessionGap        | gap between 2 session windows                                                       |\n  | useSystemTime     | whether the stream engine is triggered as soon as data are ingested into the system |\n  | numGroups         | the number of groups that the stream engine has handled                             |\n  | numRows           | the number of records that has entered the stream engine                            |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | Metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n  | snapshotDir       | the directory to save snapshot                                                      |\n  | snapshotInterval  | the interval to save snapshot                                                       |\n  | snapshotMsgId     | the message ID (msgId) of engine snapshot                                           |\n  | snapshotTimestamp | the timestamp of snapshot                                                           |\n\n* Table *DailyTimeSeriesEngine* returns the following columns about the daily time series engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | windowTime        | the length of the window                                                            |\n  | step              | the duration between 2 adjacent calculations                                        |\n  | useSystemTime     | whether the stream engine is triggered as soon as data are injected into the system |\n  | garbageSize       | the threshold of the number of records in memory that triggers memory cleaning      |\n  | numGroups         | the number of groups that the stream engine has handled                             |\n  | numRows           | the number of records that has entered the stream engine                            |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n  | snapshotDir       | the directory to save snapshot                                                      |\n  | snapshotInterval  | the interval to save snapshot                                                       |\n  | snapshotMsgId     | the message ID (msgId) of engine snapshot                                           |\n  | snapshotTimestamp | the timestamp of snapshot                                                           |\n\n* Table *AsofJoinEngine* returns the following columns about the as of join engine:\n\n  | Column Name       | Description                                                                    |\n  | ----------------- | ------------------------------------------------------------------------------ |\n  | name              | name of the stream engine                                                      |\n  | user              | name of the user who created the stream engine                                 |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable   |\n  | lastErrMsg        | the latest error message                                                       |\n  | useSystemTime     | the value of parameter useSystemTime in function createAsofJoinEngine          |\n  | delayedTime       | the value of parameter delayedTime in function createAsofJoinEngine            |\n  | garbageSize       | the threshold of the number of records in memory that triggers memory cleaning |\n  | leftTableNumRows  | the number of records in the left table of stream engine                       |\n  | rightTableNumRows | the number of records in the right table of stream engine                      |\n  | numMetrics        | the number of metrics calculated by the stream engine                          |\n  | metrics           | the metacode of the metrics calculated by the stream engine                    |\n  | memoryUsed        | the amount of memory used                                                      |\n\n* Table *EquiJoinEngine* returns the following columns about the equi join engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | garbageSize       | whether the stream engine is triggered as soon as data are ingested into the system |\n  | leftTableNumRows  | the number of records that has entered the left table of the stream engine          |\n  | rightTableNumRows | the number of records that has entered the right table of the stream engine         |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n\n* Table *WindowJoinEngine* returns the following columns about the window join engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | garbageSize       | whether the stream engine is triggered as soon as data are ingested into the system |\n  | leftTableNumRows  | the number of records that has entered the left table of the stream engine          |\n  | rightTableNumRows | the number of records that has entered the right table of the stream engine         |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n\n* Table *LookupJoinEngine* returns the following columns about the lookup join engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | garbageSize       | whether the stream engine is triggered as soon as data are ingested into the system |\n  | leftTableNumRows  | the number of records that has entered the left table of the stream engine          |\n  | rightTableNumRows | the number of records that has entered the right table of the stream engine         |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n\n* Table *LeftSemiJoinEngine* returns the following columns about the left semi join engine:\n\n  | Column Name       | Description                                                                         |\n  | ----------------- | ----------------------------------------------------------------------------------- |\n  | name              | name of the stream engine                                                           |\n  | user              | name of the user who created the stream engine                                      |\n  | status            | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable        |\n  | lastErrMsg        | the latest error message                                                            |\n  | garbageSize       | whether the stream engine is triggered as soon as data are ingested into the system |\n  | leftTableNumRows  | the number of records that has entered the left table of the stream engine          |\n  | rightTableNumRows | the number of records that has entered the right table of the stream engine         |\n  | numMetrics        | the number of metrics calculated by the stream engine                               |\n  | metrics           | the metacode of the metrics calculated by the stream engine                         |\n  | memoryUsed        | the amount of memory used                                                           |\n\n* Table *DualOwnershipReactiveStateEngine* returns the following columns about the dual ownership reactive state engine:\n\n  | Column Name                | Description                                                                                                                                              |\n  | -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n  | name                       | name of the engine                                                                                                                                       |\n  | metrics                    | the metacode specifying the formulas for calculation                                                                                                     |\n  | dummyTable                 | a table object whose schema must be the same as the subscribed stream table                                                                              |\n  | outputTable                | the output table for the results                                                                                                                         |\n  | keyColumn                  | the grouping column(s)                                                                                                                                   |\n  | filter                     | the metacode indicating the filtering conditions in the form of expression                                                                               |\n  | snapshotDir                | the number of metrics calculated by the stream engine                                                                                                    |\n  | snapshotIntervalInMsgCount | the number of messages to receive before the next snapshot is saved                                                                                      |\n  | keepOrder                  | whether to preserve the insertion order of the records in the output table                                                                               |\n  | keyPurgeFilter             | the filtering conditions that identify the data to be purged from the cache                                                                              |\n  | keyPurgeFreqInSecond       | the time interval (in seconds) to trigger a purge                                                                                                        |\n  | raftGroup                  | the ID of the raft group on the high-availability streaming subscriber specified by the configuration parameter *streamingRaftGroups*                    |\n  | outputElapsedMicroseconds  | whether to output the elapsed time (in microseconds) from the ingestion of data to the output of result in each batch and the total number of each batch |\n\n* Table *NarrowReactiveStateEngine* returns the following columns about the narrow reactive state engine:\n\n  | Column Name               | Description                                                                                                                                               |\n  | ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n  | name                      | name of the engine                                                                                                                                        |\n  | metrics                   | metacode or a tuple of metacode containing columns from the input table (excluding *keyColumn*, optional) or factors (formulas for calculation, required) |\n  | metricNames               | the name for each factor specified in *metrics*                                                                                                           |\n  | dummyTable                | a table object whose schema must be the same as the subscribed stream table                                                                               |\n  | outputTable               | the output table for the results                                                                                                                          |\n  | keyColumn                 | the grouping column(s)                                                                                                                                    |\n  | filter                    | the metacode indicating the filtering conditions in the form of expression                                                                                |\n  | keepOrder                 | whether to preserve the insertion order of the records in the output table                                                                                |\n  | keyPurgeFilter            | the filtering conditions that identify the data to be purged from the cache                                                                               |\n  | keyPurgeFreqInSecond      | the time interval (in seconds) to trigger a purge                                                                                                         |\n  | outputElapsedMicroseconds | whether to output the elapsed time (in microseconds) from the ingestion of data to the output of result in each batch and the total number of each batch  |\n\n* Table *StreamFilter* returns the following columns about stream filter:\n\n  | Column Name | Description                                                                  |\n  | ----------- | ---------------------------------------------------------------------------- |\n  | name        | name of the stream engine                                                    |\n  | user        | name of the user who created the stream engine                               |\n  | status      | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable |\n  | lastErrMsg  | the latest error message                                                     |\n  | numRows     | the number of records that has entered the stream engine                     |\n  | filters     | the filtering condition                                                      |\n\n* Table *StreamDispatchEngine* returns the following columns about stream dispatch engines:\n\n  | Column Name | Description                                                                  |\n  | ----------- | ---------------------------------------------------------------------------- |\n  | name        | name of the stream engine                                                    |\n  | user        | name of the user who created the stream engine                               |\n  | status      | status of the stream engine. \"OK\" means available; \"FATAL\" means unavailable |\n  | lastErrMsg  | the latest error message                                                     |\n  | numRows     | the number of records that has entered the stream engine                     |\n  | memoryUsed  | the amount of memory used                                                    |\n\n#### Examples\n\n```\nshare streamTable(10:0,`time`sym`price`qty,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades\noutputTable1 = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\noutputTable2 = table(1:0, `time`avgPrice`sumqty`Total, [TIMESTAMP,DOUBLE,INT,DOUBLE])\ntradesTsEngine = createTimeSeriesEngine(name=\"TimeSeriesDemo\", windowSize=3, step=3, metrics=<[sum(qty)]>, dummyTable=trades, outputTable=outputTable1, timeColumn=`time, keyColumn=`sym, garbageSize=50)\ntradesCsEngine=createCrossSectionalEngine(name=\"CrossSectionalDemo\", metrics=<[avg(price), sum(qty), sum(price*qty)]>, dummyTable=trades, outputTable=outputTable2, keyColumn=`sym, triggeringPattern=`perRow)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesTsEngine\", offset=0, handler=append!{tradesTsEngine}, msgAsTable=true)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesCsEngine\", offset=0, handler=append!{tradesCsEngine}, msgAsTable=true)\n\ndef writeData(n){\n   timev = 2000.10.08T01:01:01.001 + timestamp(1..n)\n   symv =take(`A`B, n)\n   pricev=take(102.1 33.4 73.6 223,n)\n   qtyv = take(60 74 82 59, n)\n   insert into trades values(timev, symv, pricev,qtyv)\n}\n\nwriteData(4);\n\ngetStreamEngineStat().TimeSeriesEngine;\ngetStreamEngineStat().CrossSectionalEngine;\n```\n"
    },
    "getStreamingLeader": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getStreamingLeader.html",
        "signatures": [
            {
                "full": "getStreamingLeader(groupId)",
                "name": "getStreamingLeader",
                "parameters": [
                    {
                        "full": "groupId",
                        "name": "groupId"
                    }
                ]
            }
        ],
        "markdown": "### [getStreamingLeader](https://docs.dolphindb.com/en/Functions/g/getStreamingLeader.html)\n\n\n\n#### Syntax\n\ngetStreamingLeader(groupId)\n\n#### Arguments\n\n**groupId** is an integer indicating a Raft group ID\n\n#### Details\n\nGet the node alias of the Leader in a Raft group.\n\n#### Examples\n\n```\ngetStreamingLeader(11);\n// output\nDFS_NODE2\n```\n"
    },
    "getStreamingRaftGroups": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getStreamingRaftGroups.html",
        "signatures": [
            {
                "full": "getStreamingRaftGroups()",
                "name": "getStreamingRaftGroups",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getStreamingRaftGroups](https://docs.dolphindb.com/en/Functions/g/getStreamingRaftGroups.html)\n\n\n\n#### Syntax\n\ngetStreamingRaftGroups()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn a table with information about the Raft group that the local node belongs to. The first column is Raft group ID; the second column is information about the data nodes in the Raft group.\n\n#### Examples\n\n```\ngetStreamingRaftGroups();\n```\n\n| id | sites                                                                         |\n| -- | ----------------------------------------------------------------------------- |\n| 12 | 192.168.1.135:18102:NODE1,192.168.1.135:18103:NODE2,192.168.1.135:18104:NODE3 |\n| 11 | 192.168.1.135:18102:NODE1,192.168.1.135:18103:NODE2,192.168.1.135:18105:NODE4 |\n\nUse the following script to get information about all Raft groups in the cluster:\n\n```\nselect id,sites from pnodeRun(getStreamingRaftGroups) where isDuplicated([id,sites],FIRST)=false;\n```\n"
    },
    "getStreamingStat": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getStreamingStat.html",
        "signatures": [
            {
                "full": "getStreamingStat()",
                "name": "getStreamingStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getStreamingStat](https://docs.dolphindb.com/en/Functions/g/getStreamingStat.html)\n\n\n\n#### Syntax\n\ngetStreamingStat()\n\n#### Arguments\n\nNone\n\n#### Details\n\nMonitor streaming process. Return a dictionary with the following tables:\n\n* Table *pubConns* displays the status of the connections between the local publisher node and all of its subscriber nodes. Each row represents a subscriber node.\n\n  | Column Name     | Description                                                                                      |\n  | --------------- | ------------------------------------------------------------------------------------------------ |\n  | client          | IP address and port number of a subscriber node                                                  |\n  | queueDepthLimit | The maximum depth (number of records) of the message queue that is allowed on the publisher node |\n  | queueDepth      | Current depth (number of records) of the message queue on the publisher node                     |\n  | tables          | All shared streaming tables in the publisher node                                                |\n\n* Table *subConns* displays the status of the connections between the local subscriber node and the publisher nodes. Each row is a publisher node that the local node subscribes to.\n\n  | Column Name    | Description                                    |\n  | -------------- | ---------------------------------------------- |\n  | publisher      | A publisher node alias                         |\n  | cumMsgCount    | The number of messages that have been received |\n  | cumMsgLatency  | The average latency of all received messages   |\n  | LastMsgLatency | The latency of the last received message       |\n  | lastUpdate     | The last time a message was received           |\n\n  Latency in this table means the time consumed from the moment a message arrives at the publisher node message queue to the moment the message arrives at the subscriber node message queue.\n\n* Table *pubTables* displays the status of stream tables. Each row represents a stream table.\n\n  | Column Name | Description                                     |\n  | ----------- | ----------------------------------------------- |\n  | tableName   | the shared stream table                         |\n  | subscriber  | IP address and port number of a subscriber node |\n  | msgOffset   | offset of the last published record             |\n  | actions     | the subscription task name                      |\n\n* Table *persistWorkers* displays the status of workers (threads) responsible for stream table persistence.\n\n  | Column Name     | Description                                                                                    |\n  | --------------- | ---------------------------------------------------------------------------------------------- |\n  | workerId        | Worker ID                                                                                      |\n  | queueDepthLimit | The maximum depth (number of records) of a message queue that is allowed for table persistence |\n  | queueDepth      | Current depth (number of records) of the message queue for table persistence                   |\n  | tables          | Names of the persisted streaming tables                                                        |\n\n* Table *subWorkers* displays the status of workers of subscriber nodes.\n\n  | Column Name         | Description                                                                                                                                                               |\n  | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n  | workerId            | Worker ID. An empty \"workerId\" column means the subscriber node has not received data.                                                                                    |\n  | topics              | Subscription topics                                                                                                                                                       |\n  | type                | The subscription method, which can be tcp (TCP) or udp (UDP multicast).                                                                                                   |\n  | queueDepthLimit     | The maximum depth (number of records) of a message queue that is allowed on the subscriber node                                                                           |\n  | queueDepth          | Current depth (number of records) of the message queue on the subscriber node                                                                                             |\n  | processedMsgCount   | The number of messages that have been processed                                                                                                                           |\n  | lastMsgId           | the last message ID                                                                                                                                                       |\n  | failedMsgCount      | The number of messages that failed to be processed                                                                                                                        |\n  | lastFailedMsgId     | the last failed message ID                                                                                                                                                |\n  | lastFailedTimestamp | The timestamp of the latest failed message                                                                                                                                |\n  | lastErrMsg          | the last error information on the failed message                                                                                                                          |\n  | msgAsTable          | a BOOLEAN value indicating how the subscribed data is ingested into handler. True means the data is ingested as a table, and false means data is ingested as a tuple.     |\n  | batchSize           | the number of messages batch processed by the handler                                                                                                                     |\n  | throttle            | a numeric scalar (in seconds), indicating the waiting time for the handler to process the messages if the batchSize condition has not been reached since the last process |\n  | hash                | a non-negative integer, indicating which subscription executor to process the incoming messages                                                                           |\n  | filter              | the filtering column of a stream table                                                                                                                                    |\n  | persistOffset       | a Boolean value, indicating whether to persist the offset of the last processed message                                                                                   |\n  | timeTrigger         | a Boolean value. True means that the handler is triggered at the intervals specified by the parameter throttle even if no new messages arrive                             |\n  | handlerNeedMsgId    | a Boolean value, default false. True means that the handler supports two parameters: msgBody and msgId                                                                    |\n  | raftGroup           | the raft group ID                                                                                                                                                         |\n\n* Table *udpPubTables*displays the publishing status using UDP multicast.\n\n  | Column Name | Description                             |\n  | ----------- | --------------------------------------- |\n  | tableName   | The publisher table                     |\n  | channel     | The UDP channel                         |\n  | msgOffset   | The offset of the last published record |\n  | actions     | The subscription task name              |\n  | subNum      | The number of subscriptions             |\n\n#### Examples\n\n```\ngetStreamingStat().pubConns;\ngetStreamingStat().subConns;\ngetStreamingStat().pubTables;\ngetStreamingStat().persistWorkers;\ngetStreamingStat().subWorkers;\n```\n"
    },
    "getStreamTableCacheOffset": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getStreamTableCacheOffset.html",
        "signatures": [
            {
                "full": "getStreamTableCacheOffset(streamTable)",
                "name": "getStreamTableCacheOffset",
                "parameters": [
                    {
                        "full": "streamTable",
                        "name": "streamTable"
                    }
                ]
            }
        ],
        "markdown": "### [getStreamTableCacheOffset](https://docs.dolphindb.com/en/Functions/g/getStreamTableCacheOffset.html)\n\n#### Syntax\n\ngetStreamTableCacheOffset(streamTable)\n\n#### Arguments\n\n**streamTable** is a non-persisted stream table that has cache purge enabled (with either `enableTableShareAndCachePurge` or `enableTableCachePurge`).\n\n#### Details\n\nCheck number of records that have been purged from cache by calculating the difference between the number of records retained in memory and the number of records written to the table.\n\n#### Examples\n\n```\nt = streamTable(1000:0, `time`sym`volume, [DATETIME, SYMBOL, INT])\nenableTableShareAndCachePurge(table=t, tableName=`st, cachePurgeTimeColumn=`time,\n cachePurgeInterval=30m, cacheRetentionTime=20m)\n\ntime = datetime(2024.01.01T09:00:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\n\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n// output: 0\n\ntime = datetime(2024.01.01T09:35:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n//output: 999\n```\n\n"
    },
    "getStreamTableFilterColumn": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getStreamTableFilterColumn.html",
        "signatures": [
            {
                "full": "getStreamTableFilterColumn(streamTable)",
                "name": "getStreamTableFilterColumn",
                "parameters": [
                    {
                        "full": "streamTable",
                        "name": "streamTable"
                    }
                ]
            }
        ],
        "markdown": "### [getStreamTableFilterColumn](https://docs.dolphindb.com/en/Functions/g/getStreamTableFilterColumn.html)\n\n\n\n#### Syntax\n\ngetStreamTableFilterColumn(streamTable)\n\n#### Arguments\n\n**streamTable** is a stream table object.\n\n#### Details\n\nReturn the filter column name of a stream table. The filter column is specified by the function [setStreamTableFilterColumn](https://docs.dolphindb.com/en/Functions/s/setStreamTableFilterColumn.html).\n\n#### Examples\n\n```\nshare streamTable(10000:0,`time`symbol`price, [TIMESTAMP,SYMBOL,INT]) as trades\nsetStreamTableFilterColumn(trades, `symbol)\ntrades_1=table(10000:0,`time`symbol`price, [TIMESTAMP,SYMBOL,INT])\nfilter=symbol(`IBM`GOOG)\nsubscribeTable(tableName=`trades, actionName=`trades_1, handler=append!{trades_1}, msgAsTable=true, filter=filter);\n\nn=100\ntime=take(2018.01.01T09:30:00.000,n)\nsymbol=take((`IBM`GOOG`AAPL`C`BABA),n)\nprice=1..n\n\nt=table(time,symbol,price)\ntrades.append!(t)\n\n// Obtain the filtering column of trades which is specified by the function setStreamTableFilterColumn\ngetStreamTableFilterColumn(trades); \n// output\nsymbol\n```\n"
    },
    "getStreamTables": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getstreamtables.html",
        "signatures": [
            {
                "full": "getStreamTables([option=0])",
                "name": "getStreamTables",
                "parameters": [
                    {
                        "full": "[option=0]",
                        "name": "option",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [getStreamTables](https://docs.dolphindb.com/en/Functions/g/getstreamtables.html)\n\n\n\n#### Syntax\n\ngetStreamTables(\\[option=0])\n\n#### Arguments\n\n**option** (optional) is an integral scalar indicating the type of the stream table to be obtained. It can take the following values:\n\n* 0: all stream tables;\n\n* 1: persisted stream tables;\n\n* 2: non-persisted stream tables;\n\n#### Details\n\nGet the information of specified stream tables. It returns a table containing the following columns:\n\n* name: Table name.\n* shared: Whether the table is shared.\n* persisted: Whether the table is persisted.\n* cachePurgeEnabled: Whether cache purge is enabled.\n* loaded: Whether the table is loaded into memory.\n* columns: The number of columns.\n* rowsInMemory: The number of rows in memory.\n* totalRows: The total number of rows.\n* memoryUsed: Memory used (in bytes).\n\nNote: If the persisted table has not been loaded to memory, only \"name\", \"persisted\", and \"loaded\" columns are returned. NULLs are returned for the rest of columns.\n\n#### Examples\n\n```\nid=`XOM`GS`AAPL;\nx=102.1 33.4 73.6;\n\nrt=streamTable(id, x);\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1;\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades2;\n\ngetStreamTables()\n```\n\nOutput:\n\n| name    | shared | persisted | cachePurgeEnabled | loaded | columns | rowsInMemory | totalRows | memoryUsed |\n| ------- | ------ | --------- | ----------------- | ------ | ------- | ------------ | --------- | ---------- |\n| rt      | false  | false     | false             | true   | 2       | 3            | 3         | 152        |\n| trades1 | true   | false     | false             | true   | 4       | 0            | 0         | 240        |\n| trades2 | true   | false     | false             | true   | 4       | 0            | 0         | 240        |\n"
    },
    "getSubscriptionTopic": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getSubscriptionTopic.html",
        "signatures": [
            {
                "full": "getSubscriptionTopic(tableName, [actionName])",
                "name": "getSubscriptionTopic",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[actionName]",
                        "name": "actionName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getSubscriptionTopic](https://docs.dolphindb.com/en/Functions/g/getSubscriptionTopic.html)\n\n\n\n#### Syntax\n\ngetSubscriptionTopic(tableName, \\[actionName])\n\n#### Arguments\n\n**tableName** is a string indicating the name of the shared stream table.\n\n**actionName** (optional) is a string indicating the name of the subscription task. It can use letters, digits and underscore.\n\n#### Details\n\nReturn a tuple with 2 elements: the subscription topic name and a list of column names of the stream table. It can only be executed on a publisher node.\n\nThe subscription topic name is a combination of the information about the node that the stream table is located (the intranet IP address, port number and node alias separated by \":\"), the stream table name, and the subscription task name (if actionName is specified) separated by \"/\". For example, if the intranet IP of the server is \"localhost:8848:nodeA\" and the stream table name is \"trades\", the topic is \"localhost:8848:nodeA/trades\"; If the subscription task name is \"vwap\", then the topic is \"localhost:8848:nodeA/trades/vwap\".\n\n#### Examples\n\nThe following script is executed on a node with alias \"rh8502\":\n\n```\nt=streamTable(1000000:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nshare t as trades\ntrades_1=streamTable(1000000:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nsubscribeTable(tableName=`trades, actionName=`vwap, offset=-1, handler=append!{trades_1})\ngetSubscriptionTopic(`trades,`vwap);\n// output\n(\"192.168.1.135:8502/rh8502/trades/vwap\",[\"date\",\"time\",\"sym\",\"qty\",\"price\",\"exch\"])\n```\n"
    },
    "getSupportBundle": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getSupportBundle.html",
        "signatures": [
            {
                "full": "getSupportBundle([dir])",
                "name": "getSupportBundle",
                "parameters": [
                    {
                        "full": "[dir]",
                        "name": "dir",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getSupportBundle](https://docs.dolphindb.com/en/Functions/g/getSupportBundle.html)\n\n\n\n#### Syntax\n\ngetSupportBundle(\\[dir])\n\n#### Arguments\n\n**dir** (optional) specifies the directory to store the support bundle. The default path is *\\<HomeDir>*(which can be obtained with [getHomeDir](https://docs.dolphindb.com/en/Functions/g/getHomeDir.html)) for a standalone mode, and the sibling directory of *\\<HomeDir>* for a cluster mode.\n\n##### Details\n\nGenerate a file of support bundle containing all configuration information and return the file path. The function can only be called on a data node or compute node.\n\nThe file contains the following information:\n\n<table id=\"table_cwf_1bb_dzb\"><thead><tr><th>\n\nBlock\n\n</th><th>\n\nDescription\n\n</th><th>\n\nInfo Source\n\n</th></tr></thead><tbody><tr><td>\n\nVERSION\n\n</td><td>\n\nthe server version\n\n</td><td>\n\n`version()`\n\n</td></tr><tr><td>\n\nCONFIGS\n\n</td><td>\n\nthe configuration information.\n\n</td><td>\n\n* standalone mode: *dolphindb.cfg*;\n* cluster mode: *cluster.cfg*, *cluster.nodes*, *controller.cfg*\n\n</td></tr><tr><td>\n\nDB AND TABLE SCHEMA\n\n</td><td>\n\nthe schema of each database and table\n\n</td><td>\n\n`schema`\n\n</td></tr><tr><td>\n\nLICENSE AND MACHINE INFO\n\n</td><td>\n\nlicense, CPU cores and memory usage\n\n</td><td>\n\nlicense file: *dolphindb.lic*\n\n</td></tr><tr><td>\n\nOLAP CACHE ENGINE STATUS\n\n</td><td>\n\nThe status of OLAP cache engine on the current node and the memory usage of each node\n\n</td><td>\n\n`pnodeRun(getOLAPCacheEngineSize)` `pnodeRun(getOLAPCacheEngineStat)`\n\n</td></tr><tr><td>\n\nTSDB META\n\n</td><td>\n\nthe metadata of all chunks in the TSDB database\n\n</td><td>\n\n`pnodeRun(getTSDBMetaData)`\n\n</td></tr><tr><td>\n\nREDO LOG GC STATUS\n\n</td><td>\n\nthe redo log status\n\n</td><td>\n\n`pnodeRun(getRedoLogGCStat)`\n\n</td></tr><tr><td>\n\nTRANSACTION STATUS\n\n</td><td>\n\nthe transaction status\n\n</td><td>\n\n`pnodeRun(getTransactionStatus)`\n\n</td></tr><tr><td>\n\nTABLETS META\n\n</td><td>\n\nthe metadata of the 100 chunks in the cluster with the most rows\n\n</td><td>\n\n`select top 100 * from pnodeRun(getTabl etsMeta{\"%\",\"%\",false,-1}) order by rowNum desc`\n\n</td></tr><tr><td>\n\nANOMALOUS CHUNK STATUS\n\n</td><td>\n\nthe status of anomalous chunks. Anomaly means chunks in recovery, with different version or replica counts.\n\n</td><td>\n\n`getClusterChunksStatus()`\n\n</td></tr></tbody>\n</table>### Examples\n\n```\ngetSupportBundle()\n// output\n/home/dolphindb/server/getSupportBundle.1655869793424\n\ngetSupportBundle(\"/home/dolphindb/sup\")\n// output\n/home/dolphindb/sup/getSupportBundle.1655869853178\n```\n"
    },
    "getSystemCpuUsage": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getSystemCpuUsage.html",
        "signatures": [
            {
                "full": "getSystemCpuUsage()",
                "name": "getSystemCpuUsage",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getSystemCpuUsage](https://docs.dolphindb.com/en/Functions/g/getSystemCpuUsage.html)\n\n\n\n#### Syntax\n\ngetSystemCpuUsage()\n\n#### Arguments\n\nNone\n\n#### Details\n\nThis function returns the CPU utilization rate taken by a DolphinDB process on the current node.\n\n**Note:** If a DolphinDB process uses multiple CPU cores, the total usage rate is returned.\n\n#### Examples\n\n```\ngetSystemCpuUsage();\n// output\n1.771654\n```\n"
    },
    "getSystemLoadAvg": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getSystemLoadAvg.html",
        "signatures": [
            {
                "full": "getSystemLoadAvg()",
                "name": "getSystemLoadAvg",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getSystemLoadAvg](https://docs.dolphindb.com/en/Functions/g/getSystemLoadAvg.html)\n\n\n\n#### Syntax\n\ngetSystemLoadAvg()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn real-time system load average. To use this function, we must set *perfMonitoring*=1 in the configuration file to enable performance monitoring.\n\n#### Examples\n\n```\ngetSystemLoadAvg();\n// output\n5.664062\n```\n"
    },
    "getTableAccess": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTableAccess.html",
        "signatures": [
            {
                "full": "getTableAccess(dbUrl, table)",
                "name": "getTableAccess",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [getTableAccess](https://docs.dolphindb.com/en/Functions/g/getTableAccess.html)\n\n\n\n#### Syntax\n\ngetTableAccess(dbUrl, table)\n\n#### Arguments\n\n**dbUrl** is a string indicating the database URL.\n\n**table** is a string indicating the table name.\n\n#### Details\n\nAllow users to get a detailed view of users and groups with privileges of the specified DFS table.\n\n\\*\\*Note:\\*\\*This function can only be invoked by administrators or by users with DB\\_OWNER or DB\\_MANAGE privileges of the database.\n\n**Return value**: A table with the following columns:\n\n* name: The user or group name.\n* type: User or group.\n* TABLE\\_READ, TABLE\\_INSERT, TABLE\\_UPDATE, TABLE\\_DELETE: The specific privileges. The states can be ALLOW, DENY, or NONE. For more information on user access privileges, please refer to [User Access Control](https://docs.dolphindb.com/en/Tutorials/access_control.html).\n\n#### Examples\n\nUser1 with the DB\\_OWNER privilege creates the DFS table dfs\\://testDB/pt with following settings\n\n* Grants TABLE\\_READ privilege to user2.\n* Denies TABLE\\_INSERT privilege to user3.\n* Grants TABLE\\_DELETE privilege to group1.\n\nUse `getTableAccess` to view the permission set of testDB.\n\n```\nlogin(`user1, `123456)\ngetTableAccess(\"dfs://testDB\", \"pt\")\n```\n\nOutput:\n\n| name   | type  | TABLE\\_READ | TABLE\\_INSERT | TABLE\\_UPDATE | TABLE\\_DELETE |\n| :----- | :---- | :---------- | :------------ | :------------ | :------------ |\n| group1 | group | NONE        | NONE          | NONE          | ALLOW         |\n| user3  | user  | NONE        | DENY          | NONE          | NONE          |\n| user2  | user  | ALLOW       | NONE          | NONE          | NONE          |\n| admin  | user  | ALLOW       | ALLOW         | ALLOW         | ALLOW         |\n\nRelated functions: [getDBAccess](https://docs.dolphindb.com/en/Functions/g/getDBAccess.html)\n"
    },
    "getTables": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTables.html",
        "signatures": [
            {
                "full": "getTables(dbHandle)",
                "name": "getTables",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    }
                ]
            }
        ],
        "markdown": "### [getTables](https://docs.dolphindb.com/en/Functions/g/getTables.html)\n\n\n\n#### Syntax\n\ngetTables(dbHandle)\n\n#### Arguments\n\n**dbHandle** is a database handle.\n\n#### Details\n\nReturn a list of all tables saved in the specified database.\n\n#### Examples\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\ny=rand(10, n)\nt1=table(ID, date, x)\nt2=table(ID, date, y)\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt1 = db.createPartitionedTable(t1, `pt1, `date)\npt1.append!(t1)\npt2 = db.createPartitionedTable(t2, `pt2, `date)\npt2.append!(t2);\ngetTables(db);\n// output\n[\"pt1\",\"pt2\"]\n```\n"
    },
    "getTablet": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTablet.html",
        "signatures": [
            {
                "full": "getTablet(table, partition)",
                "name": "getTablet",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "partition",
                        "name": "partition"
                    }
                ]
            }
        ],
        "markdown": "### [getTablet](https://docs.dolphindb.com/en/Functions/g/getTablet.html)\n\n\n\n#### Syntax\n\ngetTablet(table, partition)\n\n#### Arguments\n\n**table** is an in-memory partitioned table.\n\n**partition** is a scalar/vector indicating a partition or partitions. If an element of *partition* belongs to the partitioning scheme of a partition, it represents the entire partition.\n\n#### Details\n\nReturn a table or a list of tables corresponding to the specified partition or partitions.\n\n* If partition is a scalar, return a table.\n* If partition is a vertor, return a tuple in which every element is a table.\n\n#### Examples\n\n```\ndb=database(partitionType=RANGE, partitionScheme=2012.06.01 2012.06.10 2012.06.20 2012.07.01)\nn=30\nt=table(take(2012.06.01..2012.06.30, n) as date, n..1 as val)\npt=db.createPartitionedTable(table=t, tableName=`pt, partitionColumns=`date).append!(t);\n\ngetTablet(pt, 2012.06.05);\n```\n\n| date       | val |\n| ---------- | --- |\n| 2012.06.01 | 30  |\n| 2012.06.02 | 29  |\n| 2012.06.03 | 28  |\n| 2012.06.04 | 27  |\n| 2012.06.05 | 26  |\n| 2012.06.06 | 25  |\n| 2012.06.07 | 24  |\n| 2012.06.08 | 23  |\n| 2012.06.09 | 22  |\n\n```\nresult=getTablet(pt, 2012.06.22 2012.06.11);\nresult.size();\n// output\n2\n\nresult[0];\n```\n\n| date       | val |\n| ---------- | --- |\n| 2012.06.20 | 11  |\n| 2012.06.21 | 10  |\n| 2012.06.22 | 9   |\n| 2012.06.23 | 8   |\n| 2012.06.24 | 7   |\n| 2012.06.25 | 6   |\n| 2012.06.26 | 5   |\n| 2012.06.27 | 4   |\n| 2012.06.28 | 3   |\n| 2012.06.29 | 2   |\n| 2012.06.30 | 1   |\n"
    },
    "getTabletsMeta": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTabletsMeta.html",
        "signatures": [
            {
                "full": "getTabletsMeta([chunkPath],[tableName],[diskUsage=false],[top=124])",
                "name": "getTabletsMeta",
                "parameters": [
                    {
                        "full": "[chunkPath]",
                        "name": "chunkPath",
                        "optional": true
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    },
                    {
                        "full": "[diskUsage=false]",
                        "name": "diskUsage",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[top=124]",
                        "name": "top",
                        "optional": true,
                        "default": "124"
                    }
                ]
            }
        ],
        "markdown": "### [getTabletsMeta](https://docs.dolphindb.com/en/Functions/g/getTabletsMeta.html)\n\n\n\n#### Syntax\n\ngetTabletsMeta(\\[chunkPath],\\[tableName],\\[diskUsage=false],\\[top=124])\n\n#### Arguments\n\n**chunkPath** (optional) is the DFS path to one or multiple database chunks. It supports wildcards %, \\* and ?.\n\n**tableName** (optional) is a string indicating a table name.\n\n**diskUsage** (optional) is a Boolean value indicating whether the result includes the column of diskUsage.\n\n**top** (optional) is a positive number indicating the maximum number of chunks in the output. The default value is 1024. To remove the upper limit of chunks in the output, set top to -1.\n\n#### Details\n\nReturn metadata of specified tablet chunks on the local node. To get metadata about all tablet chunks of a distributed table, use `getTabletsMeta` together with [pnodeRun](https://docs.dolphindb.com/en/Functions/p/pnodeRun.html).\n\nReturn a table with the following columns:\n\n* chunkId: the unique identifier of chunk.\n\n* path: the physical path of the partition.\n\n* dfsPath: the dfs path of the partition.\n\n* tableName: the table name.\n\n* version: the version number.\n\n* rowNum: the number of records in the partition.\n\n* createCids: the Cids created when updating/deleting the table.\n\n* latestPhysicalDir: the temporary physical directory storing the data generated by the operation with the latest Cid.\n\n* diskUsage: the disk space occupied by partition (in Bytes).\n\n#### Examples\n\n```\nif(existsDatabase(\"dfs://testDB\")){\n   dropDatabase(\"dfs://testDB\")\n}\ndb=database(\"dfs://testDB\", VALUE, 1..10)\nn=1000000\nt=table(rand(1..10, n) as id, rand(100.0, n) as x)\ndb.createPartitionedTable(t, `pt1, `id).append!(t)\nn=2000000\nt=table(rand(1..10, n) as id, rand(100.0, n) as x, rand(100, n) as y)\ndb.createPartitionedTable(t, `pt2, `id).append!(t)\nupdate loadTable(\"dfs://testDB\",`pt1) set x=x*10\ngetTabletsMeta(\"/testDB/%\", `pt1, true);\n```\n\n| chunkId                              | path            | dfsPath    | tableName | version | rowNum | createCids | latestPhysicalDir |\n| ------------------------------------ | --------------- | ---------- | --------- | ------- | ------ | ---------- | ----------------- |\n| dbfd1767-f9ca-689e-4d5e-643b8506e82d | C:UsersDownl... | /testDB/10 | pt1       | 2       | 99815  | \\[2059]    | pt1\\_2\\_2059      |\n| d221b457-fa7b-5990-4caa-13c99f56f716 | C:UsersDownl... | /testDB/9  | pt1       | 2       | 99975  | \\[2059]    | pt1\\_2\\_2059      |\n| 92904d3b-0147-9bb8-4a28-f99525b250e7 | C:UsersDownl... | /testDB/8  | pt1       | 2       | 99844  | \\[2059]    | pt1\\_2\\_2059      |\n| 7478c15a-0629-c8ab-47ee-a1d12c3c1cd6 | C:UsersDownl... | /testDB/1  | pt1       | 2       | 100237 | \\[2059]    | pt1\\_2\\_2059      |\n| 8bc48c11-86ca-97ac-4ee4-8f829de92cc8 | C:UsersDownl... | /testDB/5  | pt1       | 2       | 99991  | \\[2059]    | pt1\\_2\\_2059      |\n| 6b3a0a09-bc64-3bab-4535-344b7316d244 | C:UsersDownl... | /testDB/2  | pt1       | 2       | 100120 | \\[2059]    | pt1\\_2\\_2059      |\n| a7452c44-5d2b-6f82-4150-7bc48e941d64 | C:UsersDownl... | /testDB/4  | pt1       | 2       | 99535  | \\[2059]    | pt1\\_2\\_2059      |\n| a1a375cc-b6c0-29b2-485a-330af7447564 | C:UsersDownl... | /testDB/6  | pt1       | 2       | 100518 | \\[2059]    | pt1\\_2\\_2059      |\n| b04b4c04-6d43-0d8d-4000-6ae88e349eda | C:UsersDownl... | /testDB/3  | pt1       | 2       | 99919  | \\[2059]    | pt1\\_2\\_2059      |\n| b20df3a7-678b-1cbe-400d-d8e566706682 | C:UsersDownl... | /testDB/7  | pt1       | 2       | 100046 | \\[2059]    | pt1\\_2\\_2059      |\n"
    },
    "getTopicProcessedOffset": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTopicProcessedOffset.html",
        "signatures": [
            {
                "full": "getTopicProcessedOffset(topic)",
                "name": "getTopicProcessedOffset",
                "parameters": [
                    {
                        "full": "topic",
                        "name": "topic"
                    }
                ]
            }
        ],
        "markdown": "### [getTopicProcessedOffset](https://docs.dolphindb.com/en/Functions/g/getTopicProcessedOffset.html)\n\n\n\n#### Syntax\n\ngetTopicProcessedOffset(topic)\n\n#### Arguments\n\n**topic** is the subscription topic returned by function [subscribeTable](https://docs.dolphindb.com/en/Functions/s/subscribeTable.html)\n\n#### Details\n\n* If parameter *persistOffset* of function `subscribeTable` is true, return the offset of the last subscribed message that has been processed.\n* If parameter *persistOffset* of function `subscribeTable` is false, return -1.\n\n#### Examples\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\ntrades_1 = streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT])\ntopic=subscribeTable(tableName=\"trades\", actionName=\"trades_1\", offset=0, handler=append!{trades_1}, msgAsTable=true, persistOffset=true)\ndef writeData(n){\n   timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n   symv =take(`A`B, n)\n   qtyv = take(1, n)\n   insert into trades values(timev, symv, qtyv)\n}\nwriteData(6);\nselect * from trades_1;\n```\n\n| time                    | sym | qty |\n| ----------------------- | --- | --- |\n| 2018.10.08T01:01:01.002 | A   | 1   |\n| 2018.10.08T01:01:01.003 | B   | 1   |\n| 2018.10.08T01:01:01.004 | A   | 1   |\n| 2018.10.08T01:01:01.005 | B   | 1   |\n| 2018.10.08T01:01:01.006 | A   | 1   |\n| 2018.10.08T01:01:01.007 | B   | 1   |\n\n```\ngetTopicProcessedOffset(topic);\n// output\n5\n```\n"
    },
    "getTradingCalendarType": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTradingCalendarType.html",
        "signatures": [
            {
                "full": "getTradingCalendarType(marketName)",
                "name": "getTradingCalendarType",
                "parameters": [
                    {
                        "full": "marketName",
                        "name": "marketName"
                    }
                ]
            }
        ],
        "markdown": "### [getTradingCalendarType](https://docs.dolphindb.com/en/Functions/g/getTradingCalendarType.html)\n\n\n\n#### Syntax\n\ngetTradingCalendarType(marketName)\n\n#### Arguments\n\n**marketName** is a STRING scalar, indicating the identifier of the trading calendar, e.g., the Market Identifier Code of an exchange, or a user-defined calendar name.\n\n#### Details\n\nGet the type of the trading calendar of a specified exchange.\n\n**Return value**: A STRING scalar of \"holidayDate\" or \"tradingDate\".\n\n#### Examples\n\n```\ngetTradingCalendarType(\"SZSE\")\n```\n\nOutput: holidayDate\n"
    },
    "getTransactionStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTransactionStatus.html",
        "signatures": [
            {
                "full": "getTransactionStatus()",
                "name": "getTransactionStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getTransactionStatus](https://docs.dolphindb.com/en/Functions/g/getTransactionStatus.html)\n\n\n\n#### Syntax\n\ngetTransactionStatus()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet the status of transactions. Return a table containing the following columns:\n\n* tid: The transaction ID.\n\n* startTime: The time when the transaction started.\n\n* type: The type of operations involved in the transaction, including APPEND, DROP, SQLUPDATE, SQLUPSERT, SQLDELETE, FILEOPERATE, or UNKNOWN.\n\n* status: The transaction status. It can be BEGIN, COMMIT, COMPLETE, or ROLLBACK.\n\n* partitionCount: The number of partitions involved in the transaction.\n\n* endTime: The time when the transaction ended.\n\n* elapsedTime: The elapsed time of the transaction.\n\n#### Examples\n\n```\ngetTransactionStatus()\n```\n\n| tid  | startTime               | type   | status | partitionCount | endTime                 | elapsedTime |\n| ---- | ----------------------- | ------ | ------ | -------------- | ----------------------- | ----------- |\n| 3135 | 2022.06.07 16:19:48.477 | APPEND | BEGIN  | 4              |                         | 584         |\n| 3143 | 2022.06.07 16:11:27.489 | APPEND | COMMIT | 4              | 2022.06.07 16:11:33.100 | 484         |\n"
    },
    "getTSDBCachedSymbolBaseMemSize": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTSDBCachedSymbolBaseMemSize.html",
        "signatures": [
            {
                "full": "getTSDBCachedSymbolBaseMemSize()",
                "name": "getTSDBCachedSymbolBaseMemSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBCachedSymbolBaseMemSize](https://docs.dolphindb.com/en/Functions/g/getTSDBCachedSymbolBaseMemSize.html)\n\n#### Syntax\n\ngetTSDBCachedSymbolBaseMemSize()\n\n#### Arguments\n\nNone\n\n#### Details\n\nObtain the cache size (in Bytes) of SYMBOL base (i.e., a dictionary that stores integers encoded from the data of SYMBOL type) of the TSDB engine.\n\n"
    },
    "getTSDBCacheEngineSize": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTSDBCacheEngineSize.html",
        "signatures": [
            {
                "full": "getTSDBCacheEngineSize()",
                "name": "getTSDBCacheEngineSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBCacheEngineSize](https://docs.dolphindb.com/en/Functions/g/getTSDBCacheEngineSize.html)\n\n\n\n#### Syntax\n\ngetTSDBCacheEngineSize()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn a LONG type data that indicates the maximum memory (in Bytes) allocated to the TSDB cache engine.\n\n#### Examples\n\n```\nsetTSDBCacheEngineSize(0.5)\ngetTSDBCacheEngineSize()\n// output\n536870912\n```\n\nRelated function: [setTSDBCacheEngineSize](https://docs.dolphindb.com/en/Functions/s/setTSDBCacheEngineSize.html)\n"
    },
    "getTSDBCompactionTaskStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTSDBCompactionTaskStatus.html",
        "signatures": [
            {
                "full": "getTSDBCompactionTaskStatus([count])",
                "name": "getTSDBCompactionTaskStatus",
                "parameters": [
                    {
                        "full": "[count]",
                        "name": "count",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBCompactionTaskStatus](https://docs.dolphindb.com/en/Functions/g/getTSDBCompactionTaskStatus.html)\n\n\n\n#### Syntax\n\ngetTSDBCompactionTaskStatus(\\[count])\n\n#### Arguments\n\n**count** (optional) is a non-negative integer. Return the status of the latest count compaction tasks. The default value is 0, indicating that all completed compaction tasks (up to 256 latest tasks) and uncompleted tasks are returned.\n\n#### Details\n\nObtain the status of TSDB level file compaction tasks. The function can only be executed on a data node.\n\nReturn a table with the following columns:\n\n* volume: the volume where the compaction is performed. It is set by the configuration parameter *volumes*.\n\n* level: the level of files for compaction.\n\n* chunkId: the ID of chunk where the compaction is performed.\n\n* tableName: the physical name of the table where the compaction is performed.\n\n* files: the level files involved in the current compaction.\n\n* force: whether the compaction is triggered by `triggerTSDBCompaction`.\n\n* receivedTime: the timestamp when the compaction task enqueued.\n\n* startTime: the timestamp when the compaction task started.\n\n* endTime: the timestamp when the compaction task ended.\n\n* errorMessage: If a task failed, the column displays the failure cause; otherwise it is left empty.\n\n#### Examples\n\n```\ngetTSDBCompactionTaskStatus()\n```\n\n| volume                                                                            | level | chunkId                              | tableName | files                    | force | receivedTime            | startTime               | endTime                 | errorMessage |\n| --------------------------------------------------------------------------------- | ----- | ------------------------------------ | --------- | ------------------------ | ----- | ----------------------- | ----------------------- | ----------------------- | ------------ |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 0     | e0e00bc2-b81e-6eb9-4d01-7bb17fb39595 | pt\\_2     | 0\\_00000006,0\\_00000011, | true  | 2023.06.22T12:47:32.009 | 2023.06.22T12:47:32.010 | 2023.06.22T12:47:32.182 |              |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 1     | a9dfccad-cec1-0786-480a-9ae809481a8b | pt\\_2     | 0\\_00000003,0\\_00000007, | true  | 2023.06.22T12:47:32.010 | 2023.06.22T12:47:32.182 | 2023.06.22T12:47:32.326 |              |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 1     | 331324ce-b49f-94ac-4da8-a4bcf6c34e1c | pt\\_2     | 0\\_00000004,0\\_00000010, | true  | 2023.06.22T12:47:32.010 | 2023.06.22T12:47:32.326 | 2023.06.22T12:47:32.451 |              |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 2     | f3597e0f-6ad9-6eb6-45c8-d42adc5c50f7 | pt\\_2     | 0\\_00000002,0\\_00000008, | true  | 2023.06.22T12:47:32.010 | 2023.06.22T12:47:32.451 | 2023.06.22T12:47:32.527 |              |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 2     | d36ac640-3428-069b-4382-0b9608b94d17 | pt\\_2     | 0\\_00000005,0\\_00000009, | true  | 2023.06.22T12:47:32.010 | 2023.06.22T12:47:32.527 | 2023.06.22T12:47:32.616 |              |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 2     | e0e00bc2-b81e-6eb9-4d01-7bb17fb39595 | pt\\_2     | 0\\_00000016,0\\_00000021, | true  | 2023.06.22T12:47:33.058 | 2023.06.22T12:47:33.058 | 2023.06.22T12:47:33.151 |              |\n\nRelated function: [triggerTSDBCompaction](https://docs.dolphindb.com/en/Functions/t/triggerTSDBCompaction.html)\n"
    },
    "getTSDBDataStat": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gettsdbdatastat.html",
        "signatures": [
            {
                "full": "getTSDBDataStat([dbName=\"*\"],[tableName=\"*\"])",
                "name": "getTSDBDataStat",
                "parameters": [
                    {
                        "full": "[dbName=\"*\"]",
                        "name": "dbName",
                        "optional": true,
                        "default": "\"*\""
                    },
                    {
                        "full": "[tableName=\"*\"]",
                        "name": "tableName",
                        "optional": true,
                        "default": "\"*\""
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBDataStat](https://docs.dolphindb.com/en/Functions/g/gettsdbdatastat.html)\n\n\n\n#### Syntax\n\ngetTSDBDataStat(\\[dbName=\"\\*\"],\\[tableName=\"\\*\"])\n\n#### Arguments\n\n**dbName** (optional) is a string indicating the database name. It can contain wildcards (\"\\*\", \"%\", and \"?\"). The default value is \"\\*\".\n\n**tableName** (optional) is a string indicating the table name. It can contain wildcards (\"\\*\", \"%\", and \"?\"). The default value is \"\\*\".\n\n\"\\*\" matches all; \"?\" matches a single character; \"%\" matches 0, 1 or more characters.\n\n#### Details\n\nGet the number of level files and sort key entries of TSDB tables on the current node for each chunk.\n\nYou can also use function `pnodeRun` to check the number of level files and sort key entries of tables in a cluster.\n\nIt returns a table containing the following columns:\n\n* levelFileCount: the number of level files of tables for each chunk.\n\n* sortKeyEntryCount: the number of sort key entries that has not been deduplicated in all level files for each chunk.\n\n#### Examples\n\n```\nt = table(1 2 1 1 2 2 3 as month, `Rome`Paris`London`Paris`Rome`London`Rome as city, 200 500 100 300 300 400 400 as sold)\ndb_name = \"dfs://window_function\"\nif (existsDatabase(db_name)) {\n    dropDatabase(db_name)\n}\ndb = database(db_name, HASH, [INT, 4], , 'TSDB')\n\npt = db.createPartitionedTable(t, \"pt\", \"month\", ,\"sold\")\npt.append!(t)\n\npt1 = db.createPartitionedTable(t, \"pt1\", \"month\", ,\"sold\")\npt1.append!(t)\n\nflushTSDBCache()\n```\n\nGet the number of level files and sort key entries for all tables in the databases starting with *dfs\\://window*.\n\n```\ngetTSDBDataStat(\"dfs://window%\")  \n// output\ndbName\tchunkId\ttableName\tlevelFileCount\tsortKeyEntryCount\ndfs://window_function\td334ffab-741a-dcbd-174e-42b412058877\tpt1\t1\t1\ndfs://window_function\tc3de728c-4efb-7e8e-024c-cfafd46c506c\tpt1\t1\t3\ndfs://window_function\t572b1660-790e-e3a0-3944-9b81e50f4eb4\tpt1\t1\t3\ndfs://window_function\te9ea31f6-4e12-2881-b04a-c540dc3947c8\tpt\t1\t1\ndfs://window_function\t673a7c12-c0d4-72bf-6a42-9c374589e2d6\tpt\t1\t3\ndfs://window_function\t57ceedc9-4aaf-2aad-aa43-37924da3d32e\tpt\t1\t3\n```\n\nGet the number of level files and sort key entries for table \"pt\" in the databases starting with *dfs\\://window*.\n\n```\ngetTSDBDataStat(\"dfs://window%\",\"pt\") \n// output\ndbName\tchunkId\ttableName\tlevelFileCount\tsortKeyEntryCount\ndfs://window_function\te9ea31f6-4e12-2881-b04a-c540dc3947c8\tpt\t1\t1\ndfs://window_function\t673a7c12-c0d4-72bf-6a42-9c374589e2d6\tpt\t1\t3\ndfs://window_function\t57ceedc9-4aaf-2aad-aa43-37924da3d32e\tpt\t1\t3\n```\n"
    },
    "getTSDBMetaData": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTSDBMetaData.html",
        "signatures": [
            {
                "full": "getTSDBMetaData()",
                "name": "getTSDBMetaData",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBMetaData](https://docs.dolphindb.com/en/Functions/g/getTSDBMetaData.html)\n\n\n\n#### Syntax\n\ngetTSDBMetaData()\n\n#### Arguments\n\nNone\n\n#### Details\n\nObtain the metadata of all chunks in the TSDB engine. The function can only be executed on a data node.\n\nIt return a table with the following columns:\n\n* chunkId: the chunk ID\n\n* chunkPath: the physical path of the chunk\n\n* level: the file level\n\n* table: the table name\n\n* files: the level file name\n\n#### Examples\n\n```\ngetTSDBMetaData()\n```\n\n| chunkId                          | chunkPath           | level | table | files                    |\n| -------------------------------- | ------------------- | ----- | ----- | ------------------------ |\n| 7e0c65ca-5e4a-4594-2948-fa0b5... | /hdd/hdd7/test/v... | 0     | pt\\_2 | 0\\_00211490,0\\_002115580 |\n| 7e0c65ca-5e4a-4594-2948-fa0b5... | /hdd/hdd7/test/v... | 1     | pt\\_2 | 1\\_00013041              |\n"
    },
    "getTSDBSortKeyEntry": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTSDBSortKeyEntry.html",
        "signatures": [
            {
                "full": "getTSDBSortKeyEntry(chunkId, [tableName])",
                "name": "getTSDBSortKeyEntry",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBSortKeyEntry](https://docs.dolphindb.com/en/Functions/g/getTSDBSortKeyEntry.html)\n\n#### Syntax\n\ngetTSDBSortKeyEntry(chunkId, \\[tableName])\n\n#### Arguments\n\n**chunkId** is a STRING scalar or vector indicating the chunk ID. Note: When *chunkId* is a vector, its length cannot exceed 1024.\n\n**tableName** (optional) is a STRING scalar indicating the DFS table name. If not specified, all tables under the specified chunk are checked.\n\n#### Details\n\nThis function obtains information on the sort key entries of each chunk (See the parameter [sortColumns](https://docs.dolphindb.com/en/Functions/c/createPartitionedTable.html)). It returns a table containing the following information:\n\n* chunkId: The chunk ID.\n\n* chunkPath: The DFS path to the chunk.\n\n* tableName: The DFS table name.\n\n* file: The level file name.\n\n* key: The sort key entry. Use an underscore \"\\_\" to separate sort keys.\n\n* size: The number of records with the sort key entry.\n\nNote that the function cannot check data in the cache engine. You can call [flushTSDBCache](https://docs.dolphindb.com/en/Functions/f/flushTSDBCache.html) to forcibly flush the completed transactions cached in the TSDB cache engine to disk.\n\n#### Examples\n\n```\nn = 10000\nSecurityID = rand(`st0001`st0002`st0003`st0004`st0005, n)\nsym = rand(`A`B`C`D`E, n)\nTradeDate = 2022.01.01 + rand(100,n)\nTotalVolumeTrade = rand(1000..3000, n)\nTotalValueTrade = rand(100.0, n)\nschemaTable_snap = table(SecurityID, sym, TradeDate, TotalVolumeTrade, TotalValueTrade).sortBy!(`SecurityID`sym`TradeDate)\n\ndbPath = \"dfs://TSDB_STOCK\"\nif(existsDatabase(dbPath)){dropDatabase(dbPath)}\ndb_snap = database(dbPath, VALUE, 2022.01.01..2022.01.05, engine='TSDB')\n\nsnap=createPartitionedTable(dbHandle=db_snap, table=schemaTable_snap, tableName=\"snap\", partitionColumns=`TradeDate, sortColumns=`SecurityID`sym`TradeDate, keepDuplicates=ALL, sortKeyMappingFunction=[hashBucket{,3}, hashBucket{,2}])\nsnap.append!(schemaTable_snap)\n\nsnap1=createPartitionedTable(dbHandle=db_snap, table=schemaTable_snap, tableName=\"snap1\", partitionColumns=`TradeDate, sortColumns=`SecurityID`sym`TradeDate, keepDuplicates=ALL)\nsnap1.append!(schemaTable_snap)\n\nflushTSDBCache()\n```\n\n```\ngetChunksMeta()\n```\n\n| site        | chunkId                              | path                                                                 | dfsPath                  | type | flag | size | version | state | versionList                   | resolved |\n| ----------- | ------------------------------------ | -------------------------------------------------------------------- | ------------------------ | ---- | ---- | ---- | ------- | ----- | ----------------------------- | -------- |\n| server11352 | fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | /TSDB\\_STOCK/20220410/yv | 1    | 0    | 0    | 1       | 0     | cid : 2134,snap1=>2134:89; #  | false    |\n| server11352 | 5c30ef71-3e51-c5ac-6b4d-4458feb8454a | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220407/yv | /TSDB\\_STOCK/20220407/yv | 1    | 0    | 0    | 1       | 0     | cid : 2134,snap1=>2134:95; #  | false    |\n| server11352 | 4216dbe9-c238-49a9-4d45-66829c98a7b5 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220406/yv | /TSDB\\_STOCK/20220406/yv | 1    | 0    | 0    | 1       | 0     | cid : 2134,snap1=>2134:92; #  | false    |\n| server11352 | 47ea0d35-7ea9-c3b3-cc4b-cc6cd1fe039d | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220401/yv | /TSDB\\_STOCK/20220401/yv | 1    | 0    | 0    | 1       | 0     | cid : 2134,snap1=>2134:100; # | false    |\n| server11352 | aafd71c5-a197-63a9-2d4c-b65cbced3d21 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220330/yv | /TSDB\\_STOCK/20220330/yv | 1    | 0    | 0    | 1       | 0     | cid : 2134,snap1=>2134:97; #  | false    |\n\n```\ngetTSDBSortKeyEntry(\"fe93077a-5a05-34a8-554c-67467415bf68\")\n```\n\n| chunkId                              | chunkPath                                                            | tableName | file        | key       | size |\n| ------------------------------------ | -------------------------------------------------------------------- | --------- | ----------- | --------- | ---- |\n| fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | snap1     | 0\\_00000058 | st0001\\_A | 2    |\n| fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | snap1     | 0\\_00000058 | st0001\\_B | 3    |\n| fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | snap1     | 0\\_00000058 | st0001\\_C | 2    |\n| fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | snap1     | 0\\_00000058 | st0001\\_D | 6    |\n| fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | snap1     | 0\\_00000058 | st0002\\_A | 4    |\n\n"
    },
    "getTSDBTableIndexCacheStatus": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getTSDBTableIndexCacheStatus.html",
        "signatures": [
            {
                "full": "getTSDBTableIndexCacheStatus()",
                "name": "getTSDBTableIndexCacheStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBTableIndexCacheStatus](https://docs.dolphindb.com/en/Functions/g/getTSDBTableIndexCacheStatus.html)\n\n#### Syntax\n\ngetTSDBTableIndexCacheStatus()\n\n#### Arguments\n\nNone\n\n#### Details\n\nWhen querying a TSDB table, the indexes (including zonemap) of related level files will be loaded to the memory. This function is used to obtain the memory usage (in bytes) of the level file indexes for each loaded table. Combined with function `getTSDBDataStat`, it helps you to check whether the number of sort keys set for tables is reasonable.\n\nReturn a table with the following columns:\n\n* dbName: the database name.\n\n* chunkId: the chunk ID.\n\n* tableName: the table name.\n\n* memUsage: the size of the memory used (in bytes).\n\n#### Examples\n\n```\nt = table(1 2 1 1 2 2 3 as month, `Rome`Paris`London`Paris`Rome`London`Rome as city, 200 500 100 300 300 400 400 as sold)\ndb_name = \"dfs://tsdb_01\"\nif (existsDatabase(db_name)) {\n    dropDatabase(db_name)\n}\ndb = database(db_name, HASH, [INT, 4], , 'TSDB')\n\npt = db.createPartitionedTable(t, \"pt\", \"month\", ,\"sold\")\npt.append!(t)\n\npt1 = db.createPartitionedTable(t, \"pt1\", \"month\", ,\"sold\")\npt1.append!(t)\n\nflushTSDBCache()\n\ngetTSDBTableIndexCacheStatus()\n```\n\n| dbName          | chunkId                              | tableName | memUsage |\n| --------------- | ------------------------------------ | --------- | -------- |\n| dfs\\://tsdb\\_01 | 01e891fa-f66d-7599-7544-4e0449f4e608 | pt1\\_3    | 680      |\n| dfs\\://tsdb\\_01 | 81c0f8f7-e195-b298-da4a-d007492f4733 | pt1\\_3    | 680      |\n| dfs\\://tsdb\\_01 | 17f8bc0b-946e-f688-374c-955c586faccf | pt\\_2     | 296      |\n| dfs\\://tsdb\\_01 | 1df88c41-bccf-449b-504c-5978df9cc03f | pt\\_2     | 680      |\n| dfs\\://tsdb\\_01 | 10371e0c-685a-51b1-3042-1ba289514bb9 | pt1\\_3    | 296      |\n| dfs\\://tsdb\\_01 | 0be81d1e-1962-108b-274e-3dc2632921bc | pt\\_2     | 680      |\n\nRelated functions: [getTSDBDataStat](https://docs.dolphindb.com/en/Functions/g/gettsdbdatastat.html), [getLevelFileIndexCacheStatus](https://docs.dolphindb.com/en/Functions/g/getLevelFileIndexCacheStatus.html)\n\n"
    },
    "getUnresolvedTxn": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getUnresolvedTxn.html",
        "signatures": [
            {
                "full": "getUnresolvedTxn()",
                "name": "getUnresolvedTxn",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getUnresolvedTxn](https://docs.dolphindb.com/en/Functions/g/getUnresolvedTxn.html)\n\n\n\n#### Syntax\n\ngetUnresolvedTxn()\n\n#### Arguments\n\nNone\n\n#### Details\n\nGet transactions and nodes in the resolution phase. This can only be executed by an administrator on the controller.\n\nReturn a table containing the following columns:\n\n* tid: the transaction ID\n\n* cid: the commit ID\n\n* chunkId: the chunk ID\n\n* initiatingNode: the node that initiates the resolution\n\n* firstResolutionAt: the starting time of the resolution\n\n* lastResolutionAt: the starting time of the last resolution when there are multiple resolutions in the transaction\n"
    },
    "getUserAccess": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getUserAccess.html",
        "signatures": [
            {
                "full": "getUserAccess([userIds], [finalAccess=false])",
                "name": "getUserAccess",
                "parameters": [
                    {
                        "full": "[userIds]",
                        "name": "userIds",
                        "optional": true
                    },
                    {
                        "full": "[finalAccess=false]",
                        "name": "finalAccess",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [getUserAccess](https://docs.dolphindb.com/en/Functions/g/getUserAccess.html)\n\n#### Syntax\n\ngetUserAccess(\\[userIds], \\[finalAccess=false])\n\n#### Arguments\n\n**userId** (optional) is a STRING scalar/vector indicating one or multiple user names.\n\n**finalAccess** (optional) is a Boolean value that specifies whether the obtained result is the privileges that ultimately take effect, i.e., the privileges for both the user and the groups the user belongs to are taken into account. The default value is false.\n\n#### Details\n\nThis function returns privileges for specific users.\n\nWhen *userId* is not specified, it returns the privileges for the current user.\n\nWhen *userId*is specified (only by administrators):\n\n* If *finalAccess* = false, the obtained access is the explicit privileges applied to the user.\n\n* If *finalAccess* = true, the obtained access is the privileges that ultimately take effect.\n\n**Return value**: A table with the following columns\n\n| Column                    | Description                                                                                                                                                                |\n| ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| userId                    | The user name                                                                                                                                                              |\n| groups                    | The group to which the user belongs                                                                                                                                        |\n| isAdmin                   | Whether the user is an administrator                                                                                                                                       |\n| MAX\\_JOB\\_PRIORITY        | An integer between 0 and 8 indicating the highest priority of the jobs submitted by the user. It is specified by the command `setMaxJobPriority`.                          |\n| MAX\\_PARALLELISM          | An integer indicating the maximum number of tasks that can be executed in parallel for a job submitted by the user. It is specified by the command `setMaxJobParallelism`. |\n| QUERY\\_RESULT\\_MEM\\_LIMIT | The memory limit for a query result. It is a floating-point number indicating memory usage (in GB). You can use `grant` to set the limit and `revoke` to remove.           |\n| TASK\\_GROUP\\_MEM\\_LIMIT   | The memory limit of a task group. It is a floating-point number indicating memory usage in GB. You can use `grant` to set the limit and `revoke` to remove.                |\n\nThe following privileges are listed with permission state \"allow\" / \"none\" / \"deny\": ACCESS\\_READ, ACCESS\\_INSERT, ACCESS\\_UPDATE, ACCESS\\_DELETE, VIEW\\_EXEC, SCRIPT\\_EXEC, TEST\\_EXEC, DBOBJ\\_CREATE, DBOBJ\\_DELETE, DB\\_MANAGE, DB\\_OWNER, and VIEW\\_OWNER.\n\n**Note:**\n\n* Version 1.30.21/2.00.9 onwards extends privileges at the table level. The original TABLE\\_WRITE field is now replaced with fields TABLE\\_INSERT, TABLE\\_UPDATE, and TABLE\\_DELETE.\n\n* Since the DB\\_READ, DB\\_WRITE, DB\\_INSERT, DB\\_UPDATE, and DB\\_DELETE privileges apply to tables in databases, only table-level privileges are returned.\n\nThe remaining columns in the table display the specific objects (tables, views or databases) that the user is granted/denied access to:\n\n| objs                     |\n| ------------------------ |\n| TABLE\\_READ\\_allowed     |\n| TABLE\\_READ\\_denied      |\n| TABLE\\_INSERT\\_allowed   |\n| TABLE\\_INSERT\\_denied    |\n| TABLE\\_UPDATE\\_allowed   |\n| TABLE\\_UPDATE\\_denied    |\n| TABLE\\_DELETE\\_allowed   |\n| TABLE\\_DELETE\\_denied    |\n| DB\\_READ\\_allowed        |\n| DB\\_READ\\_denied         |\n| DB\\_INSERT\\_allowed      |\n| DB\\_INSERT\\_denied       |\n| DB\\_UPDATE\\_allowed      |\n| DB\\_UPDATE\\_denied       |\n| DB\\_DELETE\\_allowed      |\n| DB\\_DELETE\\_denied       |\n| VIEW\\_EXEC\\_allowed      |\n| VIEW\\_EXEC\\_denied       |\n| DBOBJ\\_CREATE\\_allowed   |\n| DBOBJ\\_CREATE\\_denied    |\n| DBOBJ\\_DELETE\\_allowed   |\n| DBOBJ\\_DELETE\\_denied    |\n| DB\\_OWNER\\_allowed       |\n| DB\\_MANAGE\\_allowed      |\n| DB\\_MANAGE\\_denied       |\n| CATALOG\\_READ\\_allowed   |\n| CATALOG\\_READ\\_denied    |\n| CATALOG\\_INSERT\\_allowed |\n| CATALOG\\_INSERT\\_denied  |\n| CATALOG\\_UPDATE\\_allowed |\n| CATALOG\\_UPDATE\\_denied  |\n| CATALOG\\_DELETE\\_allowed |\n| CATALOG\\_DELETE\\_denied  |\n\n"
    },
    "getUserHardwareUsage": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getuserhardwareusage.html",
        "signatures": [
            {
                "full": "getUserHardwareUsage([from=0], [to])",
                "name": "getUserHardwareUsage",
                "parameters": [
                    {
                        "full": "[from=0]",
                        "name": "from",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[to]",
                        "name": "to",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getUserHardwareUsage](https://docs.dolphindb.com/en/Functions/g/getuserhardwareusage.html)\n\n\n\n#### Syntax\n\ngetUserHardwareUsage(\\[from=0], \\[to])\n\n#### Arguments\n\n**from** (optional) is an integral or temporal number indicating the start time of the query. The default value is 0, indicating the queried records starts from the record at 1970.01.01 00:00.\n\n**to** (optional) is an integral or temporal number indicating the end time of the query. The default value is NULL, indicating the query includes records up to the current time.\n\nNote that *from* must be no greater than *to*.\n\n#### Details\n\nGet the CPU and memory usage within the specified time range from query logs (located at *\\<HomeDir>/resource/hardware.log)*. This function can only be called by the administrator on a data node.\n\nIt returns a table containing the following columns:\n\n* timestamp: a timestamp of NANOTIMESTAMP type.\n\n* userId: the login user ID.\n\n* cpu: the number of CPU threads used by the user.\n\n* memory: the memory used (in bytes) by the user.\n\n#### Examples\n\n```\ngetUserHardwareUsage(2023.12.29T10:55:43.280031346,2023.12.29T10:56:23.321355134)\n// output\ntimestamp\tuserId\tcpu\tmemory\n2023.12.29T10:55:43.280031346\tguest\t1\t16\n2023.12.29T10:55:53.290361530\tadmin\t0\t16\n2023.12.29T10:55:53.290361530\tguest\t1\t16\n2023.12.29T10:56:03.299225976\tadmin\t0\t16\n2023.12.29T10:56:03.299225976\tguest\t1\t16\n2023.12.29T10:56:13.310316778\tadmin\t0\t16\n2023.12.29T10:56:13.310316778\tguest\t1\t16\n```\n"
    },
    "getUserList": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getUserList.html",
        "signatures": [
            {
                "full": "getUserList()",
                "name": "getUserList",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getUserList](https://docs.dolphindb.com/en/Functions/g/getUserList.html)\n\n\n\n#### Syntax\n\ngetUserList()\n\n#### Arguments\n\nReturn a list of user names other than the administrators. This function can only be executed by administrators.\n\n#### Details\n\n```\nlogin(`admin, `123456);\ngetUserList().sort();\n// output\n[\"AA\",\"AAA\",\"BB\",\"BBB\",\"CC\",\"DeionSanders\",\"EliManning\",\"JoeFlacco\"]\n```\n"
    },
    "getUsersByGroupId": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getUsersByGroupId.html",
        "signatures": [
            {
                "full": "getUsersByGroupId(groupId)",
                "name": "getUsersByGroupId",
                "parameters": [
                    {
                        "full": "groupId",
                        "name": "groupId"
                    }
                ]
            }
        ],
        "markdown": "### [getUsersByGroupId](https://docs.dolphindb.com/en/Functions/g/getUsersByGroupId.html)\n\n\n\n#### Syntax\n\ngetUsersByGroupId(groupId)\n\n#### Arguments\n\n**groupId** a string indicating a group name.\n\n#### Details\n\nReturn a STRING vector of the user names that belong to the specified group. It can only be executed by an administrator.\n"
    },
    "getUserTableAccessRecords": {
        "url": "https://docs.dolphindb.com/en/Functions/g/getusertableaccessrecords.html",
        "signatures": [
            {
                "full": "getUserTableAccessRecords([from=0], [to])",
                "name": "getUserTableAccessRecords",
                "parameters": [
                    {
                        "full": "[from=0]",
                        "name": "from",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[to]",
                        "name": "to",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getUserTableAccessRecords](https://docs.dolphindb.com/en/Functions/g/getusertableaccessrecords.html)\n\n\n\n#### Syntax\n\ngetUserTableAccessRecords(\\[from=0], \\[to])\n\n#### Arguments\n\n**from** (optional) is an integral or temporal number indicating the start time of the query. The default value is 0, indicating the queried records starts from the record at 1970.01.01 00:00.\n\n**to** (optional) is an integral or temporal number indicating the end time of the query. The default value is NULL, indicating the query includes records up to the current time.\n\nNote that *from* must be no greater than *to*.\n\n#### Details\n\nGet the information stored in query logs (located at *\\<HomeDir>/resource/access.log)* within the specified time range. This function can only be called by the administrator on a data node.\n\nIt returns a table containing the following fields:\n\n* timestamp: a timestamp of NANOTIMESTAMP type. If type is sql, it indicates the time when the query execution starts; If type is rowCount or memUsage, it indicates the time when data is read.\n\n* rootQueryId: the query ID of a SQL query. It is the unique identifier for DFS SQL queries. A DFS query is split into multiple sub-queries by partition. This ID is the root ID for the DFS query and its sub-queries.\n\n* userId: the login user ID.\n\n* database: the queried database.\n\n* table: the queried table.\n\n* type: the message type, which can be sql, rowCount or memUsage.\n\n* value:\n\n  * the execution count (always 1) when type is *sql*.\n  * the number of records involved in the query when type is rowCount.\n  * the memory usage (in bytes) of the query results when type is *memUsage*.\n\n#### Examples\n\n```\ngetUserTableAccessRecords(2023.12.30T09:18:35.894150296,2023.12.30T09:18:35.894538439)\n// output\ntimestamp\trootQueryId\tuserId\tdatabase\ttable\ttype\tvalue\tscript\n2023.12.30T09:18:35.894150296\te892855b-7843-1492-0140-a85810662006\tadmin\tdfs://rangedb\tpt\tsql\t1\tselect count(x) as count_x from pt\n2023.12.30T09:18:35.894497304\te892855b-7843-1492-0140-a85810662006\tadmin\tdfs://rangedb\tpt\trowCount\t43\t\n2023.12.30T09:18:35.894501600\te892855b-7843-1492-0140-a85810662006\tadmin\tdfs://rangedb\tpt\tmemUsage\t516\t\n```\n"
    },
    "glm": {
        "url": "https://docs.dolphindb.com/en/Functions/g/glm.html",
        "signatures": [
            {
                "full": "glm(ds, yColName, xColNames, [family], [link], [tolerance=1e-6], [maxIter=100])",
                "name": "glm",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[family]",
                        "name": "family",
                        "optional": true
                    },
                    {
                        "full": "[link]",
                        "name": "link",
                        "optional": true
                    },
                    {
                        "full": "[tolerance=1e-6]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "1e-6"
                    },
                    {
                        "full": "[maxIter=100]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "100"
                    }
                ]
            }
        ],
        "markdown": "### [glm](https://docs.dolphindb.com/en/Functions/g/glm.html)\n\n\n\n#### Syntax\n\nglm(ds, yColName, xColNames, \\[family], \\[link], \\[tolerance=1e-6], \\[maxIter=100])\n\n#### Arguments\n\n**ds** is the data source to be trained. It can be generated with function [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html).\n\n**yColName** is a string indicating the dependent variable column.\n\n**xColNames** is a STRING scalar/vector indicating the names of the indepenent variable columns.\n\n**family** (optional) is a string indicating the type of distribution. It can be gaussian (default), poisson, gamma, inverseGuassian or binomial.\n\n**link** (optional) is a string indicating the type of the link function.\n\nPossible values of *link* and the dependent variable for each *family*:\n\n| family          | link                                   | default link    | dependent variable   |\n| --------------- | -------------------------------------- | --------------- | -------------------- |\n| gaussian        | identity, inverse, log                 | identity        | DOUBLE type          |\n| poisson         | log, sqrt, identity                    | log             | non-negative integer |\n| gamma           | inverse, identity, log                 | inverse         | y>=0                 |\n| inverseGaussian | nverseOfSquare, inverse, identity, log | inverseOfSquare | y>=0                 |\n| binomial        | logit, probit                          | logit           | y=0,1                |\n\n**tolerance** (optional) is a numeric scalar. The iterations stops if the difference in the value of the log likelihood functions of 2 adjacent iterations is smaller than tolerance. The default value is 0.000001.\n\n**maxIter** (optional) is a positive integer indicating the maximum number of iterations. The default value is 100.\n\n#### Details\n\nFit a generalized linear model. The result is a dictionary with the following keys: coefficients, link, tolerance, family, xColNames, tolerance, modelName, residualDeviance, iterations and dispersion.\n\n* coefficients is a table with the coefficient estimate, standard deviation, t value and p value for each coefficient;\n* modelName is \"Generalized Linear Model\";\n* iterations is the number of iterations;\n* dispersion is the dispersion coefficient of the model.\n\n#### Examples\n\nFit a generalized linear model model with simulated data:\n\n```\nx1 = rand(100.0, 100)\nx2 = rand(100.0, 100)\nb0 = 6\nb1 = 1\nb2 = -2\nerr = norm(0, 10, 100)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(x1, x2, y)\nmodel = glm(sqlDS(<select * from t>), `y, `x1`x2, `gaussian, `identity);\nmodel;\n\n// output\ncoefficients->\n\nbeta     stdError tstat      pvalue\n-------- -------- ---------- --------\n1.027483 0.032631 31.487543  0\n-1.99913 0.03517  -56.842186 0\n5.260677 2.513633 2.092858   0.038972\n\nlink->identity\ntolerance->1.0E-6\nfamily->gaussian\nxColNames->[\"x1\",\"x2\"]\nmodelName->Generalized Linear Model\nresidualDeviance->8873.158697\niterations->5\ndispersion->91.475863\n```\n\nUse the fitted model in forecasting:\n\n```\npredict(model, t);\n```\n\nSave the fitted model to disk:\n\n```\nsaveModel(model, \"C:/DolphinDB/Data/GLMModel.txt\");\n```\n\nLoad a saved model:\n\n```\nloadModel(\"C:/DolphinDB/Data/GLMModel.txt\");\n```\n"
    },
    "gmm": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gmm.html",
        "signatures": [
            {
                "full": "gmm(X, k, [maxIter=300], [tolerance=1e-4], [randomSeed], [mean], [sigma])",
                "name": "gmm",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "k",
                        "name": "k"
                    },
                    {
                        "full": "[maxIter=300]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "300"
                    },
                    {
                        "full": "[tolerance=1e-4]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "1e-4"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    },
                    {
                        "full": "[mean]",
                        "name": "mean",
                        "optional": true
                    },
                    {
                        "full": "[sigma]",
                        "name": "sigma",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [gmm](https://docs.dolphindb.com/en/Functions/g/gmm.html)\n\n\n\n#### Syntax\n\ngmm(X, k, \\[maxIter=300], \\[tolerance=1e-4], \\[randomSeed], \\[mean], \\[sigma])\n\n#### Arguments\n\n**X** is the training data set. For univariate data, *X* is a vector; For multivariate data, *X* is a matrix/table where each column is a sample.\n\n**k** is an integer indicating the number of independent Gaussians in a mixture model.\n\n**maxlter** (optional) is a positive integer indicating the maximum EM iterations to perform. The default value is 300.\n\n**tolerance** (optional) is a floating-point number indicating the convergence tolerance. EM iterations will stop when the lower bound average gain is below this threshold. The default value is 1e-4.\n\n**randomSeed** (optional) is the random seed given to the method.\n\n**mean** (optional) is a vector or matrix indicating the initial means.\n\n* For univariate data, it is a vector of length *k*;\n\n* For multivariate data, it is a matrix whose number of columns is *k* and number of rows is the same as the number of variables in *X*;\n\n* If *mean* is unspecified, *k* values are randomly selected from *X* as the initial means.\n\n**sigma** (optional) can be\n\n* a vector, indicating the initialized variance of each submodel if *X* is univariate data;\n\n* a tuple of length *k*, indicating the covariance matrix of each submodel if *X* is multivariate data;\n\n* a vector with element values of 1 or an identity matrix if sigma is unspecified.\n\n#### Details\n\nTrain the Gaussian Mixture Model (GMM) with the given data set. Return a dictionary with the following keys:\n\n* modelName: a string \"Gaussian Mixture Model\"\n\n* prior: the prior probability of each submodel\n\n* mean: the expectation of each submodel\n\n* sigma: If *X* is univariate data, it represents the variance of each submodel; If *X* is multivariate data, it represents the covariance matrix of each submodel.\n\n#### Examples\n\n```\ndataT = 6.8 7.2 5.3 9.4 6.5 11.2 25.6 0.6 8.9 4.3 2.2 1.9 8.7 0.2 1.5\nmean = [2, 2]\nre = gmm(dataT, 2, 300, 1e-4, 42, mean)\nre\n// output\nsigma->[36.759822,36.759822]\nmodelName->Gaussian Mixture Model\nprior->[0.5,0.5]\nmean->[6.686667,6.686667]\n\ndataT = transpose(matrix(3.2 1.5 2.6 7.8 6.3 4.2 5.1 8.9 11.2 25.8, 25.6 4.6 8.9 4.3 2.2 1.9 8.7 0.2 1.5 9.3))\nmean = transpose(matrix([1, 0], [0, 1]))\nre = gmm(dataT, 2, 300, 1e-4, 42, mean)\nre\n// output\nsigma->(#0        #1\n51.001369 18.273032\n18.273032 9.34789\n,#0       #1\n1.718475 0.629584\n0.629584 67.713701\n)\nmodelName->Gaussian Mixture Model\nprior->[0.558683,0.441317]\nmean->\n#0        #1\n11.152841 3.238262\n3.341493  10.996997\n```\n"
    },
    "gmtime": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gmtime.html",
        "signatures": [
            {
                "full": "gmtime(X)",
                "name": "gmtime",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [gmtime](https://docs.dolphindb.com/en/Functions/g/gmtime.html)\n\n\n\n#### Syntax\n\ngmtime(X)\n\n#### Arguments\n\n**X** is a scalar or a vector. The data type of *X* can be DATETIME, TIMESTAMP, or NANOTIMESTAMP.\n\n#### Details\n\nConvert *X* from local time zone to GMT (Greenwich Mean Time).\n\n#### Examples\n\nThe following examples were conducted in US Eastern time zone.\n\n```\ngmtime(2018.01.22 10:20:26);\n// output\n2018.01.22T15:20:26\n\ngmtime(2017.12.16T13:30:10.008);\n// output\n2017.12.16T18:30:10.008\n```\n"
    },
    "gpFit": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gpFit.html",
        "signatures": [
            {
                "full": "gpFit(engine, [programNum=1], [programCorr=false])",
                "name": "gpFit",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "[programNum=1]",
                        "name": "programNum",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[programCorr=false]",
                        "name": "programCorr",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [gpFit](https://docs.dolphindb.com/en/Functions/g/gpFit.html)\n\n**Note:** This function is not supported by Community Edition. You can [get a trial](https://dolphindb.com/product#downloads-down) of Shark from DolphinDB official website.\n\n#### Syntax\n\ngpFit(engine, \\[programNum=1], \\[programCorr=false])\n\n#### Arguments\n\n**engine** is the engine object returned by `createGPLearnEngine`.\n\n**programNum** (optional) is an integer specifying the number of programs returned.\n\n**programCorr** (optional) is a Boolean value indicating whether to return the correlation between programs. The default value is false.\n\n#### Details\n\nGet the trained programs. It returns a table with the following columns:\n\n* program: STRING type, the generated programs.\n\n* fitness: DOUBLE type, the fitness.\n\n* programCorr (if *programCorr*=true): a DOUBLE array vector, the correlation between programs.\n\n#### Examples\n\nSee [Quick Start Guide for Shark GPLearn](https://docs.dolphindb.com/en/Tutorials/gplearn_qsg.html)\n\n"
    },
    "gpPredict": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gpPredict.html",
        "signatures": [
            {
                "full": "gpPredict(engine, input, [programNum=1], [groupCol], [deviceId=0])",
                "name": "gpPredict",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "input",
                        "name": "input"
                    },
                    {
                        "full": "[programNum=1]",
                        "name": "programNum",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[groupCol]",
                        "name": "groupCol",
                        "optional": true
                    },
                    {
                        "full": "[deviceId=0]",
                        "name": "deviceId",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [gpPredict](https://docs.dolphindb.com/en/Functions/g/gpPredict.html)\n\n**Note:** This function is not supported by Community Edition. You can [get a trial](https://dolphindb.com/product#downloads-down) of Shark from DolphinDB official website.\n\n#### Syntax\n\ngpPredict(engine, input, \\[programNum=1], \\[groupCol], \\[deviceId=0])\n\n#### Arguments\n\n**engine** is the engine object returned by `createGPLearnEngine`.\n\n**input** is a table where all columns are of floating-point type indicating the data for prediction.\n\n**programNum** (optional) is an integer specifying the number of programs used for prediction.\n\n**groupCol**(optional) is a string indicating the grouping column. The default is empty. The grouping column will not participate in calculation.\n\n**deviceId** (optional) is an INT scalar or vector specifying the device ID to be used. The default value is 0.\n\n#### Details\n\nUse a number of *programNum*formulas with better fitness obtained from last training for prediction. Calculation will be conducted by group if *groupCol*is specified.\n\nIt returns a table with a number of *programNum*columns, where each column corresponds to a formula trained by `gpFit`.\n\n#### Examples\n\nSee [Quick Start Guide for Shark GPLearn](https://docs.dolphindb.com/en/Tutorials/gplearn_qsg.html)\n\n"
    },
    "gram": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gram.html",
        "signatures": [
            {
                "full": "gram(ds, [colNames], [subMean], [normalize])",
                "name": "gram",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "[colNames]",
                        "name": "colNames",
                        "optional": true
                    },
                    {
                        "full": "[subMean]",
                        "name": "subMean",
                        "optional": true
                    },
                    {
                        "full": "[normalize]",
                        "name": "normalize",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [gram](https://docs.dolphindb.com/en/Functions/g/gram.html)\n\n\n\n#### Syntax\n\ngram(ds, \\[colNames], \\[subMean], \\[normalize])\n\n#### Arguments\n\n**ds** is one or multiple data source. It is usually generated by function [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html).\n\n**colNames** (optional) is a STRING vector indicating column names. The default value is all columns names in *ds*.\n\n**subMean** (optional) is a Boolean value indicating whether to substract from each column its mean. The default value is true.\n\n**normalize** (optional) is a Boolean value indicating whether to divide each column by its standard deviation. The default value is false.\n\n#### Details\n\nCalculate the Gram matrix of the selected columns in the given table. With a given matrix A, the result is `A.tranpose() dot A`.\n\n#### Examples\n\n```\nx = [7,1,1,0,5,2]\ny = [0.7, 0.9, 0.01, 0.8, 0.09, 0.23]\nt=table(x, y)\nds = sqlDS(<select * from t>);\ngram(ds);\n```\n\n| #0        | #1      |\n| --------- | ------- |\n| 37.333333 | -0.56   |\n| -0.56     | 0.75895 |\n"
    },
    "gramSchmidt": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gramSchmidt.html",
        "signatures": [
            {
                "full": "gramSchmidt(X, [normalize = false])",
                "name": "gramSchmidt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[normalize = false]",
                        "name": "[normalize = false]"
                    }
                ]
            }
        ],
        "markdown": "### [gramSchmidt](https://docs.dolphindb.com/en/Functions/g/gramSchmidt.html)\n\n\n\n#### Syntax\n\ngramSchmidt(X, \\[normalize = false])\n\n#### Arguments\n\n**X** is a matrix where each column (as a vector) is linearly independent, i.e., the matrix has column full rank. It cannot contain any NULL values.\n\n**normalize** (optional) is a Boolean value indicating whether to output a normalized orthogonal matrix. The default value is false.\n\n#### Details\n\nThis function converts a matrix of full column rank into an orthogonal matrix.\n\n**Return value**: a matrix of DOUBLE type.\n\n#### Examples\n\n```\nx = matrix([2 3 5, 3 6 2, 8 3 6]);\ngramSchmidt(x)\n\n// output\ncol1    col2    col3\n2.0000  1.2105  4.7932\n3.0000  3.3157  -2.1968\n5.0000  -2.4736 -0.5991\n\n// If normalize=true, a normalized orthogonal matrix is returned.\ngramSchmidt(x, true)\n// output\ncol1    col2    col3\n0.3244      0.2808  0.9033\n0.4867      0.7693  -0.414\n0.8111      -0.5739 -0.1129\n\nx = matrix([1 4, 2 5, 3 6]);\ngramSchmidt(x)\n// An error is raised when the columns of the matrix are linearly dependent.\nvector set must be linearly independent\n```\n"
    },
    "grant": {
        "url": "https://docs.dolphindb.com/en/Functions/g/grant.html",
        "signatures": [
            {
                "full": "grant(userId|groupId,accessType,[objs])",
                "name": "grant",
                "parameters": [
                    {
                        "full": "userId|groupId",
                        "name": "userId|groupId"
                    },
                    {
                        "full": "accessType",
                        "name": "accessType"
                    },
                    {
                        "full": "[objs]",
                        "name": "objs",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [grant](https://docs.dolphindb.com/en/Functions/g/grant.html)\n\n\n\n#### Syntax\n\ngrant(userId|groupId,accessType,\\[objs])\n\n#### Arguments\n\n**userId** | **groupId** is a string indicating a user name or a group name.\n\n**accessType** is the privilege type or memory limit.\n\n**objs** (optional) is a STRING scalar/vector indicating the objects that the priviledges specified by *accessType* applies to.\n\nSee the privilege table in [User Access Control](https://docs.dolphindb.com/en/Maintenance/UserAccessControl.html) for the values that *accessType* and *objs* can take.\n\n#### Details\n\n1. Grant a user or group with the specified privilege.\n2. Set the memory limit of a query result (when *accessType* = QUERY\\_RESULT\\_MEM\\_LIMIT) or the memory limit of a task group (when *accessType* = TASK\\_GROUP\\_MEM\\_LIMIT) for a user. Different from commands [setMemLimitOfQueryResult](https://docs.dolphindb.com/en/Functions/s/setMemLimitOfQueryResult.html) and [setMemLimitOfTaskGroupResult](https://docs.dolphindb.com/en/Functions/s/setMemLimitOfTaskGroupResult.html), `grant` only applies to the specified user (group is not supported). You can use `revoke` to remove the memory limit set with `grant`.\n\nAdministrators can grant users all privileges (*accessType*) through this command, but regular users, after having the relevant OWNER privileges, can only grant the following privileges through this command: TABLE\\_READ, TABLE\\_WRITE, TABLE\\_INSERT, TABLE\\_UPDATE, TABLE\\_DELETE, DB\\_READ, DB\\_WRITE, DB\\_INSERT, DB\\_UPDATE, DB\\_DELETE, DBOBJ\\_DELETE, DBOBJ\\_CREATE and VIEW\\_EXEC.\n\nWhen the *accessType*is DB\\_OWNER, *objs*can be specified as a prefix rule to limit the databases that the user can create and manage. Multiple prefix rules can be passed in a vector to *objs*. If there is already a global DB\\_OWNER privilege granted, adding prefix rules will be invalid. Prefix rules do not override each other if one contains the other. The authorized prefix rules can be viewed using the `getUserAccess` function.\n\nWhen a user attempts to create or manage a database, if the user's privilege is denied globally, the operation is prohibited; otherwise, the user's privileges are the union of all the prefix rules, meaning if the database name matches any of the authorized prefix rules, the operation is permitted.\n\nNote that the prefix rules can only be specified with function `grant`, and revoked with `revoke`, but cannot be denied with `deny`. When the *accessType*is DB\\_OWNER, `deny` only takes effect at a global scope and overrides all previously-defined prefix rules.\n\n#### Examples\n\nGrant all members of group \"production\" the read privilege to all tables and databases:\n\n```\ngrant(`production, TABLE_READ, \"*\")\n```\n\nGrant all members of group \"research\" the write privilege to the table \"dfs\\://db1/t1\":\n\n```\ngrant(`research, TABLE_WRITE, \"dfs://db1/t1\")\n```\n\nGrant all members of group \"research\" the table creation privilege to the databases \"dfs\\://db1\" and \"dfs\\://db2\":\n\n```\ngrant(\"research\", DBOBJ_CREATE, [\"dfs://db1\",\"dfs://db2\"])\n```\n\nGrant the user \"AlexSmith\" the DB\\_MANAGE privilege:\n\n```\ngrant(\"AlexSmith\", DB_MANAGE)\n```\n\nGrant the user \"AlexSmith\" the script execution privilege:\n\n```\ngrant(\"AlexSmith\", SCRIPT_EXEC)\n```\n\nGrant the user \"AlexSmith\" the script test privilege:\n\n```\ngrant(\"AlexSmith\", TEST_EXEC)\n```\n\nGrant the user \"AlexSmith\" the execution privilege of function `f1` under the namespace test1:\n\n```\ngrant(\"AlexSmith\", VIEW_EXEC, \"test1::f1\")\n```\n\nGrant the user \"AlexSmith\" the execution privilege of all functions under the namespace test2:\n\n```\ngrant(\"AlexSmith\", VIEW_EXEC, \"test2::*\")\n```\n\nThe namespace must be a module name. For example, for a module test.dos under the directory moduleDir/mod1/test.dos, grant the user the execution privileges of all functions under the module namespace:\n\n```\ngrant(\"AlexSmith\", VIEW_EXEC, \"mod1::test::*\")\n```\n\nThe following script is not supported:\n\n```\ngrant(\"AlexSmith\", VIEW_EXEC, \"mod1::*\")\n```\n\nIf privilege on a namespace is granted, and later the function views in the namespace are removed with `dropFunctionView`, once the last function view in the namespace is deleted, the authorization for that namespace will also be automatically revoked. Similarly, if there are no function views in the namespace at the time of authorization, an exception will be thrown. For function views without a namespace, they are considered global. The following two methods are equivalent:\n\n```\ngrant(\"AlexSmith\", VIEW_EXEC, \"::f\")\ngrant(\"AlexSmith\", VIEW_EXEC, f)\n```\n\nSet the memory limit of query result to 4 GB for the user \"AlexSmith\".\n\n```\ngrant(\"AlexSmith\", QUERY_RESULT_MEM_LIMIT, 4)\n```\n\nGrant user \"AlexSmith\" the privilege to create and manage databases with prefix \"dbxxx\".\n\n```\ngrant(\"AlexSmith\", DB_OWNER, \"dfs://ddb*\")\n```\n\nMultiple patterns can be passed in a vector to *objs*. For example:\n\n```\ngrant(\"AlexSmith\", DB_OWNER, [\"dfs://ddb_prefix1*\",\"dfs://ddb_prefix2*\"])\n```\n"
    },
    "groups": {
        "url": "https://docs.dolphindb.com/en/Functions/g/groups.html",
        "signatures": [
            {
                "full": "groups(X, [mode='dict'])",
                "name": "groups",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[mode='dict']",
                        "name": "mode",
                        "optional": true,
                        "default": "'dict'"
                    }
                ]
            }
        ],
        "markdown": "### [groups](https://docs.dolphindb.com/en/Functions/g/groups.html)\n\n\n\n#### Syntax\n\ngroups(X, \\[mode='dict'])\n\n#### Arguments\n\n**X** is a vector.\n\n**mode** (optional) indicates the data form returned by the function. It can be:\n\n* \"dict\" (default): return a dictionary. The key of the dictionary stores the unique value in *X*; the value is a vector that stores the indices of all elements that hold the value.\n\n* \"table\": return a table with 2 columns, \"key\" and \"index\", storing the unique value in *X* and the corresponding indices.\n\n* \"vector\": return an array vector. The elements are the indices of each unique value in *X*, sorted in ascending order.\n\n* \"tuple\": return a tuple. The elements are stored the same as mode=\"vector\".\n\n#### Details\n\nFor each unique value in *X*, return the indices of all elements that hold the value.\n\n* If *mode* = \"dict\", return a dictionary.\n* If *mode* = \"table\", return a table with 2 columns, key and index. Each cell in the column index is an array vector.\n\n#### Examples\n\n```\nx=NULL NULL 12 15 12 16 15 14 NULL NULL\ngroups(x);\n\n// output\n16->[5]\n->[0,1,8,9]\n12->[2,4]\n14->[7]\n15->[3,6]\n\ngroups\\(x, \"vector\"\\)\n// output\n\\[\\[0,1,8,9\\],\\[2,4\\],\\[7\\],\\[3,6\\],\\[5\\]\\]\n\ngroups\\(x, \"tuple\"\\)\n// output\n\\(\\[0,1,8,9\\],\\[2,4\\],\\[7\\],\\[3,6\\],\\[5\\]\\)\n\ngroups\\(x, \"table\"\\)\n```\n\n| key | index    |\n| --- | -------- |\n|     | \\[0,1,8] |\n| 2   | \\[2,4]   |\n| 4   | \\[7]     |\n| 5   | \\[3,6]   |\n| 6   | \\[5]     |\n"
    },
    "gt": {
        "url": "https://docs.dolphindb.com/en/Functions/g/gt.html",
        "signatures": [
            {
                "full": "gt(X, Y)",
                "name": "gt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [gt](https://docs.dolphindb.com/en/Functions/g/gt.html)\n\n\n\n#### Syntax\n\ngt(X, Y)\n\nor\n\nX>Y\n\n#### Arguments\n\n**X** and **Y** is a scalar/pair/vector/matrix/set. If *X* or *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nIf neither *X* nor *Y* is a set, return the element-by-element comparison of *X*>*Y*.\n\nIf both *X* and *Y* are sets, check if *Y* is a proper subset of *X*.\n\n#### Examples\n\n```\n1 2 3 > 2;\n// output\n[false,false,true]\n\n1 2 3>0 2 4;\n// output\n[true,false,false]\n\n2:3>1:6;\n// output\ntrue : false\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 gt 4;\n```\n\n| #0    | #1    | #2   |\n| ----- | ----- | ---- |\n| false | false | true |\n| false | false | true |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1>m2;\n```\n\n| #0    | #1    | #2   |\n| ----- | ----- | ---- |\n| false | false | true |\n| false | true  | true |\n\nSet operation: If *X*>*Y* then *Y* is a proper subset of *X*.\n\n```\nx=set(4 6);\nx;\n\nset(6,4)\n\ny=set(8 9 4 6);\ny;\n\nset(6,4,9,8)\ny>x;\n// output\ntrue\n\nx>y;\n// output\nfalse\n\nx>x;\n// output\nfalse  // x is not a proper subset of x\n```\n"
    },
    "qclp": {
        "url": "https://docs.dolphindb.com/en/Functions/q/qclp.html",
        "signatures": [
            {
                "full": "qclp(r, V, k, [A], [b], [Aeq], [beq], [x0], [c], [eps], [alpha])",
                "name": "qclp",
                "parameters": [
                    {
                        "full": "r",
                        "name": "r"
                    },
                    {
                        "full": "V",
                        "name": "V"
                    },
                    {
                        "full": "k",
                        "name": "k"
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[b]",
                        "name": "b",
                        "optional": true
                    },
                    {
                        "full": "[Aeq]",
                        "name": "Aeq",
                        "optional": true
                    },
                    {
                        "full": "[beq]",
                        "name": "beq",
                        "optional": true
                    },
                    {
                        "full": "[x0]",
                        "name": "x0",
                        "optional": true
                    },
                    {
                        "full": "[c]",
                        "name": "c",
                        "optional": true
                    },
                    {
                        "full": "[eps]",
                        "name": "eps",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [qclp](https://docs.dolphindb.com/en/Functions/q/qclp.html)\n\n\n\n#### Syntax\n\nqclp(r, V, k, \\[A], \\[b], \\[Aeq], \\[beq], \\[x0], \\[c], \\[eps], \\[alpha])\n\n#### Arguments\n\n**V**, **A** and **Aeq** must be matrices with the same number of columns.\n\n**r**, **b** and **beq** are vectors.\n\n**k** is a positive scalar.\n\n**x0** is a vector of coefficients for absolute value inequality constraints.\n\n**c** is a non-negative number representing the right-hand constant for absolute value inequality constraints.\n\n**eps** is a positive floating-point number representing the solution precision. The default value is 1e-6, and the range is \\[1e-4, 1e-9]. A solution with higher precision can be obtained by decreasing eps. If a value beyond the range is set, it will be adjusted to the default value.\n\n**alpha** is a positive floating-point number representing the relaxation parameter. The default value is 1.5, and the range is (0,2). The solution process can be sped up by increasing *alpha*. If a value beyond the range is set, it will be adjusted to the default value.\n\n#### Details\n\nSolve the following optimization problem with a linear objective function and a set of constraints including a quadratic constraint.\n\n![](https://docs.dolphindb.com/en/images/qclp.png)\n\nThe result is a 2-element tuple. The first element is the minimum value of the objective function. The second element is the value of x where the value of the objective function is minimized.\n\n#### Examples\n\nDetermine the optimal portfolio based on expected average returns (r) and the variance-covariance matrix (V) of selected stocks, and the constraints that the volatility of the portfolio should be no more than 11% and the weight of each stock in the portfolio is between 10% and 50%.\n\n```\nr = 0.18 0.25 0.36\nV= 0.0225 -0.003 -0.01125 -0.003 0.04 0.025 -0.01125 0.025 0.0625 $ 3:3\nk = pow(0.11, 2)\nA = (eye(3) join (-1*eye(3))).transpose()\nb = 0.5 0.5 0.5 -0.1 -0.1 -0.1\nAeq = (1 1 1)$1:3\nbeq = [1]\n\nx = qclp(-r, V, k, A, b, Aeq, beq);\n\nx[1];\n// output: [0.5,0.176297,0.323703]\n```\n\nBased on the above example, adding absolute value constraints | x1 - 0.35| + | x2 - 0.35 | + | x3 - 0.35 | ≤ 0.3 :\n\n```\nx0 = [0.35, 0.35, 0.35];\nc = 0.3;\ny = qclp(-r, V, k, A, b, Aeq, beq, x0, c);\ny[1]\n// output\n[0.475001,0.247962,0.277037]\n```\n"
    },
    "qr": {
        "url": "https://docs.dolphindb.com/en/Functions/q/qr.html",
        "signatures": [
            {
                "full": "qr(obj, [mode='full'], [pivoting=false])",
                "name": "qr",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[mode='full']",
                        "name": "mode",
                        "optional": true,
                        "default": "'full'"
                    },
                    {
                        "full": "[pivoting=false]",
                        "name": "pivoting",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [qr](https://docs.dolphindb.com/en/Functions/q/qr.html)\n\n\n\n#### Syntax\n\nqr(obj, \\[mode='full'], \\[pivoting=false])\n\n#### Arguments\n\n**obj** is a matrix.\n\n**mode** is a string indicating what information is to be returned. It can be \"full\", \"economic\" or \"r\". The default value is \"full\".\n\n**pivoting** is a Boolean value. The default value is false.\n\n#### Details\n\nPerform the QR decomposition of a matrix. Decompose a matrix A into an orthogonal matrix Q and an upper triangular matrix R, with A=Q\\*R.\n\nGiven an m-by-n matrix A:\n\n* If *mode*=\"full\", return 2 matrices: Q (m-by-m) and R (m-by-n).\n\n* If *mode*=\"economic\", return 2 matrices: Q (m-by-k) and R (k-by-n) with k=min(m,n).\n\n* If *mode*=\"r\", only return matrix R (m-by-n).\n\nIf *pivoting*= true, also return a vector P which has the same length as the number of columns of the matrix. P is the pivoting for rank-revealing QR decomposition indicating the location of 1s in the permutation matrix.\n\n#### Examples\n\n```\nA = matrix([2,5,7,5], [5,2,5,4], [8,2,6,4]);\n\nQ,R = qr(A);\nQ;\n```\n\n| #0        | #1        | #2        | #3        |\n| --------- | --------- | --------- | --------- |\n| -0.197066 | 0.903357  | 0.300275  | 0.234404  |\n| -0.492665 | -0.418267 | 0.459245  | 0.609449  |\n| -0.68973  | -0.02475  | 0.170745  | -0.703211 |\n| -0.492665 | 0.091573  | -0.818398 | 0.281284  |\n\n```\nR;\n```\n\n| #0         | #1       | #2        |\n| ---------- | -------- | --------- |\n| -10.148892 | -7.38997 | -8.670898 |\n| 0          | 3.922799 | 6.608121  |\n| 0          | 0        | 1.071571  |\n| 0          | 0        | 0         |\n\n```\nQ,R=qr(A,mode='economic');\nQ;\n```\n\n| #0        | #1        | #2        |\n| --------- | --------- | --------- |\n| -0.197066 | 0.903357  | 0.300275  |\n| -0.492665 | -0.418267 | 0.459245  |\n| -0.68973  | -0.02475  | 0.170745  |\n| -0.492665 | 0.091573  | -0.818398 |\n\n```\nR;\n```\n\n| #0         | #1       | #2        |\n| ---------- | -------- | --------- |\n| -10.148892 | -7.38997 | -8.670898 |\n| 0          | 3.922799 | 6.608121  |\n| 0          | 0        | 1.071571  |\n\n```\nQ,T,R=qr(A,mode='raw');\nR;\n```\n\n| #0         | #1       | #2        |\n| ---------- | -------- | --------- |\n| -10.148892 | -7.38997 | -8.670898 |\n| 0.41156    | 3.922799 | 6.608121  |\n| 0.576184   | 0.3046   | 1.071571  |\n| 0.41156    | 0.156539 | 0.900419  |\n\n```\nT;\n// output\n[1.197066,1.790053,1.104512]\n\nR\n```\n\n| #0         | #1       | #2        |\n| ---------- | -------- | --------- |\n| -10.148892 | -7.38997 | -8.670898 |\n| 0          | 3.922799 | 6.608121  |\n| 0          | 0        | 1.071571  |\n\n```\nQ,T,R,P = qr(A,mode='raw',pivoting=true);\nQ;\n```\n\n| #0         | #1        | #2        |\n| ---------- | --------- | --------- |\n| -10.954451 | -8.033264 | -8.215838 |\n| 0.105516   | -6.20215  | -1.45111  |\n| 0.316548   | 0.37699   | -0.627918 |\n| 0.211032   | 0.284188  | 0.936372  |\n\n```\nT;\n// output\n[1.730297,1.635478,1.065648]\n\nR\n```\n\n| #0         | #1        | #2        |\n| ---------- | --------- | --------- |\n| -10.954451 | -8.033264 | -8.215838 |\n| 0          | -6.20215  | -1.45111  |\n| 0          | 0         | -0.627918 |\n\n```\nP;\n// output\n[2,0,1]\n```\n"
    },
    "quadprog": {
        "url": "https://docs.dolphindb.com/en/Functions/q/quadprog.html",
        "signatures": [
            {
                "full": "quadprog(H, f, [A], [b], [Aeq], [beq])",
                "name": "quadprog",
                "parameters": [
                    {
                        "full": "H",
                        "name": "H"
                    },
                    {
                        "full": "f",
                        "name": "f"
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[b]",
                        "name": "b",
                        "optional": true
                    },
                    {
                        "full": "[Aeq]",
                        "name": "Aeq",
                        "optional": true
                    },
                    {
                        "full": "[beq]",
                        "name": "beq",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [quadprog](https://docs.dolphindb.com/en/Functions/q/quadprog.html)\n\n\n\n#### Syntax\n\nquadprog(H, f, \\[A], \\[b], \\[Aeq], \\[beq])\n\n#### Arguments\n\n**H**, **A** and **Aeq** must be matrices with the same number of columns.\n\n**f**, **b** and **beq** are vectors.\n\n**A** is the coefficient matrix of linear inequality constraints.\n\n**b** is the right-hand-side vector of the linear inequality constraint.\n\n**Aeq** is a linear equality constraint coefficient matrix.\n\n**beq** is the right-hand-side vector of the linear equality constraint.\n\n#### Details\n\nSolve the following optimization problem with a quadratic objective function and a set of linear constraints.\n\n![](https://docs.dolphindb.com/en/images/quadprog.png)\n\nThe result is a 2-element tuple. The first element is the minimum value of the objective function. The second element is the value of x where the value of the objective function is minimized.\n\n#### Examples\n\nExample 1: Find the minimum of ![](https://docs.dolphindb.com/en/images/quadprog1.png)\n\n```\nH=matrix([2 -2,-2 6])\nf=[-5,4]\nx=quadprog(H,f);\n\nx[0];\n// output\n-6.375\n\nx[1];\n// output\n[2.75,0.25]\n```\n\nExample 2: Find the minimum of\n\n![](https://docs.dolphindb.com/en/images/quadprog1.png)\n\nsubject to the constraints of\n\n![](https://docs.dolphindb.com/en/images/quadprog2.png)\n\n```\nH=matrix([2 -2,-2 6])\nf=[-5,4]\nA=matrix([1 -1 6, 1 3 1])\nb=[10, 8, 5]\nx=quadprog(H,f,A,b);\n\nx[0];\n// output\n-4.092975\n\nx[1];\n// output\n[0.904959, -0.429752]\n```\n\nExample 3: Find the minimum of\n\n![](https://docs.dolphindb.com/en/images/quadprog1.png)\n\nsubject to the constraints of\n\n![](https://docs.dolphindb.com/en/images/quadprog3.png)\n\n```\nH=matrix([2 -2,-2 6])\nf=[-5,4]\nA=matrix([1 -1 6, 1 3 1])\nb=[10, 8, 5]\nAeq=matrix([1],[2])\nbeq=[1]\nx=quadprog(H,f,A,b,Aeq,beq);\n\nx[0];\n// output\n-3.181818\n\nx[1];\n// output\n[0.818182,0.090909]\n```\n\nThe 3 examples above share the same objective function. Example 1 has no constaints and achieves the lowest minimum value. Example 3 has more constaints than example 2 and therefore can only achieve a higher minimum value than both example 2 and example 1.\n"
    },
    "quantile": {
        "url": "https://docs.dolphindb.com/en/Functions/q/quantile.html",
        "signatures": [
            {
                "full": "quantile(X, q, [interpolation='linear'])",
                "name": "quantile",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "q",
                        "name": "q"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    }
                ]
            }
        ],
        "markdown": "### [quantile](https://docs.dolphindb.com/en/Functions/q/quantile.html)\n\n\n\n#### Syntax\n\nquantile(X, q, \\[interpolation='linear'])\n\n#### Arguments\n\n**X** is a numeric vector, matrix or table.\n\n**q** is a floating number between 0 and 1.\n\n**interpolation** is a string indicating how to interpolate if the quantile is between element i and j in *X* with i\\<j. It can take the following values:\n\n* 'linear' (default): i+(j-i)\\*fraction, where fraction is the decimal part of *q*\\*size(X).\n\n* 'lower': i\n\n* 'higher': j\n\n* 'nearest': i or j whichever is nearest.\n\n* 'midpoint': (i+ j)/2\n\n#### Details\n\nReturn values at the given quantile in *X*.\n\n#### Examples\n\n```\na=[6, 47, 49, 15, 42, 41, 7, 39, 43, 40, 36];\nquantile(a,0.25);\n// output\n25.5\n\nquantile(a,0.5);\n// output\n40\n\nquantile(a,0.75);\n// output\n42.5\n\nquantile(a,0.75, 'lower');\n// output\n42\n```\n\nRelated function: [quantileSeries](https://docs.dolphindb.com/en/Functions/q/quantileSeries.html)\n"
    },
    "quantileSeries": {
        "url": "https://docs.dolphindb.com/en/Functions/q/quantileSeries.html",
        "signatures": [
            {
                "full": "quantileSeries(X, q, [interpolation='linear'])",
                "name": "quantileSeries",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "q",
                        "name": "q"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    }
                ]
            }
        ],
        "markdown": "### [quantileSeries](https://docs.dolphindb.com/en/Functions/q/quantileSeries.html)\n\n\n\n#### Syntax\n\nquantileSeries(X, q, \\[interpolation='linear'])\n\n#### Arguments\n\n**X** is a numeric vector.\n\n**q** is a scalar or vector of floating numbers between 0 and 1.\n\n**interpolation** is a string indicating how to interpolate if the quantile is between element i and j in X with i\\<j. It can take the following values and the default value is 'linear'.\n\n* 'linear' (default): i+(j-i)\\*fraction, where fraction is the decimal part of *q*\\*size(X).\n\n* 'lower': i\n\n* 'higher': j\n\n* 'nearest': i or j whichever is nearest.\n\n* 'midpoint': (i+ j)/2\n\n#### Details\n\nReturn values at the given quantile in *X*.\n\n#### Examples\n\n```\na=[6, 47, 49, 15, 42, 41, 7, 39, 43, 40, 36];\nquantileSeries(a,[0.25,0.5,0.75]);\n// output\n[25.5,40,42.5]\n\nquantileSeries(a,[0.25,0.5,0.75], 'higher');\n// output\n[36,40,43]\n```\n\nRelated function: [quantile](https://docs.dolphindb.com/en/Functions/q/quantile.html)\n"
    },
    "quarterBegin": {
        "url": "https://docs.dolphindb.com/en/Functions/q/quarterBegin.html",
        "signatures": [
            {
                "full": "quarterBegin(X, [startingMonth=1], [offset], [n=1])",
                "name": "quarterBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [quarterBegin](https://docs.dolphindb.com/en/Functions/q/quarterBegin.html)\n\n\n\n#### Syntax\n\nquarterBegin(X, \\[startingMonth=1], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**startingMonth** is an integer between 1 and 12 indicating a month. The default value is 1.\n\n**offset** is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the first day of the quarter that *X* belongs to. The first months of the quarters are determined by *startingMonth*. Note that *startingMonth*=1 is equivalent to *startingMonth*=4, 7 or 10.\n\nIf parameter *offset* is specified, the result is updated every *n* quarters. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nquarterBegin(2012.06.12);\n// output\n2012.04.01\n\nquarterBegin(2012.06.13 10:10:10.008,5);\n// output\n2012.05.01\n\ndate=2016.01.12 2016.02.25 2016.05.12 2016.06.28 2016.07.10 2016.08.18 2016.09.02 2016.10.16 2016.11.26 2016.12.30\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by quarterBegin(date,1,2016.01.01,2)\n```\n\n| quarterBegin\\_date | avg\\_price | sum\\_qty |\n| ------------------ | ---------- | -------- |\n| 2016.01.01         | 34.65      | 9400     |\n| 2016.07.01         | 92.491667  | 29300    |\n\nRelated functions: [quarterEnd](https://docs.dolphindb.com/en/Functions/q/quarterEnd.html), [businessQuarterBegin](https://docs.dolphindb.com/en/Functions/b/businessQuarterBegin.html), [businessQuarterEnd](https://docs.dolphindb.com/en/Functions/b/businessQuarterEnd.html)\n"
    },
    "quarterEnd": {
        "url": "https://docs.dolphindb.com/en/Functions/q/quarterEnd.html",
        "signatures": [
            {
                "full": "quarterEnd(X, [endingMonth=12], [offset], [n=1])",
                "name": "quarterEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[endingMonth=12]",
                        "name": "endingMonth",
                        "optional": true,
                        "default": "12"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [quarterEnd](https://docs.dolphindb.com/en/Functions/q/quarterEnd.html)\n\n\n\n#### Syntax\n\nquarterEnd(X, \\[endingMonth=12], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**endingMonth** is an integer between 1 and 12 indicating a month. The default value is 1.\n\n**offset** is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the first day of the quarter that *X* belongs to. The first months of the quarters are determined by *startingMonth*. Note that *startingMonth*=1 is equivalent to *startingMonth*=4, 7 or 10.\n\nIf parameter *offset* is specified, the result is updated every *n* quarters. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nquarterEnd(2012.06.12);\n// output\n2012.06.30\n\nquarterEnd(2012.06.13 10:10:10.008,5);\n// output\n2012.08.31\n\ndate=2016.01.12 2016.02.25 2016.05.12 2016.06.28 2016.07.10 2016.08.18 2016.09.02 2016.10.16 2016.11.26 2016.12.30\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by quarterEnd(date,12,2016.01.01,2)\n```\n\n| quarterEnd\\_date | avg\\_price | sum\\_qty |\n| ---------------- | ---------- | -------- |\n| 2016.03.31       | 39.53      | 4100     |\n| 2016.09.30       | 92.1       | 18800    |\n| 2017.03.31       | 51.33      | 15800    |\n\nRelated functions: [quarterBegin](https://docs.dolphindb.com/en/Functions/q/quarterBegin.html), [businessQuarterBegin](https://docs.dolphindb.com/en/Functions/b/businessQuarterBegin.html), [businessQuarterEnd](https://docs.dolphindb.com/en/Functions/b/businessQuarterEnd.html)\n"
    },
    "quarterOfYear": {
        "url": "https://docs.dolphindb.com/en/Functions/q/quarterOfYear.html",
        "signatures": [
            {
                "full": "quarterOfYear(X)",
                "name": "quarterOfYear",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [quarterOfYear](https://docs.dolphindb.com/en/Functions/q/quarterOfYear.html)\n\n\n\n#### Syntax\n\nquarterOfYear(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, MONTH, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nFor each element in *X*, return a number from 1 to 4 indicating which quarter of the year it falls in.\n\n#### Examples\n\n```\nquarterOfYear(2012.07.02);\n// output\n3\n\nquarterOfYear([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n// output\n[2,4,1,2]\n```\n\nRelated functions: [dayOfYear](https://docs.dolphindb.com/en/Functions/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.com/en/Functions/d/dayOfMonth.html), [monthOfYear](https://docs.dolphindb.com/en/Functions/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.com/en/Functions/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.com/en/Functions/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.com/en/Functions/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.com/en/Functions/m/millisecond.html), [microsecond](https://docs.dolphindb.com/en/Functions/m/microsecond.html), [nanosecond](https://docs.dolphindb.com/en/Functions/n/nanosecond.html)\n"
    },
    "rad2deg": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rad2deg.html",
        "signatures": [
            {
                "full": "rad2deg(X)",
                "name": "rad2deg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rad2deg](https://docs.dolphindb.com/en/Functions/r/rad2deg.html)\n\n\n\n#### Syntax\n\nrad2deg(X)\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n#### Details\n\nConvert angle units from radians to degrees for each element of *X*.\n\n#### Examples\n\n```\nrad2deg(pi);\n// output\n180\n```\n\nRelated function: [deg2rad](https://docs.dolphindb.com/en/Functions/d/deg2rad.html)\n"
    },
    "rand": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rand.html",
        "signatures": [
            {
                "full": "rand(X, count)",
                "name": "rand",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [rand](https://docs.dolphindb.com/en/Functions/r/rand.html)\n\n\n\n#### Syntax\n\nrand(X, count)\n\n#### Arguments\n\n**X** is a scalar/vector.\n\n**count** is an INT scalar/pair. As a scalar, it indicates the length of the output vector; As a pair, it indicates the dimension of the output matrix.\n\n#### Details\n\nReturn a vector/matrix of random values.\n\n* If *X* is a scalar, return a vector of random values that follows a uniform distribution on \\[0, *X*).\n\n* If *X* is a vector, return a vector of random values drawn from the elements of *X*.\n\nThe data type of the result is the same as the data type of *X*.\n\n#### Examples\n\n```\n// generate 20 random nonnegative integers less than 10\nrand(10, 20);\n// output: [9,9,8,1,1,0,8,3,2,6,4,6,9,6,8,9,3,2,1,5]\n\n// generate 10 random non-negative double values less than 9.8\nrand(9.8, 10);// output: [3.653754,1.750518,0.055747,5.219222,2.473778,6.337576,7.797493,1.392241,0.149499,5.697612]\n\n// generate 3 random values drawn from vector x\nx=3 5 4 6 9;\nrand(x, 3);\n// output: [9,3,6]\n\n// generate a 2*2 random matrix less than 10\nrand(10.0, 2:2) \n```\n\n| col1   | col2   |\n| ------ | ------ |\n| 0.8233 | 1.0052 |\n| 7.1127 | 9.7578 |\n\n```\n12:35:06 + rand(100, 10);\n// output: [12:35:44,12:35:16,12:35:50,12:35:44,12:35:46,12:35:09,12:35:50,12:36:35,12:35:09,12:36:44]\n\nx=`IBM`C`AAPL`BABA;\nrand(x, 10);\n// output: [\"IBM\",\"BABA\",\"C\",\"AAPL\",\"IBM\",\"C\",\"BABA\",\"AAPL\",\"BABA\",\"BABA\"]\n```\n\n```\nrand(x,2:3)\n```\n\n| #0   | #1   | #2   |\n| ---- | ---- | ---- |\n| BABA | AAPL | BABA |\n| C    | AAPL | AAPL |\n"
    },
    "randBeta": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randBeta.html",
        "signatures": [
            {
                "full": "randBeta(alpha, beta, count)",
                "name": "randBeta",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randBeta](https://docs.dolphindb.com/en/Functions/r/randBeta.html)\n\n\n\n#### Syntax\n\nrandBeta(alpha, beta, count)\n\n#### Arguments\n\nThe shape parameters **alpha** and **bata** are positive floating numbers.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with beta distribution.\n\n#### Examples\n\n```\nrandBeta(2.31, 0.627, 2);\n// output\n[0.781246, 0.951372]\n```\n"
    },
    "randBinomial": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randBinomial.html",
        "signatures": [
            {
                "full": "randBinomial(trials, p, count)",
                "name": "randBinomial",
                "parameters": [
                    {
                        "full": "trials",
                        "name": "trials"
                    },
                    {
                        "full": "p",
                        "name": "p"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randBinomial](https://docs.dolphindb.com/en/Functions/r/randBinomial.html)\n\n\n\n#### Syntax\n\nrandBinomial(trials, p, count)\n\n#### Arguments\n\n**trials** is a positive integer.\n\n**p** is a floating number between 0 and 1.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with binomial distribution.\n\n#### Examples\n\n```\nrandBinomial(2, 0.627, 2);\n// output\n[1, 1]\n```\n"
    },
    "randChiSquare": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randChiSquare.html",
        "signatures": [
            {
                "full": "randChiSquare(df, count)",
                "name": "randChiSquare",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randChiSquare](https://docs.dolphindb.com/en/Functions/r/randChiSquare.html)\n\n\n\n#### Syntax\n\nrandChiSquare(df, count)\n\n#### Arguments\n\n**df** is a positive integer indicating the degree of freedom of a chi-squared distribution.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with chi-squared distribution.\n\n#### Examples\n\n```\nrandChiSquare(2.31, 2);\n// output\n[2.78303, 2.868523]\n```\n"
    },
    "randDiscrete": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randDiscrete.html",
        "signatures": [
            {
                "full": "randDiscrete(v, p, count)",
                "name": "randDiscrete",
                "parameters": [
                    {
                        "full": "v",
                        "name": "v"
                    },
                    {
                        "full": "p",
                        "name": "p"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randDiscrete](https://docs.dolphindb.com/en/Functions/r/randDiscrete.html)\n\n\n\n#### Syntax\n\nrandDiscrete(v, p, count)\n\n#### Arguments\n\n**v** is a vector/tuple indicating the sample data.\n\n**p** is a vector of floating point type of the same length as *v*. Each element in p must be a positive number, indicating the probability distribution of *v*.\n\n**count** is a positive integer indicating the length of the output vector.\n\n#### Details\n\nGenerate a sample of size count with random values sampling from *v* based on the specified probability distribution *p*.\n\n#### Examples\n\n```\nrandDiscrete(1..5, [0.1, 0.1, 0.2, 0.2, 0.4], 10)\n// output\n[2,3,5,2,5,5,2,1,1,2]\n\n//If the sum of p is not 1, it will be normalized automatically.\nrandDiscrete(1..5, [0.1, 0.2, 0.3, 0.4, 0.5], 5)\n// output\n[5,1,2,3,5]\n\nrandDiscrete(`A`B`C`E`F, [0.1, 0.2, 0.3, 0.4, 0.5], 5)\n// output\n[\"C\",\"E\",\"B\",\"C\",\"F\"]\n\n// Sample from each element in a tuple.\nrandDiscrete([[1,2], [2,3,4], 'S', 'abc'], [0.3, 0.3, 0.2, 0.1], 10)\n// output\n('S',[2,3,4],[1,2],[2,3,4],[1,2],'S','S',[2,3,4],[2,3,4],[2,3,4])\n\n// Sample from each vector in an array vector.\na = array\\(INT\\[\\], 0, 10\\).append!\\(\\[1 2 3, 4 5,6 7 8, 9 NULL\\]\\)\nrandDiscrete\\(a, \\[0.1, 0.2, 0.3, 0.4\\], 10\\)\n// output\n\\[\\[9,00i\\],\\[9,00i\\],\\[9,00i\\],\\[4,5\\],\\[9,00i\\],\\[1,2,3\\],\\[9,00i\\],\\[6,7,8\\],\\[9,00i\\],\\[9,00i\\]\\]\n```\n"
    },
    "randExp": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randExp.html",
        "signatures": [
            {
                "full": "randExp(mean, count)",
                "name": "randExp",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randExp](https://docs.dolphindb.com/en/Functions/r/randExp.html)\n\n\n\n#### Syntax\n\nrandExp(mean, count)\n\n#### Arguments\n\n**mean** is the mean of an exponential distribution.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with exponential distribution.\n\n#### Examples\n\n```\nrandExp(2.31, 2);\n// output\n[0.732791, 0.732791]\n```\n"
    },
    "randF": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randF.html",
        "signatures": [
            {
                "full": "randF(numeratorDF, denominatorDF, count)",
                "name": "randF",
                "parameters": [
                    {
                        "full": "numeratorDF",
                        "name": "numeratorDF"
                    },
                    {
                        "full": "denominatorDF",
                        "name": "denominatorDF"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randF](https://docs.dolphindb.com/en/Functions/r/randF.html)\n\n\n\n#### Syntax\n\nrandF(numeratorDF, denominatorDF, count)\n\n#### Arguments\n\n**numeratorDF** and **denominatorDF** are positive integers indicating degrees of freedom of an F distribution.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with F distribution.\n\n#### Examples\n\n```\nrandF(2.31, 0.671, 2);\n// output\n[0.41508, 0.642609]\n```\n"
    },
    "randGamma": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randGamma.html",
        "signatures": [
            {
                "full": "randGamma(shape, scale, count)",
                "name": "randGamma",
                "parameters": [
                    {
                        "full": "shape",
                        "name": "shape"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randGamma](https://docs.dolphindb.com/en/Functions/r/randGamma.html)\n\n\n\n#### Syntax\n\nrandGamma(shape, scale, count)\n\n#### Arguments\n\nThe shape parameter **shape** is a positive floating number.\n\nThe scale parameter **scale** is a positive floating number.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with gamma distribution.\n\n#### Examples\n\n```\nrandGamma(2.31, 0.671, 2);\n// output\n[0.784424, 0.716934]\n```\n"
    },
    "randLogistic": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randLogistic.html",
        "signatures": [
            {
                "full": "randLogistic(mean, s, count)",
                "name": "randLogistic",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "s",
                        "name": "s"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randLogistic](https://docs.dolphindb.com/en/Functions/r/randLogistic.html)\n\n\n\n#### Syntax\n\nrandLogistic(mean, s, count)\n\n#### Arguments\n\n**mean** is the mean of a logistic distribution.\n\n**s** is the scale parameter of a logistic distribution.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with logistic distribution.\n\n#### Examples\n\n```\nrandLogistic(2.31, 0.671, 2);\n// output\n[2.465462, 2.577171]\n```\n"
    },
    "randMultivariateNormal": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randMultivariateNormal.html",
        "signatures": [
            {
                "full": "randMultivariateNormal(mean, covar, count, [sampleAsRow=true])",
                "name": "randMultivariateNormal",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "covar",
                        "name": "covar"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    },
                    {
                        "full": "[sampleAsRow=true]",
                        "name": "sampleAsRow",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [randMultivariateNormal](https://docs.dolphindb.com/en/Functions/r/randMultivariateNormal.html)\n\n\n\n#### Syntax\n\nrandMultivariateNormal(mean, covar, count, \\[sampleAsRow=true])\n\nAlias: multivariateNormal\n\n#### Arguments\n\n**mean** is a vector indicating the mean of a normal distribution.\n\n**covar** is a positive definite matrix indicating the variance-covariance matrix of a multivariate normal distribution.\n\n**count** is a positive number indicating the number of samples to be generated.\n\n**sampleAsRow** (optional) is a Boolean value. The default value is true indicating each row of the result is a sample. Otherwise each column of the result is a sample.\n\n#### Details\n\nReturn a matrix of random values that follow a multivariate normal distribution.\n\n#### Examples\n\n```\nmultivariateNormal([2, 3], [1.0, 1.5, 1.5, 3.0]$2:2, 5);\n```\n\n| #0        | #1        |\n| --------- | --------- |\n| -0.02395  | -0.844505 |\n| -0.630637 | 0.098955  |\n| 3.001908  | 4.831809  |\n| 0.791095  | 2.01402   |\n| 1.708191  | 2.41748   |\n\n```\nmultivariateNormal([2, 3], [1.0, 1.5, 1.5, 3.0]$2:2, 5, false);\n```\n\n| #0       | #1       | #2        | #3        | #4       |\n| -------- | -------- | --------- | --------- | -------- |\n| 0.435419 | 0.138209 | -0.046187 | -1.201421 | 0.069719 |\n| 0.40163  | 0.034553 | -0.337324 | -1.008628 | 0.822161 |\n"
    },
    "randNormal": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randNormal.html",
        "signatures": [
            {
                "full": "randNormal(mean, stdev, count)",
                "name": "randNormal",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "stdev",
                        "name": "stdev"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randNormal](https://docs.dolphindb.com/en/Functions/r/randNormal.html)\n\n\n\n#### Syntax\n\nrandNormal(mean, stdev, count)\n\n#### Arguments\n\n**mean** is the mean of a normal distribution.\n\n**stdev** is the standard deviation of a normal distribution.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with normal distribution.\n\n#### Examples\n\n```\nrandNormal(2.31, 0.671, 2);\n// output\n[2.805524, 2.148019]\n```\n"
    },
    "randomForestClassifier": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randomForestClassifier.html",
        "signatures": [
            {
                "full": "randomForestClassifier(ds, yColName, xColNames, numClasses, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=32], [minImpurityDecrease=0.0], [numJobs=-1], [randomSeed])",
                "name": "randomForestClassifier",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "numClasses",
                        "name": "numClasses"
                    },
                    {
                        "full": "[maxFeatures=0]",
                        "name": "maxFeatures",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[numTrees=10]",
                        "name": "numTrees",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[numBins=32]",
                        "name": "numBins",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[maxDepth=32]",
                        "name": "maxDepth",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[minImpurityDecrease=0.0]",
                        "name": "minImpurityDecrease",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[numJobs=-1]",
                        "name": "numJobs",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [randomForestClassifier](https://docs.dolphindb.com/en/Functions/r/randomForestClassifier.html)\n\n\n\n#### Syntax\n\nrandomForestClassifier(ds, yColName, xColNames, numClasses, \\[maxFeatures=0], \\[numTrees=10], \\[numBins=32], \\[maxDepth=32], \\[minImpurityDecrease=0.0], \\[numJobs=-1], \\[randomSeed])\n\n#### Arguments\n\n**ds** is the data sources to be trained. It can be generated with function [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html).\n\n**yColName** is a string indicating the category column.\n\n**xColNames** is a string scalar/vector indicating the names of the feature columns.\n\n**numClasses** is a positive integer indicating the number of categories in the category column. The value of the category column must be integers in \\[0, numClasses).\n\n**maxFeatures** (optional) is an integer or a floating number indicating the number of features to consider when looking for the best split. The default value is 0.\n\n* if *maxFeatures* is a positive integer, then consider maxFeatures features at each split.\n\n* if *maxFeatures* is 0, then sqrt(the number of feature columns) features are considered at each split.\n\n* if *maxFeatures* is a floating number between 0 and 1, then int(*maxFeatures* \\* the number of feature columns) features are considered at each split.\n\n**numTrees** (optional) is a positive integer indicating the number of trees in the random forest. The default value is 10.\n\n**numBins** (optional) is a positive integer indicating the number of bins used when discretizing continuous features. The default value is 32. Increasing numBins allows the algorithm to consider more split candidates and make fine-grained split decisions. However, it also increases computation and communication time.\n\n**maxDepth** (optional) is a positive integer indicating the maximum depth of a tree. The default value is 32.\n\n**minImpurityDecrease** (optional) a node will be split if this split induces a decrease of the Gini impurity greater than or equal to this value. The default value is 0.\n\n**numJobs** (optional) is an integer indicating the maximum number of concurrently running jobs if set to a positive number. If set to -1, all CPU threads are used. If set to another negative integer, (the number of all CPU threads + numJobs + 1) threads are used.\n\n**randomSeed** (optional) is the seed used by the random number generator.\n\n#### Details\n\nFit a random forest classification model. The result is a dictionary with the following keys: numClasses, minImpurityDecrease, maxDepth, numBins, numTress, maxFeatures, model, modelName and xColNames. model is a tuple with the result of the trained trees; modelName is \"Random Forest Classifier\".\n\nThe fitted model can be used as an input for function [predict](https://docs.dolphindb.com/en/Functions/p/predict.html) .\n\n#### Examples\n\nFit a random forest classification model with simulated data:\n\n```\nt = table(100:0, `cls`x0`x1, [INT,DOUBLE,DOUBLE])\ncls = take(0, 50)\nx0 = norm(-1.0, 1.0, 50)\nx1 = norm(-1.0, 1.0, 50)\ninsert into t values (cls, x0, x1)\ncls = take(1, 50)\nx0 = norm(1.0, 1.0, 50)\nx1 = norm(1.0, 1.0, 50)\ninsert into t values (cls, x0, x1)\n\nmodel = randomForestClassifier(sqlDS(<select * from t>), `cls, `x0`x1, 2);\n```\n\nUse the fitted model in forecasting:\n\n```\npredict(model, t)\n```\n\nSave the fitted model to disk:\n\n```\nsaveModel(model, \"C:/DolphinDB/Data/classificationModel.txt\");\n```\n\nLoad a saved model:\n\n```\nloadModel(\"C:/DolphinDB/data/classifierModel.bin\")\n```\n"
    },
    "randomForestRegressor": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randomForestRegressor.html",
        "signatures": [
            {
                "full": "randomForestRegressor(ds, yColName, xColNames, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=32], [minImpurityDecrease=0.0], [numJobs=-1], [randomSeed])",
                "name": "randomForestRegressor",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[maxFeatures=0]",
                        "name": "maxFeatures",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[numTrees=10]",
                        "name": "numTrees",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[numBins=32]",
                        "name": "numBins",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[maxDepth=32]",
                        "name": "maxDepth",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[minImpurityDecrease=0.0]",
                        "name": "minImpurityDecrease",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[numJobs=-1]",
                        "name": "numJobs",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [randomForestRegressor](https://docs.dolphindb.com/en/Functions/r/randomForestRegressor.html)\n\n\n\n#### Syntax\n\nrandomForestRegressor(ds, yColName, xColNames, \\[maxFeatures=0], \\[numTrees=10], \\[numBins=32], \\[maxDepth=32], \\[minImpurityDecrease=0.0], \\[numJobs=-1], \\[randomSeed])\n\n#### Arguments\n\n**ds** is the data sources to be trained. It can be generated with function [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html) .\n\n**yColName** is a string indicating the dependent variable column.\n\n**xColNames** is a string scalar/vector indicating the names of the feature columns.\n\n**maxFeatures** (optional) is an integer or a floating number indicating the number of features to consider when looking for the best split. The default value is 0.\n\n* if *maxFeatures* is a positive integer, then consider maxFeatures features at each split.\n\n* if *maxFeatures* is 0, then sqrt(the number of feature columns) features are considered at each split.\n\n* if *maxFeatures* is a floating number between 0 and 1, then int(*maxFeatures* \\* the number of feature columns) features are considered at each split.\n\n**numTrees** (optional) is a positive integer indicating the number of trees in the random forest. The default value is 10.\n\n**numBins** (optional) is a positive integer indicating the number of bins used when discretizing continuous features. The default value is 32. Increasing numBins allows the algorithm to consider more split candidates and make fine-grained split decisions. However, it also increases computation and communication time.\n\n**maxDepth** (optional) is a positive integer indicating the maximum depth of a tree. The default value is 32.\n\n**minImpurityDecrease** (optional) a node will be split if this split induces a decrease of impurity greater than or equal to this value. The default value is 0.\n\n**numJobs** (optional) is an integer indicating the maximum number of concurrently running jobs if set to a positive number. If set to -1, all CPU threads are used. If set to another negative integer, (the number of all CPU threads + numJobs + 1) threads are used.\n\n**randomSeed** (optional) is the seed used by the random number generator.\n\n#### Details\n\nFit a random forest regression model. The result is a dictionary with the following keys: minImpurityDecrease, maxDepth, numBins, numTress, maxFeatures, model, modelName and xColNames. model is a tuple with the result of the trained trees; modelName is \"Random Forest Regressor\".\n\nThe fitted model can be used as an input for function [predict](https://docs.dolphindb.com/en/Functions/p/predict.html) .\n\n#### Examples\n\nFit a random forest regression model with simulated data:\n\n```\nx1 = rand(100.0, 100)\nx2 = rand(100.0, 100)\nb0 = 6\nb1 = 1\nb2 = -2\nerr = norm(0, 10, 100)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(x1, x2, y)\nmodel = randomForestRegressor(sqlDS(<select * from t>), `y, `x1`x2)\nyhat=predict(model, t);\n\nplot(y, yhat, ,SCATTER);\n```\n\nSave the trained model to disk:\n\n```\nsaveModel(model, \"C:/DolphinDB/Data/regressionModel.txt\");\n```\n\nLoad a saved model:\n\n```\nmodel=loadModel(\"C:/DolphinDB/Data/regressionModel.txt\");\n```\n"
    },
    "randPoisson": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randPoisson.html",
        "signatures": [
            {
                "full": "randPoisson(mean, count)",
                "name": "randPoisson",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randPoisson](https://docs.dolphindb.com/en/Functions/r/randPoisson.html)\n\n\n\n#### Syntax\n\nrandPoisson(mean, count)\n\n#### Arguments\n\n**mean** is the mean of a Poisson distribution.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with Poisson distribution.\n\n#### Examples\n\n```\nrandPoisson(2.31, 2);\n// output\n[7, 2]\n```\n"
    },
    "randStudent": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randStudent.html",
        "signatures": [
            {
                "full": "randStudent(df, count)",
                "name": "randStudent",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randStudent](https://docs.dolphindb.com/en/Functions/r/randStudent.html)\n\n\n\n#### Syntax\n\nrandStudent(df, count)\n\n#### Arguments\n\n**df** is a positive floating number indicating the degree of freedom of a Student's t-distribution.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with Student's t-distribution.\n\n#### Examples\n\n```\nrandStudent(2.31, 2);\n// output\n[-0.543993, 0.375804]\n```\n"
    },
    "randUniform": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randUniform.html",
        "signatures": [
            {
                "full": "randUniform(lower, upper, count)",
                "name": "randUniform",
                "parameters": [
                    {
                        "full": "lower",
                        "name": "lower"
                    },
                    {
                        "full": "upper",
                        "name": "upper"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randUniform](https://docs.dolphindb.com/en/Functions/r/randUniform.html)\n\n\n\n#### Syntax\n\nrandUniform(lower, upper, count)\n\n#### Arguments\n\n**lower** and **upper** are numeric scalars indicating the lower bound and upper bound of a continuous uniform distribution.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with continuous uniform distribution.\n\n#### Examples\n\n```\nrandUniform(0.61, 2.31, 2);\n// output\n[2.064851, 2.263172]\n```\n"
    },
    "randWeibull": {
        "url": "https://docs.dolphindb.com/en/Functions/r/randWeibull.html",
        "signatures": [
            {
                "full": "randWeibull(alpha, beta, count)",
                "name": "randWeibull",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randWeibull](https://docs.dolphindb.com/en/Functions/r/randWeibull.html)\n\n\n\n#### Syntax\n\nrandWeibull(alpha, beta, count)\n\n#### Arguments\n\nThe scale parameter **alpha** and the shape parameter **beta** are both positive floating numbers.\n\n**count** is the number of random values to be generated.\n\n#### Details\n\nReturn a vector of random values with Weibull distribution.\n\n#### Examples\n\n```\nrandWeibull(2.31,0.61, 2);\n// output\n[0.524197, 0.51402]\n```\n"
    },
    "rank": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rank.html",
        "signatures": [
            {
                "full": "rank(X, [ascending=true], [groupNum], [ignoreNA=true], [tiesMethod='min'], [percent=false], [precision])",
                "name": "rank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[groupNum]",
                        "name": "groupNum",
                        "optional": true
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='min']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'min'"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[precision]",
                        "name": "precision",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rank](https://docs.dolphindb.com/en/Functions/r/rank.html)\n\n\n\n#### Syntax\n\nrank(X, \\[ascending=true], \\[groupNum], \\[ignoreNA=true], \\[tiesMethod='min'], \\[percent=false], \\[precision])\n\n#### Arguments\n\n**X** is a vector/matrix/table.\n\n**ascending** (optional) is a Boolean value indicating whether the sorting is in ascending order. The default value is true (ascending).\n\n**groupNum** (optional) is a positive integer indicating the number of groups to sort X into.\n\n**ignoreNA** (optional) is a Boolean value indicating whether NULL values are ignored.\n\n**tiesMethod** (optional) is a string indicating how to rank the group of elements with the same value (i.e., ties):\n\n* 'min' : the smallest rank value of the tie values.\n\n* 'max' : the largest rank value of the tie values.\n\n* 'average' : the average of the rank values for all ties.\n\n* 'first': Gives the first found tie value the lowest rank value, and continues with the following rank value for the next tie.\n\n**percent** (optional) is a Boolean value, indicating whether to display the returned rankings in percentile form. The default value is false.\n\n**precision** (optional) is an integer between \\[1, 15]. If the absolute difference between two values is no greater than 10^(-precision), the two values are considered to be equal.\n\n**Note:**\n\nIf parameter *precision* is specified, *X* must be numeric, and the *tiesMethod* cannot be specified as 'first'.\n\n#### Details\n\nBased on the sort order specified by *ascending*, this function returns the ranking (starting from 0) of each element in *X*.\n\nIf *X* is a vector, return a vector with the same length as *X*:\n\n* If *groupNum* is specified, divide the sorted vector *X* into *groupNum* groups and return the group number (starting from 0) for each element in *X*.\n\n  * If the number of elements in *X* cannot be divided by *groupNum*, the first *mod(size(X), groupNum)* groups will hold one more element. For example, *X* has 6 elements, groupNum is specified as 4, the first and second elements of sorted vector *X* belong to group 0, the third and fourth elements belong to group 1, and the fifth and sixth elements belong to groups 2 and 3, respectively.\n\n  * If the identical elements are not divided in the same group, return the smallest group number for all identical elements.\n\n* If *ignoreNA* = true, NULL values are ignored and return NULL.\n\nIf *X* is a matrix/table, conduct the aforementioned calculation within each column of *X*. The result is a matrix/table with the same shape as *X*.\n\n#### Examples\n\n```\nrank(45 16 32 21);\n// output\n[3,0,2,1]\n\nrank(45 16 32 21, false);\n// output\n[0,3,1,2]\n\nrank(9 1 6 1 3 3);\n// output\n[5,0,4,0,2,2]\n// two identical elements have the same ranking.\n\nrank(X=9 5 4 8 1 3 6 2 7, groupNum=3);\n// output\n[2,1,1,2,0,0,1,0,2]\n\nrank(X=9 5 4 8 1 3 6 2 7, ascending=false, groupNum=3);\n// output\n[0,1,1,0,2,2,1,2,0]\n\nrank(X=1 2 2 3, tiesMethod='min');\n// output\n[0,1,1,3]\n\nrank(X=1 2 2 3, tiesMethod='average');\n// output\n[0,1.5,1.5,3]\n\nrank(X=1 2 2 3, tiesMethod='first');\n// output\n[0,1,2,3]\n\nrank(1 NULL NULL 3);\n// output\n[0,,,1]\n\nrank(X=1 NULL NULL 3, ignoreNA=false);\n// output\n[2,0,0,3]\n\nt=table(1 1 1 2 2 2 2 as id, 3 5 4 6 2 7 1 as x)\nt\n```\n\n| id | x |\n| -- | - |\n| 1  | 3 |\n| 1  | 5 |\n| 1  | 4 |\n| 2  | 6 |\n| 2  | 2 |\n| 2  | 7 |\n| 2  | 1 |\n\n```\nselect *, rank(x) from t context by id;\n```\n\n| id | x | rank\\_x |\n| -- | - | ------- |\n| 1  | 3 | 0       |\n| 1  | 5 | 2       |\n| 1  | 4 | 1       |\n| 2  | 6 | 2       |\n| 2  | 2 | 1       |\n| 2  | 7 | 3       |\n| 2  | 1 | 0       |\n"
    },
    "ratio": {
        "url": "https://docs.dolphindb.com/en/Functions/r/ratio.html",
        "signatures": [
            {
                "full": "ratio(X, Y)",
                "name": "ratio",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ratio](https://docs.dolphindb.com/en/Functions/r/ratio.html)\n\n\n\n#### Syntax\n\nratio(X, Y) or X\\Y\n\n#### Arguments\n\n**X** and **Y** is a scalar/pair/vector/matrix.\n\nIf *X* or *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nReturns element-by-element ratio of *X* to *Y*. Function `ratio` always returns floating numbers. If both *X* and *Y* are integer/long, `ratio` converts them into floating numbers and then conduct division. This is different from operator [div](https://docs.dolphindb.com/en/Functions/d/div.html) (/) , which does not convert integer/long to floating numbers. Another difference with `div` is that *Y* can be negative integers when *X* is integer.\n\n#### Examples\n\n```\n9\\2:5;\n// output\n4.5 : 1.8\n\n11:25\\3:4;\n// output\n3.666667 : 6.25\n\nx=1 2 3;\nx \\ 2;\n// output\n[0.5,1,1.5]\n\n2 \\ x;\n// output\n[2,1,0.666667]\n\ny=4 5 6;\n x \\ y;\n// output\n[0.25,0.4,0.5]\n\ny \\ x;\n// output\n[4,2.5,2]\n\nm1=1..6$2:3;\nm1\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\n m1\\2;\n```\n\n| #0  | #1  | #2  |\n| --- | --- | --- |\n| 0.5 | 1.5 | 2.5 |\n| 1   | 2   | 3   |\n\n```\nm2=6..1$2:3;\nm2\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1\\m2;\n```\n\n| #0       | #1       | #2  |\n| -------- | -------- | --- |\n| 0.166667 | 0.75     | 2.5 |\n| 0.4      | 1.333333 | 6S  |\n\n```\n-7\\5;\n// output\n-1.4\n\nx=-1 2 3;\nx\\-5;\n// output\n[0.2,-0.4,-0.6]\n```\n"
    },
    "ratios": {
        "url": "https://docs.dolphindb.com/en/Functions/r/ratios.html",
        "signatures": [
            {
                "full": "ratios(X)",
                "name": "ratios",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ratios](https://docs.dolphindb.com/en/Functions/r/ratios.html)\n\n\n\n#### Syntax\n\nratios(X)\n\n#### Arguments\n\n**X** is a vector or a matrix.\n\n#### Details\n\nIf *X* is a vector, return X(n)\\X(n-1) by scanning *X*. The first element of the result is always NULL.\n\nIf *X* is a matrix, conduct the aforementioned calculation within each column of *X*. The result is a matrix with the same shape as *X*.\n\n#### Examples\n\n```\nx=3 12 0 -5 32;\nratios x;\n// output\n[,4,0,,-6.4]\n\nx=2 3 6 NULL 28 7;\nratios x;\n// output\n[,1.5,2,,,0.25]\n\nm=matrix(100 105 109 112 108 116, 200 212 208 199 206 210);\nm;\n```\n\n| #0  | #1  |\n| --- | --- |\n| 100 | 200 |\n| 105 | 212 |\n| 109 | 208 |\n| 112 | 199 |\n| 108 | 206 |\n| 116 | 210 |\n\n```\nratios(m);\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n| 1.05              | 1.06              |\n| 1.038095238095238 | 0.981132075471698 |\n| 1.027522935779817 | 0.956730769230769 |\n| 0.964285714285714 | 1.035175879396985 |\n| 1.074074074074074 | 1.019417475728155 |\n"
    },
    "rdp": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rdp.html",
        "signatures": [
            {
                "full": "rdp(pointList, epsilon)",
                "name": "rdp",
                "parameters": [
                    {
                        "full": "pointList",
                        "name": "pointList"
                    },
                    {
                        "full": "epsilon",
                        "name": "epsilon"
                    }
                ]
            }
        ],
        "markdown": "### [rdp](https://docs.dolphindb.com/en/Functions/r/rdp.html)\n\n\n\n#### Syntax\n\nrdp(pointList, epsilon)\n\n#### Arguments\n\n**pointList** is a POINT vector which cannot contain NULL.\n\n**epsilon** is a non-negative DOUBLE type scalar that represents the compression threshold.\n\n#### Details\n\nUse RDP (Ramer-Douglas-Peucker) vector compression algorithm to compress the POINT type vector.\n\n#### Examples\n\n```\npt = point(1 2 3 4, 1 2 3 4)\nrdp(pt, 0.1)\n// output\n[(1.0, 1.0), (4.0, 4.0)]\n​\npt = point(1 2 3 4, 1 3 3 4)\nrdp(pt, 0.1)\n// output\n[(1.0, 1.0), (2.0, 3.0), (3.0, 3.0), (4.0, 4.0)]\n\ntemp = array(POINT,0)\nn=90000\nx_data = rand(10.0,n)\ny_data = rand(10.0,n)\nindex=0\ndo{\ntemp.append!(point(x_data[index], y_data[index]))\nindex += 1\n}while(index<n)\ns=rdp(temp, 0.8)\nprint(s.size())\n// output\n82002\nprint(temp.size())\n// output\n90000\n```\n"
    },
    "read!": {
        "url": "https://docs.dolphindb.com/en/Functions/r/read!.html",
        "signatures": [
            {
                "full": "read!(handle, holder, [offset=0], [length=1])",
                "name": "read!",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "holder",
                        "name": "holder"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length=1]",
                        "name": "length",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [read!](https://docs.dolphindb.com/en/Functions/r/read!.html)\n\n\n\n#### Syntax\n\nread!(handle, holder, \\[offset=0], \\[length=1])\n\n#### Arguments\n\n**handle** is the handle of the file to read.\n\n**holder** is the variable that saves the data that are imported into the system.\n\n**offset** is the starting position of the holder to save the data.\n\n**length** is the number of data points to read.\n\n#### Details\n\nRead a given number of data points from the handle and save them to the holder starting from the given offset, and return the number of data points read. The type of data to read is the same as the type of the holder.\n\nThe [readBytes](https://docs.dolphindb.com/en/Functions/r/readBytes.html) function always returns a new CHAR vector. It takes some time to create a new vector buffer. To improve the performance, we can create a buffer and reuse it. `read!` is such a function that accepts an existing buffer.Another advantage of the `read!` function is that we don't need to know the exact number of bytes to read. The function returns if it reaches the end of the file or if the give number of bytes have been read. If the returned count is less than expected, it indicates the file has reached the end.\n\n#### Examples\n\nThis example defines a function to copy a file:\n\n```\ndef fileCopy(source, target){\ns = file(source)\nt = file(target,\"w\")\nbuf = array(CHAR,1024)\ndo{\n  numByte = s.read!(buf,0,1024)\n  t.write(buf,0, numByte)\n}while(numByte==1024)\n}\nfileCopy(\"test.txt\",\"testcopy.txt\");\n```\n"
    },
    "readBytes": {
        "url": "https://docs.dolphindb.com/en/Functions/r/readBytes.html",
        "signatures": [
            {
                "full": "readBytes(fileHandle, sizeInByte)",
                "name": "readBytes",
                "parameters": [
                    {
                        "full": "fileHandle",
                        "name": "fileHandle"
                    },
                    {
                        "full": "sizeInByte",
                        "name": "sizeInByte"
                    }
                ]
            }
        ],
        "markdown": "### [readBytes](https://docs.dolphindb.com/en/Functions/r/readBytes.html)\n\n\n\n#### Syntax\n\nreadBytes(fileHandle, sizeInByte)\n\n#### Arguments\n\n**fileHandle** is the handle of the file to read.\n\n**sizeInByte** is an integer indicating the number of bytes to read.\n\n#### Details\n\nRead the given number of bytes from the handle. If the file reaches the end or an IO error occurs, an IOException will be raised; otherwise a buffer containing the given number of bytes will return. We must know the exact number of bytes to read before calling this function.\n\n#### Examples\n\nThis example defines a function to copy a file:\n\n```\ndef fileCopy(source, target){\ns = file(source)\nlen = s.seek(0,TAIL)\ns.seek(0,HEAD)\nt = file(target,\"w\")\nif(len==0) return\ndo{\n  buf = s.readBytes(min(len,1024))\n  t.writeBytes(buf)\n  len -= buf.size()\n}while(len)\n};\nfileCopy(\"test.txt\",\"testcopy.txt\");\n```\n"
    },
    "readLine": {
        "url": "https://docs.dolphindb.com/en/Functions/r/readLine.html",
        "signatures": [
            {
                "full": "readLine(handle)",
                "name": "readLine",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    }
                ]
            }
        ],
        "markdown": "### [readLine](https://docs.dolphindb.com/en/Functions/r/readLine.html)\n\n\n\n#### Syntax\n\nreadLine(handle)\n\n#### Arguments\n\n**handle** is the handle of the file to read.\n\n#### Examples\n\nRead a line from the given file. The return line doesn't include the line delimiter. If the file reaches the end, the function will return a NULL object which can be tested by the [isNull](https://docs.dolphindb.com/en/Functions/i/isNull.html) function.\n\n#### Examples\n\n```\nx=`IBM`MSFT`GOOG`YHOO`ORCL;\neachRight(writeLine, file(\"test.txt\",\"w\"), x);\n// output\n[1,1,1,1,1]\n\n fin = file(\"test.txt\")\n do{\n x=fin.readLine()\n if(x.isNull()) break\n print x\n }while(true);\n\n// output\nIBM\nMSFT\nGOOG\nYHOO\nORCL\n```\n\nRelated function: [writeLine](https://docs.dolphindb.com/en/Functions/w/writeLine.html)\n"
    },
    "readLines!": {
        "url": "https://docs.dolphindb.com/en/Functions/r/readLines!.html",
        "signatures": [
            {
                "full": "readLines!(handle, holder, [offset=0], [length=1])",
                "name": "readLines!",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "holder",
                        "name": "holder"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length=1]",
                        "name": "length",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [readLines!](https://docs.dolphindb.com/en/Functions/r/readLines!.html)\n\n\n\n#### Syntax\n\nreadLines!(handle, holder, \\[offset=0], \\[length=1])\n\n#### Arguments\n\n**handle** is the handle of the file to read.\n\n**holder** is the variable that saves the data that are imported into the system.\n\n**offset** (optional) is the starting position of the holder to save the lines.\n\n**length** (optional) is the number of lines to read.\n\n#### Details\n\nRead a number of lines from the handle and save them to holder starting from the given offset, and return the number of lines read.\n\nThe [readLines](https://docs.dolphindb.com/en/Functions/r/readLines.html) function returns a string vector for every call. It takes a certain amount of time to create a string vector, so it saves time if we can reuse the same vector as the buffer when a function call repeats. `readLines!` is such a function that accepts the existing buffer as data holder. The 2 examples below read the same amount of data for 100 times. It is faster to use `readLines!` than `readLines` .\n\n#### Examples\n\n```\ntimer(100){\nfin = file(\"test.txt\")\ndo{ y=fin.readLines(1024) } while(y.size()==1024)\nfin.close()\n};\n// output\nTime elapsed: 79.511 ms\n\ntimer(100){\nfin = file(\"test.txt\")\ny=array(STRING,1024)\ndo{ lines = fin.readLines!(y,0,1024) } while(lines==1024)\nfin.close()\n};\n// output\nTime elapsed: 56.034 ms\n```\n"
    },
    "readLines": {
        "url": "https://docs.dolphindb.com/en/Functions/r/readLines.html",
        "signatures": [
            {
                "full": "readLines(handle, [length=1024])",
                "name": "readLines",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "[length=1024]",
                        "name": "length",
                        "optional": true,
                        "default": "1024"
                    }
                ]
            }
        ],
        "markdown": "### [readLines](https://docs.dolphindb.com/en/Functions/r/readLines.html)\n\n\n\n#### Syntax\n\nreadLines(handle, \\[length=1024])\n\n#### Arguments\n\n**handle** is the handle of the file to read.\n\n**length** (optional) is the number of lines from the handle to read. The default number of lines to read is 1024.\n\n#### Details\n\nRead a given number of lines from the handle. The function returns if the handle reaches the end or the given number of lines has been read.\n\n#### Examples\n\n```\ntimer(10){\nx=rand(`IBM`MSFT`GOOG`YHOO`ORCL,10240)\neachRight(writeLine, file(\"test.txt\",\"w\"),x)\nfin = file(\"test.txt\")\ndo{\n   y=fin.readLine()\n} while(!y.isVoid())\nfin.close()\n};\n// output\nTime elapsed: 277.548 ms ms\n\n\ntimer(10){\nx=rand(`IBM`MSFT`GOOG`YHOO`ORCL,10240)\nfile(\"test.txt\",\"w\").writeLines(x)\nfin = file(\"test.txt\")\ndo{\n   y=fin.readLines(1024)\n} while(y.size()==1024)\n fin.close()\n};\n// output\nTime elapsed: 28.003 ms\n```\n"
    },
    "readObject": {
        "url": "https://docs.dolphindb.com/en/Functions/r/readObject.html",
        "signatures": [
            {
                "full": "readObject(handle)",
                "name": "readObject",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    }
                ]
            }
        ],
        "markdown": "### [readObject](https://docs.dolphindb.com/en/Functions/r/readObject.html)\n\n\n\n#### Syntax\n\nreadObject(handle)\n\n#### Arguments\n\n**handle** is the handle of the object to read.\n\n#### Details\n\nCan read all data structures including scalar, vector, matrix, set, dictionary and table to the handle. It must be executed by a logged-in user.\n\n#### Examples\n\n```\na1=10.5\na2=1..10\na3=cross(*,1..5,1..10)\na4=set(`IBM`MSFT`GOOG`YHOO)\na5=dict(a4.keys(),125.6 53.2 702.3 39.7)\na6=table(1 2 3 as id, `Jenny`Tom`Jack as name)\na7=(1 2 3, \"hello world!\", 25.6)\n\nfout=file(\"test.bin\",\"w\")\nfout.writeObject(a1)\nfout.writeObject(a2)\nfout.writeObject(a3)\nfout.writeObject(a4)\nfout.writeObject(a5)\nfout.writeObject(a6)\nfout.writeObject(a7)\nfout.close();\n```\n\nThe script above writes 7 different types of objects to a file. The script below reads out those 7 objects from the file and prints out a short description of the objects.\n\n```\nfin = file(\"test.bin\")\nfor(i in 0:7) print typestr fin.readObject()\nfin.close();\n// output\n DOUBLE\n FAST INT VECTOR\n INT MATRIX\n STRING SET\n STRING->DOUBLE Dictionary\n TABLE\n ANY VECTOR\n```\n"
    },
    "readRecord!": {
        "url": "https://docs.dolphindb.com/en/Functions/r/readRecord!.html",
        "signatures": [
            {
                "full": "readRecord!(handle, holder, [offset=0], [length])",
                "name": "readRecord!",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "holder",
                        "name": "holder"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [readRecord!](https://docs.dolphindb.com/en/Functions/r/readRecord!.html)\n\n\n\n#### Syntax\n\nreadRecord!(handle, holder, \\[offset=0], \\[length])\n\n#### Arguments\n\n**handle** is a binary file handle.\n\n**holder** is a table or a tuple with array elements of equal size.\n\n**offset** (optional) specifies the starting row position.\n\n**length** (optional) indicates the number of rows to be loaded.\n\n#### Details\n\nConvert binary files to DolphinDB data objects. DolhinDB also provides the function [writeRecord](https://docs.dolphindb.com/en/Functions/w/writeRecord.html) to covert DolphinDB data objects to binary files that can be used by other programs. The binary files should be row-based and each row should contain records with fixed data types and lengths. For example, if a binary file contains 5 data fields with the following type (length): char(1), boolean(1), short(2), int(4), long(8), and double(8), the function `readRecord!` will treat every 24 bytes as a new row. Similarly, the function `writeRecord` converts DolphinDB objects such as tables or tuples to binary files with the aforementioned format.\n\n#### Examples\n\n```\n// create a file handle for reading records. The binary file a.bin contains 1000 records\nf=file(\"c:/DB/a.bin\")\nt=table(1000:0, `PERMNO`PRC`VOL`SHROUT, `int`double`int`double)\nf.readRecord!(t);\n// output\n1000\n\n// similarily, we can load a binary file to a DolphinDB tuple object\nf=file(\"c:/DB/a.bin\")\nt=loop(array, [int, double, int, double], 0, 500)\n// create tuple t with 4 array elements. The size of each array is 500.\n f.readRecord!(t, 0, 500);\n// read the first 500 rows\n// output\n500\n```\n"
    },
    "rebalanceChunksAmongDataNodes": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rebalanceChunksAmongDataNodes.html",
        "signatures": [
            {
                "full": "rebalanceChunksAmongDataNodes([exec = false], [updatedBeforeDays = 7.0])",
                "name": "rebalanceChunksAmongDataNodes",
                "parameters": [
                    {
                        "full": "[exec = false]",
                        "name": "[exec = false]"
                    },
                    {
                        "full": "[updatedBeforeDays = 7.0]",
                        "name": "[updatedBeforeDays = 7.0]"
                    }
                ]
            }
        ],
        "markdown": "### [rebalanceChunksAmongDataNodes](https://docs.dolphindb.com/en/Functions/r/rebalanceChunksAmongDataNodes.html)\n\n\n\n#### Syntax\n\nrebalanceChunksAmongDataNodes(\\[exec = false], \\[updatedBeforeDays = 7.0])\n\n#### Argument\n\n**exec** (optional) is a Boolean value indicating whether to initiate data rebalancing. The default value is false, meaning that data rebalancing will not be executed and only the rebalancing plan will be returned.\n\n**updatedBeforeDays** (optional) is a non-negative floating-point number, which limits the rebalancing process to only include chunks that were updated before *updatedBeforeDays*. The default value is 7 (in days).\n\n#### Details\n\nThis function is used to rebalance data among disks for optimal performance after a cluster is scaled up. It can only be executed on a controller by an administrator.\n\nReturn a table containing the following columns:\n\n| name       | meaning                   |\n| ---------- | ------------------------- |\n| chunkId    | the chunk ID              |\n| srcNode    | alias of source node      |\n| destNode   | alias of destination node |\n| destVolume | destination volume        |\n\nAfter invoking this function, the system will print INFO-level logs that include the disk usage rate before and after rebalancing, in the following format:\n\n```\n[rebalance] Expected change of disk usage rate is before -> after\n[rebalance] Change of disk usage rate in IP@fsid(1/disk count) is before -> after\n[rebalance] Change of disk usage rate in IP@fsid(2/disk count) is before -> after\n...\n```\n\nYou can get the status of recovery tasks by [getRecoveryTaskStatus](https://docs.dolphindb.com/en/Functions/g/getRecoveryTaskStatus.html) on a controller.\n\n#### Example\n\n```\nrebalanceChunksAmongDataNodes()\n```\n\n| srcNode | chunkId                              | destNode | destVolume              |\n| ------- | ------------------------------------ | -------- | ----------------------- |\n| node1   | 99279094-ca12-3b87-48b6-520cbb986f39 | node2    | /home/xxx/node2/storage |\n| node1   | 45f612b8-42f5-aebd-4cef-e522b6ae1fc8 | node2    | /home/xxx/node2/storage |\n"
    },
    "rebalanceChunksWithinDataNode": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rebalanceChunksWithinDataNode.html",
        "signatures": [
            {
                "full": "rebalanceChunksWithinDataNode(nodeAlias, [exec = false], [updatedBeforeDays = 7.0])",
                "name": "rebalanceChunksWithinDataNode",
                "parameters": [
                    {
                        "full": "nodeAlias",
                        "name": "nodeAlias"
                    },
                    {
                        "full": "[exec = false]",
                        "name": "[exec = false]"
                    },
                    {
                        "full": "[updatedBeforeDays = 7.0]",
                        "name": "[updatedBeforeDays = 7.0]"
                    }
                ]
            }
        ],
        "markdown": "### [rebalanceChunksWithinDataNode](https://docs.dolphindb.com/en/Functions/r/rebalanceChunksWithinDataNode.html)\n\n\n\n#### Syntax\n\nrebalanceChunksWithinDataNode(nodeAlias, \\[exec = false], \\[updatedBeforeDays = 7.0])\n\n#### Arguments\n\n**nodeAlias** is a string indicating the alias of a node.\n\n**exec** (optional) is a Boolean value indicating whether to initiate data rebalancing within a data node. The default value is false, meaning that data rebalancing will not be executed and only the rebalancing plan will be returned.\n\n**updatedBeforeDays** (optional) is a non-negative floating-point number, which limits the rebalancing process to only include chunks that were updated before *updatedBeforeDays*. The default value is 7 (in days).\n\n#### Details\n\nAfter volumes are added in a data node, partitions on the other volumes need to be rebalanced for optimal performance. This function is used to rebalance data among volumes within a data node. It can only be executed on a controller by an administrator in cluster mode.\n\nStarting from 2.00.12, `rebalanceChunksWithinDataNode` is supported in the standalone mode.\n\nReturn a table containing the following columns:\n\n| name       | meaning            |\n| ---------- | ------------------ |\n| chunkId    | the chunk ID       |\n| srcVolume  | source volume      |\n| destVolume | destination volume |\n\nYou can get the status of recovery tasks by [getRecoveryTaskStatus](https://docs.dolphindb.com/en/Functions/g/getRecoveryTaskStatus.html) on a controller.\n\n#### Examples\n\n```\nrebalanceChunksWithinDataNode(\"node1\")\n```\n\n| ChunkId                              | srcVolume         | destVolume        |\n| ------------------------------------ | ----------------- | ----------------- |\n| 82c6eb6c-36ee-b1b6-4a86-ca24d9faaa25 | /hdd/hdd1/volumes | /hdd/hdd2/volumes |\n"
    },
    "reciprocal": {
        "url": "https://docs.dolphindb.com/en/Functions/r/reciprocal.html",
        "signatures": [
            {
                "full": "reciprocal(X)",
                "name": "reciprocal",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [reciprocal](https://docs.dolphindb.com/en/Functions/r/reciprocal.html)\n\n\n\n#### Syntax\n\nreciprocal(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nReturn element-by-element reciprocal of *X*. The data type of the result is always DOUBLE.\n\n#### Examples\n\n```\nreciprocal(10);\n// output\n0.1\n\nreciprocal(1 2 4 8);\n// output\n[1,0.5,0.25,0.125]\n\nreciprocal(1 2 4 8$2:2);\n```\n\n| #0  | #1    |\n| --- | ----- |\n| 1   | 0.25  |\n| 0.5 | 0.125 |\n"
    },
    "refCount": {
        "url": "https://docs.dolphindb.com/en/Functions/r/refCount.html",
        "signatures": [
            {
                "full": "refCount(varname)",
                "name": "refCount",
                "parameters": [
                    {
                        "full": "varname",
                        "name": "varname"
                    }
                ]
            }
        ],
        "markdown": "### [refCount](https://docs.dolphindb.com/en/Functions/r/refCount.html)\n\n\n\n#### Syntax\n\nrefCount(varname)\n\n#### Arguments\n\n**varname** is a string indicating a variable name.\n\n#### Details\n\nReturn the number of times a variable is referred to.\n\n#### Examples\n\n```\ndb=database(\"\",VALUE,1 2 3)\nrefCount(`db);\n// output\n1\n\ndb1=db\ndb2=db\nrefCount(`db);\n// output\n3\n```\n"
    },
    "regexCount": {
        "url": "https://docs.dolphindb.com/en/Functions/r/regexCount.html",
        "signatures": [
            {
                "full": "regexCount(str, pattern, [offset=0])",
                "name": "regexCount",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [regexCount](https://docs.dolphindb.com/en/Functions/r/regexCount.html)\n\n\n\n#### Syntax\n\nregexCount(str, pattern, \\[offset=0])\n\n#### Arguments\n\n**str** is a string or a string vector.\n\n**pattern** is an ordinary string scalar or a regular expression pattern to be searched in *str*. Regular expression pattern includes character literals, metacharacters, or a combination of both.\n\n**offset** (optional) is a non-negative integer with default value of 0. This optional argument is the starting position in *str* to conduct the count operation. The first character in *str* corresponds to position 0.\n\n#### Details\n\nSearch in *str* from the *offset* position, and return an integer indicating how many times a string that matches *pattern* occurs in *str*.\n\n#### Examples\n\n```\nregexCount(\"1231hsdU777_ DW#122ddd\", \"[0-9]+\");\n// output\n3\n\nregexCount(\"1231hsdU777_ DW#122ddd\", \"[0-9]+$\");\n// output\n0\n\nregexCount(\"1231hsdU777_ DW#122ddd\", \"^[0-9]+\");\n// output\n1\n\nregexCount(\"abc234 ff456\", \"[a-z]\", 3);\n// output\n2\n```\n"
    },
    "regexFind": {
        "url": "https://docs.dolphindb.com/en/Functions/r/regexFind.html",
        "signatures": [
            {
                "full": "regexFind(str, pattern, [offset])",
                "name": "regexFind",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [regexFind](https://docs.dolphindb.com/en/Functions/r/regexFind.html)\n\n\n\n#### Syntax\n\nregexFind(str, pattern, \\[offset])\n\n#### Arguments\n\n**str** is a string or a string vector.\n\n**pattern** is an ordinary string scalar or a regular expression pattern to be searched in *str*. Regular expression pattern includes character literals, metacharacters, or a combination of both.\n\n**offset** (optional) is a non-negative integer with default value of 0. This optional argument is the starting position in *str*to conduct the search operation. The first character in *str* corresponds to position 0.\n\n#### Details\n\nSearch in *str* for another string that matches *pattern* and return an integer that indicates the beginning position of the first matched substring. If no substring matches, return -1.\n\n#### Examples\n\n```\nregexFind(\"1231hsdU777_ DW#122ddd\", \"[a-z]+\");\n// output\n4\n\nregexFind(\"1231hsdU777_ DW#122ddd\", \"[0-9]+\");\n// output\n0\n\nregexFind(\"1231hsdU777_ DW#122ddd\", \"[0-9]+\", 4);\n// output\n8\n```\n"
    },
    "regexFindStr": {
        "url": "https://docs.dolphindb.com/en/Functions/r/regexfindstr.html",
        "signatures": [
            {
                "full": "regexFindStr(str, pattern, [onlyFirst=true], [offset])",
                "name": "regexFindStr",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    },
                    {
                        "full": "[onlyFirst=true]",
                        "name": "onlyFirst",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [regexFindStr](https://docs.dolphindb.com/en/Functions/r/regexfindstr.html)\n\n\n\n#### Syntax\n\nregexFindStr(str, pattern, \\[onlyFirst=true], \\[offset])\n\n#### Arguments\n\n**str** is a STRING scalar or vector, indicating the target string to be scanned.\n\n**pattern** is a string indicating the string pattern with regular expression. It can contain literals and metacharacters.\n\n**onlyFirst** (optional) is a Boolean value indicating whether to return only the first substring that matches *pattern* for each string.\n\n* true (default): Return the first match.\n\n* false: Return all non-overlapping matches.\n\n**offset** (optional) is a non-negative integer indicating the starting position for the search in *str*. The default value is 0, which is the first position of *str*.\n\n#### Details\n\nDifferent from `regexFind` which returns the positions of the matched strings, `regexFindStr` searches from the offset position and returns the matched substring.\n\n* When *str*is a scalar:\n\n  * If *onlyFirst*is set to true, return the first substring that matches *pattern*. Otherwise return an empty string.\n\n  * If *onlyFirst*is set to false, return a STRING vector containing all non-overlapping matches. Otherwise return an empty STRING vector.\n\n* When *str*is a vector:\n\n  * If *onlyFirst*is set to true, return the first substring that matches *pattern*for each string of *str*. Otherwise return a STRING vector of the same length as *str*, with all elements being empty strings.\n\n  * If *onlyFirst*is set to false, return a tuple containing all non-overlapping matches for each string of *str*. Otherwise return an tuple of the same length as *str*, with all elements being empty STRING vectors.\n\n#### Examples\n\n```\n// when str is a scalar and onlyFirst = true\nregexFindStr('234AA(2)BBB S&P', '([A|B|C|+|-]*)', true)\n//output: AA\n\n// when str is a scalar and onlyFirst = false\nregexFindStr('234AA(2)BBB S&P', '([A|B|C|+|-]*)', false)\n//output: [\"AA\",\"BBB\"]\n\n// when str is a vector and onlyFirst = true\nregexFindStr(['234AA(2)BBBS&P', '234AA(2)BBBS&P'], '([A|B|C|+|-]*)', true)\n//output: [\"AA\",\"AA\"]\n\n// when str is a vector and onlyFirst = false\nregexFindStr(['234AA(2)BBBS&P', '234AA(2)BBBS&P'], '([A|B|C|+|-]*)', false)\n//output: ([\"AA\",\"BBB\"],[\"AA\",\"BBB\"])\n```\n"
    },
    "regexReplace": {
        "url": "https://docs.dolphindb.com/en/Functions/r/regexReplace.html",
        "signatures": [
            {
                "full": "regexReplace(str, pattern, replacement, [offset])",
                "name": "regexReplace",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    },
                    {
                        "full": "replacement",
                        "name": "replacement"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [regexReplace](https://docs.dolphindb.com/en/Functions/r/regexReplace.html)\n\n\n\n#### Syntax\n\nregexReplace(str, pattern, replacement, \\[offset])\n\n#### Arguments\n\n**str** is a string or a string vector.\n\n**pattern** is an ordinary string scalar or a regular expression pattern to be searched in *str*. Regular expression pattern includes character literals, metacharacters, or a combination of both.\n\n**replacement** is a string scalar. It is used to replace pattern in *str*.\n\n**offset** (optional) is a non-negative integer with default value of 0. This optional argument is the starting position in *str* to conduct the search and replace operation. The first character in *str* corresponds to positive 0.\n\n#### Details\n\nSearch in *str* for another string that matches *pattern* and and replace every occurrence of the matched string or pattern with *replacement*.\n\n#### Examples\n\n```\nregexReplace(\"abc234 ff456\", \"[a-z]\", \"z\");\n// output\nzzz234 zz456\n\nregexReplace(\"abc234 ff456\", \"[a-z]+\", \"zzz\");\n// output\nzzz234 zzz456\n\nregexReplace(\"abc234 ff456\", \"[0-9]+\", \"zzz\");\n// output\nabczzz ffzzz\n```\n"
    },
    "registerSnapshotEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/r/registerSnapshotEngine.html",
        "signatures": [
            {
                "full": "registerSnapshotEngine(dbName, tableName, keyColumnName, [dedupColumnName])",
                "name": "registerSnapshotEngine",
                "parameters": [
                    {
                        "full": "dbName",
                        "name": "dbName"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "keyColumnName",
                        "name": "keyColumnName"
                    },
                    {
                        "full": "[dedupColumnName]",
                        "name": "dedupColumnName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [registerSnapshotEngine](https://docs.dolphindb.com/en/Functions/r/registerSnapshotEngine.html)\n\n\n\n#### Syntax\n\nregisterSnapshotEngine(dbName, tableName, keyColumnName, \\[dedupColumnName])\n\n#### Arguments\n\n**dbName** is a string indicating the name of a distributed database.\n\n**tableName** is a string indicating the name of a table.\n\n**keyColumnName** is a string indicating the name of a column.\n\n**dedupColumnName** \\[optional] is a string indicating the column based on which data will be sorted in descending order within each group, retaining only the first record after sorting. In cluster mode,this parameter must be specified to keep the query results correct and consistent across cluster.\n\n#### Details\n\nRegister a snapshot engine for a DFS table. After registering the snapshot engine, we can get the most recent row of each group specified by *keyColumnName* with the following SQL statement:\n\n```\nselect [HINT_SNAPSHOT] * from loadTable(dbName,tableName).\n```\n\n**Note:**\n\n* This engine is currently not supported in clusters with compute nodes.\n* A DFS table can only be registered with one snapshot engine.\n* After system restart, the snapshot engine needs to be re-registered. In cluster mode, if any data node restarts, the snapshot engine needs to be re-registered. First use [unregisterSnapshotEngine](https://docs.dolphindb.cn/en/Functions/u/unregisterSnapshotEngine.html) to clear snapshot information on other nodes, then call `registerSnapshotEngine` to re-register.\n\n#### Examples\n\nCreate a partitioned DFS table:\n\n```\ndb1=database(\"\",VALUE,2018.09.01..2018.09.30)\ndb2=database(\"\",VALUE,`AAPL`MSFT`MS`C)\ndb=database(\"dfs://compoDB\",COMPO,[db1,db2])\nt=table(1:0,`date`sym`val,[DATE,SYMBOL,DOUBLE])\npt=db.createPartitionedTable(t,`pt,`date`sym);\n```\n\nRegister a snapshot engine to get the latest record for each symbol from the DFS table pt.\n\n```\nregisterSnapshotEngine(\"dfs://compoDB\",\"pt\",\"sym\");\n```\n\nAppend data to pt. Then get the latest records. Note that this example uses randomly generated data, so your execution results may differ from those shown in this example.\n\n```\ndef writeData(batch){\n    pt=loadTable(\"dfs://compoDB\",\"pt\")\n    tmp=table(batch:0,`date`sym`val,[DATE,SYMBOL,DOUBLE])\n    dates=take(2018.09.01..2018.09.30,batch)\n    syms=take(`AAPL`MSFT`MS`C,batch)\n    vals=rand(100.0,batch)\n    insert into tmp values(dates,syms,vals)\n    pt.append!(tmp)\n}\n\nwriteData(1000);\n```\n\n```\nselect [HINT_SNAPSHOT] * from loadTable(\"dfs://compoDB\",\"pt\");\n```\n\n| date       | sym  | val       |\n| ---------- | ---- | --------- |\n| 2018.09.29 | AAPL | 24.945753 |\n| 2018.09.29 | MS   | 14.034453 |\n| 2018.09.30 | C    | 3.89175   |\n| 2018.09.30 | MSFT | 17.720025 |\n\n```\nwriteData(1000);\nselect [HINT_SNAPSHOT] * from loadTable(\"dfs://compoDB\",\"pt\");\n```\n\n| date       | sym  | val       |\n| ---------- | ---- | --------- |\n| 2018.09.29 | AAPL | 86.296883 |\n| 2018.09.29 | MS   | 48.17885  |\n| 2018.09.30 | C    | 83.7821   |\n| 2018.09.30 | MSFT | 44.415456 |\n\nWhen executing the script above in cluster mode, the query may return different results on different executions. To avoid inconsistent results, set the \"date\" column as *dedupColumnName* to sort the data of each group by date in descending order and retain only the latest record.\n\n```\nunregisterSnapshotEngine(dbName=\"dfs://compoDB\", tableName=\"pt\")\nregisterSnapshotEngine(dbName=\"dfs://compoDB\", tableName=\"pt\",keyColumnName=\"sym\", dedupColumnName=\"date\");\nwriteData(1000);\n\n// same query result across the cluster\nselect [HINT_SNAPSHOT] * from loadTable(\"dfs://compoDB\",\"pt\");\n```\n"
    },
    "regroup": {
        "url": "https://docs.dolphindb.com/en/Functions/r/regroup.html",
        "signatures": [
            {
                "full": "regroup(X, label, func, [byRow=true])",
                "name": "regroup",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "label",
                        "name": "label"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "[byRow=true]",
                        "name": "byRow",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [regroup](https://docs.dolphindb.com/en/Functions/r/regroup.html)\n\n\n\n#### Syntax\n\nregroup(X, label, func, \\[byRow=true])\n\n#### Arguments\n\n**X** is a matrix.\n\n**label** is a vector indicating the column/row labels based on which the matrix is grouped and aggregated. When *byRow* = true, the length of label must match the number of rows of *X*. Otherwise, it must match the number of columns of *X*.\n\n**func** is a unary aggregate function called on each group of the matrix. It can be built-in or user-defined.\n\n**byRow** (optional) is a Boolean. The default value is true, indicating that the matrix will be grouped and aggregated by rows. False means to group and aggregate matrix by columns.\n\n#### Details\n\nGroup the data of a matrix based on user-specified column/row labels and apply aggregation on each group.\n\n`regroup` is similar to the SQL keyword \"group by\", except that \"group by\" is applied only on *tables* whereas this function is applied on *matrices*.\n\nNote: It is recommended that the *func* parameter be specified as a built-in aggregate function as built-in functions are optimized internally for optimal performance. (see Example 2)\n\n#### Examples\n\nExample 1. Perform grouped aggregation on a matrix by row/column labels.\n\n```\nm = rand(20, 4:5)\nm;\n```\n\n| col1 | col2 | col3 | col4 | col5 |\n| ---- | ---- | ---- | ---- | ---- |\n| 11   | 6    | 6    | 10   | 4    |\n| 6    | 7    | 5    | 2    | 16   |\n| 2    | 16   | 14   | 19   | 9    |\n| 17   | 6    | 13   | 10   | 2    |\n\n```\n// by column labels\nlabel = `A`A`B`A`B\nregroup(X=m, label=label, func=firstNot, byRow=false)\n```\n\n| A  | B  |\n| -- | -- |\n| 11 | 6  |\n| 6  | 5  |\n| 2  | 14 |\n| 17 | 13 |\n\n```\n// by row labels\nlabel = 1 2 1 2\nregroup(X=m, label=label, func=firstNot, byRow=true)\n```\n\n| label | col1 | col2 | col3 | col4 | col5 |\n| ----- | ---- | ---- | ---- | ---- | ---- |\n| 1     | 11   | 6    | 6    | 10   | 4    |\n| 2     | 6    | 7    | 5    | 2    | 16   |\n\nExample 2. Compare the performance between applying a built-in function and a user-defined function.\n\n```\nm = rand(1000.0, 10000)$100:100\ndefg my_avg(v):avg(v)\n\ntimer(1000) regroup(m, take(1 2 3 4 5, 100), avg)\n// output\nTime elapsed: 176.175 ms\n\ntimer(1000) regroup(m, take(1 2 3 4 5, 100), my_avg)\n// output\nTime elapsed: 1062.553 ms\n```\n\nExample 3. Aggregate the panel data by minute\n\n```\nn=1000\ntimestamp = 09:00:00 + rand(10000, n).sort!()\nid = take(`st1`st2`st3, n)\nvol = 100 + rand(10.0, n)\nvt = table(timestamp, id, vol)\nm = exec vol from vt pivot by timestamp, id\nregroup(m, minute(m.rowNames()), avg)\n```\n"
    },
    "remoteRun": {
        "url": "https://docs.dolphindb.com/en/Functions/r/remoteRun.html",
        "signatures": [
            {
                "full": "remoteRun(conn, script, args)",
                "name": "remoteRun",
                "parameters": [
                    {
                        "full": "conn",
                        "name": "conn"
                    },
                    {
                        "full": "script",
                        "name": "script"
                    },
                    {
                        "full": "args",
                        "name": "args"
                    }
                ]
            }
        ],
        "markdown": "### [remoteRun](https://docs.dolphindb.com/en/Functions/r/remoteRun.html)\n\n\n\n#### Syntax\n\nremoteRun(conn, script, args)\n\n#### Arguments\n\n**conn** represents a database connection.\n\n**script** is a string indicating the script to be executed on the remote node.\n\n**args** ... are the parameters for the function to be executed if *script* is a function name. It can have 0 items or multiple items.\n\n#### Details\n\nSend a script or function to a remote database for execution. The `remoteRun` function requires version compatibility when the local server is 3.00 or higher.\n\n#### Examples\n\nThe first use case: execute script on a remote node.\n\n```\nconn =  xdb(\"localhost\",81);\nremoteRun(conn, \"x=rand(1.0,10000000); y=x pow 2; avg y\");\n// output\n0.333254\n```\n\nThe second use case:\n\n* If *functionName* is quoted: execute a remote function on a remote node. The function is defined on the remote node, while the parameters of the function are given on the local node.\n\n  ```\n  h=xdb(\"localhost\",80);\n  x=remoteRun(h, \"sum\",1..100);\n  x;\n  // output\n  5050\n  ```\n\n* If *functionName* is not quoted: execute a local function on a remote node. The parameters of the function are given on the local node.\n\nAssume on the local node we have a table \"EarningsDates\" with 2 columns: ticker and date. This table has the earnings announcement dates of 3 stocks for the 3rd quarter of 2006. There is a files *USPrices.csv* on a remote node with machine name \"localhost\" and port number 8081. It contains daily stock prices for all US stocks. We would like to get the stock prices from the remote node for all stocks in the table \"EarningsDates\" for the week after earnings announcement.\n\nOn the remote node, we import the data file to create the table \"USPrices\", and then share it across all nodes as \"sharedUSPrices\".\n\n```\nUSPrices = loadText(\"c:/DolphinDB/Data/USPrices.csv\");\nshare USPrices as USPrices;\n```\n\nWhen we create a connection to a remote node, the remote node will create a new session for this connection. This new session is completely isolated from other sessions on the remote node. This is convenient for developers as they don't have to worry about name conflicts. In this case, however, we do want to share data among multiple sessions on the same node. We can use the statement [share](https://docs.dolphindb.com/en/Programming/ProgrammingStatements/share.html) to share the objects. Currently only tables can be shared in DolphinDB.\n\nOn the local node, we create the table `EarningsDates`, and send it with the script over to the remote node. After the execution, the result is sent back to the local node.\n\n```\nEarningsDates=table(`XOM`AAPL`IBM as TICKER, 2006.10.26 2006.10.19 2006.10.17 as date)\ndef loadDailyPrice(data){\n    dateDict = dict(data.TICKER, data.date)\n    return select date, TICKER, PRC from objByName(\"sharedUSPrices\") where dateDict[TICKER]<date<=dateDict[TICKER]+7\n}\nconn = xdb(\"localhost\",8081)\nprices = conn.remoteRun(loadDailyPrice, EarningsDates);\nprices;\n```\n\n| date       | TICKER | PRC   |\n| ---------- | ------ | ----- |\n| 2006.10.27 | XOM    | 71.46 |\n| 2006.10.30 | XOM    | 70.84 |\n| 2006.10.31 | XOM    | 71.42 |\n| 2006.11.01 | XOM    | 71.06 |\n| 2006.11.02 | XOM    | 71.19 |\n| 2006.10.18 | IBM    | 89.82 |\n| 2006.10.19 | IBM    | 89.86 |\n| 2006.10.20 | IBM    | 90.48 |\n| 2006.10.23 | IBM    | 91.56 |\n| 2006.10.24 | IBM    | 91.49 |\n| 2006.10.20 | AAPL   | 79.95 |\n| 2006.10.23 | AAPL   | 81.46 |\n| 2006.10.24 | AAPL   | 81.05 |\n| 2006.10.25 | AAPL   | 81.68 |\n| 2006.10.26 | AAPL   | 82.19 |\n"
    },
    "remoteRunCompatible": {
        "url": "https://docs.dolphindb.com/en/Functions/r/remoteRunCompatible.html",
        "signatures": [
            {
                "full": "remoteRunCompatible(conn, script, args...)",
                "name": "remoteRunCompatible",
                "parameters": [
                    {
                        "full": "conn",
                        "name": "conn"
                    },
                    {
                        "full": "script",
                        "name": "script"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [remoteRunCompatible](https://docs.dolphindb.com/en/Functions/r/remoteRunCompatible.html)\n\n\n\n#### Syntax\n\nremoteRunCompatible(conn, script, args...)\n\n#### Arguments\n\n**conn** represents a database connection.\n\n**script** is a string indicating the script or function name to be executed on the remote node.\n\n**args**... (optional) are the parameters for the function to be executed if *script* is a function name. It can have 0 or multiple items.\n\n#### Details\n\nSend a script or function to a remote database for execution.\n\nCompared to `remoteRun`, `remoteRunCompatible` works across all database versions. The `remoteRun` function requires version compatibility when the local server is 3.00 or higher.\n\n#### Examples\n\nThe first use case: *script* is the script.\n\nExecute script on a remote node.\n\n```\nconn =  xdb(host=\"localhost\",port=8848,userId=\"admin\",password=123456);\nremoteRunCompatible(conn, \"avg(1..100)\");\n\n// output: 50.5\n```\n\nThe second use case: *script* is a function name.\n\n* If it is quoted: execute a remote function on a remote node. The function is defined on the remote node, while the parameters of the function are given on the local node.\n\n```\n// create a function view on the remote node\ndef myAvg(x){\n  return avg(x)+2\n}\naddFunctionView(myAvg)\n\n// execute function view \"myAvg\"\nconn =  xdb(\"localhost\",8848,`admin,`123456);\nremoteRunCompatible(conn, \"myAvg\", 1..100);\n\n// output: 52.5\n```\n\n* If it is not quoted: execute a local function on a remote node. The parameters of the function are given on the local node.\n\n```\n// define function \"myAvg\" on the local node\ndef myAvg(x){\n  return avg(x)+1\n}\n\n// execute \"myAvg\" function on the remote node\nconn =  xdb(\"localhost\",8848,`admin,`123456);\nremoteRunCompatible(conn, myAvg, 1..100);\n\n// output: 51.5\n```\n\nRelated function: remoteRun\n"
    },
    "remoteRunWithCompression": {
        "url": "https://docs.dolphindb.com/en/Functions/r/remoteRunWithCompression.html",
        "signatures": [
            {
                "full": "remoteRunWithCompression(conn, script, args)",
                "name": "remoteRunWithCompression",
                "parameters": [
                    {
                        "full": "conn",
                        "name": "conn"
                    },
                    {
                        "full": "script",
                        "name": "script"
                    },
                    {
                        "full": "args",
                        "name": "args"
                    }
                ]
            }
        ],
        "markdown": "### [remoteRunWithCompression](https://docs.dolphindb.com/en/Functions/r/remoteRunWithCompression.html)\n\n#### Syntax\n\nremoteRunWithCompression(conn, script, args)\n\n#### Arguments\n\n**conn** is the connection handle to a remote database.\n\n**script** is the script or function to be executed.\n\n**args** are the arguments to be passed to the function if *script* is a function name. It can have 0 or multiple items.\n\n#### Details\n\nThe function has the same feature and usage as the function [remoteRun](https://docs.dolphindb.com/en/Functions/r/remoteRun.html). The only difference lies in that `remoteRunWithCompression` compresses tables with more than 1,024 rows during transmission.\n\n"
    },
    "removeHead!": {
        "url": "https://docs.dolphindb.com/en/Functions/r/removeHead!.html",
        "signatures": [
            {
                "full": "removeHead!(obj, n)",
                "name": "removeHead!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [removeHead!](https://docs.dolphindb.com/en/Functions/r/removeHead!.html)\n\n\n\n#### Syntax\n\nremoveHead!(obj, n)\n\n#### Arguments\n\n**obj** is a vector.\n\n**n** is a positive integer indicating the number of elements at the beginning of the vector to be removed.\n\n#### Details\n\nDelete the first *n* elements from a vector.\n\n#### Examples\n\n```\nx=11..20;\nx.removeHead!(3);\n// output\n[14,15,16,17,18,19,20]\n```\n"
    },
    "removeNode": {
        "url": "https://docs.dolphindb.com/en/Functions/r/removeNode.html",
        "signatures": [
            {
                "full": "removeNode(alias, [force=false])",
                "name": "removeNode",
                "parameters": [
                    {
                        "full": "alias",
                        "name": "alias"
                    },
                    {
                        "full": "[force=false]",
                        "name": "force",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [removeNode](https://docs.dolphindb.com/en/Functions/r/removeNode.html)\n\n\n\n#### Syntax\n\nremoveNode(alias, \\[force=false])\n\n#### Details\n\n\\[Linux Only] Remove compute nodes from a cluster. It can only be executed by an administrator.\n\n#### Arguments\n\n**alias** is a STRING scalar or vector indicating the node alias(es).\n\n**force** (optional) is a BOOL scalar indicating whether to forcibly remove the nodes.\n\n* false (default): Nodes will only be removed if they are shut down.\n\n* true: Nodes will be forcibly shut down by the system and then removed. This may cause running tasks on the nodes to terminate.\n\n#### Examples\n\nRemove a compute node \"cnode1\". The node must be shut down before removal:\n\n```\nremoveNode(alias=\"cnode1\")\n```\n\nForce remove the compute nodes \"cnode2\" and \"cnode3\":\n\n```\nremoveNode(alias=`cnode2`cnode3, force=true)\n```\n"
    },
    "removeTail!": {
        "url": "https://docs.dolphindb.com/en/Functions/r/removeTail!.html",
        "signatures": [
            {
                "full": "removeTail!(obj, n)",
                "name": "removeTail!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [removeTail!](https://docs.dolphindb.com/en/Functions/r/removeTail!.html)\n\n\n\n#### Syntax\n\nremoveTail!(obj, n)\n\n#### Arguments\n\n**obj** is a vector.\n\n**n** is a positive integer indicating the number of elements at the end of the vector to be removed.\n\n#### Details\n\nDelete the last *n* elements from a vector.\n\n#### Examples\n\n```\nx=11..20;\nx.removeTail!(3);\n// output\n[11,12,13,14,15,16,17]\n```\n"
    },
    "removeTopicOffset": {
        "url": "https://docs.dolphindb.com/en/Functions/r/removeTopicOffset.html",
        "signatures": [
            {
                "full": "removeTopicOffset(topic)",
                "name": "removeTopicOffset",
                "parameters": [
                    {
                        "full": "topic",
                        "name": "topic"
                    }
                ]
            }
        ],
        "markdown": "### [removeTopicOffset](https://docs.dolphindb.com/en/Functions/r/removeTopicOffset.html)\n\n\n\n#### Syntax\n\nremoveTopicOffset(topic)\n\n#### Arguments\n\n**topic** is the subscription topic returned by the [subscribeTable](https://docs.dolphindb.com/en/Functions/s/subscribeTable.html) function.\n\n#### Details\n\nDelete the persisted offset of the last processed message in the specified subscription topic. (The offset is persisted if the *persistOffset* parameter is enabled when calling [subscribeTable](https://docs.dolphindb.com/en/Functions/s/subscribeTable.html).)\n"
    },
    "rename!": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rename!.html",
        "signatures": [
            {
                "full": "rename!(X, Y, [Z])",
                "name": "rename!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[Z]",
                        "name": "Z",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rename!](https://docs.dolphindb.com/en/Functions/r/rename!.html)\n\n\n\n#### Syntax\n\nrename!(X, Y, \\[Z])\n\n#### Arguments\n\n**X** is a vector/matrix/in-memory table/DFS table(for OLAP engine only).\n\n* When *X* is a vector, *Y* is a string/symbol.\n\n* When *X* is a matrix, if *Z* is not specified, *Y* is the column names; if *Z* is specified, *Y* is the row names and *Z* is the column names. Column names and row names need to be of same length as the number of columns and rows in *X*. *Y* and *Z* could be data of any types.\n\n* When *X* is an in-memory table, *Y* and *Z* is a string scalar or vector. If *Z* is not specified, *Y* is new column names starting from the first column on the left; if *Z* is specified, *Y* is the old column names and *Z* is the corresponding new column names. Users should make sure the number of new or old column names be less than or equal to the total number of columns in the table.\n\n* When *X* is a DFS table, *Y* and *Z* must be a string. If *Z* is not specified, *Y* is new column names starting from the first column on the left; if *Z* is specified, *Y* is the old column names and *Z* is the corresponding new column names. Users should make sure the number of new or old column names be less than or equal to the total number of columns in the table;\n\n#### Details\n\nFor a vector, assign a new name.\n\nFor a matrix, add or change columns names or row names.\n\nFor a table, rename the columns.\n\n#### Examples\n\n```\nk=3 6 9;\nk.rename!(`rk);\n// output\n[3,6,9]\n\n// one way to check name is to use function stat to get the descriptive statistics of data\n>stat k;\nMedian->6\nAvg->6\nMin->3\nStdev->3\nCount->3\nSize->3\nName->rk        // the new name for k\nMax->9\n```\n\n```\nm1=1..9$3:3;\nm1\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 4  | 7  |\n| 2  | 5  | 8  |\n| 3  | 6  | 9  |\n\n```\nm1.rename!(`col1`col2`col3);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 7    |\n| 2    | 5    | 8    |\n| 3    | 6    | 9    |\n\n```\nm1.rename!(1 2 3, `c1`c2`c3);\n```\n\n|   | c1 | c2 | c3 |\n| - | -- | -- | -- |\n| 1 | 1  | 4  | 7  |\n| 2 | 2  | 5  | 8  |\n| 3 | 3  | 6  | 9  |\n\n```\n// note the new matrix uses the name of k as its column name.\nm1 join k;\n```\n\n|   | c1 | c2 | c3 | rk |\n| - | -- | -- | -- | -- |\n| 1 | 1  | 4  | 7  | 3  |\n| 2 | 2  | 5  | 8  | 6  |\n| 3 | 3  | 6  | 9  | 9  |\n\n```\nt1=table(1..3 as x, 4..6 as y, 7..9 as z);\nt1\n```\n\n| x | y | z |\n| - | - | - |\n| 1 | 4 | 7 |\n| 2 | 5 | 8 |\n| 3 | 6 | 9 |\n\n```\nt1.rename!(`a`b);\n```\n\n| a | b | z |\n| - | - | - |\n| 1 | 4 | 7 |\n| 2 | 5 | 8 |\n| 3 | 6 | 9 |\n\n```\nt1.rename!(`aa`bb`cc);\n```\n\n| aa | bb | cc |\n| -- | -- | -- |\n| 1  | 4  | 7  |\n| 2  | 5  | 8  |\n| 3  | 6  | 9  |\n\n```\nt1.rename!(`bb`cc, `y`z);\n```\n\n| aa | y | z |\n| -- | - | - |\n| 1  | 4 | 7 |\n| 2  | 5 | 8 |\n| 3  | 6 | 9 |\n\n```\nt1=table(1..3 as x, 4..6 as y, 7..9 as z, k);\nt1\n// note the table uses the name of k as its column name.\n```\n\n| x | y | z | rk |\n| - | - | - | -- |\n| 1 | 4 | 7 | 3  |\n| 2 | 5 | 8 | 6  |\n| 3 | 6 | 9 | 9  |\n"
    },
    "renameCatalog": {
        "url": "https://docs.dolphindb.com/en/Functions/r/renameSchema.html",
        "signatures": [
            {
                "full": "renameSchema(catalog, oldSchema, newSchema)",
                "name": "renameSchema",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    },
                    {
                        "full": "oldSchema",
                        "name": "oldSchema"
                    },
                    {
                        "full": "newSchema",
                        "name": "newSchema"
                    }
                ]
            }
        ],
        "markdown": "### [renameCatalog](https://docs.dolphindb.com/en/Functions/r/renameSchema.html)\n\n#### Syntax\n\nrenameSchema(catalog, oldSchema, newSchema)\n\n#### Arguments\n\n**catalog**is a string specifying the catalog name.\n\n**oldSchema**is a string specifying the old schema name.\n\n**newSchema**is a string specifying the new schema name.\n\n#### Details\n\nRename a schema.\n\n#### Examples\n\n```\nrenameSchema(\"catalog1\", \"schema1\", \"schema2\")\n```\n\n"
    },
    "renameTable": {
        "url": "https://docs.dolphindb.com/en/Functions/r/renameTable.html",
        "signatures": [
            {
                "full": "renameTable(dbHandle, tableName, newTableName)",
                "name": "renameTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "newTableName",
                        "name": "newTableName"
                    }
                ]
            }
        ],
        "markdown": "### [renameTable](https://docs.dolphindb.com/en/Functions/r/renameTable.html)\n\n\n\n#### Syntax\n\nrenameTable(dbHandle, tableName, newTableName)\n\n#### Arguments\n\n**dbHandle** is a DFS database handle.\n\n**tableName** is a string indicating a table name. The table can be either a DFS table or a dimension table.\n\n**newTableName** is a string indicating the new table name.\n\n#### Details\n\nRename a table in a DFS database.\n\n#### Examples\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x)\ndb=database(\"dfs://hashdb101\", HASH,  [INT, 2]);\npt = db.createPartitionedTable(t, `pt, `ID)\npt.append!(t)\nrenameTable(db, `pt, `pt1)\nselect count(x) from loadTable(db, `pt1);\n// output\n1000000\n```\n"
    },
    "reorderColumns!": {
        "url": "https://docs.dolphindb.com/en/Functions/r/reorderColumns!.html",
        "signatures": [
            {
                "full": "reorderColumns!(table, reorderedColNames)",
                "name": "reorderColumns!",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "reorderedColNames",
                        "name": "reorderedColNames"
                    }
                ]
            }
        ],
        "markdown": "### [reorderColumns!](https://docs.dolphindb.com/en/Functions/r/reorderColumns!.html)\n\n\n\n#### Syntax\n\nreorderColumns!(table, reorderedColNames)\n\n#### Arguments\n\n**table** is an in-memory table that is not shared.\n\n**reorderedColNames** is a string vector indicating column names. It specifies the order of columns after execution. We only need to write the names for the columns whose positions are changed and all columns before them in the new table. For example, if we switch the position of the 3th column and the 6th column, then we only need to specify the names of the first 6 columns.\n\n#### Details\n\nChange the order of columns of an in-memory table. It modifies the original table instead of creating a new table.\n\n#### Examples\n\n```\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nt = table(timestamp, sym, qty, price);\nt;\n```\n\n| timestamp | sym | qty  | price  |\n| --------- | --- | ---- | ------ |\n| 09:34:07  | C   | 2200 | 49.6   |\n| 09:36:42  | MS  | 1900 | 29.46  |\n| 09:36:51  | MS  | 2100 | 29.52  |\n| 09:36:59  | MS  | 3200 | 30.02  |\n| 09:32:47  | IBM | 6800 | 174.97 |\n| 09:35:26  | IBM | 5400 | 175.23 |\n| 09:34:16  | C   | 1300 | 50.76  |\n| 09:34:26  | C   | 2500 | 50.32  |\n| 09:38:12  | C   | 8800 | 51.29  |\n\n```\nreorderColumns!(t,`sym`timestamp`price`qty)\nt;\n```\n\n| sym | timestamp | price  | qty  |\n| --- | --------- | ------ | ---- |\n| C   | 09:34:07  | 49.6   | 2200 |\n| MS  | 09:36:42  | 29.46  | 1900 |\n| MS  | 09:36:51  | 29.52  | 2100 |\n| MS  | 09:36:59  | 30.02  | 3200 |\n| IBM | 09:32:47  | 174.97 | 6800 |\n| IBM | 09:35:26  | 175.23 | 5400 |\n| C   | 09:34:16  | 50.76  | 1300 |\n| C   | 09:34:26  | 50.32  | 2500 |\n| C   | 09:38:12  | 51.29  | 8800 |\n\n```\nreorderColumns!(t,`timestamp`sym);\nt;\n```\n\n| timestamp | sym | price  | qty  |\n| --------- | --- | ------ | ---- |\n| 09:34:07  | C   | 49.6   | 2200 |\n| 09:36:42  | MS  | 29.46  | 1900 |\n| 09:36:51  | MS  | 29.52  | 2100 |\n| 09:36:59  | MS  | 30.02  | 3200 |\n| 09:32:47  | IBM | 174.97 | 6800 |\n| 09:35:26  | IBM | 175.23 | 5400 |\n| 09:34:16  | C   | 50.76  | 1300 |\n| 09:34:26  | C   | 50.32  | 2500 |\n| 09:38:12  | C   | 51.29  | 8800 |\n"
    },
    "repartitionDS": {
        "url": "https://docs.dolphindb.com/en/Functions/r/repartitionDS.html",
        "signatures": [
            {
                "full": "repartitionDS(query, [column], [partitionType], [partitionScheme], [local=true])",
                "name": "repartitionDS",
                "parameters": [
                    {
                        "full": "query",
                        "name": "query"
                    },
                    {
                        "full": "[column]",
                        "name": "column",
                        "optional": true
                    },
                    {
                        "full": "[partitionType]",
                        "name": "partitionType",
                        "optional": true
                    },
                    {
                        "full": "[partitionScheme]",
                        "name": "partitionScheme",
                        "optional": true
                    },
                    {
                        "full": "[local=true]",
                        "name": "local",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [repartitionDS](https://docs.dolphindb.com/en/Functions/r/repartitionDS.html)\n\n\n\n#### Syntax\n\nrepartitionDS(query, \\[column], \\[partitionType], \\[partitionScheme], \\[local=true])\n\n#### Arguments\n\n**query** is metacode of SQL statements or a tuple of metacode of SQL statements.\n\n**column** (optional) is a string indicating a column name in query. Function `repartitionDS` deliminates data sources based on column.\n\n**partitionType** (optional) means the type of partition. It can take the value of VALUE or RANGE.\n\n**partitionScheme** (optional) is a vector indicating the partitioning scheme. For details please refer to [DistributedComputing](https://docs.dolphindb.com/en/Database/DatabaseandDistributedComputing/DistributedComputing.html).\n\n**local** (optional) is a Boolean value indicating whether to move the data sources to the local node for computing. The default value is true.\n\n#### Details\n\nGenerate a tuple of data sources from a table with a new partitioning design.\n\nIf *query* is metacode of SQL statements, the parameter *column* must be specified. *partitionType* and *partitionScheme* can be unspecified for a partitioned table with a COMPO domain. In this case, the data sources will be determined based on the original *partitionType* and *partitionScheme* of column.\n\nIf *query* is a tuple of metacode of SQL statements, the other 3 parameters should be unspecified. The function returns a tuple with the same length as *query*. Each element of the result is a data source corresponding to a piece of metacode in *query*.\n\n#### Examples\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID = database(, RANGE, 0 50 100)\ndb = database(\"dfs://compoDB\", COMPO, [dbDate, dbID])\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n```\n\nExample 1. *query* is metacode of SQL statements. *partitionType* and *partitionScheme* are specified.\n\n```\nrepartitionDS(<select * from pt>,`date,RANGE,2017.08.07 2017.08.09 2017.08.11);\n// output\n[DataSource< select [4] * from pt where date >= 2017.08.07,date < 2017.08.09 >,DataSource< select [4] * from pt where date >= 2017.08.09,date < 2017.08.11 >]\n```\n\nExample 2. *query* is metacode of SQL statements. *partitionType* and *partitionScheme* are unspecified.\n\n```\nrepartitionDS(<select * from pt>,`ID);\n// output\n[DataSource< select [4] * from pt [partition = */0_50] >,DataSource< select [4] * from pt [partition = */50_100] >]\n```\n\nExample 3. *query* is a tuple of metacode of SQL statements.\n\n```\nrepartitionDS([<select * from pt where id between 0:50>,<select * from pt where id between 51:100>]);\n// output\n[DataSource< select [4] * from pt where id between 0 : 50 >,DataSource< select [4] * from pt where id between 51 : 100 >]\n```\n"
    },
    "repeat": {
        "url": "https://docs.dolphindb.com/en/Functions/r/repeat.html",
        "signatures": [
            {
                "full": "repeat(X, n)",
                "name": "repeat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [repeat](https://docs.dolphindb.com/en/Functions/r/repeat.html)\n\n\n\n#### Syntax\n\nrepeat(X, n)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n**n** is a positive integer.\n\n#### Details\n\nRepeats each item in string *X* *n* times to form a new string. The size of the result is the same as the size of *X*.\n\n#### Examples\n\n```\nrepeat(`FB, 3);\n// output\nFBFBFB\n\nrepeat(`AB`CD,2);\n// output\n[\"ABAB\",\"CDCD\"]\n```\n"
    },
    "replace!": {
        "url": "https://docs.dolphindb.com/en/Functions/r/replace!.html",
        "signatures": [
            {
                "full": "replace!(X, oldValue, newValue)",
                "name": "replace!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "oldValue",
                        "name": "oldValue"
                    },
                    {
                        "full": "newValue",
                        "name": "newValue"
                    }
                ]
            }
        ],
        "markdown": "### [replace!](https://docs.dolphindb.com/en/Functions/r/replace!.html)\n\n\n\n#### Syntax\n\nreplace!(X, oldValue, newValue)\n\n#### Details\n\nPlease refer to [replace](https://docs.dolphindb.com/en/Functions/r/replace.html). The only difference between `replace` and `replace!` is that the latter assigns the result to *X* and thus changing the value of *X* after the execution.\n"
    },
    "replace": {
        "url": "https://docs.dolphindb.com/en/Functions/r/replace.html",
        "signatures": [
            {
                "full": "replace(X, oldValue, newValue)",
                "name": "replace",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "oldValue",
                        "name": "oldValue"
                    },
                    {
                        "full": "newValue",
                        "name": "newValue"
                    }
                ]
            }
        ],
        "markdown": "### [replace](https://docs.dolphindb.com/en/Functions/r/replace.html)\n\n\n\n#### Syntax\n\nreplace(X, oldValue, newValue)\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n**oldValue** is the value to be replaced.\n\n**newValue** is the new value.\n\n#### Details\n\nReplace *oldValue* with *newValue* in *X*. `replace!` is the in-place change version of `replace` .\n\n#### Examples\n\n```\nx=1 1 3;\nx=x.replace(1,2);\nx\n// output\n[2,2,3];\n\nm=1..4$2:2;\nm\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\nm=m.replace(2,1);\nm\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 1  | 4  |\n\n```\nm.replace!(1,6);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 6  | 4  |\n"
    },
    "replaceColumn!": {
        "url": "https://docs.dolphindb.com/en/Functions/r/replaceColumn!.html",
        "signatures": [
            {
                "full": "replaceColumn!(table, colName, newCol)",
                "name": "replaceColumn!",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "colName",
                        "name": "colName"
                    },
                    {
                        "full": "newCol",
                        "name": "newCol"
                    }
                ]
            }
        ],
        "markdown": "### [replaceColumn!](https://docs.dolphindb.com/en/Functions/r/replaceColumn!.html)\n\n\n\n#### Syntax\n\nreplaceColumn!(table, colName, newCol)\n\n#### Arguments\n\n**table** is a non-shared in-memory tableor a DFS table.\n\n**colName** is a string indicating the name of the column to replace. When *table* is an in-memory table, *colName* can also be a vector of strings indicating multiple column names.\n\n**newCol**is a vector with the same number elements as the number of rows of table.is the column values to replace with. When *colName* is a scalar, *newCol* is a vector with the same number of elements as the rows of *table*; when *colName* is a vector, *newCol* is a tuple containing the same number of elements as *colName*. Each tuple element is a vector with the same number of elements as the rows of *table*.\n\n#### Details\n\nReplace table column(s) with the specified vector(s). The data type of the new column is the same as the data type of the specified vector. The original column name is not changed.When *table* is an in-memory table, replacing multiple columns at once is supported. Note that the multi-column replacement operation is not atomic, which means in cases of some system errors, some specified column replacements may succeed while others fail partway through.\n\nTo update column's value without changing its data type, we can use both `replaceColumn!` and SQL statement [update](https://docs.dolphindb.com/en/Programming/SQLStatements/update.html). Only `replaceColumn!`, however, can change a column's data type.\n\n#### Examples\n\n```\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nt = table(timestamp, sym, qty, price)\nschema(t).colDefs;\n```\n\n| name      | typeString | typeInt | comment |\n| --------- | ---------- | ------- | ------- |\n| timestamp | SECOND     | 10      |         |\n| sym       | STRING     | 18      |         |\n| qty       | INT        | 4       |         |\n| price     | DOUBLE     | 16      |         |\n\nTo change the data type of column \"sym\" to SYMBOL:\n\n```\nsyms=symbol(exec sym from t)\nreplaceColumn!(t,`sym,syms);\nschema(t).colDefs;\n```\n\n| name      | typeString | typeInt | comment |\n| --------- | ---------- | ------- | ------- |\n| timestamp | SECOND     | 10      |         |\n| sym       | SYMBOL     | 17      |         |\n| qty       | INT        | 4       |         |\n| price     | DOUBLE     | 16      |         |\n\nTo replace columns \"price\" and \"timestamp\":\n\n```\nnewPrice =round(t.qty)\nnewTimestamp = minute(t.timestamp)\nreplaceColumn!(t, `price`timestamp, (newPrice,newTimestamp))\nschema(t).colDefs;\n```\n\n<table id=\"table_nvy_5l3_zzb\"><thead><tr><th align=\"left\">\n\nname\n\n</th><th align=\"left\">\n\ntypeString\n\n</th><th align=\"left\">\n\ntypeInt\n\n</th><th align=\"left\">\n\nextra\n\n</th><th align=\"left\">\n\ncomment\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\ntimestamp\n\n</td><td align=\"left\">\n\nMINUTE\n\n</td><td align=\"left\">\n\n9\n\n</td><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td></tr><tr><td align=\"left\">\n\nsym\n\n</td><td align=\"left\">\n\nSYMBOL\n\n</td><td align=\"left\">\n\n17\n\n</td><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td></tr><tr><td align=\"left\">\n\nqty\n\n</td><td align=\"left\">\n\nINT\n\n</td><td align=\"left\">\n\n4\n\n</td><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td></tr><tr><td align=\"left\">\n\nprice\n\n</td><td align=\"left\">\n\nINT\n\n</td><td align=\"left\">\n\n4\n\n</td><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td></tr></tbody>\n</table>```\nlogin(\"admin\",\"123456\")\nif(existsDatabase(\"dfs://replaceColumn\")){\n  dropDatabase(\"dfs://replaceColumn\")\n}\nn=10\nmonth=take(2012.06.13..2012.06.13, n);\nx=rand(1.0, n);\nt=table(month, x);\ndb=database(\"dfs://replaceColumn\", VALUE, 2012.06.13..2012.06.23)\npt = db.createPartitionedTable(t, `pt, `month);\npt.append!(t);\nschema(pt).colDefs\n```\n\n| name  | typeString | typeInt | extra | comment |\n| ----- | ---------- | ------- | ----- | ------- |\n| month | DATE       | 6       |       |         |\n| x     | DOUBLE     | 16      |       |         |\n\n```\nnewCols=int(exec x from loadTable(\"dfs://replaceColumn\",`pt))\nreplaceColumn!(loadTable(\"dfs://replaceColumn\",`pt), `x, newCols)\nschema(pt).colDefs\n```\n\n| name  | typeString | typeInt | extra | comment |\n| ----- | ---------- | ------- | ----- | ------- |\n| month | DATE       | 6       |       |         |\n| x     | INT        | 4       |       |         |\n"
    },
    "replay": {
        "url": "https://docs.dolphindb.com/en/Functions/r/replay.html",
        "signatures": [
            {
                "full": "replay(inputTables, outputTables, [dateColumn], [timeColumn], [replayRate], [absoluteRate=true], [parallelLevel=1], [sortColumns], [preciseRate=false])",
                "name": "replay",
                "parameters": [
                    {
                        "full": "inputTables",
                        "name": "inputTables"
                    },
                    {
                        "full": "outputTables",
                        "name": "outputTables"
                    },
                    {
                        "full": "[dateColumn]",
                        "name": "dateColumn",
                        "optional": true
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[replayRate]",
                        "name": "replayRate",
                        "optional": true
                    },
                    {
                        "full": "[absoluteRate=true]",
                        "name": "absoluteRate",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[parallelLevel=1]",
                        "name": "parallelLevel",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[sortColumns]",
                        "name": "sortColumns",
                        "optional": true
                    },
                    {
                        "full": "[preciseRate=false]",
                        "name": "preciseRate",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [replay](https://docs.dolphindb.com/en/Functions/r/replay.html)\n\n#### Syntax\n\nreplay(inputTables, outputTables, \\[dateColumn], \\[timeColumn], \\[replayRate], \\[absoluteRate=true], \\[parallelLevel=1], \\[sortColumns], \\[preciseRate=false])\n\n#### Details\n\nReplay one or more tables or data sources (generated by [replayDS](https://docs.dolphindb.com/en/Functions/r/replayDS.html)) to table(s) in chronological order to simulate real-time ingestion of streaming data. It is commonly used for backtesting of high-frequency trading strategies.\n\n**Replay Types**\n\nBased on mappings between the input table(s) and output table(s) , there are three replay types: 1-to-1, N-to-1, and N-to-N.\n\nN-to-N replay is not simply N separate 1-to-1 replay tasks. With N 1-to-1 replays, there are N source tables each replayed to N different target tables, executed in parallel. When *inputTables* is specified as a tuple of data sources, N-to-N replay coordinates the replay of multiple data sources sequentially, which first finishes replaying the first source before starting replay of the second, and so on.\n\nIn contrast to N-to-N replay, N-to-1 replay provides ordered replay of multiple data sources into a single target table. With N-to-1 replay, the timestamp ordering across different input sources is preserved when replaying them into the target table.\n\n**Note:** For N-to-1 replay, before version 1.30.17/2.00.5, the schemata of the input tables must be the same, which is called homogeneous replay. Starting from version 1.30.17/2.00.5, replay supports inputting tables with different schemata, which is called heterogeneous replay. For heterogeneous replay, the serialized result of replayed records cannot be processed directly. The output table needs to be deserialized and data is filtered and processed by `streamFilter`.\n\n**Replay Rate**\n\n* If *replayRate* is a positive integer and *absoluteRate* = true, replay *replayRate* records per second.\n\n* If *replayRate* is a positive integer, and *absoluteRate* = false, replay at *replayRate* times the time span of the data. Note that the number of records replayed per second is the same.\n\n* If *replayRate* is negative or unspecified, replay at the maximum speed.\n\n* If *replayRate* is a positive integer and*preciseRate* = true, replay at *replayRate* times the difference between two adjacent records. Suppose two adjacent rows have a timestamp difference of *t*. If the *replayRate* is specified as 2, then during replay the two rows will be spaced by *t*/2, i.e., replaying at twice the speed.\n\n**Replay Process**\n\n1. Loading data. When parameter *inputTables* is specified as a tuple of data sources, it is first loaded from disk to memory.\n\n   Before version 1.30.21/2.00.9, only data souces with the same index are loaded and then replayed in order. Starting from version 1.30.21/2.00.9, it will be automatically sorted by timestamps before it is replayed.\n\n   **Note:**\n\n   * To improve the performance, the *parallelLevel* parameter can be specified to load data in parallel.\n\n   * Data is loaded and replayed asynchronously.\n\n2. Replaying data in batches.\n\n   Data to be replayed is loaded from the memory. Only data in the same batch is replayed in order. Therefore, please sort the input tables by the specified time column (as determined by the parameters *dateColumn* and *timeColumn*) before calling the `replay` function.\n\n   Replay one or more tables containing n records with a time span of t seconds:\n\n   | Replay Rate                                          | Batch Size                                                                        | Elapsed time (s)                            | Note                                                                                                                                                        |\n   | ---------------------------------------------------- | --------------------------------------------------------------------------------- | ------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n   | replays specified records per second                 | *replayRate* records from one or multiple table(s) sorted by the timestamps       | n/*replayRate*                              | If the number of records loaded in one second is less than *replayRate*, all loaded data will be replayed as a batch.                                       |\n   | replays at specified times the time span of the data | *replayRate* \\*n/t records from one or multiple table(s) sorted by the timestamps | t/ *replayRate*                             | If *replayRate* \\*n/t < 1, take 1. If the number of records loaded in one second is less than replayRate\\*n/t, all loaded data will be replayed as a batch. |\n   | replays at the maximum speed                         | all loaded data                                                                   | determined by the performance of the system | For N-to-N replay, each table is replayed one by one in this case.                                                                                          |\n\n   **Note:**\n\n   * When *inputTables* is specified as data sources, (i.e., loaded from disk), the replay speed is impacted by disk I/O.\n\n   * The elapsed time of heterogeneous replay will be slightly longer than homogeneous replay.\n\n3. Writing data: Currently the system only supports writing to the output tables in a single thread.\n\n4. Terminating the replay: Use command [cancelJob](https://docs.dolphindb.com/en/Functions/c/cancelJob.html) or [cancelConsoleJob](https://docs.dolphindb.com/en/Functions/c/cancelConsoleJob.html) from a new web or console.\n\n#### Arguments\n\n**inputTables** can be:\n\n* for 1-to-1 replay, a non-partitioned in-memory table or data source;\n\n* for N-to-N/N-to-1 homogeneous replay, multiple non-partitioned in-memory tables or a tuple of data sources;\n\n* for N-to-1 heterogeneous replay, a dictionary. The key of the dictionary can be of any data type indicating the unique identifier of the input table, and the value is the table object or data source.\n\n**outputTables** can be:\n\n* for 1-to-1/N-to-1 homogeneous replay, a table object (a non-partitioned in-memory table/stream table) or a string scalar with the same schema of the input table.\n\n* for N-to-N replay, a string vector or tuple of table objects (non-partitioned in-memory tables/stream tables) with the same length as that of inputTables. The outputTables and inputTables are mapped one-to-one, and each pair has the same schema.\n\n* for N-to-1 heterogeneous replay, a table object (a non-partitioned in-memory table/stream table) containing at least three columns:\n\n  * The first column is of TIMESTAMP type indicating the timestamp specified by *dateColumn/timeColumn*;\n\n  * The second column is of SYMBOL or STRING type indicating the key of the dictionary specified in the *inputTables*;\n\n  * The third column must be of BLOB type that stores the serialized result of each replayed record.\n\n  * In addition, you can output the columns with the same column names and data types in the input tables.\n\n**dateColumn** and **timeColumn** (optional) is the column name of the time column. At least one of them must be specified.\n\n* for 1-to-1/N-to-1 homogeneous replay: it is a string scalar, and the time columns in the *inputTables* and *outputTables* must use the same name.\n\n* for N-to-N replay: It is a string scalar if time columns of the input tables have same column names; otherwise, it is a string vector.\n\n* for N-to-1 replay: It is a string scalar if time columns of the input tables have same column names; otherwise, it is a dictionary. The key of the dictionary is a user-defined string indicating the unique identifier of the input table, and the value is *dateColumn*/*timeColumn*.\n\nIf *dateColumn* and *timeColum* are specified as the same column or only one of them is specified, there is no restriction on the type of the specified time column.\n\nIf *dateColumn* and *timeColum* are specified as different columns, *dateColumn* must be DATE and *timeColum* can only be SECOND, TIME or NANOTIME.\n\n**replayRate** (optional) is an integer. Together with the parameter *absoluteRate*, it determines the speed of replaying data.\n\n**absoluteRate** (optional) is a Boolean value. The default value is true, indicating that the system replays *replayRate* records per second. If set to false, data is replayed at *replayRate* times the time span of the data.\n\n**parallelLevel** (optional) is a positive integer indicating the number of threads to load data sources to memory concurrently. The default value is 1. If *inputTables* is not a data source, there is no need to specify.\n\n**sortColumns** (optional) is a STRING scalar or vector of length 2. Data with the same timestamp is sorted according to the specified *sortColumns*. It is supported only for heterogeneous replay.\n\nNote that any column in either of the input tables can be specified as a sort column. If one of the input tables doesn't contain the specified sort column, it is filled with NULL values and treated as the minimum values when the data is sorted.\n\n**preciseRate** (optional) is a Boolean value. The default value is false. If it is set to true, the data is replayed at *replayRate* times the time difference between two adjacent records. Note that deviation of a few milliseconds may exist.\n\n#### Examples\n\nExample 1. 1-to-1 replay:\n\n```\nn=1000\nsym = take(`IBM,n)\ntimestamp= take(temporalAdd(2012.12.06T09:30:12.000,1..500,'s'),n)\nvolume = rand(100,n)\ntrades=table(sym,timestamp,volume)\ntrades.sortBy!(`timestamp)\nshare streamTable(100:0,`sym`timestamp`volume,[SYMBOL,TIMESTAMP,INT]) as st\n```\n\nReplay 100 records per second. For 1000 records in table \"trades\", it takes about 10 seconds.\n\n```\ntimer replay(inputTables=trades, outputTables=st, dateColumn=`timestamp, timeColumn=`timestamp,replayRate=100, absoluteRate=true);\n// output\nTime elapsed: 10001.195 ms\n```\n\nReplay at 100 times the time span of the data. The difference between the start timestamp and the end timestamp in table \"trades\" is 500 seconds, and it takes about 5 seconds to replay the table.\n\n```\ntimer replay(inputTables=trades,outputTables=st,dateColumn=`timestamp,timeColumn=`timestamp,replayRate=100,absoluteRate=false);\n// output\nTime elapsed: 5001.909 ms\n```\n\nReplay at the maximum speed:\n\n```\ntimer replay(inputTables=trades,outputTables=st,dateColumn=`timestamp,timeColumn=`timestamp);\n// output\nTime elapsed: 0.974 ms\n```\n\nReplay at 100 times the difference between two adjacent records with the *preciseRate* specified. It takes about 4.99 seconds to replay the table.\n\n```\ntimer replay(inputTables=trades,outputTables=st,dateColumn=`timestamp,timeColumn=`timestamp,replayRate=100,absoluteRate=false, preciseRate=true);\nTime elapsed: 4991.177 ms\n```\n\nExample 2. N-to-N replay.\n\nThe following script replays two data sources to the join engine for asof join.\n\n```\nn=50000\nsym = rand(symbol(`IBM`APPL`MSFT`GOOG`GS),n)\ndate=take(2012.06.12..2012.06.16,n)\ntime=rand(13:00:00.000..16:59:59.999,n)\nvolume = rand(100,n)\nt1=table(sym,date,time,volume).sortBy!([`date, `time])\n\nsym = rand(symbol(`IBM`APPL`MSFT`GOOG`GS),n)\ndate=take(2012.06.12..2012.06.16,n)\ntime=rand(13:00:00.000..16:59:59.999,n)\nprice = 100 + rand(10.0,n)\nt2=table(sym,date,time,price).sortBy!([`date, `time])\n\nif(existsDatabase(\"dfs://test_stock\")){\ndropDatabase(\"dfs://test_stock\")\n}\ndb=database(\"dfs://test_stock\",VALUE,2012.06.12..2012.06.16)\npt1=db.createPartitionedTable(t1,`pt1,`date).append!(t1)\npt2=db.createPartitionedTable(t2,`pt2,`date).append!(t2)\n\nleft = table(100:0,`sym`dt`volume,[SYMBOL,TIMESTAMP,INT]) \nright = table(100:0,`sym`dt`price,[SYMBOL,TIMESTAMP,DOUBLE]) \n\nopt=table(100:0, `dt`sym`volume`price`total, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE])\najEngine=createAsofJoinEngine(name=\"ajEngine\", leftTable=left, rightTable=right, outputTable=opt, metrics=<[volume, price, volume*price]>, matchingColumn=`sym, timeColumn=`dt, useSystemTime=false, delayedTime=1)\n\nds1=replayDS(sqlObj=<select sym, concatDateTime(date, time) as dt, volume from pt1>,dateColumn=`date,timeColumn=`time,timeRepartitionSchema=[13:00:00.000, 14:00:00.000, 15:00:00.000, 16:00:00.000, 17:00:00.000])\nds2=replayDS(sqlObj=<select sym, concatDateTime(date, time) as dt, price from pt2>,dateColumn=`date,timeColumn=`time,timeRepartitionSchema=[13:00:00.000, 14:00:00.000, 15:00:00.000, 16:00:00.000, 17:00:00.000])\n\nreplay(inputTables=[ds1,ds2], outputTables=[getLeftStream(ajEngine), getRightStream(ajEngine)], dateColumn=`dt);   \n\nselect count(*) from opt\n// output\n50000\n```\n\nExample 3. N-to-1 heterogeneous replay. The output table needs to be deserialized, filtered and processed by `streamFilter`.\n\n```\nn=1000\nsym = take(`IBM`GS,n)\nmyDate=take(2021.01.02..2021.01.06, n).sort!()\nmyTime=take(09:30:00..15:59:59,n)\nvol = rand(100,n)\nt=table(sym,myDate,myTime,vol)\n\nsym = take(`IBM`GS,n)\ndate=take(2021.01.02..2021.01.06, n).sort!()\ntime=take(09:30:00..15:59:59,n)\nvol = rand(100,n)\nprice = take(10,n)+rand(1.0,n)\nt1=table(sym, date,time,vol,price)\n\n\nif(existsDatabase(\"dfs://test_stock1\")){\ndropDatabase(\"dfs://test_stock1\")\n}\ndb1=database(\"\",RANGE, 2021.01.02..2021.01.07)\ndb2=database(\"\",VALUE,`IBM`GS)\ndb=database(\"dfs://test_stock1\",COMPO,[db1, db2])\norders=db.createPartitionedTable(t,`orders,`myDate`sym)\norders.append!(t);\ntrades=db.createPartitionedTable(t1,`trades,`date`sym)\ntrades.append!(t1);\n// load data sources\nds = replayDS(sqlObj=<select * from loadTable(db, `orders)>, dateColumn=`myDate, timeColumn=`myTime)\nds.size();\nds1 = replayDS(sqlObj=<select * from loadTable(db, `trades)>, dateColumn=`date, timeColumn=`time)\nds1.size();\n\ninput_dict  = dict([\"msg1\", \"msg2\"], [ds, ds1])\ndate_dict = dict([\"msg1\", \"msg2\"], [`myDate, `date])\ntime_dict = dict([\"msg1\", \"msg2\"], [`myTime, `time])\n//subscribe to the output table of replay to ingest the data to the stream filter\nshare streamTable(100:0,`timestamp`sym`blob`vol, [DATETIME,SYMBOL, BLOB, INT]) as opt\n\nfilterOrder=table(100:0, `sym`date`time`volume, [SYMBOL, DATE, SECOND, INT])\nfilterTrades=table(100:0, `sym`date`time`volume`price, [SYMBOL, DATE, SECOND, INT, DOUBLE])\n//define the input table of stream filter\nshare streamTable(100:0,`timestamp`sym`blob`vol, [DATETIME,SYMBOL, BLOB, INT]) as streamFilter_input\n// the stream filter splits the ingested data and distributes them to table \"filterOrder\" and \"filterTrades\"\nfilter1=dict(STRING,ANY)\nfilter1['condition']=`msg1\nfilter1['handler']=filterOrder\n\nfilter2=dict(STRING,ANY)\nfilter2['condition']=`msg2\nfilter2['handler']=filterTrades\nschema=dict([\"msg1\",\"msg2\"], [filterOrder, filterTrades])\nstEngine=streamFilter(name=`streamFilter, dummyTable=streamFilter_input, filter=[filter1,filter2], msgSchema=schema)\nsubscribeTable(tableName=\"opt\", actionName=\"sub1\", offset=0, handler=stEngine, msgAsTable=true)\n\nreplay(inputTables=input_dict, outputTables=opt, dateColumn = date_dict, timeColumn=time_dict,  replayRate=100, absoluteRate=false);\n\nselect count(*) from filterOrder\n// output\n1000\n```\n\n"
    },
    "replayDS": {
        "url": "https://docs.dolphindb.com/en/Functions/r/replayDS.html",
        "signatures": [
            {
                "full": "replayDS(sqlObj, [dateColumn], [timeColumn], [timeRepartitionSchema])",
                "name": "replayDS",
                "parameters": [
                    {
                        "full": "sqlObj",
                        "name": "sqlObj"
                    },
                    {
                        "full": "[dateColumn]",
                        "name": "dateColumn",
                        "optional": true
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[timeRepartitionSchema]",
                        "name": "timeRepartitionSchema",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [replayDS](https://docs.dolphindb.com/en/Functions/r/replayDS.html)\n\n\n\n#### Syntax\n\nreplayDS(sqlObj, \\[dateColumn], \\[timeColumn], \\[timeRepartitionSchema])\n\n#### Arguments\n\n**sqlObj** is metacode with SQL statements. The table object in the SQL statement is a DFS table and must use a DATE type column as one of the partitioning columns.\n\n**dateColumn** (optional) must be a time column of the table queried by the SQL statement, based on which the data is sorted. It can be of DATE (most commonly used), MONTH or other temporal types. If *dateColumn* is specified, it must be one of the partitioning columns of the DFS table. Data sources are generated based on the time precision of the *dateColumn*, e.g., if the *dateColumn* is partitioned by day, the data source is also divided by day.\n\n**timeColumn** (optional) must be a time column of the table queried by the SQL statement, based on which the data is sorted. If *dateColumn* is of DATE type, you can further deliminate data sources by specifying *timeColumn* as SECOND, TIME or NANOTIME type.\n\n**Note:**\n\n* Currently, parameters *dateColumn* and *timeColumn* do not support DATEHOUR type.\n\n* If *dateColumn* is not specified, the first column of the table object is treated as the date column.\n\n**timeRepartitionSchema** (optional) is a vector of temporal type. If *timeColumn* is specified, *timeRepartitionSchema* deliminates multiple data sources based on *timeColumn*. For example, if timeRepartitionSchema =\\[t1, t2, t3], then there are 4 data sources within each day: \\[00:00:00.000,t1), \\[t1,t2), \\[t2,t3), and \\[t3,23:59:59.999).\n\n#### Details\n\nGenerates a tuple of data sources from a DFS table (queried by a SQL statement) based on its time columns. It can be further divided by the parameters *timeColumn* and *timeRepartitionSchema*.\n\nIt is used as the inputs of function `replay`. To replay a DFS table, the `replay` function must be conjuncted with the `replayDS` function.\n\n#### Examples\n\n```\nn=int(60*60*6.5)\nsym = take(take(`IBM,n).join(take(`GS,n)), n*2*3)\ndate=take(2021.01.04..2021.01.06, n*2*3).sort!()\ntime=take(09:30:00..15:59:59,n*2*3)\nvolume = rand(100, n*2*3)\nt=table(sym,date,time,volume)\nif(existsDatabase(\"dfs://test_stock\")){\ndropDatabase(\"dfs://test_stock\")\n}\ndb1=database(\"\",RANGE, 2021.01.04..2021.01.07)\ndb2=database(\"\",VALUE,`IBM`GS)\ndb=database(\"dfs://test_stock\",COMPO,[db1, db2])\ntrades=db.createPartitionedTable(t,`trades,`date`sym)\ntrades.append!(t);\nds = replayDS(sqlObj=<select * from loadTable(db, `trades)>, dateColumn=`date, timeColumn=`time)\nds.size();\n// output\n3\n\nds = replayDS(sqlObj=<select * from loadTable(db, `trades)>, dateColumn=`date, timeColumn=`time, timeRepartitionSchema=[11:30:00, 14:00:00])\nds.size();\n// output\n9\n```\n"
    },
    "repmat": {
        "url": "https://docs.dolphindb.com/en/Functions/r/repmat.html",
        "signatures": [
            {
                "full": "repmat(X, rowRep, colRep)",
                "name": "repmat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "rowRep",
                        "name": "rowRep"
                    },
                    {
                        "full": "colRep",
                        "name": "colRep"
                    }
                ]
            }
        ],
        "markdown": "### [repmat](https://docs.dolphindb.com/en/Functions/r/repmat.html)\n\n\n\n#### Syntax\n\nrepmat(X, rowRep, colRep)\n\n#### Arguments\n\n**X** is a matrix.\n\n**rowRep** and **colRep** are positive integers.\n\n#### Details\n\nCreate a large matrix consisting of a rowRep-by-colRep tiling of copies of *X*.\n\n#### Examples\n\n```\nx=matrix(1 2 3, 4 5 6);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nrepmat(x, 2, 3);\n```\n\n| #0 | #1 | #2 | #3 | #4 | #5 |\n| -- | -- | -- | -- | -- | -- |\n| 1  | 4  | 1  | 4  | 1  | 4  |\n| 2  | 5  | 2  | 5  | 2  | 5  |\n| 3  | 6  | 3  | 6  | 3  | 6  |\n| 1  | 4  | 1  | 4  | 1  | 4  |\n| 2  | 5  | 2  | 5  | 2  | 5  |\n| 3  | 6  | 3  | 6  | 3  | 6  |\n"
    },
    "resample": {
        "url": "https://docs.dolphindb.com/en/Functions/r/resample.html",
        "signatures": [
            {
                "full": "resample(X, rule, func, [closed], [label], [origin='start_day'])",
                "name": "resample",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "rule",
                        "name": "rule"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    },
                    {
                        "full": "[label]",
                        "name": "label",
                        "optional": true
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    }
                ]
            }
        ],
        "markdown": "### [resample](https://docs.dolphindb.com/en/Functions/r/resample.html)\n\n\n\n#### Syntax\n\nresample(X, rule, func, \\[closed], \\[label], \\[origin='start\\_day'])\n\n#### Arguments\n\n**X** is a matrix or series with row labels. The row labels must be non-NULL values of temporal type, and must be increasing.\n\n**rule** is a string that can take the following values:\n\n| Values of parameter \"rule\" | Corresponding DolphinDB function |\n| -------------------------- | -------------------------------- |\n| \"B\"                        | businessDay                      |\n| \"W\"                        | weekEnd                          |\n| \"WOM\"                      | weekOfMonth                      |\n| \"LWOM\"                     | lastWeekOfMonth                  |\n| \"M\"                        | monthEnd                         |\n| \"MS\"                       | monthBegin                       |\n| \"BM\"                       | businessMonthEnd                 |\n| \"BMS\"                      | businessMonthBegin               |\n| \"SM\"                       | semiMonthEnd                     |\n| \"SMS\"                      | semiMonthBegin                   |\n| \"Q\"                        | quarterEnd                       |\n| \"QS\"                       | quarterBegin                     |\n| \"BQ\"                       | businessQuarterEnd               |\n| \"BQS\"                      | businessQuarterBegin             |\n| \"REQ\"                      | FY5253Quarter                    |\n| \"A\"                        | yearEnd                          |\n| \"AS\"                       | yearBegin                        |\n| \"BA\"                       | businessYearEnd                  |\n| \"BAS\"                      | businessYearBegin                |\n| \"RE\"                       | FY5253                           |\n| \"D\"                        | date                             |\n| \"H\"                        | hourOfDay                        |\n| \"min\"                      | minuteOfHour                     |\n| \"S\"                        | secondOfMinute                   |\n| \"L\"                        | millisecond                      |\n| \"U\"                        | microsecond                      |\n| \"N\"                        | nanosecond                       |\n\nThe strings above can also be used with positive integers for parameter *rule*. For example, \"2M\" means the end of every two months. In addition, *rule* can also be set as the identifier of the trading calendar, e.g., the Market Identifier Code of an exchange, or a user-defined calendar name. Positive integers can also be used with identifiers. For example, \"2XNYS\" means every two trading days of New York Stock Exchange.\n\n**func** is an aggregate function.\n\n**closed** (optional) is a string indicating which boundary of the interval is closed.\n\n* The default value is 'left' for all values of *rule* except for 'M', 'A', 'Q', 'BM', 'BA', 'BQ', and 'W' which all have a default of 'right'.\n\n* The default is 'right' if *origin* is 'end' or 'end\\_day'.\n\n**label** (optional) is a string indicating which boundary is used to label the interval.\n\n* The default value is 'left' for all values of *rule* except for 'M', 'A', 'Q', 'BM', 'BA', 'BQ', and 'W' which all have a default of 'right'.\n\n* The default is 'right' if *origin* is 'end' or 'end\\_day'.\n\n**origin** (optional) is a string or a scalar of the same data type as *X*, indicating the timestamp where the intervals start. It can be 'epoch', start', 'start\\_day', 'end', 'end\\_day' or a user-defined time object. The default value is 'start\\_day'.\n\n* 'epoch': *origin* is 1970-01-01\n\n* 'start': *origin* is the first value of the timeseries\n\n* 'start\\_day': *origin* is 00:00 of the first day of the timeseries\n\n* 'end': *origin* is the last value of the timeseries\n\n* 'end\\_day': *origin* is 24:00 of the last day of the timeseries\n\n#### Details\n\nApply func to *X* based on the frenquency (or the trading calendar) as specified in *rule*. Note that when *rule* is specified as the identifier of the trading calendar, data generated on a non-trading day will be calculated in the previous trading day.\n\n#### Examples\n\n```\nindex = [2000.01.01, 2000.01.31, 2000.02.15, 2000.02.20, 2000.03.12, 2000.04.16, 2000.05.06, 2000.08.30]\ns = indexedSeries(index, 1..8)\ns.resample(\"M\", sum);\n```\n\n|            | col1 |\n| ---------- | ---- |\n| 2000.01.31 | 3    |\n| 2000.02.29 | 7    |\n| 2000.03.31 | 5    |\n| 2000.04.30 | 6    |\n| 2000.05.31 | 7    |\n| 2000.06.30 |      |\n| 2000.07.31 |      |\n| 2000.08.31 | 8    |\n\n```\ns.resample(\"2M\", last);\n```\n\n|            | col1 |\n| ---------- | ---- |\n| 2000.01.31 | 2    |\n| 2000.03.31 | 5    |\n| 2000.05.31 | 7    |\n| 2000.07.31 |      |\n| 2000.09.30 | 8    |\n\n```\nindex = temporalAdd(2022.01.01 00:00:00,1..8,`m)\ns = indexedSeries(index, 1..8)\ns.resample(rule=`3min, func=sum);\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.01.01T00:00:00 | 3    |\n| 2022.01.01T00:03:00 | 12   |\n| 2022.01.01T00:06:00 | 21   |\n\n```\ns.resample(rule=`3min, func=sum, closed=`right);\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.01.01T00:00:00 | 6    |\n| 2022.01.01T00:03:00 | 15   |\n| 2022.01.01T00:06:00 | 15   |\n\n```\ns.resample(rule=`3min, func=sum, closed=`left,origin=`end);\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.01.01T00:02:00 | 1    |\n| 2022.01.01T00:05:00 | 9    |\n| 2022.01.01T00:08:00 | 18   |\n| 2022.01.01T00:11:00 | 8    |\n\n```\ns.resample(rule=`3min, func=sum,origin=2022.10.01 00:00:10)\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.01.01T00:00:10 | 6    |\n| 2022.01.01T00:03:10 | 15   |\n| 2022.01.01T00:06:10 | 15   |\n\nA matrix with increasing row labels can be specified.\n\n```\nm = matrix(1..5, 1..5)\n// The row labels are non-strictly increasing.\nindex = temporalAdd(2000.01.01, [1, 1, 2, 2, 3], \"d\")\nm.rename!(index, `A`B);\nm.resample(rule=`D, func=sum);\n```\n\n| label      | A | B |\n| ---------- | - | - |\n| 2000.01.02 | 3 | 3 |\n| 2000.01.03 | 7 | 7 |\n| 2000.01.04 | 5 | 5 |\n"
    },
    "resetDBDirMeta": {
        "url": "https://docs.dolphindb.com/en/Functions/r/resetDBDirMeta.html",
        "signatures": [
            {
                "full": "resetDBDirMeta(dbDir)",
                "name": "resetDBDirMeta",
                "parameters": [
                    {
                        "full": "dbDir",
                        "name": "dbDir"
                    }
                ]
            }
        ],
        "markdown": "### [resetDBDirMeta](https://docs.dolphindb.com/en/Functions/r/resetDBDirMeta.html)\n\n\n\n#### Syntax\n\nresetDBDirMeta(dbDir)\n\n#### Arguments\n\n**dbDir** is a string in the format of \"volumeB/DATABASE\", indicating the destination directory to which the database will be moved.\n\n#### Details\n\nWhen transferring metadata across disk volumes, please call `resetDBDirMeta` to change the DATABASE storage path in the metadata to the destination path before transferring the metadata. This command can only be executed on the data node.\n\n**Note:**\n\n1. The transfer of metadata across volumes can only be performed on the same node;\n\n2. Before moving the metadata, make sure that there is no writing process on the current node, all transactions have been completed, and all buffers have been synchronized to the disk.\n\nThe procedures to move the metalog (including CHUNK\\_METADATA, DATABASE, IOTRAN\\_TYPE and LOG) from volume A to volume B are as follows:\n\n1. Execute command `resetDBDirMeta('volumeB/DATABASE')` and shut down the server.\n\n2. Copy the directories CHUNK\\_METADATA, DATABASE, IOTRAN\\_TYPE and LOG from VolumeA to VolumeB.\n\n3. Delete the original directories CHUNK\\_METADATA, DATABASE, IOTRAN\\_TYPE and LOG from VolumeA.\n\n4. Modify the configuration parameter *chunkMetaDir* = volumeB/CHUNK\\_METADATA and start the server.\n"
    },
    "resetDfsRebalanceConcurrency": {
        "url": "https://docs.dolphindb.com/en/Functions/r/resetDfsRebalanceConcurrency.html",
        "signatures": [
            {
                "full": "resetDfsRebalanceConcurrency(newConcurrecyNum)",
                "name": "resetDfsRebalanceConcurrency",
                "parameters": [
                    {
                        "full": "newConcurrecyNum",
                        "name": "newConcurrecyNum"
                    }
                ]
            }
        ],
        "markdown": "### [resetDfsRebalanceConcurrency](https://docs.dolphindb.com/en/Functions/r/resetDfsRebalanceConcurrency.html)\n\n#### Syntax\n\nresetDfsRebalanceConcurrency(newConcurrecyNum)\n\n#### Arguments\n\n**newConcurrecyNum** is a positive integer that specifies the maximum number of workers allocated for chunk rebalance.\n\n#### Details\n\nModify the number of workers used by the current node for chunk rebalance online. This function can only be executed by the administrator on the controller.\n\n**Note:** This function modifies the configuration parameter *dfsRebalanceConcurrency* during the current session only. To permanently modify *dfsRebalanceConcurrency*, change it in the configuration file (the default value is twice the number of all nodes except the agent).\n\n#### Examples\n\n```\nresetDfsRebalanceConcurrency(2)\n```\n\nRelated functions: [getDfsRebalanceConcurrency](https://docs.dolphindb.com/en/Functions/g/getDfsRebalanceConcurrency.html)\n\n"
    },
    "resetDfsRecoveryConcurrency": {
        "url": "https://docs.dolphindb.com/en/Functions/r/resetDfsRecoveryConcurrency.html",
        "signatures": [
            {
                "full": "resetDfsRecoveryConcurrency(newConcurrecyNum)",
                "name": "resetDfsRecoveryConcurrency",
                "parameters": [
                    {
                        "full": "newConcurrecyNum",
                        "name": "newConcurrecyNum"
                    }
                ]
            }
        ],
        "markdown": "### [resetDfsRecoveryConcurrency](https://docs.dolphindb.com/en/Functions/r/resetDfsRecoveryConcurrency.html)\n\n#### Syntax\n\nresetDfsRecoveryConcurrency(newConcurrecyNum)\n\n#### Arguments\n\n**newConcurrecyNum** is a positive integer that specifies the maximum number of workers allocated for chunk recovery.\n\n#### Details\n\nModify the number of workers used by the current node for chunk recovery online. This function can only be executed by the administrator on the controller.\n\n**Note:** This function modifies the configuration parameter *dfsRecoveryConcurrency* during the current session only. To permanently modify *dfsRecoveryConcurrency*, change it in the configuration file (the default value is twice the number of all nodes except the agent).\n\n#### Examples\n\n```\nresetDfsRecoveryConcurrency(2)\n```\n\nRelated functions: [getDfsRecoveryConcurrency](https://docs.dolphindb.com/en/Functions/g/getDfsRecoveryConcurrency.html)\n\n"
    },
    "resetPwd": {
        "url": "https://docs.dolphindb.com/en/Functions/r/resetPwd.html",
        "signatures": [
            {
                "full": "resetPwd(userId, newPwd)",
                "name": "resetPwd",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    },
                    {
                        "full": "newPwd",
                        "name": "newPwd"
                    }
                ]
            }
        ],
        "markdown": "### [resetPwd](https://docs.dolphindb.com/en/Functions/r/resetPwd.html)\n\n\n\n#### Syntax\n\nresetPwd(userId, newPwd)\n\n#### Arguments\n\n**userId** is a string indicating a user name.\n\n**newPwd** is a string indicating the new password for the user. It cannot contain space or control characters.\n\nSince DolphinDB 2.00.10.10, users can determine whether to verify the complexity of *newPwd* by setting the configuration *enhancedSecurityVerification*. If it is not specified, no verification will be applied; if it is set to true, the password must meet the following conditions:\n\n* 8-20 characters\n\n* at least 1 capital letter\n\n* at least 1 special character, including !\"#$%&'()\\*+,-./:;<=>?@\\[]^\\_\\`{|}\\~\n\n#### Details\n\nReset a user's password. This can only be executed by an administrator.\n\n#### Examples\n\n```\nresetPwd(`AlexEdwards, `T51pm363);\n```\n"
    },
    "resetRecoveryWorkerNum": {
        "url": "https://docs.dolphindb.com/en/Functions/r/resetRecoveryWorkerNum.html",
        "signatures": [
            {
                "full": "resetRecoveryWorkerNum(newWorkerNum)",
                "name": "resetRecoveryWorkerNum",
                "parameters": [
                    {
                        "full": "newWorkerNum",
                        "name": "newWorkerNum"
                    }
                ]
            }
        ],
        "markdown": "### [resetRecoveryWorkerNum](https://docs.dolphindb.com/en/Functions/r/resetRecoveryWorkerNum.html)\n\n#### Syntax\n\nresetRecoveryWorkerNum(newWorkerNum)\n\n#### Arguments\n\n**newWokerNum** is a positive integer that specifies the number of worker threads used for chunk recovery.\n\n#### Details\n\nModify the number of worker threads used by the current node for chunk recovery online. This command can only be executed by the administrator on the data node.\n\n**Note:** This command modifies the configuration parameter *recoveryWorkers* during the current session only. To permanently modify *recoveryWorkers*, change it in the configuration file (the default value is 1).\n\n#### Example\n\n```\nresetRecoveryWorkerNum(2)\n```\n\n"
    },
    "reshape": {
        "url": "https://docs.dolphindb.com/en/Functions/r/reshape.html",
        "signatures": [
            {
                "full": "reshape(obj, [dim])",
                "name": "reshape",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[dim]",
                        "name": "dim",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [reshape](https://docs.dolphindb.com/en/Functions/r/reshape.html)\n\n\n\n#### Syntax\n\nreshape(obj, \\[dim])\n\n#### Arguments\n\n**obj** is a vector/matrix.\n\n**dim** (optional) is a pair of integers indicating (row dimension):(column dimension) of the result.\n\n#### Details\n\nChange the dimensions of a matrix and return a new matrix. If *dim* is not specified, reshape *obj* to a vector.\n\n#### Examples\n\n```\nx=1..6;\nx=x.reshape(3:2);\nx\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nx=x.reshape(2:3);\nx\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 1  | 4  | 6  |\n\n```\nx=x.reshape(6:1)\nx\n```\n\n| #0 |\n| -- |\n| 1  |\n| 2  |\n| 3  |\n| 4  |\n| 5  |\n| 6  |\n\n```\nx.reshape()\n// output\n[1,2,3,4,5,6]\n// reshape x to a vector.\n```\n"
    },
    "residual": {
        "url": "https://docs.dolphindb.com/en/Functions/r/residual.html",
        "signatures": [
            {
                "full": "residual(Y,X,params,[intercept=true])",
                "name": "residual",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "params",
                        "name": "params"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [residual](https://docs.dolphindb.com/en/Functions/r/residual.html)\n\n\n\n#### Syntax\n\nresidual(Y,X,params,\\[intercept=true])\n\n#### Arguments\n\n**Y** is the dependent variable. It is a vector.\n\n**X** is the independent variable(s). *X* can be a matrix, table or tuple. When *X* is a matrix, if the number of rows is the same as the length of *Y*, each column of *X* is a factor; If the number of columns equals the length of *Y*, each row of *X* is a factor.\n\n**params** is the regression estimator.\n\n**intercept** (optional) is a Boolean variable indicating whether to include an intercept in the regression. The default value is true, meaning that the system automatically adds a column of \"1\" to *X* to generate the intercept.\n\n#### Details\n\nReturn the residuals from the least squares regression of *Y* on *X*.\n\n**Note:**\n\n* For an in-memory table, the residuals can be obtained setting mode=2 in function `ols` or `wls`;\n\n* For a DFS table, the residuals can only be obtained with function `residual`.\n\n#### Examples\n\n```\nx1=1 3 5 7 11 16 23\nx2=2 8 11 34 56 54 100\ny=0.1 4.2 5.6 8.8 22.1 35.6 77.2\n\nparams=ols(y, x1);\nresidual(y,x1,params)\n// output\n[6.634188034188036,3.976923076923078,-1.380341880341881,-4.937606837606838,-5.152136752136756,-8.545299145299146,9.404273504273504]\n\nparams1=ols(y, (x1,x2),false);\nresidual(y,(x1,x2),params1,false)\n// output\n[-1.941530853763632,-2.556479729553295,-4.923597852949359,-11.809587658969416,-11.098921251860737,-4.0152525111045,13.183836820351686]\n\nx=matrix(1 4 8 2 3, 1 4 2 3 8, 1 5 1 1 5);\np1=ols(1..5, x);\nresidual(1..5, x,p1);\n// output\n[-0.474770642201834,0.268348623853214,-0.123853211009174,0.598623853211011,-0.268348623853205]\n```\n"
    },
    "restore": {
        "url": "https://docs.dolphindb.com/en/Functions/r/restore.html",
        "signatures": [
            {
                "full": "restore(backupDir, dbPath, tableName, partition, [force=false], [outputTable], [parallel=false], [snapshot=false])",
                "name": "restore",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "partition",
                        "name": "partition"
                    },
                    {
                        "full": "[force=false]",
                        "name": "force",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[outputTable]",
                        "name": "outputTable",
                        "optional": true
                    },
                    {
                        "full": "[parallel=false]",
                        "name": "parallel",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[snapshot=false]",
                        "name": "snapshot",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [restore](https://docs.dolphindb.com/en/Functions/r/restore.html)\n\n\n\n#### Syntax\n\nrestore(backupDir, dbPath, tableName, partition, \\[force=false], \\[outputTable], \\[parallel=false], \\[snapshot=false])\n\n#### Arguments\n\n**backupDir** is a string indicating the directory where the backup is kept.\n\n**dbPath** is a string indicating the path of a DFS database.\n\n**tableName** is a string indicating a DFS table name.\n\n**partition** is a string indicating the relative path of the partitions to be restored. Use \"?\" as a single wildcard and \"%\" as a wildcard that can match zero or more characters.\n\n* To restore all partitions, use \"%\".\n\n* To restore a certain partition, specify the relative path or \"%\" +\"partition name\". For example, to restore the \"20170810/50\\_100\" partition under \"dfs\\://compoDB\", specify \"/compoDB/20170807/0\\_50\" or \"%/20170807/0\\_50\" as partition path.\n\n  For versions between 1.30.16/2.00.4 - 1.30.18/2.00.6, if *chunkGranularity* is set to \"TABLE\" when creating the database, *partition* must include the physical index (which you can get with the `listTables` function) of the selected partition. For example, if the physical index of the \"/compoDB/20170807/0\\_50\" partition is 8t, then specify partition as \"/compoDB/20170807/0\\_50/8t\" to restore it.\n\n**force** (optional) is a Boolean value. The default value is false, meaning to perform an incremental recovery, i.e., only the partitions with different metadata from that of the most recent backup are restored. True means to perform a full recovery.\n\n**outputTable** (optional) is the handle to a DFS table which has the same schema as the backup table. If it is unspecified, partitions will be restored to the target table specified by *tableName*; Otherwise, partitions will be restored to *outputTable* whereas the table specified by *tableName* remains unchanged.\n\n**parallel** (optional) is a Boolean value indicating whether to restore partitions of a table in parallel. The default value is false.\n\n**snapshot** (optional) is a Boolean value indicating whether to synchronize the deletion of table/partitions in the backup to the restored database. It only takes effect when *partition* is set to \"%\". If set to true, the deleted tables/partitions in the backup are deleted in the target restore database synchronously. Note: For versions prior to 2.00.13/3.00.1, the default value for *snapshot* is true. Since version 2.00.13/3.00.1, the default value is false.\n\n#### Details\n\nRestore the specified partitions from the most recent backup. Return a string vector indicating the path of restored partitions. The function must be executed by a logged-in user.\n\nNote:\n\n* To restore the partitions backed up with SQL statements, the parameter *snapshot* should not be true. Otherwise an error is raised.\n\n* When restoring the partitions backed up with SQL statements, the backup data is directly appended to the target restore table; When restoring the partitions backed up by copying files, the system only overwrites the partitions that have different data.\n\n* Make sure that the storage engine of the backup database is the same as the engine of *newDBPath*, and the partitionScheme must be the same (except for VALUE). For a VALUE partitioned database, the partitioning scheme of the backup database must be a subset of that of the database to be restored. For example, if the partitioning scheme of the backup database is database(\"dfs\\://xxx\", VALUE, 2017.08.07..2017.08.11), then the partitioning scheme of the target database must be VALUE-based and its range must be beyond 2017.08.07..2017.08.11.\n\n#### Examples\n\nCreate a DFS database dfs\\://compoDB\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x);\n\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID=database(, RANGE, 0 50 100);\ndb = database(\"dfs://compoDB\", COMPO, [dbDate, dbID]);\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n```\n\nBack up the entire table pt:\n\n```\nbackup(\"/home/DolphinDB/backup\",<select * from loadTable(\"dfs://compoDB\",\"pt\")>,true);\n// output\n10\n```\n\nExample 1. Restore the entire table pt:\n\n```\nrestore(\"/home/DolphinDB/backup\",\"dfs://compoDB\",\"pt\",\"%\",true);\n// output\n[\"dfs://compoDB/20170807/0_50/6F\",\"dfs://compoDB/20170807/50_100/6F\",\"dfs://compoDB/20170808/0_50/6F\",\"dfs://compoDB/20170808/50_100/6F\",\"dfs://compoDB/20170809/0_50/6F\",\"dfs://compoDB/20170809/50_100/6F\",\"dfs://compoDB/20170810/0_50/6F\",\"dfs://compoDB/20170810/50_100/6F\",\"dfs://compoDB/20170811/0_50/6F\",\"dfs://compoDB/20170811/50_100/6F\"]\n```\n\nExample 2. Restore the partitions in table pt with date=2017.08.10:\n\n```\nrestore(\"/home/DolphinDB/backup\",\"dfs://compoDB\",\"pt\",\"%20170810%\",true)\n// output\n[\"dfs://compoDB/20170810/0_50/6F\",\"dfs://compoDB/20170810/50_100/6F\"]\n```\n\nExample 3. Restore the backup of table pt to table temp. Table temp has the same schema as table pt. Note that data loss may occur in table temp when using \"%\".\n\n```\ntemp=db.createPartitionedTable(t, `pt, `date`ID);\n\nrestore(\"/home/DolphinDB/backup\",\"dfs://compoDB\",\"pt\",\"%\",true,temp);\n// output\n[\"dfs://compoDB/20170807/0_50/6F\",\"dfs://compoDB/20170807/50_100/6F\",\"dfs://compoDB/20170808/0_50/6F\",\"dfs://compoDB/20170808/50_100/6F\",\"dfs://compoDB/20170809/0_50/6F\",\"dfs://compoDB/20170809/50_100/6F\",\"dfs://compoDB/20170810/0_50/6F\",\"dfs://compoDB/20170810/50_100/6F\",\"dfs://compoDB/20170811/0_50/6F\",\"dfs://compoDB/20170811/50_100/6F\"]\n\nselect count(*) from temp;\n```\n\n| count   |\n| ------- |\n| 1000000 |\n\nRelated functions: [restoreDB](https://docs.dolphindb.com/en/Functions/r/restoreDB.html), [restoreTable](https://docs.dolphindb.com/en/Functions/r/restoreTable.html), [migrate](https://docs.dolphindb.com/en/Functions/m/migrate.html), [backup](https://docs.dolphindb.com/en/Functions/b/backup.html)\n"
    },
    "restoreDB": {
        "url": "https://docs.dolphindb.com/en/Functions/r/restoreDB.html",
        "signatures": [
            {
                "full": "restoreDB(backupDir, dbPath, [newDBPath])",
                "name": "restoreDB",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "[newDBPath]",
                        "name": "newDBPath",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [restoreDB](https://docs.dolphindb.com/en/Functions/r/restoreDB.html)\n\n\n\n#### Syntax\n\nrestoreDB(backupDir, dbPath, \\[newDBPath])\n\n#### Arguments\n\n**backupDir** is a string indicating the directory to save the backup.\n\n**dbPath** is a string indicating the database path.\n\n**newDBPath** (optional) is is a string indicating the new database name. The default value is *dbPath*.\n\n#### Details\n\nRestore the backup database. Return a table where each row is the restored database and table name.\n\nSimilar to function [migrate](https://docs.dolphindb.com/en/Functions/m/migrate.html), the function can restore a database, and the difference lies in:\n\n* `migrate` can restore all databases and tables under a directory, while `restoreDB` can only restore a database.\n\n* If the names of restored database and tables are the same as the originals, the original databases and tables must be deleted before calling `migrate`, which is not required by function `restoreDB`.\n\nNote:\n\n* This function can only restore a database backed up by copying files (when dbPath is specified for function backup).\n\n* Make sure that the storage engine of the backed-up database is the same as the engine of *newDBPath*, and the *partitionScheme* (except for VALUE) must be the same. For a VALUE partitioned database, the partitioning scheme of the backup database must be a subset of that of the database to be restored.\n\n#### Examples\n\n```\ndbName = \"dfs://compoDB2\"\nn=1000\nID=rand(\"a\"+string(1..10), n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10, n)\nt=table(ID, date, x)\ndb1 = database(, VALUE, 2017.08.07..2017.08.11)\ndb2 = database(, HASH,[INT, 20])\nif(existsDatabase(dbName)){\n     dropDatabase(dbName)\n}\ndb = database(dbName, COMPO,[ db1,db2])\n\n//create 2 tables\npt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\npt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\nbackupDB(backupDir, dbName)\n\nrestoreDB(backupDir, dbName)\n```\n\n| dbName          | tableName |\n| --------------- | --------- |\n| dfs\\://compoDB2 | pt1       |\n| dfs\\://compoDB2 | pt2       |\n\nRelated functions: [restore](https://docs.dolphindb.com/en/Functions/r/restore.html), [restoreTable](https://docs.dolphindb.com/en/Functions/r/restoreTable.html), [migrate](https://docs.dolphindb.com/en/Functions/m/migrate.html), [backup](https://docs.dolphindb.com/en/Functions/b/backup.html), [backupDB](https://docs.dolphindb.com/en/Functions/b/backupDB.html), [backupTable](https://docs.dolphindb.com/en/Functions/b/backupTable.html)\n"
    },
    "restoreDislocatedTablet": {
        "url": "https://docs.dolphindb.com/en/Functions/r/restoreDislocatedTablet.html",
        "signatures": [
            {
                "full": "restoreDislocatedTablet()",
                "name": "restoreDislocatedTablet",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [restoreDislocatedTablet](https://docs.dolphindb.com/en/Functions/r/restoreDislocatedTablet.html)\n\n\n\n#### Syntax\n\nrestoreDislocatedTablet()\n\n#### Arguments\n\nNone\n\n#### Details\n\nWhen *enableChunkGranularityConfig*=false (see details in [StandaloneMode](https://docs.dolphindb.com/en/Database/Configuration/StandaloneMode.html) *enableChunkGranularityConfig*) all tables in the same partition are distributed in the same node.\n\nWhen rebalancing data by function [rebalanceChunksAmongDataNodes](https://docs.dolphindb.com/en/Functions/r/rebalanceChunksAmongDataNodes.html), if the node is down, some tables in the same partition may fail to relocate, i.e., different tables under the same partition will be distributed in different nodes. Execute the function to move all tables under the same partition to one node.\n\nReturn a table containing the following columns:\n\n| name     | meaning                   |\n| -------- | ------------------------- |\n| chunkId  | the chunk ID              |\n| srcNode  | alias of source node      |\n| destNode | alias of destination node |\n\nThis function can only be executed on the controller.\n\nYou can get the status of recovery tasks by [getRecoveryTaskStatus](https://docs.dolphindb.com/en/Functions/g/getRecoveryTaskStatus.html) on a controller.\n\n#### Examples\n\n```\nrestoreDislocatedTablet()\n```\n\n| ChunkId                              | srcNode | destNode |\n| ------------------------------------ | ------- | -------- |\n| 99279094-ca12-3b87-48b6-520cbb986f39 | node1   | node2    |\n| 45f612b8-42f5-aebd-4cef-e522b6ae1fc8 | node1   | node2    |\n"
    },
    "restoreSettings": {
        "url": "https://docs.dolphindb.com/en/Functions/r/restoreSettings.html",
        "signatures": [
            {
                "full": "restoreSettings(fileName, [overwrite=false])",
                "name": "restoreSettings",
                "parameters": [
                    {
                        "full": "fileName",
                        "name": "fileName"
                    },
                    {
                        "full": "[overwrite=false]",
                        "name": "overwrite",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [restoreSettings](https://docs.dolphindb.com/en/Functions/r/restoreSettings.html)\n\n#### Syntax\n\nrestoreSettings(fileName, \\[overwrite=false])\n\n#### Arguments\n\n**fileName**is a STRING scalar specifying the backup file path. It can be an absolute path or relative path to *\\<HomeDir>*.\n\n**overwrite**(optional) is a Boolean scalar indicating whether to overwrite the current settings with the backup setting files.\n\n* false (default): Not to overwrite the current settings. Only new users (along with permissions) and function views are added.\n\n* true: Delete current settings and overwrite with the backup files.\n\n#### Details\n\nRestore settings on users, permissions, and function views with files backed up with `backupSettings` to the current cluster.\n\nThis function can only be executed by an administrator on the controller. It can be used with `backupSettings` to back up and restore user settings when migrating databases.\n\n**Return value**: A vector containing all restored user names and function views.\n\n#### Examples\n\nFor a cluster with user A and B, restore permission settings on user A and C.\n\nWhen *overwrite*=false, add user C and its permission to the cluster:\n\n```\nrestoreSettings(fileName=\"/home/ddb/backup/permission.back\", overwrite=false)\n```\n\nWhen *overwrite*=true, overwrite the user settings in the cluster:\n\n```\nrestoreSettings(fileName=\"/home/ddb/backup/permission.back\", overwrite=true)\n```\n\n**Related function**: [backupSettings](https://docs.dolphindb.com/en/Functions/b/backupSettings.html)\n\n"
    },
    "restoreTable": {
        "url": "https://docs.dolphindb.com/en/Functions/r/restoreTable.html",
        "signatures": [
            {
                "full": "restoreTable(backupDir, dbPath, tableName, [newDBPath], [newTableName])",
                "name": "restoreTable",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[newDBPath]",
                        "name": "newDBPath",
                        "optional": true
                    },
                    {
                        "full": "[newTableName]",
                        "name": "newTableName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [restoreTable](https://docs.dolphindb.com/en/Functions/r/restoreTable.html)\n\n\n\n#### Syntax\n\nrestoreTable(backupDir, dbPath, tableName, \\[newDBPath], \\[newTableName])\n\n#### Arguments\n\n**backupDir** is a string indicating the directory to save the backup.\n\n**dbPath** is a string indicating the database path.\n\n**tableName** is a string indicating the table name.\n\n**newDBPath** (optional) is a string indicating the new database name. The default value is *dbPath*.\n\n**newTableName** (optional) is a string indicating the new table name. The default value is *tableName*.\n\n#### Details\n\nRestore the backup database. Return a table where each row is the restored database and table name. The function is equivalent to `restore(backupDir, dbPath, tableName, force=false, parallel=true, snapshot=true)`.\n\nSimilar to function [migrate](https://docs.dolphindb.com/en/Functions/m/migrate.html), the function can restore all tables of a database, and the difference lies in:\n\n* `migrate` can restore all databases and tables under a directory, while `restoreTable` can only restore a table.\n\n* When the names of restored database and tables are the same as the originals, the original database and tables must be deleted before calling `migrate`, which is not required by function `restoreTable`.\n\nNote:\n\n* This function can only restore a database backed up by copying files (when dbPath is specified for function backup).\n\n* Make sure that the storage engine of the backed-up database is the same as the engine of *newDBPath*, and the partitionScheme (except for VALUE) must be the same. For a VALUE partitioned database, the partitioning scheme of the backup database must be a subset of that of the database to be restored.\n\n#### Examples\n\n```\ndbName = \"dfs://compoDB2\"\nn=1000\nID=rand(\"a\"+string(1..10), n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10, n)\nt=table(ID, date, x)\ndb1 = database(, VALUE, 2017.08.07..2017.08.11)\ndb2 = database(, HASH,[INT, 20])\nif(existsDatabase(dbName)){\n     dropDatabase(dbName)\n}\ndb = database(dbName, COMPO,[ db1,db2])\n\n//create 2 tables\npt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\npt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\nbackupDB(backupDir, dbName)\n\nrestoreTable(backupDir,\"dfs://compoDB2\",`pt1)\n```\n\n| dbName          | tableName |\n| --------------- | --------- |\n| dfs\\://compoDB2 | pt1       |\n\nRelated functions: [restore](https://docs.dolphindb.com/en/Functions/r/restore.html), [restoreDB](https://docs.dolphindb.com/en/Functions/r/restoreDB.html), [migrate](https://docs.dolphindb.com/en/Functions/m/migrate.html), [backup](https://docs.dolphindb.com/en/Functions/b/backup.html), [backupDB](https://docs.dolphindb.com/en/Functions/b/backupDB.html), [backupTable](https://docs.dolphindb.com/en/Functions/b/backupTable.html)\n"
    },
    "resumeRecovery": {
        "url": "https://docs.dolphindb.com/en/Functions/r/resumeRecovery.html",
        "signatures": [
            {
                "full": "resumeRecovery()",
                "name": "resumeRecovery",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [resumeRecovery](https://docs.dolphindb.com/en/Functions/r/resumeRecovery.html)\n\n\n\n#### Syntax\n\nresumeRecovery()\n\n#### Arguments\n\nNone\n\n#### Details\n\nResume suspended recovery processes in \"Waiting\" status. This command can only be executed by the administrator on the controller.\n\n**Note:**\n\nFor high-availability clusters, this command must be executed on every node in the raft group.\n\nRelated command: [suspendRecovery](https://docs.dolphindb.com/en/Functions/s/suspendRecovery.html)\n"
    },
    "reverse": {
        "url": "https://docs.dolphindb.com/en/Functions/r/reverse.html",
        "signatures": [
            {
                "full": "reverse(X)",
                "name": "reverse",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [reverse](https://docs.dolphindb.com/en/Functions/r/reverse.html)\n\n\n\n#### Syntax\n\nreverse(X)\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n#### Details\n\nReturn a new vector or matrix with reverse order of the original vector or matrix.\n\n#### Examples\n\n```\nreverse `hello `world;\n// output\n[world,hello]\n\n(1..6).reverse();\n// output\n[6,5,4,3,2,1]\nx=1..6$2:3;\nx\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nreverse(x);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n"
    },
    "revoke": {
        "url": "https://docs.dolphindb.com/en/Functions/r/revoke.html",
        "signatures": [
            {
                "full": "revoke(userId|groupId,accessType,[objs])",
                "name": "revoke",
                "parameters": [
                    {
                        "full": "userId|groupId",
                        "name": "userId|groupId"
                    },
                    {
                        "full": "accessType",
                        "name": "accessType"
                    },
                    {
                        "full": "[objs]",
                        "name": "objs",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [revoke](https://docs.dolphindb.com/en/Functions/r/revoke.html)\n\n\n\n#### Syntax\n\nrevoke(userId|groupId,accessType,\\[objs])\n\n#### Arguments\n\n**userId** | **groupId** is a string indicating a user name or a group name.\n\n**accessType** is the type of privilege.\n\n**objs** is a string scalar/vector indicating the objects that the priviledges specified by *accessType* applies to.\n\nSee the privilege table in [UserAccessControl](https://docs.dolphindb.com/en/Maintenance/UserAccessControl.html) for the values that *accessType* and *objs* can take.\n\n#### Details\n\n* Revokes specified access privileges to a user or a group of users that were previously granted or denied.\n\n* Removes the memory limit that was previously set for a specific user. It includes the memory limit of a query result (when *accessType* = QUERY\\_RESULT\\_MEM\\_LIMIT) and the memory limit of a task group (when *accessType* = TASK\\_GROUP\\_MEM\\_LIMIT). The memory limit will be reverted to the default memory limit configured in the system.\n\nAdministrators can grant users all privileges (*accessType*) through this command, but regular users, after having the relevant OWNER privileges, can only grant the following privileges through this command: TABLE\\_READ, TABLE\\_WRITE, TABLE\\_INSERT, TABLE\\_UPDATE, TABLE\\_DELETE, DB\\_READ, DB\\_WRITE, DB\\_INSERT, DB\\_UPDATE, DB\\_DELETE, DBOBJ\\_DELETE, DBOBJ\\_CREATE and VIEW\\_EXEC.\n\n#### Examples\n\nRevoke the privilege of the members of the group \"production\" to read all tables in all databases:\n\n```\nrevoke(`production, TABLE_READ, \"*\")\n```\n\nRevoke the denial of the privilege of the members of the group \"research\" to write to the table dfs\\://db1/t1:\n\n```\nrevoke(`research, TABLE_WRITE, \"dfs://db1/t1\")\n```\n\nRevoke the privilege of the members of the group \"research\" to create tables in the databases dfs\\://db1 and dfs\\://db2:\n\n```\nrevoke(\"research\", DBOBJ_CREATE, [\"dfs://db1\",\"dfs://db2\"])\n```\n\nRevoke the denial of the privilege of the user \"AlexSmith\" to create or delete databases:\n\n```\nrevoke(\"AlexSmith\", DB_MANAGE)\n```\n\nRevoke the privilege of the user \"AlexSmith\" to execute script:\n\n```\nrevoke(\"AlexSmith\", SCRIPT_EXEC)\n```\n\nRevoke the denial of the privilege of the user \"AlexSmith\" to test script:\n\n```\nrevoke(\"AlexSmith\", TEST_EXEC)\n```\n"
    },
    "ridge": {
        "url": "https://docs.dolphindb.com/en/Functions/r/ridge.html",
        "signatures": [
            {
                "full": "ridge(ds, yColName, xColNames, [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [solver='svd'], [swColName])",
                "name": "ridge",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alpha=1.0]",
                        "name": "alpha",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[solver='svd']",
                        "name": "solver",
                        "optional": true,
                        "default": "'svd'"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ridge](https://docs.dolphindb.com/en/Functions/r/ridge.html)\n\n\n\n#### Syntax\n\nridge(ds, yColName, xColNames, \\[alpha=1.0], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[solver='svd'], \\[swColName])\n\n#### Arguments\n\n**ds** is an in-memory table, or a data source, or a list of data sources.\n\n**yColName** is a string indicating the column name of the dependent variable in ds.\n\n**xColNames** is a string scalar/vector indicating the column names of the independent variables in ds.\n\n**alpha** (optional) is a floating number representing the constant that multiplies the L1-norm. The default value is 1.0.\n\n**intercept** (optional) is a Boolean value indicating whether to include the intercept in the regression. The default value is true.\n\n**normalize** (optional) is a Boolean value. If true, the regressors will be normalized before regression by subtracting the mean and dividing by the L2-norm. If *intercept*=false, this parameter will be ignored. The default value is false.\n\n**maxIter** (optional) is a positive integer indicating the maximum number of iterations. The default value is 1000.\n\n**tolerance** (optional) is a floating number. The iterations stop when the improvement in the objective function value is smaller than tolerance. The default value is 0.0001.\n\n**solver** (optional) is a string indicating the solver to use in the computation. It can be either 'svd' or 'cholesky'. It ds is a list of data sources, solver must be 'cholesky'.\n\n**swColName** (optional) is a STRING indicating a column name of *ds*. The specified column is used as the sample weight. If it is not specified, the sample weight is treated as 1.\n\n#### Details\n\nLinear least squares with l2 regularization.\n\nMinimize the following objective function:\n\n![](https://docs.dolphindb.com/en/images/ridge.png)\n\n#### Examples\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288]\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599]\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219]\nt = table(y, x0, x1);\n\nridge(t, `y, `x0`x1);\n```\n\nIf t is a DFS table, then the input should be a data source:\n\n```\nridge(sqlDS(<select * from t>), `y, `x0`x1);\n```\n"
    },
    "ridgeBasic": {
        "url": "https://docs.dolphindb.com/en/Functions/r/ridgebasic.html",
        "signatures": [
            {
                "full": "ridgeBasic(Y, X, [mode=0], [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [solver='svd'], [swColName])",
                "name": "ridgeBasic",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[alpha=1.0]",
                        "name": "alpha",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[solver='svd']",
                        "name": "solver",
                        "optional": true,
                        "default": "'svd'"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ridgeBasic](https://docs.dolphindb.com/en/Functions/r/ridgebasic.html)\n\n\n\n#### Syntax\n\nridgeBasic(Y, X, \\[mode=0], \\[alpha=1.0], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[solver='svd'], \\[swColName])\n\n#### Details\n\nPerform Ridge regression.\n\nMinimize the following objective function:\n\n![image-20230626-092438.png](https://docs.dolphindb.com/en/images/ridgeBasic.png)\n\n#### Arguments\n\n**Y** is a numeric vector indicating the dependent variable.\n\n**X** is a numeric vector/tuple/matrix/table indicating the independent variable.\n\n* When *X* is a vector/tuple, it must be of the same length as *Y*.\n\n* When *X* is a matrix/table, the number of rows must be the same as the length of *Y*.\n\n**mode**is an integer indicating the contents in the output. It can be:\n\n* 0 (default): a vector of the coefficient estimates.\n\n* 1: a table with coefficient estimates, standard error, t-statistics, and p-values.\n\n* 2: a dictionary with the following keys: ANOVA, RegressionStat, Coefficient, and Residual.\n\n<table id=\"table_n2f_fcz_21c\"><thead><tr><th align=\"left\">\n\nSource of Variance\n\n</th><th align=\"left\">\n\nDF (degree of freedom)\n\n</th><th align=\"left\">\n\nSS (sum of square)\n\n</th><th align=\"left\">\n\nMS (mean of square)\n\n</th><th align=\"left\">\n\nF (F-score)\n\n</th><th align=\"left\">\n\nSignificance\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\nRegression\n\n</td><td align=\"left\">\n\np\n\n</td><td align=\"left\">\n\nsum of squares regression, SSR\n\n</td><td align=\"left\">\n\nregression mean square, MSR=SSR/R\n\n</td><td align=\"left\">\n\nMSR/MSE\n\n</td><td align=\"left\">\n\np-value\n\n</td></tr><tr><td align=\"left\">\n\nResidual\n\n</td><td align=\"left\">\n\nn-p-1\n\n</td><td align=\"left\">\n\nsum of squares error, SSE\n\n</td><td align=\"left\">\n\nmean square error, MSE=MSE/E\n\n</td><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td></tr><tr><td align=\"left\">\n\nTotal\n\n</td><td align=\"left\">\n\nn-1\n\n</td><td align=\"left\">\n\nsum of squares total, SST\n\n</td><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td></tr></tbody>\n</table><table id=\"table_u2f_fcz_21c\"><thead><tr><th align=\"left\">\n\nItem\n\n</th><th align=\"left\">\n\nDescription\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\nR2\n\n</td><td align=\"left\">\n\nR-squared\n\n</td></tr><tr><td align=\"left\">\n\nAdjustedR2\n\n</td><td align=\"left\">\n\nThe adjusted R-squared corrected based on the degrees of freedom by comparing the sample size to the number of terms in the regression model.\n\n</td></tr><tr><td align=\"left\">\n\nStdError\n\n</td><td align=\"left\">\n\nThe residual standard error/deviation corrected based on the degrees of freedom.\n\n</td></tr><tr><td align=\"left\">\n\nObservations\n\n</td><td align=\"left\">\n\nThe sample size.\n\n</td></tr></tbody>\n</table><table id=\"table_x2f_fcz_21c\"><thead><tr><th align=\"left\">\n\nItem\n\n</th><th align=\"left\">\n\nDescription\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\nfactor\n\n</td><td align=\"left\">\n\nIndependent variables\n\n</td></tr><tr><td align=\"left\">\n\nbeta\n\n</td><td align=\"left\">\n\nEstimated regression coefficients\n\n</td></tr><tr><td align=\"left\">\n\nStdError\n\n</td><td align=\"left\">\n\nStandard error of the regression coefficients\n\n</td></tr><tr><td align=\"left\">\n\ntstat\n\n</td><td align=\"left\">\n\nt statistic, indicating the significance of the regression coefficients\n\n</td></tr></tbody>\n</table>Residual: the difference between each predicted value and the actual value.\n\n**alpha**(optional) is a floating number representing the constant that multiplies the L1-norm. The default value is 1.0.\n\n**intercept** (optional) is a Boolean value indicating whether to include the intercept in the regression. The default value is true.\n\n**normalize** (optional) is a Boolean value. If true, the regressors will be normalized before regression by subtracting the mean and dividing by the L2-norm. If *intercept*=false, this parameter will be ignored. The default value is false.\n\n**maxIter** (optional) is a positive integer indicating the maximum number of iterations. The default value is 1000.\n\n**tolerance** (optional) is a floating number. The iterations stop when the improvement in the objective function value is smaller than tolerance. The default value is 0.0001.\n\n**solver** (optional) is a string indicating the solver to use in the computation. It can be either 'svd' or 'cholesky'. It ds is a list of data sources, solver must be 'cholesky'.\n\n**swColName** (optional) is a STRING indicating a column name of *ds*. The specified column is used as the sample weight. If it is not specified, the sample weight is treated as 1.\n"
    },
    "ridgeCV": {
        "url": "https://docs.dolphindb.com/en/Functions/r/ridgecv.html",
        "signatures": [
            {
                "full": "ridgeCV(ds, yColName, xColNames, [alphas], [intercept], [normalize], [maxIter], [tolerance], [solver], [swColName])",
                "name": "ridgeCV",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alphas]",
                        "name": "alphas",
                        "optional": true
                    },
                    {
                        "full": "[intercept]",
                        "name": "intercept",
                        "optional": true
                    },
                    {
                        "full": "[normalize]",
                        "name": "normalize",
                        "optional": true
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[tolerance]",
                        "name": "tolerance",
                        "optional": true
                    },
                    {
                        "full": "[solver]",
                        "name": "solver",
                        "optional": true
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ridgeCV](https://docs.dolphindb.com/en/Functions/r/ridgecv.html)\n\n\n\n#### Syntax\n\nridgeCV(ds, yColName, xColNames, \\[alphas], \\[intercept], \\[normalize], \\[maxIter], \\[tolerance], \\[solver], \\[swColName])\n\n#### Arguments\n\nThe `ridgeCV` function inherits all parameters of function [ridge](https://docs.dolphindb.com/en/Functions/r/ridge.html), with one added parameter, *alphas*.\n\n**alphas**(optional) is a floating-point scalar or vector that represents the coefficient multiplied by the L1 norm penalty term. The default value is \\[0.01, 0.1, 1.0].\n\n#### Details\n\nPerform ridge regression using 5-fold cross-validation and return a model corresponding to the optimal parameters.\n\n**Return value**: A dictionary containing the following keys\n\n* modelName: the model name, which is \"ridgeCV\" for this method\n\n* coefficients: the regression coefficients\n\n* intercept: the intercept\n\n* xColNames: the column names of the independent variables in the data source\n\n* predict: the function used for prediction\n\n* alpha: the penalty term for cross-validation\n\n#### Examples\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288]\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599]\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219]\nt = table(y, x0, x1);\n\nridgeCV(t, `y, `x0`x1);\n\n// output\ncoefficients->[94.3410,14.2523]\npredict->coordinateDescentPredict\nmodelName->ridgeCV\nxColNames->[x0,x1]\nintercept->0.1063\nalpha->0.0100\n```\n"
    },
    "right": {
        "url": "https://docs.dolphindb.com/en/Functions/r/right.html",
        "signatures": [
            {
                "full": "right(X, n)",
                "name": "right",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [right](https://docs.dolphindb.com/en/Functions/r/right.html)\n\n\n\n#### Syntax\n\nright(X, n)\n\n#### Arguments\n\n**X** is a string scalar or vector.\n\n**n** is a positive integer.\n\n#### Details\n\nReturn the last *n* characters of string *X*.\n\n#### Examples\n\n```\nright(\"I love this game!\", 6);\n\n\ngame!\n```\n"
    },
    "rm": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rm.html",
        "signatures": [
            {
                "full": "rm(filename)",
                "name": "rm",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    }
                ]
            }
        ],
        "markdown": "### [rm](https://docs.dolphindb.com/en/Functions/r/rm.html)\n\n\n\n#### Syntax\n\nrm(filename)\n\n#### Arguments\n\n**filename** is the path and name of the file to be deleted.\n\n#### Details\n\nDelete a file specified by path and name. It must be executed by a logged-in user.\n\n#### Examples\n\n```\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| abc.txt  | 0     | 15       | 1496650187443 | 1496647459999 |\n| dir1     | 1     | 0        | 1496650004836 | 1496650004836 |\n| dir2     | 1     | 0        | 1496650002210 | 1496650002210 |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n\n```\nrm(\"/home/test/abc.txt\");\n// delete file abc.txt\n```\n\n```\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| dir1     | 1     | 0        | 1496650004836 | 1496650004836 |\n| dir2     | 1     | 0        | 1496650002210 | 1496650002210 |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n"
    },
    "rmdir": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rmdir.html",
        "signatures": [
            {
                "full": "rmdir(dir, [recursive=false], [keepRootDir=false])",
                "name": "rmdir",
                "parameters": [
                    {
                        "full": "dir",
                        "name": "dir"
                    },
                    {
                        "full": "[recursive=false]",
                        "name": "recursive",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keepRootDir=false]",
                        "name": "keepRootDir",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [rmdir](https://docs.dolphindb.com/en/Functions/r/rmdir.html)\n\n\n\n#### Syntax\n\nrmdir(dir, \\[recursive=false], \\[keepRootDir=false])\n\n#### Arguments\n\n**directory** is the the path of the directory to be deleted.\n\n**recursive** (optional) specifies whether to delete a non-empty directory. The default value is false.\n\n**keepRootDir** (optional) is a Boolean value that specifies whether to keep the root directory. The default value is false. When it is set to true, only subdirectories and files are deleted.\n\n**Note:** If *keepRootDir*is set to true, then *recursive*must be set to true.\n\n#### Details\n\nrmdir(directory): delete an empty directory.\n\nrmdir(directory, true): delete a non-empty directory.\n\nIt must be executed by a logged-in user.\n\n#### Examples\n\n```\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| dir1     | 1     | 0        | 1496650004836 | 1496650004836 |\n| dir2     | 1     | 0        | 1496650002210 | 1496650002210 |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n\n```\n// delete a directory. dir1 is empty, dir2 is not empty.\nrmdir(\"/home/test/dir1\");\nrmdir(\"/home/test/dir2\");\n\nFailed to remove directory [/home/test/dir2] with error code 145\n\n// Delete a directory recursively\nrmdir(\"/home/test/dir2\", true);\n\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n"
    },
    "rollingPanel": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rollingPanel.html",
        "signatures": [
            {
                "full": "rollingPanel(X, window, [groupingCol])",
                "name": "rollingPanel",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[groupingCol]",
                        "name": "groupingCol",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rollingPanel](https://docs.dolphindb.com/en/Functions/r/rollingPanel.html)\n\n\n\n#### Syntax\n\nrollingPanel(X, window, \\[groupingCol])\n\n#### Arguments\n\n**X** is a table.\n\n**window** is a positive integer indicating the length of the moving windows.\n\n**groupingCol** (optional) is a string scalar/vector indicating one or some columns in table *X*.\n\n#### Details\n\nExtract a fixed number of rows from a table with a rolling window to generate a new table. The rolling window moves by 1 row each time until it reaches the bottom of the table.\n\nIf *groupingCol* is specified, perform the aforementioned operation in each group.\n\nThe panelNumber column in the result means the index of each extraction operation, which starts from 0.\n\n#### Examples\n\n```\nt=table(1 1 1 1 1 2 2 2 2 2 as id, 1..10 as x);\nrollingPanel(t, 3, `id);\n```\n\n| id | x  | panelNumber |\n| -- | -- | ----------- |\n| 1  | 1  | 0           |\n| 1  | 2  | 0           |\n| 1  | 3  | 0           |\n| 1  | 2  | 1           |\n| 1  | 3  | 1           |\n| 1  | 4  | 1           |\n| 1  | 3  | 2           |\n| 1  | 4  | 2           |\n| 1  | 5  | 2           |\n| 2  | 6  | 3           |\n| 2  | 7  | 3           |\n| 2  | 8  | 3           |\n| 2  | 7  | 4           |\n| 2  | 8  | 4           |\n| 2  | 9  | 4           |\n| 2  | 8  | 5           |\n| 2  | 9  | 5           |\n| 2  | 10 | 5           |\n"
    },
    "round": {
        "url": "https://docs.dolphindb.com/en/Functions/r/round.html",
        "signatures": [
            {
                "full": "round(X, [precision])",
                "name": "round",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[precision]",
                        "name": "precision",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [round](https://docs.dolphindb.com/en/Functions/r/round.html)\n\n\n\n#### Syntax\n\nround(X, \\[precision])\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n**precision** (optional) is an integer indicating the number of digits (up to 10) after the decimal point. The default value is 0.\n\n#### Details\n\nRound a number to the specified number of digits after the decimal point with the round half up rule.\n\nIn comparison, functions [floor](https://docs.dolphindb.com/en/Functions/f/floor.html) and [ceil](https://docs.dolphindb.com/en/Functions/c/ceil.html) map a number to the largest previous or the smallest following integer, respectively.\n\n#### Examples\n\n```\nround 2.1;\n// output: 2\n\nround 2.9;\n// output: 3\n\nround -2.1;\n// output: -2\n\nround(2.154,2);\n// output: 2.15\n\nround(2.156,2);\n// output: 2.16\n\nceil 2.1;\n// output: 3\n\nceil 2.9;\n// output: 3\n\nceil -2.1;\n// output: -2\n\nfloor 2.1;\n// output: 2\n\nfloor 2.9;\n// output: 2\n\nfloor -2.1;\n// output: -3\n\nm = 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9 10$2:5;\nm;\n```\n\n| #0  | #1  | #2  | #3  | #4  |\n| --- | --- | --- | --- | --- |\n| 1.1 | 3.3 | 5.5 | 7.7 | 9.9 |\n| 2.2 | 4.4 | 6.6 | 8.8 | 10  |\n\n```\nround m;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 6  | 8  | 10 |\n| 2  | 4  | 7  | 9  | 10 |\n"
    },
    "row": {
        "url": "https://docs.dolphindb.com/en/Functions/r/row.html",
        "signatures": [
            {
                "full": "row(obj, index)",
                "name": "row",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "index",
                        "name": "index"
                    }
                ]
            }
        ],
        "markdown": "### [row](https://docs.dolphindb.com/en/Functions/r/row.html)\n\n\n\n#### Syntax\n\nrow(obj, index)\n\n#### Arguments\n\n**obj** is a vector/matrix/table.\n\n**index** is an integral scalar or pair.\n\n#### Details\n\nReturn a row of a vector/matrix/table.\n\n#### Examples\n\n```\nx=matrix(1 2 3, 4 5 6);\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nrow(x,1);\n// output\n[2,5]\n\nrow(x,0);\n// output\n[1,4]\n\nx.row(2);\n// output\n[3,6]\n\na=table(1..3 as x,`IBM`C`AAPL as y);\na\n```\n\n| x | y    |\n| - | ---- |\n| 1 | IBM  |\n| 2 | C    |\n| 3 | AAPL |\n\n```\nrow(a,1);\n// output\ny->C\nx->2\n```\n\nRelated function: [col](https://docs.dolphindb.com/en/Functions/c/col.html)\n"
    },
    "rowAlign": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowAlign.html",
        "signatures": [
            {
                "full": "rowAlign(left, right, how)",
                "name": "rowAlign",
                "parameters": [
                    {
                        "full": "left",
                        "name": "left"
                    },
                    {
                        "full": "right",
                        "name": "right"
                    },
                    {
                        "full": "how",
                        "name": "how"
                    }
                ]
            }
        ],
        "markdown": "### [rowAlign](https://docs.dolphindb.com/en/Functions/r/rowAlign.html)\n\n#### Syntax\n\nrowAlign(left, right, how)\n\n#### Arguments\n\n**left**/**right** is an array vector or a columnar tuple.\n\n* *left* and *right* must be of the same data type and size (number of rows), but the number of elements in corresponding rows do not have to match. For example, if *left* has 3 rows and the first row has 5 elements, then *right* must also have 3 rows but the first row does not necessarily have 5 elements.\n\n* Data in each row of *left* and *right* must be strictly increasing/decreasing.\n\n**how** is a string indicating how *left* and *right* will be aligned. It can take the following values:\n\n| *how* (case-insensitive) | Description                                                                                                                                                     | Max. Value in the Alignment Result | Min. Value in the Alignment Result |\n| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------- | ---------------------------------- |\n| \"bid\"                    | *left* and *right* are bid prices sorted in strictly decreasing order. The output will only include the indices of prices that fall within the alignment range. | max(max(left), max(right))         | max(min(left), min(right))         |\n| \"allBid\"                 | *left* and *right* are bid prices sorted in strictly decreasing order. The output will include the indices of all prices from *left*and *right*.                | max(max(left), max(right))         | min(min(left), min(right))         |\n| \"ask\"                    | *left* and *right* are ask prices sorted in strictly increasing order. The output will only include the indices of prices that fall within the alignment range. | min(max(left), max(right))         | min(min(left), min(right))         |\n| \"allAsk\"                 | *left* and *right* are ask prices sorted in strictly increasing order. The output will include the indices of all prices from *left*and *right*.                | max(max(left), max(right))         | min(min(left), min(right))         |\n\n#### Details\n\nThe `rowAlign` function aligns corresponding rows from *left* and *right*based on their values. It returns a tuple containing two elements (either array vectors or columnar tuples, matching the input type). Each element in this tuple contains indices that map the aligned elements to their original positions in *left*and *right* respectively. Unmatched elements from one input are marked as -1 in the other input's returned index.\n\nThis function is typically used for aligning bid/ask prices, where *left* represents prices from one time point and *right* represents prices from a previous time point. The returned indices can be used with the `rowAt` function to extract the aligned elements from the original *left* and *right* arrays, with any unaligned elements left blank.\n\nThe alignment process for each row is illustrated in the accompanying images, where blue blocks indicate the elements not included in the output when using the \"bid\" or \"ask\" method.\n\n* *how* = \"bid\" or \"allBid\"\n\n  ![](https://docs.dolphindb.com/en/images/rowAlign_1.png)\n\n* *how* = \"ask\" or \"allAsk\":\n\n  ![](https://docs.dolphindb.com/en/images/rowAlign_2.png)\n\n#### Examples\n\n```\nleft = array(DOUBLE[], 0, 5).append!([9.01 9.00 8.99 8.98 8.97, 9.00 8.98 8.97 8.96 8.95, 8.99 8.97 8.95 8.93 8.91])\nright = array(DOUBLE[], 0, 5).append!([9.02 9.01 9.00 8.99 8.98, 9.01 9.00 8.99 8.98 8.97, 9.00 8.98 8.97 8.96 8.95])\nleftIndex, rightIndex = rowAlign(left, right, \"bid\")\nleftIndex\n// output\n[[-1,0,1,2,3],[-1,0,-1,1,2],[-1,0,-1,1,-1,2]]\n\nleft.rowAt(leftIndex)\n// output\n[[,9.01,9.00,8.99,8.98],[,9,,8.99,8.97],[,8.99,,8.97,,8.95]]\n\nrightIndex\n// output\n[[0,1,2,3,4],[0,1,2,3,4],[0,-1,1,2,3,4]]\n\nright.rowAt(rightIndex)\n// output\n[[9.02,9.01,9.00,8.99,8.98],[9.01,9.00,8.99,8.98,8.97],[9.00,,8.98,8.97,8.96,8.95]]\n\n// output all bid prices in one array vector after aligning left and right\nleft.rowAt(leftIndex).nullFill(right.rowAt(rightIndex))\n// output\n[[9.02,9.01,9,8.99,8.98],[9.01,9.00,8.99,8.98,8.97],[9.00,8.99,8.98,8.97,8.96,8.95]]\n\n// the bid sizes\nleftBidQty = array(INT[], 0, 5).append!([10 5 15 20 13, 12 15 20 21 18, 7 8 9 9 10])\nrightBidQty = array(INT[], 0, 5).append!([8 12 10 12 8, 10 5 15 18 13, 12 15 20 21 19])\n\n// calculate the difference in bid quantities between left and right \nleftBidQty.rowAt(leftIndex).nullFill(0) - rightBidQty.rowAt(rightIndex).nullFill(0)\n// output\n[[-8,-2,-5,3,12],[-10,7,-15,-3,7],[-12,7,-15,-12,-21,-10]]\n\nleftIndex, rightIndex = rowAlign(left, right, \"allBid\")\nleftIndex\n// output\n[[-1,0,1,2],[-1,-1,0,1,2],[-1,0,-1,1,2]]\n\nrightIndex\n// output\n[[0,1,2,-1],[0,1,2,-1,-1],[0,-1,1,2,-1]]\n```\n\n```\nleft = array(DOUBLE[], 0, 3).append!([8.99 9.00 9.01, 8.97 8.99 9.00, 8.95 8.97 8.99])\nright = array(DOUBLE[], 0, 3).append!([9.00 9.01 9.02, 8.99 9.00 9.01, 8.97 8.98 9.00])\nleftIndex, rightIndex = rowAlign(left, right, \"ask\")\nleftIndex\n// output\n[[0,1,2],[0,1,2],[0,1,-1,2]]\n \nrightIndex\n// output\n[[-1,0,1],[-1,0,1],[-1,0,1,-1]]\n\nleftIndex, rightIndex = rowAlign(left, right, \"allAsk\")\nleftIndex\n// output\n[[0,1,2,-1],[0,1,2,-1],[0,1,-1,2,-1]]\n \nrightIndex\n// output\n[[-1,0,1,2],[-1,0,1,2],[-1,0,1,-1,2]]\n```\n\n```\nsym = `st1`st2`st3\nleft = [[3.1,2.5,2.8], [3.1,3.3], [3.2,2.9,3.3]]\nleft.setColumnarTuple!()\nright = [[3.1,2.5,2.8], [3.1,3.3], [3.2,2.9,3.3]]\nright.setColumnarTuple!()\nrowAlign(left, right, \"bid\")\n//output:\n[([0,1,2],[0,1],[0,1,2]), ([0,1,2],[0,1],[0,1,2])]\n```\n\n"
    },
    "rowAnd": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowAnd.html",
        "signatures": [
            {
                "full": "rowAnd(args...)",
                "name": "rowAnd",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowAnd](https://docs.dolphindb.com/en/Functions/r/rowAnd.html)\n\n\n\n#### Syntax\n\nrowAnd(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nFor each row (a vector is viewed as a one-column matrix here), return 1 if all rows of all input variables are true; otherwise return 0.\n\n#### Examples\n\n```\nm=matrix([true false false, true true true, true true true])\nrowAnd(m);\n// output\n[1,0,0]\n\nt1=table(false true true true false as x, false true false true true as y)\nrowAnd(t1);\n// output\n[0,1,0,1,0]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect *  from t where rowAnd(price1>30, price2>50);\n```\n\n| sym  | price1 | price2 |\n| ---- | ------ | ------ |\n| AAPL | 49.6   | 175.23 |\n| IBM  | 30.02  | 51.29  |\n\nRelated function: [and](https://docs.dolphindb.com/en/Functions/a/and.html)\n"
    },
    "rowAt": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowAt.html",
        "signatures": [
            {
                "full": "rowAt(X, Y)",
                "name": "rowAt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            },
            {
                "full": "rowAt(X, [Y])",
                "name": "rowAt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rowAt](https://docs.dolphindb.com/en/Functions/r/rowAt.html)\n\n\n\n#### Syntax\n\nrowAt(X, Y)\n\nrowAt(X, \\[Y])\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Arguments\n\n**X** is a matrix/array vector/columnar tuple..\n\n**Y**(optional) can be a vector of integers, a Boolean matrix, a Boolean/integral array vector or columnar tuple.\n\n#### Details\n\nRetrieve the element in each row of X based on the index specified by the corresponding element of Y. Return a vector with the same length as the number of input rows.\n\n* If *Y* is not specified, *X* must be a Boolean matrix or Boolean array vector. The `rowAt` function retrieves the row indices for each \"true\" element in *X* by row and returns an array vector (or columnar tuple) of integers. The returned result has the same number of rows as *X*. If X contains a row with only NULL or \"false\" elements, `rowAt` returns null for that row.\n\n* If *Y* is a vector of integers, then each element in *Y* indicates the column index for *X* at each row. The `rowAt` function retrieves the corresponding element at each row in *X* and returns a vector of the same size as *Y*. If no element is found at the position specified by *Y*, a NULL value is returned. When *Y* is a Boolean matrix, *X* must be a matrix.\n\n* If *Y* is a Boolean matrix or Boolean array vector (or columnar tuple), the `rowAt` function retrieves the elements in *X* that correspond to the \"true\" values in *Y* and returns an array vector (or columnar tuple). The returned result has the same number of rows as *Y*. For any row in *Y* that contains only \"false\" elements, `rowAt` returns a NULL value in the output array vector for that row.\n\n* If *Y* is an array vector (or columnar tuple) of integers, then each row in *Y* indicates the column index for *X* at each row. The `rowAt` function retrieves the corresponding element(s) at each row in *X* and returns an array vector (or columnar tuple) of the same dimension as *Y*. If no element is found at the position specified by *Y*, a NULL value is returned.\n\n#### Examples\n\n```\nm = matrix(3.1 4.5 2.2, 4.2 4.3 5.1, 6.2 7.1 2.2, 1.8 6.1 5.3, 7.1 8.4 3.5)\nindex = 4 0 2\nrowAt(m, index)\n// output\n[7.1,4.5,2.2]\n\ntrades = table(10:0,`time`sym`p1`p2`p3`p4`p5`vol1`vol2`vol3`vol4`vol5,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,INT,INT,INT,INT,INT])\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 200, 180, 180, 220, 200)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.1, 32.8, 33.2, 34.3, 32.3, 150, 280, 190, 100, 220)\ninsert into trades values(2022.01.01T09:00:00, `A, 31.2, 32.6, 33.6, 35.3, 34.5, 220, 160, 130, 100, 110)\ninsert into trades values(2022.01.01T09:00:00, `A, 30.2, 32.5, 33.6, 35.3, 34.1, 200, 180, 150, 140, 120)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 180, 160, 160, 180, 200)\nselect rowAt(matrix(p1, p2, p3, p4, p5), rowImin(vol1, vol2, vol3, vol4, vol5)) as price1, rowAt(matrix(p1, p2, p3, p4, p5), rowImax(vol1, vol2, vol3, vol4, vol5)) as price2 from trades\n\n\n```\n\n| price1 | price2 |\n| ------ | ------ |\n| 33.8   | 33.3   |\n| 34.3   | 32.8   |\n| 35.3   | 31.2   |\n| 34.1   | 30.2   |\n| 33.8   | 33.1   |\n\n```\nindex = array(INT[], 0, 10).append!([0 1, 2 4, 3 4 5])\nrowAt(m, index)\n// output\n[[3.1,4.2],[7.1,8.4],[5.3,3.5,]]\n\nx = array(DOUBLE[], 0, 10).append!([3.3 3.6 3.8, 3.7 3.4 3.5, 3.4 3.4 3.5])\nindex = array(INT[], 0, 10).append!([0 1, 2, 0 2])\nrowAt(x, index)\n// output\n[[3.3,3.6],[3.5],[3.4,3.5]]\n```\n\nFor version 2.00.10.2 and later, when *X* is a Boolean matrix or array vector, *Y* can be unspecified, and `rowAt` returns the indices of elements that are true in each row.\n\n```\nm = matrix(true false false, false true false, true true false)\nR=rowAt(m)\nR\n# output\n[[0,2],[1,2],]\ntypestr(R)  \n# output\nFAST INT[] VECTOR\n\nm = matrix(3.1 4.5 2.2, 2.2 4.3 5.1, 1.2 7.1 2.2, 1.8 6.1 5.3, 1 4 3)\nrowAt(m, m>4)\n# output\n[,[4.5,4.3,7.1,6.1],[5.1,5.3]]\n\nx = array(DOUBLE[], 0, 10).append!([3.3 3.6 3.8, 3.7 3.4 3.5, 3.4 3.4 3.5])\nrowAt(x, x>3.5)\n# output\n[[3.6,3.8],[3.7],]\n```\n\nUse `rowAt` on a columnar tuple and an array vector:\n\n```\nx = ([1, 2, 3], [4, 5, 6]).setColumnarTuple!()\ny = fixedLengthArrayVector([1, 4], [2, 5], [3, 6])\n\nrowAt(x, x > 1)        \n// output\n([2,3],[4,5,6])\n\nrowAt(y, y>1)           \n// output\n[[2,3],[4,5,6]]\n```\n\nRelated functions: [at](https://docs.dolphindb.com/en/Functions/a/at.html)\n"
    },
    "rowAvg": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowAvg.html",
        "signatures": [
            {
                "full": "rowAvg(args...)",
                "name": "rowAvg",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowAvg](https://docs.dolphindb.com/en/Functions/r/rowAvg.html)\n\n\n\n#### Syntax\n\nrowAvg(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the average of each row of the arguments. A vector is viewed as a one-column matrix here.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowAvg(m);\n// output\n[3.633333,3.133333,3.7]\n\nt1=table(1..5 as x, 6..10 as y)\nt2=table(5..1 as a, 10..6 as b);\nrowAvg(t1);\n// output\n[3.5,4.5,5.5,6.5,7.5]\n\nrowAvg(t1[`x], t2, take(1, 5));\n// output\n[4.25,4,3.75,3.5,3.25]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect sym,rowAvg(price1,price2) as avg from t;\n```\n\n| sym  | price1  |\n| ---- | ------- |\n| AAPL | 112.415 |\n| MS   | 40.11   |\n| IBM  | 39.92   |\n| IBM  | 40.655  |\n| C    | 100.6   |\n\nRelated function: [avg](https://docs.dolphindb.com/en/Functions/a/avg.html)\n"
    },
    "rowBeta": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowBeta.html",
        "signatures": [
            {
                "full": "rowBeta(Y, X)",
                "name": "rowBeta",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowBeta](https://docs.dolphindb.com/en/Functions/r/rowBeta.html)\n\n\n\n#### Syntax\n\nrowBeta(Y, X)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the coefficient estimate of the ordinary-least-squares regression of *Y* on *X* by row and return a vector with the same number of rows of *X*.\n\n#### Examples\n\n```\nm1=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nm2=matrix(49.6 NULL 29.52, 50.32 51.29 26.23, NULL 74.97 23.75)\nrowBeta(m1, m2)\n// output\n[-4.1667,-0.1182, -1.3374]\n\nm3=matrix(8 NULL 10, 8 NULL 4, 14 NULL NULL)\nrowBeta(m3, m2)\n// output\n[0, , 1.8237]\n\na= 110 112.3 44 98\nb= 57.9 39 75 90\nc= 55 64 37 78\nx=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[a, b, c\\]\\)\ny=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[b, a, c\\]\\)\nrowBeta\\(x, y\\)\n// output\n\\[0.6783, 1 , -0.3202, 1\\]\n```\n\nRelated function: [beta](https://docs.dolphindb.com/en/Functions/b/beta.html)\n"
    },
    "rowCorr": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowCorr.html",
        "signatures": [
            {
                "full": "rowCorr(X, Y)",
                "name": "rowCorr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowCorr](https://docs.dolphindb.com/en/Functions/r/rowCorr.html)\n\n\n\n#### Syntax\n\nrowCorr(X, Y)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the correlation between *X* and *Y* by row and return a vector with the same number of rows of *X*. NULL values are ignored in calculation.\n\n#### Examples\n\n```\nm1=matrix(2 -1 4, 8 3 2, 9 0 1)\nm2=matrix(8 11 10, 8 17 4, 14 6 4)\nrowCorr(m1, m2)\n// output\n[0.61, 0.7559, 0.9449]\n\nm3=matrix(8 NULL 10, 8 NULL 4, 14 NULL NULL)\nrowCorr(m1, m3)\n// output\n[0.61, , 1]\n\na=array\\(DOUBLE\\[\\], 0, 10\\).append!\\(\\[1 2 3, 4 NULL 5, 6 7 8, NULL 3 10\\]\\);\nb=array\\(DOUBLE\\[\\], 0, 10\\).append!\\(\\[\\[1.3,1.2, 4\\], \\[1.0,1.4, 2\\], \\[1.1, 1.4, 3\\],\\[1, 4, 7\\]\\]\\);\n\nrowBeta\\(a, b\\)\n// output\n\\[0.535, 1 , 0.9105, 2.3333\\]\n```\n\nRelated function: [corr](https://docs.dolphindb.com/en/Functions/c/corr.html)\n"
    },
    "rowCount": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowCount.html",
        "signatures": [
            {
                "full": "rowCount(args...)",
                "name": "rowCount",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowCount](https://docs.dolphindb.com/en/Functions/r/rowCount.html)\n\n\n\n#### Syntax\n\nrowCount(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nReturn the number of non-null elements in each row of the arguments.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]);\nrowCount(m);\n// output\n[3,3,2]\n\nt1=table(1 NULL 3 NULL 5 as x, 6..10 as y);\nt2=table(5 NULL 3 NULL 1 as a, 10..6 as b);\nrowCount(t1);\n\n2,1,2,1,2]\n\nrowCount(t1[`x], t2, 1 NULL 2 NULL NULL);\n// output\n[4,1,4,1,3]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, [49.6, NULL, 29.52, NULL, 174.97] as price1, [175.23, NULL, 50.32, 51.29, 26.23] as price2);\nselect sym,rowCount(price1,price2) as count from t;\n```\n\n| sym  | count |\n| ---- | ----- |\n| AAPL | 2     |\n| MS   | 0     |\n| IBM  | 2     |\n| IBM  | 1     |\n| C    | 2     |\n\nRelated function: [rowSize](https://docs.dolphindb.com/en/Functions/r/rowSize.html), [count](https://docs.dolphindb.com/en/Functions/c/count.html)\n"
    },
    "rowCovar": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowCovar.html",
        "signatures": [
            {
                "full": "rowCovar(X, Y)",
                "name": "rowCovar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowCovar](https://docs.dolphindb.com/en/Functions/r/rowCovar.html)\n\n\n\n#### Syntax\n\nrowCovar(X, Y)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the covariance between *X* and *Y* by row and return a vector with the same number of rows of *X*.\n\n#### Examples\n\n```\nm1=matrix(2 8 9 12, 9 14 11 8,-3 NULL NULL 9)\nm2=matrix(11.2 3 5 9, 7 -10 8 5,17 12 18 9)\nrowCovar(m1, m2)\n// output\n[-29.7333, -39, 3, 3.3333]\n\na= 110 112.3 44 98\nb= 57.9 39 75 90\nc= 55 64 37 78\nx=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[a, b, c\\]\\)\ny=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[b, a, c\\]\\)\n\nrowCovar\\(x, y\\)\n// output\n\\[-327.9475, -327.9475, 295\\]\n```\n\n```\n//Define a random data set x\n\nx = rand(1.0, 1000000)\n\n//calculate the covariance between x and sorted x in a sliding window with a user-defined aggregate function\ntimer moving(defg(x):covar(x, sort(x)), x, 5)\n// output\n1928.888 ms\n\n//calculate with rowCovar\n\ntimer rowCovar(x[movingWindowIndex(x, 5)], x[movingTopNIndex(x, 5, 5)])\n// output\n232.407 ms\n```\n\nRelated function: [covar](https://docs.dolphindb.com/en/Functions/c/covar.html)\n"
    },
    "rowCummax": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowCummax.html",
        "signatures": [
            {
                "full": "rowCummax(X)",
                "name": "rowCummax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowCummax](https://docs.dolphindb.com/en/Functions/r/rowCummax.html)\n\n\n\n#### Syntax\n\nrowCummax(X)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\n`rowCummax` calculates the cumulative maximum values in each row of *X*.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowCummax(m)\n// output\ncol1        col2    col3\n4.5         4.5     4.9\n2.6         4.8     4.8\n1.5         5.9     5.9\n\n\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowCummax(a)\n// output\n[[1,2,3],[4,5],[6,7,8]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowCummax(tp)\n// output\n[[1.3,2.5,2.5],[4.1,5.3,6.2]]\n```\n"
    },
    "rowCummin": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowCummin.html",
        "signatures": [
            {
                "full": "rowCummax(X)",
                "name": "rowCummax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowCummin](https://docs.dolphindb.com/en/Functions/r/rowCummin.html)\n\n\n\n#### Syntax\n\nrowCummax(X)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\n`rowCummin` calculates the cumulative minimum values in each row of *X*.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowCummin(m)\n// output\ncol1        col2    col3\n4.5         1.5     1.5\n2.6         2.6     2\n1.5         1.5     1.5\n\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowCummin(a)\n// output\n[[1,1,1],[4,4],[6,6,6]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowCummin(tp)\n// output\n[[1.3,1.3,1.3],[4.1,4.1,4.1]]\n```\n"
    },
    "rowCumprod": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowCumprod.html",
        "signatures": [
            {
                "full": "rowCumprod(X)",
                "name": "rowCumprod",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowCumprod](https://docs.dolphindb.com/en/Functions/r/rowCumprod.html)\n\n\n\n#### Syntax\n\nrowCumprod(X)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\n`rowCumprod` calculates the cumulative products of the elements in each row of X.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowCumProd(m)\n// output\ncol1        col2    col3\n4.5 6.75    33.075\n2.6 12.48   24.96\n1.5 8.85    8.85\n\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowCumProd(a)\n// output\n[[1,3,6],[4,9],[6,13,21]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowCumProd(tp)\n// output\n[[1.3,3.25,7.475],[4.1,21.73,134.726]]\n```\n"
    },
    "rowCumsum": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowCumsum.html",
        "signatures": [
            {
                "full": "rowCumsum(X)",
                "name": "rowCumsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowCumsum](https://docs.dolphindb.com/en/Functions/r/rowCumsum.html)\n\n\n\n#### Syntax\n\nrowCumsum(X)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\n`rowCumsum` calculates the cumulative sum of each row of *X*.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowCumsum(m)\n// output\ncol1        col2    col3\n4.5     6       10.9\n2.6     7.4     9.4\n1.5     7.4     7.4\n\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowCumsum(a)\n// output\n[[1,3,6],[4,9],[6,13,21]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowCumsum(tp)\n// output\n[[1.3,3.8,6.1],[4.1,9.4,15.6]]\n```\n"
    },
    "rowCumwsum": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowCumwsum.html",
        "signatures": [
            {
                "full": "rowCumwsum(X, Y)",
                "name": "rowCumwsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowCumwsum](https://docs.dolphindb.com/en/Functions/r/rowCumwsum.html)\n\n\n\n#### Syntax\n\nrowCumwsum(X, Y)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\n`rowCumwsum` calculates the cumulative weighted sum in each row of *X* with *Y* as the weights.\n\n#### Examples\n\n```\nm1=matrix(2 -1 4, 8 3 2, 9 0 1)\nm2=matrix(8 11 10, 8 17 4, 14 6 4)\nrowCumwsum(m1, m2)\n// output\ncol1        col2    col3\n16          80      206\n-11         40      40\n40          48      52\n\na= -10 12.3 4 -8\nb= 17.9 9 7.5 -4\nc= 5.5 6.4 -7 8\nx=array(DOUBLE[],0, 10).append!([a, b, c])\ny=array(DOUBLE[],0, 10).append!([b, a, c])\nrowCumwsum(x, y)\n// output\n[[-179,-68.30,-38.30,-6.29],[-179,-68.30,-38.30,-6.29],[30.25,71.21,120.21,184.21]]\n\ntp1 = [[3,4,5],[4,5,6]]\ntp1.setColumnarTuple!()\n\ntp2 = [[13,41,25],[21,30,10]]\ntp2.setColumnarTuple!()\nrowCumwsum(tp1, tp2)\n// output\n[[39,203,328],[84,234,294]]\n```\n"
    },
    "rowDenseRank": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowDenseRank.html",
        "signatures": [
            {
                "full": "rowDenseRank(X, [ascending=true], [ignoreNA=true], [percent=false])",
                "name": "rowDenseRank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [rowDenseRank](https://docs.dolphindb.com/en/Functions/r/rowDenseRank.html)\n\n\n\n#### Syntax\n\nrowDenseRank(X, \\[ascending=true], \\[ignoreNA=true], \\[percent=false])\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Arguments\n\n**X** is a matrix.\n\n**ascending** (optional) is a Boolean value indicating whether to sort in ascending order. The default value is true.\n\n**ignoreNA** (optional) is a Boolean value indicating whether NULL values are ignored in ranking and return NULL. When NULL values participate in ranking, NULL values return 0, which is the smallest value in the result.\n\n**percent** (optional) is a Boolean value, indicating whether to display the returned rankings in percentile form. The default value is false.\n\n#### Details\n\n`rowDenseRank` can be viewed as function [denseRank](https://docs.dolphindb.com/en/Functions/d/denseRank.html) applied on rows instead of columns. It returns the consecutive rank of each element in each row.\n\n#### Examples\n\n```\nm = matrix(1 5 8 5 9, 2 8 2 5 2, 6 5 3 3 4)\nrowDenseRank(m)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 0    | 1    | 2    |\n| 0    | 1    | 0    |\n| 2    | 0    | 1    |\n| 1    | 1    | 0    |\n| 2    | 0    | 1    |\n\n```\ny=matrix(1 3 3, 6 5 6, NULL 0 9)\nrowDenseRank(y)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 0    |      | 1    |\n| 1    | 2    | 0    |\n| 0    | 1    | 2    |\n\n```\nrowDenseRank(y, ignoreNA=false)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 2    | 0    |\n| 1    | 2    | 0    |\n| 0    | 1    | 2    |\n\nRelated function: [denseRank](https://docs.dolphindb.com/en/Functions/d/denseRank.html), [rowRank](https://docs.dolphindb.com/en/Functions/r/rowRank.html)\n"
    },
    "rowDot": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowDot.html",
        "signatures": [
            {
                "full": "rowDot(X, Y)",
                "name": "rowDot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowDot](https://docs.dolphindb.com/en/Functions/r/rowDot.html)\n\n\n\n#### Syntax\n\nrowDot(X, Y)\n\n#### Arguments\n\n**X** and **Y** are numeric vectors/array vectors of the same length or matrices with the same dimension. If *X* and *Y* are array vectors, the vectors at the same position in *X* and *Y* must have the same length.\n\n#### Details\n\nIf both *X* and *Y* are vectors/matrices, calculate the inner product between *X* and *Y* by row. If both *X* and *Y* are indexed matrices, calculate the inner product between rows with the same label. For other rows, return NULL.\n\nFor a vector and a matrix, the length of the vector must be the same as the number of columns of the matrix. Calculate the inner product between the vector and each row of the matrix is calculated.\n\nIf *X* and *Y* are array vectors, calculate the inner product between the corresponding rows (vectors) in *X* and *Y*, i.e., dot(X.row(i),Y.row(i)).\n\nFor a vector and an array vector, calculate the inner product between the vector and each vector in the array vector. Return NULL when *X* and *Y* are of different lengths.\n\nAs with all other aggregate functions, NULL values are ignored in the calculation.\n\n#### Examples\n\n```\nrowDot(13.5 15.2 6.3, 18.6 14.8 15.5)\n// output\n[251.1,224.96,97.65]\n\ns1=indexedSeries(2020.01.01..2020.01.03, 10.4 11.2 9)\ns2=indexedSeries(2020.01.01 2020.01.03 2020.01.04, 23.5 31.2 26)\nrowDot(s1,s2)\n// output\n[244.4,349.44,234]\n\nm=matrix(23 56 47, 112 94 59)\nm1=matrix(11 15 89, 52 41 63)\nrowDot(m,m1)\n// output\n[6077,4694,7900]\n\nm.rename!(2020.01.01..2020.01.03, `A`B)\nm.setIndexedMatrix!()\nm1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\nm1.setIndexedMatrix!()\nrowDot(m,m1)\n// output\n[6077,NULL,3124,NULL]\n\na=array(DOUBLE[],0,10)\na.append!([[10.5, 11.8, 9],[15, NULL], [2.5, 2.2, 1.3, 1.5]])\nb=array(DOUBLE[],0,10)\nb.append!([[1.1, 1.8, 6],[5, 6.9], [3.5, 2, 3, 2.8]])\nrowDot(a,b)\n// output\n[86.79,75,21.25]\n```\n\nRelated function: [dot](https://docs.dolphindb.com/en/Functions/d/dot.html)\n"
    },
    "rowEuclidean": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowEuclidean.html",
        "signatures": [
            {
                "full": "rowEuclidean(X, Y)",
                "name": "rowEuclidean",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowEuclidean](https://docs.dolphindb.com/en/Functions/r/rowEuclidean.html)\n\n\n\n#### Syntax\n\nrowEuclidean(X, Y)\n\n#### Arguments\n\n**X** and **Y** are numeric vectors/array vectors of the same length or matrices with the same dimension. If *X* and *Y* are array vectors, the vectors at the same position in *X* and *Y* must have the same length.\n\n#### Details\n\nIf both *X* and *Y* are vectors/matrices, calculate the Euclidean distance between *X* and *Y* by row. If both *X* and *Y* are indexed matrices, calculate the Euclidean distance between rows with the same label. For other rows, return NULL.\n\nFor a vector and a matrix, the length of the vector must be the same as the number of columns of the matrix. Calculate the Euclidean distance between the vector and each row of the matrix is calculated.\n\nIf *X* and *Y* are array vectors, calculate the Euclidean distance between the corresponding rows (vectors) in *X* and *Y*, i.e., euclidean(X.row(i),Y.row(i)).\n\nFor a vector and an array vector, calculate the Euclidean distance between the vector and each vector in the array vector. Return NULL when *X* and *Y* are of different lengths.\n\nAs with all other aggregate functions, NULL values are ignored in the calculation.\n\n#### Examples\n\n```\nrowEuclidean(3.6 5.2 6.3, 8.6 4.8 5.5)\n// output\n[5,0.4,0.8]\n\nm=matrix(23 56 47, 112 94 59)\nm1=matrix(11 15 89, 52 41 63)\nrowEuclidean(m,m1)\n// output\n[61.1882,67.0075,42.19]\n\nm.rename!(2020.01.01..2020.01.03, `A`B)\nm.setIndexedMatrix!()\nm1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\nm1.setIndexedMatrix!()\nrowEuclidean(m,m1)\n// output\n[61.1882,NULL,36.7151,NULL]\n\na=array(INT[],0,10)\na.append!([[1, 8, 9],[15, NULL], [25, 22, 13, 15]])\nb=array(INT[],0,10)\nb.append!([[11, 18, 6],[5, 9], [5, 2, 3, 1]])\nrowEuclidean(a,b)\n// output\n[14.4568,10,33.1059]\n```\n\nRelated function: [euclidean](https://docs.dolphindb.com/en/Functions/e/euclidean.html)\n"
    },
    "rowGroupby": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowGroupby.html",
        "signatures": [
            {
                "full": "rowGroupby(func, funcArgs, groupingCol, [mode='tuple'], [ascending=true])",
                "name": "rowGroupby",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "groupingCol",
                        "name": "groupingCol"
                    },
                    {
                        "full": "[mode='tuple']",
                        "name": "mode",
                        "optional": true,
                        "default": "'tuple'"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [rowGroupby](https://docs.dolphindb.com/en/Functions/r/rowGroupby.html)\n\n\n\n#### Syntax\n\nrowGroupby(func, funcArgs, groupingCol, \\[mode='tuple'], \\[ascending=true])\n\n#### Arguments\n\n**func** is an aggregate function.\n\n**funcArgs** is the argument(s) passed to *func*. Multiple arguments can be represented in a tuple, and the dimension of each element must be consistent with *groupingCol*.\n\n**groupingCol** is a non-empty matrix or array vector indicating the grouping column(s).\n\n**mode** (optional) specifies the returned data form. It can be:\n\n* \"tuple\" (default): Return a tuple of length 2, the first element of which is an array vector that stores the grouping variables, and the second element is an array vector that stores the result of applying *funcArgs*to *func*in each group.\n\n* \"dict\": Return a dictionary with a key-value pair. 'key' stores the grouping variables and 'value' stores the result of applying *funcArgs*to *func*in each group.\n\n* \"table\": Return a table with two columns. 'key' stores the grouping variables and 'value' stores the result of applying *funcArgs*to *func*in each group.\n\n**ascending** (optional) is a Boolean value indicating whether to sort the output by *groupingCol*in ascending or descending order. The default value is true.\n\n#### Details\n\nGroup the data by *groupingCol*, then calculate `func(funcArgs)` and return a scalar for each group.\n\n**Return value**: As specified in *mode*, sorted by *groupingCol*in *ascending*order.\n\n#### Examples\n\nGroup data by price, and calculate the sum of qty for each group:\n\n```\nsym=`A`B\nprice = array(DOUBLE[], 0).append!([12.5 12.6 12.5 12.5 12.6, 15.5 15.5 15.5 15.3 15.3])\nqty = array(INT[], 0).append!([201 212 220 215 214, 210 213 223 219 211])\nt=table(sym,price,qty)\nt;\n```\n\n| sym | price                       | qty                        |\n| --- | --------------------------- | -------------------------- |\n| A   | \\[12.5 12.6 12.5 12.5 12.6] | \\[201, 212, 220, 215, 214] |\n| B   | \\[15.5 15.5 15.5 15.3 15.3] | \\[210, 213, 223, 219, 211] |\n\nSet *mode*='dict':\n\n```\nrowGroupby(func=sum,funcArgs=t.qty,groupingCol=t.price,mode='dict')\n\n/* output:\nkey->[[12.5,12.6],[15.3,15.5]]\nvalue->[[636,426],[430,646]]\n*/\n```\n\nSet *mode*='table':\n\n```\nrowGroupby(func=sum,funcArgs=t.qty,groupingCol=t.price,mode='table')\n```\n\n| key          | value      |\n| ------------ | ---------- |\n| \\[12.5,12.6] | \\[636,426] |\n| \\[15.3,15.5] | \\[430,646] |\n\nSet *mode*='tuple':\n\n```\nselect rowGroupby(sum, qty, price, 'tuple') as `a`b from t\n```\n\n| key          | value      |\n| ------------ | ---------- |\n| \\[12.5,12.6] | \\[636,426] |\n| \\[15.3,15.5] | \\[430,646] |\n\nSet *ascending*=false:\n\n```\nrowGroupby(func=sum,funcArgs=t.qty,groupingCol=t.price,mode='dict', ascending=false)\n\n/* output:\nvalue->[[426,636],[646,430]]\nkey->[[12.6000,12.5000],[15.5000,15.3000]]\n*/\n```\n\nExample 2. Apply `rowGroupby` on matrices:\n\n```\nm=matrix([32.5 12.6 22.5 42.5 32.6, 17.5 25.5 35.5 17.3 19.3, 17 20.1 30 13 19])\ng=matrix([1 2 2 5 4, 2 2 3 2 1, 1 3 2 3 5])\n// rowGroupby m with groupingCol=g\nrowGroupby(func=sum, funcArgs=m, groupingCol=g, mode='table')\n```\n\n| key      | value           |\n| -------- | --------------- |\n| \\[1,2]   | \\[49.5,17.5]    |\n| \\[2,3]   | \\[38.1,20.1]    |\n| \\[2,3]   | \\[52.5,35.5]    |\n| \\[2,3,5] | \\[17.3,13,42.5] |\n| \\[1,4,5] | \\[19.3,32.6,19] |\n"
    },
    "rowImax": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowImax.html",
        "signatures": [
            {
                "full": "rowImax(args...)",
                "name": "rowImax",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowImax](https://docs.dolphindb.com/en/Functions/r/rowImax.html)\n\n\n\n#### Syntax\n\nrowImax(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nReturn the index of the maximum in each row. If there are multiple maxima, return the index of the first maximum from the left. The result is a vector with the same length as the number of input rows.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5 3.2, 1.5 4.8 5.9 1.7, 4.9 2.0 NULL 5.5])\nprint rowImax(m)\n// output\n[2,1,1,2]\n\ntrades = table(10:0,`time`sym`p1`p2`p3`p4`p5`vol1`vol2`vol3`vol4`vol5,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,INT,INT,INT,INT,INT])\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 200, 180, 180, 220, 200)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.1, 32.8, 33.2, 34.3, 32.3, 150, 280, 190, 100, 220)\ninsert into trades values(2022.01.01T09:00:00, `A, 31.2, 32.6, 33.6, 35.3, 34.5, 220, 160, 130, 100, 110)\ninsert into trades values(2022.01.01T09:00:00, `A, 30.2, 32.5, 33.6, 35.3, 34.1, 200, 180, 150, 140, 120)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 180, 160, 160, 180, 200)\nselect rowAt(matrix(p1, p2, p3, p4, p5), rowImax(vol1, vol2, vol3, vol4, vol5)) as price from trades\n```\n\n| price |\n| ----- |\n| 33.3  |\n| 32.8  |\n| 31.2  |\n| 30.2  |\n| 33.1  |\n\nIf *args* is an array vector, return the index of the maximum in each row. The result is a vector.\n\n```\na = 1 8 3 8 1\nb = 5 8 1 3 6\nc =  9 5 4 7 6\nx = fixedLengthArrayVector(a, b, c)\nrowImax(x)\n// output\n[2,0,2,0,1]\n```\n\nRelated functions: [imax](https://docs.dolphindb.com/en/Functions/i/imax.html)\n"
    },
    "rowImaxLast": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowimaxlast.html",
        "signatures": [
            {
                "full": "rowImaxLast(args…)",
                "name": "rowImaxLast",
                "parameters": [
                    {
                        "full": "args…",
                        "name": "args…"
                    }
                ]
            }
        ],
        "markdown": "### [rowImaxLast](https://docs.dolphindb.com/en/Functions/r/rowimaxlast.html)\n\n\n\n#### Syntax\n\nrowImaxLast(args…)\n\n#### Arguments\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.dita) for the parameters and calculation rules.\n\n#### Details\n\nReturn a vector of the same length as the number of rows of the argument. The vector contains the index of the element with the largest value in *X* in each row. If there are multiple elements with the identical largest value, return the index of the first element from the right.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5 3.2, 1.5 4.8 5.9 1.7, 4.9 2.0 NULL 5.5])\nrowImaxLast(m)\n// output\n[2,1,1,2]\n\ntrades = table(10:0,`time`sym`p1`p2`p3`p4`p5`vol1`vol2`vol3`vol4`vol5,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,INT,INT,INT,INT,INT])\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 200, 180, 180, 220, 200)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.1, 32.8, 33.2, 34.3, 32.3, 150, 280, 190, 100, 220)\ninsert into trades values(2022.01.01T09:00:00, `A, 31.2, 32.6, 33.6, 35.3, 34.5, 220, 160, 130, 100, 110)\ninsert into trades values(2022.01.01T09:00:00, `A, 30.2, 32.5, 33.6, 35.3, 34.1, 200, 180, 150, 140, 120)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 180, 160, 160, 180, 200)\n\nselect rowAt(matrix(p1, p2, p3, p4, p5), rowImaxLast(vol1, vol2, vol3, vol4, vol5)) as price from trades\n// output\nprice\n33.3\n32.8\n31.2\n30.2\n33.1\n```\n\nRelated function: [rowImax](https://docs.dolphindb.com/en/Functions/r/rowImax.html)\n"
    },
    "rowImin": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowImin.html",
        "signatures": [
            {
                "full": "rowImin(args...)",
                "name": "rowImin",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowImin](https://docs.dolphindb.com/en/Functions/r/rowImin.html)\n\n\n\n#### Syntax\n\nrowImin(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nReturn the index of the minimum in each row. If there are multiple minima, return the index of the first minimum from the left. The result is a vector with the same length as the number of input rows.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5 3.2, 1.5 4.8 5.9 1.7, 4.9 2.0 NULL 5.5])\nrowImin(m)\n// output\n[1,2,0,1]\n\n\ntrades = table(10:0,`time`sym`p1`p2`p3`p4`p5`vol1`vol2`vol3`vol4`vol5,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,INT,INT,INT,INT,INT])\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 200, 180, 180, 220, 200)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.1, 32.8, 33.2, 34.3, 32.3, 150, 280, 190, 100, 220)\ninsert into trades values(2022.01.01T09:00:00, `A, 31.2, 32.6, 33.6, 35.3, 34.5, 220, 160, 130, 100, 110)\ninsert into trades values(2022.01.01T09:00:00, `A, 30.2, 32.5, 33.6, 35.3, 34.1, 200, 180, 150, 140, 120)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 180, 160, 160, 180, 200)\n\nselect rowAt(matrix(p1, p2, p3, p4, p5), rowImin(vol1, vol2, vol3, vol4, vol5)) as price from trades\n```\n\n| price |\n| ----- |\n| 33.8  |\n| 34.3  |\n| 35.3  |\n| 34.1  |\n| 33.8  |\n\nIf *args* is an array vector, return the index of the minimum in each row. The result is a vector.\n\n```\na = 1 8 3 8 1\nb = 5 7 1 3 9\nc =  5 5 4 3 6\nx = fixedLengthArrayVector(a, b, c)\nrowImin(x)\n// output\n[0,2,1,1,0]\n```\n\nRelated functions: [imin](https://docs.dolphindb.com/en/Functions/i/imin.html)\n"
    },
    "rowIminLast": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowiminlast.html",
        "signatures": [
            {
                "full": "rowIminLast(args…)",
                "name": "rowIminLast",
                "parameters": [
                    {
                        "full": "args…",
                        "name": "args…"
                    }
                ]
            }
        ],
        "markdown": "### [rowIminLast](https://docs.dolphindb.com/en/Functions/r/rowiminlast.html)\n\n\n\n#### Syntax\n\nrowIminLast(args…)\n\n#### Arguments\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.dita) for the parameters and calculation rules.\n\n#### Details\n\nReturn a vector of the same length as the number of rows of the argument. The vector contains the index of the element with the smallest value in *X* in each row. If there are multiple elements with the identical smallest value, return the index of the first element from the right.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5 3.2, 1.5 4.8 5.9 1.7, 4.9 2.0 NULL 5.5])\nrowIminLast(m)\n// output\n[1,2,0,1]\n\ntrades = table(10:0,`time`sym`p1`p2`p3`p4`p5`vol1`vol2`vol3`vol4`vol5,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,INT,INT,INT,INT,INT])\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 200, 180, 180, 220, 200)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.1, 32.8, 33.2, 34.3, 32.3, 150, 280, 190, 100, 220)\ninsert into trades values(2022.01.01T09:00:00, `A, 31.2, 32.6, 33.6, 35.3, 34.5, 220, 160, 130, 100, 110)\ninsert into trades values(2022.01.01T09:00:00, `A, 30.2, 32.5, 33.6, 35.3, 34.1, 200, 180, 150, 140, 120)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 180, 160, 160, 180, 200)\n\nselect rowAt(matrix(p1, p2, p3, p4, p5), rowIminLast(vol1, vol2, vol3, vol4, vol5)) as price from trades\n// output\nprice\n33.6\n34.3\n35.3\n34.1\n33.6\n```\n\nRelated function: [rowlmin](https://docs.dolphindb.com/en/Functions/r/rowImin.html)\n"
    },
    "rowKurtosis": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowKurtosis.html",
        "signatures": [
            {
                "full": "rowKurtosis(X, [biased=true])",
                "name": "rowKurtosis",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [rowKurtosis](https://docs.dolphindb.com/en/Functions/r/rowKurtosis.html)\n\n\n\n#### Syntax\n\nrowKurtosis(X, \\[biased=true])\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Arguments\n\n**biased** (optional) is a Boolean value, indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\n#### Details\n\nReturn the kurtosis of each row in *X*.\n\nThe calculation uses the following formula when *biased*=true:\n\n![](https://docs.dolphindb.com/en/images/kurtosisx.png)\n\n#### Examples\n\n```\nm = [4.5 2.6 1.5 1.5 4.8, 5.9 4.9 2.0 4.0 6.3, 2 2 2 2 2, 2.1 3.4 4.2 5.5 2.3]\nrowKurtosis(m);\n// output\n[1.336589711715856,1.839333299961742,2.248755164221374,1.437834622248661,1.341044189891083]\n\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL, 4.3 NULL 3.5]);\nrowKurtosis(m);\n// output\n[2.270290894661423,1.499999999999941,1.499999999999972]\n\nt1=table(1..5 as x, 10..6 as y, 15..19 as z, take(3,5) as t);\nrowKurtosis(t1);\n// output\n[1.417974225003112,1.676864,1.951167883478534,2.158698670898631,2.262015004030008]\n```\n\nRelated function: [kurtosis](https://docs.dolphindb.com/en/Functions/k/kurtosis.html)\n"
    },
    "rowMax": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowMax.html",
        "signatures": [
            {
                "full": "rowMax(args...)",
                "name": "rowMax",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowMax](https://docs.dolphindb.com/en/Functions/r/rowMax.html)\n\n\n\n#### Syntax\n\nrowMax(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the maximum value of each row of the arguments.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowMax(m);\n// output\n[4.9,4.8,5.9]\n\nt1=table(1..5 as x, 6..10 as y)\nt2=table(5..1 as a, 10..6 as b);\n\nrowMax(t1);\n// output\n[6,7,8,9,10]\n\nrowMax(t1[`y], t2, take(8, 5));\n// output\n[10,9,8,9,10]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect sym,rowMax(price1,price2) as max from t;\n```\n\n| sym  | max    |\n| ---- | ------ |\n| AAPL | 175.23 |\n| MS   | 50.76  |\n| IBM  | 50.32  |\n| IBM  | 51.29  |\n| C    | 174.97 |\n\nRelated function: [max](https://docs.dolphindb.com/en/Functions/m/max.html)\n"
    },
    "rowMin": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowMin.html",
        "signatures": [
            {
                "full": "rowMin(args...)",
                "name": "rowMin",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowMin](https://docs.dolphindb.com/en/Functions/r/rowMin.html)\n\n\n\n#### Syntax\n\nrowMin(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the minimum value of each row of the arguments.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowMin(m);\n// output\n[1.5,2,1.5]\n\nt1=table(1..5 as x, 6..10 as y)\nt2=table(5..1 as a, 10..6 as b);\n\nrowMin(t1);\n// output\n[1,2,3,4,5]\n\nrowMin(t1[`x], t2, take(2, 5));\n// output\n[1,2,2,2,1]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect sym,rowMin(price1,price2) as min from t;\n```\n\n| sym  | min   |\n| ---- | ----- |\n| AAPL | 49.6  |\n| MS   | 29.46 |\n| IBM  | 29.52 |\n| IBM  | 30.02 |\n| C    | 26.23 |\n\nRelated function: [min](https://docs.dolphindb.com/en/Functions/m/min.html)\n"
    },
    "rowMove": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowMove.html",
        "signatures": [
            {
                "full": "rowMove(X, steps)",
                "name": "rowMove",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "steps",
                        "name": "steps"
                    }
                ]
            }
        ],
        "markdown": "### [rowMove](https://docs.dolphindb.com/en/Functions/r/rowMove.html)\n\n\n\n#### Syntax\n\nrowMove(X, steps)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Arguments\n\n**steps** is an integer indicating the length to shift the row elements of *X*.\n\n* if *steps* is positive, the elements in each row are shifted to the right by *steps* position(s).\n\n* if *steps* is negative, the elements in each row are shifted to the left by *steps* position(s).\n\n* if *steps* is 0, *X* is not shifted.\n\n#### Details\n\nThe `rowMove` function shifts the elements in each row of *X* left or right by a specified number of steps.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowMove(m, 2)          \n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n|      |      | 4.5  |\n|      |      | 2.6  |\n|      |      | 1.5  |\n\n```\nrowMove(m, -2)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 4.9  |      |      |\n| 2    |      |      |\n|      |      |      |\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowMove(a, 2)\n// output\n[[00i,00i,1],[00i,00i],[00i,00i,6]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowMove(tp, -2)\n// output\n[[2.3,00F,00F],[6.200000000000001,00F,00F]]\n```\n"
    },
    "rowNames": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowNames.html",
        "signatures": [
            {
                "full": "rowNames(X)",
                "name": "rowNames",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowNames](https://docs.dolphindb.com/en/Functions/r/rowNames.html)\n\n\n\n#### Syntax\n\nrowNames(X)\n\n#### Arguments\n\n**X** is a matrix.\n\n#### Details\n\nReturn the row names of matrix *X*. Please check related function: [columnNames](https://docs.dolphindb.com/en/Functions/c/columnNames.html).\n\n#### Examples\n\n```\nx=1..6$2:3;\nx\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nx.rename!(1 2, `a`b`c);\n```\n\n|   | a | b | c |\n| - | - | - | - |\n| 1 | 1 | 3 | 5 |\n| 2 | 2 | 4 | 6 |\n\n```\nrowNames x;\n// output\n[1,2]\n```\n"
    },
    "rowNext": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowNext.html",
        "signatures": [
            {
                "full": "rowNext(X)",
                "name": "rowNext",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowNext](https://docs.dolphindb.com/en/Functions/r/rowNext.html)\n\n\n\n#### Syntax\n\nrowNext(X)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nFor each row in *X*, `rowNext` shifts the elements to the left for one position.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowNext(m)\n// output\ncol1        col2    col3\n1.5         4.9\n4.8     2\n5.9\n\n\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowNext(a)\n// output\n[[2,3,00i],[5,00i],[7,8,00i]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowNext(tp)\n// output\n[[2.5,2.3,00F],[5.3,6.2,00F]]\n```\n"
    },
    "rowNo": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowNo.html",
        "signatures": [
            {
                "full": "rowNo(X)",
                "name": "rowNo",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowNo](https://docs.dolphindb.com/en/Functions/r/rowNo.html)\n\n\n\n#### Syntax\n\nrowNo(X)\n\n#### Arguments\n\n**X** is a vector.\n\n#### Details\n\nReturn the index position of each row in a table.\n\n#### Examples\n\n```\nteam=1 1 1 1 1 2 2 2 2 2\nid=1..5 join 2..6\nx=11..20\\2\nt=table(team, id, x)\nt;\n```\n\n| team | id | x   |\n| ---- | -- | --- |\n| 1    | 1  | 5.5 |\n| 1    | 2  | 6   |\n| 1    | 3  | 6.5 |\n| 1    | 4  | 7   |\n| 1    | 5  | 7.5 |\n| 2    | 2  | 8   |\n| 2    | 3  | 8.5 |\n| 2    | 4  | 9   |\n| 2    | 5  | 9.5 |\n| 2    | 6  | 10  |\n\n```\nselect * from t where rowNo(id)%3=0;\n```\n\n| team | id | x   |\n| ---- | -- | --- |\n| 1    | 1  | 5.5 |\n| 1    | 4  | 7   |\n| 2    | 3  | 8.5 |\n| 2    | 6  | 10  |\n\n```\nupdate t set teamFirst=(rowNo(id)==0) context by team;\nt;\n```\n\n| team | id | x   | teamFirst |\n| ---- | -- | --- | --------- |\n| 1    | 1  | 5.5 | 1         |\n| 1    | 2  | 6   | 0         |\n| 1    | 3  | 6.5 | 0         |\n| 1    | 4  | 7   | 0         |\n| 1    | 5  | 7.5 | 0         |\n| 2    | 2  | 8   | 1         |\n| 2    | 3  | 8.5 | 0         |\n| 2    | 4  | 9   | 0         |\n| 2    | 5  | 9.5 | 0         |\n| 2    | 6  | 10  | 0         |\n"
    },
    "rowOr": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowOr.html",
        "signatures": [
            {
                "full": "rowOr(args...)",
                "name": "rowOr",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowOr](https://docs.dolphindb.com/en/Functions/r/rowOr.html)\n\n\n\n#### Syntax\n\nrowOr(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nFor each row (a vector is viewed as a one-column matrix here), return 1 if there are true elements in each row of the input; otherwise return 0.\n\n#### Examples\n\n```\nm=matrix([true false false, true true true, true true true])\nrowOr(m);\n// output\n[1,1,1]\n\nt1=table(false true true true false as x, false true false true true as y)\nrowOr(t1);\n// output\n[0,1,1,1,1]]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect *  from t where rowOr(price1>30, price2>100);\n```\n\n| sym  | price1 | price2 |\n| ---- | ------ | ------ |\n| AAPL | 49.6   | 175.23 |\n| IBM  | 30.02  | 51.29  |\n| C    | 174.97 | 26.23  |\n\nRelated function: [or](https://docs.dolphindb.com/en/Programming/Operators/OperatorReferences/or.html)\n"
    },
    "rowPrev": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowPrev.html",
        "signatures": [
            {
                "full": "rowPrev(X)",
                "name": "rowPrev",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowPrev](https://docs.dolphindb.com/en/Functions/r/rowPrev.html)\n\n\n\n#### Syntax\n\nrowPrev(X)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nFor each row in *X*, `rowPrev` shifts the elements to the right for one position.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowPrev(m) \n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n|      | 4.5  | 1.5  |\n|      | 2.6  | 4.8  |\n|      | 1.5  | 5.9  |\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowPrev(a)\n// output\n[[00i,1,2],[00i,4],[00i,6,7]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowPrev(tp)\n// output\n[[00F,1.3,2.5],[00F,4.1,5.3]]\n```\n"
    },
    "rowProd": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowProd.html",
        "signatures": [
            {
                "full": "rowProd(args...)",
                "name": "rowProd",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowProd](https://docs.dolphindb.com/en/Functions/r/rowProd.html)\n\n\n\n#### Syntax\n\nrowProd(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the product of each row of the arguments.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowProd(m);\n// output\n[33.075,24.96,8.85]\n\nv1=1 0 2 -2 5\nv2=-8 1 2 4 2\nrowProd(v1, v2);\n// output\n[-8,0,4,-8,10]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect * from t where rowOr(price1>50, price2>50);\n```\n\n| sym  | price     |\n| ---- | --------- |\n| AAPL | 8691.408  |\n| MS   | 1495.3896 |\n| IBM  | 1485.4464 |\n| IBM  | 1539.7258 |\n| C    | 4589.4631 |\n\nRelated functions: [prod](https://docs.dolphindb.com/en/Functions/p/prod.html),\n"
    },
    "rowRank": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowRank.html",
        "signatures": [
            {
                "full": "rowRank(X, [ascending=true], [groupNum], [ignoreNA=true], [tiesMethod='min'], [percent=false], [precision])",
                "name": "rowRank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[groupNum]",
                        "name": "groupNum",
                        "optional": true
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='min']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'min'"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[precision]",
                        "name": "precision",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rowRank](https://docs.dolphindb.com/en/Functions/r/rowRank.html)\n\n\n\n#### Syntax\n\nrowRank(X, \\[ascending=true], \\[groupNum], \\[ignoreNA=true], \\[tiesMethod='min'], \\[percent=false], \\[precision])\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Arguments\n\n**X** is a matrix.\n\n**ascending** (optional) is a Boolean value indicating whether the sorting is in ascending order. The default value is true (ascending).\n\n**groupNum** (optional) is a positive integer indicating the number of groups to sort *X* into.\n\n**ignoreNA** (optional) is a Boolean value indicating whether NULL values are ignored.\n\n**tiesMethod** (optional) is a string indicating how to rank the group of elements with the same value (i.e., ties):\n\n* 'min' : the smallest rank value of the tie values.\n\n* 'max' : the largest rank value of the tie values.\n\n* 'average' : the average of the rank values for all ties.\n\n* 'first': Gives the first found tie value the lowest rank value, and continues with the following rank value for the next tie.\n\n**percent** (optional) is a Boolean value, indicating whether to display the returned rankings in percentile form. The default value is false.\n\n**precision** (optional) is an integer between \\[1, 15]. If the absolute difference between two values is no greater than 10^(-precision), the two values are considered to be equal.\n\n**Note:**\n\nIf parameter *precision* is specified, *X* must be numeric, and the *tiesMethod* cannot be specified as 'first'.\n\n#### Details\n\nConduct the following operation within each row of matrix *X*:\n\n* Return the position of each element in the sorted vector.\n* If *groupNum* is specified, group the elements into *groupNum* groups and return the group number each element belongs to.\n* If *ignoreNA* =true, NULL values return NULL.\n\nThe result is a matrix with the same shape as *X*.\n\n#### Examples\n\n```\nm=matrix(3 1 2 4 7 6 9 8 5, 9 NULL 2 3 5 6 3 2 8).transpose();\nm\n```\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 3  | 1  | 2  | 4  | 7  | 6  | 9  | 8  | 5  |\n| 9  |    | 2  | 3  | 5  | 6  | 3  | 2  | 8  |\n\n```\nm.rowRank();\n```\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 2  | 0  | 1  | 3  | 6  | 5  | 8  | 7  | 4  |\n| 7  |    | 0  | 2  | 4  | 5  | 2  | 0  | 6  |\n\n```\nm.rowRank(false);\n```\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 6  | 8  | 7  | 5  | 2  | 3  | 0  | 1  | 4  |\n| 0  |    | 6  | 4  | 3  | 2  | 4  | 6  | 1  |\n\n```\nm.rowRank(groupNum=3);\n```\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 0  | 0  | 0  | 1  | 2  | 1  | 2  | 2  | 1  |\n| 2  |    | 0  | 0  | 1  | 1  | 0  | 0  | 2  |\n\n```\nm.rowRank(ignoreNA=false);\n```\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 2  | 0  | 1  | 3  | 6  | 5  | 8  | 7  | 4  |\n| 8  | 0  | 1  | 3  | 5  | 6  | 3  | 1  | 7  |\n\n```\nm.rowRank(ignoreNA=false, tiesMethod='max');\n```\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 2  | 0  | 1  | 3  | 6  | 5  | 8  | 7  | 4  |\n| 8  | 0  | 2  | 4  | 5  | 6  | 4  | 2  | 7  |\n\n```\nm.rowRank(ignoreNA=false, tiesMethod='first');\n```\n\n| col1 | col2 | col3 | col4 | col5 | col6 | col7 | col8 | col9 |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 2    | 0    | 1    | 3    | 6    | 5    | 8    | 7    | 4    |\n| 8    | 0    | 1    | 3    | 5    | 6    | 4    | 2    | 7    |\n\nRelated functions: [rowDenseRank](https://docs.dolphindb.com/en/Functions/r/rowDenseRank.html), [rank](https://docs.dolphindb.com/en/Functions/r/rank.html)\n"
    },
    "rows": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rows.html",
        "signatures": [
            {
                "full": "rows(X)",
                "name": "rows",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rows](https://docs.dolphindb.com/en/Functions/r/rows.html)\n\n\n\n#### Syntax\n\nrows(X)\n\n#### Arguments\n\n**X** is a vector/matrix/table.\n\n#### Details\n\nReturn the number of rows in *X*. Please check related function: [cols](https://docs.dolphindb.com/en/Functions/c/cols.html).\n\n#### Examples\n\n```\ny=1 2 3;\nrows(y);\n// output\n3\n// a vector can be viewed as an n*1 matrix.\n\nx=1..6$2:3;\nX\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nrows X\n// output\n2\n\na=table(1..3 as x,`IBM`C`AAPL as y);\na\n```\n\n| x | y    |\n| - | ---- |\n| 1 | IBM  |\n| 2 | C    |\n| 3 | AAPL |\n\n```\n rows a;\n// output\n3\n```\n"
    },
    "rowSize": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowSize.html",
        "signatures": [
            {
                "full": "rowSize(args...)",
                "name": "rowSize",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowSize](https://docs.dolphindb.com/en/Functions/r/rowSize.html)\n\n\n\n#### Syntax\n\nrowSize(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the number of elements (NULL values included) of each row.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]);\nrowSize(m);\n// output\n[3,3,3]\n\nt1=table(1 NULL 3 NULL 5 as x, 6..10 as y);\nt2=table(5 NULL 3 NULL 1 as a, 10..6 as b);\nrowSize(t1);\n// output\n[2,2,2,2,2]\n\nrowCount(t1[`x], t2, 1 NULL 2 NULL NULL);\n// output\n[4,1,4,1,3]\nrowSize(t1[`x], t2, 1 NULL 2 NULL NULL);\n// output\n[4,4,4,4,4]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, [49.6, NULL, 29.52, NULL, 174.97] as price1, [175.23, NULL, 50.32, 51.29, 26.23] as price2);\nselect sym,rowSize(price1,price2) as size from t;\n```\n\n| sym  | size |\n| ---- | ---- |\n| AAPL | 2    |\n| MS   | 2    |\n| IBM  | 2    |\n| IBM  | 2    |\n| C    | 2    |\n\nRelated functions: [rowCount](https://docs.dolphindb.com/en/Functions/r/rowCount.html), [size](https://docs.dolphindb.com/en/Functions/s/size.html)\n"
    },
    "rowSkew": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowSkew.html",
        "signatures": [
            {
                "full": "rowSkew(X, [biased=true])",
                "name": "rowSkew",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [rowSkew](https://docs.dolphindb.com/en/Functions/r/rowSkew.html)\n\n\n\n#### Syntax\n\nrowSkew(X, \\[biased=true])\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Arguments\n\n**biased** (optional) is a Boolean value, indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\n#### Details\n\nReturn the skewness of each row in *X*.\n\nThe calculation uses the following formula when *biased*=true:\n\n![](https://docs.dolphindb.com/en/images/rowskewx.png)\n\n#### Examples\n\n```\nm = [4.5 2.6 1.5 1.5 4.8, 5.9 4.9 2.0 4.0 6.3, 2 2 2 2 2]\nrowSkew(m);\n// output\n[-0.329206341655613,0.586870565935934,-0.707106781186563,0.595170064139497,-0.350377619697706]\n\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL, 4.3 NULL 3.5]);\nrowSkew(m);\n// output\n[-1.064430070205901,0.577633692366209,0.110780117654846]\n\nt1=table(1..5 as x, 10..6 as y, take(3, 5) as z);\nrowSkew(t1);\n// output\n[0.567316577993729,0.652012117044047,0.707106781186548,0.528004979218188,-0.381801774160629]\n```\n\nRelated function: [skew](https://docs.dolphindb.com/en/Functions/s/skew.html)\n"
    },
    "rowStd": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowStd.html",
        "signatures": [
            {
                "full": "rowStd(args...)",
                "name": "rowStd",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowStd](https://docs.dolphindb.com/en/Functions/r/rowStd.html)\n\n\n\n#### Syntax\n\nrowStd(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the (sample) standard deviation of each row of the arguments.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowStd(m);\n// output\n[1.858315,1.474223,3.11127]\n\nt1=table(1..5 as x, 10..6 as y, take(3, 5) as z)\nt2=table(5..1 as a, 6..10 as b, take(8, 5) as c);\n\nrowStd(t1);\n// output\n[4.725816,3.785939,2.886751,2.081666,1.527525]\n\nrowStd(t1[`x], t2, 1 1 2 2 2);\n// output\n[3.114482,3.04959,2.949576,3.316625,3.834058]\n\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect sym,rowStd(price1,price2) as std from t;\n```\n\n| sym  | std        |\n| ---- | ---------- |\n| AAPL | 88.833825  |\n| MS   | 15.061374  |\n| IBM  | 14.707821  |\n| IBM  | 15.040161  |\n| C    | 105.175063 |\n\nRelated functions: [rowStdp](https://docs.dolphindb.com/en/Functions/r/rowStdp.html), [std](https://docs.dolphindb.com/en/Functions/s/std.html)\n"
    },
    "rowStdp": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowStdp.html",
        "signatures": [
            {
                "full": "rowStdp(args...)",
                "name": "rowStdp",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowStdp](https://docs.dolphindb.com/en/Functions/r/rowStdp.html)\n\n\n\n#### Syntax\n\nrowStdp(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the population standard deviation of each row.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowStdp(m);\n// output\n[1.517307556898806,1.203698005684518,2.2]\n\nt1=table(1..5 as x, 10..6 as y, take(3, 5) as z)\nt2=table(5..1 as a, 6..10 as b, take(8, 5) as c);\nrowStdp(t1);\n// output\n[3.858612300930075,3.091206165165235,2.357022603955159,1.699673171197595,1.247219128924648]\n\nrowStdp(t1[`x], t2, 1 1 2 2 2);\n// output\n[2.785677655436824,2.727636339397171,2.638181191654584,2.966479394838265,3.42928563989645]\n\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect sym,rowStdp(price1,price2) as stdp from t;\n```\n\n| sym  | stdp   |\n| ---- | ------ |\n| AAPL | 62.815 |\n| MS   | 10.65  |\n| IBM  | 10.4   |\n| IBM  | 10.635 |\n| C    | 74.37  |\n\nRelated functions: [rowStd](https://docs.dolphindb.com/en/Functions/r/rowStd.html), [std](https://docs.dolphindb.com/en/Functions/s/std.html)\n"
    },
    "rowSum": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowSum.html",
        "signatures": [
            {
                "full": "rowSum(args...)",
                "name": "rowSum",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowSum](https://docs.dolphindb.com/en/Functions/r/rowSum.html)\n\n\n\n#### Syntax\n\nrowSum(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the sum of each row of the arguments.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowSum(m);\n// output\n[10.9,9.4,7.4]\n\nt1=table(1..5 as x, 6..10 as y)\nt2=table(5..1 as a, 10..6 as b);\n\nrowSum(t1);\n// output\n[7,9,11,13,15]\n\nrowSum(t1[`x], t2, 1 1 2 2 2);\n// output\n[17,16,16,15,14]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect sym,rowSum(price1,price2) as priceSum from t;\n```\n\n| sym  | priceSum |\n| ---- | -------- |\n| AAPL | 224.83   |\n| MS   | 80.22    |\n| IBM  | 79.84    |\n| IBM  | 81.31    |\n| C    | 201.2    |\n\nRelated function: [sum](https://docs.dolphindb.com/en/Functions/s/sum.html)\n"
    },
    "rowSum2": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowSum2.html",
        "signatures": [
            {
                "full": "rowSum2(args...)",
                "name": "rowSum2",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowSum2](https://docs.dolphindb.com/en/Functions/r/rowSum2.html)\n\n\n\n#### Syntax\n\nrowSum2(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the sum of square of all elements in each row of the arguments.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]);\nrowSum2(m);\n// output\n[46.51,33.8,37.06]\n\nt1=table(1..5 as x, 6..10 as y);\nt2=table(5..1 as a, 10..6 as b);\n\nrowSum2(t1);\n// output\n[37,53,73,97,125]\n\nrowSum2(t1[`x], t2, 1 1 2 2 2);\n// output\n[127,102,86,73,66]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect sym,rowSum2(price1,price2) as price2Sum from t;\n```\n\n| sym  | priceSum |\n| ---- | -------- |\n| AAPL | 224.83   |\n| MS   | 80.22    |\n| IBM  | 79.84    |\n| IBM  | 81.31    |\n| C    | 201.2    |\n\nRelated function: [sum2](https://docs.dolphindb.com/en/Functions/s/sum2.html)\n"
    },
    "rowTanimoto": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowTanimoto.html",
        "signatures": [
            {
                "full": "rowTanimoto(X, Y)",
                "name": "rowTanimoto",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowTanimoto](https://docs.dolphindb.com/en/Functions/r/rowTanimoto.html)\n\n\n\n#### Syntax\n\nrowTanimoto(X, Y)\n\n#### Arguments\n\n**X** and **Y** are numeric vectors/array vectors of the same length or matrices with the same dimension. If *X* and *Y* are array vectors, the vectors at the same position in *X* and *Y* must have the same length.\n\n#### Details\n\nIf both *X* and *Y* are vectors/matrices, calculate the tanimoto distance between *X* and *Y* by row. If both *X* and *Y* are indexed matrices, calculate the tanimoto distance between rows with the same label. For other rows, return NULL.\n\nFor a vector and a matrix, the length of the vector must be the same as the number of columns of the matrix. Calculate the tanimoto distance between the vector and each row of the matrix.\n\nIf *X* and *Y* are array vectors, calculate the tanimoto distance between the corresponding rows (vectors) in *X* and *Y*, i.e., tanimoto(X.row(i),Y.row(i)).\n\nFor a vector and an array vector, calculate the tanimoto distance between the vector and each vector in the array vector. Return NULL when *X* and *Y* are of different lengths.\n\nAs with all other aggregate functions, NULL values are ignored in the calculation.\n\n#### Examples\n\n```\nrowTanimoto(3.6 5.2 6.3, 8.6 4.8 5.5)\n// output\n[0.4467,0.0064,0.0181]\n\na=array(INT[],0,10)\na.append!([[1, 8, 9],[15, NULL], [25, 22, 13, 15]])\nb=array(INT[],0,10)\nb.append!([[11, 18, 6],[5, 9], [5, 2, 3, 1]])\nrowTanimoto(a,b)\n// output\n[0.5,0.5714,0.8309]\n\ns1=indexedSeries(2020.01.01..2020.01.03, 10.4 11.2 9)\ns2=indexedSeries(2020.01.01 2020.01.03 2020.01.04, 23.5 31.2 26)\nrowTanimoto(s1,s2)\n// output\n[0.4125,0.5337,0.5526]\n\nm=matrix(23 56 47, 112 94 59)\nm1=matrix(11 15 89, 52 41 63)\nrowTanimoto(m,m1)\n// output\n[0.3812,0.4889,0.1839]\n\nm.rename!(2020.01.01..2020.01.03, `A`B)\nm.setIndexedMatrix!()\nm1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\nm1.setIndexedMatrix!()\nrowTanimoto(m,m1)\n// output\n[0.3812,NULL,0.3014,NULL]\n```\n\nRelated function: [tanimoto](https://docs.dolphindb.com/en/Functions/t/tanimoto.html)\n"
    },
    "rowVar": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowVar.html",
        "signatures": [
            {
                "full": "rowVar(args...)",
                "name": "rowVar",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowVar](https://docs.dolphindb.com/en/Functions/r/rowVar.html)\n\n\n\n#### Syntax\n\nrowVar(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the (sample) variance of each row of the arguments.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]);\nrowVar(m);\n// output\n[3.453333,2.173333,9.68]\n\nt1=table(1..5 as x, 10..6 as y, take(3, 5) as z);\nt2=table(5..1 as a, 6..10 as b, take(8, 5) as c);\n\nrowVar(t1);\n// output\n[22.333333,14.333333,8.333333,4.333333,2.333333]\n\nrowVar(t1[`x], t2, 1 1 2 2 2);\n// output\n[9.7,9.3,8.7,11,14.7]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect sym,rowVar(price1,price2) as var from t;\n```\n\n| sym  | var        |\n| ---- | ---------- |\n| AAPL | 7891.44845 |\n| MS   | 226.845    |\n| IBM  | 216.32     |\n| IBM  | 226.20645  |\n| C    | 11061.7938 |\n\nRelated functions: [rowVarp](https://docs.dolphindb.com/en/Functions/r/rowVarp.html), [varp](https://docs.dolphindb.com/en/Functions/v/varp.html)\n"
    },
    "rowVarp": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowVarp.html",
        "signatures": [
            {
                "full": "rowVarp(args...)",
                "name": "rowVarp",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowVarp](https://docs.dolphindb.com/en/Functions/r/rowVarp.html)\n\n\n\n#### Syntax\n\nrowVarp(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the population variance of each row.\n\n#### Examples\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]);\nrowVarp(m);\n// output\n[2.302222222222225,1.448888888888887,4.84]\n\nt1=table(1..5 as x, 10..6 as y, take(3, 5) as z);\nt2=table(5..1 as a, 6..10 as b, take(8, 5) as c);\nrowVarp(t1);\n// output\n[14.888888888888891,9.555555555555557,5.555555555555558,2.888888888888891,1.555555555555557]\n\nrowVarp(t1[`x], t2, 1 1 2 2 2);\n// output\n[7.76,7.440000000000001,6.96,8.8,11.760000000000001]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect sym,rowVarp(price1,price2) as varp from t;\n```\n\n| sym  | varp      |\n| ---- | --------- |\n| AAPL | 3945.7242 |\n| MS   | 113.4225  |\n| IBM  | 108.16    |\n| IBM  | 113.1032  |\n| C    | 5530.8969 |\n\nRelated functions: [rowVar](https://docs.dolphindb.com/en/Functions/r/rowVar.html), [varp](https://docs.dolphindb.com/en/Functions/v/varp.html)\n"
    },
    "rowWavg": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowWavg.html",
        "signatures": [
            {
                "full": "rowWavg(X, Y)",
                "name": "rowWavg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowWavg](https://docs.dolphindb.com/en/Functions/r/rowWavg.html)\n\n\n\n#### Syntax\n\nrowWavg(X, Y)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the weighted average of *X* by row with *Y* as the weights and return a vector with the same number of rows of *X*.\n\n#### Examples\n\n```\nm1=matrix(2 -1 4, 8 3 2, 9 0 1)\nm2=matrix(8 11 10, 8 17 4, 14 6 4)\nrowWavg(m1, m2)\n// output\n[6.8667, 1.1765, 2.8889]\n\nm3=matrix(2 NULL 4, 8 NULL 2, 9 NULL NULL)\nrowWavg(m3, m2)\n// output\n[6.8667, , 3.4286]\n\na= -10 12.3 -10 -8\nb= 17.9 9 7.5 -4\nc= 5.5 5.5 -7 8\n\nrowWavg(matrix(a, b, c), matrix(b, a, c))\n// output\n[-24.459, 9.3899, 10.6316, -32]\n\nx=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[a, b, c\\]\\)\ny=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[b, a, c\\]\\)\nrowWavg\\(x, y\\)\n// output\n\\[-3.6612, 7.0892, 14.4583\\]\n```\n\nRelated function: [wavg](https://docs.dolphindb.com/en/Functions/w/wavg.html)\n"
    },
    "rowWsum": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowWsum.html",
        "signatures": [
            {
                "full": "rowWsum(X, Y)",
                "name": "rowWsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowWsum](https://docs.dolphindb.com/en/Functions/r/rowWsum.html)\n\n\n\n#### Syntax\n\nrowWsum(X, Y)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nCalculate the cumulative weighted sum of *X* by row with *Y* as the weights and return a vector with the same number of rows of *X*.\n\n#### Examples\n\n```\nm1=matrix(2 -1 4, 8 3 2, 9 0 1)\nm2=matrix(8 11 10, 8 17 4, 14 6 4)\nrowWsum(m1, m2)\n// output\n[206, 40, 52]\n\nm3=matrix(8 NULL 10, 8 NULL 4, 14 NULL NULL)\nrowWsum(m1, m3)\n// output\n[206, , 48]\n\na= -10 12.3 4 -8\nb= 17.9 9 7.5 -4\nc= 5.5 6.4 -7 8\nx=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[a, b, c\\]\\)\ny=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[b, a, c\\]\\)\n\nrowWsum\\(x, y\\)\n// output\n\\[0.63, -6.3 , 184.21\\]\n```\n\nRelated function: [wsum](https://docs.dolphindb.com/en/Functions/w/wsum.html)\n"
    },
    "rowXor": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rowXor.html",
        "signatures": [
            {
                "full": "rowXor(args...)",
                "name": "rowXor",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowXor](https://docs.dolphindb.com/en/Functions/r/rowXor.html)\n\n\n\n#### Syntax\n\nrowXor(args...)\n\nPlease see [rowFunctions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html) for the parameters and calculation rules.\n\n#### Details\n\nFor each row, return 1 if odd number of columns are true; otherwise return 0.\n\n#### Examples\n\n```\nm=matrix([true false false, true true true, true true true]);\nrowXor(m);\n// output\n[1,0,0]\n\nt=table(true false false true false true as x, false true false true false true as y, false false true true false false as z);\nt;\n```\n\n| x | y | z |\n| - | - | - |\n| 1 | 0 | 0 |\n| 0 | 1 | 0 |\n| 0 | 0 | 1 |\n| 1 | 1 | 1 |\n| 0 | 0 | 0 |\n| 1 | 1 | 0 |\n\n```\nrowXor(t);\n// output\n[1,1,1,1,0,0]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect * from t where rowXor(price1$ 30, price2$ 50);\n```\n\n| sym | price1 | price2 |\n| --- | ------ | ------ |\n| MS  | 29.46  | 50.76  |\n| IBM | 29.52  | 50.32  |\n| C   | 174.97 | 26.23  |\n\nRelated function: [xor](https://docs.dolphindb.com/en/Functions/x/xor.html)\n"
    },
    "rpad": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rpad.html",
        "signatures": [
            {
                "full": "rpad(str, length, [pattern])",
                "name": "rpad",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "length",
                        "name": "length"
                    },
                    {
                        "full": "[pattern]",
                        "name": "pattern",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rpad](https://docs.dolphindb.com/en/Functions/r/rpad.html)\n\n\n\n#### Syntax\n\nrpad(str, length, \\[pattern])\n\n#### Arguments\n\n**str** is a string scalar or vector. It is the string to pad characters to (the right-hand side).\n\n**length** is a positive integer indicating the number of characters to return. If *length* is smaller than the length of *str*, the `rpad` function will truncate *str* to the size of length.\n\n**pattern** (optional) is a string scalar. It is the string that will be padded to the right-hand side of str. If it is unspecified, the `rpad` function will pad spaces to the right-side of *str*.\n\n#### Details\n\nPad the right-side of a string with a specific set of characters.\n\n#### Examples\n\n```\nrpad(\"Hello\",2);\n// output\nHe\n\nrpad(`Hello, 10);\n// output\nHello\n\nrpad(`Hello, 12, `0);\n// output\nHello0000000\n```\n"
    },
    "rpc": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rpc.html",
        "signatures": [
            {
                "full": "rpc(nodeAlias, func, args, ...)",
                "name": "rpc",
                "parameters": [
                    {
                        "full": "nodeAlias",
                        "name": "nodeAlias"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args",
                        "name": "args"
                    },
                    {
                        "full": "...",
                        "name": "..."
                    }
                ]
            }
        ],
        "markdown": "### [rpc](https://docs.dolphindb.com/en/Functions/r/rpc.html)\n\n\n\n#### Syntax\n\nrpc(nodeAlias, func, args, ...)\n\n#### Arguments\n\n**nodeAlias** is the alias of a remote node.\n\n**func** is a function. It must not be quoted. The function could be either a built-in function or a user-defined function on the local node.\n\n**args** are function arguments. It does not support dictionaries whose values are function definitions.\n\n#### Details\n\nCall a local function on the specified remote node and return the result to the local node. The function can be either a built-in function or a user defined function on the local node. The system automatically serializes the function definition and the definitions of all dependent functions together with necessary local data to remote node.\n\nBoth the calling node and the remote node must be located in the same cluster. Otherwise, we need to use function [remoteRun](https://docs.dolphindb.com/en/Functions/r/remoteRun.html) .\n\nFor more details please refer to [Batch Job Management](https://docs.dolphindb.com/en/Maintenance/BatchJobManagement.html).\n\n#### Examples\n\n* Remote call a user defined function:\n\n  ```\n  rpc(\"nodeA\", def(x,y):x+y, 10, 15)\n  ```\n\n* Remote call a partial application:\n\n  ```\n  rpc(\"nodeA\", getRecentJobs{10})\n  ```\n\n* Remote call a built-in function that quotes a user-defined function:\n\n  ```\n  def jobDemo(n){\n      s = 0\n      for (x in 1 : n) {\n         s += sum(sin rand(1.0, 100000000)-0.5)\n             print(\"iteration \" + x + \" \" + s)\n  }\n  return s\n  };\n  // the node \"DFS_NODE2\" is located in the same cluster as the local node.\n  rpc(\"DFS_NODE2\", submitJob, \"jobDemo3\", \"job demo\", jobDemo, 10);\n  // Output: jobDemo3\n\n  rpc(\"DFS_NODE2\", getJobReturn, \"jobDemo3\")\n  // Output: -3426.577521\n  ```\n"
    },
    "rshift": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rshift.html",
        "signatures": [
            {
                "full": "rshift(X, a)",
                "name": "rshift",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "a",
                        "name": "a"
                    }
                ]
            }
        ],
        "markdown": "### [rshift](https://docs.dolphindb.com/en/Functions/r/rshift.html)\n\n\n\n#### Syntax\n\nrshift(X, a) or X>>a\n\n#### Arguments\n\n**X** is an integral scalar/pair/vector/matrix.\n\n**a** is the number of bits to shift.\n\n#### Details\n\nShift bits to the right.\n\n#### Examples\n\n```\nrshift(2048, 2);\n// output\n512\n\n 1..10 >> 1;\n// output\n[0,1,1,2,2,3,3,4,4,5]\n\n1:10>>1;\n// output\n0 : 5\n```\n\nRelated function: [lshift](https://docs.dolphindb.com/en/Functions/l/lshift.html)\n"
    },
    "rtrim": {
        "url": "https://docs.dolphindb.com/en/Functions/r/rtrim.html",
        "signatures": [
            {
                "full": "rtrim(X)",
                "name": "rtrim",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rtrim](https://docs.dolphindb.com/en/Functions/r/rtrim.html)\n\n\n\n#### Syntax\n\nrtrim(X)\n\n#### Arguments\n\n**X** is a string scalar or vector.\n\n#### Details\n\nTake a string of characters that has spaces at the end, and return the text without the spaces at the end.\n\n#### Examples\n\n```\nrtrim(\"I love      \")+\" \"+ltrim(\"    this game!\");\n// output\nI love this game!\n```\n"
    },
    "run": {
        "url": "https://docs.dolphindb.com/en/Functions/r/run.html",
        "signatures": [
            {
                "full": "run(scriptFile, [newSession=false], [clean=true])",
                "name": "run",
                "parameters": [
                    {
                        "full": "scriptFile",
                        "name": "scriptFile"
                    },
                    {
                        "full": "[newSession=false]",
                        "name": "newSession",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[clean=true]",
                        "name": "clean",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [run](https://docs.dolphindb.com/en/Functions/r/run.html)\n\n\n\n#### Syntax\n\nrun(scriptFile, \\[newSession=false], \\[clean=true])\n\n#### Arguments\n\n**scriptFile** is the path of the script file.\n\n**newSession** indicates whether to create a new session to execute the script.\n\n**clean** indicates whether to clean the variables in the current session. The default value is true, meaning the variables will be cleaned after executing `run`.\n\n#### Details\n\nExecute a saved program. It must be executed by a logged-in user. If *newSession* = false, the program runs in the current session. If *newSession* = true, the program file runs in a newly created session which will be closed after finish running the script.\n\n#### Examples\n\n```\nrun \"/home/DolphinDB/test.script\";\nd = dict(STRING, ANY)\nd[\"TradePrice\"] = 1..1000\n//The variable d defined in the current session is not cleaned as the parameter clean is set to false.\nrun(\"/home/DolphinDB/test.script\", clean=false)\nparseExpr(\"avg(TradePrice)\",d).eval()\n// output\n500.5\n```\n"
    },
    "runScript": {
        "url": "https://docs.dolphindb.com/en/Functions/r/runScript.html",
        "signatures": [
            {
                "full": "runScript(script)",
                "name": "runScript",
                "parameters": [
                    {
                        "full": "script",
                        "name": "script"
                    }
                ]
            }
        ],
        "markdown": "### [runScript](https://docs.dolphindb.com/en/Functions/r/runScript.html)\n\n\n\n#### Syntax\n\nrunScript(script)\n\n#### Arguments\n\n**Script** is a string indicating the script to be executed.\n\n#### Details\n\nLocally execute a script. It must be executed by a logged-in user.\n\n#### Examples\n\n```\nt = table(1..100 as id,201..300 as val1)\nscript1 = 'dn = \"dfs://test\";if(existsDatabase(dn)){dropDatabase(dn)};db = database(dn,VALUE,1..10);pt = db.createPartitionedTable(t,`pt,`id).append!(t)'\nscript2 = 'select * from loadTable(\"dfs://test\",`pt)'\nrunScript(script1)\nrunScript(script2)\n```\n"
    },
    "saveAsNpy": {
        "url": "https://docs.dolphindb.com/en/Functions/s/saveAsNpy.html",
        "signatures": [
            {
                "full": "saveAsNpy(obj, fileName)",
                "name": "saveAsNpy",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "fileName",
                        "name": "fileName"
                    }
                ]
            }
        ],
        "markdown": "### [saveAsNpy](https://docs.dolphindb.com/en/Functions/s/saveAsNpy.html)\n\n\n\n#### Syntax\n\nsaveAsNpy(obj, fileName)\n\n#### Arguments\n\n**obj** is a numeric vector/matrix.\n\n**fileName** is the path and name of the output file.\n\n#### Details\n\nSave a vector/matrix in DolphinDB as an npy file. It must be executed by a logged-in user.\n\nNULL in a DolphinDB variable will be converted into NaN in the npy file.\n\n#### Examples\n\n```\nv = 1..1000\nv.saveAsNpy(\"C:/DolphinDB/intVec.npy\")\n\nm = (1..1000 + 0.5)$20:50\nm.saveAsNpy(\"C:/DolphinDB/doubleMat.npy\")\n```\n\nLoad files in python:\n\n```\nimport numpy as np\nv = np.load(\"C:/DolphinDB/intVec.npy\")\nm = np.load(\"C:/DolphinDB/doubleMat.npy\")\n```\n\nRelated function: [loadNpy](https://docs.dolphindb.com/en/Functions/l/loadNpy.html)\n"
    },
    "saveDatabase": {
        "url": "https://docs.dolphindb.com/en/Functions/s/saveDatabase.html",
        "signatures": [
            {
                "full": "saveDatabase(dbHandle)",
                "name": "saveDatabase",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    }
                ]
            }
        ],
        "markdown": "### [saveDatabase](https://docs.dolphindb.com/en/Functions/s/saveDatabase.html)\n\n\n\n#### Syntax\n\nsaveDatabase(dbHandle)\n\n#### Arguments\n\n**dbHandle** is a DolphinDB database handle.\n\n#### Details\n\nSave a database handle. It must be executed by a logged-in user. It is used with the [database](https://docs.dolphindb.com/en/Functions/d/database.html) function.\n\nAfter we create a database for the first time, we can save the database with the command `saveDatabase`. If the database location is a folder that already contains DolphinDB table related files, then function [database](https://docs.dolphindb.com/en/Functions/d/database.html) reopens a previously created database, and there is no need to use the `saveDatabase` command to save it.\n\n#### Examples\n\n```\ndb=database(\"C:/DolphinDB/\")\nsaveDatabase(db);\n```\n"
    },
    "saveDualPartition": {
        "url": "https://docs.dolphindb.com/en/Functions/s/saveDualPartition.html",
        "signatures": [
            {
                "full": "saveDualPartition(dbHandle1, dbHandle2, table, tableName, partitionColumn1, partitionColumn2, [compression=false])",
                "name": "saveDualPartition",
                "parameters": [
                    {
                        "full": "dbHandle1",
                        "name": "dbHandle1"
                    },
                    {
                        "full": "dbHandle2",
                        "name": "dbHandle2"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "partitionColumn1",
                        "name": "partitionColumn1"
                    },
                    {
                        "full": "partitionColumn2",
                        "name": "partitionColumn2"
                    },
                    {
                        "full": "[compression=false]",
                        "name": "compression",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [saveDualPartition](https://docs.dolphindb.com/en/Functions/s/saveDualPartition.html)\n\n\n\n#### Syntax\n\nsaveDualPartition(dbHandle1, dbHandle2, table, tableName, partitionColumn1, partitionColumn2, \\[compression=false])\n\n#### Arguments\n\n**dbHandle1** is the database handle of the first level partition.\n\n**dbHandle2** is the database handle of the second level partition.\n\n**table** is the table in memory to be saved.\n\n**tableName** is a string indicating the desired name of the saved partitioned table.\n\n**partitionColumn1** is a string indicating the partitioning column of the first level partition.\n\n**partitionColumn2** is a string indicating the partitioning column of the second level partition.\n\n**compression** (optional) is a Boolean variable. It sets the compression mode. When it is set to true, the table will be saved to disk in compression mode. The default value is false.\n\n#### Details\n\nSave a table in the local node before sharing it to other nodes to form a dual partition database. It must be executed by a logged-in user.\n\nIt is used together with statement [share](https://docs.dolphindb.com/en/Programming/ProgrammingStatements/share.html). If the partition and a table already exist, the function will append the new data to the existing table.\n\n#### Examples\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(1.0, n)\nt=table(ID, date, x);\n\nhdb = database(\"C:/DolphinDB/Data/dualDB\", RANGE,  0 5 10)\nvdb = database(, VALUE, dates)\nsaveDualPartition(hdb, vdb, t, `tDualPartition, `ID, `date)\n```\n"
    },
    "saveModel": {
        "url": "https://docs.dolphindb.com/en/Functions/s/saveModel.html",
        "signatures": [
            {
                "full": "saveModel(model, location)",
                "name": "saveModel",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "location",
                        "name": "location"
                    }
                ]
            }
        ],
        "markdown": "### [saveModel](https://docs.dolphindb.com/en/Functions/s/saveModel.html)\n\n\n\n#### Syntax\n\nsaveModel(model, location)\n\n#### Arguments\n\n**model** is a dictionary of the specifications of a prediction model. It is generated by functions such as [randomForestClassifier](https://docs.dolphindb.com/en/Functions/r/randomForestClassifier.html) and [randomForestRegressor](https://docs.dolphindb.com/en/Functions/r/randomForestRegressor.html).\n\n**location** is a string indicating the absolute path and name of the output file.\n\n#### Details\n\nSave the specifications of a trained model to a file on disk.\n\n#### Examples\n\n```\nx1 = rand(100.0, 100)\nx2 = rand(100.0, 100)\nb0 = 6\nb1 = 1\nb2 = -2\nerr = norm(0, 10, 100)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(x1, x2, y)\nmodel = randomForestRegressor(sqlDS(<select * from t>), `y, `x1`x2)\nsaveModel(model, \"C:/DolphinDB/Data/regressionModel.txt\");\n```\n"
    },
    "saveModule": {
        "url": "https://docs.dolphindb.com/en/Functions/s/saveModule.html",
        "signatures": [
            {
                "full": "saveModule(name,[moduleDir],[overwrite=false])",
                "name": "saveModule",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[moduleDir]",
                        "name": "moduleDir",
                        "optional": true
                    },
                    {
                        "full": "[overwrite=false]",
                        "name": "overwrite",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [saveModule](https://docs.dolphindb.com/en/Functions/s/saveModule.html)\n\n\n\n#### Syntax\n\nsaveModule(name,\\[moduleDir],\\[overwrite=false]))\n\n#### Arguments\n\n**name** is a string indicating the name of the module.\n\n**moduleDir** (optional) is a string indicating the directory where the module files are located.\n\n**overwrite** (optional) is a Boolean value indicating whether to overwrite the existing module dom file.\n\n#### Details\n\nSerialize a module (\".dos\" file) to a binary file with a file name extension of \".dom\". It must be executed by a logged-in user.\n\nThe default value of *moduleDir* is the relative directory \"modules\" that needs to be created by the user. The system searches the relative directory \"modules\" in the following order: home directory of the node, the working directory of the node, and the directory with the DolphinDB executable. Please note that in the single node mode, these 3 directory are the same by default.\n\n`saveModule` enhances the confidentiality and the security of the code.\n\n#### Examples\n\nAssuming the directory \"modules\" under the node's home directory contains the module files \"ta.dos\" and \"system/log/fileLog.dos\", the following example serializes the module files to binary files.\n\n```\nsaveModule(\"ta\");\n\nsaveModule(\"system::log::fileLog\");\n```\n\nRelated command: [loadModule](https://docs.dolphindb.com/en/Functions/l/loadModule.html)\n"
    },
    "savePartition": {
        "url": "https://docs.dolphindb.com/en/Functions/s/savePartition.html",
        "signatures": [
            {
                "full": "savePartition(dbHandle, table, tableName, [compression=true])",
                "name": "savePartition",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[compression=true]",
                        "name": "compression",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [savePartition](https://docs.dolphindb.com/en/Functions/s/savePartition.html)\n\n\n\n#### Syntax\n\nsavePartition(dbHandle, table, tableName, \\[compression=true])\n\n#### Arguments\n\n**dbHandle** is a DolphinDB database handle.\n\n**table** is the table in memory to be saved.\n\n**tableName** is a string indicating the desired name of the saved partitioned table.\n\n**compression** (optional) is a Boolean variable. It sets the compression mode. When it is set to *true*, the table will be saved to disk in compression mode. The default value is *true*.\n\n#### Details\n\nSave a table as a partitioned DFS table. It must be executed by a logged-in user.\n\nAn empty table must be created with the function [createPartitionedTable](https://docs.dolphindb.com/en/Functions/c/createPartitionedTable.html).\n\n#### Examples\n\n```\nn=1000000\nID=rand(10, n)\nvalue=rand(1.0, n)\nt=table(ID, value);\n\ndb=database(\"dfs://rangedb_Trades\", RANGE,  0 5 10)\nTrades = db.createPartitionedTable(t, \"Trades\", \"ID\");\nsavePartition(db, t, `Trades)\n\nTrades=loadTable(db, `Trades)\nselect count(value) from Trades;\n// output\n1,000,000\n```\n\nIn the example above, the database db has two partitions: \\[0,5) and \\[5,10). Table t is saved as a partitioned table *Trades* with the partitioning column of *ID* in database db.\n\nWe can append another table to the table *Trades*:\n\n```\nn=500000\nID=rand(10, n)\nvalue=rand(1.0, n)\nt1=table(ID, value);\nsavePartition(db, t1, `Trades)\nTrades=loadTable(db, `Trades)\nselect count(value) from Trades;\n// output\n1,500,000\n```\n"
    },
    "saveTable": {
        "url": "https://docs.dolphindb.com/en/Functions/s/saveTable.html",
        "signatures": [
            {
                "full": "saveTable(dbHandle, table, [tableName], [append=false], [compression=false])",
                "name": "saveTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    },
                    {
                        "full": "[append=false]",
                        "name": "append",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[compression=false]",
                        "name": "compression",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [saveTable](https://docs.dolphindb.com/en/Functions/s/saveTable.html)\n\n\n\n#### Syntax\n\nsaveTable(dbHandle, table, \\[tableName], \\[append=false], \\[compression=false])\n\n#### Arguments\n\n**dbHandle** is a DolphinDB database handle.\n\n**table** is the table in memory to be saved.\n\n**tableName** (optional) is a string indicating the desired name for the saved table. If unspecified, the saved table has the same name as the table in memory.\n\n**appending** (optional) is the appending mode. When it is set to *true*, the new table will be appended to the old table. The default value is *false*.\n\n**compression** (optional) is the compression mode. When it is set to *true*, the table will be saved to disk in compression mode. The default setting is *false*.\n\n#### Details\n\nSave a table to an unpartitioned disk table. It must be executed by a logged-in user.\n\nTo save a table to a partitioned database, use [createPartitionedTable](https://docs.dolphindb.com/en/Functions/c/createPartitionedTable.html) together with [append!](https://docs.dolphindb.com/en/Functions/a/append!.html) or [tableInsert](https://docs.dolphindb.com/en/Functions/t/tableInsert.html).\n\n**Note:** Disk tables are only used for backup or local computing. Unlike the DFS tables, disk tables do not support access control.\n\n#### Examples\n\n```\ndb=database(\"C:/DolphinDB/Data/db1\")\nt=table(take(1..10,10000000) as id, rand(10,10000000) as x, rand(10.0,10000000) as y);\n```\n\nSave table t to disk:\n\n```\nsaveTable(db, t);\n```\n\nSave table t to disk with name t1:\n\n```\nsaveTable(db, t, `t1);\n```\n\nSave table t to disk with name t2 and with appending mode:\n\n```\nsaveTable(db, t, `t2, true);\n```\n\nSave table t to disk with name t3 and with compression mode:\n\n```\nsaveTable(db, t, `t3, false, true);\n```\n"
    },
    "saveText": {
        "url": "https://docs.dolphindb.com/en/Functions/s/saveText.html",
        "signatures": [
            {
                "full": "saveText(obj, filename, [delimiter=','], [append=false], [header=true], [bom=''])",
                "name": "saveText",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[delimiter='",
                        "name": "[delimiter='"
                    },
                    {
                        "full": "']",
                        "name": "']"
                    },
                    {
                        "full": "[append=false]",
                        "name": "append",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[header=true]",
                        "name": "header",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[bom='']",
                        "name": "bom",
                        "optional": true,
                        "default": "''"
                    }
                ]
            }
        ],
        "markdown": "### [saveText](https://docs.dolphindb.com/en/Functions/s/saveText.html)\n\n\n\n#### Syntax\n\nsaveText(obj, filename, \\[delimiter=','], \\[append=false], \\[header=true], \\[bom=''])\n\n#### Arguments\n\n**obj** can be a table/matrix/vector/metacode of SQL statements. When *obj* is the metacode of SQL statements, multiple workers are allocated to read the data concurrently, and the data is written to the file with another worker. In other cases, data queries and writes are handled by the current worker.\n\n**filename** is a string indicating the absolute path and name of the output file. Currently the output file can only be saved in *.csv* format.\n\n**delimiter** (optional) is the table column separator. The system uses comma as the default delimiter.\n\n**append** (optional) is a Boolean value indicating whether to append to (true) or overwrite (false) the output file if it exists already.\n\n**header** (optional) is a BOOLEAN indicating whether to save the column names in the output file when obj is a table. The default value is true. Please note that this parameter has no effect when this command is used for appending data to an existing non-empty file (i.e., when append = true).\n\n**bom** (optional) is a case-insensitive STRING scalar that determines whether to include Byte order mark (BOM) in output CSV files. Currently, only \"UTF-8\" is supported. It defaults to ' '.\n\n#### Details\n\nSave DolphinDB variables or data queried by SQL statement as a text file on disk. Compared with [saveTable](https://docs.dolphindb.com/en/Functions/s/saveTable.html), `saveText` requires more disk space and time.\n\n#### Examples\n\n*Example 1*\n\n```\nn=20000000\nsyms=`IBM`C`MS`MSFT`JPM`ORCL`GE`EBAY`GOOG`FORD`GS\ntimestamp=09:30:00+rand(18000,n)\nsym=rand(syms,n)\nqty=100*(1+rand(100,n))\nprice=5.0+rand(100.0,n)\nt1=table(timestamp,sym,qty,price);\n\ntimer saveText(t1, \"c:/test/trades.txt\");\n// output\nTime elapsed: 191488 ms\n```\n\n*Example 2*\n\n```\nn=100\nt1=table(1..n as id, rand(1000, n) as x)\nsaveText(t1, \"C:/DolphinDB/Data/t.csv\",,1)\nt2=table((n+1)..(2*n) as id, rand(1000, n) as x)\nsaveText(t2, \"C:/DolphinDB/Data/t.csv\",,1)\nt = loadText(\"C:/DolphinDB/Data/t.csv\")\nselect count(*) from t;\n// output\n200\n```\n\n*Example 3* Save a DFS table as a text file\n\n```\nif(existsDatabase(\"dfs://testdb\")){\n\n  dropDatabase(\"dfs://testdb\")\n}\nn=3000\nticker = rand(`MSFT`GOOG`FB`ORCL`IBM`PPT`AZH`ILM`ANZ,n);\nid = rand(`A`B`C, n)\nx=rand(1.0, n)\nt=table(ticker, id, x)\ndb=database(directory=\"dfs://testdb\", partitionType=HASH, partitionScheme=[STRING, 5])\npt = db.createPartitionedTable(t, `pt, `ticker)\npt.append!(t)\n\nsaveText(<select * from pt>, \"/home/data/pt.txt\")\n```\n"
    },
    "saveTextFile": {
        "url": "https://docs.dolphindb.com/en/Functions/s/saveTextFile.html",
        "signatures": [
            {
                "full": "saveTextFile(content, filename, [append=false], [lastModified])",
                "name": "saveTextFile",
                "parameters": [
                    {
                        "full": "content",
                        "name": "content"
                    },
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[append=false]",
                        "name": "append",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[lastModified]",
                        "name": "lastModified",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [saveTextFile](https://docs.dolphindb.com/en/Functions/s/saveTextFile.html)\n\n\n\n#### Syntax\n\nsaveTextFile(content, filename, \\[append=false], \\[lastModified])\n\n#### Arguments\n\n**content** is the contents to be written into the file.\n\n**filename** is a string indicating the absolute path and name of the output file. Currently the output file can only be saved in *.csv* format.\n\n**append** (optional) is a Boolean flag. True means appending while false means overwriting.\n\n**lastModified** (optional) is the previously modified time displayed in epoch time format.\n\n#### Details\n\nSave strings to a file by appending or overwriting. It must be executed by a logged-in user.\n\n#### Examples\n\n```\nsaveTextFile(\"1234567890\\n0987654321\\nabcdefghijk\\n\", \"/home/test/abc.txt\", false, 1495762562671l);\n\n// output\n[content of file \"/home/test/abc.txt\"]\n1234567890\n0987654321\nabcdefghijk\n```\n"
    },
    "scheduleJob": {
        "url": "https://docs.dolphindb.com/en/Functions/s/scheduleJob.html",
        "signatures": [
            {
                "full": "scheduleJob(jobId, jobDesc, jobFunc, scheduleTime, startDate, endDate, frequency, [days], [onComplete], [priority], [parallelism])",
                "name": "scheduleJob",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    },
                    {
                        "full": "jobDesc",
                        "name": "jobDesc"
                    },
                    {
                        "full": "jobFunc",
                        "name": "jobFunc"
                    },
                    {
                        "full": "scheduleTime",
                        "name": "scheduleTime"
                    },
                    {
                        "full": "startDate",
                        "name": "startDate"
                    },
                    {
                        "full": "endDate",
                        "name": "endDate"
                    },
                    {
                        "full": "frequency",
                        "name": "frequency"
                    },
                    {
                        "full": "[days]",
                        "name": "days",
                        "optional": true
                    },
                    {
                        "full": "[onComplete]",
                        "name": "onComplete",
                        "optional": true
                    },
                    {
                        "full": "[priority]",
                        "name": "priority",
                        "optional": true
                    },
                    {
                        "full": "[parallelism]",
                        "name": "parallelism",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [scheduleJob](https://docs.dolphindb.com/en/Functions/s/scheduleJob.html)\n\n\n\n#### Syntax\n\nscheduleJob(jobId, jobDesc, jobFunc, scheduleTime, startDate, endDate, frequency, \\[days], \\[onComplete], \\[priority], \\[parallelism])\n\n#### Arguments\n\n**jobId** is a string indicating the job ID.\n\n**jobDesc** is a string indicating the job description.\n\n**jobFunc** is a function with no parameters. It is usually a partial application. Note that if the *jobFunc* is a user-defined function, it can only take scalars, pairs or regular vectors as default parameters.\n\n**scheduleTime** is a scalar/vector of MINUTE type. The minimum time interval to execute the next task is 5 minutes.\n\n**startDate** is a scalar of DATE type.\n\n**endDate** is a scalar of DATE type.\n\n**frequency** is of CHAR type. It can take one of the following 3 values: 'D' for daily, 'W' for weekly, and 'M' for monthly.\n\n**days** (optional) is an integer scalar/vector indicating which day(s) of a week or a month to run the scheduled job. This optional parameter is required if frequency=W or M. If frequency=W, days can take the following values: 0 (Sunday), 1 (Monday), ...., 5 (Firday), 6 (Saturday).\n\n**onComplete** (optional) is a callback function with 4 parameters. For details please refer to the last example below. After the scheduled job is executed (even if an error occurs), the callback function is executed. It can be used to send out emails regarding the execution.\n\n**priority** (optional) is an integer from 0 to 8 indicating the priority of the job. The default value is 4.\n\n**parallelism** (optional) is an integer from 0 to 8 indicating the maximum number of workers allocated to the job. The default value is 2.\n\n**Note**: The *priority* and *parallelism* of the job are limited by the maximum values (*maxPriority*and *maxParallelism*) set by [setMaxJobPriority](https://docs.dolphindb.com/en/Functions/s/setMaxJobPriority.html) and [setMaxJobParallelism](https://docs.dolphindb.com/en/Functions/s/setMaxJobParallelism.html), respectively. The final priority and parallelism are `min(priority, maxPriority)` and `min(parallelism, maxParallelism)`.\n\n#### Details\n\nExecute a job at specified time and with specified *frequency*. Return the job ID of the scheduled job. If *jobId* is different from the job IDs of all the existing scheduled jobs, the system returns *jobId*. Otherwise, append suffix of the current date, or \"000\", \"001\", ..... or both to *jobId* until a unique scheduled job ID is found. Please use [getRecentJobs](https://docs.dolphindb.com/en/Functions/g/getRecentJobs.html) to view the recently finished scheduled jobs.\n\nThe messages produced in the execution of the scheduled job are saved in *jobId.msg*; if the scheduled job returns any value, it is saved in *jobId.object*. *jobId.msg* and *jobId.object* are saved under the folder of *batchJobs*. We can use functions [getJobMessage](https://docs.dolphindb.com/en/Functions/g/getJobMessage.html) and [getJobReturn](https://docs.dolphindb.com/en/Functions/g/getJobReturn.html) to view these 2 files respectively.\n\n#### Examples\n\nSchedule to run a function:\n\n```\ndef f():1+2;\nscheduleJob(jobId=`daily, jobDesc=\"Daily Job 1\", jobFunc=f, scheduleTime=17:23m, startDate=2018.01.01, endDate=2018.12.31, frequency='D');\nscheduleJob(jobId=`weekly, jobDesc=\"Weekly Job\", jobFunc=f, scheduleTime=17:30m, startDate=2018.01.01, endDate=2018.12.31, frequency='W', days=2);\n```\n\nSchedule to run a script:\n\n```\nscheduleJob(jobId=`monthly, jobDesc=\"Monthly Job 1\", jobFunc=run{\"monthlyJob.dos\"}, scheduleTime=17:23m, startDate=2018.01.01, endDate=2018.12.31, frequency='M', days=1);\n```\n\nHere we use a partial application run{\\<script>} as this parameter needs to be a function with no arguments.\n\n```\ngetJobMessage(`daily);\n\n018-02-08 17:23:27.166296 Start the job [daily]: Daily Job 1\n\n018-02-08 17:23:27.167303 The job is done.\n\n\n getJobReturn(`daily);\n\n\n```\n\nWe can schedule to run the same job multiple times a day:\n\n```\nscheduleJob(jobId=`Trading, jobDesc=\"Generate Trading Tickets\", jobFunc=run{\"TradingTickets.dos\"}, scheduleTime=[09:25m, 12:00m, 02:00m, 15:50m], startDate=2018.01.01, endDate=2018.12.31, frequency='D');\n```\n\nIn this case, each time this scheduled job is executed, the job ID is different. The job IDs for the first day is \"Trading\", \"Trading20180101000\", \"Trading001\", \"Trading002\" for the first day, and \"Trading003\", \"Trading004\", \"Trading005\", \"Trading006\" for the second day, etc.\n\nTo run the same job multiple times a day only on weekdays:\n\n```\nscheduleJob(jobId=`PnL, jobDesc=\"Calculate Profit & Loss\", jobFunc=run{\"PnL.dos\"}, scheduleTime=[12:00m, 02:00m, 14:50m], startDate=2018.01.01, endDate=2018.12.31, frequency='W', days=[1,2,3,4,5]);\n```\n\nSend an email after the execution of the scheduled job. Please install the HttpClient plugin before running the following script.\n\n```\ndef sendEmail(jobId, jobDesc, success, result){\n  desc = \"jobId=\" + jobId + \" jobDesc=\" + jobDesc\n  if(success){\n  desc += \" successful \" + result\n    res = httpClient::sendEmail('patrick.mahomes@dolphindb.com','password','andy.reid@dolphindb.com','This is a subject',desc)\n  }\n  else{\n  desc += \" with error: \" + result\n    res = httpClient::sendEmail('patrick.mahomes@dolphindb.com','password','andy.reid@dolphindb.com','This is a subject',desc)\n  }\n}\nscheduleJob(jobId=`PnL, jobDesc=\"Calculate Profit & Loss\", jobFunc=run{\"PnL.dos\"}, scheduleTime=[12:00m, 02:00m, 14:50m], startDate=2018.01.01, endDate=2018.12.31, frequency='W', days=[1,2,3,4,5], onComplete=sendEmail);\n```\n"
    },
    "schema": {
        "url": "https://docs.dolphindb.com/en/Functions/s/schema.html",
        "signatures": [
            {
                "full": "schema(table|dbHandle)",
                "name": "schema",
                "parameters": [
                    {
                        "full": "table|dbHandle",
                        "name": "table|dbHandle"
                    }
                ]
            }
        ],
        "markdown": "### [schema](https://docs.dolphindb.com/en/Functions/s/schema.html)\n\n\n\n#### Syntax\n\nschema(table|dbHandle)\n\n#### Arguments\n\n**table | dbHandle** can be a table object or a database handle.\n\n#### Details\n\nDisplay information about the schema of a table or a database. The function returns an unordered dictionary containing the following information (in alphabetical order):\n\n* atomic: the level at which the atomicity is guaranteed for a write transaction. It can be TRANS or CHUNK.\n* chunkGranularity: the chunk granularity which determines whether to allow concurrent writes to different tables in the same chunk. It can be TABLE or DATABASE.\n* clusterReplicationEnabled: whether asynchronous replication has been enabled.\n* colDefs: information about each column in the table:\n  * name: column name\n  * typeString: column type\n  * typeInt: the type ID\n  * extra: the scale of a DECIMAL value\n  * comment: comment on the column\n* compressMethods: the compression methods used for specified columns of a DFS table.\n  * name: Column names\n  * compressMethods: Compression algorithm applied, including \"lz4\", \"delta\", or \"zstd\".\n* databaseDir: the directory where the database is stored.\n* databaseOwner: the database creator.\n* engineType: the storage engine type. It can be OLAP or TSDB.\n* keepDuplicates: how to deal with records with duplicate sort key values.\n* partitionColumnIndex: the index that indicates the positions of partitioning columns. It returns -1 for a dimension table.\n* partitionColumnName: the partitioning column names.\n* partitionColumnType: the data type ID (which can be checked at Data Types and Data Forms) of the partitioning column.\n* partitionSchema: how the partitions are organized\n* partitionSites (optional): If the parameter locations is specified for function `database`, it displays the ip:port information of the specified node.\n* partitionTypeName / partitionType: the partitioning scheme and the corresponding ID, including VALUE(1), RANGE(2), LIST(3), COMPO(4), HASH(5).\n* sortColumns: the sort columns for a table.\n* softDelete: whether soft deletion of the table has been enabled. This field will only be returned for tables in TSDB databases. Return true if soft deletion has been enabled, false otherwise.\n* sortKeyMappingFunction: the mapping functions applied to sort keys.\n* tableComment: the comment for DFS tables.\n* tableOwner: the table creator.\n* partitionFunction: the function applied to a column for data partitioning. It is a STRING vector with each element as a function signature. If an element is \"asis\", meaning no function is applied to that column. For example, `partitionFunction->[\"myPartitionFunc{, 6, 8}\",\"asis\"]`.\n\n#### Examples\n\nOLAP database:\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x)\ndb=database(\"dfs://rangedb101\", RANGE, 0 5 10)\npt = db.createPartitionedTable(t, `pt, `ID)\npt.append!(t)\npt=loadTable(db,`pt);\n\nschema(db);\n// output\ndatabaseDir->dfs://rangedb101\npartitionSchema->[0,5,10]\npartitionSites->\natomic->TRANS\nchunkGranularity->TABLE\npartitionType->2\npartitionTypeName->RANGE\npartitionColumnType->4\nclusterReplicationEnabled->1\ndatabaseOwner->admin\n```\n\nOLAP table:\n\n```\nschema(pt);\n// output\nchunkGranularity->TABLE\ntableOwner->admin\ncompressMethods->\nname compressMethods\n---- ---------------\nID   lz4            \nx    lz4            \n\ncolDefs->\nname typeString typeInt comment\n---- ---------- ------- -------\nID   INT        4              \nx    DOUBLE     16             \n\nchunkPath->\npartitionColumnIndex->0\npartitionColumnName->ID\npartitionColumnType->4\npartitionType->2\npartitionTypeName->RANGE\npartitionSchema->[0,5,10]\npartitionSites->\n```\n\nTSDB database:\n\n```\nn = 10000\nSecurityID = rand(`st0001`st0002`st0003`st0004`st0005, n)\nsym = rand(`A`B, n)\nTradeDate = 2022.01.01 + rand(100,n)\nTotalVolumeTrade = rand(1000..3000, n)\nTotalValueTrade = rand(100.0, n)\nschemaTable_snap = table(SecurityID, TradeDate, TotalVolumeTrade, TotalValueTrade).sortBy!(`SecurityID`TradeDate)\n\ndbPath = \"dfs://TSDB_STOCK\"\nif (existsDatabase(dbPath)){dropDatabase(dbPath)}\ndb_snap = database(dbPath, VALUE, 2022.01.01..2022.01.05, engine='TSDB')\n\nschema(db_snap)\n// output\ndatabaseDir->dfs://TSDB_STOCK\npartitionSchema->[2022.01.01,2022.01.02,2022.01.03,2022.01.04,2022.01.05]\npartitionSites->\nengineType->TSDB\natomic->TRANS\nchunkGranularity->TABLE\npartitionType->1\npartitionTypeName->VALUE\npartitionColumnType->6\nclusterReplicationEnabled->1\ndatabaseOwner->admin\n```\n\nTSDB table:\n\n```\ndef myHashFunc(x){\n  return hashBucket(x, 10)\n}\nsnap=createPartitionedTable(dbHandle=db_snap, table=schemaTable_snap, tableName=\"snap\", partitionColumns=`TradeDate, sortColumns=`SecurityID`TradeDate, keepDuplicates=ALL, sortKeyMappingFunction=[myHashFunc])\n\nschema(snap)\n// output\nengineType->TSDB\nkeepDuplicates->ALL\nchunkGranularity->TABLE\nsortColumns->[\"SecurityID\",\"TradeDate\"]\nsortKeyMappingFunction->[\"def myHashFunc(x){\n  return hashBucket(x, 10)\n}\"]\nsoftDelete->0\ntableOwner->admin\ncompressMethods->\nname             compressMethods\n---------------- ---------------\nSecurityID       lz4            \nTradeDate        lz4            \nTotalVolumeTrade lz4            \nTotalValueTrade  lz4            \n\ncolDefs->\nname             typeString typeInt extra comment\n---------------- ---------- ------- ----- -------\nSecurityID       SYMBOL     17                   \nTradeDate        DATE       6                    \nTotalVolumeTrade INT        4                    \nTotalValueTrade  DOUBLE     16                   \n\nchunkPath->\npartitionColumnIndex->1\npartitionColumnName->TradeDate\npartitionColumnType->6\npartitionType->1\npartitionTypeName->VALUE\npartitionSchema->[2022.01.01,2022.01.02,2022.01.03,2022.01.04,2022.01.05]\npartitionSites->\n```\n"
    },
    "schur": {
        "url": "https://docs.dolphindb.com/en/Functions/s/schur.html",
        "signatures": [
            {
                "full": "schur(obj, [sort])",
                "name": "schur",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[sort]",
                        "name": "sort",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [schur](https://docs.dolphindb.com/en/Functions/s/schur.html)\n\n\n\n#### Syntax\n\nschur(obj, \\[sort])\n\n#### Arguments\n\n**obj** is a square matrix.\n\n**sort** (optional) is a string. It is used to reorder the factors according to a specified ordering of the eigenvalues. The value can be 'lhp' (eigenvalue is a negative real number), 'rhp' (eigenvalue is a positive real number), 'iuc' (the absolute value of a complex eigenvalue<=1.0), 'ouc' (the absolute value of a complex eigenvalue>1.0).\n\n#### Details\n\nCompute the Schur decomposition of a square matrix.\n\nSuppose the input is the square matrix A:\n\n* If *sort* is not specified, return 2 matrices: T (Schur form of A, an upper triangular matrix) and an unitary matrix Z (the transpose matrix of Z is equal to its inverse matrix), so that A = Z\\*T\\*Z-1.\n* If *sort* is specified, the function will also return an integer indicating the number of eigenvalues that meet the sorting conditions.\n\n#### Examples\n\n```\nm=matrix([[0,0,1],[2,1,0],[2,2,1]]);\nT,Z=schur(m)\nT;\n```\n\n| #0       | #1        | #2        |\n| -------- | --------- | --------- |\n| 2.658967 | 1.424405  | -1.929334 |\n| 0        | -0.329484 | -0.490637 |\n| 0        | 1.311789  | -0.329484 |\n\n```\nZ\n```\n\n| #0       | #1        | #2        |\n| -------- | --------- | --------- |\n| 0.727116 | -0.601562 | 0.330796  |\n| 0.528394 | 0.798019  | 0.289768  |\n| 0.438294 | 0.035904  | -0.898114 |\n\n```\nT,Z,s=schur(m, 'lhp');\nT;\n```\n\n| #0        | #1        | #2        |\n| --------- | --------- | --------- |\n| -0.329484 | 1.570974  | 2.251318  |\n| -0.40969  | -0.329484 | -0.092398 |\n| 0         | 0         | 2.658967  |\n\n```\nZ\n```\n\n| #0        | #1        | #2       |\n| --------- | --------- | -------- |\n| 0.703818  | -0.632169 | 0.324042 |\n| 0.509043  | 0.766983  | 0.390655 |\n| -0.495495 | -0.109999 | 0.861618 |\n\n```\ns\n// output\n2\nT,Z,s=schur(m, 'rhp');\n\ns;\n// output\n1\n\nm=matrix([[0,0,9],[-2,1,0],[2,2,1]]);\nT,Z,s=schur(m, 'iuc');\ns;\n// output\n0\n\nT,Z,s=schur(m, 'ouc');\ns;\n// output\n1\n```\n"
    },
    "scs": {
        "url": "https://docs.dolphindb.com/en/Functions/s/scs.html",
        "signatures": [
            {
                "full": "scs(f, [P], [A], [b], [Aeq], [beq], [lb], [ub], [x0], [c], [eps], [alpha])",
                "name": "scs",
                "parameters": [
                    {
                        "full": "f",
                        "name": "f"
                    },
                    {
                        "full": "[P]",
                        "name": "P",
                        "optional": true
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[b]",
                        "name": "b",
                        "optional": true
                    },
                    {
                        "full": "[Aeq]",
                        "name": "Aeq",
                        "optional": true
                    },
                    {
                        "full": "[beq]",
                        "name": "beq",
                        "optional": true
                    },
                    {
                        "full": "[lb]",
                        "name": "lb",
                        "optional": true
                    },
                    {
                        "full": "[ub]",
                        "name": "ub",
                        "optional": true
                    },
                    {
                        "full": "[x0]",
                        "name": "x0",
                        "optional": true
                    },
                    {
                        "full": "[c]",
                        "name": "c",
                        "optional": true
                    },
                    {
                        "full": "[eps]",
                        "name": "eps",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [scs](https://docs.dolphindb.com/en/Functions/s/scs.html)\n\n\n\n#### Syntax\n\nscs(f, \\[P], \\[A], \\[b], \\[Aeq], \\[beq], \\[lb], \\[ub], \\[x0], \\[c], \\[eps], \\[alpha])\n\n#### Details\n\nSolve the following optimization problem for the objective function with given constraints:\n\n![](https://docs.dolphindb.com/en/images/scs01.png)\n\nThe result is a 2-element tuple. The first element is the minimum value of the objective function. The second element is the value of x when the value of the objective function is minimized.\n\n#### Arguments\n\n**Note:** Among the following parameters, only *lb* and *ub* can be empty, while all other parameters must not contain NULL values.\n\n**f** is a vector of coefficients for linear terms in the quadratic programming problem. It must be of the same length as *x0*.\n\n**P** (optional) is a matrix obtained by multiplying the diagonal elements of the coefficient matrix for quadratic terms by 2. For example, to obtain matrix p, form an upper triangular matrix based on all the quadratic terms:\n\n![](https://docs.dolphindb.com/en/images/scs02.png)\n\n**A** (optional) is a coefficient matrix for linear inequality constraints. Its number of columns must be consistent with the size of x.\n\n**b** (optional) is the right-hand vector for linear inequality constraints.\n\n**Aeq** (optional) is a coefficient matrix for linear equality constraints. Its number of columns must be consistent with the size of x.\n\n**beq** (optional) is the right-hand vector for linear equality constraints.\n\n**lb** / **ub** (optional) is a scalar or a vector of the same length as x, specifying the lower/upper bounds for variables.\n\n* If *lb* or *ub* is a scalar, all variables are subject to the same lower or upper bound constraints. If *lb* or *ub* is NULL, there are no lower or upper bound constraints for x.\n\n* If *lb* or *ub* is a vector, the elements of x are subject to the corresponding elements of *lb* or *ub*. If a certain element in lb or ub is NULL, the corresponding element in x has no lower or upper bound constraint.\n\n**x0** (optional) is a vector of coefficients for absolute value inequality constraints.\n\n**c** (optional) is a non-negative number representing the right-hand constant for absolute value inequality constraints.\n\n**eps** (optional) is a positive floating-point number representing the solution precision. The default value is 1e-6, and the range is \\[1e-4, 1e-9]. A solution with higher precision can be obtained by decreasing eps. If a value beyond the range is set, it will be adjusted to the default value.\n\n**alpha** (optional) is a positive floating-point number representing the relaxation parameter. The default value is 1.5, and the range is (0,2). The solution process can be sped up by increasing alpha. If a value beyond the range is set, it will be adjusted to the default value.\n\n#### Examples\n\nFind x and y that satisfy the following constraints and minimize the objective function x2 + y2:\n\n![](https://docs.dolphindb.com/en/images/scs03.png)\n\n```\n// No linear terms in the objective function, so all coefficients are 0, and f takes the following values\nf = [0, 0];\n// Only quadratic terms x^2 and y^2 exist with coefficients as 1, so p takes the following values\nP = [2, 0, 0, 2]$2:2;\n// Coefficients and right-hand vector for absolute value inequality constraints\nx0 = [0.4, 0.6];\nc = 0.5;\n// Linear equality constraint x + y = 1, so Aeq and beq take the following values\nAeq = [1, 1]$1:2;\nbeq = [1];\n// Since x, y > 0, we have lower bounds for variables as follows:\nlb = [0, 0];\nre = scs(f=f,P=P,Aeq=Aeq,beq=beq,lb=lb,x0=x0,c=c);\nre[1]\n// output\n[0.500000043984074,0.499999955746447]\n```\n\nRelated functions: [linprog](https://docs.dolphindb.com/en/Functions/l/linprog.html), [quadprog](https://docs.dolphindb.com/en/Functions/q/quadprog.html)\n"
    },
    "searchK": {
        "url": "https://docs.dolphindb.com/en/Functions/s/searchK.html",
        "signatures": [
            {
                "full": "searchK(X, k)",
                "name": "searchK",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "k",
                        "name": "k"
                    }
                ]
            }
        ],
        "markdown": "### [searchK](https://docs.dolphindb.com/en/Functions/s/searchK.html)\n\n\n\n#### Syntax\n\nsearchK(X, k)\n\n#### Arguments\n\n**X** is a vector.\n\n**k** is an integer indicating the k-th smallest item.\n\n#### Details\n\nReturn the k-th smallest item ignoring NULL values.\n\n#### Examples\n\n```\nsearchK(1 7 3 5 3 9 6 1 NULL, 1);\n// output\n1\n\nsearchK(1 7 3 5 3 9 6 1 NULL, 2);\n// output\n1\n\nsearchK(1 7 3 5 3 9 6 1 NULL, 3);\n// output\n3\n```\n"
    },
    "seasonalEsd": {
        "url": "https://docs.dolphindb.com/en/Functions/s/seasonalEsd.html",
        "signatures": [
            {
                "full": "seasonalEsd(data, period, [hybrid], [maxAnomalies], [alpha])",
                "name": "seasonalEsd",
                "parameters": [
                    {
                        "full": "data",
                        "name": "data"
                    },
                    {
                        "full": "period",
                        "name": "period"
                    },
                    {
                        "full": "[hybrid]",
                        "name": "hybrid",
                        "optional": true
                    },
                    {
                        "full": "[maxAnomalies]",
                        "name": "maxAnomalies",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [seasonalEsd](https://docs.dolphindb.com/en/Functions/s/seasonalEsd.html)\n\n\n\n#### Syntax\n\nseasonalEsd(data, period, \\[hybrid], \\[maxAnomalies], \\[alpha])\n\n#### Arguments\n\n**data** is a numeric vector.\n\n**period** is an integer larger than 1 indicating the length of a time-series cycle.\n\n**hybrid** (optional) is a Boolean value indicating whether to use median and median absolute deviation to replace mean and standard deviation. The results are more robust if *hybrid*=true. The default value is false.\n\n**maxAnomalies** (optional) is a positive integer or a floating number between 0 and 0.5. The default value is 0.1.\n\n* If *maxAnomalies* is a positive integer, it must be smaller than the size of data. It indicates the upper bound of the number of anomalies.\n\n* If *maxAnomalies* is a floating number between 0 and 0.5, the upper bound of the number of anomalies is int(size(*data*) \\* *maxAnomalies*).\n\n**alpha** (optional) alpha is a positive number indicating the significance level of the statistical test. A larger alpha means a higher likelihood of detecting anomalies.\n\n#### Details\n\nConduct anomaly detection with the Seasoned Extreme Studentized Deviate test (S-ESD).\n\nThe result is a table of anomalies. It has 2 columns: column index records the subscript of anomalies in data, and column anoms are the anomaly values.\n\n#### Examples\n\n```\nn = 100\ntrend = 6 * sin(1..n \\ 200)\nseasonal = sin(pi / 6 * 1..n)\nresidual = rand(1.0, n) - 0.5\ndata = trend + seasonal + residual\ndata[20 50 70] += 20;\n\nseasonalEsd(data, 12);\n```\n\n| index | anoms     |\n| ----- | --------- |\n| 50    | 22.6365   |\n| 70    | 21.141346 |\n| 20    | 19.174165 |\n"
    },
    "second": {
        "url": "https://docs.dolphindb.com/en/Functions/s/second.html",
        "signatures": [
            {
                "full": "second(X)",
                "name": "second",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [second](https://docs.dolphindb.com/en/Functions/s/second.html)\n\n\n\n#### Syntax\n\nsecond(X)\n\n#### Arguments\n\n**X** is an integer or temporal scalar/vector.\n\n#### Details\n\nReturn the corresponding second(s).\n\n#### Examples\n\n```\nsecond 2012.12.03 01:22:01;\n// output\n01:22:01\n\nsecond(61);\n// output\n00:01:01\n```\n"
    },
    "secondOfMinute": {
        "url": "https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html",
        "signatures": [
            {
                "full": "secondOfMinute(X)",
                "name": "secondOfMinute",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [secondOfMinute](https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html)\n\n\n\n#### Syntax\n\nsecondOfMinute(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type TIME, SECOND, DATETIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP.\n\n#### Details\n\nFor each element in *X*, return a number from 0 to 59 indicating which second of the minute it falls in.\n\n#### Examples\n\n```\nsecondOfMinute(12:32:00);\n// output\n0\n\nsecondOfMinute([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n// output\n[0,0,47,14]\n```\n"
    },
    "seek": {
        "url": "https://docs.dolphindb.com/en/Functions/s/seek.html",
        "signatures": [
            {
                "full": "seek(handle, offset, [mode])",
                "name": "seek",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "offset",
                        "name": "offset"
                    },
                    {
                        "full": "[mode]",
                        "name": "mode",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [seek](https://docs.dolphindb.com/en/Functions/s/seek.html)\n\n\n\n#### Syntax\n\nseek(handle, offset, \\[mode])\n\n#### Arguments\n\n**handle** must be a file handle.\n\n**offset** is an integer.\n\n**mode** (optional) must be one of the 3 positions: HEAD, CURRENT, TAIL. Default mode is CURRENT.\n\n#### Details\n\nReturn the final position of the internal cursor if no exception is raised.\n\nWhen the system reads data from a file or writes data to a file, the internal cursor moves forward. Users can manipulate the cursor manually with the `seek` function.\n\n#### Examples\n\n```\n//  write a function to show the length of a file\ndef fileLength(f): file(f).seek(0, TAIL)\nfileLength(\"test.txt\");\n// output\n14\n\n// move the internal cursor to the beginning of the file\nfin=file(\"test.txt\")\nfin.readLine();\n// output\nHello World!\n\nfin.seek(0, HEAD);\n// output\n0\n\nfin.readLine();\n// output\nHello World!\n```\n"
    },
    "segment": {
        "url": "https://docs.dolphindb.com/en/Functions/s/segment.html",
        "signatures": [
            {
                "full": "segment(X, [segmentOffset=true])",
                "name": "segment",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[segmentOffset=true]",
                        "name": "segmentOffset",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [segment](https://docs.dolphindb.com/en/Functions/s/segment.html)\n\n\n\n#### Syntax\n\nsegment(X, \\[segmentOffset=true])\n\n#### Arguments\n\n**X** is a vector.\n\n**segmentOffset** (optional) is a Boolean value. The default value is true.\n\n#### Details\n\nDivide a vector into groups. Each group is composed of identical values next to each other. For example, \\[1,1,2,2,1,1,1] is divided into 3 groups: \\[1,1], \\[2,2] and \\[1,1,1].\n\nReturn a vector of the same length as *X*.\n\n* If *segmentOffset*=true, each element of the result is the index(in *X*) of the first element in each group.\n* If *segmentOffset*=false, each element of the result is its group number. Group numbers start from 0.\n\n#### Examples\n\nExample 1.\n\n```\nx = 1 1 2 4 4 5 2 5 NULL NULL\nsegment(x);\n// output\n[0,0,2,3,3,5,6,7,8,8]\n\nsegment(x, false);\n// output\n[0,0,1,2,2,3,4,5,6,6]\n```\n\nExample 2.\n\n```\nx = 1 2 1 2 1 2 1 2 1 2 1 2;\ny = 0 0 1 1 1 2 2 1 1 3 3 2;\nt = table(x,y);\nselect *, cumsum(x) from t context by segment(y);\n```\n\n| y | x | cumsum\\_x |\n| - | - | --------- |\n| 0 | 1 | 1         |\n| 0 | 2 | 3         |\n| 1 | 1 | 1         |\n| 1 | 2 | 3         |\n| 1 | 1 | 4         |\n| 2 | 2 | 2         |\n| 2 | 1 | 3         |\n| 1 | 2 | 2         |\n| 1 | 1 | 3         |\n| 3 | 2 | 2         |\n| 3 | 1 | 3         |\n| 2 | 2 | 2         |\n"
    },
    "sem": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sem.html",
        "signatures": [
            {
                "full": "sem(X)",
                "name": "sem",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sem](https://docs.dolphindb.com/en/Functions/s/sem.html)\n\n\n\n#### Syntax\n\nsem(X)\n\n#### Arguments\n\n**X** is a numeric vector/matrix/table.\n\n#### Details\n\nReturn unbiased (normalized by N-1) standard error of the mean over *X* .\n\n* If *X* is a matrix, calculate the standard error for each column and return a vector.\n\n* If *X* is a table, calculate the standard error of each column and return a table.\n\n#### Examples\n\n```\n[1,4,9,10,20,32].sem();\n// output\n4.688046\n\n[1,4,9,10,NULL,20,32].sem();\n// output\n4.688046\n```\n"
    },
    "semiMonthBegin": {
        "url": "https://docs.dolphindb.com/en/Functions/s/semiMonthBegin.html",
        "signatures": [
            {
                "full": "semiMonthBegin(X, [dayOfMonth=15], [offset], [n=1])",
                "name": "semiMonthBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[dayOfMonth=15]",
                        "name": "dayOfMonth",
                        "optional": true,
                        "default": "15"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [semiMonthBegin](https://docs.dolphindb.com/en/Functions/s/semiMonthBegin.html)\n\n\n\n#### Syntax\n\nsemiMonthBegin(X, \\[dayOfMonth=15], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**dayOfMonth** (optional) is an integer between 2 and 27. The default value is 15.\n\n**offset** (optional) is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the first day of the semi-month that *X* belongs to. Suppose *X* is the d-th day of the month:\n\n* If d < *dayOfMonth*: return the first day of the month.\n\n* If d >= *dayOfMonth*: return the *dayOfMonth*-th day of the month.\n\nIf parameter *offset* is specified, the result is updated every n semi-months. Parameter *offset* works only if parameter n>1.\n\n#### Examples\n\n```\nsemiMonthBegin(2012.06.12);\n// output\n2012.06.01\n\nsemiMonthBegin(2012.06.24);\n// output\n2012.06.15\n\nsemiMonthBegin(2012.06.15);\n// output\n2012.06.15\n\nsemiMonthBegin(2012.06.16, 16);\n// output\n2012.06.16\n\n\ndate=2016.04.07+(1..10)*7\ntime = take(09:30:00, 10);\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2016.04.14 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2016.04.21 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2016.04.28 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2016.05.05 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.05.12 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2016.05.19 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2016.05.26 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2016.06.02 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2016.06.09 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2016.06.16 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by semiMonthBegin(date);\n```\n\n| semiMonthBegin\\_date | avg\\_price | sum\\_qty |\n| -------------------- | ---------- | -------- |\n| 2016.04.01           | 49.6       | 2200     |\n| 2016.04.15           | 29.49      | 4000     |\n| 2016.05.01           | 102.495    | 10000    |\n| 2016.05.15           | 112.995    | 6700     |\n| 2016.06.01           | 50.805     | 11300    |\n| 2016.06.15           | 52.38      | 4500     |\n"
    },
    "semiMonthEnd": {
        "url": "https://docs.dolphindb.com/en/Functions/s/semiMonthEnd.html",
        "signatures": [
            {
                "full": "semiMonthEnd(X, [dayOfMonth=15], [offset], [n=1])",
                "name": "semiMonthEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[dayOfMonth=15]",
                        "name": "dayOfMonth",
                        "optional": true,
                        "default": "15"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [semiMonthEnd](https://docs.dolphindb.com/en/Functions/s/semiMonthEnd.html)\n\n\n\n#### Syntax\n\nsemiMonthEnd(X, \\[dayOfMonth=15], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**dayOfMonth** (optional) is an integer between 2 and 27. The default value is 15.\n\n**offset** (optional) is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nSuppose *X* is the d-th day of the month:\n\n* If d < *dayOfMonth*: return the last day of the previous month.\n\n* If d >= *dayOfMonth*: return the *dayOfMonth*-th day of the current month.\n\nIf parameter *offset* is specified, the result is updated every n semi-months. Parameter *offset* works only if parameter n>1.\n\n#### Examples\n\n```\nsemiMonthEnd(2012.06.12);\n// output\n012.05.31\n\nsemiMonthEnd(2012.06.24);\n// output\n012.06.15\n\n\nsemiMonthEnd(2012.06.15);\n// output\n012.06.15\n\nsemiMonthEnd(2012.06.16, 16);\n// output\n012.06.16\n\n\ndate=2016.04.07+(1..10)*7\ntime = take(09:30:00, 10);\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2016.04.14 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2016.04.21 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2016.04.28 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2016.05.05 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.05.12 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2016.05.19 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2016.05.26 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2016.06.02 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2016.06.09 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2016.06.16 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by semiMonthEnd(date);\n```\n\n| semiMonthEnd\\_date | avg\\_price | sum\\_qty |\n| ------------------ | ---------- | -------- |\n| 2016.03.31         | 49.6       | 2200     |\n| 2016.04.15         | 29.49      | 4000     |\n| 2016.04.30         | 102.495    | 10000    |\n| 2016.05.15         | 112.995    | 6700     |\n| 2016.05.31         | 50.805     | 11300    |\n| 2016.06.15         | 52.38      | 4500     |\n"
    },
    "seq": {
        "url": "https://docs.dolphindb.com/en/Functions/s/seq.html",
        "signatures": [
            {
                "full": "seq(start, end)",
                "name": "seq",
                "parameters": [
                    {
                        "full": "start",
                        "name": "start"
                    },
                    {
                        "full": "end",
                        "name": "end"
                    }
                ]
            }
        ],
        "markdown": "### [seq](https://docs.dolphindb.com/en/Functions/s/seq.html)\n\n\n\n#### Syntax\n\nseq(start, end) or start..end\n\n#### Arguments\n\n**start** and **end** must be integers.\n\n#### Details\n\nReturn a sequence with start at beginning and end in the end. The step between two consecutive items is 1.\n\n#### Examples\n\n```\nx=0..3;\nx;\n// output\n[0,1,2,3]\n\n1..3+1;\n// output\n[2,3,4]\n\n11..1;\n// output\n[11,10,9,8,7,6,5,4,3,2,1]\n\nseq(3,1);\n// output\n[3,2,1]\n\n2015.01M..2015.12M;\n// output\n[2015.01M,2015.02M,2015.03M,2015.04M,2015.05M,2015.06M,2015.07M,2015.08M,2015.09M,2015.10M,2015.11M,2015.12M]\n\n2016.01.01..2016.01.07;\n// output\n[2016.01.01,2016.01.02,2016.01.03,2016.01.04,2016.01.05,2016.01.06,2016.01.07]\n```\n"
    },
    "sessionWindow": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sessionWindow.html",
        "signatures": [
            {
                "full": "sessionWindow(X, sessionGap)",
                "name": "sessionWindow",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "sessionGap",
                        "name": "sessionGap"
                    }
                ]
            }
        ],
        "markdown": "### [sessionWindow](https://docs.dolphindb.com/en/Functions/s/sessionWindow.html)\n\n#### Syntax\n\nsessionWindow(X, sessionGap)\n\n#### Arguments\n\n**X** is an integral or temporal vector.\n\n**sessionGap** is a positive integer indicating the gap between two sessions. Its unit is the same as the time precision of *X*.\n\n#### Details\n\nThe first session window starts at the first non-NULL value of *X*. Sequentially check whether the difference between each element in *X* and its previous adjacent element is less than *sessionGap*. If the difference is less than *sessionGap*, the session window remains open. Otherwise, the session window ends and a new session window is started from the current element. The value of the first element in each session window is used as its identifier. This function returns the identifier of the session window to which each element in *X* belongs.\n\n**Note:**\n\n* For NULL values in *X*: If the first element of *X* is NULL, a NULL value is returned; otherwise, it returns the identifier of the window to which the previous non-null element belongs.\n\n* For out-of-order data: It will not be involved in the comparison and the identifier of the current window is returned directly.\n\n#### Examples\n\n```\nx = 1 5 6 12 13 13 15\nsessionWindow(x, 5)\n// output\n[1,1,1,12,12,12,12]\ny = 2012.06.13 2012.06.15 2012.06.19 2012.06.26 2012.06.28\nsessionWindow(y, 5)\n// output\n[2012.06.13,2012.06.13,2012.06.13,2012.06.26,2012.06.26]\n```\n\nIn the following example, for the elements 3 and 7 in the second session window (identifier 12), it returns 12 directly. The subsequent element 15 belongs to window 12 (as 15-12 < 4).\n\n```\nx = [, , 1, 12, 3, 7, 15, 19]\nsessionWindow(x, 4)\n// output\n[,,1,12,12,12,12,12,12,19]\n```\n\n```\ncolTime = 2023.06.01T10:00:00.000 + 1 2 3 4 5 6 7 8 9 21 22 23 28 29 30\ncolSym = take(`A`B`C,15)\ncolVolume = [2,1,5,5,2,3,2,3,2,2,5,5,2,7,2]\nt = table(colTime as time, colSym as sym, colVolume as volume)\nt\n```\n\n| time                    | sym | volume |\n| ----------------------- | --- | ------ |\n| 2023.06.01 10:00:00.001 | A   | 2      |\n| 2023.06.01 10:00:00.002 | B   | 1      |\n| 2023.06.01 10:00:00.003 | C   | 5      |\n| 2023.06.01 10:00:00.004 | A   | 5      |\n| 2023.06.01 10:00:00.005 | B   | 2      |\n| 2023.06.01 10:00:00.006 | C   | 3      |\n| 2023.06.01 10:00:00.007 | A   | 2      |\n| 2023.06.01 10:00:00.008 | B   | 3      |\n| 2023.06.01 10:00:00.009 | C   | 2      |\n| 2023.06.01 10:00:00.021 | A   | 2      |\n| 2023.06.01 10:00:00.022 | B   | 5      |\n| 2023.06.01 10:00:00.023 | C   | 5      |\n| 2023.06.01 10:00:00.028 | A   | 2      |\n| 2023.06.01 10:00:00.029 | B   | 7      |\n| 2023.06.01 10:00:00.030 | C   | 2      |\n\nThe following example uses the higher-order function `contextby` to group the data based on \"sym\". Within each group, calculate the sum of the volumes in each session window. In this case, `sessionWinodow` uses partial application and its first argument is fixed to column \"time\".\n\n```\nselect sum(volume) from t group by contextby(sessionWindow{, 5}, time, sym) as time,sym\n```\n\n| time                    | sym | sum\\_volume |\n| ----------------------- | --- | ----------- |\n| 2023.06.01 10:00:00.001 | A   | 9           |\n| 2023.06.01 10:00:00.002 | B   | 6           |\n| 2023.06.01 10:00:00.003 | C   | 10          |\n| 2023.06.01 10:00:00.021 | A   | 2           |\n| 2023.06.01 10:00:00.022 | B   | 5           |\n| 2023.06.01 10:00:00.023 | C   | 5           |\n| 2023.06.01 10:00:00.028 | A   | 2           |\n| 2023.06.01 10:00:00.029 | B   | 7           |\n| 2023.06.01 10:00:00.030 | C   | 2           |\n\n"
    },
    "set": {
        "url": "https://docs.dolphindb.com/en/Functions/s/set.html",
        "signatures": [
            {
                "full": "set(X)",
                "name": "set",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [set](https://docs.dolphindb.com/en/Functions/s/set.html)\n\n\n\n#### Syntax\n\nset(X)\n\n#### Arguments\n\n**X** is a vector\n\n#### Details\n\nReturn the corresponding set object of vector *X* .\n\n#### Examples\n\nFunction `set` returns a set.\n\n```\nx=set(4 5 5 2 3 11 6);\nx;\n// output\nset(6,11,3,2,5,4)\n\nx.intersection(set([2,5,9]));\n// output\nset(2,5)\n```\n\nIn comparison, function [distinct](https://docs.dolphindb.com/en/Functions/d/distinct.html) returns a vector.\n\n```\ndistinct(4 5 5 2 3 11 6);\n// output\n[6,11,3,2,5,4]\n```\n\nUse function keys to convert sets to vectors:\n\n```\nx=set(4 5 5 2 3 11 6);\nx.keys()\n// output\n[6,11,3,2,5,4]\n```\n"
    },
    "setAtomicLevel": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setAtomicLevel.html",
        "signatures": [
            {
                "full": "setAtomicLevel(dbHandle, atomic)",
                "name": "setAtomicLevel",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "atomic",
                        "name": "atomic"
                    }
                ]
            }
        ],
        "markdown": "### [setAtomicLevel](https://docs.dolphindb.com/en/Functions/s/setAtomicLevel.html)\n\n\n\n#### Syntax\n\nsetAtomicLevel(dbHandle, atomic)\n\n#### Arguments\n\n**dbHandle** is a distributed database handle returned by function [database](https://docs.dolphindb.com/en/Functions/d/database.html).\n\n**atomic** indicates at which level the atomicity is guaranteed for a write transaction, thus determining whether concurrent writes to the same chunk are allowed. It can be 'TRANS' or 'CHUNK' and the default value is 'TRANS'.\n\n* 'TRANS' indicates that the atomicity is guaranteed at the transaction level. If a transaction attempts to write to multiple chunks and one of the chunks is locked by another transaction, a write-write conflict occurs, and all writes of the transaction fail. Therefore, setting *atomic* ='TRANS' means concurrent writes to a chunk are not allowed.\n\n* 'CHUNK' indicates that the atomicity is guaranteed at the chunk level. If a transaction tries to write to multiple chunks and a write-write conflict occurs as a chunk is locked by another transaction, instead of aborting the writes, the transaction will keep writing to the non-locked chunks and keep attempting to write to the chunk in conflict until it is still locked after a few minutes. Therefore, setting *atomic* ='CHUNK' means concurrent writes to a chunk are allowed. As the atomicity at the transaction level is not guaranteed, the write operation may succeed in some chunks but fail in other chunks. Please also note that the write speed may be impacted by the repeated attempts to write to the chunks that are locked.\n\n#### Details\n\nTo manually specify at which level concurrent writes are allowed in a distributed database.\n\n#### Examples\n\n```\ndbPath=\"dfs://test\"\nmydb=database(dbPath, VALUE, ['AMZN','NFLX', 'NVDA'])\nmydb.schema()\n\n// output\ndatabaseDir->dfs://test\npartitionSchema->[NVDA,AMZN,NFLX]\npartitionSites->\npartitionTypeName->VALUE\npartitionType->1\natomic->TRANS\n\nsetAtomicLevel(mydb, `CHUNK)\nmydb.schema()\n\n// output\ndatabaseDir->dfs://test\npartitionSchema->[NVDA,AMZN,NFLX]\npartitionSites->\npartitionTypeName->VALUE\npartitionType->1\natomic->CHUNK\n```\n"
    },
    "setCacheEngineMemSize": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setCacheEngineMemSize.html",
        "signatures": [
            {
                "full": "setCacheEngineMemSize(memSize)",
                "name": "setCacheEngineMemSize",
                "parameters": [
                    {
                        "full": "memSize",
                        "name": "memSize"
                    }
                ]
            }
        ],
        "markdown": "### [setCacheEngineMemSize](https://docs.dolphindb.com/en/Functions/s/setCacheEngineMemSize.html)\n\n\n\n#### Syntax\n\nsetCacheEngineMemSize(memSize)\n\n#### Arguments\n\n**memSize** is a numeric scalar (in GB). It must be greater than 0 and less than *maxMemSize* \\* 0.75.\n\n#### Details\n\nModify the capacity of the OLAP cache engine online. In a cluster, this command can only be executed by the admin on a data node or compute node. Please make sure the cache engine is enabled by specifying configuration parameter *chunkCacheEngineMemSize* before execution.\n\n* Scenario: If the cache engine is enabled, the system will first write the data to the cache. Only when the amount of cached data reaches 30% of *chunkCacheEngineMemSize* will it be written to disk. If the configuration parameter is set too low, massive concurrent writes may take up the cache engine capacity quickly and cause the writing process stuck. In this case, execute the command to online modify the cache engine capacity to ensure that the writes continue.\n\n* You can obtain the real-time status of the cache engine with function `getOLAPCacheEngineSize` to check if the modification takes effect online.\n\n**Note:**\n\nThe modified configuration will expire after the cluster is rebooted. To make it permanent, please change the configuration parameter *chunkCacheEngineMemSize*.\n\nRelated function: [getOLAPCacheEngineSize](https://docs.dolphindb.com/en/Functions/g/getOLAPCacheEngineSize.html)\n"
    },
    "setColumnarTuple!": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setColumnarTuple!.html",
        "signatures": [
            {
                "full": "setColumnarTuple!(X, [on=true])",
                "name": "setColumnarTuple!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[on=true]",
                        "name": "on",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [setColumnarTuple!](https://docs.dolphindb.com/en/Functions/s/setColumnarTuple!.html)\n\n#### Syntax\n\nsetColumnarTuple!(X, \\[on=true])\n\n#### Arguments\n\n**X** is a tuple of vectors or scalars of the same type.\n\n**on** is a Boolean value indicating the conversion between tuple and columnar tuple. The default value is true, indicating the conversion from tuple to columnar tuple; False indicates the opposite operation.\n\n#### Details\n\nThis function is used for the conversion between tuple and columnar tuple.\n\n#### Examples\n\n```\ntp = [[1,2,3], [4,5,6], [7,8]]\nisColumnarTuple(tp)\n// output\nfalse\n\ntp.setColumnarTuple!()\nisColumnarTuple(tp)\n// output\ntrue\n \nt = table(1..5 as id, [`a`a,`b`a,`c, `f`e, `g] as val)\nisColumnarTuple(t.val)\n// output\ntrue\n\nt1 = t.val.setColumnarTuple!(false)\nisColumnarTuple(t1)\n// output\nfalse\n```\n\n"
    },
    "setColumnComment": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setColumnComment.html",
        "signatures": [
            {
                "full": "setColumnComment(table, columnComments)",
                "name": "setColumnComment",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "columnComments",
                        "name": "columnComments"
                    }
                ]
            }
        ],
        "markdown": "### [setColumnComment](https://docs.dolphindb.com/en/Functions/s/setColumnComment.html)\n\n\n\n#### Syntax\n\nsetColumnComment(table, columnComments)\n\n#### Arguments\n\n**table** is a DFS tableor MVCC table.\n\n**columnComments** is a dictionary. Its keys are table columns and values are comments for each column.\n\n#### Details\n\nAdd comments to columns of a DFS tableor an MVCC table. Use function [schema](https://docs.dolphindb.com/en/Functions/s/schema.html) to view column comments.\n\n#### Examples\n\n```\nn=1000000\nsym=rand(`A`B`C`D`E`F,n)\ndate=rand(2019.06.01..2019.06.10,n)\nopen=rand(100.0,n)\nhigh=rand(200.0,n)\nclose=rand(200.0,n)\npre_close=rand(200.0,n)\nchange=rand(100.0,n)\nvol=rand(10000,n)\namount=rand(100000.0,n)\nt=table(sym,date,open,high,close,pre_close,change,vol,amount);\n\ndb1=database(\"\",VALUE,2019.06.01..2019.06.10)\ndb2=database(\"\",VALUE,`A`B`C`D`E`F)\ndb=database(\"dfs://db1\",COMPO,[db1,db2])\npt=db.createPartitionedTable(t,`pt,`date`sym).append!(t);\n\nsetColumnComment(pt,{sym:\"stock ticker\", date:\"trading date\", open:\"open price\", high:\"highest price\", low:\"lowest price\", close:\"close price\", vol:\"trading volume (shares)\", amount:\"trading volume (dollar)\"})\nschema(pt).colDefs;\n```\n\n| name   | typeString | typeInt | comment                 |\n| ------ | ---------- | ------- | ----------------------- |\n| sym    | SYMBOL     | 17      | stock ticker            |\n| date   | DATE       | 6       | trading date            |\n| open   | DOUBLE     | 16      | open price              |\n| high   | DOUBLE     | 16      | highest price           |\n| close  | DOUBLE     | 16      | close price             |\n| vol    | INT        | 4       | trading volume (shares) |\n| amount | DOUBLE     | 16      | trading volume (dollar) |\n\n```\nid=`XOM`GS`AAPL\nx=102.1 33.4 73.6\nmt = mvccTable(id, x);\nsetColumnComment(mt, {id:\"identifier\"})\nschema(mt).colDefs\n```\n\n| name | typeString | typeInt | extra | comment    |\n| ---- | ---------- | ------- | ----- | ---------- |\n| id   | STRING     | 18      |       | identifier |\n| x    | DOUBLE     | 16      |       |            |\n"
    },
    "setDatabaseClusterReplicationExecutionSet": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setDatabaseClusterReplicationExecutionSet.html",
        "signatures": [
            {
                "full": "setDatabaseClusterReplicationExecutionSet(dbHandle, executionSet)",
                "name": "setDatabaseClusterReplicationExecutionSet",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "executionSet",
                        "name": "executionSet"
                    }
                ]
            }
        ],
        "markdown": "### [setDatabaseClusterReplicationExecutionSet](https://docs.dolphindb.com/en/Functions/s/setDatabaseClusterReplicationExecutionSet.html)\n\n\n\n#### Syntax\n\nsetDatabaseClusterReplicationExecutionSet(dbHandle, executionSet)\n\n#### Arguments\n\n**dbHandle** is the database handle for which to set the execution set.\n\n**executionSet** is an integer 0 or 1, representing the execution set. When asynchronous replication is enabled for the database, the default execution set is 0.\n\n#### Details\n\nSet the execution set for asynchronous replication tasks of a database. Tasks within an execution set are executed sequentially. Different execution sets are isolated and executed in parallel. This function can only be executed by an administrator on the data nodes of the master cluster for databases that have asynchronous replication enabled.\n\n#### Examples\n\n```\nsetDatabaseClusterReplicationExecutionSet(dbHandle=database(\"dfs://test\"), executionSet=1)\n```\n"
    },
    "setDatabaseForClusterReplication": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setDatabaseForClusterReplication.html",
        "signatures": [
            {
                "full": "setDatabaseForClusterReplication(dbHandle, option)",
                "name": "setDatabaseForClusterReplication",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "option",
                        "name": "option"
                    }
                ]
            }
        ],
        "markdown": "### [setDatabaseForClusterReplication](https://docs.dolphindb.com/en/Functions/s/setDatabaseForClusterReplication.html)\n\n#### Syntax\n\nsetDatabaseForClusterReplication(dbHandle, option)\n\n#### Arguments\n\n**dbHandle** is a database handle.\n\n**option** is a Boolean value indicating whether to enable asynchronous replication on the specified database. The default value is false.\n\n#### Details\n\nThis command enables/disables asynchronous replication on the specified database. It can only be executed on the data node of the master cluster.\n\nRelated functions: [getDatabaseClusterReplicationStatus](https://docs.dolphindb.com/en/Functions/g/getDatabaseClusterReplicationStatus.html)\n\n"
    },
    "setDatanodeRestartInterval": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setdatanoderestartinterval.html",
        "signatures": [
            {
                "full": "setDatanodeRestartInterval(interval)",
                "name": "setDatanodeRestartInterval",
                "parameters": [
                    {
                        "full": "interval",
                        "name": "interval"
                    }
                ]
            }
        ],
        "markdown": "### [setDatanodeRestartInterval](https://docs.dolphindb.com/en/Functions/s/setdatanoderestartinterval.html)\n\n\n\n#### Syntax\n\nsetDatanodeRestartInterval(interval)\n\n#### Arguments\n\n**interval** is a non-negative integer (in seconds).\n\n#### Details\n\nModify *datanodeRestartInterval* online. This command can only be executed by an administrator on the controller.\n\n* If *interval*=0, the controller will not automatically restart the data/compute node.\n\n* If *interval*>0, the controller will restart the data/compute node after *datanodeRestartInterval* of offline time.\n\n**Note:** The modified configuration is only valid for the current node, and will expire after the system restarts. To make it permanent, please change the configuration parameter *datanodeRestartInterval.*\n\nRelated function: [getDatanodeRestartInterval](https://docs.dolphindb.com/en/Functions/g/getdatanoderestartinterval.html)\n"
    },
    "setDefaultCatalog": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setDefaultCatalog.html",
        "signatures": [
            {
                "full": "setDefaultCatalog(catalog)",
                "name": "setDefaultCatalog",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    }
                ]
            }
        ],
        "markdown": "### [setDefaultCatalog](https://docs.dolphindb.com/en/Functions/s/setDefaultCatalog.html)\n\n#### Syntax\n\nsetDefaultCatalog(catalog)\n\n#### Arguments\n\n**catalog** is a string specifying the catalog name. An empty string (\"\") means no default catalog is used.\n\n#### Details\n\nSet a default catalog for the current session. After setting a default catalog, you can refer to databases and tables without specifying the catalog name explicitly.\n\n#### Examples\n\n```\ncreateCatalog(\"cat1\")\nsetDefaultCatalog(\"cat1\")\ngetCurrentCatalog()\n// output: cat1\n\nsetDefaultCatalog(\"\")\ngetCurrentCatalog()\n// NULL\n```\n\n"
    },
    "setDynamicConfig": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setDynamicConfig.html",
        "signatures": [
            {
                "full": "setDynamicConfig(configName, configValue)",
                "name": "setDynamicConfig",
                "parameters": [
                    {
                        "full": "configName",
                        "name": "configName"
                    },
                    {
                        "full": "configValue",
                        "name": "configValue"
                    }
                ]
            }
        ],
        "markdown": "### [setDynamicConfig](https://docs.dolphindb.com/en/Functions/s/setDynamicConfig.html)\n\n#### Syntax\n\nsetDynamicConfig(configName, configValue)\n\n#### Arguments\n\n**configName** is a STRING scalar indicating the name of configuration parameter to be modified.\n\n**configValue** is a scalar indicating the new value to be set.\n\n#### Details\n\nModify the specified configuration parameter online.\n\n**Note:** The modified configuration is only valid for the current node, and will expire after the system restarts. To make it permanent, please change the configuration parameter in configuration file\\*.\\*\n\nThe following are supported configuration parameters (for detailed usage, see [Configuration](https://docs.dolphindb.com/en/Database/Configuration/configuration.html)):\n\n*enableMultiThreadMerge*, *logLevel*, *maxBlockSizeForReservedMemory*, *maxConnections*, *memLimitOfQueryResult*, *memLimitOfTaskGroupResult*, *maxMemSize*, *maxPartitionNumPerQuery*, *memLimitOfTempResult*, *OLAPCacheEngineSize*, *recoveryWorkers*, *reservedMemSize*,*dfsChunkNodeHeartBeatTimeout*, *TSDBCacheEngineSize*, *TSDBVectorIndexCacheSize*, *memLimitOfAllTempResults*.\n\n#### Examples\n\n```\ngetDynamicConfig();\n// output: [\"recoveryWorkers\",\"OLAPCacheEngineSize\",\"memLimitOfAllTempResults\",\"memLimitOfTempResult\",\"dfsChunkNodeHeartBeatTimeout\",\"maxPartitionNumPerQuery\",\"TSDBCacheEngineSize\",\"memLimitOfTaskGroupResult\",\"memLimitOfQueryResult\",\"maxConnections\",\"maxBlockSizeForReservedMemory\",\"logLevel\",\"reservedMemSize\",\"maxMemSize\",\"enableMultiThreadMerge\"]\n```\n\nRelated functions: [getDynamicConfig](https://docs.dolphindb.com/en/Functions/g/getDynamicConfig.html)\n\n"
    },
    "setGpFitnessFunc": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setGpFitnessFunc.html",
        "signatures": [
            {
                "full": "setGpFitnessFunc(engine, func)",
                "name": "setGpFitnessFunc",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    }
                ]
            }
        ],
        "markdown": "### [setGpFitnessFunc](https://docs.dolphindb.com/en/Functions/s/setGpFitnessFunc.html)\n\n**Note:** This function is not supported by Community Edition. You can [get a trial](https://dolphindb.com/product#downloads-down) of Shark from DolphinDB official website.\n\n#### Syntax\n\nsetGpFitnessFunc(engine, func)\n\n#### Arguments\n\n**engine** is the engine object returned by `createGPLearnEngine`.\n\n**func** is the fitness function, which can be:\n\n* A FUNCTIONDEF scalar, specifying a built-in function supported by *fitnessFunc*of `createGPLearnEngine`. It must be 'mse', 'rmse', 'pearson', 'spearmanr', or 'mae'.\n\n* A user-defined function with a floating-point return value. It takes two input arguments, the first represents the factor calculation result, and the second represents the predicted value. Currently it does not support complex assignment, `if` or `for` statement. Only `return` statement can be used to return a combination of the supported fitness function and the training function. For example:\n\n  ```\n  def f(x, y){\n    return mse(x+y,y)\n  }\n  ```\n\n  A user-defined fitness function can be combined with a helper function (as shown below) to pre-process the data before calculation.\n\n  | Function                   | Num of Args |\n  | -------------------------- | ----------- |\n  | clip(X,Y,Z)                | 3           |\n  | zscore(x)                  | 1           |\n  | mad(X, \\[useMedian=false]) | 1           |\n  | med(x)                     | 1           |\n  | mean(x)                    | 1           |\n  | corr(X,Y)                  | 2           |\n\n#### Details\n\nSet fitness function for the GPLearn engine.\n\n#### Examples\n\nSet fitness function for the GPLearn engine.\n\n```\ndef f(x, y){\n  return mse(x+y,y)\n}\nsetGpFitnessFunc(engine,f)\n```\n\n"
    },
    "setIndexedMatrix!": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setIndexedMatrix!.html",
        "signatures": [
            {
                "full": "setIndexedMatrix!(X, [on=true])",
                "name": "setIndexedMatrix!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[on=true]",
                        "name": "on",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [setIndexedMatrix!](https://docs.dolphindb.com/en/Functions/s/setIndexedMatrix!.html)\n\n\n\n#### Syntax\n\nsetIndexedMatrix!(X, \\[on=true])\n\n#### Arguments\n\n**X** is a matrix with row labels and column labels. Row labels and column labels must be monotonically increasing with no duplicate values.\n\n**on** (optional) is a Boolean value indicating the conversion between a matrix and an indexed matrix. The default value is true, indicating the conversion from a matrix to an indexed matrix. Set to false for the opposite conversion.\n\n#### Details\n\nSet the labels of the rows and columns of a matrix as the indexes.\n\n#### Examples\n\n```\nm=matrix(1..5, 11..15)\nm.rename!(2020.01.01..2020.01.05, `A`B)\nm.setIndexedMatrix!();\n```\n\n|            | A | B  |\n| ---------- | - | -- |\n| 2020.01.01 | 1 | 11 |\n| 2020.01.02 | 2 | 12 |\n| 2020.01.03 | 3 | 13 |\n| 2020.01.04 | 4 | 14 |\n| 2020.01.05 | 5 | 15 |\n"
    },
    "setIndexedSeries!": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setIndexedSeries!.html",
        "signatures": [
            {
                "full": "setIndexedSeries!(X, [on=true])",
                "name": "setIndexedSeries!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[on=true]",
                        "name": "on",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [setIndexedSeries!](https://docs.dolphindb.com/en/Functions/s/setIndexedSeries!.html)\n\n\n\n#### Syntax\n\nsetIndexedSeries!(X, \\[on=true])\n\n#### Arguments\n\n**X** is a matrix with row labels and only one column. The row labels must be monotonically increasing with no duplicate values.\n\n**on** (optional) is a Boolean value indicating the conversion between a matrix and an indexed series. The default value is true, indicating the conversion from a matrix to an indexed series. Set to false for the opposite conversion.\n\n#### Details\n\nConvert a single column matrix with row labels into an indexed series.\n\n#### Examples\n\n```\ns = matrix(1..10).rename!(2012.01.01..2012.01.10, ).setIndexedSeries!();\ns;\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2012.01.01 | 1  |\n| 2012.01.02 | 2  |\n| 2012.01.03 | 3  |\n| 2012.01.04 | 4  |\n| 2012.01.05 | 5  |\n| 2012.01.06 | 6  |\n| 2012.01.07 | 7  |\n| 2012.01.08 | 8  |\n| 2012.01.09 | 9  |\n| 2012.01.10 | 10 |\n"
    },
    "setLogLevel": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setLogLevel.html",
        "signatures": [
            {
                "full": "setLogLevel(logLevel)",
                "name": "setLogLevel",
                "parameters": [
                    {
                        "full": "logLevel",
                        "name": "logLevel"
                    }
                ]
            }
        ],
        "markdown": "### [setLogLevel](https://docs.dolphindb.com/en/Functions/s/setLogLevel.html)\n\n\n\n#### Syntax\n\nsetLogLevel(logLevel)\n\n#### Arguments\n\n**logLevel** indicates the log level. The optional values from low to high are: DEBUG, INFO, WARNING, and ERROR.\n\n#### Details\n\nSet the log level on the current node online. After setting the log level, only logs at and above the specified *logLevel* are printed.\n\nThe command can only be executed by an administrator.\n"
    },
    "setMaxBlockSizeForReservedMemory": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setMaxBlockSizeForReservedMemory.html",
        "signatures": [
            {
                "full": "setMaxBlockSizeForReservedMemory(blockSizeKB)",
                "name": "setMaxBlockSizeForReservedMemory",
                "parameters": [
                    {
                        "full": "blockSizeKB",
                        "name": "blockSizeKB"
                    }
                ]
            }
        ],
        "markdown": "### [setMaxBlockSizeForReservedMemory](https://docs.dolphindb.com/en/Functions/s/setMaxBlockSizeForReservedMemory.html)\n\n\n\n#### Syntax\n\nsetMaxBlockSizeForReservedMemory(blockSizeKB)\n\n#### Arguments\n\n**blockSizeKB** is a positive integer or floating-point number (in KB).\n\n#### Details\n\nModify the maximum reserved memory allocated to a DolphinDB block online. This command can only be executed by the admin on the data node.\n\n**Note:** The modified configuration is only valid for the current node, and will expire after the system restarts. To make it permanent, please change the configuration parameter *maxBlockSizeForReservedMemory*.\n"
    },
    "setMaxConnections": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setMaxConnections.html",
        "signatures": [
            {
                "full": "setMaxConnections(newValue)",
                "name": "setMaxConnections",
                "parameters": [
                    {
                        "full": "newValue",
                        "name": "newValue"
                    }
                ]
            }
        ],
        "markdown": "### [setMaxConnections](https://docs.dolphindb.com/en/Functions/s/setMaxConnections.html)\n\n#### Syntax\n\nsetMaxConnections(newValue)\n\n#### Arguments\n\n**newValue** is a positive integer smaller than 2^16 (65536).\n\n#### Details\n\nModify the maximum number of connections to the current node online. This command can only be executed by an administrator.\n\nYou can check if the modification is successful from the field *maxConnections* returned by executing function [getClusterPerf](https://docs.dolphindb.com/en/Functions/g/getClusterPerf.html) on the controller.\n\n**Note:**\n\n* The value specified by *newValue* must be greater than the current maximum number of connections, otherwise, it cannot take effect.\n\n* The modified configuration will expire after the cluster is rebooted. To make it permanent, change the configuration parameter *maxConnections*.\n\n* The function `getClusterPerf` has a delay in getting the node information.\n\n"
    },
    "setMaxJobParallelism": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setMaxJobParallelism.html",
        "signatures": [
            {
                "full": "setMaxJobParallelism(userId, maxParallelism)",
                "name": "setMaxJobParallelism",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    },
                    {
                        "full": "maxParallelism",
                        "name": "maxParallelism"
                    }
                ]
            }
        ],
        "markdown": "### [setMaxJobParallelism](https://docs.dolphindb.com/en/Functions/s/setMaxJobParallelism.html)\n\n\n\n#### Syntax\n\nsetMaxJobParallelism(userId, maxParallelism)\n\n#### Arguments\n\n**userId** is a string indicating a user name.\n\n**maxParallelism** is an integer between 1 and 64.\n\n#### Details\n\nSpecify the maximum number of subjobs that can be concurrently executed for the jobs submitted by the user. It must be executed by a logged-in user.\n\nIf the function is not executed, the default value of *maxParallelism* is 64 for an administrator and 2 for a non-admin user.\n\n#### Examples\n\n```\nlogin(`admin,`123456)\ncreateUser(`ElonMusk, `superman)\nsetMaxJobParallelism(`ElonMusk, 64);\n```\n"
    },
    "setMaxJobPriority": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setMaxJobPriority.html",
        "signatures": [
            {
                "full": "setMaxJobPriority(userId, maxPriority)",
                "name": "setMaxJobPriority",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    },
                    {
                        "full": "maxPriority",
                        "name": "maxPriority"
                    }
                ]
            }
        ],
        "markdown": "### [setMaxJobPriority](https://docs.dolphindb.com/en/Functions/s/setMaxJobPriority.html)\n\n\n\n#### Syntax\n\nsetMaxJobPriority(userId, maxPriority)\n\n#### Arguments\n\n**userId** is a string indicating a user name.\n\n**maxPriority** is an integer between 0 and 8.\n\n#### Details\n\nSpecify the highest priority of the jobs submitted by the user. It can only be executed by an administrator.\n\n#### Examples\n\n```\nlogin(`admin,`123456)\ncreateUser(`KyleMurray, `Cardinals2020QB)\nsetMaxJobPriority(`KyleMurray, 7);\n```\n"
    },
    "setMaxMemSize": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setMaxMemSize.html",
        "signatures": [
            {
                "full": "setMaxMemSize(memSizeGB)",
                "name": "setMaxMemSize",
                "parameters": [
                    {
                        "full": "memSizeGB",
                        "name": "memSizeGB"
                    }
                ]
            }
        ],
        "markdown": "### [setMaxMemSize](https://docs.dolphindb.com/en/Functions/s/setMaxMemSize.html)\n\n\n\n#### Syntax\n\nsetMaxMemSize(memSizeGB)\n\n#### Arguments\n\n**memSizeGB** is a numeric scalar (in GB). It is greater than 0 but no greater than *maxMemoryPerNode* (specified by DolphinDB license), which can be checked with function `license`. Otherwise an error will be raised.\n\n#### Details\n\nModify the maximum memory (in GB) allocated to DolphinDB online. This command can only be executed by the administrator. Call `getClusterPerf().maxMemSize` to check if the modification has taken effect.\n\n**Note:**\n\nThe modified configuration will expire after the cluster is rebooted. To make it permanent, please change the configuration parameter *maxMemSize*.\n"
    },
    "setMemLimitOfAllTempResults": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setMemLimitOfAllTempResults.html",
        "signatures": [
            {
                "full": "setMemLimitOfAllTempResults(memLimit)",
                "name": "setMemLimitOfAllTempResults",
                "parameters": [
                    {
                        "full": "memLimit",
                        "name": "memLimit"
                    }
                ]
            }
        ],
        "markdown": "### [setMemLimitOfAllTempResults](https://docs.dolphindb.com/en/Functions/s/setMemLimitOfAllTempResults.html)\n\n\n\n#### Syntax\n\nsetMemLimitOfAllTempResults(memLimit)\n\n#### Arguments\n\n**memLimit** is a positive number smaller than configured *maxMemSize*.\n\n#### Details\n\nModify *memLimitOfAllTempResults*online. This command can only be executed by an administrator on the data node or compute node.\n\n**Note:** The modified configuration is only valid for the current node, and will expire after the system restarts. To make it permanent, please change the configuration parameter *memLimitOfAllTempResults.*\n\n#### Examples\n\n```\n`setMemLimitOfAllTempResults(3.0)`\n```\n"
    },
    "setMemLimitOfQueryResult": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setMemLimitOfQueryResult.html",
        "signatures": [
            {
                "full": "setMemLimitOfQueryResult(memLimit)",
                "name": "setMemLimitOfQueryResult",
                "parameters": [
                    {
                        "full": "memLimit",
                        "name": "memLimit"
                    }
                ]
            }
        ],
        "markdown": "### [setMemLimitOfQueryResult](https://docs.dolphindb.com/en/Functions/s/setMemLimitOfQueryResult.html)\n\n\n\n#### Syntax\n\nsetMemLimitOfQueryResult(memLimit)\n\n#### Arguments\n\n**memLimit** is a numeric scalar, indicating the memory limit (in GB). It must be smaller than smaller than 80% \\* *maxMemSize*.\n\n#### Details\n\nSet the memory limit for the result of each query online. This command can only be executed by an administrator on a data node or compute node.\n\n**Note:**\n\nThe modified configuration will expire after the cluster is rebooted. To make it permanent, please specify the configuration parameter *memLimitOfQueryResult*.\n\nRelated function: [getMemLimitOfQueryResult](https://docs.dolphindb.com/en/Functions/g/getMemLimitOfQueryResult.html)\n"
    },
    "setMemLimitOfTaskGroupResult": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setMemLimitOfTaskGroupResult.html",
        "signatures": [
            {
                "full": "setMemLimitOfTaskGroupResult(memLimit)",
                "name": "setMemLimitOfTaskGroupResult",
                "parameters": [
                    {
                        "full": "memLimit",
                        "name": "memLimit"
                    }
                ]
            }
        ],
        "markdown": "### [setMemLimitOfTaskGroupResult](https://docs.dolphindb.com/en/Functions/s/setMemLimitOfTaskGroupResult.html)\n\n\n\n#### Syntax\n\nsetMemLimitOfTaskGroupResult(memLimit)\n\n#### Arguments\n\n**memLimit** is a numeric scalar, indicating the memory limit (in GB).\n\n#### Details\n\nSet the memory limit of a task group sent from the current node online. This command can only be executed by an administrator on a data node or compute node.\n\n**Note:**\n\nThe modified configuration will expire after the cluster is rebooted. To make it permanent, please specify the configuration parameter *memLimitOfTaskGroupResult*.\n\nRelated function: [getMemLimitOfTaskGroupResult](https://docs.dolphindb.com/en/Functions/g/getMemLimitOfTaskGroupResult.html)\n"
    },
    "setMemLimitOfTempResult": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setMemLimitOfTempResult.html",
        "signatures": [
            {
                "full": "setMemLimitOfTempResult(X)",
                "name": "setMemLimitOfTempResult",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [setMemLimitOfTempResult](https://docs.dolphindb.com/en/Functions/s/setMemLimitOfTempResult.html)\n\n\n\n#### Syntax\n\nsetMemLimitOfTempResult(X)\n\n#### Arguments\n\n**X** is a positive number that is no greater than *maxMemSize*.\n\n#### Details\n\nModifies the upper limit of memory usage (in GB) for each temporary result generated during a table join operation. It can only be executed by an administrator on a data node or compute node.\n\n**Note:**\n\nThe modified configuration will expire after the cluster is rebooted. To make it permanent, please change the configuration parameter *memLimitOfTempResult*.\n"
    },
    "setOLAPCacheEngineSize": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setOLAPCacheEngineSize.html",
        "signatures": [
            {
                "full": "setOLAPCacheEngineSize(memSize)",
                "name": "setOLAPCacheEngineSize",
                "parameters": [
                    {
                        "full": "memSize",
                        "name": "memSize"
                    }
                ]
            }
        ],
        "markdown": "### [setOLAPCacheEngineSize](https://docs.dolphindb.com/en/Functions/s/setOLAPCacheEngineSize.html)\n\n\n\n#### Syntax\n\nsetOLAPCacheEngineSize(memSize)\n\nAlias: setCacheEngineMemSize\n\n#### Arguments\n\n**memSize** is a numeric scalar (in GB). It must be greater than 0 and less than *maxMemSize* \\* 0.75.\n\n#### Details\n\nModify the capacity of the OLAP cache engine online. In a cluster, this command can only be executed by the admin on a data node or compute node. Please make sure the cache engine is enabled by specifying configuration parameter *chunkCacheEngineMemSize* before execution.\n\n* Scenario: If the cache engine is enabled, the system will first write the data to the cache. Only when the amount of cached data reaches 30% of *chunkCacheEngineMemSize* will it be written to disk. If the configuration parameter is set too low, massive concurrent writes may take up the cache engine capacity quickly and cause the writing process stuck. In this case, execute the command to online modify the cache engine capacity to ensure that the writes continue.\n\n* You can obtain the real-time status of the cache engine with function `getOLAPCacheEngineSize` to check if the modification takes effect online.\n\n**Note:**\n\nThe modified configuration will expire after the cluster is rebooted. To make it permanent, please change the configuration parameter *chunkCacheEngineMemSize*.\n\nRelated function: [getOLAPCacheEngineSize](https://docs.dolphindb.com/en/Functions/g/getOLAPCacheEngineSize.html)\n"
    },
    "setRaftElectionTick": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setRaftElectionTick.html",
        "signatures": [
            {
                "full": "setRaftElectionTick(groupId, tickCount)",
                "name": "setRaftElectionTick",
                "parameters": [
                    {
                        "full": "groupId",
                        "name": "groupId"
                    },
                    {
                        "full": "tickCount",
                        "name": "tickCount"
                    }
                ]
            }
        ],
        "markdown": "### [setRaftElectionTick](https://docs.dolphindb.com/en/Functions/s/setRaftElectionTick.html)\n\n\n\n#### Syntax\n\nsetRaftElectionTick(groupId, tickCount)\n\n#### Arguments\n\n**groupId** is a positive integer indicating the raft group ID. Currently it can only be 1, referring to the ID of the raft group composed of controllers.\n\n**tickCount** is an integer no less than 800 (in 10ms).\n\n#### Details\n\nUse this command to dynamically set the configuration parameter *raftElectionTick*. *tickCount* specifies a time interval: \\[*tickCount*, 2\\**tickCount*]. After receiving the last heartbeat from the leader, if a follower does not receive the next heartbeat after a random waiting time within the specified interval, it will send a request for leader election.\n\n**Note:**\n\n* The command must be executed by the admin on all controllers within a raft group, please make sure that they all share the same *raftElectionTick* value.\n\n* The command will not modify the configuration parameter *raftElectionTick*. It will restore to the default or specified value after the server restarts.\n\nRelated Functions: [getRaftElectionTick](https://docs.dolphindb.com/en/Functions/g/getRaftElectionTick.html), [getControllerElectionTick](https://docs.dolphindb.com/en/Functions/g/getControllerElectionTick.html)\n"
    },
    "setRandomSeed": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setRandomSeed.html",
        "signatures": [
            {
                "full": "setRandomSeed(seed)",
                "name": "setRandomSeed",
                "parameters": [
                    {
                        "full": "seed",
                        "name": "seed"
                    }
                ]
            }
        ],
        "markdown": "### [setRandomSeed](https://docs.dolphindb.com/en/Functions/s/setRandomSeed.html)\n\n\n\n#### Syntax\n\nsetRandomSeed(seed)\n\n#### Arguments\n\n**seed** is an integer indicating the random seed.\n\n#### Details\n\nSet the random seed.\n\n#### Examples\n\n```\nsetRandomSeed(5);\nrand(10, 10);\n// output\n[2,0,8,8,2,3,9,9,4,0]\n```\n"
    },
    "setReservedMemSize": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setReservedMemSize.html",
        "signatures": [
            {
                "full": "setReservedMemSize(memSizeGB)",
                "name": "setReservedMemSize",
                "parameters": [
                    {
                        "full": "memSizeGB",
                        "name": "memSizeGB"
                    }
                ]
            }
        ],
        "markdown": "### [setReservedMemSize](https://docs.dolphindb.com/en/Functions/s/setReservedMemSize.html)\n\n\n\n#### Syntax\n\nsetReservedMemSize(memSizeGB)\n\n#### Arguments\n\n**memSizeGB** is a numeric scalar (in GB). It is greater than 0 and less than *maxMemSize* \\* 0.5.\n\n#### Details\n\nModify the reserved memory allocated to DolphinDB online. This command can only be executed by the admin.\n\n**Note:**\n\nThe modified configuration will expire after the cluster is rebooted. To make it permanent, please change the configuration parameter *reservedMemSize*.\n"
    },
    "setRetentionPolicy": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setRetentionPolicy.html",
        "signatures": [
            {
                "full": "setRetentionPolicy(dbHandle, retentionHours, [retentionDimension], [hoursToColdVolume])",
                "name": "setRetentionPolicy",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "retentionHours",
                        "name": "retentionHours"
                    },
                    {
                        "full": "[retentionDimension]",
                        "name": "retentionDimension",
                        "optional": true
                    },
                    {
                        "full": "[hoursToColdVolume]",
                        "name": "hoursToColdVolume",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [setRetentionPolicy](https://docs.dolphindb.com/en/Functions/s/setRetentionPolicy.html)\n\n\n\n#### Syntax\n\nsetRetentionPolicy(dbHandle, retentionHours, \\[retentionDimension], \\[hoursToColdVolume])\n\n#### Arguments\n\n**dbHandle** is a database handle. The data type of at least one of the partitioning columns of the database must be DATE or DATEHOUR.\n\n**retentionHours** is a positive integer indicating the number of hours that data are kept.\n\n**retentionDimension** (optional) is an integer indicating the layer of the temporal partition. The default value is 0 indicating the first layer of a COMPO partition is a temporal partition.\n\n**hoursToColdVolume** (optional) is a positive integer indicating the number of hours that data are kept in volumes. Data stored in volumes will be migrated to the specified *coldVolumes* (configuration parameter) after hoursToColdVolume.\n\n**Note:**\n\nMake sure that *retentionHours* - *hoursToColdVolume* > 7 \\* 24 (7 days).\n\n#### Details\n\nSet the policy of data retention and tiered storage. The parameter *retentionHours* should be specified as large as possible for tiered storage to avoid deleting any data.\n\nBoth data retention and tiered storage are partition-based. Therefore, the interval configured by *retentionHours* and *hoursToColdVolume* must be divisible by the granularity of the partition.\n\nThe system will keep the data with the timestamp of the last *retentionHours* based on the system time: Data of the last *hoursToColdVolume* are stored in volumes; Data in \\[current time - *hoursToColdVolumes* - 10 days, current time - *hoursToColdVolumes*) are migrated to *coldVolumes*. If multiple paths are specified for *coldVolumes*, the data will be transferred randomly to one of the specified directories.\n\nFor other data, only data in the range of \\[current time - *retentionHours* - 10 days, current time - *retentionHours*) are deleted. To delete the data outside the range, you can call function `dropPartition`.\n\n**Note:**\n\nThe function is only applied to a DFS database.\n\n#### Examples\n\n```\ndb=database(\"dfs://db1\",VALUE,2019.06.01..date(now()))\nretentionHour=9*24\nhoursToColdVolume=1*24\nsetRetentionPolicy(db,retentionHour,0, hoursToColdVolume);\n\nschema(db);\n// output\npartitionSchema->[2022.05.05,2022.05.04,2022.05.03,2022.05.02,2022.05.01,2022.04.30,2022.04.29,2022.04.28,2022.04.27,2022.04.26,...]\npartitionSites->\npartitionTypeName->VALUE\nhoursToColdVolume->24\natomic->TRANS\ndatabaseDir->dfs://db1\nengineType->OLAP\nchunkGranularity->TABLE\nretentionDimension->0\npartitionType->1\nretentionHours->216\n```\n"
    },
    "setStreamTableFilterColumn": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setStreamTableFilterColumn.html",
        "signatures": [
            {
                "full": "setStreamTableFilterColumn(streamTable, columnName)",
                "name": "setStreamTableFilterColumn",
                "parameters": [
                    {
                        "full": "streamTable",
                        "name": "streamTable"
                    },
                    {
                        "full": "columnName",
                        "name": "columnName"
                    }
                ]
            }
        ],
        "markdown": "### [setStreamTableFilterColumn](https://docs.dolphindb.com/en/Functions/s/setStreamTableFilterColumn.html)\n\n\n\n#### Syntax\n\nsetStreamTableFilterColumn(streamTable, columnName)\n\n#### Arguments\n\n**streamTable** is a stream table object.\n\n**columnName** is a string indicating a column name. The column must be of type SYMBOL, STRING or INT.\n\n#### Details\n\nSpecify the filtering column of a stream table. It is related to parameter *filter* in function [subscribeTable](https://docs.dolphindb.com/en/Functions/s/subscribeTable.html) The value of parameter *filter* is a vector. Only the rows with values of the filtering column in *filter* are published to the subscriber. A stream table can have only one filtering column.\n\n#### Examples\n\nIn the following example, the filter column of the stream table \"trades\" is \"symbol\". The table \"trades\\_slave\" on the same node subscribes to \"trades\" and the filter is set to \\[\"IBM\", \"GOOG\"]. Only when the column \"symbol\" is \"IBM\" or \"GOOG\", the corresponding data will be published.\n\n```\nshare streamTable(10000:0,`time`symbol`price, [TIMESTAMP,SYMBOL,INT]) as trades\nsetStreamTableFilterColumn(trades, `symbol)\ntrades_1=table(10000:0,`time`symbol`price, [TIMESTAMP,SYMBOL,INT])\n\nfilter=symbol(`IBM`GOOG)\n\nsubscribeTable(tableName=`trades, actionName=`trades_1, handler=append!{trades_1}, msgAsTable=true, filter=filter);\n```\n"
    },
    "setStreamTableTimestamp": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setStreamTableTimestamp.html",
        "signatures": [
            {
                "full": "setStreamTableTimestamp(streamTable, columnName)",
                "name": "setStreamTableTimestamp",
                "parameters": [
                    {
                        "full": "streamTable",
                        "name": "streamTable"
                    },
                    {
                        "full": "columnName",
                        "name": "columnName"
                    }
                ]
            }
        ],
        "markdown": "### [setStreamTableTimestamp](https://docs.dolphindb.com/en/Functions/s/setStreamTableTimestamp.html)\n\n\n\n#### Syntax\n\nsetStreamTableTimestamp(streamTable, columnName)\n\n#### Arguments\n\n**streamTable**can be a regular, shared, persisted or HA stream table.\n\n**columnName**is a string indicating the name of the last column of the table. It must be a time column that records the system time when the message is inserted to the stream table.\n\n#### Details\n\nSet a time column for the stream table for recording the ingestion time of each message. The system will attach the system time of data ingestion to the column each time data is written. This helps users to measure the delay when writing real-time stream to the stream table.\n\nNote that the column cannot be changed or revoked once set.\n\n#### Examples\n\n```\nshare streamTable(10000:0,`time`symbol`price`timestamp, [TIMESTAMP,SYMBOL,DOUBLE,TIMESTAMP]) as trades\n// set the timestamp column for trades\nsetStreamTableTimestamp(trades, `timestamp)\n\n// insert a record and the timestamp column is automatically added\ninsert into trades values(2023.03.19T03:17:49, `A, 10.2)\n\nselect * from trades\n```\n\n| time                    | symbol | price | timestamp               |\n| ----------------------- | ------ | ----- | ----------------------- |\n| 2023.03.19 03:17:49.000 | A      | 10.2  | 2024.03.31 08:01:31.324 |\n"
    },
    "setSystem": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setSystem.html",
        "signatures": [
            {
                "full": "setSystem(paramName, paramValue)",
                "name": "setSystem",
                "parameters": [
                    {
                        "full": "paramName",
                        "name": "paramName"
                    },
                    {
                        "full": "paramValue",
                        "name": "paramValue"
                    }
                ]
            }
        ],
        "markdown": "### [setSystem](https://docs.dolphindb.com/en/Functions/s/setSystem.html)\n\n\n\n#### Syntax\n\nsetSystem(paramName, paramValue)\n\n#### Arguments\n\n**paramName** is a string indicating the parameter name.\n\n**paramValue** is the corresponding parameter value.\n\n#### Details\n\nSet the following system-wide parameters:\n\n* the maximum number of rows to display for an object in console\n\n* the maximum width of a row to display for an object in console\n\n**Note:** Administrator priviledges are required.\n\n#### Examples\n\n```\nsetSystem(\"rows\", 30);\nsetSystem(\"width\", 200);\n```\n"
    },
    "setTableComment": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setTableComment.html",
        "signatures": [
            {
                "full": "setTableComment(table, comment)",
                "name": "setTableComment",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "comment",
                        "name": "comment"
                    }
                ]
            }
        ],
        "markdown": "### [setTableComment](https://docs.dolphindb.com/en/Functions/s/setTableComment.html)\n\n\n\n#### Syntax\n\nsetTableComment(table, comment)\n\n#### Arguments\n\n**table** is a DFS table.\n\n**comment** is a STRING scalar for table comment, limited to 4096 bytes.\n\n#### Details\n\nAdd comments to a DFS table. Use function [schema](https://docs.dolphindb.com/en/Functions/s/schema.html) to view table comments.\n\n#### Examples\n\n```\n// create a DFS table\ndb = database(directory=\"dfs://testDB\", partitionType=VALUE, partitionScheme=1..5)\nschemaTB = table(1..5 as id, take(`A`B`C,5) as sym, rand(10.0,5) as price)\npt = db.createPartitionedTable(table=schemaTB, tableName=\"pt\", partitionColumns=\"id\")\n// add comment \"my first pt\" to table pt\nsetTableComment(table=pt, comment=\"my first pt\")\n// check the comment with function schema\nschema(pt)[\"tableComment\"]\n// output: 'my first pt'\n```\n"
    },
    "setTimeoutTick": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setTimeoutTick.html",
        "signatures": [
            {
                "full": "setTimeoutTick(tick)",
                "name": "setTimeoutTick",
                "parameters": [
                    {
                        "full": "tick",
                        "name": "tick"
                    }
                ]
            }
        ],
        "markdown": "### [setTimeoutTick](https://docs.dolphindb.com/en/Functions/s/setTimeoutTick.html)\n\n\n\n#### Syntax\n\nsetTimeoutTick(tick)\n\nAlias: setDfsChunkNodeHeartBeatTimeoutTick\n\n#### Arguments\n\n**tick** is a positive integer (in seconds) that indicates the timeout period.\n\n#### Details\n\nDynamically modify the timeout period for the controller to receive a data node's heartbeat. If the heartbeat is not received within the specified period, the node is considered as offline. This command can only be executed by the admin on the controller. For a high availability cluster, it must be executed on all controllers within the raft group.\n\n**Note:**\n\nThe modified configuration will expire after the cluster is rebooted. To make it permanent, please change the configuration parameter *dfsChunkNodeHeartBeatTimeout*.\n"
    },
    "setTSDBCacheEngineSize": {
        "url": "https://docs.dolphindb.com/en/Functions/s/setTSDBCacheEngineSize.html",
        "signatures": [
            {
                "full": "setTSDBCacheEngineSize(memSize)",
                "name": "setTSDBCacheEngineSize",
                "parameters": [
                    {
                        "full": "memSize",
                        "name": "memSize"
                    }
                ]
            }
        ],
        "markdown": "### [setTSDBCacheEngineSize](https://docs.dolphindb.com/en/Functions/s/setTSDBCacheEngineSize.html)\n\n#### Syntax\n\nsetTSDBCacheEngineSize(memSize)\n\n#### Arguments\n\n**memSize** is a numeric scalar (in GB). It is greater than 0 and less than *maxMemSize* \\* 0.75.\n\n#### Details\n\nModify the capacity of the TSDB cache engine online. In a cluster, this command can only be executed by the admin on the data node or compute node. Please make sure the cache engine is enabled by specifying configuration parameter *TSDBCacheEngineSize* before execution. You can obtain the real-time status of the TSDB cache engine with function `getTSDBCacheEngineSize` to check if the modification takes effect online.\n\n**Note:**\n\nThe modified configuration will expire after the cluster is rebooted. To make it permanent, please change the configuration parameter *TSDBCacheEngineSize*.\n\nRelated function: [getTSDBCacheEngineSize](https://docs.dolphindb.com/en/Functions/g/getTSDBCacheEngineSize.html).\n\n"
    },
    "shape": {
        "url": "https://docs.dolphindb.com/en/Functions/s/shape.html",
        "signatures": [
            {
                "full": "shape(X)",
                "name": "shape",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [shape](https://docs.dolphindb.com/en/Functions/s/shape.html)\n\n\n\n#### Syntax\n\nshape(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nReturn the dimension of a scalar/vector/matrix as a PAIR.\n\n#### Examples\n\nDimension of a scalar is 1 by 1:\n\n```\nshape 6;\n// output\n1:1\n\ns;\n```\n\nDimension of a vector is the length of the vector by 1:\n\n```\nshape 1 5 3 7 8;\n// output\n5:1\n```\n\nDimension of a matrix:\n\n```\nm=(5 3 1 4 9 10)$3:2;\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 5  | 4  |\n| 3  | 9  |\n| 1  | 10 |\n\n```\nshape m;\n\n// output\n3 :2\n```\n\nDimension of a table:\n\n```\nt=table(1 2 3 as x, 4 5 6 as y);\n\nt;\n```\n\n| x | y |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\nshape t;\n// output\n3 :2\n```\n"
    },
    "shapiroTest": {
        "url": "https://docs.dolphindb.com/en/Functions/s/shapiroTest.html",
        "signatures": [
            {
                "full": "shapiroTest(X)",
                "name": "shapiroTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [shapiroTest](https://docs.dolphindb.com/en/Functions/s/shapiroTest.html)\n\n\n\n#### Syntax\n\nshapiroTest(X)\n\n#### Arguments\n\n**X** is a numeric vector indicating the sample for the test.\n\n#### Details\n\nConduct a Shapiro-Wilk test on *X*. Return a dictionary with the following keys:\n\n* method : \"Shapiro-Wilk normality test\"\n\n* pValue : p-value of the test\n\n* W : W-stat\n\n#### Examples\n\n```\nx = norm(0.0, 1.0, 50)\nshapiroTest(x);\n\n// output\nmethod->Shapiro-Wilk normality test\npValue->0.621668\nW->0.981612\n```\n"
    },
    "share": {
        "url": "https://docs.dolphindb.com/en/Functions/s/share.html",
        "signatures": [
            {
                "full": "share(table, sharedName, [database], [dbName], [partitionColumn], [readonly=false])",
                "name": "share",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "sharedName",
                        "name": "sharedName"
                    },
                    {
                        "full": "[database]",
                        "name": "database",
                        "optional": true
                    },
                    {
                        "full": "[dbName]",
                        "name": "dbName",
                        "optional": true
                    },
                    {
                        "full": "[partitionColumn]",
                        "name": "partitionColumn",
                        "optional": true
                    },
                    {
                        "full": "[readonly=false]",
                        "name": "readonly",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [share](https://docs.dolphindb.com/en/Functions/s/share.html)\n\n\n\n#### Syntax\n\nshare(table, sharedName, \\[database], \\[dbName], \\[partitionColumn], \\[readonly=false])\n\n#### Arguments\n\n**table** is the table or engine to be shared across all sessions.\n\n**sharedName** is a string indicating the name to be used to refer to the shared table across all sessions, or the name of the DFS table to be shared.\n\n**database** (optional) is a database handle. When it is defined by the function [database](https://docs.dolphindb.com/en/Functions/d/database.html), it specifies the location of each partition.\n\n**dbName** (optional) is a string indicating the distributed database name.\n\n**partitionColumn** (optional) is the partitioning column of the DFS table.\n\n**readonly** (optional) is a Boolean value indicating whether to share an ordinary/keyed/indexed in-memory table as a readonly table to improve query performance. The default value is false.\n\n#### Details\n\nIf only *table* and *sharedName* are specified:\n\n* When *table* is a table, it is shared across all sessions with the specified shared name. Local objects including tables are invisible to other sessions. They need to be shared before they are visible to other sessions. The shared name must be different from all regular table names on all sessions. Data of a shared stream table cannot be deleted or updated, but data of a shared table (created with `table` or `mvccTable`) can be deleted or updated. Data inserts are allowed on all types of shared tables.\n\n* When *table* is a streaming engine, a lock is applied to the engine to allow concurrent writes.\n\nIf all 5 parameters are used: populate a shard of a distributed table and share it across all sessions with a shared name. The sharding is based on the given partitioning column. Multiple `share` statements are used together to save a DFS table on multiple nodes.\n\nThe rows of a shared stream table cannot be updated or deleted. In comparison, the rows of other shared tables can be updated or deleted.\n\nNote that it is not allowed to share a stream table multiple times by modifying the shared table name.\n\n#### Examples\n\n```\nshare(t, `sharedT);\nshare(t, `quotes, tickDB, `tickDB, `date);\n```\n\n```\ntrades = streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE])\nshare table(100:0, `sym`time`factor1, [SYMBOL, TIMESTAMP, DOUBLE]) as outputTable\nengine = createReactiveStateEngine(name=\"test\", metrics=[<time>, <mavg(price, 3)>], dummyTable=trades, outputTable=outputTable, keyColumn=`sym)\n// share engine\nshare(engine, \"test\")\n\n// define a function write1 to write to the engine\ndef write1(mutable engine) {\n  N = 10\n  for (i in 1..500) {\n      data = table(take(now(), N) as time, take(`A`B, N) as sym, rand(10.0, N) as price)\n      engine.append!(data)\n  }\n}\n// define a function write2 to write to the engine\ndef write2(mutable engine) {\n  N = 10\n  for (i in 1..500) {\n      data = table(take(now(), N) as time, take(`C`D, N) as sym, rand(10.0, N) as price)\n      engine.append!(data)\n  }\n}\n// submit jobs to write to the engine at the same time\nsubmitJob(\"j1\", \"j1\", write1, engine)\nsubmitJob(\"j2\", \"j2\", write2, engine)\n// the number of output records is 10000, which is exactly the sum of records written by write1 and write2\nselect count(*) from outputTable\n// output\n10,000\n```\n"
    },
    "shell": {
        "url": "https://docs.dolphindb.com/en/Functions/s/shell.html",
        "signatures": [
            {
                "full": "shell(cmd)",
                "name": "shell",
                "parameters": [
                    {
                        "full": "cmd",
                        "name": "cmd"
                    }
                ]
            }
        ],
        "markdown": "### [shell](https://docs.dolphindb.com/en/Functions/s/shell.html)\n\n\n\n#### Syntax\n\nshell(cmd)\n\n#### Arguments\n\n**cmd** is a string indicating an operating system command.\n\n#### Details\n\nExecute an operating system command. It can only be executed by the administrator when the configuration parameter *enableShellFunction* is set to true.\n\nCall function `system()` of the corresponding operating system. If *cmd* is successfully executed, the system will return 0. For other return values, please refer to the return values of function `system()` of the corresponding operating system.\n\n#### Examples\n\n```\ncmd=\"rm -rf /home/user1/test.txt\"\nshell(cmd);\n```\n"
    },
    "short": {
        "url": "https://docs.dolphindb.com/en/Functions/s/short.html",
        "signatures": [
            {
                "full": "short(X)",
                "name": "short",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [short](https://docs.dolphindb.com/en/Functions/s/short.html)\n\n\n\n#### Syntax\n\nshort(X)\n\n#### Arguments\n\n**x** can be of any data type.\n\n#### Details\n\nConvert the input to the data type of SHORT.\n\n#### Examples\n\n```\nx=short();\nx;\n// output\n00h\n\ntypestr x;\n// output\nSHORT\n\nshort(`12.3);\n// output\n12\n\nshort(`120.9c);\n// output\n120\n\nshort(32767);\n// output\n32767\n```\n\n**Note:**\n\nThe range of SHORT is \\[ -215+1, 215 -1] = \\[-32767, 32767]. If *X* exceeds this range, an overflow will occur.\n\n```\nshort(32768);\n//output\nnull\n\nshort(65578);\n//output\n42\n\nshort(32789)\n//output\n-32747\n```\n"
    },
    "shuffle!": {
        "url": "https://docs.dolphindb.com/en/Functions/s/shuffle!.html",
        "signatures": [
            {
                "full": "shuffle!(X)",
                "name": "shuffle!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [shuffle!](https://docs.dolphindb.com/en/Functions/s/shuffle!.html)\n\n\n\n#### Syntax\n\nshuffle!(X)\n\n#### Details\n\nPlease refer to [shuffle](https://docs.dolphindb.com/en/Functions/s/shuffle.html). The only difference between `shuffle` and `shuffle!` is that the latter assigns the result to *X* and thus changing the value of *X* after the execution.\n"
    },
    "shuffle": {
        "url": "https://docs.dolphindb.com/en/Functions/s/shuffle.html",
        "signatures": [
            {
                "full": "shuffle(X)",
                "name": "shuffle",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [shuffle](https://docs.dolphindb.com/en/Functions/s/shuffle.html)\n\n\n\n#### Syntax\n\nshuffle(X)\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n#### Details\n\nReturn a new vector/matrix after taking a shuffle on the data.\n\n#### Examples\n\n```\nx=(1..6).shuffle();\nx;\n// output\n[1,6,3,5,4,2]\n\nx.shuffle!();\n// output\n[5,4,1,3,2,6]\n\n\nx=(1..6).reshape(3:2);\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nx.shuffle();\n```\n\n| #0 | #1 |\n| -- | -- |\n| 5  | 3  |\n| 2  | 1  |\n| 4  | 6  |\n"
    },
    "signbit": {
        "url": "https://docs.dolphindb.com/en/Functions/s/signbit.html",
        "signatures": [
            {
                "full": "signbit(X)",
                "name": "signbit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [signbit](https://docs.dolphindb.com/en/Functions/s/signbit.html)\n\n\n\n#### Syntax\n\nsignbit(X)\n\n#### Arguments\n\n**X** is a floating-point or integer scalar.\n\n#### Details\n\nDetect the sign bit of the input value.\n\n**Return value**: true if *X* is negative, false otherwise.\n\n#### Examples\n\n```\n$ signbit('a')\nfalse\n\n$ signbit(-21)\ntrue\n\n$ signbit(-2.1)\ntrue\n\n$ b=complex(10,-5)// create a complex number\n$ b\n10.0-5.0i\n$ signbit(highDouble(b)) // detect the sign bit of the imaginary number\ntrue\n$ signbit(lowDouble(b))  // detect the sign bit of the real number\nfalse\n```\n"
    },
    "signum": {
        "url": "https://docs.dolphindb.com/en/Functions/s/signum.html",
        "signatures": [
            {
                "full": "signum(X)",
                "name": "signum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [signum](https://docs.dolphindb.com/en/Functions/s/signum.html)\n\n\n\n#### Syntax\n\nsignum(X)\n\nAlias: sign\n\n#### Arguments\n\n**x** is a scalar/vector/matrix of numeric or Boolean value.\n\n#### Details\n\nReturn 1 if *X* is positive; 0 if *X* is 0; -1 if *X* is negative; NULL if *X* is NULL.\n\n#### Examples\n\n```\nsignum 1 0 -1 NULL;\n// output\n[1,0,-1, ]\n```\n"
    },
    "sin": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sin.html",
        "signatures": [
            {
                "full": "sin(X)",
                "name": "sin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sin](https://docs.dolphindb.com/en/Functions/s/sin.html)\n\n\n\n#### Syntax\n\nsin(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nThe sine function.\n\n#### Examples\n\n```\nsin(1 2 3);\n// output\n[0.841471,0.909297,0.141120]\n```\n"
    },
    "sinh": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sinh.html",
        "signatures": [
            {
                "full": "sinh(X)",
                "name": "sinh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sinh](https://docs.dolphindb.com/en/Functions/s/sinh.html)\n\n\n\n#### Syntax\n\nsinh(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nThe hyperbolic sine function.\n\n#### Examples\n\n```\nsinh 1 2 3;\n// output\n[1.175201,3.62686,10.017875]\n```\n"
    },
    "size": {
        "url": "https://docs.dolphindb.com/en/Functions/s/size.html",
        "signatures": [
            {
                "full": "size(X)",
                "name": "size",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [size](https://docs.dolphindb.com/en/Functions/s/size.html)\n\n\n\n#### Syntax\n\nsize(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nFor a vector/matrix, `size` returns the number of elements. In comparison, `count` returns the number of non-null elements.\n\nFor an in-memory table, `size` returns the number of rows.\n\n#### Examples\n\n```\nsize(3 NULL 5 6);\n// output\n4\ncount(3 NULL 5 6);\n// output\n3\n\nm=1 2 3 NULL 4 5$2:3;\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 4  |\n| 2  |    | 5  |\n\n```\nsize(m);\n// output\n6\n\ncount(m);\n// output\n5\n\nt = table(1 NULL 3 as id, 3 NULL 9 as qty);\nt;\n```\n\n| id | qty |\n| -- | --- |\n| 1  | 3   |\n|    |     |\n| 3  | 9   |\n\n```\nsize(t);\n// output\n3\n\ncount(t);\n// output\n3\n```\n"
    },
    "skew": {
        "url": "https://docs.dolphindb.com/en/Functions/s/skew.html",
        "signatures": [
            {
                "full": "skew(X, [biased=true])",
                "name": "skew",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [skew](https://docs.dolphindb.com/en/Functions/s/skew.html)\n\n\n\n#### Syntax\n\nskew(X, \\[biased=true])\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n**biased** (optional) is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\n#### Details\n\nReturn the skewness of *X*. The calculation skips NULL values.\n\nThe calculation uses the following formulas in different cases:\n\n* When *biased*=true:\n\n  ![](https://docs.dolphindb.com/en/images/rowskewx.png)\n\n* When *biased*=false:\n\n  ![](https://docs.dolphindb.com/en/images/rowskewfalse.png)\n\nIf *X* is a matrix, calculate the skewness of each column of *X* and return a vector.\n\nIf *X* is a table, calculate the skewness of each column of *X* and return a table.\n\nThe `skew` function also supports querying partitioned tables and distributed tables with bias correction.\n\n#### Examples\n\nPlease note that as the example below uses a random number generator, the result is slightly different each time it is executed.\n\n```\nx=norm(0, 1, 1000000);\nskew(x);\n// output\n-0.00124\n\nx[0]=100;\nskew(x);\n// output\n0.983656\n\nm=matrix(1..10, 1 2 3 4 5 6 7 8 9 100);\nm;\n```\n\n| #0 | #1  |\n| -- | --- |\n| 1  | 1   |\n| 2  | 2   |\n| 3  | 3   |\n| 4  | 4   |\n| 5  | 5   |\n| 6  | 6   |\n| 7  | 7   |\n| 8  | 8   |\n| 9  | 9   |\n| 10 | 100 |\n\n```\nskew(m);\n// output\n[0,2.630083823883674]\n```\n"
    },
    "skipClusterReplicationTask": {
        "url": "https://docs.dolphindb.com/en/Functions/s/skipClusterReplicationTask.html",
        "signatures": [
            {
                "full": "skipClusterReplicationTask(taskIds)",
                "name": "skipClusterReplicationTask",
                "parameters": [
                    {
                        "full": "taskIds",
                        "name": "taskIds"
                    }
                ]
            }
        ],
        "markdown": "### [skipClusterReplicationTask](https://docs.dolphindb.com/en/Functions/s/skipClusterReplicationTask.html)\n\n#### Syntax\n\nskipClusterReplicationTask(taskIds)\n\n#### Arguments\n\n**taskIds** is a scalar or vector indicating ID of asynchronous replication tasks to be skipped. Task ID can be obtained with function [getMasterReplicationStatus](https://docs.dolphindb.com/en/Functions/g/getMasterReplicationStatus.html).\n\n#### Details\n\nSkips the specified replication tasks (usually are those caused cluster replication failure). It can only be executed by an administrator on the controller of a slave cluster.\n\nBefore a replication task is skipped, cluster replication should be stopped (with [stopClusterReplication](https://docs.dolphindb.com/en/Functions/s/stopClusterReplication.html)). The skipped task is marked as \"finished\". After the task is skipped, you can resume the cluster replication with [startClusterReplication](https://docs.dolphindb.com/en/Functions/s/startClusterReplication.html).\n\n#### Examples\n\n```\nskipClusterReplicationTask(1);\n```\n\nRelated functions: [startClusterReplication](https://docs.dolphindb.com/en/Functions/s/startClusterReplication.html), [stopClusterReplication](https://docs.dolphindb.com/en/Functions/s/stopClusterReplication.html)\n\n"
    },
    "sleep": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sleep.html",
        "signatures": [
            {
                "full": "sleep(X)",
                "name": "sleep",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sleep](https://docs.dolphindb.com/en/Functions/s/sleep.html)\n\n\n\n#### Syntax\n\nsleep(X)\n\n#### Arguments\n\n**X** is a non-negative scalar.\n\n#### Details\n\nPause the application for *X* milliseconds.\n\n#### Examples\n\n```\nfor(s in 1:10){\n   sleep(1000)\n   print(s+\" seconds passed.\")\n};\n\n// output\n1 seconds passed.\n2 seconds passed.\n3 seconds passed.\n4 seconds passed.\n5 seconds passed.\n6 seconds passed.\n7 seconds passed.\n8 seconds passed.\n9 seconds passed.\n```\n"
    },
    "slice": {
        "url": "https://docs.dolphindb.com/en/Functions/s/slice.html",
        "signatures": [
            {
                "full": "slice(obj, index)",
                "name": "slice",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "index",
                        "name": "index"
                    }
                ]
            },
            {
                "full": "slice(obj, rowIndex, [colIndex])",
                "name": "slice",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "rowIndex",
                        "name": "rowIndex"
                    },
                    {
                        "full": "[colIndex]",
                        "name": "colIndex",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [slice](https://docs.dolphindb.com/en/Functions/s/slice.html)\n\n#### Syntax\n\nslice(obj, index)\n\nor\n\nslice(obj, rowIndex, \\[colIndex])\n\nwhich is equivalent to\n\nobj\\[index] or obj\\[rowIndex, colIndex]\n\n#### Arguments\n\n**obj** can be an array vector,a matrix or a table.\n\n**index**, **rowIndex** and **colIndex** can be scalar/vector/pair indicating the row or column index. If *index*, *rowIndex* or *colIndex* is a pair, it indicates the range of index which is left-closed and right-open.\n\n#### Details\n\nFor `slice(obj, index)`:\n\n* If *obj* is an array vector and\n\n  * *index* is a scalar, it returns a vector indicating a column;\n\n  * *index* is a vector, it returns an array vector of selected rows;\n\n  * *index* is a pair, it returns an array vector of selected columns.\n\n* If *obj* is a matrix and\n\n  * *index* is a scalar, it returns a vector indicating a column.\n\n  * *index* is a vector or a pair, it returns a matrix of selected columns.\n\n* If obj is a table and\n\n  * *index* is a scalar, it returns a dictionary indicating a row.\n\n  * *index* is a vector or a pair, it returns a table of selected rows.\n\nFor `slice(obj, rowIndex, [colIndex])`:\n\n* If *obj* is an array vector and\n\n  * *rowIndex* and *colIndex* are both scalars, it returns a vector indicating a column;\n\n  * *rowIndex* is a scalar and *colIndex* is a pair (or vise versa), it returns an array vector of selected rows and columns;\n\n  * *rowIndex* and *colIndex* are both pair, it returns an array vector of selected rows and columns.\n\n* If *obj* is a matrix and\n\n  * *rowIndex* and *colIndex* are both scalars, it returns a scalar indicating the value of specified element of the matrix.\n\n  * *rowIndex* is a scalar and *colIndex* is a pair (or vise versa), it returns a submatrix of selected rows and columns.\n\n  * *rowIndex* and *colIndex* are both vectors or pairs, it returns a submatrix of selected rows and columns.\n\n* If *obj* is a table and\n\n  * *rowIndex* and *colIndex* are both scalars, return a scalar indicating the value of specified element of the table.\n\n  * *rowIndex* is a scalar and *colIndex* is a pair (or vise versa), it returns a table of selected rows and columns.\n\n  * *rowIndex* and *colIndex* are both vectors or pairs, it returns a table of selected rows and columns.\n\n**Note:**\n\n* To get a particular row or column from a table, consider using function `col` or `row`.\n\n* When *index*, *rowIndex* or *colIndex* specifies the index range of an array vector ora matrix, if the values are not within \\[0, size(X)-1], the corresponding results are NULL values.\n\n#### Examples\n\nIf *obj* is a matrix:\n\n```\nm=1..9$3:3\nm.slice(0);\n// output\n[1,2,3]\n    \nm.slice([0]);\n```\n\n| #0 |\n| -- |\n| 1  |\n| 2  |\n| 3  |\n\n```\nm.slice(0:2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nm.slice(0 2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 7  |\n| 2  | 8  |\n| 3  | 9  |\n\n```\nm.slice(0,1);\n// output\n 4\n\nm.slice(0 1,0 1);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n\n```\nm.slice(1:2,1:2);\n```\n\n| #0 |\n| -- |\n| 5  |\n\nIf *obj* is a table:\n\n```\nt=table(`A`B`C as sym,2018.01.01..2018.01.03 as date,10 48 5 as val)\nt.slice(0);\n// output\nval->10\ndate->2018.01.01\nsym->A\nt.slice([0]);\n```\n\n| sym | date       | val |\n| --- | ---------- | --- |\n| A   | 2018.01.01 | 10  |\n\n```\nt.slice(0 1);\n```\n\n| sym | date       | val |\n| --- | ---------- | --- |\n| A   | 2018.01.01 | 10  |\n| B   | 2018.01.02 | 48  |\n\n```\nt.slice(0:1);\n```\n\n| sym | date       | val |\n| --- | ---------- | --- |\n| A   | 2018.01.01 | 10  |\n\n```\nt.slice(0,1);\n// output\n2018.01.01\n \nt.slice(0 1,0 1);\n```\n\n| sym | date       |\n| --- | ---------- |\n| A   | 2018.01.01 |\n| B   | 2018.01.02 |\n\n```\nt.slice(1:2,1:2);\n```\n\n| date       |\n| ---------- |\n| 2018.01.02 |\n\nIf *obj* is an array vector:\n\n```\nav =array(DOUBLE[], 0, 10).append!([1.0, 2.1 4.1 6.8, 0.5 2.2 2]);\nav[1] \n// output\n[,4.1,2.2]\n\nav[1,1]\n// output\n[4.1]\n\nav[1:3,1:3] \n// output\n[[4.1,6.8],[2.2,2]]\n```\n\n"
    },
    "sliceByKey": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sliceByKey.html",
        "signatures": [
            {
                "full": "sliceByKey(table, rowKeys, [colNames])",
                "name": "sliceByKey",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "rowKeys",
                        "name": "rowKeys"
                    },
                    {
                        "full": "[colNames]",
                        "name": "colNames",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sliceByKey](https://docs.dolphindb.com/en/Functions/s/sliceByKey.html)\n\n\n\n#### Syntax\n\nsliceByKey(table, rowKeys, \\[colNames])\n\n#### Arguments\n\n**table** is a keyed table or indexed table.\n\n**rowKeys** is a scalar/vector indicating the specified values of key columns.\n\n**colNames** (optional) is a string scalar/vector indicating the names of columns to be selected.\n\n#### Details\n\nGet the rows containing the specified values of the key columns from a keyed table or an indexed table. It is faster than the corresponding SQL statement.\n\nFor a keyed table, *rowKeys* must contain values for all key columns.\n\nFor an indexed table, *rowKeys* must contain values for the first n key columns.\n\nIf *colNames* is not specified, return all columns.\n\nThe data form of the result depends on *colNames*. If *colNames* is a scalar, return a vector; if *colNames* is a vector, return an in-memory table.\n\n#### Examples\n\n```\nt = indexedTable(`sym`side, 10000:0, `sym`side`price`qty, [SYMBOL,CHAR,DOUBLE,INT])\ninsert into t values(`IBM`MSFT`IBM, ['B','S','S'], 125.27 208.9 125.29, 1000 800 200)\na=sliceByKey(t,\"IBM\", 'price');\n\na;\n// output\n[125.27,125.29]\n\ntypestr(a);\n// output\nFAST DOUBLE VECTOR\n\na=sliceByKey(t,(\"IBM\",'S'));\na;\n```\n\n| sym | side | price  | qty |\n| --- | ---- | ------ | --- |\n| IBM | S    | 125.29 | 200 |\n\n```\ntypestr(a);\n// output\nIN-MEMORY TABLE\n\nt1 = keyedTable(`sym`side, 10000:0, `sym`side`price`qty, [SYMBOL,CHAR,DOUBLE,INT])\ninsert into t1 values(`IBM`MSFT`IBM, ['B','S','S'], 125.27 208.9 125.29, 1000 800 200)\nsliceByKey(t1, [[\"IBM\", \"MSFT\"], ['B', 'S']]);\n```\n\n| sym  | side | price  | qty  |\n| ---- | ---- | ------ | ---- |\n| IBM  | B    | 125.27 | 1000 |\n| MSFT | S    | 208.9  | 800  |\n"
    },
    "sma": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sma.html",
        "signatures": [
            {
                "full": "sma(X, window)",
                "name": "sma",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [sma](https://docs.dolphindb.com/en/Functions/s/sma.html)\n\n\n\n#### Syntax\n\nsma(X, window)\n\nPlease see [TALib](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the Simple Moving Average (sma) for *X* in a sliding window of the given length.\n\nThe formula is: ![](https://docs.dolphindb.com/en/images/sma.png)\n\n#### Examples\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\nsma(x,3);\n// output\n[,,12.299999999999998,12.533333333333331,12.433333333333331,12.099999999999999,11.566666666666664]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\nsma(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n| 12.3    | 15.6667 |\n| 12.5333 | 17.3333 |\n| 12.4333 | 19.3333 |\n| 12.1    | 17.3333 |\n| 11.5667 | 14.3333 |\n\nRelated functions: [wma](https://docs.dolphindb.com/en/Functions/w/wma.html), [trima](https://docs.dolphindb.com/en/Functions/t/trima.html)\n"
    },
    "snippet": {
        "url": "https://docs.dolphindb.com/en/Functions/s/snippet.html",
        "signatures": [
            {
                "full": "snippet(X)",
                "name": "snippet",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [snippet](https://docs.dolphindb.com/en/Functions/s/snippet.html)\n\n\n\n#### Syntax\n\nsnippet(X)\n\n#### Arguments\n\n**X** can be data of any type.\n\n#### Details\n\nPrint the results.\n\nReturn value: A STRING scalar.\n\n#### Examples\n\n```\na = [[\"a\",\"b\"],\"c\"]\nsnippet(a)\n//output\n\"([\"a\",\"b\"],\"c\")\"\n\nsnippet(date(2023.01.01))\n//output\n\"2023.01.01\"\n```\n"
    },
    "socp": {
        "url": "https://docs.dolphindb.com/en/Functions/s/socp.html",
        "signatures": [
            {
                "full": "socp(f, [G], [h], [l], [q], [A], [b])",
                "name": "socp",
                "parameters": [
                    {
                        "full": "f",
                        "name": "f"
                    },
                    {
                        "full": "[G]",
                        "name": "G",
                        "optional": true
                    },
                    {
                        "full": "[h]",
                        "name": "h",
                        "optional": true
                    },
                    {
                        "full": "[l]",
                        "name": "l",
                        "optional": true
                    },
                    {
                        "full": "[q]",
                        "name": "q",
                        "optional": true
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[b]",
                        "name": "b",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [socp](https://docs.dolphindb.com/en/Functions/s/socp.html)\n\n\n\n#### Syntax\n\nsocp(f, \\[G], \\[h], \\[l], \\[q], \\[A], \\[b])\n\n#### Arguments\n\nSecond-order cone programming (SOCP) problems are subject to the constraint with the following form:\n\n![](https://docs.dolphindb.com/en/images/socp_12.png)\n\n*K* is a cone and *s* is a slack variable. The value of *s* will be determined during optimization.\n\n**f** is a numeric vector indicating the coefficient vector of the objective function.\n\n**G** (optional) is a numeric matrix indicating the coefficient matrix of the cone constraint.\n\n**h** (optional) is a numeric vector indicating the right-hand-side vector of the cone constraint.\n\n**l** (optional) is an integral scalar indicating the dimension of the non-negative quadrant constraint.\n\n**q** (optional) is a positive vector indicating the dimension size of each second-order cone constraint. The form is \\[r0,r1,…,rN-1].\n\n**A** (optional) is a numeric matrix indicating the coefficient matrix of the equality constraint.\n\n**b** (optional) is a numeric vector indicating the right-hand-side vector of the equality constraint.\n\n#### Details\n\nSolve SOCP problems and calculate the minimum of the objective function under specified constraints. The standard form of the SOCP constraint is as follows:\n\n![](https://docs.dolphindb.com/en/images/socp_11.png)\n\n*G* is as follows:\n\n![](https://docs.dolphindb.com/en/images/socp_3.png)\n\n*h* is as follows:\n\n![](https://docs.dolphindb.com/en/images/socp_4.png)\n\n**Return value**: A 3-element tuple:\n\n* The first element is a string indicating the state of the solution:\n\n  * Problem solved to optimality: optimal solution found;\n\n  * Found certificate of primal infeasibility: no feasible solution to the primal;\n\n  * Found certificate of dual infeasibility: no feasible solution to the dual;\n\n  * Offset exitflag at inaccurate results: inaccurate results;\n\n  * Maximum number of iterations reached: reach the maximum number of iterations;\n\n  * Search direction unreliable: unreliable search direction;\n\n  * Unknown problem in solver: the solver cannot identify the problem.\n\n* The second element is the value of x where the value of the objective function is minimized.\n\n* The third element is the minimum value of the objective function.\n\n#### Examples\n\nSolve the following SOCP problem:\n\n![](https://docs.dolphindb.com/en/images/socp_5.png)\n\n```\nf = [-6, -4, -5]\nG = matrix([[16, 7, 24, -8, 8, -1, 0, -1, 0], \n[-14, 2, 7, -13, -18, 3, 0, 0, -1], \n[5, 0, -15, 12, -6, 17, 0, 0, 0]])\nh = [-3, 5, 12, -2, -14, -13, 10, 0, 0]\n\nl = 2\nq = [4,3]\n\nre = socp(f,G,h,l,q, ,)\nprint(re)\n\n// output > (\"Problem solved to optimality\",[-9.902804882871327,-1.39084684264198,26.211851780740154],-66.079042235904907)\n```\n"
    },
    "solve": {
        "url": "https://docs.dolphindb.com/en/Functions/s/solve.html",
        "signatures": [
            {
                "full": "solve(X, Y)",
                "name": "solve",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [solve](https://docs.dolphindb.com/en/Functions/s/solve.html)\n\n\n\n#### Syntax\n\nsolve(X, Y)\n\n#### Arguments\n\n**X** is a square matrix;\n\n**Y** is a vector.\n\n#### Details\n\nIt generates the vector b that solves X\\*b=Y.\n\n#### Examples\n\n```\nm=1..4$2:2;\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\nm.solve(7 10);\n// output\n[1, 2]\n```\n"
    },
    "sort!": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sort!.html",
        "signatures": [
            {
                "full": "sort!(X, [ascending=true])",
                "name": "sort!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [sort!](https://docs.dolphindb.com/en/Functions/s/sort!.html)\n\n\n\n#### Syntax\n\nsort!(X, \\[ascending=true])\n\n#### Arguments\n\n**X** is a vector.\n\n**ascending** (optional) is a Boolean scalar indicating whether to sort *X* in ascending order or descending order. The default value is true (ascending order).\n\n#### Details\n\nSort *X* in-place in ascending/descending order.\n\n#### Examples\n\n```\nx=9 1 5;\nsort!(x);\nx;\n// output\n[1 5 9]\n\nx.sort!(0);\nx;\n// output\n[9,5,1]\n```\n"
    },
    "sort": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sort.html",
        "signatures": [
            {
                "full": "sort(X, [ascending=true])",
                "name": "sort",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [sort](https://docs.dolphindb.com/en/Functions/s/sort.html)\n\n\n\n#### Syntax\n\nsort(X, \\[ascending=true])\n\nPlease refer to [sort!](https://docs.dolphindb.com/en/Functions/s/sort!.html). The only difference between sort and sort! is that the latter assigns the result to X and thus changing the value of X after the execution.\n\n#### Arguments\n\n**X** is a vector.\n\n**ascending** (optional) is a Boolean scalar indicating whether to sort *X* in ascending order or descending order. The default value is true (ascending order).\n\n#### Details\n\nReturn a sorted vector in ascending/descending order.\n\n#### Examples\n\n```\nx=9 1 5;\nx;\n// output\n[9,1,5]\n\ny=sort(x);\ny;\n// output\n[1,5,9]\n\nsort(x, false);\n// output\n[9,5,1]\n\nx=1 4 2 5 6 3$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 2  | 6  |\n| 4  | 5  | 3  |\n\n```\nsort x;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\nThe `sort!` function change the value of input after sorting.\n\n```\nx=9 1 5;\nsort!(x);\nx;\n// output\n[1 5 9];\n```\n\nRelated function: [isort](https://docs.dolphindb.com/en/Functions/i/isort.html)\n"
    },
    "sortBy!": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sortBy!.html",
        "signatures": [
            {
                "full": "sortBy!(table, sortColumns, [sortDirections])",
                "name": "sortBy!",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "sortColumns",
                        "name": "sortColumns"
                    },
                    {
                        "full": "[sortDirections]",
                        "name": "sortDirections",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sortBy!](https://docs.dolphindb.com/en/Functions/s/sortBy!.html)\n\n\n\n#### Syntax\n\nsortBy!(table, sortColumns, \\[sortDirections])\n\n#### Arguments\n\n**table** is a table object. It can be a partitioned or unpartitioned in-memory table.\n\n**sortColumns** can be a string scalar/vector indicating the columns based on which the table will be sorted. It can also be a piece of metacode with an expression.\n\n**sortDirections** (optional) is a Boolean scalar/vector indicating the sorting directions for the sorting columns. 1 means ascending and 0 means descending. If *sortColumns* is a vector and *sortDirections* is a scalar, the *sortDirections* applies to all the sorting columns.\n\n#### Details\n\nSort a table in-place based on the specified columns and directions. If the table is a partitioned table, the sorting is conducted within each partition, not on the entire table.\n\nThis operation is executed in parallel if the table is a partitioned table and the parallel processing feature is enabled (when the configuration parameter *localExcutors* > 0).\n\n#### Examples\n\nSort an unpartitioned table:\n\n```\nn=20000000\ntrades=table(rand(`IBM`MSFT`GM`C`YHOO`GOOG,n) as sym, 2000.01.01+rand(365,n) as date, 10.0+rand(2.0,n) as price, rand(1000,n) as qty);\ntrades.sortBy!(`sym`date, [0,1]);\n```\n\nSort a partitioned table:\n\n```\nworkDir = \"C:/DolphinDB/Data\"\nif(!exists(workDir)) mkdir(workDir)\ntrades.saveText(workDir + \"/trades.txt\")\ndb = database(workDir + \"/trade\",VALUE,`IBM`MSFT`GM`C`YHOO`GOOG)\ndb.loadTextEx(\"trades\",\"sym\", workDir + \"/trades.txt\")\ntrades = db.loadTable(\"trades\",`IBM`GM`YHOO,1)\ntrades.sortBy!(`date)\ntrades.sortBy!(`date, false)\ntrades.sortBy!(`date`qty, false)\ntrades.sortBy!(`date`qty, false true)\ntrades.sortBy!(<qty*price>)\ntrades.sortBy!(<[date, sym]>)\ntrades.sortBy!(<[sym, qty*price]>, true false)\n```\n"
    },
    "spearmanr": {
        "url": "https://docs.dolphindb.com/en/Functions/s/spearmanr.html",
        "signatures": [
            {
                "full": "spearmanr(X, Y)",
                "name": "spearmanr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [spearmanr](https://docs.dolphindb.com/en/Functions/s/spearmanr.html)\n\n\n\n#### Syntax\n\nspearmanr(X, Y)\n\n#### Arguments\n\n**X** is a vector/ matrix.\n\n**Y** is a vector/ matrix.\n\n#### Details\n\nCalculate the Spearman rank correlation coefficient of *X* and *Y*. NULL values are ignored in the calculation. Spearman correlation is a non-parametric measure of the monotonicity of the relationship between two data sets. The coefficient varies between -1 and +1, where 0 means no correlation. -1 or +1 means an exact monotonic relationship.\n\nIf *X* or *Y* is a matrix, apply the function to each column and return a vector.\n\n#### Examples\n\n```\nx=[2013.06.13, 2013.06.14, 2013.06.15]\ny=1 5 3\nspearmanr(x, y)\n// output\n0.5\n\nx = [33,21,46,-11,78,47,18,20,-5,66]\ny = [1,NULL,10,6,10,3,NULL,NULL,5,3]\nspearmanr(x, y)\n// output\n0.109109\n```\n\nIf *X* is a matrix, *Y* can be a vector/matrix with the same number of rows as *X*.\n\n```\nm1 = [34,77,35,-40,-39,-86,49,-55,15,72,NULL,-24,16,20,26,-82,80,-93,-65,99,45,90,44,46]$4:6\nm2 = [0, 25, 7, 3]\nspearmanr(m1, m2)\n// output\n[0.8, -0.4, 0.5, 0.6, -0.8, 0.4]\n```\n"
    },
    "splev": {
        "url": "https://docs.dolphindb.com/en/Functions/s/splev.html",
        "signatures": [
            {
                "full": "splev(x, tck)",
                "name": "splev",
                "parameters": [
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "tck",
                        "name": "tck"
                    }
                ]
            }
        ],
        "markdown": "### [splev](https://docs.dolphindb.com/en/Functions/s/splev.html)\n\n#### Syntax\n\nsplev(x, tck)\n\n#### Arguments\n\n**x** is a vector that specifies a set of data points to obtain corresponding values on the spline.\n\n**tck** can be a tuple of length 3 or a B-spline curve object that contains a vector t of knots, the B-spline coefficients, and the degree k of the spline. It can be generated with function [splrep](https://docs.dolphindb.com/en/Functions/s/splrep.html). Note that the spline degree k must satisfy 1 <= k <= 5.\n\n#### Details\n\n`splev`, short for Spline Evaluation, is used to evaluate B-spline curves or their derivatives. Given the knots and coefficients of the B-spline representation, this function calculates the values of the smooth polynomials and their derivatives. If NULL is included in the input values of *x* or *tck*, it will be filled with 0.\n\n**Return value**: y, a DOUBLE type vector that represents the array of spline function values evaluated at points x.\n\n**Note:**\n\nIt is not recommended to use a user-defined *tck*. If it is not generated by function `splrep`, the returned y may contain random values or be filled with 0s.\n\n#### Examples\n\n```\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\ny = [0, 3, 5, 6, 5, 3, 1, 2, 4, 5]\nnewx = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5]\nt=[1,3,5,8]\ntck= splrep(x, y, t=t)\nprint(tck)\n// output\n([0,0,0,0,1,3,5,8,9,9,9,9],[0,2.234794827972243,2.999908797063527,8.195517483732592,0.982766102937427,0.416533320193195,6.868465914739519,5,0,0,0,0],3)\n\nnewy = splev(newx, tck)\nprint(newy)\n// output\n[2.147514374187927,3.928180605155257,5.780093403045226,5.788551610920491,3.842319632145274,1.928386784305488,1.343262026468735,2.600266282317609,5.680148059970901,-0.902321655035049] \n```\n\nRelated function: [splrep](https://docs.dolphindb.com/en/Functions/s/splrep.html)\n\n"
    },
    "spline": {
        "url": "https://docs.dolphindb.com/en/Functions/s/spline.html",
        "signatures": [
            {
                "full": "spline(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false])",
                "name": "spline",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "resampleRule",
                        "name": "resampleRule"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    },
                    {
                        "full": "[outputX=false]",
                        "name": "outputX",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [spline](https://docs.dolphindb.com/en/Functions/s/spline.html)\n\n\n\n#### Syntax\n\nspline(X, Y, resampleRule, \\[closed='left'], \\[origin='start\\_day'], \\[outputX=false])\n\n#### Arguments\n\n**X** is a strictly increasing vector of temporal type.\n\n**Y** is a numeric vector of the same length as *X*.\n\n**resampleRule** is a string. See the parameter *rule* of function [resample](https://docs.dolphindb.com/en/Functions/r/resample.html) for the optional values.\n\n**closed** and **origin** (optional) are the same as the parameters *closed* and *origin* of function [resample](https://docs.dolphindb.com/en/Functions/r/resample.html).\n\n**outputX** (optional) is a Boolean value indicating whether to output the resampled *X*. The default value is false.\n\n#### Details\n\nResample *X* based on the specified *resampleRule*, *closed* and *origin*. Perform cubic spline interpolation on *Y* based on the resampled *X*.\n\nIf *outputX* is unspecified, return a vector of *Y* after the interpolation.\n\nIf *outputX*=true, return a tuple where the first element is the vector of resampled *X* and the second element is a vector of *Y* after the interpolation.\n\n#### Examples\n\n```\nspline([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min);\n\n// output\n[1,1.0313,1.0626,1.0942,1.1262,1.1585,1.1914,1.225,1.2593,1.2944,1.3306,1.3678,1.4062,1.446,1.4871,1.5298,1.5741,1.6201,1.668,1.7178\n,1.7697,1.8237,1.8801,1.9388,2,2.0638,2.1301,2.1987,2.2697,2.3428,2.418,2.4951,2.5741,2.6548,2.7371,2.821,2.9062,2.9928,3.0806,3.1694\n,3.2593,3.35,3.4414,3.5335,3.6262,3.7192,3.8126,3.9063,4]\n```\n"
    },
    "split": {
        "url": "https://docs.dolphindb.com/en/Functions/s/split.html",
        "signatures": [
            {
                "full": "split(str, [delimiter])",
                "name": "split",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [split](https://docs.dolphindb.com/en/Functions/s/split.html)\n\n\n\n#### Syntax\n\nsplit(str, \\[delimiter])\n\n#### Arguments\n\n**str** is a STRING scalaror vector.\n\n**delimiter** (optional) is a CHAR or STRING scalar indicating the separator. It can consist of one or more characters, with the default being a comma (',').\n\n#### Details\n\n* If *delimiter* is not specified, split *str* into a CHAR vector.\n\n* If *delimiter* is specified, use *delimiter* as the delimiter to split str into a CHAR vector or a STRING vector.\n\n* *str* is a scalar:\n\n  * If *delimiter* is not specified, split *str* into a CHAR vector.\n\n  * If *delimiter* is specified, use *delimiter* as the delimiter to split str into a CHAR vector or a STRING vector.\n\n* *str* is a vector: Split each element of the vector as described above. Return the results in a columnar tuple.\n\n#### Examples\n\n```\nsplit(\"xyz 1\");\n// output\n['x','y','z',' ','1']\n\nsplit(\"xyz 1\",\" \");\n// output\n[\"xyz\",\"1\"]\n\nsplit(`xyz1,`xyz);\n// output\n[,\"1\"]\n\nsplit(`xyz1,`xyz)[1];\n// output\n1\n\na = split\\(\"20220101 09:00:00\" \"20220101 09:12:20\" \"20220101 10:00:00\", \" \"\\)\n// output\n\\(\\[\"20220101\",\"09:00:00\"\\],\\[\"20220101\",\"09:12:20\"\\],\\[\"20220101\",\"10:00:00\"\\]\\)\n\n// access by column\na\\[0\\];\n// output\n\\[\"20220101\",\"20220101\",\"20220101\"\\]\n\na\\[1\\];\n// output\n\\[\"09:00:00\",\"09:12:20\",\"10:00:00\"\\]\n\n//access by row\na.row\\(0\\)\n// output\n\\[\"20220101\",\"09:00:00\"\\]\n```\n"
    },
    "splrep": {
        "url": "https://docs.dolphindb.com/en/Functions/s/splrep.html",
        "signatures": [
            {
                "full": "splrep(x, y, t)",
                "name": "splrep",
                "parameters": [
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "y",
                        "name": "y"
                    },
                    {
                        "full": "t",
                        "name": "t"
                    }
                ]
            }
        ],
        "markdown": "### [splrep](https://docs.dolphindb.com/en/Functions/s/splrep.html)\n\n#### Syntax\n\nsplrep(x, y, t)\n\n#### Arguments\n\n**x** and **y** are vectors of Integral/Temporal/Floating/Decimal type that define the data points for the cubic spline curve y = f(x). Note that x and y must have the same length, and the input values of y must be in ascending order.\n\n**t** (optional) is a vector indicating the knots needed. Splines can have different polynomials on either side of the knots. The values in *t* must satisfy the Schoenberg-Whitney conditions, meaning there must exist a subset of data points x\\[j] for all j=0, 1,...,n-5 such that t\\[j] < x\\[j] < t\\[j+4].\n\n#### Details\n\n`splrep`, short for Spline Representation, is used to find the B-spline representation of a one-dimensional curve. With a given set of data points (x\\[i], y\\[i]), it determines the degree-3 smooth spline approximation over the interval x\\[0] <= x <= x\\[size(x)-1]. If NULL is included in the input values of *x*, *y*, or *t*, it will be filled with 0.\n\n**Return value**: A tuple of length 3 containing the vector of knots, the B-spline coefficients, and the degree of the spline.\n\n#### Examples\n\n```\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\ny = [0, 3, 5, 6, 5, 3, 1, 2, 4, 5]\nt=[1,3,5,8]\ntck= splrep(x, y, t=t)\nprint(tck)\n// output\n([0,0,0,0,1,3,5,8,9,9,9,9],[0,2.234794827972243,2.999908797063527,8.195517483732592,0.982766102937427,0.416533320193195,6.868465914739519,5,0,0,0,0],3)\n```\n\nRelated function: [splev](https://docs.dolphindb.com/en/Functions/s/splev.html)\n\n"
    },
    "sql": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sql.html",
        "signatures": [
            {
                "full": "sql(select, from, [where], [groupBy], [groupFlag], [csort], [ascSort], [having], [orderBy], [ascOrder], [limit], [hint], [exec=false], [map=false])",
                "name": "sql",
                "parameters": [
                    {
                        "full": "select",
                        "name": "select"
                    },
                    {
                        "full": "from",
                        "name": "from"
                    },
                    {
                        "full": "[where]",
                        "name": "where",
                        "optional": true
                    },
                    {
                        "full": "[groupBy]",
                        "name": "groupBy",
                        "optional": true
                    },
                    {
                        "full": "[groupFlag]",
                        "name": "groupFlag",
                        "optional": true
                    },
                    {
                        "full": "[csort]",
                        "name": "csort",
                        "optional": true
                    },
                    {
                        "full": "[ascSort]",
                        "name": "ascSort",
                        "optional": true
                    },
                    {
                        "full": "[having]",
                        "name": "having",
                        "optional": true
                    },
                    {
                        "full": "[orderBy]",
                        "name": "orderBy",
                        "optional": true
                    },
                    {
                        "full": "[ascOrder]",
                        "name": "ascOrder",
                        "optional": true
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    },
                    {
                        "full": "[hint]",
                        "name": "hint",
                        "optional": true
                    },
                    {
                        "full": "[exec=false]",
                        "name": "exec",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[map=false]",
                        "name": "map",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [sql](https://docs.dolphindb.com/en/Functions/s/sql.html)\n\n\n\n#### Syntax\n\nsql(select, from, \\[where], \\[groupBy], \\[groupFlag], \\[csort], \\[ascSort], \\[having], \\[orderBy], \\[ascOrder], \\[limit], \\[hint], \\[exec=false], \\[map=false])\n\n#### Arguments\n\n**select** is metacode indicating the columns to be selected. Each column is generated by either function [sqlCol](https://docs.dolphindb.com/en/Functions/s/sqlCol.html) or [sqlColAlias](https://docs.dolphindb.com/en/Functions/s/sqlColAlias.html) . Use a tuple to select multiple columns.\n\n**from** is a table object or table name.\n\n**where** (optional) indicates the \"where\" conditions. In case of multiple \"where\" conditions, use an ANY vector with each element corresponding to the metacode of a condition.\n\n**groupBy** (optional) indicates \"group by\" or \"context by\" column(s). In case of multiple \"group by\" columns, use an ANY vector with each element corresponding to the metacode of a column name.\n\n**groupFlag** (optional) 1 means \"group by\"; 0 means \"context by\"; 2 means \"pivot by\". The default value is 1.\n\n**csort** (optional) is metacode or a tuple of metacode that specifies the column name(s) followed by `csort`. This parameter only works when *contextBy*is specified.\n\n**ascSort**(optional) is a scalar or vector indicating whether each *csort*column is sorted in ascending or descending order. 1 (default) means ascending and 0 means descending.\n\n**having**(optional) is metacode or a tuple of metacode that specifies the `having` condition(s). This parameter only works when *contextBy*is specified.\n\n**orderBy** (optional) indicates \"order by\" column(s). In case of multiple \"order by\" columns, use a tuple with each element corresponding to the metacode of a column name.\n\n**ascOrder** (optional) is a scalar or vector indicating whether each \"order by\" column is sorted in ascending or descending order. 1 means sorting in ascending order; 0 means sorting in descending order. The default value is 1.\n\n**limit** (optional) is an integer or an integral pair indicating the number of rows to select from the result starting from the first row. If *groupBy* is specified and *groupFlag*=0, select limit rows from each group starting from the first row in each group. It corresponds to \"top\" clause in \"select\" statements.\n\n**hint** (optional) is a constant that can take the following values:\n\n* HINT\\_HASH: use Hashing algorithm to execute \"group by\" statements.\n\n* HINT\\_SNAPSHOT: query data from snapshot engine.\n\n* HINT\\_KEEPORDER: the records in the result after executing \"context by\" statements are in the same order as in the input data.\n\n**exec** indicates whether to use the exec clause. The default value is false. If set to be true, a scalar or a vector will be generated. If the \"pivot by\" is used in the exec clause, a matrix can be generated.\n\n**map**(optional) is a Boolean scalar specifying whether to use the `map` keyword. The default value is false.\n\n#### Details\n\nCreate a SQL statement dynamically. To execute the generated SQL statement, use function [eval](https://docs.dolphindb.com/en/Functions/e/eval.html).\n\n#### Examples\n\n```\nsymbol = take(`GE,6) join take(`MSFT,6) join take(`F,6)\ndate=take(take(2017.01.03,2) join take(2017.01.04,4), 18)\nprice=31.82 31.69 31.92 31.8  31.75 31.76 63.12 62.58 63.12 62.77 61.86 62.3 12.46 12.59 13.24 13.41 13.36 13.17\nvolume=2300 3500 3700 2100 1200 4600 1800 3800 6400 4200 2300 6800 4200 5600 8900 2300 6300 9600\nt1 = table(symbol, date, price, volume);\n\nt1;\n```\n\n| symbol | date       | price volume |\n| ------ | ---------- | ------------ |\n| GE     | 2017.01.03 | 31.82 2300   |\n| GE     | 2017.01.03 | 31.69 3500   |\n| GE     | 2017.01.04 | 31.92 3700   |\n| GE     | 2017.01.04 | 31.8 2100    |\n| GE     | 2017.01.04 | 31.75 1200   |\n| GE     | 2017.01.04 | 31.76 4600   |\n| MSFT   | 2017.01.03 | 63.12 1800   |\n| MSFT   | 2017.01.03 | 62.58 3800   |\n| MSFT   | 2017.01.04 | 63.12 6400   |\n| MSFT   | 2017.01.04 | 62.77 4200   |\n| MSFT   | 2017.01.04 | 61.86 2300   |\n| MSFT   | 2017.01.04 | 62.3 6800    |\n| F      | 2017.01.03 | 12.46 4200   |\n| F      | 2017.01.03 | 12.59 5600   |\n| F      | 2017.01.04 | 13.24 8900   |\n| F      | 2017.01.04 | 13.41 2300   |\n| F      | 2017.01.04 | 13.36 6300   |\n| F      | 2017.01.04 | 13.17 9600   |\n\n```\nx=5000\nwhereConditions = [<symbol=`MSFT>,<volume>x>]\nhavingCondition = <sum(volume)>200>;\n\nsql(sqlCol(\"*\"), t1);\n// output: < select * from t1 >\n\nsql(sqlCol(\"*\"), t1, whereConditions);\n// output: < select * from t1 where symbol == \"MSFT\",volume > x >\n\nsql(select=sqlColAlias(<avg(price)>), from=t1, where=whereConditions, groupBy=sqlCol(`date));\n// output: < select avg(price) as avg_price from t1 where symbol == \"MSFT\",volume > x group by date >\n\nsql(select=sqlColAlias(<avg(price)>), from=t1, groupBy=[sqlCol(`date),sqlCol(`symbol)]);\n// output: < select avg(price) as avg_price from t1 group by date,symbol >\n\nsql(select=(sqlCol(`symbol),sqlCol(`date),sqlColAlias(<cumsum(volume)>, `cumVol)), from=t1, groupBy=sqlCol(`date`symbol), groupFlag=0);\n// output: < select symbol,date,cumsum(volume) as cumVol from t1 context by date,symbol >\n\nsql(select=(sqlCol(`symbol),sqlCol(`date),sqlColAlias(<cumsum(volume)>, `cumVol)), from=t1, where=whereConditions, groupBy=sqlCol(`date), groupFlag=0);\n// output: < select symbol,date,cumsum(volume) as cumVol from t1 where symbol == \"MSFT\",volume > x context by date >\n\nsql(select=(sqlCol(`symbol),sqlCol(`date),sqlColAlias(<cumsum(volume)>, `cumVol)), from=t1, where=whereConditions, groupBy=sqlCol(`date), groupFlag=0, csort=sqlCol(`volume), ascSort=0);\n// output: < select symbol,date,cumsum(volume) as cumVol from t1 where symbol == \"MSFT\",volume > x context by date csort volume desc >\n\nsql(select=(sqlCol(`symbol),sqlCol(`date),sqlColAlias(<cumsum(volume)>, `cumVol)), from=t1, where=whereConditions, groupBy=sqlCol(`date), groupFlag=0, having=havingCondition);\n// output: < select symbol,date,cumsum(volume) as cumVol from t1 where symbol == \"MSFT\",volume > x context by date having sum(volume) > 200 >\n\nsql(select=sqlCol(\"*\"), from=t1, where=whereConditions, orderBy=sqlCol(`date), ascOrder=0);\n// output: < select * from t1 where symbol == \"MSFT\",volume > x order by date desc >\n\nsql(select=sqlCol(\"*\"), from=t1, limit=1);\n// output: < select top 1 * from t1 >\n\nsql(select=sqlCol(\"*\"), from=t1, groupBy=sqlCol(`symbol), groupFlag=0, limit=1);\n// output: < select top 1 * from t1 context by symbol >\n\nsql(select=(sqlCol(`symbol),sqlCol(`date),sqlColAlias(<cumsum(volume)>, `cumVol)), from=t1, groupBy=sqlCol(`date`symbol), groupFlag=0, hint=HINT_KEEPORDER);\n// output: < select [128] symbol,date,cumsum(volume) as cumVol from t1 context by date,symbol >\n\nwhereConditions1 = <symbol=`MSFT or volume>x>\nsql(select=sqlCol(\"*\"), from=t1, where=whereConditions1, orderBy=sqlCol(`date), ascOrder=0);\n// output: < select * from t14059d76a00000000 where symbol == \"MSFT\" or volume > x order by date desc > \n\nsql(select=sqlCol(\"*\"), from=t1, where=whereConditions, orderBy=sqlCol(`date), ascOrder=0, map=true);\n// output: < select [256] * from t17092a30500000000 where symbol == \"MSFT\",volume > x order by date desc map >\n```\n\nA convenient and flexible way to generate complicated queries dynamically is to define a function that calls function `sql`.\n\n```\ndef f1(t, sym, x){\nwhereConditions=[<symbol=sym>,<volume>x>]\nreturn sql(sqlCol(\"*\"),t,whereConditions).eval()\n};\n\nf1(t1, `MSFT, 5000);\n```\n\n| symbol | date       | price volume |\n| ------ | ---------- | ------------ |\n| MSFT   | 2017.01.04 | 63.12 6400   |\n| MSFT   | 2017.01.04 | 62.3 6800    |\n\n```\nf1(t1, `F, 9000);\n```\n\n| symbol | date       | price volume |\n| ------ | ---------- | ------------ |\n| F      | 2017.01.04 | 13.17 9600   |\n\n```\ndef f2(t, sym, colNames, filterColumn, filterValue){\n whereConditions=[<symbol=sym>,expr(sqlCol(filterColumn),>,filterValue)]\n    return sql(sqlCol(colNames),t,whereConditions).eval()\n};\n```\n\n```\nf2(t1,`GE, `symbol`date`volume, `volume, 3000);\n```\n\n| symbol | date       | volume |\n| ------ | ---------- | ------ |\n| GE     | 2017.01.03 | 3500   |\n| GE     | 2017.01.04 | 3700   |\n| GE     | 2017.01.04 | 4600   |\n\n```\nf2(t1,`F, `symbol`date`volume,`price,13.2);\n```\n\n| symbol | date       | volume |\n| ------ | ---------- | ------ |\n| F      | 2017.01.04 | 8900   |\n| F      | 2017.01.04 | 2300   |\n| F      | 2017.01.04 | 6300   |\n\nSet the parameter *exec*=true and use `exec` clause with the pivot by statement to generate a matrix:\n\n```\ndate = 2020.09.21 + 0 0 0 0 1 1 1 1\nsym = `MS`MS`GS`GS`MS`MS`GS`GS$SYMBOL\nfactorNum = 1 2 1 2 1 2 1 2\nfactorValue = 1.2 -3.4 -2.5 6.3 1.1 -3.2 -2.1 5.6\nt = table(date, sym, factorNum, factorValue);\nsql(select=sqlCol(`factorValue), from=t, groupBy=[sqlCol(`date), sqlCol(`sym)], groupFlag=2, exec=true)\n\n// output: < exec factorValue from t pivot by date,sym >\n```\n"
    },
    "sqlCol": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sqlCol.html",
        "signatures": [
            {
                "full": "sqlCol(colName, [func], [alias], [qualifier])",
                "name": "sqlCol",
                "parameters": [
                    {
                        "full": "colName",
                        "name": "colName"
                    },
                    {
                        "full": "[func]",
                        "name": "func",
                        "optional": true
                    },
                    {
                        "full": "[alias]",
                        "name": "alias",
                        "optional": true
                    },
                    {
                        "full": "[qualifier]",
                        "name": "qualifier",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sqlCol](https://docs.dolphindb.com/en/Functions/s/sqlCol.html)\n\n\n\n#### Syntax\n\nsqlCol(colName, \\[func], \\[alias], \\[qualifier])\n\n#### Arguments\n\n**colName** is a string scalar/vector indicating column name(s).\n\n**func** (optional) is a unary function.\n\n**alias** (optional) is a string scalar/vector indicating column name(s) of the selected column(s) or calculation result(s).\n\n**qualifier** (optional) is a STRING scalar. It is only used in a table join operation when we need to select a column that appears in both tables and that is not a matching column. It indicates the table from which to select the column.\n\n#### Details\n\nGenerate metacode for selecting one or multiple columns with or without calculations. It is generally used together with function [sql](https://docs.dolphindb.com/en/Functions/s/sql.html) and [eval](https://docs.dolphindb.com/en/Functions/e/eval.html) to generate SQL statements dynamically.\n\n#### Examples\n\n```\nt = table(`GME`AMC`KOSS as symbol, 325 13.26 64 as price);\ncolName=\"symbol\";\nsql(select=sqlCol(colName), from=t).eval();\n```\n\n| symbol |\n| ------ |\n| GME    |\n| AMC    |\n| KOSS   |\n\n```\ncolName=\"price\";\nsql(select=sqlCol(colName, max, `maxPrice), from=t).eval();\n```\n\n| maxPrice |\n| -------- |\n| 325      |\n\n```\nt1 = table(1 2 3 3 as id, 7.8 4.6 5.1 0.1 as value, 4 3 2 1 as x);\nt2 = table(5 3 1 as id,  300 500 800 as qty, 44 66 88 as x) ;\nsql(select=(sqlCol(`id),sqlCol(colName=`x, alias=\"t1_x\", qualifier=\"t1\"),sqlCol(colName=`x, alias=\"t2_x\", qualifier=`t2)), from=<ej(t1,t2,`id)>).eval()\n```\n\n| id | t1\\_x | t2\\_x |\n| -- | ----- | ----- |\n| 1  | 4     | 88    |\n| 3  | 2     | 66    |\n| 3  | 1     | 66    |\n"
    },
    "sqlColAlias": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sqlColAlias.html",
        "signatures": [
            {
                "full": "sqlColAlias(colDefs, [colNames])",
                "name": "sqlColAlias",
                "parameters": [
                    {
                        "full": "colDefs",
                        "name": "colDefs"
                    },
                    {
                        "full": "[colNames]",
                        "name": "colNames",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sqlColAlias](https://docs.dolphindb.com/en/Functions/s/sqlColAlias.html)\n\n\n\n#### Syntax\n\nsqlColAlias(colDefs, \\[colNames])\n\n#### Arguments\n\n**colDefs** is metacode.\n\n**colNames** (optional) is a string indicating an alias name.\n\n#### Details\n\nUse metacode and an optional alias name to define a column. It is often used to name calculated columns.\n\n#### Examples\n\n```\nsqlColAlias(<x>, `y);\n// output\n< x as y >\n\nsqlColAlias(<avg(PRC)>, `avgPRC);\n// output\n< avg(PRC) as avgPRC >\n\nsqlColAlias(<avg(PRC)>);\n// output\n< avg(PRC) as avg_PRC >\n```\n"
    },
    "sqlDelete": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sqlDelete.html",
        "signatures": [
            {
                "full": "sqlDelete(table, [where], [from])",
                "name": "sqlDelete",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "[where]",
                        "name": "where",
                        "optional": true
                    },
                    {
                        "full": "[from]",
                        "name": "from",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sqlDelete](https://docs.dolphindb.com/en/Functions/s/sqlDelete.html)\n\n\n\n#### Syntax\n\nsqlDelete(table, \\[where], \\[from])\n\n#### Arguments\n\n**table** can be an in-memory table or a DFS table.\n\n**where** (optional) is a metacode indicating the where condition.\n\n**from** (optional) is metacode indicating the from clause, which supports specifying table joins using `ej` or `lj`.\n\n#### Details\n\nDynamically generate a metacode of the SQL delete statement. To execute the generated metacode, please use function [eval](https://docs.dolphindb.com/en/Functions/e/eval.html).\n\n#### Examples\n\nExample 1. Delete the records in an in-memory table\n\n```\nt1=table(`A`B`C as symbol, 10 20 30 as x)\nsqlDelete(t1, <symbol=`C>).eval()\nt1;\n```\n\n| symbol | x  |\n| ------ | -- |\n| A      | 10 |\n| B      | 20 |\n\nExample 2. Delete the records in a DFS table\n\n```\nif(existsDatabase(\"dfs://db1\")){\n    dropDatabase(\"dfs://db1\")\n}\n\nn=1000000\nt=table(take(`A`B`C`D,n) as symbol, rand(10.0, n) as value)\ndb = database(\"dfs://db1\", VALUE, `A`B`C`D)\nTrades = db.createPartitionedTable(t, \"Trades\", \"symbol\")\nTrades.append!(t)\nselect count(*) from Trades;\n\n// output\n1000000\n\nTrades=loadTable(\"dfs://db1\", \"Trades\")\nsqlDelete(Trades, <symbol=`A>).eval()\nselect count(*) from Trades;\n\n// output\n750000\n```\n\nExample 3. Delete records using table joins. The following example deletes records from t2 that have a matching id in both t1 and t2, where the flag in t1 is equal to 1.\n\n```\nt1 = table(1..5 as id, [1,2,2,1,1] as flag)\nt2 = table(3..7 as id, [100,200,100,150,100] as profit)\nsqlDelete(table=t2, where=<flag=1>, from=<ej(t2,t1,`id)>).eval()\nt2\n```\n\n| id | profit |\n| :- | :----- |\n| 3  | 100    |\n| 6  | 150    |\n| 7  | 100    |\n"
    },
    "sqlDS": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sqlDS.html",
        "signatures": [
            {
                "full": "sqlDS(sqlObj, [forcePartition=false])",
                "name": "sqlDS",
                "parameters": [
                    {
                        "full": "sqlObj",
                        "name": "sqlObj"
                    },
                    {
                        "full": "[forcePartition=false]",
                        "name": "forcePartition",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html)\n\n\n\n#### Syntax\n\nsqlDS(sqlObj, \\[forcePartition=false])\n\n#### Arguments\n\n**sqlObj** is SQL metacode. For more details about metacode please refer to the section of [Metaprogramming](https://docs.dolphindb.com/en/Programming/Metaprogramming/functional_meta.html).\n\n**forcePartition** (optional) is a Boolean value. The default value is false. If it is set to false, the system checks if the query can be splitted into multiple child queries. If not then it won't split the query over partitions and will throw an exception. However, when it is set to true, the system splits the query over partitions and runs the query on selected partitions. Cases when a query cannot be splitted into child queries include (1) the group by columns are not partitioning columns; (2) the order by clause is specified, among others.\n\n#### Details\n\nCreate a list of data sources based on the input SQL metacode. If the table in the SQL metacode has n partitions, *sqlDS* generates n data sources. If the SQL metacode doesn't contain any partitioned table, *sqlDS* returns a tuple containing one data source. This function divides a large file into several partitions, each representing a subset of the data, and returns a tuple of the data source. A data source is generally represented by a code object and serves as a function call that takes metaprogramming as its parameter and returns a table.\n\n#### Examples\n\n```\nn=1000000\ndate=take(2019.01.01..2019.01.03,n)\nsym = take(`C`MS`MS`MS`IBM`IBM`IBM`C`C$SYMBOL,n)\nprice= take(49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29,n)\nqty = take(2200 1900 2100 3200 6800 5400 1300 2500 8800,n)\nt=table(date, sym, price, qty)\n\ndb1=database(\"\",VALUE,2019.01.01..2019.01.03)\ndb2=database(\"\",VALUE,`C`MS`IBM)\ndb=database(\"dfs://stock\",COMPO,[db1,db2])\ntrades=db.createPartitionedTable(t,`trades,`date`sym).append!(t)\n\nds=sqlDS(<select * from trades where date=2019.01.02>);\n\ntypestr ds;\n// output\nANY VECTOR\n\nsize ds;\n// output\n3\n\nds[0];\n// output\nDataSource< select [7] * from trades [partition = /stock/20190102/C] >\n\nds[1];\n// output\nDataSource< select [7] * from trades [partition = /stock/20190102/IBM] >\n\nds[2];\n// output\nDataSource< select [7] * from trades [partition = /stock/20190102/MS] >\n```\n"
    },
    "sqlTuple": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sqlTuple.html",
        "signatures": [
            {
                "full": "sqlTuple(colNames)",
                "name": "sqlTuple",
                "parameters": [
                    {
                        "full": "colNames",
                        "name": "colNames"
                    }
                ]
            }
        ],
        "markdown": "### [sqlTuple](https://docs.dolphindb.com/en/Functions/s/sqlTuple.html)\n\n\n\n#### Syntax\n\nsqlTuple(colNames)\n\n#### Arguments\n\n**colNames** is a STRING scalar/vector indicating column names.\n\n#### Details\n\nGenerate metacode with a tuple expression. The elements of the tuple are specified by *colNames*. `sqlTuple` is usually used with `sql` and `makeUnifiedCall` to dynamically generate SQL statements.\n\n#### Examples\n\nIn the following example, the parameter *args* of `makeUnifiedCall` is tuple metacode generated using `sqlTuple`, and *func* is a user-defined function. The result of `makeUnifiedCall` is passed as the parameter *select* of function `sql` to generate SQL metacode `c`.\n\n```\n// Create a user-defined function\nf = def (x,y)->(x-y)/(x+y)\n\n// Create a table for query\nt = table(1.0 2.0 3.0 as qty1, 1.0 3.0 7.0 as qty2)\n\n// Generate metacode for query\nc = sql(select=makeUnifiedCall(f, sqlTuple(`qty1`qty2)), from=t)\n\n// Execute the corresponding metacode\nc.eval()\n```\n\n<table id=\"table_ssl_nwc_s1c\"><thead><tr><th align=\"left\">\n\n**\\_qty1**\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\n0\n\n</td></tr><tr><td align=\"left\">\n\n-0.2\n\n</td></tr><tr><td align=\"left\">\n\n-0.4\n\n</td></tr></tbody>\n</table>\n"
    },
    "sqlUpdate": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sqlUpdate.html",
        "signatures": [
            {
                "full": "sqlUpdate(table, updates, [from], [where], [contextBy], [csort], [ascSort], [having])",
                "name": "sqlUpdate",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "updates",
                        "name": "updates"
                    },
                    {
                        "full": "[from]",
                        "name": "from",
                        "optional": true
                    },
                    {
                        "full": "[where]",
                        "name": "where",
                        "optional": true
                    },
                    {
                        "full": "[contextBy]",
                        "name": "contextBy",
                        "optional": true
                    },
                    {
                        "full": "[csort]",
                        "name": "csort",
                        "optional": true
                    },
                    {
                        "full": "[ascSort]",
                        "name": "ascSort",
                        "optional": true
                    },
                    {
                        "full": "[having]",
                        "name": "having",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sqlUpdate](https://docs.dolphindb.com/en/Functions/s/sqlUpdate.html)\n\n\n\n#### Syntax\n\nsqlUpdate(table, updates, \\[from], \\[where], \\[contextBy], \\[csort], \\[ascSort], \\[having])\n\n#### Arguments\n\n**table** can be an in-memory table or a distributed table.\n\n**update** is a metacode or a tuple of metacode, indicating the updating operation.\n\n**from** (optional) is a metacode indicating the table join operation.\n\n**where** (optional) is a metacode indicating the where condition.\n\n**contextBy** (optional) is a metacode indicating the context by clause.\n\n**csort** (optional) is metacode or a tuple of metacode that specifies the column name(s) followed by `csort`. This parameter only works when *contextBy*is specified.\n\n**ascSort**(optional) is a scalar or vector indicating whether each *csort*column is sorted in ascending or descending order. 1 (default) means ascending and 0 means descending.\n\n**having**(optional) is metacode or a tuple of metacode that specifies the `having` condition(s). This parameter only works when *contextBy*is specified.\n\n#### Details\n\nDynamically generate a metacode of the SQL update statement. To execute the generated metacode, please use function [eval](https://docs.dolphindb.com/en/Functions/e/eval.html).\n\n#### Examples\n\nExample 1. Update the records in an in-memory table\n\n```\nt1=table(`A`A`B`B as symbol, 2021.04.15 2021.04.16 2021.04.15 2021.04.16 as date, 12 13 21 22 as price)\nt2=table(`A`A`B`B as symbol, 2021.04.15 2021.04.16 2021.04.15 2021.04.16 as date, 10 20 30 40 as volume);\n\nsqlUpdate(t1, <price*2 as updatedPrice>).eval()\nt1;\n```\n\n| symbol | date       | price | updatedPrice |\n| ------ | ---------- | ----- | ------------ |\n| A      | 2021.04.15 | 12    | 24           |\n| A      | 2021.04.16 | 13    | 26           |\n| B      | 2021.04.15 | 21    | 42           |\n| B      | 2021.04.16 | 22    | 44           |\n\n```\nsqlUpdate(table=t1, updates=[<price*10 as updatedPrice>,<price*20 as updatedPrice2>]).eval()\nt1;\n```\n\n| symbol | date       | price | updatedPrice | updatedPrice2 |\n| ------ | ---------- | ----- | ------------ | ------------- |\n| A      | 2021.04.15 | 12    | 120          | 240           |\n| A      | 2021.04.16 | 13    | 130          | 260           |\n| B      | 2021.04.15 | 21    | 210          | 420           |\n| B      | 2021.04.16 | 22    | 220          | 440           |\n\n```\nsqlUpdate(table=t2, updates=<cumsum(volume) as cumVolume>, contextby=<symbol>).eval()\nt2;\n```\n\n| symbol | date       | volume | cumVolume |\n| ------ | ---------- | ------ | --------- |\n| A      | 2021.04.15 | 10     | 10        |\n| A      | 2021.04.16 | 20     | 30        |\n| B      | 2021.04.15 | 30     | 30        |\n| B      | 2021.04.16 | 40     | 70        |\n\n```\nsqlUpdate(table=t1, updates=<updatedPrice*volume as dollarVolume>, from=<lj(t1, t2, `symbol`date)>).eval()\nt1;\n```\n\n| symbol | date       | price | updatedPrice | dollarVolume |\n| ------ | ---------- | ----- | ------------ | ------------ |\n| A      | 2021.04.15 | 12    | 120          | 1200         |\n| A      | 2021.04.16 | 13    | 130          | 2600         |\n| B      | 2021.04.15 | 21    | 42           | 1260         |\n| B      | 2021.04.16 | 22    | 44           | 1760         |\n\n```\nsqlUpdate(table=t2,updates=<cumsum(volume) as cumVolume>,contextBy=<symbol>,csort=<volume>,ascSort=0).eval()\nt2;\n```\n\n| symbol | date       | volume | cumVolume |\n| ------ | ---------- | ------ | --------- |\n| A      | 2021.04.15 | 10     | 30        |\n| A      | 2021.04.16 | 20     | 20        |\n| B      | 2021.04.15 | 30     | 70        |\n| B      | 2021.04.16 | 40     | 40        |\n\nExample 2. Update a DFS table\n\n```\nif(existsDatabase(\"dfs://db1\")){\n    dropDatabase(\"dfs://db1\")\n}\nn=1000000\nt=table(take(`A`B`C`D,n) as symbol, rand(10.0, n) as value)\ndb = database(\"dfs://db1\", VALUE, `A`B`C`D)\nTrades = db.createPartitionedTable(t, \"Trades\", \"symbol\")\nTrades.append!(t)\nx=exec sum(value) from Trades;\n\nTrades=loadTable(\"dfs://db1\", \"Trades\")\nsqlUpdate(table=Trades, updates=<value+1 as value>, where=<symbol=`A>).eval()\ny=exec sum(value) from Trades;\n\ny-x;\n\n// output\n250000\n```\n"
    },
    "sqrt": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sqrt.html",
        "signatures": [
            {
                "full": "sqrt(X)",
                "name": "sqrt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sqrt](https://docs.dolphindb.com/en/Functions/s/sqrt.html)\n\n\n\n#### Syntax\n\nsqrt(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nReturn the square root of each element in *X*. The data type of the result is always DOUBLE.\n\n#### Examples\n\n```\nsqrt(4 16 -4 NULL);\n// output\n[2,4, , ]\n\ntypestr(sqrt(4));\n// output\nDOUBLE\n```\n"
    },
    "square": {
        "url": "https://docs.dolphindb.com/en/Functions/s/square.html",
        "signatures": [
            {
                "full": "square(X)",
                "name": "square",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [square](https://docs.dolphindb.com/en/Functions/s/square.html)\n\n\n\n#### Syntax\n\nsquare(X)\n\n#### Arguments\n\n**X** is a scalar/pair/vector/matrix.\n\n#### Details\n\nReturn the square of *X*. The data type of the result is always DOUBLE.\n\n#### Examples\n\n```\nsquare(3);\n// output\n9\n\nsquare(2 4 NULL 6);\n// output\n[4,16,,36]\n\nsquare(1..4$2:2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 9  |\n| 4  | 16 |\n"
    },
    "startClusterReplication": {
        "url": "https://docs.dolphindb.com/en/Functions/s/startClusterReplication.html",
        "signatures": [
            {
                "full": "startClusterReplication()",
                "name": "startClusterReplication",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [startClusterReplication](https://docs.dolphindb.com/en/Functions/s/startClusterReplication.html)\n\n#### Syntax\n\nstartClusterReplication()\n\n#### Arguments\n\nNone\n\n#### Details\n\nStarts the cluster replication that was stopped due to repeated failures or by calling `stopClusterReplication`.\n\nIt can only be executed by an administrator on the controller of a master/slave cluster. The configuration parameter *replicationMode* should be specified before you execute this command.\n\n#### Example\n\n```\nstartClusterReplication();\n```\n\nRelated functions: [stopClusterReplication](https://docs.dolphindb.com/en/Functions/s/stopClusterReplication.html), [skipClusterReplicationTask](https://docs.dolphindb.com/en/Functions/s/skipClusterReplicationTask.html)\n\n"
    },
    "startDataNode": {
        "url": "https://docs.dolphindb.com/en/Functions/s/startDataNode.html",
        "signatures": [
            {
                "full": "startDataNode(X)",
                "name": "startDataNode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [startDataNode](https://docs.dolphindb.com/en/Functions/s/startDataNode.html)\n\n\n\n#### Syntax\n\nstartDataNode(X)\n\n#### Arguments\n\n**X** is a vector, which contains information about the data nodes/compute nodes to be started.\n\n#### Details\n\nStart data nodes/compute nodes on a cluster controller.\n\n#### Examples\n\n```\nx = [\"192.168.1.27:8506\",\"192.168.1.27:8502\",\"192.168.1.27:8527\"]\nstartDataNode(x);\n```\n"
    },
    "startHeapSample": {
        "url": "https://docs.dolphindb.com/en/Functions/s/startHeapSample.html",
        "signatures": [
            {
                "full": "startHeapSample(sampleParameter)",
                "name": "startHeapSample",
                "parameters": [
                    {
                        "full": "sampleParameter",
                        "name": "sampleParameter"
                    }
                ]
            }
        ],
        "markdown": "### [startHeapSample](https://docs.dolphindb.com/en/Functions/s/startHeapSample.html)\n\n\n\n#### Syntax\n\nstartHeapSample(sampleParameter)\n\n#### Details\n\nThis function dynamically enables heap memory sampling. It sets the TCMALLOC\\_SAMPLE\\_PARAMETER environment variable, allowing developers to monitor and analyze the program's memory usage. Only administrators can execute this function.\n\n#### Arguments\n\n**sampleParameter** is a LONG integer ranging from 1 to 524,288, indicating the approximate gap between sampling actions in bytes. The system takes one sample approximately once every *sampleParmeter* bytes of allocation. A reasonable value is 524288.\n\n#### Examples\n\nRecommended workflow for memory usage analysis:\n\n1. Enable heap memory sampling: This can be done by setting the environment variable TCMALLOC\\_SAMPLE\\_PARAMETER to a value between 1 and 524288 (recommended: 524288) before starting DolphinDB; or by dynamically enabling it using `startHeapSample`.\n2. Execute `dumpHeapSample` before and after operations that may cause memory leaks, saving to two different files. Compare these files to confirm memory allocation and usage related to the operation.\n3. Disable heap memory sampling.\n\n```\nstartHeapSample(524288)\n\ndumpHeapSample(\"/DolphinDB/Data/heap1\")\ndumpHeapSample(\"/DolphinDB/Data/heap2\")\n\nstopHeapSample()\n```\n\nRelated functions: [dumpHeapSample](https://docs.dolphindb.com/en/Functions/d/dumpHeapSample.html), [stopHeapSample](https://docs.dolphindb.com/en/Functions/s/stopHeapSample.html)\n"
    },
    "startsWith": {
        "url": "https://docs.dolphindb.com/en/Functions/s/startsWith.html",
        "signatures": [
            {
                "full": "startsWith(X, str)",
                "name": "startsWith",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "str",
                        "name": "str"
                    }
                ]
            }
        ],
        "markdown": "### [startsWith](https://docs.dolphindb.com/en/Functions/s/startsWith.html)\n\n\n\n#### Syntax\n\nstartsWith(X, str)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n**str** is a string scalar.\n\n#### Details\n\nCheck if *X* starts with *str*. If yes, return true; otherwise return false.\n\n#### Examples\n\n```\nstr1=\"US product\"\nstr2=\"UK product\"\nif (startsWith(str1, \"US\")) print \"str1 is a US product.\"\nelse print \"str1 is not a US product.\"\nif (startsWith(str2, \"US\")) print \"str2 is a US product.\"\nelse print \"str2 is not a US product.\";\n\n// output\nstr1 is a US product.\nstr2 is not a US product.\n```\n"
    },
    "stat": {
        "url": "https://docs.dolphindb.com/en/Functions/s/stat.html",
        "signatures": [
            {
                "full": "stat(X)",
                "name": "stat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [stat](https://docs.dolphindb.com/en/Functions/s/stat.html)\n\n\n\n#### Syntax\n\nstat(X)\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n#### Details\n\nReturn a dictionary about the descriptive statistics of *X* including avg(mean), max, min, count, median, and stdev.\n\n#### Examples\n\n```\nx=5 7 4 3 2 1 7 8 9 NULL;\n\nstat(x);\n// output\nMedian->5\nAvg->5.111111\nMin->1\nStdev->2.803767\nCount->9\nSize->10\nName->x\nMax->9\n\nstats = stat(x);\nstats[`Avg];\n// output\n5.111111\n```\n"
    },
    "stateIterate": {
        "url": "https://docs.dolphindb.com/en/Functions/s/stateIterate.html",
        "signatures": [
            {
                "full": "stateIterate(X, initial, initialWindow, iterateFunc, combineCoeff)",
                "name": "stateIterate",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "initial",
                        "name": "initial"
                    },
                    {
                        "full": "initialWindow",
                        "name": "initialWindow"
                    },
                    {
                        "full": "iterateFunc",
                        "name": "iterateFunc"
                    },
                    {
                        "full": "combineCoeff",
                        "name": "combineCoeff"
                    }
                ]
            }
        ],
        "markdown": "### [stateIterate](https://docs.dolphindb.com/en/Functions/s/stateIterate.html)\n\n\n\n#### Syntax\n\nstateIterate(X, initial, initialWindow, iterateFunc, combineCoeff)\n\nThis function can only be used as a state function in the reactive state engine.\n\n#### Arguments\n\n**X** is a vector. It can be a column from the engine's input table, or the result of a vectorized function with the column as its input argument.\n\n**initial** is a vector used to fill the first *initialWindow* values in the corresponding result column of the engine's output table. It can be a column from the engine's input table, or the result of a vectorized function with the column as its input argument.\n\n**initialWindow** is a positive integer determining the initial window size \\[0, *initialWindow*).\n\n**iterateFunc** is the function for iteration, whose only parameter is the column from the output table. Currently, only the following functions are supported (use partial application to specify functions with multiple parameters):\n\n* Moving functions: tmove, tmavg, tmmax, tmmin, tmsum, mavg, mmax, mmin, mcount, msum\n\n* Cumulative window functions: cumlastNot, cumfirstNot\n\n* Order-sensitive functions: ffill, move\n\n**Note:**\n\n* As the iterations are performed based on the historical data, the output for the current record is calculated based on the historical results in the output table and *X*.\n\n* When calculating with time-based moving windows, windows are determined by the current timestamp T, and the interval is (T - window, T).\n\n**combineCoeff** is a vector of length 2. The elements indicate the correlation coefficients between the result of *interateFunc* and *X*.\n\n#### Details\n\nSupposing the iteration is based only on the previous result, for the k-th (k ∈ N+) record, the calculation logic is (where the column \"factor\" holds the results):\n\n* k < initialWindow: factor\\[k] = initial\\[k]\n\n* k >= initialWindow:factor\\[k] = combineCoeff\\[0] \\* X\\[k] + combineCoeff\\[1] \\* iterateFunc(factor)\\[k-1]\n\nIf *iterateFunc* is a window function, the iteration is based on multiple previous results.\n\n#### Examples\n\n```\ntrade = table(take(\"A\", 6) join take(\"B\", 6) as sym,  1..12 as val0,  take(10, 12) as val1)\ntrade;\n```\n\n| sym | val0 | val1 |\n| --- | ---- | ---- |\n| A   | 1    | 10   |\n| A   | 2    | 10   |\n| A   | 3    | 10   |\n| A   | 4    | 10   |\n| A   | 5    | 10   |\n| A   | 6    | 10   |\n| B   | 7    | 10   |\n| B   | 8    | 10   |\n| B   | 9    | 10   |\n| B   | 10   | 10   |\n| B   | 11   | 10   |\n| B   | 12   | 10   |\n\nThe following example defines a reactive state streaming engine and conducts the calculation within each group of sym.\n\n* For the 1st initialWindow records, the formula is *factor\\[k]=initial\\[k]*. So the factor\\[0], factor\\[1], factor\\[2] records take the value of val1.\n\n* For the subsequent records, the formula is *factor\\[k]=0.5\\*val0\\[k]+0.5\\*msum(factor, 3)\\[k-1]*.\n\nFor the 4th record (sym=\\`A, val0=4) in the output table, there are 3 historical values in the factor column (\\[10,10,10]). Therefore, for the current record, the output is *0.5\\*4+0.5\\*msum(\\[10, 10, 10], 3)\\[2]=17*. Similarly, for the record (sym=\\`A, val0=5), the output is *0.5\\*5+0.5\\*msum(\\[10, 10, 10, 17], 3)\\[3]=21*.\n\n```\ninputTable = streamTable(1:0, `sym`val0`val1, [SYMBOL, INT, INT])\noutputTable = table(100:0, `sym`factor, [STRING, DOUBLE])\nengine = createReactiveStateEngine(name=\"rsTest\", metrics=<[stateIterate(val0, val1, 3, msum{, 3}, [0.5, 0.5])]>, dummyTable=inputTable, outputTable=outputTable, keyColumn=[\"sym\"], keepOrder=true)\n\nengine.append!(trade)\nselect * from outputTable\n```\n\n| sym | factor |\n| --- | ------ |\n| A   | 10     |\n| A   | 10     |\n| A   | 10     |\n| A   | 17     |\n| A   | 21     |\n| A   | 27     |\n| B   | 10     |\n| B   | 10     |\n| B   | 10     |\n| B   | 20     |\n| B   | 25.5   |\n| B   | 33.75  |\n"
    },
    "std": {
        "url": "https://docs.dolphindb.com/en/Functions/s/std.html",
        "signatures": [
            {
                "full": "std(X)",
                "name": "std",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [std](https://docs.dolphindb.com/en/Functions/s/std.html)\n\n\n\n#### Syntax\n\nstd(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nIf *X* is a vector, return the (unbiased) sample standard deviation of *X*.\n\nIf *X* is a matrix, calculate the (unbiased) sample standard deviation of each column of *X* and return a vector.\n\nIf *X* is a table, calculate the (unbiased) sample standard deviation of each column of *X* and return a table.\n\nAs with all aggregate functions, NULL values are not included in the calculation.\n\n**Note:** The result is sample standard deviation instead of population standard deviation.\n\n#### Examples\n\n```\nstd(1 2 3);\n// output\n1\n\nm=matrix(1 3 5 7 9, 1 4 7 10 13);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 3  | 4  |\n| 5  | 7  |\n| 7  | 10 |\n| 9  | 13 |\n\n```\nstd(m);\n// output\n[3.162277660168379,4.743416490252569]\n```\n"
    },
    "stdp": {
        "url": "https://docs.dolphindb.com/en/Functions/s/stdp.html",
        "signatures": [
            {
                "full": "stdp(X)",
                "name": "stdp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [stdp](https://docs.dolphindb.com/en/Functions/s/stdp.html)\n\n\n\n#### Syntax\n\nstdp(X)\n\n#### Arguments\n\n**X** is a vector/matrix/table.\n\n#### Details\n\nIf *X* is a vector, return the population standard deviation of *X*.\n\nIf *X* is a matrix, calculate the population standard deviation of each column and return a vector.\n\nIf *X* is a table, calculate the population standard deviation of each column and return a table.\n\nAs with all other aggregate functions, NULL values are not included in the calculation.\n\n#### Examples\n\n```\nstdp(1 2 3);\n// output\n0.816497\n\nm=matrix(1 3 5 7 9, 1 4 7 10 13);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 3  | 4  |\n| 5  | 7  |\n| 7  | 10 |\n| 9  | 13 |\n\n```\nstdp(m);\n// output\n[2.8284,4.2426]\n```\n"
    },
    "stl": {
        "url": "https://docs.dolphindb.com/en/Functions/s/stl.html",
        "signatures": [
            {
                "full": "stl(data, period, sWindow, [sDegree], [sJump], [tWindow], [tDegree], [tJump], [lWindow], [lDegree], [lJump], [robust], [inner], [outer])",
                "name": "stl",
                "parameters": [
                    {
                        "full": "data",
                        "name": "data"
                    },
                    {
                        "full": "period",
                        "name": "period"
                    },
                    {
                        "full": "sWindow",
                        "name": "sWindow"
                    },
                    {
                        "full": "[sDegree]",
                        "name": "sDegree",
                        "optional": true
                    },
                    {
                        "full": "[sJump]",
                        "name": "sJump",
                        "optional": true
                    },
                    {
                        "full": "[tWindow]",
                        "name": "tWindow",
                        "optional": true
                    },
                    {
                        "full": "[tDegree]",
                        "name": "tDegree",
                        "optional": true
                    },
                    {
                        "full": "[tJump]",
                        "name": "tJump",
                        "optional": true
                    },
                    {
                        "full": "[lWindow]",
                        "name": "lWindow",
                        "optional": true
                    },
                    {
                        "full": "[lDegree]",
                        "name": "lDegree",
                        "optional": true
                    },
                    {
                        "full": "[lJump]",
                        "name": "lJump",
                        "optional": true
                    },
                    {
                        "full": "[robust]",
                        "name": "robust",
                        "optional": true
                    },
                    {
                        "full": "[inner]",
                        "name": "inner",
                        "optional": true
                    },
                    {
                        "full": "[outer]",
                        "name": "outer",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [stl](https://docs.dolphindb.com/en/Functions/s/stl.html)\n\n\n\n#### Syntax\n\nstl(data, period, sWindow, \\[sDegree], \\[sJump], \\[tWindow], \\[tDegree], \\[tJump], \\[lWindow], \\[lDegree], \\[lJump], \\[robust], \\[inner], \\[outer])\n\n#### Details\n\n**data** is a numeric vector.\n\n**period** is an integer larger than 1 indicating the length of a time-series cycle.\n\n**sWindow** is either the string \"periodic\" that means smoothing is effectively replaced by taking the mean, or an odd number no smaller than 7 indicating the span (in lags) of the loess window for seasonal extraction.\n\n**sDegree** (optional) can be 0, 1 or 2 indicating the degree of locally-fitted polynomial in seasonal extraction. The default value is 1.\n\n**sJump** (optional) is an integer greater than 1 indicating the number of elements to skip for the smoother in seasonal extraction. The default value is ceil(sWindow/10).\n\n**tWindow** (optional) is a positive odd number indicating the span (in lags) of the loess window for trend extraction. The default value is the next odd number after 1.5 \\* period / (1 - (1.5 / sWindow)).\n\n**tDegree** (optional) can be 0, 1 or 2 indicating the degree of locally-fitted polynomial in trend extraction. The default value is 1.\n\n**tJump** (optional) is an integer greater than 1 indicating the number of elements to skip for the smoother in trend extraction. The default value is ceil(sWindow/10).\n\n**lWindow** (optional) is a positive odd number indicating the the span (in lags) of the loess window of the low-pass filter used for each subseries. The default value is the next odd number after period.\n\n**lDegree** (optional) can be 0, 1 or 2 indicating the degree of locally-fitted polynomial for the subseries low-pass filter. The default value is 1.\n\n**lJump** (optional) is an integer greater than 1 indicating the number of elements to skip for the smoother in the subseries low-pass filter. The default value is ceil(sWindow/10).\n\n**robust** (optional) is a Boolean value indicating if robust fitting is used in the loess procedure. The default value is false.\n\n**inner** (optional) is a positive integer indicating the number of 'inner' (backfitting) iterations; usually very few (2) iterations suffice. If *robust*=true, the default value of *inner* is 1; if *robust*=false, the default value of *inner* is 2.\n\n**outer** (optional) is a positive integer indicating the number of 'outer' robustness iterations. If *robust*=true, the default value of *outer* is 15; if *robust*=false, the default value of *outer* is 0.\n\n#### Details\n\nUse Loess method to decompose a time series into trend, seasonality and randomness. The result is a dictionary with the following keys: trend, seasonal, and residual. Each key corresponds to a vector with the same length as data.\n\n#### Examples\n\n```\nn = 100\ntrend = 6 * sin(1..n \\ 200)\nseasonal = sin(pi / 6 * 1..n)\nresidual = rand(1.0, n) - 0.5\ndata = trend + seasonal + residual\nres = stl(data, 12, \"periodic\");\n\nplot([trend, res.trend]);\n```\n\n![](https://docs.dolphindb.com/en/images/stl01.png)\n\n```\nplot([seasonal, res.seasonal]);\n```\n\n![](https://docs.dolphindb.com/en/images/stl02.png)\n"
    },
    "stopClusterReplication": {
        "url": "https://docs.dolphindb.com/en/Functions/s/stopClusterReplication.html",
        "signatures": [
            {
                "full": "stopClusterReplication()",
                "name": "stopClusterReplication",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [stopClusterReplication](https://docs.dolphindb.com/en/Functions/s/stopClusterReplication.html)\n\n#### Syntax\n\nstopClusterReplication()\n\n#### Arguments\n\nNone\n\n#### Details\n\nStops cluster replication.\n\nIt can only be executed by an administrator on the controller.\n\n* If it is called in the master cluster, subsequent tasks will not be put in the push queue.\n\n* If it is called in the slave cluster, new tasks are no longer pulled from the master cluster, but tasks in execution are not stopped.\n\nThe configuration parameter *replicationMode* should be specified before you execute this command.\n\n#### Example\n\n```\nstopClusterReplication();\n```\n\nRelated functions: [startClusterReplication](https://docs.dolphindb.com/en/Functions/s/startClusterReplication.html), [skipClusterReplicationTask](https://docs.dolphindb.com/en/Functions/s/skipClusterReplicationTask.html)\n\n"
    },
    "stopDataNode": {
        "url": "https://docs.dolphindb.com/en/Functions/s/stopDataNode.html",
        "signatures": [
            {
                "full": "stopDataNode(X)",
                "name": "stopDataNode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [stopDataNode](https://docs.dolphindb.com/en/Functions/s/stopDataNode.html)\n\n\n\n#### Syntax\n\nstopDataNode(X)\n\n#### Arguments\n\n**X** is a vector, which contains information about the data nodes/compute nodes to be stopped.\n\n#### Details\n\nStop data nodes/compute nodes on a cluster controller.\n\n#### Examples\n\n```\nx = [\"192.168.1.27:8506\",\"192.168.1.27:8502\",\"192.168.1.27:8527\"]\nstopDataNode(x);\n```\n"
    },
    "stopHeapSample": {
        "url": "https://docs.dolphindb.com/en/Functions/s/stopHeapSample.html",
        "signatures": [
            {
                "full": "stopHeapSample()",
                "name": "stopHeapSample",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [stopHeapSample](https://docs.dolphindb.com/en/Functions/s/stopHeapSample.html)\n\n\n\n#### Syntax\n\nstopHeapSample()\n\n#### Details\n\nThis function dynamically disables heap memory sampling. Only administrators can execute this function.\n\n#### Arguments\n\nNone.\n\n#### Examples\n\nRecommended workflow for memory usage analysis:\n\n1. Enable heap memory sampling: This can be done by setting the environment variable TCMALLOC\\_SAMPLE\\_PARAMETER to a value between 1 and 524288 (recommended: 524288) before starting DolphinDB; or by dynamically enabling it using `startHeapSample`.\n2. Execute `dumpHeapSample` before and after operations that may cause memory leaks, saving to two different files. Compare these files to confirm memory allocation and usage related to the operation.\n3. Disable heap memory sampling.\n\n```\nstartHeapSample(524288)\n\ndumpHeapSample(\"/DolphinDB/Data/heap1\")\ndumpHeapSample(\"/DolphinDB/Data/heap2\")\n\nstopHeapSample()\n```\n\nRelated functions: [dumpHeapSample](https://docs.dolphindb.com/en/Functions/d/dumpHeapSample.html), [startHeapSample](https://docs.dolphindb.com/en/Functions/s/startHeapSample.html)\n"
    },
    "streamEngineParser": {
        "url": "https://docs.dolphindb.com/en/Functions/s/streamEngineParser.html",
        "signatures": [
            {
                "full": "streamEngineParser(name, metrics, dummyTable, outputTable, keyColumn, [timeColumn], [useSystemTime=false], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup], [filter], [keepOrder], [keyPurgeFilter], [keyPurgeFreqInSecond], [triggeringPattern='perBatch'], [triggeringInterval=1000], [lastBatchOnly=false], [contextByColumn], [updateTime], [useWindowStartTime=false], [roundTime=true], [forceTriggerTime], [sessionBegin], [sessionEnd], [mergeSessionEnd=false], [closed='left'], [fill='none'], [garbageSize], [forceTriggerSessionEndTime], [keyPurgeFreqInSec=-1])",
                "name": "streamEngineParser",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[filter]",
                        "name": "filter",
                        "optional": true
                    },
                    {
                        "full": "[keepOrder]",
                        "name": "keepOrder",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFilter]",
                        "name": "keyPurgeFilter",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSecond]",
                        "name": "keyPurgeFreqInSecond",
                        "optional": true
                    },
                    {
                        "full": "[triggeringPattern='perBatch']",
                        "name": "triggeringPattern",
                        "optional": true,
                        "default": "'perBatch'"
                    },
                    {
                        "full": "[triggeringInterval=1000]",
                        "name": "triggeringInterval",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[lastBatchOnly=false]",
                        "name": "lastBatchOnly",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[contextByColumn]",
                        "name": "contextByColumn",
                        "optional": true
                    },
                    {
                        "full": "[updateTime]",
                        "name": "updateTime",
                        "optional": true
                    },
                    {
                        "full": "[useWindowStartTime=false]",
                        "name": "useWindowStartTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[forceTriggerTime]",
                        "name": "forceTriggerTime",
                        "optional": true
                    },
                    {
                        "full": "[sessionBegin]",
                        "name": "sessionBegin",
                        "optional": true
                    },
                    {
                        "full": "[sessionEnd]",
                        "name": "sessionEnd",
                        "optional": true
                    },
                    {
                        "full": "[mergeSessionEnd=false]",
                        "name": "mergeSessionEnd",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[fill='none']",
                        "name": "fill",
                        "optional": true,
                        "default": "'none'"
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[forceTriggerSessionEndTime]",
                        "name": "forceTriggerSessionEndTime",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSec=-1]",
                        "name": "keyPurgeFreqInSec",
                        "optional": true,
                        "default": "-1"
                    }
                ]
            }
        ],
        "markdown": "### [streamEngineParser](https://docs.dolphindb.com/en/Functions/s/streamEngineParser.html)\n\n\n\n#### Syntax\n\nstreamEngineParser(name, metrics, dummyTable, outputTable, keyColumn, \\[timeColumn], \\[useSystemTime=false], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[raftGroup], \\[filter], \\[keepOrder], \\[keyPurgeFilter], \\[keyPurgeFreqInSecond], \\[triggeringPattern='perBatch'], \\[triggeringInterval=1000], \\[lastBatchOnly=false], \\[contextByColumn], \\[updateTime], \\[useWindowStartTime=false], \\[roundTime=true], \\[forceTriggerTime], \\[sessionBegin], \\[sessionEnd], \\[mergeSessionEnd=false], \\[closed='left'], \\[fill='none'], \\[garbageSize], \\[forceTriggerSessionEndTime], \\[keyPurgeFreqInSec=-1])\n\n#### Details\n\nThe stream engine parser provides a unified interface for computing complex metrics over stream data. These metrics often require logic involving cross-sectional computation, stateful computation, windowing calculations over time series, table joins, and more. To handle such computational tasks, multiple streaming engines need to be combined into a pipeline. With the stream engine parser, you don't need to manually define and connect engines in a specific order. Instead, you only need to rewrite your metrics following a set of rules. The stream engine parser analyzes the metric expressions and automatically constructs a computational pipeline by combining the appropriate engines.\n\nAs the stream engine parser integrates DolphinDB's time-series, reactive state, and cross-sectional engines, it provides parameters for configuring each engine. Some parameters, like *keyColumn*, are shared across the engines. However, if you need to set different values for the shared parameters per engine, the stream engine parser cannot be used. In these cases, you'll need to manually build a cascade of engines.\n\n`streamEngineParser` returns a table object. It is the table returned by the first streaming engine in the auto-generated pipeline. Appending data to this table means that data enters the engine pipeline for processing. Note that there is no function to delete the entire pipeline at once. The engines created by the stream engine parser must be deleted individually by name (see **Arguments** -> *name*) after use.\n\nAs mentioned earlier, the parser requires metrics to be written using specific functions or syntax rules. In this way, metrics can be translated into executable logic that is mapped to the appropriate streaming engines. For metrics with user-defined functions, the stream engine parser will analyze the function body logic.\n\nWhen parsing a metric, the parser follows the following rules:\n\n1. **It looks for function signifiers indicating the engine type**\n\n   * If a metric involves cross-sectional computation, the corresponding function must be a function signifier (often a function with the `row-` prefix). For example, to compute the sorted order of elements in each row, the `rowRank` function must be used to implement this layer of logic.\n\n     Supported function signifiers for cross-sectional computation include:\n\n     ```\n     \"byRow\", \"rowAvg\", \"rowCount\", \"count\", \"rowDenseRank\",\n     \"rowMax\", \"rowMin\", \"rowProd\", \"rowRank\", \"rowSize\", \"rowSkew\", \"rowStd\", \"rowStdp\", \"rowSum\", \"rowSum2\",\n     \"rowVar\", \"rowVarp\", \"rowAnd\", \"rowOr\", \"rowXor\", \"rowKurtosis\", \"rowCorr\", \"rowCovar\",\n     \"rowBeta\", \"rowWsum\", \"rowWavg\"\n     ```\n\n     For logic not expressible with `row-` functions or must be expressed with user-defined functions, you can use the `byRow` higher-order function.\n\n   * If a metric involves windowing aggregation over time series, use the `rolling` higher-order function. For example, to calculate a rolling 3-element sum stepped by 3 elements on the \"price\" column using forward filling, specify `rolling(sum,price,3,3,`ffill`)`.\n\n     Syntax of `rolling`:\n\n     ```\n     rolling(func, funcArgs, window, [step=1], [fill='none'])\n     ```\n\n   * Built-in functions without the above function signifiers will be processed by the reactive state engine.\n\n2. **Input table schema for intermediate engines**\n\n   `streamEngineParser` allows you to specify the schema for only the input table of the first parsed engine through the *dummyTable* parameter. The intermediate processing steps are abstracted away from the user. The stream engine parser uses specific naming conventions for the *dummyTables*of intermediate engines. If you need to reference a column from an intermediate engine's *dummyTable*in *metrics*or other parameters, follow these naming conventions:\n\n   * The first column of any intermediate *dummyTable* is the time column.\n   * The next columns are the ones specified by *keyColumn*.\n   * After that come columns holding the calculation results of *metrics*. These metric columns are named \"col\\_0\\_, col\\_1\\_, col\\_2\\_,...\" and so on.\n\n**Note:**\n\n1. The output tables for time-series engines and cross-sectional engines both contain a time column. However, reactive state engines do not output a time column. When the engine pipeline generates a reactive state engine, it will automatically add a time column to that engine's *metrics*. This enables the time column to be included in the *dummyTable* passed to the next engine in the pipeline. In this scenario, if *useSystemTime* is true, the auto-added time column is named \"datetime\".\n2. Certain parameters for cross-sectional engines and reactive state engines may need column names from the intermediate *dummyTable*. For example:\n\n   * *contextByColumn* of cross-sectional engines\n   * *filter* and *keyPurgeFilter* of reactive state engines\n     To specify columns from an intermediate *dummyTable*, follow the aforementioned naming conventions, e.g., `contextByColumn = col_0_`.\n\n   To specify the time column or a key column, simply use the column name.\n\n#### Required Arguments\n\n**name** is a string specifying the prefix for the names of the engines in the parser. It can contain letters, numbers, and underscores, but must start with a letter. For example, if *name*= \"test\", the engine names will be \"test0\", \"test1\", \"test2\", etc. The number appended to each name indicates the engine's position within the parser, which is determined by the parsing results of *metrics*.\n\n**metrics** is metacode indicating the metrics to be computed by the parser. Tuples are supported. For more information, see [Functional Metaprogramming](https://docs.dolphindb.com/en/Programming/Metaprogramming/functional_meta.html).\n\n* *metrics* can include built-in or user-defined functions, like <\\[sum(qty), avg(price)]>; expressions, like <\\[avg(price1)-avg(price2)]>; computation on columns, like <\\[std(price1-price2)]>.\n\n* Functions that return multiple values are also supported, such as \\<func(price) as col1 col2> (column names are optional).\n\nThe metrics are typically complex, with multiple layers of computation logic. The parser analyzes each layer of logic and assigns it to the appropriate streaming engine (see **Details**).\n\n**dummyTable** is a table object. It must have the same schema as the stream table to which the engine subscribes. Whether it contains data or not doesn't matter.\n\n**outputTable** holds the computation results from the engine pipeline. It can be an in-memory table or a DFS table, but must be empty before calling `streamEngineParser`. The column names and data types in *outputTable*must be specified upfront. The schema of *outputTable*depends on the last engine in the pipeline:\n\n* For a time-series engine, the columns are ordered as:\n\n  1. Time column\n\n     1. The column type is either TIMESTAMP (when *useSystemTime*= true) or same type as *timeColumn*(when *useSystemTime* = false).\n\n     2. It displays window start (when *useWindowStartTime* = true) or end times (when *useWindowStartTime* = false).\n\n  2. Key column(s), if *keyColumn* is specified. They are ordered the same as in *keyColumn*.\n\n  3. Metric computation result column(s).\n\n* For a reactive state engine, the columns are ordered as:\n\n  1. Key column(s), ordered the same as in *keyColumn*.\n\n  2. Metric computation result column(s).\n\n* For a cross-sectional engine:\n\n  * If *contextByColumn* is not specified, the columns of the output table are ordered as:\n\n    1. A TIMESTAMP column with system timestamps for each computation (or the corresponding values from the *timeColumn*, if this parameter is specified).\n\n    2. Metric computation result column(s). The data types must be consistent with the metric computation results.\n\n  * If *contextByColumn* is specified, the columns of the output table are ordered as:\n\n    1. A TIMESTAMP column with system timestamps for each computation (or the corresponding values from the *timeColumn*, if this parameter is specified).\n\n    2. The column specified in *contextByColumn*.\n\n    3. Metric computation result column(s). The data types must be consistent with the metric computation results.\n\n**keyColumn** is a string scalar or vector.\n\n* For time-series engines and reactive state engines, *keyColumn* indicates the columns to group data by. If specified, computations are done per group, such as aggregations by stock.\n\n* For cross-sectional engines, *keyColumn* indicates the column holding the unique keys. The engine will use only the latest record per key for each computation.\n\n#### Optional Arguments\n\n**timeColumn** specifies the time column in the stream table to which the engine subscribes. It is required when *useSystemTime* = false.\n\n* For time-series engines and reactive state engines, *timeColumn* is can be a string scalar or a 2-element string vector. The vector specifies a DATE and a TIME/SECOND/NANOTIME column. The engine will concatenate the date and time values into a single time value for the output table. See concatDateTime() for details on the concatenated data type.\n\n* For cross-sectional engines, *timeColumn* is a string. The specified column must be of TIMESTAMP type.\n\n**useSystemTime** indicates how the engine handles time when processing data.\n\n* For cross-sectional engines, *useSystemTime*is an optional boolean parameter. If true (default), the engine will use the system time when each calculation starts and output it in the first column of the output table. If false, it will use the time values from the specified *timeColumn* instead.\n\n* For time-series engines, *useSystemTime* is an optional parameter specifying how data is windowed for processing:\n\n  * When *useSystemTime* = true, the engine will regularly window the streaming data at fixed time intervals for calculations according to the ingestion time (local system time with millisecond precision, independent of any time columns in the stream table) of each record. As long as a window contains data, the calculation will be performed automatically when the window ends. The first column in output table indicates the timestamps when the calculation occurred. Note: When *useSystemTime* = true, *timeColumn* must be left empty.\n\n  * *useSystemTime* = false (default): the engine will window the streaming data according to the *timeColumn*in the stream table. The calculation for a window is triggered by the first record after the previous window. Please note that the record which triggers the calculation will not participate in this calculation.\n\nTo enable snapshot in the streaming engines, specify parameters *snapshotDir* and *snapshotIntervalInMsgCount*.\n\n**snapshotDir** is a string indicating the directory where the streaming engine snapshot is saved.\n\n* The directory must already exist, otherwise an exception is thrown.\n\n* If *snapshotDir* is specified, the system checks whether a snapshot already exists in the directory when creating a streaming engine. If it exists, the snapshot will be loaded to restore the engine state.\n\n* Multiple streaming engines can share a directory where the snapshot files are named as the engine names.\n\n* The file extension of a snapshot can be:\n\n  * *\\<engineName>.tmp*: temporary snapshot\n\n  * *\\<engineName>.snapshot*: a snapshot that is generated and flushed to disk\n\n  * *\\<engineName>.old*: if a snapshot with the same name already exists, the previous snapshot is renamed to *\\<engineName>.old*.\n\n**snapshotIntervalInMsgCount** is a positive integer indicating the number of messages to receive before the next snapshot is saved.\n\n**raftGroup** is an integer greater than 1, indicating ID of the raft group on the high-availability streaming subscriber specified by the configuration parameter *streamingRaftGroups*. Specify *raftGroup* to enable high availability on the streaming engine. When an engine is created on the leader, it is also created on each follower and the engine snapshot is synchronized to the followers. When a leader is down, the raft group automatically switches to a new leader to resubscribe to the stream table. Note that *SnapShotDir* must also be specified when specifying a raft group.\n\nThe stream engine parser must be created on the leader of a raft group.\n\nBelow are the parameters unique to a specific type of streaming engine:\n\n* reactive state engines ([createReactiveStateEngine](https://docs.dolphindb.com/en/Functions/c/createReactiveStateEngine.html)): *filter*, *keepOrder*, *keyPurgeFilter*, *keyPurgeFreqInSecond*\n\n* cross-sectional engines ([createCrossSectionalEngine](https://docs.dolphindb.com/en/Functions/c/createCrossSectionalEngine.html)): *triggeringPattern*, *triggeringInterval*, *lastBatchOnly*, *contextByColumn*\n\n* time-series engines ([createTimeSeriesEngine](https://docs.dolphindb.com/en/Functions/c/createTimeSeriesEngine.html)): *updateTime*, *useWindowStartTime*, *roundTime*, \\*forceTriggerTime,\\**closed*, *fill*, *garbageSize*, *keyPurgeFreqInSec*\n\n* daily time-series engines ([createDailyTimeSeriesEngine](https://docs.dolphindb.com/en/Functions/c/createDailyTimeSeriesEngine.html)): *sessionBegin*, *sessionEnd*, *mergeSessionEnd*, *closed*, *fill*, *garbageSize*, *forceTriggerSessionEndTime*, *keyPurgeFreqInSec*\n\n**Note:** If *triggeringPattern*='keyCount', parameter *keepOrder* must be set to true.\n\n#### Examples\n\nThis example implements Formula #1 from World Quant's 101 Alpha Factors on streaming data. The `rank` function performs a cross-sectional operation and is processed with a cross-sectional engine. `rank`'s parameters are computed using a reactive state engine which outputs to the cross-sectional engine.\n\n```\nn = 100\nsym = rand(`aaa`bbb`ccc, n)\ntime = 2021.01.01T13:30:10.008 + 1..n\nmaxIndex=rand(100.0, n)\ndata = table(sym as sym, time as time, maxIndex as maxIndex)\n\n```\n\n```\nAlpha#001formula: rank(Ts_ArgMax(SignedPower((returns<0?stddev(returns,20):close), 2), 5))-0.5\n\n//create a cross-sectional engine to calculate the rank of each stock\ndummy = table(1:0, `sym`time`maxIndex, [SYMBOL, TIMESTAMP, DOUBLE])\nresultTable = streamTable(10000:0, `time`sym`factor1, [TIMESTAMP, SYMBOL, DOUBLE])\nccsRank = createCrossSectionalAggregator(name=\"alpha1CCS\", metrics=<[sym, rank(maxIndex, percent=true) - 0.5]>,  dummyTable=dummy, outputTable=resultTable,  keyColumn=`sym, triggeringPattern='keyCount', triggeringInterval=3000, timeColumn=`time, useSystemTime=false)\n\n@state\ndef wqAlpha1TS(close){\n    ret = ratios(close) - 1\n    v = iif(ret < 0, mstd(ret, 20), close)\n    return mimax(signum(v)*v*v, 5)\n}\n\n//create a reactive state engine which outputs to the cross-sectional engine\ninput = table(1:0, `sym`time`close, [SYMBOL, TIMESTAMP, DOUBLE])\nrse = createReactiveStateEngine(name=\"alpha1\", metrics=<[time, wqAlpha1TS(close)]>, dummyTable=input, outputTable=ccsRank, keyColumn=\"sym\")\nrse.append!(data)\n\ndropStreamEngine(\"alpha1CCS\")\ndropStreamEngine(\"alpha1\")\n\n```\n\nThe computation can also be done by using the `streamEngineParser`:\n\n```\ninput = table(1:0, `sym`time`close, [SYMBOL, TIMESTAMP, DOUBLE])\nresultTable = streamTable(10000:0, `time`sym`factor1, [TIMESTAMP, SYMBOL, DOUBLE])\n\n//construc metrics\nmetrics=<[sym, rowRank(wqAlpha1TS(close), percent=true)- 0.5]>\n\nstreamEngine=streamEngineParser(name=`alpha1_parser, metrics=metrics, dummyTable=input, outputTable=resultTable, keyColumn=`sym, timeColumn=`time, triggeringPattern='keyCount', triggeringInterval=3000)\nstreamEngine.append!(data)\n\ndropStreamEngine(\"alpha1_parser0\")\ndropStreamEngine(\"alpha1_parser1\")\n\n```\n"
    },
    "streamFilter": {
        "url": "https://docs.dolphindb.com/en/Functions/s/streamFilter.html",
        "signatures": [
            {
                "full": "streamFilter(name, dummyTable, filter, [msgSchema], [timeColumn], [conditionColumn])",
                "name": "streamFilter",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "filter",
                        "name": "filter"
                    },
                    {
                        "full": "[msgSchema]",
                        "name": "msgSchema",
                        "optional": true
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[conditionColumn]",
                        "name": "conditionColumn",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [streamFilter](https://docs.dolphindb.com/en/Functions/s/streamFilter.html)\n\n\n\n#### Syntax\n\nstreamFilter(name, dummyTable, filter, \\[msgSchema], \\[timeColumn], \\[conditionColumn])\n\n#### Details\n\nCreate an engine that splits the ingested stream for different handlers. Return a table object.\n\nThe engine works as follows:\n\n1. Deserialize the ingested data.\n\n   Note that this step only takes place when the ingested data is from a heterogeneous stream table, i.e., the output of heterogeneous [replay](https://docs.dolphindb.com/en/Functions/r/replay.html).\n\n2. Split the ingested stream based on the conditions as specified by *filter*.\n\n3. Ingest the split streams to the handlers as specified by *filter* in the order of their timestamps.\n\n**Note:**\n\nStarting from version 1.30.18/2.00.6, in addition to heterogeneous stream tables, `streamFilter` also supports processing data from standard stream tables.\n\n#### Arguments\n\n**name** is a STRING scalar indicating the name of the stream filter engine. It must begin with a letter and may contain letters, numbers and underscores.\n\n**dummyTable** is a table. It has the same schema as the stream table that the stream filter subscribes to. The table can be empty.\n\n**filter** is a dictionary or a tuple of dictionaries. It defines how to process the ingested data. Each dictionary can have the following key-value pairs:\n\n* 'timeRange' (optional) is a pair or a tuple of pairs. Apply it to *timeColumn* to filter for records in the specified time range. Note: When processing a standard stream table, *timeRange* must have the same data type as *timeColumn*.\n\n* 'condition':\n\n  * When processing a heterogeneous stream table: It is a STRING referring to a dictionary key from the *inputTables* of [replay](https://docs.dolphindb.com/en/Functions/r/replay.html). The engine will filter records by the specified key.\n\n  * When processing a standard stream table: It is a STRING scalar/vector indicating the value(s) from the *conditionColumn*, or metacode of one or more Boolean expressions (can contain built-in functions; cannot contain partial applications). The engine will filter records by the specified condition.\n\n* 'handler' is a unary function or a table (can be the table object returned by a streaming engine).\n\n  * If it's a function, the filter result (a table) is passed as the function's sole argument.\n\n  * If it's a table object, the filtered data are inserted into the table directly.\n\n**msgSchema** (optional) is a dictionary\n\n* When processing a heterogeneous stream table: The dictionary indicates the input tables of [replay](https://docs.dolphindb.com/en/Functions/r/replay.html). The keys are the table identifiers as specified in the *inputTables* parameter of [replay](https://docs.dolphindb.com/en/Functions/r/replay.html) and the values indicate the schema of each table. The ingested data will be parsed based on *msgSchema*.\n\n* When processing a standard stream table: Do not specify the parameter.\n\nThe following parameters are only required when processing data from *a standard stream table*:\n\n**timeColumn** (optional) is a STRING indicating the name of the temporal column in *dummyTable*. If unspecified, it takes the name of the first column in the *dummyTable*.\n\n**conditionColumn** (optional) is a STRING indicating a column (must be STRING or SYMBOL type) in *dummyTable*. If this parameter is unspecified, the \"condition\" key of filter takes no effect.\n\n#### Examples\n\n(1) Processing a heterogeneous stream table:\n\nReplay the DFS tables \"orders\" and \"trades\" to simulate an asof join of the two streams.\n\nIf we simply perform an N-to-N replay on the two tables, it is not guaranteed that the records will be ingested to the left and right tables of the asof join engine in chronological order: It may happen that a record with a larger timestamp arrives in the left table before a record with a smaller timestamp arrives in the right table. For more information, see [replay](https://docs.dolphindb.com/en/Functions/r/replay.html).\n\nTherefore, we replay the two tables into one heterogeneous stream table to make sure all records are ordered by timestamp. The stream filter subscribes to the heterogenous stream table, splits the ingested data into two streams and distributes them to the left and right tables of the asof join engine ([createAsofJoinEngine](https://docs.dolphindb.com/en/Functions/c/createAsofJoinEngine.html)). In this way, we can make sure that the data is ingested to the left and right tables of the asof join engine in the order of the timestamps.\n\n```\n//create the \"orders\" table\nn=1000\nsym = take(take(\"IBM\",n).join(take(\"GS\",n)), n*2*3)\ndate=take(2022.01.04..2022.01.06, n*2*3).sort!()\ntimestamp1=take(2022.01.04 09:30:00.000+rand(1000,n),n) join take(2022.01.04 09:31:00.000+rand(1000,n),n)\ntimestamp2=take(2022.01.05 09:30:00.000+rand(1000,n),n) join take(2022.01.05 09:31:00.000+rand(1000,n),n)\ntimestamp3=take(2022.01.06 09:30:00.000+rand(1000,n),n) join take(2022.01.06 09:31:00.000+rand(1000,n),n)\ntimestamp=timestamp1 join timestamp2 join timestamp3\nvolume = rand(100, n*2*3)\nt=table(sym,date,timestamp,volume)\n\nif(existsDatabase(\"dfs://test_order\")){\ndropDatabase(\"dfs://test_order\")\n}\ndb1_or=database(\"\",RANGE, 2022.01.04..2022.01.07)\ndb2_or=database(\"\",VALUE,`IBM`GS)\ndb_or=database(\"dfs://test_order\",COMPO,[db1_or, db2_or])\norders=db_or.createPartitionedTable(t,`orders,`date`sym)\norders.append!(t);\nselect count(*) from orders\n// output\n6000\n\n//create the \"trades\" table\nn=2000\nsym = take(take(\"IBM\",n).join(take(\"GS\",n)), n*2*3)\ndate=take(2022.01.04..2022.01.06, n*2*3).sort!()\ntimestamp1=take(2022.01.04 09:30:00.000+rand(1000,n),n) join take(2022.01.04 09:31:00.000+rand(1000,n),n)\ntimestamp2=take(2022.01.05 09:30:00.000+rand(1000,n),n) join take(2022.01.05 09:31:00.000+rand(1000,n),n)\ntimestamp3=take(2022.01.06 09:30:00.000+rand(1000,n),n) join take(2022.01.06 09:31:00.000+rand(1000,n),n)\ntimestamp=timestamp1 join timestamp2 join timestamp3\nvolume = rand(100, n*2*3)\nprice = rand(50.0, n*3) join  rand(20.0, n*3)\n\nt=table(sym,date,timestamp,volume,price)\n\nif(existsDatabase(\"dfs://test_trades\")){\ndropDatabase(\"dfs://test_trades\")\n}\ndb1=database(\"\",RANGE, 2022.01.04..2022.01.07)\ndb2=database(\"\",VALUE,`IBM`GS)\ndb=database(\"dfs://test_trades\",COMPO,[db1, db2])\ntrades=db.createPartitionedTable(t,`trades,`date`sym)\ntrades.append!(t);\nselect count(*) from trades\n// output\n12000\n\n//generate the heterogeneous data sources and create a table as the the outputTable of replay()\nds_or = replayDS(sqlObj=<select * from loadTable(db_or, `orders)>, dateColumn=`date, timeColumn=`timestamp)\nds = replayDS(sqlObj=<select * from loadTable(db, `trades)>, dateColumn=`date, timeColumn=`timestamp)\ninput_dict=dict([\"orders\",\"trades\"], [ds_or, ds])\nshare streamTable(100:0,`timestamp`sym`blob`volume, [TIMESTAMP,SYMBOL, BLOB, INT]) as opt\n\n\n//subscribe to the output table of replay to ingest the data to the stream filter\nshare streamTable(100:0,`timestamp`sym`blob`volume, [TIMESTAMP,SYMBOL, BLOB, INT]) as streamFilterOpt\nshare streamTable(100:0, `sym`date`timestamp`volume, [SYMBOL, DATE, TIMESTAMP, INT] ) as streamOrders\nshare streamTable(100:0, `sym`date`timestamp`volume`price, [SYMBOL, DATE, TIMESTAMP, INT, DOUBLE] ) as streamTrades\nstreamOpt=table(100:0, `timestamp`sym`volume`price`result, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE])\n\nfilter1=dict(STRING,ANY)\nfilter1['condition']=`orders\nfilter1['timeRange']=09:30:00.000:09:30:00.005\n\nfilter2=dict(STRING,ANY)\nfilter2['condition']=`trades\nfilter2['timeRange']=09:30:00.000:09:30:00.005\n\najEngine=createAsofJoinEngine(name=\"ajEngine\", leftTable=streamOrders, rightTable=streamTrades, outputTable=streamOpt, metrics=<[volume,price,price*volume]>, matchingColumn=`sym, useSystemTime=true)\nfilter1['handler']=getLeftStream(ajEngine)\nfilter2['handler']=getRightStream(ajEngine)\nschema=dict([\"orders\",\"trades\"], [streamOrders, streamTrades])\n\nengine=streamFilter(name=`streamFilter,dummyTable=streamFilterOpt, filter=[filter1,filter2],msgSchema=schema)\nsubscribeTable(tableName=\"opt\", actionName=\"sub1\", offset=0, handler=engine, msgAsTable=true)\n\n//replay the heterogeneous data sources and output to the table \"opt\"\nreplay(inputTables=input_dict,outputTables=opt, timeColumn=`timestamp)\n\nselect count(*) from streamOpt\n// output\n20\n\n//drop the subscription\nunsubscribeTable(tableName=\"opt\", actionName=\"sub1\")\ndropStreamEngine(`streamFilter)\ndropStreamEngine(`ajEngine)\n```\n\n(2) Processing standard stream table:\n\nIn this example, data from the standard stream table \"trades\" is ingested to the stream filter, where the records are filtered and assigned to handlers for further processing.\n\n```\nn=20\nsym = symbol(take(`A`B`C,n))\nname = string(rand(1..10,n))\ndate = temporalAdd(2012.12.06,0..(n-1),'d')\ntime = temporalAdd(09:30:00.000,0..(n-1),'ms')\nvol = 100+take(1..8,20)\nt = table(date,time,sym,name,vol)\n\nshare streamTable(100:0,`date`time`sym`name`vol,[DATE,TIME,SYMBOL,STRING,INT]) as st1\nshare streamTable(100:0,`date`time`sym`name`vol,[DATE,TIME,SYMBOL,STRING,INT]) as st2\nshare streamTable(100:0,`date`time`sym`name`vol,[DATE,TIME,SYMBOL,STRING,INT]) as st3\n\n\nshare streamTable(100:0,`time`sym`sum_vol,[TIME,SYMBOL,INT]) as output1\nshare streamTable(100:0,`time`avg_vol,[TIME,INT]) as output2\n\n// create 2 streaming engines has the handlers of the stream filter\nengine1=createTimeSeriesEngine(name=\"timeEngine\", windowSize=3, step=3, metrics=<[sum(vol)]>, dummyTable=st3, outputTable=output1, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50)\nengine2=createReactiveStateEngine(name=\"reactiveEngine\", metrics=<[mavg(vol, 3)]>, dummyTable=st1, outputTable=output2, keyColumn=`sym)\n\n//share \"trades\" as the stream table to be subscribed by the stream filter\nshare streamTable(100:0,`date`time`sym`name`vol,[DATE,TIME,SYMBOL,STRING,INT]) as trades\n\n//set the first filter and ingest the result to engine2\nfilter1 = dict(STRING,ANY)\nfilter1['condition']=`A\nfilter1['handler']=engine2\nfilter1['timeRange']=(09:30:00.001:09:30:00.010,09:29:00.000:09:30:00.000)\n\n//set the second filter and ingest the result to st2\nfilter2 = dict(STRING,ANY)\nfilter2['handler']=st2\nfilter2['timeRange']=09:30:00.002:09:30:00.005\n\n//set the first filter and ingest the result to engine1\nfilter3 = dict(STRING,ANY)\nfilter3['condition']=`C`A\nfilter3['handler']=engine1\n\n///The stream filter subscribes to the stream table \"trades\" and distributes the ingested data based on the specified conditions\nstreamFilter2=streamFilter(name=\"streamFilterDemo\",dummyTable=trades,filter=[filter1,filter2,filter3], timeColumn=`time, conditionColumn=`sym)\nsubscribeTable(tableName=\"trades\", actionName=\"sub1\", offset=0, handler=streamFilter2, msgAsTable=true)\ntrades.append!(t)\n```\n\n```\nselect * from output1\n```\n\n| time         | sym | sum\\_vol |\n| ------------ | --- | -------- |\n| 09:30:00.003 | A   | 101      |\n| 09:30:00.003 | C   | 103      |\n| 09:30:00.006 | A   | 104      |\n| 09:30:00.006 | C   | 106      |\n| 09:30:00.009 | A   | 107      |\n| 09:30:00.009 | C   | 101      |\n| 09:30:00.012 | A   | 102      |\n| 09:30:00.012 | C   | 104      |\n| 09:30:00.015 | A   | 105      |\n| 09:30:00.015 | C   | 107      |\n| 09:30:00.018 | A   | 108      |\n\n```\nselect * from output2\n```\n\n| time         | avg\\_vol |\n| ------------ | -------- |\n| 00:00:00.001 |          |\n| 00:00:00.001 |          |\n| 00:00:00.001 | 104      |\n| 00:00:00.001 | 104      |\n\n```\nselect * from st2\n```\n\n| date       | time         | sym | name | vol |\n| ---------- | ------------ | --- | ---- | --- |\n| 2012.12.08 | 09:30:00.002 | C   | 6    | 103 |\n| 2012.12.09 | 09:30:00.003 | A   | 8    | 104 |\n| 2012.12.10 | 09:30:00.004 | B   | 10   | 105 |\n| 2012.12.11 | 09:30:00.005 | C   | 10   | 106 |\n| 2012.12.12 | 09:30:00.006 | A   | 10   | 107 |\n| 2012.12.13 | 09:30:00.007 | B   | 1    | 108 |\n| 2012.12.14 | 09:30:00.008 | C   | 3    | 101 |\n| 2012.12.15 | 09:30:00.009 | A   | 4    | 102 |\n| 2012.12.16 | 09:30:00.010 | B   | 9    | 103 |\n\n\"condition\" can also be specified as Boolean expressions to support more complex filter logic. In the example above, replace the value of \"condition\" in filter2 with a Boolean expression to filter the data based on the columns \"vol\" and \"date\".\n\n```\nfilter2 = dict(STRING,ANY)\nfilter2['condition'] = <sym==`A and 101<vol<105 and date<2012.12.15>\nfilter2['handler'] = st2\nfilter2['timeRange'] = 09:30:00.002:09:30:00.010\n\nselect * from st2\n```\n\n| date       | time         | sym | name | vol |\n| ---------- | ------------ | --- | ---- | --- |\n| 2012.12.09 | 09:30:00.003 | A   | 7    | 104 |\n"
    },
    "streamTable": {
        "url": "https://docs.dolphindb.com/en/Functions/s/streamTable.html",
        "signatures": [
            {
                "full": "streamTable(X, [X1], [X2], ....)",
                "name": "streamTable",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": "....",
                        "name": "...."
                    }
                ]
            },
            {
                "full": "streamTable(capacity:size, colNames, colTypes)",
                "name": "streamTable",
                "parameters": [
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            }
        ],
        "markdown": "### [streamTable](https://docs.dolphindb.com/en/Functions/s/streamTable.html)\n\n\n\n#### Syntax\n\nstreamTable(X, \\[X1], \\[X2], ....)\n\nor\n\nstreamTable(capacity:size, colNames, colTypes)\n\n#### Arguments\n\nFor the first usage, X, X1, X2, .... are vectors.\n\nFor the second scenario:\n\n**capacity** is the amount of memory (in terms of the number of rows) allocated to the table. When the number of rows exceeds capacity, the system will first allocate memory of 1.2\\~2 times of capacity, copy the data to the new memory space, and release the original memory. For large tables, these steps may use significant amount of memory.\n\n**size** is the initial size (in terms of the number of rows) of the table. If *size*=0, create an empty table.\n\n**colNames** is a string vector of column names.\n\n**colTypes** is a string vector of data types.\n\n#### Details\n\nCreate a table in real-time mode to be used in streaming (also called a stream table). A table in real-time mode can handle concurrent reading and writing.\n\n#### Examples\n\n```\nid=`XOM`GS`AAPL\nx=102.1 33.4 73.6\nrt = streamTable(id, x);\nrt=streamTable(`XOM`GS`AAPL as id, 102.1 33.4 73.6 as x);\ncolName=[\"Name\",\"Age\"]\ncolType=[\"string\",\"int\"]\nrt = streamTable(100:10, colName, colType);\n```\n"
    },
    "stretch": {
        "url": "https://docs.dolphindb.com/en/Functions/s/stretch.html",
        "signatures": [
            {
                "full": "stretch(X, n)",
                "name": "stretch",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [stretch](https://docs.dolphindb.com/en/Functions/s/stretch.html)\n\n\n\n#### Syntax\n\nstretch(X, n)\n\n#### Arguments\n\n**X** is a vector/tuple/matrix/table.\n\n**n** is a non-negative integer.\n\n#### Details\n\n* If *X* is a vector or tuple, stretches *X* evenly to a new vector or tuple with the length of *n*.\n\n* If *X* is a matrix or table, stretches *X* evenly to a new matrix or table with *n* rows.\n\nThe difference between `stretch` and [take](https://docs.dolphindb.com/en/Functions/t/take.html) lies in:\n\n* `take` takes *n* values iteratively and sequentially from a vector, whereas `stretch` copies each element of the vector to stretch the vector to a new length *n*.\n\n#### Examples\n\n```\nX = 1 NULL 2 3\nprint stretch(X, 10)\n// output\n[1,1,1,,,,2,2,3,3]\n\nprint stretch(X, 11)\n// output\n[1,1,1,,,,2,2,2,3,3]\n\nprint stretch(X, 12)\n// output\n[1,1,1,,,,2,2,2,3,3,3]\n\nprint take(X, 10)\n// output\n[1,,2,3,1,,2,3,1,]\n\nY=array(INT[], 0, 10).append!([1 NULL 3, 4 5, 6 NULL 8, 9 10]);\nprint stretch(Y,7)\n// output\n[[1,,3],[1,,3],[4,5],[4,5],[6,,8],[6,,8],[9,10]]\n\ns=[1 2 3, 4 5 6]\nstretch(s, 5)\n// output\n([1,2,3],[1,2,3],[1,2,3],[4,5,6],[4,5,6])\n\nm=matrix(1 2 3, 4 5 6)\nstretch(m,5)\n// output\ncol1        col2\n1   4\n1   4\n2   5\n2   5\n3   6\n\nt=table(1 2 3 as a, 4 5 6 as b)\nstretch(t,5)\n// output\na   b\n1   4\n1   4\n2   5\n2   5\n3   6\n```\n"
    },
    "string": {
        "url": "https://docs.dolphindb.com/en/Functions/s/string.html",
        "signatures": [
            {
                "full": "string(X)",
                "name": "string",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [string](https://docs.dolphindb.com/en/Functions/s/string.html)\n\n\n\n#### Syntax\n\nstring(X)\n\n#### Arguments\n\n**X** can be of any data type.\n\n#### Details\n\nConvert X to a string.\n\n#### Examples\n\n```\nstring()==\"\";\n// output\n1\nstring(10);\n// output\n10\n\ntypestr string(108.5);\n// output\nSTRING\n\nstring(now());\n// output\n2016.03.02T20:55:31.287\n```\n"
    },
    "stringFormat": {
        "url": "https://docs.dolphindb.com/en/Functions/s/stringFormat.html",
        "signatures": [
            {
                "full": "stringFormat(format, [args...])",
                "name": "stringFormat",
                "parameters": [
                    {
                        "full": "format",
                        "name": "format"
                    },
                    {
                        "full": "[args...]",
                        "name": "[args...]"
                    }
                ]
            }
        ],
        "markdown": "### [stringFormat](https://docs.dolphindb.com/en/Functions/s/stringFormat.html)\n\n#### Syntax\n\nstringFormat(format, \\[args...])\n\n#### Arguments\n\n**format** is a string containing zero or more placeholders.\n\n**args...** (optional) is one or more values to fill in the placeholder(s) in *format*. If specified, the number and data type of *args* must be consistent with the number and data types of the placeholders in *format*; if not specified, the function outputs *format* directly.\n\n#### Details\n\n`stringFormat` formats strings by replacing placeholders with values passed by the user. Formatting options (e.g. field width, precision, alignment) can be specified for more precise control over how the values are formatted in the output strings.\n\nTable 1. Supported data types\n\n| Type                    | Placeholder (%-formatting) | Examples of args                                             |\n| ----------------------- | -------------------------- | ------------------------------------------------------------ |\n| BOOL                    | %b                         | 1b, 0b, true, false                                          |\n| CHAR                    | %c                         | 'a', 97c                                                     |\n| SHORT                   | %h                         | 122h                                                         |\n| integer (INT)           | %i                         | 21                                                           |\n| octal                   | %o                         | 31                                                           |\n| hexadecimal (lowercase) | %x                         | 2f                                                           |\n| hexadecimal (uppercase) | %X                         | 2F                                                           |\n| LONG                    | %l                         | 25l                                                          |\n| DATE                    | %d                         | 2022.01.01                                                   |\n| MONTH                   | %M                         | 2022.05M                                                     |\n| TIME                    | %t                         | 13:00:10.706                                                 |\n| MINUTE                  | %m                         | 13:30m                                                       |\n| SECOND                  | %s                         | 13:30:10                                                     |\n| DATETIME                | %D                         | 2012.06.13 13:30:10, 2012.06.13T13:30:10                     |\n| TIMESTAMP               | %T                         | 2012.06.13 13:30:10.008, 2012.06.13T13:30:10.008             |\n| NANOTIME                | %n                         | 13:30:10.008007006                                           |\n| NANOTIMESTAMP           | %N                         | 2012.06.13 13:30:10.008007006, 2012.06.13T13:30:10.008007006 |\n| FLOAT                   | %f                         | 2.1f                                                         |\n| DOUBLE                  | %F                         | 2.1                                                          |\n| SYMBOL                  | %S                         | symbol(\\[\"aaa\", \"bbb\"])                                      |\n| STRING                  | %W                         | \"Hello\"                                                      |\n| ANY (tuple)             | %A                         | (1, 45, 'sah')                                               |\n\n**Note:** If the string contains a \"%\" character, it must be escaped by using a double percent sign (%%).\n\nYou can specify formatting options inside the placeholders like `%[(var)][#][±][0][m/*][.][n/*]type`.\n\nTable 2. The following table lists the options which can be inserted before the decimal point `.` in placeholders:\n\n<table id=\"table_klg_nr2_czb\"><thead><tr><th align=\"left\">\n\nSpecifier\n\n</th><th align=\"left\">\n\nMeaning\n\n</th><th align=\"left\">\n\nExamples\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\n*m* (a positive integer)\n\n</td><td align=\"left\">\n\n\\[Used with %f, %F or %W]For FLOAT (f) and DOUBLE (F) data types, *m* indicates the minimum total width of the output string.\n\n* If *m* is smaller than the actual total number of digits in the float number, the full float number is output directly (rounded to 6 decimal places if needed).\n* If *m* is greater than the total digits, the output string is padded with leading spaces by default.\n\nFor STRING (W) data type, *m* indicates the minimum total length of the output string. -   If m is smaller than the actual string length, the full string is output.\n\n* If m is greater than the string length, the output string is padded with leading spaces.The output string is right-alignment by default.\n\n</td><td align=\"left\">\n\n`stringFormat(\"%10f\", pi)`output: `··3.141593`\n\n`stringFormat(\"%2f\", 12345.0)`output: `12345.000000`\n\n`stringFormat(\"%10W\", \"6chars\")`output: `····6chars`\n\n</td></tr><tr><td align=\"left\">\n\n\\*\n\n</td><td align=\"left\">\n\nLike *m*, \\* indicates the minimum total width of the output string. However, \\* allows passing the width as an argument (*args*). Specify the width in the corresponding argument (*args*) in tuple format: `(width,value)`.\n\n</td><td align=\"left\">\n\n`stringFormat(\"%*f\", (10,pi))`output: `··3.141593`\n\n</td></tr><tr><td align=\"left\">\n\n0\n\n</td><td align=\"left\">\n\n*0* pads numeric values with zeros. For left-aligned fields, the zeros are padded on the right side. If *0* is not specified, the output string is padded with spaces.\n\n</td><td align=\"left\">\n\n`stringFormat(\"%010f\", pi)`output: `003.141593`\n\n</td></tr><tr><td align=\"left\">\n\n*\n\n</td><td align=\"left\">\n\n*-* left-aligns the output string within the specified field width.\n\n</td><td align=\"left\">\n\n`stringFormat(\"%-10.3f\", pi)`output: `3.142`\n\n</td></tr><tr><td align=\"left\">\n\n*\n\n</td><td align=\"left\">\n\n*+* adds a plus sign \"`+`\" before positive values.\n\n</td><td align=\"left\">\n\n`stringFormat('%+f', pi)`output: `+3.141593`\n\n</td></tr><tr><td align=\"left\">\n\n(var)\n\n</td><td align=\"left\">\n\n\\[Cannot be used with other specifiers] (var) allows you to format a string using a dictionary, where the dictionary keys act as variables in the string. To specify a key, put it in parentheses after the *%* symbol. The values in the dictionary are substituted into the string where the `%(key)type` placeholders are located.\n\n</td><td align=\"left\">\n\n`employee = {\"name\":\"Lisa Mill\", \"year\":2010} stringFormat(\"%(name)W joined the company in %(year)i\", employee)`output: \\`Lisa Mill joined the company in 2010\\`\\`\n\n</td></tr><tr><td align=\"left\">\n\n\\#\n\n</td><td align=\"left\">\n\n\\[Used with %o, %x or %X] *#* adds \"0o\" before octal values; adds \"0x\" (lower case) or \"0X\" (upper case) before hexadecimal values.\n\n</td><td align=\"left\">\n\n`stringFormat(\"%#o\", 33)`output: `0o41`\n\n`stringFormat(\"%#X\", 33)`output: `0X21`\n\n</td></tr></tbody>\n</table>Table 3. The following table lists the options which can be inserted after the decimal point `.` in placeholders \\(these options can only be used with **%f, %F** or **%W**\\):\n\n<table id=\"table_xk1_4r2_czb\"><thead><tr><th align=\"left\">\n\nSpecifier\n\n</th><th align=\"left\">\n\nMeaning\n\n</th><th align=\"left\">\n\nExamples\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\n*n* (a positive integer)\n\n</td><td align=\"left\">\n\nFor FLOAT (f) and DOUBLE (F) data types, *n* specifies the number of digits after the decimal point.-   If *n* is smaller than the number of decimal digits, the float number is rounded to *n* digits.\n\n* If *n* is greater than the number of decimal digits, zeros are padded to the right.\n\nFor STRING (W) data type, *n* specifies the string length.-   If *n* is smaller than the actual length of string, the string is truncated to *n* characters.\n\n* If *n* is greater than the actual length of string, the full string is output without padding.\n\n</td><td align=\"left\">\n\n`stringFormat(\"%10.5f\", pi)`output: `···3.14159`\n\n`stringFormat('%10.3f' , 3.1)`output: `·····3.100`\n\n`stringFormat(\"%2.10W\", \"6chars\")`output: `6chars`\n\n</td></tr><tr><td align=\"left\">\n\n\\*\n\n</td><td align=\"left\">\n\nLike *n*, \\* specifies the number of digits after the decimal point. However, \\* allows specifying the number of decimals (precision) by passing it as an argument (*args*).Specify the digits in the corresponding argument in tuple format: `([width],[precision],value)`.\n\n</td><td align=\"left\">\n\nSpecify precision: `stringFormat(\"%.*f\", (5,pi))`output: `3.14159`\n\nSpecify both the minimum field width and the precision: `stringFormat(\"%0*.*f\", (10,5,pi))`output: `···3.14159`\n\n</td></tr></tbody>\n</table>## Examples\n\n```\nstringFormat(\"date: %d, time: %t\", 2022.12.01, 10:12:45.065)\n// output\ndate: 2022.12.01, time: 10:12:45.065\n\nstringFormat(\"Students account for %i%% of our customers.\", 50)\n// output\nStudents account for 50% of our customers.\n\nt = datetime(now())\nstringFormat(\"The current time is %D.\", t)\n// output\nThe current time is 2023.01.02T20:36:03.\n\na = 7.596\nstringFormat(\"%-+10.5f\", a)\n// output\n+7.59600\n\nstringFormat(\"%010.3f\", a) \n// output\n000007.596\n\nproduct = {\"item\":\"Eggs\", \"price_per_unit\":2}\nstringFormat(\"%(item)W: $ %(price_per_unit)i\", product)\n// output\nEggs: $ 2\n```\n\n"
    },
    "strip": {
        "url": "https://docs.dolphindb.com/en/Functions/s/strip.html",
        "signatures": [
            {
                "full": "strip(X)",
                "name": "strip",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [strip](https://docs.dolphindb.com/en/Functions/s/strip.html)\n\n\n\n#### Syntax\n\nstrip(X)\n\n#### Arguments\n\n**X** is a literal scalar/vector.\n\n#### Details\n\nRemove all space, tab, new line, and carriage characters in both head and tail of a string.\n\n#### Examples\n\n```\nx=\"\\nhello world\\t\\n\";\nx;\n\n// output\nhello world\n\nstrip x;\n// output\nhello world\n```\n\nRelated function: [trim](https://docs.dolphindb.com/en/Functions/t/trim.html)\n"
    },
    "strlen": {
        "url": "https://docs.dolphindb.com/en/Functions/s/strlen.html",
        "signatures": [
            {
                "full": "strlen(X)",
                "name": "strlen",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [strlen](https://docs.dolphindb.com/en/Functions/s/strlen.html)\n\n\n\n#### Syntax\n\nstrlen(X)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n#### Details\n\nReturn the length of each string in X.\n\n#### Examples\n\n```\nstrlen('abcdefg');\n// output\n7\n\nstrlen(\"I am a boy.\");\n// output\n11\n\nstrlen([\"abc\",\"123456789\"]);\n// output\n[3,9]\n```\n"
    },
    "strlenu": {
        "url": "https://docs.dolphindb.com/en/Functions/s/strlenu.html",
        "signatures": [
            {
                "full": "strlenu(X)",
                "name": "strlenu",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [strlenu](https://docs.dolphindb.com/en/Functions/s/strlenu.html)\n\n\n\n#### Syntax\n\nstrlenu(X)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n#### Details\n\nGet the length of a string encoded by Unicode.\n\n#### Examples\n\n```\nstrlenu(\"database\")\n// output\n8\n\nstrlenu([\"database\",\"DolphinDB\"])\n// output\n[8,9]\n```\n"
    },
    "strpos": {
        "url": "https://docs.dolphindb.com/en/Functions/s/strpos.html",
        "signatures": [
            {
                "full": "strpos(X, str)",
                "name": "strpos",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "str",
                        "name": "str"
                    }
                ]
            }
        ],
        "markdown": "### [strpos](https://docs.dolphindb.com/en/Functions/s/strpos.html)\n\n\n\n#### Syntax\n\nstrpos(X, str)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n**str** is a string scalar.\n\n#### Details\n\nIf *X* contains str, return the index in *X* where the first occurrence of str starts; otherwise, return -1.\n\n#### Examples\n\n```\nstrpos(\"abcdefg\",\"cd\");\n// output\n2\n\nstrpos(\"abcdefg\",\"d\");\n// output\n3\n\nstrpos(\"abcdefg\",\"ah\");\n// output\n-1\n```\n"
    },
    "strReplace": {
        "url": "https://docs.dolphindb.com/en/Functions/s/strReplace.html",
        "signatures": [
            {
                "full": "strReplace(str, pattern, replacement)",
                "name": "strReplace",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    },
                    {
                        "full": "replacement",
                        "name": "replacement"
                    }
                ]
            }
        ],
        "markdown": "### [strReplace](https://docs.dolphindb.com/en/Functions/s/strReplace.html)\n\n\n\n#### Syntax\n\nstrReplace(str, pattern, replacement)\n\n#### Arguments\n\n**str** is a string scalar/vector.\n\n**pattern** and **replacement** are both string scalars.\n\n#### Details\n\nReturn a copy of *str* and replace all occurrences of *pattern* with *replacement*.\n\n#### Examples\n\n```\nstrReplace(\"The ball is red.\", \"red\", \"green\");\n// output\nThe ball is green.\n\nstrReplace([\"The ball is red.\", \"The car is red too.\"], \"red\", \"yellow\");\n// output\n[\"The ball is yellow.\",\"The car is yellow too.\"]\n```\n"
    },
    "sub": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sub.html",
        "signatures": [
            {
                "full": "sub(X, Y)",
                "name": "sub",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [sub](https://docs.dolphindb.com/en/Functions/s/sub.html)\n\n\n\n#### Syntax\n\nsub(X, Y) or X-Y\n\n#### Arguments\n\n**X**/**Y** is a scalar/pair/vector/matrix/set. If one of *X* and *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.\n\n#### Details\n\nReturn the result of element-by-element subtracting *Y* from *X*. If both *X* and *Y* are sets, sub returns a set by eliminating the common elements of *X* and *Y* from *X*.\n\n#### Examples\n\n```\n4:5-2;\n// output\n2 : 3\n\n4:5-1:2;\n// output\n3 : 3\n\nx=1 2 3;\nx-1;\n// output\n[0,1,2]\n\n1 sub x;\n// output\n[0,-1,-2]\n\ny=4 5 6;\nsub(x,y);\n// output\n[-3,-3,-3]\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm-2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| -1 | 1  | 3  |\n| 0  | 2  | 4  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1-m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| -5 | -1 | 3  |\n| -3 | 1  | 5  |\n\n```\nx=set([5,3,4]);\ny=set(8 9 4 6);\nx-y;\n// output\nset(3,5)\n\ny-x;\n// output\nset(6,9,8)\n```\n"
    },
    "subarray": {
        "url": "https://docs.dolphindb.com/en/Functions/s/subarray.html",
        "signatures": [
            {
                "full": "subarray(X, range)",
                "name": "subarray",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "range",
                        "name": "range"
                    }
                ]
            }
        ],
        "markdown": "### [subarray](https://docs.dolphindb.com/en/Functions/s/subarray.html)\n\n\n\n#### Syntax\n\nsubarray(X, range)\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n**range** is a pair of integers indicating a range. The lower bound is inclusive and the upper bound is exclusive.\n\n#### Details\n\nWhen a subset of the elements of a vector are needed in calculation, if we use script such as close\\[10:].avg(), a new vector close\\[10:] is generated with replicated data from the original vector close before the calculation is conducted. This not only consumes more memory but also takes time.\n\nFunction `subarray` generates a subarray of the original vector. It only records the pointer to the original vector together with the starting and ending positions of the subarray. As the system does not allocate a large block of memory to store the subarray, data replication does not occur. All read-only operations on vectors can be applied directly to a subarray.\n\n#### Examples\n\nExample 1\n\n```\nx=1..100\nsubarray(x, 10:20);\n// output\n[11,12,13,14,15,16,17,18,19,20]\n\n\nsubarray(x, 90:);\n// output\n[91,92,93,94,95,96,97,98,99,100]\n\n\nsubarray(x, :10);\n// output\n[1,2,3,4,5,6,7,8,9,10]\n```\n\nExample 2\n\n```\na=rand(1000.0,20000000);\ntimer a.subarray(0:1000000).avg();\n// output\nTime elapsed: 2.037 ms\n\ntimer a[0:1000000].avg();\n// output\nTime elapsed: 36.583 ms\n```\n\nExample 3. Subarrays are read-only.\n\n```\nb=a.subarray(0:1000000);\nb[0]=1;\n// output\nImmutable sub vector doesn't support method set\n```\n"
    },
    "submitJob": {
        "url": "https://docs.dolphindb.com/en/Functions/s/submitJob.html",
        "signatures": [
            {
                "full": "submitJob(jobId, jobDesc, jobDef, args...)",
                "name": "submitJob",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    },
                    {
                        "full": "jobDesc",
                        "name": "jobDesc"
                    },
                    {
                        "full": "jobDef",
                        "name": "jobDef"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [submitJob](https://docs.dolphindb.com/en/Functions/s/submitJob.html)\n\n\n\n#### Syntax\n\nsubmitJob(jobId, jobDesc, jobDef, args...)\n\n#### Arguments\n\n**jobId** is a string indicating the job ID.\n\n**jobDesc** is a string indicating job description.\n\n**jobDef** is a local function that defines the job. Please note that it is not the function name, and therefore it should not be quoted.\n\n**args...** is the arguments of the function. If the function has no arguments, it is unspecified.\n\n#### Details\n\nSubmit a batch job to the local node and return the job ID for future reference. To submit a batch job to a remote node, please use submitJob together with [rpc](https://docs.dolphindb.com/en/Functions/r/rpc.html) or [remoteRun](https://docs.dolphindb.com/en/Functions/r/remoteRun.html). For details please refer to the section of [BatchJobManagement](https://docs.dolphindb.com/en/Maintenance/BatchJobManagement.html).\n\n#### Examples\n\nThe following script submits a job to the local node:\n\n```\ndef jobDemo(n){\n    s = 0\n    for (x in 1 : n) {\n        s += sum(sin rand(1.0, 100000000)-0.5)\n        print(\"iteration \" + x + \" \" + s)\n    }\n    return s\n};\n\nsubmitJob(\"jobDemo1\",\"job demo\", jobDemo, 100);\n// output\njobDemo1\n\ngetJobStatus(\"jobDemo1\");\n```\n\n| node      | userID | jobId    | rootJobId                            | jobDesc  | priority | parallelism | clientIp  | clientPort | receivedTime            | startTime               | endTime | errorMsg |\n| --------- | ------ | -------- | ------------------------------------ | -------- | -------- | ----------- | --------- | ---------- | ----------------------- | ----------------------- | ------- | -------- |\n| local8848 | guest  | jobDemo1 | d1d76cad-d46f-338c-4179-21cface3ce7c | job demo | 4        | 2           | 127.0.0.1 | 62016      | 2023.12.12T17:52:01.576 | 2023.12.12T17:52:01.585 |         |          |\n\n*endTime* is empty. This means the job is still running. After the job finishes, *endTime* will have a value.\n\n```\ngetJobStatus(\"jobDemo1\");\n```\n\n| node      | userID | jobId    | rootJobId                            | jobDesc  | priority | parallelism | clientIp  | clientPort | receivedTime            | startTime               | endTime                 | errorMsg |\n| --------- | ------ | -------- | ------------------------------------ | -------- | -------- | ----------- | --------- | ---------- | ----------------------- | ----------------------- | ----------------------- | -------- |\n| local8848 | guest  | jobDemo1 | d1d76cad-d46f-338c-4179-21cface3ce7c | job demo | 4        | 2           | 127.0.0.1 | 62016      | 2023.12.12T17:52:01.576 | 2023.12.12T17:52:01.585 | 2023.12.12T17:53:23.204 |          |\n\n```\ngetJobMessage(\"jobDemo1\");\n\n// output\n2020-09-13 13:40:10.139269 Start the job [jobDemo1]: job demo\n2020-09-13 13:40:11.159543 iteration 1 3914.672836\n2020-09-13 13:40:12.118014 iteration 2 4263.240185\n2020-09-13 13:40:13.069435 iteration 3 4006.833021\n......\n2020-09-13 13:41:41.769256 iteration 97 -1897.963368\n2020-09-13 13:41:42.706748 iteration 98 -2455.003061\n2020-09-13 13:41:43.640253 iteration 99 924.915703\n2020-09-13 13:41:43.640253 The job is done.\n\ngetJobReturn(\"jobDemo1\");\n// output\n924.915703\n\nsubmitJob(\"jobDemo2\",, jobDemo, 10);\n// output\njobDemo2\n\ngetRecentJobs();\n```\n\n| node      | userID | jobId    | rootJobId                            | jobDesc  | priority | parallelism | clientIp  | clientPort | receivedTime            | startTime               | endTime                 | errorMsg |\n| --------- | ------ | -------- | ------------------------------------ | -------- | -------- | ----------- | --------- | ---------- | ----------------------- | ----------------------- | ----------------------- | -------- |\n| local8848 | guest  | jobDemo1 | d1d76cad-d46f-338c-4179-21cface3ce7c | job demo | 4        | 2           | 127.0.0.1 | 62016      | 2023.12.12T17:52:01.576 | 2023.12.12T17:52:01.585 | 2023.12.12T17:53:23.204 |          |\n| local8848 | guest  | jobDemo2 | def84639-5b21-c6b0-47be-986b4563e192 | jobDemo  | 4        | 2           | 127.0.0.1 | 62016      | 2023.12.12T17:57:42.325 | 2023.12.12T17:57:42.327 | 2023.12.12T17:57:49.995 |          |\n\nThe following script submits a job to a remote node:\n\nWith function `rpc` (\"DFS\\_NODE2\" is located in the same cluster as the local node):\n\n```\ndef jobDemo(n){\n    s = 0\n    for (x in 1 : n) {\n        s += sum(sin rand(1.0, 100000000)-0.5)\n        print(\"iteration \" + x + \" \" + s)\n    }\n    return s\n}\n\nrpc(\"DFS_NODE2\", submitJob, \"jobDemo3\", \"job demo\", jobDemo, 10);\n// output\nOutput: jobDemo3\n\n\nrpc(\"DFS_NODE2\", getJobReturn, \"jobDemo3\");\n// output\nOutput: -3426.577521\n```\n\nuse function `remoteRun` or `remoteRunWithCompression`. For example:\n\n```\nconn = xdb(\"DFS_NODE2\")\nconn.remoteRun(submitJob, \"jobDemo4\", \"job demo\", jobDemo, 10);\n// output\nOutput: jobDemo4\n\nconn.remoteRun(getJobReturn, \"jobDemo4\");\n// output\nOutput: 4238.832005\n```\n"
    },
    "submitJobEx": {
        "url": "https://docs.dolphindb.com/en/Functions/s/submitJobEx.html",
        "signatures": [
            {
                "full": "submitJobEx(jobId, jobDesc, priority, parallelism, jobDef, args...)",
                "name": "submitJobEx",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    },
                    {
                        "full": "jobDesc",
                        "name": "jobDesc"
                    },
                    {
                        "full": "priority",
                        "name": "priority"
                    },
                    {
                        "full": "parallelism",
                        "name": "parallelism"
                    },
                    {
                        "full": "jobDef",
                        "name": "jobDef"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [submitJobEx](https://docs.dolphindb.com/en/Functions/s/submitJobEx.html)\n\n\n\n#### Syntax\n\nsubmitJobEx(jobId, jobDesc, priority, parallelism, jobDef, args...)\n\n#### Arguments\n\n**jobId** is a string indicating the job ID.\n\n**jobDesc** is a string of the job description.\n\n**priority** is an integer from 0 to 9 indicating the importance of the job. 9 means the most important job.\n\n**parallelism** is a positive integer indicating the maximum number of workers allocated to the job.\n\n**jobDef** is a local function that defines the job. Please note that it is not the function name, and therefore it should not be quoted.\n\n**args...** is the arguments of the local function. If the function has no arguments, it is unspecified.\n\n#### Details\n\nSubmit a batch job to the local node and return the job ID for future reference. The only difference between `submitJobEx` and [submitJob](https://docs.dolphindb.com/en/Functions/s/submitJob.html) is that we can specify parameters *priority* and *parallelism* in `submitJobEx`.\n\n#### Examples\n\n```\ndef jobDemo(n){\n    s = 0\n    for (x in 1 : n) {\n        s += sum(sin rand(1.0, 100000000)-0.5)\n        print(\"iteration \" + x + \" \" + s)\n    }\n    return s\n};\n\nsubmitJobEx(\"jobDemo1\",\"job demo\", 8, 12, jobDemo, 100);\n// output\njobDemo1\n```\n"
    },
    "submitJobEx2": {
        "url": "https://docs.dolphindb.com/en/Functions/s/submitjobex2.html",
        "signatures": [
            {
                "full": "submitJobEx2(jobId, jobDesc, priority, parallelism, onComplete, jobDef, args...)",
                "name": "submitJobEx2",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    },
                    {
                        "full": "jobDesc",
                        "name": "jobDesc"
                    },
                    {
                        "full": "priority",
                        "name": "priority"
                    },
                    {
                        "full": "parallelism",
                        "name": "parallelism"
                    },
                    {
                        "full": "onComplete",
                        "name": "onComplete"
                    },
                    {
                        "full": "jobDef",
                        "name": "jobDef"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [submitJobEx2](https://docs.dolphindb.com/en/Functions/s/submitjobex2.html)\n\n\n\n#### Syntax\n\nsubmitJobEx2(jobId, jobDesc, priority, parallelism, onComplete, jobDef, args...)\n\n#### Arguments\n\n**jobId** is a string indicating the job ID.\n\n**jobDesc** is a string of the job description.\n\n**priority** is an integer from 0 to 9 indicating the importance of the job. 9 means the most important job.\n\n**parallelism** is a positive integer indicating the maximum number of workers allocated to the job.\n\n**onComplete** is a callback function with four parameters. After the submitted batch job is finished, the callback function will be executed.\n\n**jobDef** is a local function that defines the job. Please note that it is not the function name, and therefore it should not be quoted.\n\n**args...** is the arguments of the local function. If the function has no arguments, it is unspecified.\n\n#### Details\n\nSubmit a batch job to the local node and return the job ID for future reference. Different from `submitJobEx`, `submitJobEx2` will execute the callback function after the submitted job is finished.\n\n#### Examples\n\n```\ndef jobDemo(n){\n    s = 0\n    for (x in 1 : n) {\n        s += sum(sin rand(1.0, 100000000)-0.5)\n        print(\"iteration \" + x + \" \" + s)\n    }\n    return s\n}\n\ndef cbFunc(jobId, jobDesc, success, result){\n    desc = jobId + \" \" + jobDesc\n    if(success){\n        desc += \" successful \" + result\n    }\n    else{\n        desc += \" with error: \" + result\n    }\n    writeLog(desc)\n}\n\nsubmitJobEx2(\"jobDemo1\",\"job demo\", 8, 12, cbFunc, jobDemo, 100)\n```\n"
    },
    "subscribeTable": {
        "url": "https://docs.dolphindb.com/en/Functions/s/subscribeTable.html",
        "signatures": [
            {
                "full": "subscribeTable([server],tableName,[actionName],[offset=-1],handler,[msgAsTable=false],[batchSize=0],[throttle=1],[hash=-1],[reconnect=false],[filter],[persistOffset=false],[timeTrigger=false],[handlerNeedMsgId=false],[raftGroup],[userId=\"\"],[password=\"\"],[udpMulticast=false]\\)",
                "name": "subscribeTable",
                "parameters": [
                    {
                        "full": "[server]",
                        "name": "server",
                        "optional": true
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[actionName]",
                        "name": "actionName",
                        "optional": true
                    },
                    {
                        "full": "[offset=-1]",
                        "name": "offset",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "handler",
                        "name": "handler"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[batchSize=0]",
                        "name": "batchSize",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[throttle=1]",
                        "name": "throttle",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[hash=-1]",
                        "name": "hash",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[reconnect=false]",
                        "name": "reconnect",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[filter]",
                        "name": "filter",
                        "optional": true
                    },
                    {
                        "full": "[persistOffset=false]",
                        "name": "persistOffset",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[timeTrigger=false]",
                        "name": "timeTrigger",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[handlerNeedMsgId=false]",
                        "name": "handlerNeedMsgId",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[userId=\"\"]",
                        "name": "userId",
                        "optional": true,
                        "default": "\"\""
                    },
                    {
                        "full": "[password=\"\"]",
                        "name": "password",
                        "optional": true,
                        "default": "\"\""
                    },
                    {
                        "full": "[udpMulticast=false]\\",
                        "name": "udpMulticast",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [subscribeTable](https://docs.dolphindb.com/en/Functions/s/subscribeTable.html)\n\n\n\n#### Syntax\n\nsubscribeTable(\\[server],tableName,\\[actionName],\\[offset=-1],handler,\\[msgAsTable=false],\\[batchSize=0],\\[throttle=1],\\[hash=-1],\\[reconnect=false],\\[filter],\\[persistOffset=false],\\[timeTrigger=false],\\[handlerNeedMsgId=false],\\[raftGroup],\\[userId=\"\"],\\[password=\"\"],\\[udpMulticast=false]\\\\)\n\n#### Details\n\nSubscribe to a stream table on a local or remote server from a client node. We can also specify a function to process the subscribed data.\n\nReturn the subscription topic, which is a combination of the alias of the node where the stream table is located, stream table name, and the subscription task name (if *actionName* is specified) separated by \"\\_\". If the subscription topic already exists, the function throws an exception.\n\n* If *batchSize* is specified, *handler* will be triggered if either the number of unprocessed messages reaches *batchSize* or the duration of time since the last time handler was triggered reaches *throttle* seconds.\n\n* If the subscribed table is overwritten, to keep the subscription we need to cancel the subscription with command [unsubscribeTable](https://docs.dolphindb.com/en/Functions/u/unsubscribeTable.html) and then subscribe to the new table.\n\n* With the high availability subscription enabled, a leader switch or cluster restart in the raft group of subscribers may log off a user. Since guests have no privilege to write to a DFS table, the writing will be interrupted (the current user can be identified by function [getCurrentSessionAndUser](https://docs.dolphindb.cn/en/Functions/g/getCurrentSessionAndUser.html)). If parameters *userId* and *password* are specified, the system will attempt to log in after the user is logged out accidentally to make sure the subscribed data can be written to a DFS table. Note that since DolphinDB 2.00.10.10, users can determine whether to limit the number of failed login attempts by setting the parameter *enhancedSecurityVerification*. If it is not specified, no limit will be applied; if it is set to true, a user's account will be locked for 10 minutes if the user enters the wrong password 5 times in a minute.\n\nTo use UDP multicast in subscription, the socket buffer size must be set as appropriate. The recommended value is greater than or equal to 1 MB.\n\nHere is how to set the socket buffer size in Linux:\n\n* In the Linux terminal, run the following commands:\n\n  ```\n  sudo sysctl -w net.core.rmem_default=1048576\n  sudo sysctl -w net.core.rmem_max=1048576\n  sudo sysctl -w net.core.wmem_default=1048576\n  sudo sysctl -w net.core.wmem_max=1048576\n  ```\n\n* Alternatively, add or modify the values of *net.core.rmem\\_default*, *net.core.rmem\\_max*, *net.core.wmem\\_default* and *net.core.wmem\\_max* to 1048576 in the */etc/sysctl.conf* file, and then run `sudo sysctl -p`.\n\n**Note:** When switching between TCP and UDP, you need to use `unsubscribeTable` to cancel existing subscriptions before using `subscribeTable` to create new subscription topics.\n\n#### Arguments\n\nOnly **tableName** and **handler** are required. All the other parameters are optional.\n\n**server** is a string indicating the alias or the remote connection handle of a server where the stream table is located. If it is unspecified or an empty string (\"\"), it means the local instance.\n\n**tableName** is a string indicating the name of the shared stream table on the aforementioned server.\n\n**actionName** is a string indicating subscription task name. It starts with a letter and can have letters, digits, and underscores. It must be specified if multiple subscriptions on the same node subscribe to the same stream table.\n\n**offset** is an integer indicating the position of the first message where the subscription begins. A message is a row of the stream table. Offset is relative to the first row of the stream table when it is created. If *offset* is unspecified or -1, the subscription starts with the next new message. If *offset*=-2, the system will get the persisted offset on disk and start subscription from there. If some rows were cleared from memory due to cache size limit, they are still considered in determining where the subscription starts.\n\n**handler** is a unary function, binary function or a table, which is used to process the subscribed data.\n\n* If *handler* is a unary function, the only parameter of the function is the subscribed data, which can be a table or a tuple of the subscribed table columns.\n\n* The *handler* must be specified as a binary function when *handlerNeedMsgId* = true. The parameters of the function are *msgBody* and *msgId*. For more details, see parameter *handlerNeedMsgId*.\n\n* If *handler* is a table, and the subscribed data is inserted into the table directly. It supports the streaming engine, shared table (including stream table, in-memory table, keyed table, indexed table), and DFS table.\n\nNote that *handler* should be function `appendForJoin`, [getLeftStream](https://docs.dolphindb.com/en/Functions/g/getLeftStream.html) or [getRightStream](https://docs.dolphindb.com/en/Functions/g/getRightStream.html) while subscribing to a stream table for the streaming join engine.\n\n**msgAsTable** is a Boolean value indicating whether the subscribed data is ingested into *handler* as a table or as a tuple. If *msgAsTable*=true, the subscribed data is ingested into *handler* as a table and can be processed with SQL statements. The default value is false, which means the subscribed data is ingested into *handler* as a tuple of columns.\n\n**batchSize** is an integer indicating the number of unprocessed messages to trigger the *handler*. If it is positive, the *handler* does not process messages until the number of unprocessed messages reaches *batchSize*. If it is unspecified or non-positive, the *handler* processes incoming messages as soon as they come in.\n\n**throttle** is a floating point number in seconds, indicating the maximum waiting time before the *handler* processes the incoming messages if the *batchSize* condition has not been reached. The default value is 1. This optional parameter has no effect if *batchSize* is not specified. To set *throttle* less than 1 second, you need to modify the configuration parameter *subThrottle* first.\n\n**hash** is a hash value (a non-negative integer) indicating which subscription executor will process the incoming messages for this subscription. If it is unspecified, the system automatically assigns an executor. When we need to keep the messages synchronized from multiple subscriptions, we can set hash of all these subscriptions to be the same, so that the same executor is used to synchronize multiple data sources.\n\n**reconnect** is a Boolean value indicating whether the subscription may be automatically resumed successfully if it is interrupted. With a successfully resubscription, the subscriber receives all streaming data since the interruption. The default value is false. If *reconnect*=true, depending on how the subscription is interrupted, we have the following 3 scenarios:\n\n* If the network is disconnected while both the publisher and the subscriber node remain on, the subscription will be automatically reconnected if the network connection is resumed.\n* If the publisher node crashes, the subscriber node will keep attempting to resubscribe after the publisher node restarts.\n  * If the publisher node adopts data persistence mode for the stream table, the publisher will first load persisted data into memory after restarting. The subscriber won't be able to successfully resubscribe until the publisher reaches the row of data where the subscription was interrupted.\n  * If the publisher node does not adopt data persistence mode for the stream table, the automatic resubscription will fail.\n* If the subscriber node crashes, even after the subscriber node restarts, it won't automatically resubscribe. For this case we need to execute \\`subscribeTable\\` again.\n\n**Note:**\n\nTo subscribe to a high-availability stream table, the parameter *reconnect* should be set to true to ensure that the new leader node can be successfully connected to in case of a leader node change.\n\n**filter** indicates selected values in the filtering column. The filtering column is set with function [setStreamTableFilterColumn](https://docs.dolphindb.com/en/Functions/s/setStreamTableFilterColumn.html). Only the messages with filtering column values in *filter* are subscribed. *filter* does not support Boolean types.\n\nThe *filter* parameter can be specified in the following 3 ways.\n\n* value filtering: a vector.\n* range filtering: a pair. The range includes the lower bound but excludes the upper bound.\n* hash filtering: a tuple. The first element is the number of buckets. The second element is a scalar meaning the bucket index (starting from 0) or a pair meaning the bucket index range (including the lower bound but excluding the upper bound).\n\n**persistOffset** is a Boolean value indicating whether to persist the offset of the last processed message in the current subscription. It is used for resubscription and can be obtained with function [getTopicProcessedOffset](https://docs.dolphindb.com/en/Functions/g/getTopicProcessedOffset.html). The default value is false.\n\n* To subscribe to a high-availability stream table, the parameter *persistOffset* should be set to true to prevent data loss on the subscriber.\n\n* To resubscribe from the persisted offset, set *persistOffset* to true and *removeOffset* of function `unsubscribeTable` to false.\n\n**timeTrigger** is a Boolean value. If it is set to true, *handler* is triggered at the intervals specified by parameter *throttle* even if no new messages arrive. The default value is false.\n\n**handlerNeedMsgId** is a Boolean value. The default value is false.\n\n* If it is true, the parameter *handler* must support 2 parameters: *msgBody* (the messages to be ingested into the streaming engine) and *msgId* (the ID of the last message that has been ingested into the streaming engine). You can pass the `appendMsg` function to the handler after fixing the engine parameter using partial application.\n\n* If it is false, *handler* must support just 1 parameter: *msgBody*.\n\n**raftGroup** is the ID of raft group used to enable high availability on the subscriber. If the leader node of a raft group is changed after setting the parameter *raftGroup*, the new leader will resubscribe to the stream table.\n\n**Note:**\n\nThe function `subscribeTable` can only be executed on a leader node if the parameter *raftGroup* is set. If *handlerNeedMsgId* is also set to true while *raftGroup* = true, then the *handler* must be the handler of a stream engine (you can obtain the handler when you create the engine or obtain it with the function \"getStreamEngine(engineName)\".\n\n**userId** is a string indicating a user name.\n\n**password** is a string indicating the password.\n\n**udpMulticast** (optional, Linux only) is a Boolean value indicating whether to enable UDP multicast. The default value is false. If set to true, the publisher will publish messages to a multicast channel.\n\nPerformance differences between TCP and UDP Multicast:\n\n<table id=\"table_c1m_4yy_jbc\"><thead><tr><th>\n\nProtocol\n\n</th><th>\n\nPros\n\n</th><th>\n\nCons\n\n</th><th>\n\nApplication\n\n</th></tr></thead><tbody><tr><td>\n\nTCP\n\n</td><td>\n\n* Reliable transmission\n* Data sequentiality\n* Detection and correction during transmission\n\n</td><td>\n\n* One-to-one connection, requiring significant server resources and bandwidth with multiple subscribers\n\n</td><td>\n\nSuitable for applications requiring reliable, ordered data transmission to a single recipient\n\n</td></tr><tr><td>\n\nUDP Multicast\n\n</td><td>\n\n* One-to-multiple real-time transmission\n* Lower resources and network bandwidth requirements\n\n</td><td>\n\n* High rate of packet loss\n* Unsorted data\n\n</td><td>\n\nIdeal for applications needing rapid real-time data transfer to multiple subscribers\n\n</td></tr></tbody>\n</table>**Note**:\n\n* *udpMulticast*can only be set when *reconnect*, *persisitOffset*, *timeTrigger* is false and *raftGroup*= -1.\n* The network routers or switches where the publishers and subscribers are located must support the UDP Multicast stack.\n\n#### Examples\n\nExample 1. A cluster has 2 nodes: DFS\\_NODE1 and DFS\\_NODE2. We need to specify *maxPubConnections* and *subPort* in *cluster.cfg* to enable the publish/subscribe functionality. For example:\n\n```\nmaxPubConnections=32\nDFS_NODE1.subPort=9010\nDFS_NODE1.persistenceDir=C:/DolphinDB/Data\nDFS_NODE2.subPort=9011\n```\n\nExecute the following script on DFS\\_NODE1 for the following tasks:\n\n(1) Create a shared stream table \"trades\\_stream\" with persistence in synchronous mode. At this stage table \"trades\\_stream\" has 0 rows.\n\n```\nn=20000000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nenableTableShareAndPersistence(table=streamTable(n:0, colNames, colTypes), tableName=\"trades_stream\", asynWrite=false, cacheSize=n)\ngo\n```\n\n(2) Create a DFS table \"trades\". At this stage table \"trades\" has 0 rows.\n\n```\nif(existsDatabase(\"dfs://STREAM_TEST\")){\n     dropDatabase(\"dfs://STREAM_TEST\")\n}\ndbDate = database(\"\", VALUE, temporalAdd(date(today()),0..30,'d'))\ndbSym= database(\"\", RANGE, string('A'..'Z') join \"ZZZZ\")\ndb = database(\"dfs://STREAM_TEST\", COMPO, [dbDate, dbSym])\ncolNames = `date`time`sym`qty`price\ncolTypes = [DATE,TIME,SYMBOL,INT,DOUBLE]\ntrades = db.createPartitionedTable(table(1:0, colNames, colTypes), \"trades\", `date`sym)\n```\n\n(3) Create a local subscription to table \"trades\\_stream\". Use a function `saveTradesToDFS` to save streaming data from \"trades\\_stream\" and today's date to table \"trades\".\n\n```\ndef saveTradesToDFS(mutable dfsTrades, msg): dfsTrades.append!(select today() as date,* from msg)\nsubscribeTable(tableName=\"trades_stream\", actionName=\"trades\", offset=0, handler=saveTradesToDFS{trades}, msgAsTable=true, batchSize=100000, throttle=60)\n```\n\n(4) Create another local subscription to table \"trades\\_stream\". Calculate volume-weighted average price (vwap) with streaming data for each minute and save the result to a shared stream table \"vwap\\_stream\" with persistence in asynchronous mode.\n\n```\nn=1000000\ntmpTrades = table(n:0, colNames, colTypes)\nlastMinute = [00:00:00.000]\ncolNames = `time`sym`vwap\ncolTypes = [MINUTE,SYMBOL,DOUBLE]\nenableTableShareAndPersistence(table=streamTable(n:0, colNames, colTypes), tableName=\"vwap_stream\")\ngo\n\ndef calcVwap(mutable vwap, mutable tmpTrades, mutable lastMinute, msg){\n    tmpTrades.append!(msg)\n    curMinute = time(msg.time.last().minute()*60000l)\n    t = select wavg(price, qty) as vwap from tmpTrades where time < curMinute, time >= lastMinute[0] group by time.minute(), sym\n    if(t.size() == 0) return\n    vwap.append!(t)\n    t = select * from tmpTrades where time >= curMinute\n    tmpTrades.clear!()\n    lastMinute[0] = curMinute\n    if(t.size() > 0) tmpTrades.append!(t)\n}\nsubscribeTable(tableName=\"trades_stream\", actionName=\"vwap\", offset=0, handler=calcVwap{vwap_stream, tmpTrades, lastMinute}, msgAsTable=true, batchSize=100000, throttle=60)\n```\n\nExecute the following script on DFS\\_NODE2 to create a remote subscription to table \"trades\\_stream\". This subscription saves streaming data to a shared stream table \"trades\\_stream\\_slave\" with persistence in asynchronous mode.\n\n```\nn=20000000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nenableTableShareAndPersistence(table=streamTable(n:0, colNames, colTypes), tableName=\"trades_stream_slave\", cacheSize=n)\ngo\nsubscribeTable(server=\"DFS_NODE1\", tableName=\"trades_stream\", actionName=\"slave\", offset=0, handler=trades_stream_slave)\n```\n\nExecute the following script on DFS\\_NODE1 to simulate the streaming data for 3 stocks and 10 minutes. Generate 2,000,000 records for each stock in each minute. Data in one minute are inserted into the stream table \"trades\\_stream\" in 600 blocks. There is a 100 millisecond interval between 2 blocks.\n\n```\nn=10\nticks = 2000000\nrows = ticks*3\nstartMinute = 09:30:00.000\nblocks=600\nfor(x in 0:n){\n    time = startMinute + x*60000 + rand(60000, rows)\n    indices = isort(time)\n    time = time[indices]\n    sym = array(SYMBOL,0,rows).append!(take(`IBM,ticks)).append!(take(`MSFT,ticks)).append!(take(`GOOG,ticks))[indices]\n    price = array(DOUBLE,0,rows).append!(norm(153,1,ticks)).append!(norm(91,1,ticks)).append!(norm(1106,20,ticks))[indices]\n    indices = NULL\n    blockSize = rows / blocks\n    for(y in 0:blocks){\n        range =pair(y * blockSize, (y+1)* blockSize)\n        insert into trades_stream values(subarray(time,range), subarray(sym,range), 10+ rand(100, blockSize), subarray(price,range))\n        sleep(100)\n    }\n\n    blockSize = rows % blocks\n    if(blockSize > 0){\n        range =pair(rows - blockSize, rows)\n        insert into trades_stream values(subarray(time,range), subarray(sym,range), 10+ rand(100, blockSize), subarray(price,range))\n    }\n}\n```\n\nTo check the results, run the following script on DFS\\_NODE1:\n\n```\ntrades=loadTable(\"dfs://STREAM_TEST\", `trades)\nselect count(*) from trades\n```\n\nWe expect to see a result of 60,000,000\n\n```\nselect * from vwap_stream\n```\n\nWe expect the table \"vwap\\_stream\" has 27 rows.\n\nRun the following script on DFS\\_NODE2:\n\n```\nselect count(*) from trades_stream_slave\n```\n\nWe expect to see a result of less than 60,000,000 as part of the table has been persisted to disk.\n\nExample 2. Create stream table publisher on dnode1 of the cluster.\n\n```\nshare streamTable(10:0,`time`id`value,[TIMESTAMP,INT,DOUBLE]) as publisher\n```\n\nSubscribe to publisher using UDP multicast on dnode2 and write data to sub1:\n\n```\nsub1 = streamTable(10:0,`time`id`value,[TIMESTAMP,INT,DOUBLE])\nsubscribeTable(server=\"dnode1\",tableName=\"publisher\",actionName=\"sub1\",offset=-1,handler=append!{sub1},msgAsTable=true, udpMulticast=true)\n```\n\nWrite data to dnode1:\n\n```\npublisher.tableInsert(table(now()+1..10*1000 as time,1..10 as id, rand(100,10) as value))\n```\n\nCheck the publishing status:\n\n```\ngetStreamingStat().udpPubTables\n```\n\n| tableName | channel        | msgOffset | actions | subNum |\n| --------- | -------------- | --------- | ------- | ------ |\n| publisher | 224.1.1.1:1235 | 10        | sub1    | 1      |\n\nCheck subscription workers on dnode2:\n\n```\ngetStreamingStat().subWorkers\n```\n\n| workerId | topic | type                                  | queueDepthLimit | queueDepth | processedMsgCount | lastMsgId | failedMsgCount | lastFailedMsgId | lastFailedTimestamp | lastErrMsg | msgAsTable | batchSize | throttle | hash | filter | persistOffset | timeTrigger | handlerNeedMsgId | raftGroup |\n| -------- | ----- | ------------------------------------- | --------------- | ---------- | ----------------- | --------- | -------------- | --------------- | ------------------- | ---------- | ---------- | --------- | -------- | ---- | ------ | ------------- | ----------- | ---------------- | --------- |\n| 0        | 2     | localhost:8702: dnode1/publisher/sub1 | udp             | 10,000,000 | 0                 | 10        | 9              | 0               | -1                  |            |            | true      | 0        | 0    | 1      |               | false       | false            | false     |\n"
    },
    "substr": {
        "url": "https://docs.dolphindb.com/en/Functions/s/substr.html",
        "signatures": [
            {
                "full": "substr(X, offset, [length])",
                "name": "substr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "offset",
                        "name": "offset"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [substr](https://docs.dolphindb.com/en/Functions/s/substr.html)\n\n\n\n#### Syntax\n\nsubstr(X, offset, \\[length])\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n**offset** is a nonnegative integer.\n\n**length** (optional) is a positive integer.\n\n#### Details\n\nReturn a substring of *X* with the specified starting position (*offset*) and *length*. The first character of *X* corresponds to position 0. If *length* exceeds the length of X, stop at the end of X.\n\nIf *length* is not specified, return a substring of *X* from the specified starting position (*offset*) to the end of *X*.\n\n#### Examples\n\n```\nsubstr(\"This is a test\", 0, 4);\n// output\nThis\n\nsubstr(\"This is a test\", 5, 2);\n// output\nis\n\nsubstr(\"This is a test\", 5);\n// output\nis a test\n\nsubstr(\"This is a test\", 8, 100);\n// output\na test\n```\n"
    },
    "substru": {
        "url": "https://docs.dolphindb.com/en/Functions/s/substru.html",
        "signatures": [
            {
                "full": "substru(X, offset, [length])",
                "name": "substru",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "offset",
                        "name": "offset"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [substru](https://docs.dolphindb.com/en/Functions/s/substru.html)\n\n\n\n#### Syntax\n\nsubstru(X, offset, \\[length])\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n**offset** is a nonnegative integer.\n\n**length** (optional) is a positive integer.\n\n#### Details\n\nThe only differerence between `substru` and `substr` is that `substru` can process Unicode strings.\n\nReturn a substring of *X* with the specified starting position (*offset*) and *length*. The first character of *X* corresponds to position 0. If *length* exceeds the length of *X*, stop at the end of *X*.\n\nIf *length* is not specified, return a substring of *X* from the specified starting position (*offset*) to the end of *X*.\n\n#### Examples\n\n```\nsubstru(\"This is a test\", 0, 4);\n// output\nThis\n\nsubstru(\"This is a test\", 5, 2);\n// output\nis\n\nsubstru(\"This is a test\", 5);\n// output\nis a test\n\nsubstru(\"This is a test\", 8, 100);\n// output\na test\n```\n"
    },
    "subtuple": {
        "url": "https://docs.dolphindb.com/en/Functions/s/subtuple.html",
        "signatures": [
            {
                "full": "subtuple(X, range)",
                "name": "subtuple",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "range",
                        "name": "range"
                    }
                ]
            }
        ],
        "markdown": "### [subtuple](https://docs.dolphindb.com/en/Functions/s/subtuple.html)\n\n\n\n#### Syntax\n\nsubtuple(X, range)\n\n#### Arguments\n\n**X** is a tuple of vectors with the same length.\n\n**range** is a pair of integers indicating a range. The lower bound is inclusive and the upper bound is exclusive.\n\n#### Details\n\nCreate a read-only view of a subarray of each vector in *X* almost instantly. In contrast, it takes time to create a new tuple of vectors.\n\n#### Examples\n\nExample 1:\n\n```\nx=(1..10, 11..20, 21..30, 31..40)\nsubtuple(x, 2:4);\n// output\n([3,4],[13,14],[23,24],[33,34])\n```\n\nExample 2\n\n```\nm=1000.0\nn=20000000\na=(rand(m,n), rand(m,n))\nk=10000000;\ntimer each(avg, a.subtuple(0:k));\n// output\nTime elapsed: 30.87 ms\n\ntimer each(avg, (a[0][0:k], a[1][0:k]));\n// output\nTime elapsed: 46.508 ms\n```\n\nExample 3. Subtuples are read-only.\n\n```\nx=(1..10, 11..20)\nsubtuple(x, 2:4)=([4, 5], [14, 15]);\n// output\nSyntax Error: [line #2] Please use '==' rather than '=' as equal operator in non-sql expression.\n```\n"
    },
    "sum": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sum.html",
        "signatures": [
            {
                "full": "sum(X)",
                "name": "sum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sum](https://docs.dolphindb.com/en/Functions/s/sum.html)\n\n\n\n#### Syntax\n\nsum(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nIf *X* is a vector, return the sum of all the elements in *X*.\n\nIf *X* is a matrix, calculate the sum of each column of *X* and return a vector.\n\nIf *X* is a table, calculate the sum of each column of *X* and return a table.\n\nAs with all aggregate functions, NULL values are not included in the calculation.\n\nIf all elements of a calculation are NULLs, the result is NULL.\n\n#### Examples\n\n```\nsum(1 2 3 NULL 4);\n// output\n10\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nsum(m);\n// output\n[6,15]\n```\n"
    },
    "sum2": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sum2.html",
        "signatures": [
            {
                "full": "sum2(X)",
                "name": "sum2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sum2](https://docs.dolphindb.com/en/Functions/s/sum2.html)\n\n\n\n#### Syntax\n\nsum2(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nIf *X* is a vector, return the sum of squares of all the elements in *X*.\n\nIf *X* is a matrix, calculate the sum of squares for each column of *X* and return a vector.\n\nIf *X* is a table, calculate the sum of squares for each column of *X* and return a table.\n\nAs with all aggregate functions, NULL values are not included in the calculation.\n\nIf all elements of a calculation are NULLs, the result is NULL.\n\nPlease note that the data type of the result is always DOUBLE, even if the data type of *X* is INT or LONG.\n\n#### Examples\n\n```\nsum2(1 2 3);\n// output\n14\n\nsum2(1 NULL NULL);\n// output\n1\n\nsum2(1.5 4.6 7.8);\n// output\n84.25\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nsum2(m);\n// output\n[14,77]\n```\n"
    },
    "sum3": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sum3.html",
        "signatures": [
            {
                "full": "sum3(X)",
                "name": "sum3",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sum3](https://docs.dolphindb.com/en/Functions/s/sum3.html)\n\n\n\n#### Syntax\n\nsum3(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nIf *X* is a vector, return the sum of cubes of all the elements in *X*.\n\nIf *X* is a matrix, calculate the sum of cubes for each column of *X* and return a vector.\n\nIf *X* is a table, calculate the sum of cubes for each column of *X* and return a table.\n\nAs with all aggregate functions, NULL values are not included in the calculation.\n\nIf all elements of a calculation are NULLs, the result is NULL.\n\nPlease note that the data type of the result is always DOUBLE, even if the data type of *X* is INT or LONG.\n\n#### Examples\n\n```\nsum3(1 2 3);\n// output\n36\n\nsum3(1 NULL NULL);\n// output\n1\n\nsum3(1.5 4.6 7.8);\n// output\n575.263\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nsum3(m);\n// output\n[36,405]\n```\n"
    },
    "sum4": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sum4.html",
        "signatures": [
            {
                "full": "sum4(X)",
                "name": "sum4",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sum4](https://docs.dolphindb.com/en/Functions/s/sum4.html)\n\n\n\n#### Syntax\n\nsum4(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix/table.\n\n#### Details\n\nIf *X* is a vector, return the sum of the fourth powers of all the elements in *X*.\n\nIf *X* is a matrix, calculate the sum of the fourth powers for each column of *X* and return a vector.\n\nIf *X* is a table, calculate the sum of the fourth powers for each column of *X* and return a table.\n\nAs with all aggregate functions, NULL values are not included in the calculation.\n\nIf all elements of a calculation are NULLs, the result is NULL.\n\nPlease note that the data type of the result is always DOUBLE, even if the data type of X is INT or LONG.\n\n#### Examples\n\n```\nsum4(1 2 3);\n// output\n98\n\nsum4(1 NULL NULL);\n// output\n1\n\nsum4(1.5 4.6 7.8);\n// output\n4154.3137\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nsum4(m);\n// output\n[98,2177]\n```\n"
    },
    "sumbars": {
        "url": "https://docs.dolphindb.com/en/Functions/s/sumbars.html",
        "signatures": [
            {
                "full": "sumbars(X, Y)",
                "name": "sumbars",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [sumbars](https://docs.dolphindb.com/en/Functions/s/sumbars.html)\n\n\n\n#### Syntax\n\nsumbars(X, Y)\n\n#### Arguments\n\n**X** is a vector/tuple/matrix/table whose elements must be non-negative numbers.\n\n**Y** is a vector/scalar.\n\n* If *X* is a vector, *Y* is a scalar.\n\n* If *X* is a tuple, *Y* is a vector with the same length as *X*.\n\n* If *X* is a matrix/table, *Y* is a vector with the same length as the number of columns of *X*.\n\n#### Details\n\nFor each element X i in *X*, calculate the cumulative sum of X i in the backward direction, i.e., (X i + X i-1 + X i-2 …), until the value is no smaller than *Y*.\n\nIf the cumulative sum never exceeds *Y*, return 0.\n\n#### Examples\n\n```\nsumbars(1 2 3.3 2 5, 3)\n// output\n[0,2,1,2,1]\n\nsumbars(matrix(5 3 6 2 3, 2 6 1 5 4), [5, 8])\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 0    |\n| 2    | 2    |\n| 1    | 3    |\n| 2    | 3    |\n| 2    | 2    |\n\n```\n// calculate the turnover period\nid = `A`A`B`A`C`B`A`C`A`B\ntime = 2022.01.01T09:00:00 + 0..9\nvolume = 100 150 80 120 220 200 180 90 100 125\nt = table(id, time, volume)\ncapital = 300\nre = select *, sumbars(volume, capital) as period from t\nre;\n```\n\n| id | time                | volume | period |\n| -- | ------------------- | ------ | ------ |\n| A  | 2022.01.01T09:00:00 | 100    | 0      |\n| A  | 2022.01.01T09:00:01 | 150    | 0      |\n| B  | 2022.01.01T09:00:02 | 80     | 3      |\n| A  | 2022.01.01T09:00:03 | 120    | 3      |\n| C  | 2022.01.01T09:00:04 | 220    | 2      |\n| B  | 2022.01.01T09:00:05 | 200    | 2      |\n| A  | 2022.01.01T09:00:06 | 180    | 2      |\n| C  | 2022.01.01T09:00:07 | 90     | 3      |\n| A  | 2022.01.01T09:00:08 | 100    | 3      |\n| B  | 2022.01.01T09:00:09 | 125    | 3      |\n"
    },
    "summary": {
        "url": "https://docs.dolphindb.com/en/Functions/s/summary.html",
        "signatures": [
            {
                "full": "summary(X,[interpolation],[characteristic],[percentile],[precision],[partitionSampling])",
                "name": "summary",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[interpolation]",
                        "name": "interpolation",
                        "optional": true
                    },
                    {
                        "full": "[characteristic]",
                        "name": "characteristic",
                        "optional": true
                    },
                    {
                        "full": "[percentile]",
                        "name": "percentile",
                        "optional": true
                    },
                    {
                        "full": "[precision]",
                        "name": "precision",
                        "optional": true
                    },
                    {
                        "full": "[partitionSampling]",
                        "name": "partitionSampling",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [summary](https://docs.dolphindb.com/en/Functions/s/summary.html)\n\n#### Syntax\n\nsummary(X,\\[interpolation],\\[characteristic],\\[percentile],\\[precision],\\[partitionSampling])\n\n#### Details\n\n`summary` generates summary statistics for the input data. It returns an in-memory table containing the minimum, maximum, count, mean, standard deviation, and specified percentiles in ascending order.\n\n* If *X* is a table, `summary` only computes statistics for the numeric columns.\n\n* If *X* is a data source, it can only contain numeric columns, otherwise an error will occur during computation.\n\n#### Arguments\n\n**X** can be an in-memory table, DFS table or data source generated from [sqlDS](https://docs.dolphindb.com/en/Functions/s/sqlDS.html). Note that data sources with SQL metacode containing table joins are currently not supported.\n\n**interpolation** (optional) is a string indicating the interpolation method for percentiles. It can be \"linear\" (default), \"nearest\", \"lower\", \"higher\" and \"midpoint\".\n\n**characteristic** (optional) is a string scalar or vector indicating the characteristics to compute. It can be \"avg\" and/or \"std\". Default is both characteristics.\n\n**percentile** (optional) is a DOUBLE vector of percentiles to compute. Each vector element falls between 0 ang 100. The default is \\[25,50,75], which returns the 25th, 50th, and 75th percentiles.\n\n**precision** (optional) is a DOUBLE scalar greater than 0. The default value is 1e-3, which means the iteration for computing statistics will stop when the difference between the current and previous result is less than or equal to 1e-3. It is recommended to set precision between \\[1e-3, 1e-9] - small enough for adequate precision but not too small to impact performance through excessive iterations.\n\n**partitionSampling** (optional) can be a positive integer specifying the number of partitions to sample, or a float between (0, 1] specifying the sampling ratio. If not specified, statistics are computed on all partitions. When specifying *partitionSampling*, note:\n\n* For a partitioned table:\n\n  * at least one partition will always be sampled. If the sampling ratio \\* total partitions < 1, one partition is sampled.\n\n  * The sampling ratio is rounded down if the sampling ratio \\* total partitions is not an integer. E.g. if ratio=0.26 and total partitions is 10, 2 partitions are sampled.\n\n  * If *partitionSampling* (integer) > total partitions, all partitions are used.\n\n* *partitionSampling* has no effect for non-partitioned tables.\n\n#### Examples\n\n```\nn=2022\ndata=1..n\nvalue=take(1..3,n)\nname=take(`APPLE`IBM`INTEL,n)\nt=table(data,value,name);\nsummary(t, precision=0.001); \n// name is not a numeric column and therefore will not be output\n\n```\n\n| name  | min | max   | nonNullCount | count | avg     | std      | percentile                |\n| ----- | --- | ----- | ------------ | ----- | ------- | -------- | ------------------------- |\n| data  | 1   | 2,022 | 2,022        | 2,022 | 1,011.5 | 583.8454 | \\[506.24,1011.50,1516.75] |\n| value | 1   | 3     | 2,022        | 2,022 | 2       | 0.8167   | \\[1.00,1.99,2.99]         |\n\n```\nn = 5000\ndata1 = take(1..5000000, n)\ndata2 = rand(10000000, n)\ndata3 = take(\"A\" + string(0..10), n)\n\nt = table(data1, data2, data3)\ndbname = \"dfs://summary\"\nif(existsDatabase(dbname)) {\n     dropDatabase(dbname)\n }\ndb = database(dbname, HASH, [INT, 10])\npt = createPartitionedTable(db, t, `pt, `data1)\npt.append!(t)\n\nds = sqlDS(<select data1,data2 from loadTable(db, `pt)>)\nquery_percentile = [25,50,75,90]\n\nds_re1 = summary(ds);\n//returns the 25th, 50th, 75th and 90th percentiles\nds_re2 = summary(ds, percentile=query_percentile, precision=0.0001);\n// the partition sampling ratio is 0.6. As there are 10 partitions in total,  6 partitions will be sampled for statistics computation\nds_re3 = summary(loadTable(db, `pt), percentile=query_percentile, precision=0.0001, partitionSampling=0.6);\n```\n\n"
    },
    "suspendRecovery": {
        "url": "https://docs.dolphindb.com/en/Functions/s/suspendRecovery.html",
        "signatures": [
            {
                "full": "suspendRecovery()",
                "name": "suspendRecovery",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [suspendRecovery](https://docs.dolphindb.com/en/Functions/s/suspendRecovery.html)\n\n\n\n#### Syntax\n\nsuspendRecovery()\n\n#### Arguments\n\nNone\n\n#### Details\n\nSuspend online node recovery processes. When this command is executed, tasks in \"In-Progress\" status will continue to recover and processes in \"Waiting\" status will be suspended. Once suspended, the source node can continue to receive new data. This command can only be executed by the administrator on the controller.\n\n**Note:**\n\nFor high-availability clusters, this command must be executed on every node in the raft group.\n\nRelated command: [resumeRecovery](https://docs.dolphindb.com/en/Functions/r/resumeRecovery.html)\n"
    },
    "svd": {
        "url": "https://docs.dolphindb.com/en/Functions/s/svd.html",
        "signatures": [
            {
                "full": "svd(obj, [fullMatrices=true], [computeUV=true])",
                "name": "svd",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[fullMatrices=true]",
                        "name": "fullMatrices",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[computeUV=true]",
                        "name": "computeUV",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [svd](https://docs.dolphindb.com/en/Functions/s/svd.html)\n\n\n\n#### Syntax\n\nsvd(obj, \\[fullMatrices=true], \\[computeUV=true])\n\n#### Arguments\n\n**obj** is a matrix.\n\n**fullMatrices** (optional) is a Boolean value. The default value is true.\n\n**computeUV** (optional) is a Boolean value. The default value is true.\n\n#### Details\n\nPerform the singular decomposition of a matrix.\n\nGiven an m-by-n matrix A:\n\n* If *fullMatrices*=true, return an m-by-m matrix U (unitary matrix having left singular vectors as columns), an n-by-n matrix V (unitary matrix having right singular vectors as rows) and a vector s (singular values sorted in descending order) such that A=U\\*S\\*V. S is an m-by-n matrix with s as the diagonal elements.\n* If *fullMatrices*=false, remove the extra rows or columns of zeros from matrix S, along with the columns/rows in U and V that multiply those zeros in the expression A = U\\*S\\*V. Removing these zeros and columns/rows can improve execution time and reduce storage requirements without compromising the accuracy of the decomposition. The resulting matrix U is m-by-k, matrix V is k-by-n and matrix S is k-by-k with k=min(m,n).\n* If *computeUV*=false, only return vector s.\n\n#### Examples\n\n```\nm=matrix([[2,1,0],[1,3,1],[0,1,4],[1,2,3]]);\nU,s,V=svd(m);\nU;\n```\n\n| #0        | #1       | #2        |\n| --------- | -------- | --------- |\n| -0.233976 | 0.57735  | -0.782254 |\n| -0.560464 | 0.57735  | 0.593756  |\n| -0.79444  | -0.57735 | -0.188498 |\n\n```\ns;\n// output\n[6.029042,3,1.284776]\n\nV;\n```\n\n| #0        | #1        | #2        | #3        |\n| --------- | --------- | --------- | --------- |\n| -0.170577 | -0.449459 | -0.620036 | -0.620036 |\n| 0.57735   | 0.57735   | -0.57735  | 0         |\n| -0.755582 | 0.630862  | -0.12472  | -0.12472  |\n| -0.258199 | -0.258199 | -0.516398 | 0.774597  |\n\n```\nU,s,V=svd(m,fullMatrices=false);\nV;\n```\n\n| #0        | #1        | #2        | #3        |\n| --------- | --------- | --------- | --------- |\n| -0.170577 | -0.449459 | -0.620036 | -0.620036 |\n| 0.57735   | 0.57735   | -0.57735  | 0         |\n| -0.755582 | 0.630862  | -0.12472  | -0.12472  |\n"
    },
    "symbol": {
        "url": "https://docs.dolphindb.com/en/Functions/s/symbol.html",
        "signatures": [
            {
                "full": "symbol(X)",
                "name": "symbol",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [symbol](https://docs.dolphindb.com/en/Functions/s/symbol.html)\n\n\n\n#### Syntax\n\nsymbol(X)\n\n#### Arguments\n\n**X** is a string/symbol vector.\n\n#### Details\n\nConvert *X* to a symbol vector.\n\n#### Examples\n\n```\nx=`XOM`y;\ntypestr(x);\n// output\nSTRING VECTOR\n\ny=symbol(x);\ny;\n// output\n[\"XOM\",\"y\"]\n\ntypestr(y);\n// output\nFAST SYMBOL VECTOR\n```\n"
    },
    "symbolCode": {
        "url": "https://docs.dolphindb.com/en/Functions/s/symbolCode.html",
        "signatures": [
            {
                "full": "symbolCode(X)",
                "name": "symbolCode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [symbolCode](https://docs.dolphindb.com/en/Functions/s/symbolCode.html)\n\n#### Syntax\n\nsymbolCode(X)\n\n#### Arguments\n\n**X** is a vector/matrix of SYMBOL type.\n\n#### Details\n\nSYMBOL is a special STRING type used to store repetitive strings in DolphinDB. Internally, data of SYMBOL type is encoded into integers and stored as a dictionary. The internal encoding of an empty string is 0.\n\nFor each element in *X*, this function returns its internal encoding. The return value is of the same dimension as *X*.\n\nIt is recommended to use the SYMBOL type if there are a lot of duplicate values for a certain field such as device ID and stock symbol to improve storage efficiency.\n\n#### Examples\n\n```\na=symbol(`IBM`APPL)\nsymbolCode(a)\n// output\n[1,2]\n\nx=symbol(`MS`AMZN`AAPL`MS`IBM`AAPL)$3:2\nsymbolCode(x)\n\n// output\n#0 #1\n -- --\n1  1 \n2  4 \n3  3 \n```\n\n"
    },
    "symmetricDifference": {
        "url": "https://docs.dolphindb.com/en/Functions/s/symmetricDifference.html",
        "signatures": [
            {
                "full": "symmetricDifference(X, Y)",
                "name": "symmetricDifference",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [symmetricDifference](https://docs.dolphindb.com/en/Functions/s/symmetricDifference.html)\n\n\n\n#### Syntax\n\nsymmetricDifference(X, Y) or X^Y\n\n#### Arguments\n\n**X** and **Y** are sets.\n\n#### Details\n\nReturn the union of two sets minus the intersection of the two sets.\n\n#### Examples\n\n```\nx=set([5,3,4])\ny=set(8 9 4 6);\n\ny^x;\n// output\nset(5,8,3,9,6)\n\nx^y;\n// output\nset(8,5,3,6,9)\n```\n"
    },
    "syncDict": {
        "url": "https://docs.dolphindb.com/en/Functions/s/syncDict.html",
        "signatures": [
            {
                "full": "syncDict(keyObj, valueObj, [sharedName], [ordered=false])",
                "name": "syncDict",
                "parameters": [
                    {
                        "full": "keyObj",
                        "name": "keyObj"
                    },
                    {
                        "full": "valueObj",
                        "name": "valueObj"
                    },
                    {
                        "full": "[sharedName]",
                        "name": "sharedName",
                        "optional": true
                    },
                    {
                        "full": "[ordered=false]",
                        "name": "ordered",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "syncDict(keyType, valueType, [sharedName], [ordered=false])",
                "name": "syncDict",
                "parameters": [
                    {
                        "full": "keyType",
                        "name": "keyType"
                    },
                    {
                        "full": "valueType",
                        "name": "valueType"
                    },
                    {
                        "full": "[sharedName]",
                        "name": "sharedName",
                        "optional": true
                    },
                    {
                        "full": "[ordered=false]",
                        "name": "ordered",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [syncDict](https://docs.dolphindb.com/en/Functions/s/syncDict.html)\n\n\n\n#### Syntax\n\nsyncDict(keyObj, valueObj, \\[sharedName], \\[ordered=false])\n\nor\n\nsyncDict(keyType, valueType, \\[sharedName], \\[ordered=false])\n\n#### Arguments\n\n**keyObj** is a vector indicating dictionary keys.\n\n**valueObj** is a vector indicating dictionary values.\n\n**keyType** is the data type of dictionary keys. The following data categories are supported: Integral (excluding COMPRESSED), Temporal, Floating and Literal.\n\n**valueType** is the data type of dictionary values. Note that COMPLEX/POINT/DECIMAL is not supported.\n\n**sharedName** (optional) is a string. If it is specified, the dictionary is shared across sessions.\n\n**ordered** (optional) is a Boolean value. The default value is false, which indicates to create a regular dictionary. True means to create an ordered dictionary. The regular dictionaries do not track the insertion order of the key-value pairs whereas the ordered dictionaries preserve the insertion order of key-value pairs.\n\n#### Details\n\nReturn a thread-safe dictionary that allows concurrent read and write by multiple threads.\n\n#### Examples\n\n```\nx=1 2 3\ny=4.5 7.8 4.3\nz=syncDict(x,y);\n// output\n3->4.3\n1->4.5\n2->7.8\n\nz=syncDict(INT,DOUBLE)\nz[5]=7.9\nz;\n// output\n5->7.9\n\nsyncDict(INT,DOUBLE, `sn)\nsn[5 6]=10.99 2.33\nsn[5];\n// output\n10.99\n\n// y is a vector of DECIMAL32 type. Create a dictionary z with y as values.\nx=1 3 2\ny = decimal32\\(1.23 3 3.14, 3\\)\nz=dict\\(x,y,true\\);\nz;\n// output\n1-&gt;1.230\n3-&gt;3.000\n2-&gt;3.140\n```\n\nIn the following example, concurrent write to dictionary z1 results in server crash.\n\n```\ndef task1(mutable d,n){\n    for(i in 0..n){\n        d[i]=i*2\n    }\n}\n\ndef task2(mutable d,n){\n    for(i in 0..n){\n        d[i]=i+1\n    }\n}\nn=10000000\n\nz1=dict(INT,INT)\njobId1=submitJob(\"task1\",,task1,z1,n)\njobId2=submitJob(\"task2\",,task2,z1,n);\n```\n\nIn comparison, concurrent write to the thread-safe dictionary z2 is allowed.\n\n```\nz2=syncDict(INT,INT)\njobId3=submitJob(\"task1\",,task1,z2,n)\njobId4=submitJob(\"task2\",,task2,z2,n)\ngetJobReturn(jobId3, true)\ngetJobReturn(jobId4, true)\nz2;\n```\n\nRelated: [array](https://docs.dolphindb.com/en/Functions/a/array.html), [matrix](https://docs.dolphindb.com/en/Functions/m/matrix.html), [dictUpdate!](https://docs.dolphindb.com/en/Functions/d/dictUpdate!.html), [dict](https://docs.dolphindb.com/en/Functions/d/dict.html)\n"
    },
    "syntax": {
        "url": "https://docs.dolphindb.com/en/Functions/s/syntax.html",
        "signatures": [
            {
                "full": "syntax(X)",
                "name": "syntax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [syntax](https://docs.dolphindb.com/en/Functions/s/syntax.html)\n\n\n\n#### Syntax\n\nsyntax(X)\n\n#### Arguments\n\n**X** is a DolphinDB function/command.\n\n#### Details\n\nReturn the syntax of function/command *X*.\n\n#### Examples\n\n```\nsyntax(createPartitionedTable);\n// output\ncreatePartitionedTable(dbHandle, table, tableName, [partitionColumns], [compressMethods])\n```\n"
    },
    "t3": {
        "url": "https://docs.dolphindb.com/en/Functions/t/t3.html",
        "signatures": [
            {
                "full": "t3(X, window, [vfactor=1.0])",
                "name": "t3",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[vfactor=1.0]",
                        "name": "vfactor",
                        "optional": true,
                        "default": "1.0"
                    }
                ]
            }
        ],
        "markdown": "### [t3](https://docs.dolphindb.com/en/Functions/t/t3.html)\n\n\n\n#### Syntax\n\nt3(X, window, \\[vfactor=1.0])\n\nPlease see [TALib](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Arguments\n\n**vfactor** (optional) is a floating-point number in \\[0,1]. The default value is 1.0.\n\n#### Details\n\nCalculate the Triple Exponential Moving Average (t3) for *X* in a sliding window of the given length.\n\nThe formula is\n\n![](https://docs.dolphindb.com/en/images/ema1.png)\n\n![](https://docs.dolphindb.com/en/images/ema2.png)\n\n![](https://docs.dolphindb.com/en/images/gd.png)\n\n![](https://docs.dolphindb.com/en/images/t3.png)\n\n#### Examples\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2 16.9 55.6 5.6 3.3 66 6 57\nt3(x, 3, 0.5);\n// output: [,,,,,,,,,,,,26.84,33.21]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2 15.7 18.6 13.2 19.6 20.3 22.4 11, 14 15 18 19 21 12 10 6 5.5 7 11 16 15 9.9)\nt3(x, 3, 0.8);\n```\n\n| col1  | col2  |\n| ----- | ----- |\n|       |       |\n|       |       |\n|       |       |\n|       |       |\n|       |       |\n|       |       |\n|       |       |\n|       |       |\n|       |       |\n|       |       |\n|       |       |\n|       |       |\n| 20.76 | 13.47 |\n| 18.24 | 13.24 |\n\nRelated function: [tema](https://docs.dolphindb.com/en/Functions/t/tema.html)\n"
    },
    "table": {
        "url": "https://docs.dolphindb.com/en/Functions/t/table.html",
        "signatures": [
            {
                "full": "table(X, [X1], [X2], …..)",
                "name": "table",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": "…..",
                        "name": "….."
                    }
                ]
            },
            {
                "full": "table(capacity:size, colNames, colTypes)",
                "name": "table",
                "parameters": [
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            }
        ],
        "markdown": "### [table](https://docs.dolphindb.com/en/Functions/t/table.html)\n\n\n\n#### Syntax\n\ntable(X, \\[X1], \\[X2], …..)\n\nor\n\ntable(capacity:size, colNames, colTypes)\n\n#### Arguments\n\nFor the first scenario:\n\n**X**, **X1**, **X2** ... can be vectors, matrices or tuples. Each vector, each matrix column and each tuple element must have the same length.\n\nFor the second scenario:\n\n**capacity** is a positive integer indicating the amount of memory (in terms of the number of rows) allocated to the table. When the number of rows exceeds capacity, the system will first allocate memory of 1.2\\~2 times of capacity, copy the data to the new memory space, and release the original memory. For large tables, these steps may use significant amount of memory.\n\n**size** is an integer no less than 0 indicating the initial size (in terms of the number of rows) of the table. If size=0, create an empty table; If size>0, the initialized values are:\n\n* false for Boolean type;\n\n* 0 for numeric, temporal, IPADDR, COMPLEX, and POINT types;\n\n* NULL for Literal, INT128 types.\n\nNote that if *colTypes* is an array vector, *size* must be 0.\n\n**colNames** is a STRING vector of column names.\n\n**colTypes** is a STRING vector of data types. It can use either the reserved words for data types or corresponding strings.\n\n#### Details\n\nFor the first scenario: Converts vectors/matrices/tuples, or the combination of vectors and tuples into a table.\n\nNote:\n\n* If *Xk* is a regular tuple, its elements must be vectors of equal length which is the number of rows of the table. Each element of the tuple is treated as a column of the table.\n\n* If *Xk* is a columnar tuple, its elements can be of unequal length, but the number of its elements must be the same as the number of rows in the table. Xk is converted into a single column (of ANY type) of the table, and each element is stored as the value of each row.\n\nRegular tuples with elements of unequal length are stored as columnar tuples in DolphinDB. For tuples with elements of equal length, to store each element by row, you must convert them to columnar tuples with the `setColumnarTuple!` function.\n\nFor the second scenario: Creates an empty or initialized table of a fixed data type.\n\n#### Examples\n\nExamples of `table(X, [X1], [X2], …..)`:\n\n```\nid=`XOM`GS`AAPL\nx=102.1 33.4 73.6\ntable(id, x);\n```\n\n| id   | x     |\n| ---- | ----- |\n| XOM  | 102.1 |\n| GS   | 33.4  |\n| AAPL | 73.6  |\n\n```\ntable(`XOM`GS`AAPL as id, 102.1 33.4 73.6 as x);\n```\n\n| id   | x     |\n| ---- | ----- |\n| XOM  | 102.1 |\n| GS   | 33.4  |\n| AAPL | 73.6  |\n\nIn the following example, table t is created from a vector x, a matrix y and a tuple z.\n\n```\nx=1..6\ny=matrix(11..16, 17..22)\nz=(101..106, 201..206)\nt=table(x,y,z)\nt.rename!(`x`y1`y2`z1`z2);\n\nt;\n```\n\n| x | y1 | y2 | z1  | z2  |\n| - | -- | -- | --- | --- |\n| 1 | 11 | 17 | 101 | 201 |\n| 2 | 12 | 18 | 102 | 202 |\n| 3 | 13 | 19 | 103 | 203 |\n| 4 | 14 | 20 | 104 | 204 |\n| 5 | 15 | 21 | 105 | 205 |\n| 6 | 16 | 22 | 106 | 206 |\n\nConvert a matrix into a table:\n\n```\nm=matrix(1 2, 3 4, 5 6);\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nt=table(m).rename!(`a`b`x);\nt;\n```\n\n| a | b | x |\n| - | - | - |\n| 1 | 3 | 5 |\n| 2 | 4 | 6 |\n\nCurrently, it is not supported to specify colTypes as ANY type using the table creation statement `table(capacity:size, colNames, colTypes)`. If a memory table containing ANY type is needed, it must be created with an ANY vector to generate the table object. In this case, the ANY object must be a [columnar tuple](https://docs.dolphindb.cn/en/Programming/DataTypesandStructures/DataForms/Vector/columnarTuple.html?hl=columnar%2Ctuple), meaning that the elements must be tuples of the same type. The creation method is as follows:\n\n```\nid = 1 2 3\nval = [[1,2,3], [4,5,6],[7,8,9]]\nt = table(id, val)\nschema(t)\n```\n\n| id | col1 | col2 | col3 |\n| -- | ---- | ---- | :--- |\n| 1  | 1    | 4    | 7    |\n| 2  | 2    | 5    | 8    |\n| 3  | 3    | 6    | 0    |\n\nExamples of `table(capacity:size, colNames, colTypes)`:\n\n```\ntable(100:5, `name`id`value, [STRING,INT,DOUBLE]);\n```\n\n| name | id | value |\n| ---- | -- | ----- |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n\n```\ntable(100:5, `name`id`value, `STRING`INT`DOUBLE);\n```\n\n| name | id | value |\n| ---- | -- | ----- |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n\n```\ntable(100:1, [`value], [DOUBLE]);\n```\n\n| value |\n| ----- |\n| 0     |\n"
    },
    "tableInsert": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tableInsert.html",
        "signatures": [
            {
                "full": "tableInsert(table, args...)",
                "name": "tableInsert",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [tableInsert](https://docs.dolphindb.com/en/Functions/t/tableInsert.html)\n\n\n\n#### Syntax\n\ntableInsert(table, args...)\n\n#### Arguments\n\n**table** is a table object or a table name. The table can be either an in-memory table or a DFS table. In remote call, it must be a table name as we don't have the reference of a table object.\n\n**args...** can be a table/tuple/dictionary.\n\n#### Details\n\nInsert *args*... into table. Return the number of rows inserted from the operation.\n\nIf *args*... is a table, it must have the same schema as table. If *table* is a partitioned table, *args*... must be a table.\n\nIf *args*... is a tuple, it must have the same number of elements as the number of columns of *table* and each element of *args*... must have the same data type as the corresponding column of table.\n\nIf *args*... is multiple vectors or tuples, the number of its elements must be the same as the number of columns of *table* and each vector or tuple must have the same data type as the corresponding column of table.\n\nIf *args*... is a dictionary, its keys correspond to the column names of *table*. The values of *args*... must be a tuple. For this scenario *table* must be an in-memory table.\n\n#### Examples\n\n```\ncolName=[\"Name\",\"Age\"]\ncolType=[\"string\",\"int\"]\nt1=table(100:0,colName, colType);\n\nname=`Tom`Jerry`John\nage=24 25 26\nt2=table(name, age)\n\ntableInsert(t1, t2);\n// output\n3\n\nt1;\n```\n\n| Name  | Age |\n| ----- | --- |\n| Tom   | 24  |\n| Jerry | 25  |\n| John  | 26  |\n\n```\ntableInsert(t1, (`George, 29));\n// output\n1\n\nt1;\n```\n\n| Name   | Age |\n| ------ | --- |\n| Tom    | 24  |\n| Jerry  | 25  |\n| John   | 26  |\n| George | 29  |\n\n```\ntableInsert(t1, (`Frank`Henry, 31 32));\n// output\n2\n\ntableInsert(t1, `Nicole`Nancy, 28 29);\n// output\n2\n\nt1.tableInsert(dict(`Name`Age, [`Patrick, 22]));\n// output\n1\n```\n\nInsert data into a DFS table:\n\n```\ndb=database(\"dfs://db1\",RANGE,0 20 50 101)\nn=100000\nid=rand(100,n)\nval=rand(100.0,n)\nt=table(id,val)\npt=db.createPartitionedTable(t,`pt,`id).append!(t);\n\ntmp=table(rand(100,10000) as id,take(200.0,10000) as val);\n\ntableInsert(pt,tmp);\n// output\n10000\n```\n"
    },
    "tableUpsert": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tableupsert.html",
        "signatures": [
            {
                "full": "tableUpsert(obj, newData, [ignoreNull=false], [keyColNames], [sortColumns])",
                "name": "tableUpsert",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "newData",
                        "name": "newData"
                    },
                    {
                        "full": "[ignoreNull=false]",
                        "name": "ignoreNull",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColNames]",
                        "name": "keyColNames",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns]",
                        "name": "sortColumns",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [tableUpsert](https://docs.dolphindb.com/en/Functions/t/tableupsert.html)\n\n\n\n#### Syntax\n\ntableUpsert(obj, newData, \\[ignoreNull=false], \\[keyColNames], \\[sortColumns])\n\n#### Arguments\n\n**obj** is a keyed table, indexed table, or a DFS table.\n\n**newData** is an in-memory table.\n\n**ignoreNull** (optional) is a Boolean value. If set to true, for the NULL values in *newData*, the corresponding elements in obj are not updated. The default value is false.\n\n**keyColNames** (optional) is a STRING scalar/vector. When *obj* is a DFS table, *keyColNames* are considered as the key columns.\n\n**sortColumns** (optional) is a STRING scalar or vector. The updated partitions will be sorted on *sortColumns* (only within each partition, not across partitions).\n\n**Note:**\n\n* *sortColumns* is supported in `upsert!` only with the OLAP engine.\n\n* To specify *sortColumns*, *obj* must be a DFS table.\n\n* When *obj* is an empty table, setting *sortColumns* has no effect. That is, the system will not sort the inserted data.\n\n#### Details\n\nInsert rows into a table if the values with the key do not already exist, or update them if they do.\n\n**Return value**: A LONG pair. The first element represents the number of inserted records, and the second represents the number of updated records.\n\nThe usage of `tableUpsert` and `upsert!` is consistent, with the difference being that `tableUpsert` returns the number of involved records, while `upsert!` performs an in-place modification, which is often used to chain operations.\n\n#### Examples\n\nUse `tableUpsert` on a keyed table:\n\n```\nsym=`A`B`C\ndate=take(2021.01.06, 3)\nx=1 2 3\ny=5 6 7\nt=keyedTable(`sym`date, sym, date, x, y)\nnewData = table(`A`B`C`D as sym1, take(2021.01.06, 4) as date1, NULL NULL 300 400 as x1, NULL 600 700 800 as y1);\ntableUpsert(t, newData, ignoreNull=true)\n// output\n1:2\n```\n\nUsed `tableUpsert` on an indexed table:\n\n```\nsym=`A`B`C\ndate=take(2021.01.06, 3)\nx=1 2 3\ny=5 6 7\nt=indexedTable(`sym`date, sym, date, x, y)\nnewData = table(`A`B`C`D as sym1, take(2021.01.06, 4) as date1, NULL NULL 300 400 as x1, NULL 600 700 800 as y1);\ntableUpsert(t, newData, ignoreNull=true)\n// output\n1:2\n```\n\nUse `tableUpsert` on a DFS table:\n\n```\nID=0 1 2 2\nx=0.1*0..3\nt=table(ID, x)\ndb=database(\"dfs://rangedb128\", VALUE,  0..10)\npt=db.createPartitionedTable(t, `pt, `ID)\npt.append!(t)\nt1=table(1 as ID, 111 as x)\ntableUpsert(pt, t1, keyColNames=`ID)\n// output\n0:1\n```\n"
    },
    "tail": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tail.html",
        "signatures": [
            {
                "full": "tail(obj, [n=1])",
                "name": "tail",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [tail](https://docs.dolphindb.com/en/Functions/t/tail.html)\n\n\n\n#### Syntax\n\ntail(obj, \\[n=1])\n\n#### Arguments\n\n**obj** is a vector/matrix/table.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the last n element(s) of a vector, or the last n columns of a matrix, or the last n rows of a table.\n\n#### Examples\n\n```\nx=1..10;\ntail(x);\n// output\n10\n\ntail(x,2);\n// output\n[9,10]\n\nx=1..10$2:5;\nx;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  |\n| 2  | 4  | 6  | 8  | 10 |\n\n```\nx.tail();\n// output\n[9,10]\n\ntail(x,2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 7  | 9  |\n| 8  | 10 |\n\n```\nx=table(1..5 as a, 6..10 as b);\nx;\n```\n\n| a | b  |\n| - | -- |\n| 1 | 6  |\n| 2 | 7  |\n| 3 | 8  |\n| 4 | 9  |\n| 5 | 10 |\n\n```\ntail(x);\n// output\nb->10\na->5\n\nx.tail(2);\n```\n\n| a | b  |\n| - | -- |\n| 4 | 9  |\n| 5 | 10 |\n\nRelated function: [head](https://docs.dolphindb.com/en/Functions/h/head.html)\n"
    },
    "take": {
        "url": "https://docs.dolphindb.com/en/Functions/t/take.html",
        "signatures": [
            {
                "full": "take(X, n)",
                "name": "take",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [take](https://docs.dolphindb.com/en/Functions/t/take.html)\n\n\n\n#### Syntax\n\ntake(X, n)\n\n#### Arguments\n\n**X** is a scalar/vector/tuple/matrix/table.\n\n**n** is an integer or a vector of integers.\n\n#### Details\n\n* If *X* is a scalar (*n* must also be a scalar): Generates a vector containing *n* identical values of *X*.\n\n* If *X* is a vector or a tuple:\n\n  * if *n* is a scalar: takes *n* elements from *X* sequentially. It can be left to right (if *n* > 0) or right to left (if *n* < 0). The result is a vector.\n\n  * if *n* is a vector (must be of the same length as *X*): takes *n\\[i]* copies of *X\\[i]*. If *n\\[i]* <= 0, it skips *X\\[i]*. The result is a vector.\n\n* If *X* is a matrix or table:\n\n  * if *n* is a scalar: It takes *n* rows of *X* sequentially, either from top to bottom (if *n* > 0) or bottom to top (if *n* < 0). The result is a matrix or table.\n\n  * if *n* is a vector (must be of the same length as the number of rows in *X*): takes *n\\[i]* copies of the element at the *i-th* row of *X*. If *n\\[i]* <= 0, it skips the *i-th* row and takes no elements. The result is a matrix or table.\n\n#### Examples\n\n```\ntake(10,5);\n// output\n[10,10,10,10,10]\n\nx=`IBM`C`AAPL`BABA;\ntake(x,10);\n// output\n[\"IBM\",\"C\",\"AAPL\",\"BABA\",\"IBM\",\"C\",\"AAPL\",\"BABA\",\"IBM\",\"C\"]\n// sequentially and iteratively take 10 elements from vector x\n\nx=3 5 4 6 9;\ntake(x,3);\n// output\n[3,5,4]\n\n\nx=1..3;\nx.take(10);\n// output\n[1,2,3,1,2,3,1,2,3,1]\n\ntake(1 2 3, 10);\n// output\n[1,2,3,1,2,3,1,2,3,1]\n\n\ntake(1,10);\n// output\n[1,1,1,1,1,1,1,1,1,1]\n// an efficient way to generate a vector with default values.\n\n\nx=take(1,0);\n// return an empty INT VECTOR\n\nx;\n// output\n[]\n\ntypestr x;\n// output\nFAST INT VECTOR\n\n\nx=1..12$3:4;\ntake(x,2);\n// output\n[1,2]\n\ntake(x,-2);\n// output\n[11,12]\n\ntake(1..3,2 0 2)\n// output\n[1,1,3,3]\n\nm=matrix(1 2 3, 4 5 6)\ntake(m,5)\n// output\ncol1        col2\n1   4\n2   5\n3   6\n1   4\n2   5\n\ntake(m, 0 2 1)\n// output\ncol1        col2\n2   5\n2   5\n3   6\n\nt=table(1 2 3 as a, 4 5 6 as b)\ntake(t,-4)\n// output\na   b\n3   6\n1   4\n2   5\n3   6\n\ntake(t, -2 2 1)\n// output\na   b\n2   5\n2   5\n3   6\n```\n"
    },
    "talibNull": {
        "url": "https://docs.dolphindb.com/en/Functions/t/talibNull.html",
        "signatures": [
            {
                "full": "talibNull(args...)",
                "name": "talibNull",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [talibNull](https://docs.dolphindb.com/en/Functions/t/talibNull.html)\n\n\n\n#### Syntax\n\ntalibNull(args...)\n\n#### Arguments\n\n**args...** consist of two or more vectors. All vectors must have the same length.\n\n#### Details\n\nTraverse each vector (v1, v2, …, vn) based on the index starting from 0 and return a tuple.\n\nIf all values at index i (v1\\[i], v2\\[i], ..., vn\\[i] ) are non-NULL values, then the elements at index 0 to index i take the NULL values, and values of the element after index i remain unchanged.\n\n#### Examples\n\nThe values at index 2 of all vectors are non-NULL. Therefore, return NULL values for all elements before index 2.\n\n```\ntalibNull(2 3 4 5 6, NULL 1 2 NULL 4, 7 NULL 9 10 11)\n// output\n([,,4,5,6],[,,2,,4],[,,9,10,11])\n```\n"
    },
    "tan": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tan.html",
        "signatures": [
            {
                "full": "tan(X)",
                "name": "tan",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [tan](https://docs.dolphindb.com/en/Functions/t/tan.html)\n\n\n\n#### Syntax\n\ntan(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nThe tangent function.\n\n#### Examples\n\n```\ntan(0 1 2);\n// output\n[0,1.557408,-2.185040]\n```\n\nRelated functions: [asin](https://docs.dolphindb.com/en/Functions/a/asin.html), [acos](https://docs.dolphindb.com/en/Functions/a/acos.html), [atan](https://docs.dolphindb.com/en/Functions/a/atan.html), [sin](https://docs.dolphindb.com/en/Functions/s/sin.html), [cos](https://docs.dolphindb.com/en/Functions/c/cos.html).\n"
    },
    "tanh": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tanh.html",
        "signatures": [
            {
                "full": "tanh(X)",
                "name": "tanh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [tanh](https://docs.dolphindb.com/en/Functions/t/tanh.html)\n\n\n\n#### Syntax\n\ntanh(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nThe hyperbolic tangent function.\n\n#### Examples\n\n```\ntanh(0 1 2);\n// output\n[0,0.761594,0.964028]\n```\n"
    },
    "tanimoto": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tanimoto.html",
        "signatures": [
            {
                "full": "tanimoto(X, Y)",
                "name": "tanimoto",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [tanimoto](https://docs.dolphindb.com/en/Functions/t/tanimoto.html)\n\n\n\n#### Syntax\n\ntanimoto(X, Y)\n\n#### Arguments\n\n**X** and **Y** are numeric scalars, or vectors/matrices of the same size.\n\n#### Details\n\nIf *X* and *Y* are scalars or vectors, return the result of their tanimoto distance.\n\nIf *X* or *Y* is a matrix, return a vector that is the result of the tanimoto distance between elements in each column. Note that if both *X* and *Y* are indexed matrices or indexed series, return the results of rows with the same label. Rows with different labels will be ignored.\n\nAs with all other aggregate functions, NULL values are ignored in the calculation.\n\nHere is the formula of Tanimoto similarity (similar). Tanimoto distance is calculated as 1-similar.\n\n#### Examples\n\n```\na=[10.5, 11.8, 9]\nb=[11.3, 15.1, 8.9]\ntanimoto(a,b)\n// output\n0.029706\n\ns1=indexedSeries(2020.01.01..2020.01.03, 10.4 11.2 9)\ns2=indexedSeries(2020.01.01 2020.01.03 2020.01.04, 23.5 31.2 26)\ntanimoto(s1,s2)\n// output\n0.5585\n\nm=matrix(23 56 47, 112 94 59)\nm1=matrix(11 15 89, 52 41 63)\ntanimoto(m,m1)\n// output\n[0.40490.3242]\n\nm.rename!(2020.01.01..2020.01.03, `A`B)\nm.setIndexedMatrix!()\nm1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\nm1.setIndexedMatrix!()\ntanimoto(m,m1)\n// output\n[0.5494,0.3225]\n```\n\nRelated function: [rowTanimoto](https://docs.dolphindb.com/en/Functions/r/rowTanimoto.html)\n"
    },
    "tema": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tema.html",
        "signatures": [
            {
                "full": "tema(X, window)",
                "name": "tema",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tema](https://docs.dolphindb.com/en/Functions/t/tema.html)\n\n\n\n#### Syntax\n\ntema(X, window)\n\nPlease see [TALib](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the Triple Exponential Moving Average (tema) for *X* in a sliding window of the given length.\n\nThe formula is:\n\n![](https://docs.dolphindb.com/en/images/ema1.png)\n\n![](https://docs.dolphindb.com/en/images/ema2.png)\n\n![](https://docs.dolphindb.com/en/images/tema.png)\n\n#### Examples\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\ntema(x,3);\n// output\n[,,,,,,11.24444444444444]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\ntema(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n| 11.2444 | 10.6296 |\n\nRelated functions: [ema](https://docs.dolphindb.com/en/Functions/e/ema.html), [dema](https://docs.dolphindb.com/en/Functions/d/dema.html)\n"
    },
    "temporalAdd": {
        "url": "https://docs.dolphindb.com/en/Functions/t/temporalAdd.html",
        "signatures": [
            {
                "full": "temporalAdd(obj, duration, unit)",
                "name": "temporalAdd",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "duration",
                        "name": "duration"
                    },
                    {
                        "full": "unit",
                        "name": "unit"
                    }
                ]
            }
        ],
        "markdown": "### [temporalAdd](https://docs.dolphindb.com/en/Functions/t/temporalAdd.html)\n\n\n\n#### Syntax\n\ntemporalAdd(obj, duration, unit)\n\nAlias: datetimeAdd\n\n#### Arguments\n\n**obj** is a temporal scalar/pair/vector.\n\n**duration** is an integer.\n\n**unit** is a STRING vector.\n\n* When parameter *duration* is an integer, *unit* is:\n\n  * the unit of parameter *duration*. It can be \"ns\"(nanosecond), \"us\"(microsecond), \"ms\"( millisecond), \"s\"(second), \"m\"(minute), \"H\"(hour), \"d\"(day), \"w\"(week), \"M\"(month), \"y\"( year), or \"B\"(business day).\n\n  * the identifier of trading calendar, e.g., the Market Identifier Code of an exchange, or a user-defined calendar name. The corresponding file must be saved in *marketHolidayDir*.\n\n* When *duration* is of DURATION type, this parameter is not required.\n\n**Note:** When *unit* is \"y\" or \"M\", the result is consistent with mysql. Pandas provides an offset object *Dateoffsets* to move dates forward a given number of valid dates. When the *DateOffset* parameter is specified as months or years, the result is also consistent with *temporalAdd*.\n\n#### Details\n\nAdd a value to a temporal variable.\n\n#### Examples\n\n```\ntemporalAdd(2017.01.16,1,\"d\");\n// output\n2017.01.17\n\ntemporalAdd(2017.01.16,1,\"w\");\n// output\n2017.01.23\n\ntemporalAdd(2016.12M,2,\"M\");\n// output\n2017.02M\n\ntemporalAdd(2012.07.31T13:30:10.008,-1,'M');\n// output\n2012.06.30T13:30:10.008\n\ntemporalAdd(2012.07.31T13:30:10.008,1,'y');\n// output\n2013.07.31T13:30:10.008\n\ntemporalAdd(13:30:10.008007006,100,\"ns\");\n// output\n13:30:10.008007106\n\nx=[12:23:34, 23:34:45];\ntemporalAdd(x, 10m);\n// output\n[12:33:34,23:44:45]\n```\n\nAdd four business days to 2021.08.06.\n\n```\ntemporalAdd(2021.08.06, 4B)\n// output\n2021.08.12\n```\n\nAdd 2 trading days for \"date\" according to the trading calendar CFFEX.\n\n```\ndate=[2023.01.01, 2023.01.02, 2023.01.03, 2023.01.04]\ntemporalAdd(date,2,`CFFEX)\n// output\n[2023.01.04,2023.01.04,2023.01.05,2023.01.06]\n```\n\n```\ntemporalAdd(datetime(2020.08.31), -2M)\n// output\n2020.06.30T00:00:00\n\n//The result is the same as setting months=2 in pandas *DateOffset*.\npd1 = pd.Timestamp(\"2020.08.31\")\nprint(pd1 -pd.offsets.DateOffset(months=2))\n// output\n2020-06-30 00:00:00\n\ntemporalAdd(datetime(2020.02.29), -1y)\n// output\n2019.02.28T00:00:00\ntemporalAdd(datetime(2020.02.29), -4y)\n// output\n2016.02.29T00:00:00\n\n//The result is the same as setting years=1 in pandas *DateOffset*.\npd1 = pd.Timestamp(\"2020.02.29\")\nprint(pd1 - pd.offsets.DateOffset(years=1))\n// output\n2019-02-28 00:00:00\n\n//The result is the same as setting years=4 in pandas *DateOffset*.\npd2 = pd.Timestamp(\"2020.02.29\")\nprint(pd2 - pd.offsets.DateOffset(years=4))\n// output\n2016-02-29 00:00:00\n```\n"
    },
    "temporalFormat": {
        "url": "https://docs.dolphindb.com/en/Functions/t/temporalFormat.html",
        "signatures": [
            {
                "full": "temporalFormat(X, format)",
                "name": "temporalFormat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "format",
                        "name": "format"
                    }
                ]
            }
        ],
        "markdown": "### [temporalFormat](https://docs.dolphindb.com/en/Functions/t/temporalFormat.html)\n\n\n\n#### Syntax\n\ntemporalFormat(X, format)\n\nAlias: datetimeFormat\n\n#### Arguments\n\n**X** is a scalar/vector of temporal data types.\n\n**format** is a string indicating a temporal format.\n\n#### Details\n\nConvert a DolphinDB temporal variable to a string with specified format. For details about DolphinDB temporal formats, please check the section [Parsing and Format of Temporal Variables](https://docs.dolphindb.com/en/Programming/DataManipulation/TemporalObjects/ParsingandFormatofTemporalVariables.html).\n\n#### Examples\n\n```\ntemporalFormat(2018.02.14,\"dd-MM-yyyy\");\n// output\n14-02-2018\n\ntemporalFormat(2018.02.14,\"dd-MMM-yy\");\n// output\n14-FEB-18\n\ntemporalFormat(02:19:06,\"HH.mm.ss\");\n// output\n02.19.06\n\ntemporalFormat(2018.02.06T13:30:10.001, \"y-M-d-H-m-s-SSS\");\n// output\n2018-2-6-13-30-10-001\n\ntemporalFormat(14:19:06,\"hhmmssaa\");\n// output\n021906PM\n```\n"
    },
    "temporalParse": {
        "url": "https://docs.dolphindb.com/en/Functions/t/temporalParse.html",
        "signatures": [
            {
                "full": "temporalParse(X, format)",
                "name": "temporalParse",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "format",
                        "name": "format"
                    }
                ]
            }
        ],
        "markdown": "### [temporalParse](https://docs.dolphindb.com/en/Functions/t/temporalParse.html)\n\n\n\n#### Syntax\n\ntemporalParse(X, format)\n\nAlias: datetimeParse\n\n#### Arguments\n\n**X** is a string scalar/vector to be converted to temporal data types.\n\n**format** is a string indicating a temporal format.\n\n#### Details\n\nConvert a string with specified format to a DolphinDB temporal data type. Return NULL if it cannot decide on the data type.\n\nDolphinDB has the following temporal formats:\n\n| Format    | Meaning          | Range of value                              |\n| --------- | ---------------- | ------------------------------------------- |\n| yyyy      | year (4 digits)  | 1000-9999                                   |\n| yy        | year (2 digits)  | 00-99. (00-39: 2000-2039; 40-99: 1940-1999) |\n| MM        | month in year    | 1-12                                        |\n| MMM       | month in year    | JAN, FEB, ... DEC (case insensitive)        |\n| dd        | day in month     | 1-31                                        |\n| HH        | hour in day      | 0-23                                        |\n| hh        | hour in AM/PM    | 0-11                                        |\n| mm        | minute in hour   | 0-59                                        |\n| ss        | second in minute | 0-59                                        |\n| aa        | AM/PM marker     | AM, PM. (case-insensitive)                  |\n| SSS       | millisecond      | 0-999                                       |\n| nnnnnn    | microsecond      | 0-999999                                    |\n| nnnnnnnnn | nanosecond       | 0-999999999                                 |\n\nThe parameter format of the *temporalParse* function has 2 types of representation:\n\n* **With deliminator(s)**\n\nAny symbol or character is treated as a deliminator except the characters that are used to express a temporal format: y, M, d, H, h, m, s, a, S, and n. A deliminator in the parameter *format* should be identical as the deliminator in the input string.\n\n```\ntemporalParse(\"14-02-2018\",\"dd-MM-yyyy\");\n// output\n2018.02.14\n\ntemporalParse(\"14-02-2018\",\"dd/MM/yyyy\");\n// output\n00d\n\ntemporalParse(\"14//02//2018\",\"dd//MM//yyyy\");\n// output\n2018.02.14\n\ntemporalParse(\"14//02//2018\",\"dd/MM/yyyy\");\n// output\n00d\n\ntemporalParse(\"14//02//2018\",\"dd..MM..yyyy\");\n// output\n00d\n```\n\nWe can simplify the formats by using a single letter between deliminators for the parameter *format*. For example, we can use the format \"y/M/d\" instead of \"yyyy/MM/dd\" for \"2018/01/16\". As \"y\" may mean both \"yyyy\" and \"yy\", for this case the system decides on the format based on the number of digits between deliminators.\n\n```\ntemporalParse(\"14-02-18\",\"d-M-y\");\n// output\n2018.02.14\n\ntemporalParse(\"2018/2/6 02:33:01 PM\",\"y/M/d h:m:s a\");\n// output\n2018.02.06T14:33:01\n```\n\n\"MMM\",\"SSS\", \"nnnnnn\" and \"nnnnnnnnn\", however, cannot be simplified to a single letter.\n\n```\ntemporalParse(\"02-FEB-2018\",\"d-MMM-y\");\n// output\n2018.02.02\n\ntemporalParse(\"02-FEB-2018\",\"d-M-y\");\n// output\n00d\n\ntemporalParse(\"13:30:10.001\",\"H:m:s.SSS\");\n// output\n13:30:10.001\n\ntemporalParse(\"13:30:10.001\",\"H:m:s.S\");\n// output\nInvalid temporal format: 'H:m:s.S'. Millisecond (S) must have three digits.\n\ntemporalParse(\"13:30:10.008001\",\"H:m:s.nnnnnn\");\n// output\n13:30:10.008001000\n\ntemporalParse(\"13:30:10.008001\",\"H:m:s.n\");\n// output\nInvalid temporal format: 'H:m:s.n'. Nanosecond (n) must have six or nine digits.\n```\n\nThe `temporalParse` function is very flexible in interpreting the numbers between deliminators in the input string.\n\n```\ntemporalParse(\"2-4-18\",\"d-M-y\");\n// output\n2018.04.02\n\ntemporalParse(\"2-19-6\",\"H-m-s\");\n// output\n02:19:06\n\ntemporalParse(\"002-019-006\",\"H-m-s\");\n// output\n02:19:06\n```\n\nFor millisecond, microsecond and nanosecond, however, the corresponding number of digits in the input string must be 3, 6 and 9 respectively.\n\n```\ntemporalParse(\"2018/2/6 13:30:10.001\",\"y/M/d H:m:s.SSS\");\n// output\n2018.02.06T13:30:10.001\n\ntemporalParse(\"2018/2/6 13:30:10.01\",\"y/M/d H:m:s.SSS\");\n// output\n00T\n\ntemporalParse(\"2018/2/6 13:30:10.000001\",\"y/M/d H:m:s.nnnnnn\");\n// output\n2018.02.06T13:30:10.000001000\n\ntemporalParse(\"2018/2/6 13:30:10.0000010\",\"y/M/d H:m:s.nnnnnn\");\n// output\n00N\n```\n\nIf a character that is used to express a temporal format (y, M, d, H, h, m, s, a, S, n) appears in the input string as a deliminator, we need to use \"\" before the character in parameter *format*.\n\n```\ntemporalParse(\"2013a02\", \"y\\\\aM\");\n// output\n2013.02M\n\ntemporalParse(\"2013an02\", \"y\\\\a\\\\nM\");\n// output\n2013.02M\n```\n\n* **Without deliminators**\n\nFor this reprensentation, the parameter *format* must be composed of the formats in the temporal formats table. We cannot use a single letter to represent a format in the temporal format table.\n\n```\ntemporalParse(\"20180214\",\"yyyyMMdd\");\n// output\n2018.02.14\n\ntemporalParse(\"122506\",\"MMddyy\");\n// output\n2006.12.25\n\ntemporalParse(\"155950\",\"HHmmss\");\n// output\n15:59:50\n\ntemporalParse(\"035901PM\",\"hhmmssaa\");\n// output\n15:59:01\n\ntemporalParse(\"02062018155956001000001\",\"MMddyyyyHHmmssnnnnnnnnn\");\n// output\n2018.02.06T15:59:56.001000001\n```\n"
    },
    "temporalSeq": {
        "url": "https://docs.dolphindb.com/en/Functions/t/temporalSeq.html",
        "signatures": [
            {
                "full": "temporalSeq(start, end, rule, [closed], [label], [origin='start_day'])",
                "name": "temporalSeq",
                "parameters": [
                    {
                        "full": "start",
                        "name": "start"
                    },
                    {
                        "full": "end",
                        "name": "end"
                    },
                    {
                        "full": "rule",
                        "name": "rule"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    },
                    {
                        "full": "[label]",
                        "name": "label",
                        "optional": true
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    }
                ]
            }
        ],
        "markdown": "### [temporalSeq](https://docs.dolphindb.com/en/Functions/t/temporalSeq.html)\n\n#### Syntax\n\ntemporalSeq(start, end, rule, \\[closed], \\[label], \\[origin='start\\_day'])\n\n#### Details\n\nResample the time series between start and end based on the frequency specified by *rule*.\n\n**Return value**: a vector of temporal type.\n\n#### Arguments\n\n**start** is a temporal scalar.\n\n**end** is a temporal scalar. Its data type must be the same as *start*, and its value must be greater than *start*.\n\n**rule** is a string that can take the following values:\n\n| Values of *rule* | DolphinDB function   |\n| ---------------- | -------------------- |\n| \"B\"              | businessDay          |\n| \"W\"              | weekEnd              |\n| \"WOM\"            | weekOfMonth          |\n| \"LWOM\"           | lastWeekOfMonth      |\n| \"M\"              | monthEnd             |\n| \"MS\"             | monthBegin           |\n| \"BM\"             | businessMonthEnd     |\n| \"BMS\"            | businessMonthBegin   |\n| \"SM\"             | semiMonthEnd         |\n| \"SMS\"            | semiMonthBegin       |\n| \"Q\"              | quarterEnd           |\n| \"QS\"             | quarterBegin         |\n| \"BQ\"             | businessQuarterEnd   |\n| \"BQS\"            | businessQuarterBegin |\n| \"REQ\"            | fy5253Quarter        |\n| \"A\"              | yearEnd              |\n| \"AS\"             | yearBegin            |\n| \"BA\"             | businessYearEnd      |\n| \"BAS\"            | businessYearBegin    |\n| \"RE\"             | fy5253               |\n| \"D\"              | date                 |\n| \"H\"              | hourOfDay            |\n| \"U\"              | microsecond          |\n| \"L\"              | millisecond          |\n| \"min\"            | minuteOfHour         |\n| \"N\"              | nanosecond           |\n| \"S\"              | secondOfMinute       |\n\nThe strings above can also be used with integers for parameter \"rule\". For example, \"2M\" means the end of every two months. In addition, *rule* can also be set as the identifier of the trading calendar, e.g., the Market Identifier Code of an exchange, or a user-defined calendar name.\n\n**closed** (optional) is a string indicating which boundary of the interval is closed.\n\n* The default value is 'left' for all values of *rule* except for 'M', 'A', 'Q', 'BM', 'BA', 'BQ', and 'W' which all have a default of 'right'.\n\n* The default is 'right' if *origin* is 'end' or 'end\\_day'.\n\n**label** (optional) is a string indicating which boundary is used to label the interval.\n\n* The default value is 'left' for all values of *rule* except for 'M', 'A', 'Q', 'BM', 'BA', 'BQ', and 'W' which all have a default of 'right'.\n\n* The default is 'right' if *origin* is 'end' or 'end\\_day'.\n\n**origin** (optional) is a string or a scalar of the same data type as *X*, indicating the timestamp where the intervals start. It can be 'epoch', start', 'start\\_day', 'end', 'end\\_day' or a user-defined time object. The default value is 'start\\_day'.\n\n* 'epoch': *origin* is 1970-01-01\n\n* 'start': *origin* is the first value of the timeseries\n\n* 'start\\_day': *origin* is 00:00 of the first day of the timeseries\n\n* 'end': *origin* is the last value of the timeseries\n\n* 'end\\_day': *origin* is 24:00 of the last day of the timeseries\n\n#### Examples\n\n```\ntemporalSeq(start=2022.01.01 00:01:00,end=2022.01.01 00:08:00,rule=\"3min\")\n// output\n[2022.01.01T00:00:00,2022.01.01T00:03:00,2022.01.01T00:06:00]\n    \ntemporalSeq(start=2022.01.01 00:01:00, end=2022.01.01 00:08:00, rule=\"3min\", closed=`right)\n// output\n[2022.01.01T00:00:00,2022.01.01T00:03:00,2022.01.01T00:06:00]\n    \ntemporalSeq(start=2022.01.01 00:01:00, end=2022.01.01 00:08:00, rule=\"3min\", closed=`right, origin=`end)\n// output\n[2022.01.01T00:02:00,2022.01.01T00:05:00,2022.01.01T00:08:00]\n    \ntemporalSeq(start=2022.01.01 00:01:00, end=2022.01.01 00:08:00, rule=\"3min\", closed=`right, origin=2022.10.01 00:00:10)\n// output\n[2022.01.01T00:00:10,2022.01.01T00:03:10,2022.01.01T00:06:10]\n```\n\n"
    },
    "tensor": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tensor.html",
        "signatures": [
            {
                "full": "tensor(X)",
                "name": "tensor",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [tensor](https://docs.dolphindb.com/en/Functions/t/tensor.html)\n\n\n\n#### Syntax\n\ntensor(X)\n\n#### Arguments\n\n**X** can be a scalar, vector, tuple, columnar tuple, matrix or table. These data types are supported: BOOL, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE\n\n#### Details\n\nGenerate a tensor from *X* with the following rules:\n\n| **X**                                                                                                      | **Output**                   |\n| :--------------------------------------------------------------------------------------------------------- | :--------------------------- |\n| scalar                                                                                                     | 1D tensor                    |\n| vector                                                                                                     | 1D tensor                    |\n| columnar tuple                                                                                             | 2D tensor                    |\n| matrix                                                                                                     | 2D tensor                    |\n| table (with all columns of the same type)                                                                  | 2D tensor                    |\n| tuple of vectors (each element is a vector of the same type)                                               | 2D tensor                    |\n| tuple of matrices (each element is a matrix with the same dimensions and type)                             | 3D tensor                    |\n| tuple of tuples (each element is a tuple, and each element of the sub-tuples is a vector of the same type) | 3D tensor                    |\n| n-level nested tuple                                                                                       | n-D tensor (where *n* <= 10) |\n\nNote: Tensors are mainly used with the DolphinDB plugins (such as LibTorch) for data exchange with deep learning frameworks. DolphinDB does not currently support direct storage and computation of tensors, nor direct access or modification to their elements.\n\n#### Examples\n\n```\n//generate tensor from a scalar\n/* output 1D tensor of size 1: tensor<int[1]>:\n0: int 3\n*/\n\n//from a vector\n/*tensor<int[3]>:\n0: int 1\n1: int 2\n2: int 3\n*/\n\n//from a columnar tuple\ntp = [[1.3,2.5,2.3], [4.1,5.3,5], [4.1,5.3,5]]\ntp.setColumnarTuple!()\ntensor(tp)\n\n/*tensor<double[3][3]>: \n0: double[3] [1.3, 2.5, 2.3]\n1: double[3] [4.1, 5.3, 5]\n2: double[3] [4.1, 5.3, 5] \n */\n\n//from a matrix\nm= 1..6$2:3\ntensor(m)\n\n/*tensor<int[2][3]>: \n0: int[3] [1, 3, 5]\n1: int[3] [2, 4, 6]\n*/\n\n//from a table\nt=table(1..5 as id1, 6..10 as id2)\ntensor(t)\n\n/*tensor<int[5][2]>: \n0: int[2] [1, 6]\n1: int[2] [2, 7]\n2: int[2] [3, 8]\n3: int[2] [4, 9]\n4: int[2] [5, 10]\n*/\n\n//from a tuple\ntp1 = [[1.3,2.5,2.3], [4.1,5.3,5], [4.1,5.3,5]]\ntensor(tp1)\n\n/*tensor<double[3][3]>: \n0: double[3] [1.3, 4.1, 4.1]\n1: double[3] [2.5, 5.3, 5.3]\n2: double[3] [2.3, 5, 5]\n*/\n\n//from a tuple of matrixs\nm1= 1..6$2:3\nm2=4..9$2:3\ntensor([m1,m2])\n\n/*tensor<int[2][2][3]>:\n0: int[2][3]\n1: int[2][3]\n*/\n\n//from a tuple of tuples\ntp1 = [[1.3,2.5,2.3], [4.1,5.3,5], [4.1,5.3,5]]\ntp2 = [[1.1,1.2,1.4], [1.5,1.2,1.6], [1.3,1.5,1.8]]\ntensor([tp1, tp2])\n\n/*tensor<double[2][3][3]>:\n0: double[3][3]\n1: double[3][3]\n*/\n\n//from a nested tuple\ntp1 = [[1.3,2.5,2.3], [4.1,5.3,5], [4.1,5.3,5]]\ntp2 = [[1.1,1.2,1.4], [1.5,1.2,1.6], [1.3,1.5,1.8]]\ntp3 = [[2.1,6.2,4.4], [3.5,1.9,3.6], [1.8,3.5,9.8]]\ntensor([[tp1, tp2],[tp1, tp3]])\n\n/*tensor<double[2][2][3][3]>:\n0: double[2][3][3]\n1: double[2][3][3]\n*/\n```\n"
    },
    "test": {
        "url": "https://docs.dolphindb.com/en/Functions/t/test.html",
        "signatures": [
            {
                "full": "test(scriptFile, [outputFile], [testMemLeaking=false])",
                "name": "test",
                "parameters": [
                    {
                        "full": "scriptFile",
                        "name": "scriptFile"
                    },
                    {
                        "full": "[outputFile]",
                        "name": "outputFile",
                        "optional": true
                    },
                    {
                        "full": "[testMemLeaking=false]",
                        "name": "testMemLeaking",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [test](https://docs.dolphindb.com/en/Functions/t/test.html)\n\n\n\n#### Syntax\n\ntest(scriptFile, \\[outputFile], \\[testMemLeaking=false])\n\n#### Arguments\n\n**scriptFile** is a string indicating the path of a testing script file or a folder.\n\n**outputFile** (optional) is a string indicating the path of a test result script file or a folder.\n\n**testMemLeaking** (optional) is a Boolean value indicating whether to test for memory leaks.\n\n#### Details\n\nA system command for unit testing. It must be executed by a logged-in user.\n\nIf *scriptFile* is a folder, all script files in the folder will be tested.\n\nIf *outputFile* is not specified, the testing result will be displayed on screen. If *outputFile* is specified as a relative path, the testing result file will be output to \\<HomeDir>.\n\n#### Examples\n\n```\ntest(\"C:/DolphinDB/test/test1.txt\", \"C:/DolphinDB/testResult/test1.txt\");\ntest(\"C:/DolphinDB/test\");\n```\n"
    },
    "textChunkDS": {
        "url": "https://docs.dolphindb.com/en/Functions/t/textChunkDS.html",
        "signatures": [
            {
                "full": "textChunkDS(filename, chunkSize, [delimiter], [schema], [skipRows=0], [arrayDelimiter], [containHeader], [arrayMarker])",
                "name": "textChunkDS",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "chunkSize",
                        "name": "chunkSize"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    },
                    {
                        "full": "[schema]",
                        "name": "schema",
                        "optional": true
                    },
                    {
                        "full": "[skipRows=0]",
                        "name": "skipRows",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[arrayDelimiter]",
                        "name": "arrayDelimiter",
                        "optional": true
                    },
                    {
                        "full": "[containHeader]",
                        "name": "containHeader",
                        "optional": true
                    },
                    {
                        "full": "[arrayMarker]",
                        "name": "arrayMarker",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [textChunkDS](https://docs.dolphindb.com/en/Functions/t/textChunkDS.html)\n\n\n\n#### Syntax\n\ntextChunkDS(filename, chunkSize, \\[delimiter], \\[schema], \\[skipRows=0], \\[arrayDelimiter], \\[containHeader], \\[arrayMarker])\n\n#### Arguments\n\n**filename** is a string indicating the input text file name with its absolute path. Currently only *.csv* files are supported.\n\n**chunkSize** is an integer between 1 and 2048 (MB) indicating the size of a file chunk.\n\n**delimiter** (optional) is a STRING scalar indicating the table column separator. It can consist of one or more characters, with the default being a comma (',').\n\n**schema** (optional) a table. It can have the following columns, among which \"name\" and \"type\" columns are required.\n\n| Column | Data Type            | Description                    |\n| ------ | -------------------- | ------------------------------ |\n| name   | STRING scalar        | column name                    |\n| type   | STRING scalar        | data type                      |\n| format | STRING scalar        | the format of temporal columns |\n| col    | INT scalar or vector | the columns to be loaded       |\n\n**skipRows** (optional) is an integer between 0 and 1024 indicating the rows in the beginning of the text file to be ignored. The default value is 0.\n\n**arrayDelimiter** (optional) is a single character indicating the delimiter for columns holding the array vectors in the file. Since the array vectors cannot be recognized automatically, you must use the *schema* parameter to update the data type of the type column with the corresponding array vector data type before import.\n\n**containHeader** (optional) a Boolean value indicating whether the file contains a header row. The default value is NULL. See [loadText](https://docs.dolphindb.com/en/Functions/l/loadText.html) for the detailed determining rules.\n\n**arrayMarker** is a string containing 2 characters or a CHAR pair. These two characters represent the identifiers for the left and right boundaries of an array vector. The default identifiers are double quotes (\").\n\n* It cannot contain spaces, tabs (`\\t`), or newline characters (`\\t` or `\\n`).\n\n* It cannot contain digits or letters.\n\n* If one is a double quote (`\"`), the other must also be a double quote.\n\n* If the identifier is `'`, `\"`, or `\\`, a backslash ( \\ ) escape character should be used as appropriate. For example, `arrayMarker=\"\\\"\\\"\"`.\n\n* If *delimiter*specifies a single character, *arrayMarker* cannot contain the same character.\n\n* If *delimiter*specifies multiple characters, the left boundary of *arrayMarker* cannot be the same as the first character of *delimiter*.\n\n#### Details\n\nTo load an extremely large text file into DolphinDB database, we can first use function `textChunkDS` to divide the text file into multiple data sources with the size of each data source specified by *chunkSize*, then use function [mr](https://docs.dolphindb.com/en/Functions/m/mr.html) to load data.\n\nWhen loading data files in DolphinDB, a random sample of the data is analyzed to determine the data type for each column. However, this sampling method does not always accurately determine the column types. It is recommend to use the `extractTextSchema` function to check the schema of the input file before loading the data. You can specify the intended data type for each column in the \"type\" field of the *schema*. For date or time columns particularly, if DolphinDB does not recognize the correct data types, you need to set the temporal type in the \"type\" field, and provide the date/time format string (e.g. \"MM/dd/yyyy\") in the \"format\" field. Refer to [Parsing and Format of Temporal Variables](https://docs.dolphindb.com/en/Programming/DataManipulation/TemporalObjects/ParsingandFormatofTemporalVariables.html) for temproal formats in DolphinDB.\n\n#### Examples\n\nUse the following script to generate the data file of about 3.2GB:\n\n```\nn=30000000\nworkDir = \"/home/DolphinDB\"\nif(!exists(workDir)) mkdir(workDir)\ntrades=table(rand(`IBM`MSFT`GM`C`FB`GOOG`V`F`XOM`AMZN`TSLA`PG`S,n) as sym, 2000.01.01+rand(365,n) as date, 10.0+rand(2.0,n) as price1, 100.0+rand(20.0,n) as price2, 1000.0+rand(200.0,n) as price3, 10000.0+rand(2000.0,n) as price4, 10000.0+rand(3000.0,n) as price5, 10000.0+rand(4000.0,n) as price6, rand(10,n) as qty1, rand(100,n) as qty2, rand(1000,n) as qty3, rand(10000,n) as qty4, rand(10000,n) as qty5, rand(10000,n) as qty6)\ntrades.saveText(workDir + \"/trades.txt\");\n```\n\nLoad the file into a DFS database with functions `textChunkDS` and `mr`:\n\n```\ndb=database(\"dfs://db1\",VALUE, `IBM`MSFT`GM`C`FB`GOOG`V`F`XOM`AMZN`TSLA`PG`S)\npt=db.createPartitionedTable(trades,`pt,`sym)\nds=textChunkDS(workDir + \"/trades.txt\",500)\nmr(ds,append!{pt},,,false)\n```\n\n**Note:** Different data sources here may contain data in the same partition. As DolphinDB does not allow writing to the same partition simultaneously from multiple threads, we must set parameter 'parallel' of function `mr` to false, otherwise an exception might be thrown.\n"
    },
    "til": {
        "url": "https://docs.dolphindb.com/en/Functions/t/til.html",
        "signatures": [
            {
                "full": "til(n)",
                "name": "til",
                "parameters": [
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [til](https://docs.dolphindb.com/en/Functions/t/til.html)\n\n\n\n#### Syntax\n\ntil(n)\n\n#### Arguments\n\n**n** is a non-negative integer.\n\n#### Details\n\nReturn a vector of integral type from 0 to n-1. If n=0, return an empty vector.\n\nThe result is of the same data type as n. For example, if n is of LONG type, return a FAST LONG VECTOR.\n\n#### Examples\n\n```\ntil(0);\n// output\n[]\n\ntil(5);\n// output\n[0,1,2,3,4]\n\nn = 10;\nt = table(2022.01.01 + til(n) as date, rand(10.0, n) as val);\nt;\n// output\ndate        val\n2022.01.01  8.403\n2022.01.02  9.424\n2022.01.03  0.4779\n2022.01.04  1.8934\n2022.01.05  9.6637\n2022.01.06  1.7993\n2022.01.07  7.1143\n2022.01.08  8.3044\n2022.01.09  2.6919\n2022.01.10  1.9294\n```\n\nRelated functions: [take](https://docs.dolphindb.com/en/Functions/t/take.html), [rand](https://docs.dolphindb.com/en/Functions/r/rand.html)\n"
    },
    "time": {
        "url": "https://docs.dolphindb.com/en/Functions/t/time.html",
        "signatures": [
            {
                "full": "time(X)",
                "name": "time",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [time](https://docs.dolphindb.com/en/Functions/t/time.html)\n\n\n\n#### Syntax\n\ntime(X)\n\n#### Arguments\n\n**X** is a temporal scalar/vector.\n\n#### Details\n\nReturn the corresponding time(s) with millisecond precision. The data type of the result is TIME.\n\n#### Examples\n\n```\ntime();\n// output\n00t\n\ntime(\"12:32:56.356\");\n// output\n12:32:56.356\n\ntime(now());\n// output\n20:49:12.564\n```\n"
    },
    "timestamp": {
        "url": "https://docs.dolphindb.com/en/Functions/t/timestamp.html",
        "signatures": [
            {
                "full": "timestamp(X)",
                "name": "timestamp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [timestamp](https://docs.dolphindb.com/en/Functions/t/timestamp.html)\n\n\n\n#### Syntax\n\ntimestamp(X)\n\n#### Arguments\n\n**X** is a temporal scalar/vector.\n\n#### Details\n\nReturn the corresponding timestamp(s). The data type of the result is TIMESTAMP.\n\nSince version 2.00.12, converting MONTH into TIMESTAMP is allowed.\n\n#### Examples\n\n```\ntimestamp(2016.10.12);\n// output: 2016.10.12T00:00:00.000\n\ntimestamp(2016.10.12)+1;\n// output: 2016.10.12T00:00:00.001\n\ntimestamp(now());\n// output: 2016.10.13T20:28:45.104\n\ntimestamp(2012.01M)\n// output: 2012.01.01T00:00:00.000\n```\n"
    },
    "tmavg": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmavg.html",
        "signatures": [
            {
                "full": "tmavg(T, X, window)",
                "name": "tmavg",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmavg](https://docs.dolphindb.com/en/Functions/t/tmavg.html)\n\n\n\n#### Syntax\n\ntmavg(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving average of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 2 -1 2 4\nm = table(T as t,X as x)\nselect *, tmavg(t, x, 3) from m\n```\n\n| t | x  | tmavg\\_t |\n| - | -- | -------- |\n| 1 | 1  | 1        |\n| 1 | 4  | 2.5      |\n| 1 | 2  | 2.3333   |\n| 2 | -1 | 1.5      |\n| 5 | 2  | 2        |\n| 6 | 4  | 3        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = 1 4 2 -1 2 4\nm = table(T as t,X as x)\nselect *, tmavg(t, x, 3d) from m\n```\n\n| t          | x  | tmavg\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 | 1  | 1        |\n| 2021.01.02 | 4  | 2.5      |\n| 2021.01.04 | 2  | 2.3333   |\n| 2021.01.05 | -1 | 0.5      |\n| 2021.01.07 | 2  | 0.5      |\n| 2021.01.08 | 4  | 3        |\n\n```\nselect *, tmavg(t, x, 1w) from m\n```\n\n| t          | x  | tmavg\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 | 1  | 1        |\n| 2021.01.02 | 4  | 2.5      |\n| 2021.01.04 | 2  | 2.3333   |\n| 2021.01.05 | -1 | 1.5      |\n| 2021.01.07 | 2  | 1.6      |\n| 2021.01.08 | 4  | 2        |\n\nRelated functions: [mavg](https://docs.dolphindb.com/en/Functions/m/mavg.html), [avg](https://docs.dolphindb.com/en/Functions/a/avg.html)\n"
    },
    "tmavgTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmavgTopN.html",
        "signatures": [
            {
                "full": "tmavgTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmavgTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmavgTopN](https://docs.dolphindb.com/en/Functions/t/tmavgTopN.html)\n\n\n\n#### Syntax\n\ntmavgTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the average of the first *top* elements.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X do not participate in calculation\ntmavgTopN(T,X,S,6,4)\n// output\n[2,1.5,2.3333,2.3333,2.75,3.25,3]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmavgTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n| 8      |\n| 3      |\n| 2      |\n| 2      |\n| 2.6666 |\n| 3      |\n\nRelated function: [tmavg](https://docs.dolphindb.com/en/Functions/t/tmavg.html)\n"
    },
    "tmbeta": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmbeta.html",
        "signatures": [
            {
                "full": "tmbeta(T, Y, X, window)",
                "name": "tmbeta",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmbeta](https://docs.dolphindb.com/en/Functions/t/tmbeta.html)\n\n\n\n#### Syntax\n\ntmbeta(T, Y, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the coefficient estimate of an ordinary-least-squares regression of *Y* on *X* in a sliding window.\n\n#### Details\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmbeta(t, y, x, 3) from m\n```\n\n| t | x  | y  | tmbeta\\_t |\n| - | -- | -- | --------- |\n| 1 | 1  | 2  |           |\n| 1 | 4  | 5  | 1         |\n| 1 | 2  | -3 | 1.4286    |\n| 2 | -1 | 6  | -0.3846   |\n| 5 | 2  | 9  |           |\n| 6 | 4  | 1  | -4        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmbeta(t, y, x, 3d) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 1         |\n| 2021.01.04 | 2  | -3 | 1.4286    |\n| 2021.01.05 | -1 | 6  | -3        |\n| 2021.01.07 | 2  | 9  | 1         |\n| 2021.01.08 | 4  | 1  | -4        |\n\n```\nselect *, tmbeta(t, y, x, 1w) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 1         |\n| 2021.01.04 | 2  | -3 | 1.4286    |\n| 2021.01.05 | -1 | 6  | -0.3846   |\n| 2021.01.07 | 2  | 9  | -0.1818   |\n| 2021.01.08 | 4  | 1  | -0.4444   |\n\nRelated Functions: [mbeta](https://docs.dolphindb.com/en/Functions/m/mbeta.html), [beta](https://docs.dolphindb.com/en/Functions/b/beta.html)\n"
    },
    "tmbetaTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmbetaTopN.html",
        "signatures": [
            {
                "full": "tmbetaTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmbetaTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmbetaTopN](https://docs.dolphindb.com/en/Functions/t/tmbetaTopN.html)\n\n\n\n#### Syntax\n\ntmbetaTopN(T, X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the coefficient estimate ordinary-least-squares regressions of *Y* on *X*.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nY=[1, 7, 8, 9, 0, 5, 8]\nS = [5, 8, 1, , 1, 1, 3]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X and Y do not participate in calculation\ntmbetaTopN(T,X,Y,S,6,4)\n// output\n[,-0.1666,0.1279,0.1279,-0.06,0.0853,-0.1871]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nY=1 7 8 9 0 5\nS=1 5 2 3 1 1\nt=table(T as time, X as val1, Y as val2, S as id)\nselect tmbetaTopN(time,val1,val2,id,4,3) as topN from t\n```\n\n| topN    |\n| ------- |\n|         |\n|         |\n| -2      |\n| -0.5    |\n| -0.3972 |\n| -0.3442 |\n\nRelated function: [tmbeta](https://docs.dolphindb.com/en/Functions/t/tmbeta.html)\n"
    },
    "tmcorr": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmcorr.html",
        "signatures": [
            {
                "full": "tmcorr(T, X, Y, window)",
                "name": "tmcorr",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmcorr](https://docs.dolphindb.com/en/Functions/t/tmcorr.html)\n\n\n\n#### Syntax\n\ntmcorr(T, X, Y, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the correlation of *X* and *Y* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmcorr(t, y, x, 3) from m\n```\n\n| t | x  | y  | tmcorr\\_t |\n| - | -- | -- | --------- |\n| 1 | 1  | 2  |           |\n| 1 | 4  | 5  | 1         |\n| 1 | 2  | -3 | 0.5399    |\n| 2 | -1 | 6  | -0.1981   |\n| 5 | 2  | 9  |           |\n| 6 | 4  | 1  | -1        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmcorr(t, y, x, 3d) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 1         |\n| 2021.01.04 | 2  | -3 | 0.5399    |\n| 2021.01.05 | -1 | 6  | -1        |\n| 2021.01.07 | 2  | 9  | 1         |\n| 2021.01.08 | 4  | 1  | -1        |\n\n```\nselect *, tmcorr(t, y, x, 1w) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 1         |\n| 2021.01.04 | 2  | -3 | 0.5399    |\n| 2021.01.05 | -1 | 6  | -0.1981   |\n| 2021.01.07 | 2  | 9  | -0.0726   |\n| 2021.01.08 | 4  | 1  | -0.1995   |\n\nRelated Functions: [mcorr](https://docs.dolphindb.com/en/Functions/m/mcorr.html), [corr](https://docs.dolphindb.com/en/Functions/c/corr.html)\n"
    },
    "tmcorrTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmcorrTopN.html",
        "signatures": [
            {
                "full": "tmcorrTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmcorrTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmcorrTopN](https://docs.dolphindb.com/en/Functions/t/tmcorrTopN.html)\n\n\n\n#### Syntax\n\ntmcorrTopN(T, X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the moving correlation of the first *top* pairs of elements in *X* and *Y*.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nY=[1, 7, 8, 9, 0, 5, 8]\nS = [5, 8, 1, , 1, 1, 3]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X and Y do not participate in calculation\ntmcorrTopN(T,X,Y,S,6,4)\n// output\n[,-1,0.317,0.317,-0.16329,0.3296,-0.4995]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nY=1 7 8 9 0 5\nS=1 5 2 3 1 1\nt=table(T as time, X as val1, Y as val2, S as id)\nselect tmcorrTopN(time,val1,val2,id,4,3) as topN from t\n```\n\n| topN    |\n| ------- |\n|         |\n|         |\n| -1      |\n| -0.5    |\n| -0.9413 |\n| -0.8962 |\n\nRelated function: [tmcorr](https://docs.dolphindb.com/en/Functions/t/tmcorr.html)\n"
    },
    "tmcount": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmcount.html",
        "signatures": [
            {
                "full": "tmcount(T, X, window)",
                "name": "tmcount",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmcount](https://docs.dolphindb.com/en/Functions/t/tmcount.html)\n\n\n\n#### Syntax\n\ntmcount(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nReturn the number of non-NULL values of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmcount(t, x, 3) from m\n```\n\n| t | x  | tmcount\\_t |\n| - | -- | ---------- |\n| 1 | 1  | 1          |\n| 1 | 4  | 2          |\n| 1 |    | 2          |\n| 2 | -1 | 3          |\n| 5 |    | 0          |\n| 6 | 4  | 1          |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.09\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmcount(t, x, 3d) from m\n```\n\n| t          | x  | tmcount\\_t |\n| ---------- | -- | ---------- |\n| 2021.01.02 |    | 0          |\n| 2021.01.02 | 4  | 1          |\n| 2021.01.04 |    | 1          |\n| 2021.01.05 | -1 | 1          |\n| 2021.01.07 | 2  | 2          |\n| 2021.01.09 | 4  | 2          |\n\n```\nselect *, tmcount(t, x, 1w) from m\n```\n\n| t          | x  | tmcount\\_t |\n| ---------- | -- | ---------- |\n| 2021.01.02 |    | 0          |\n| 2021.01.02 | 4  | 1          |\n| 2021.01.04 |    | 1          |\n| 2021.01.05 | -1 | 2          |\n| 2021.01.07 | 2  | 3          |\n| 2021.01.09 | 4  | 3          |\n\nRelated Functions: [mcount](https://docs.dolphindb.com/en/Functions/m/mcount.html), [count](https://docs.dolphindb.com/en/Functions/c/count.html)\n"
    },
    "tmcovar": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmcovar.html",
        "signatures": [
            {
                "full": "tmcovar(T, X, Y, window)",
                "name": "tmcovar",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmcovar](https://docs.dolphindb.com/en/Functions/t/tmcovar.html)\n\n\n\n#### Syntax\n\ntmcovar(T, X, Y, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving covariance of *X* and *Y* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmcovar(t, y, x, 3) from m\n```\n\n| t | x  | y  | tmbeta\\_t |\n| - | -- | -- | --------- |\n| 1 | 1  | 2  |           |\n| 1 | 4  | 5  | 4.5       |\n| 1 | 2  | -3 | 3.3333    |\n| 2 | -1 | 6  | -1.6667   |\n| 5 | 2  | 9  |           |\n| 6 | 4  | 1  | -8        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmcovar(t, y, x, 3d) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 4.5       |\n| 2021.01.04 | 2  | -3 | 3.3333    |\n| 2021.01.05 | -1 | 6  | -13.5     |\n| 2021.01.07 | 2  | 9  | 4.5       |\n| 2021.01.08 | 4  | 1  | -8        |\n\n```\nselect *, tmcovar(t, y, x, 1w) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 4.5       |\n| 2021.01.04 | 2  | -3 | 3.3333    |\n| 2021.01.05 | -1 | 6  | -1.6667   |\n| 2021.01.07 | 2  | 9  | -0.6      |\n| 2021.01.08 | 4  | 1  | -1.6      |\n\nRelated Functions: [mcovar](https://docs.dolphindb.com/en/Functions/m/mcovar.html), [covar](https://docs.dolphindb.com/en/Functions/c/covar.html)\n"
    },
    "tmcovarTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmcovarTopN.html",
        "signatures": [
            {
                "full": "tmcovarTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmcovarTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmcovarTopN](https://docs.dolphindb.com/en/Functions/t/tmcovarTopN.html)\n\n\n\n#### Syntax\n\ntmcovarTopN(T, X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the moving covariance of the first *top* pairs of elements in *X* and *Y*.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nY=[1, 7, 8, 9, 0, 5, 8]\nS = [5, 8, 1, , 1, 1, 3]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X and Y do not participate in calculation\ntmcovarTopN(T,X,Y,S,6,4)\n// output\n[,-3,1.8333,1.8333,-1,1.1666,-2.6666]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nY=1 7 8 9 0 5\nS=1 5 2 3 1 1\nt=table(T as time, X as val1, Y as val2, S as id)\nselect tmcovarTopN(time,val1,val2,id,4,3) as topN from t\n```\n\n| topN    |\n| ------- |\n|         |\n|         |\n| -1      |\n| -0.5    |\n| -9.6666 |\n| -7      |\n\nRelated function: [tmcovar](https://docs.dolphindb.com/en/Functions/t/tmcovar.html)\n"
    },
    "tmfirst": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmfirst.html",
        "signatures": [
            {
                "full": "tmfirst(T, X, window)",
                "name": "tmfirst",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmfirst](https://docs.dolphindb.com/en/Functions/t/tmfirst.html)\n\n\n\n#### Syntax\n\ntmfirst(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nReturn the first element of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmfirst(t, x, 3) from m\n```\n\n| t | x  | tmfirst\\_t |\n| - | -- | ---------- |\n| 1 | 1  | 1          |\n| 1 | 4  | 1          |\n| 1 |    | 1          |\n| 2 | -1 | 1          |\n| 5 |    |            |\n| 6 | 4  |            |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = 3 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmfirst(t, x, 3d) from m\n```\n\n| t          | x  | tmfirst\\_t |\n| ---------- | -- | ---------- |\n| 2021.01.02 | 3  | 3          |\n| 2021.01.02 | 4  | 3          |\n| 2021.01.04 |    | 3          |\n| 2021.01.05 | -1 |            |\n| 2021.01.07 | 2  | -1         |\n| 2021.01.08 | 4  | 2          |\n\n```\nselect *, tmfirst(t, x, 1w) from m\n```\n\n| t          | x  | tmfirst\\_t |\n| ---------- | -- | ---------- |\n| 2021.01.02 | 3  | 3          |\n| 2021.01.02 | 4  | 3          |\n| 2021.01.04 |    | 3          |\n| 2021.01.05 | -1 | 3          |\n| 2021.01.07 | 2  | 3          |\n| 2021.01.08 | 4  | 3          |\n\nRelated functions: [first](https://docs.dolphindb.com/en/Functions/f/first.html)\n"
    },
    "tmkurtosis": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmkurtosis.html",
        "signatures": [
            {
                "full": "tmkurtosis(T, X, window, [biased=true])",
                "name": "tmkurtosis",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [tmkurtosis](https://docs.dolphindb.com/en/Functions/t/tmkurtosis.html)\n\n\n\n#### Syntax\n\ntmkurtosis(T, X, window, \\[biased=true])\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the common parameters and windowing logic.\n\n#### Parameters\n\n**biased** (optional) is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\n#### Details\n\nCalculate the moving kurtosis of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t, X as x)\nselect *, tmkurtosis(t, x, 3) from m\n```\n\n| t | x  | tmkurtosis\\_t |\n| - | -- | ------------- |\n| 1 | 1  |               |\n| 1 | 4  |               |\n| 1 |    |               |\n| 2 | -1 | 1.5           |\n| 5 |    |               |\n| 6 | 4  |               |\n\n```\nT = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\nX = 1 NULL 3 4 5 NULL 3 NULL 5 3\nm = table(T as t,X as x)\nselect *, tmkurtosis(t, x, 3d) from m\n```\n\n| t             | x | tmkurtosis\\_t |\n| ------------- | - | ------------- |\n| 2019.06.13T13 | 1 |               |\n| 2019.06.13T13 |   |               |\n| 2019.06.13T13 | 3 |               |\n| 2019.06.13T13 | 4 | 1.5           |\n| 2019.06.13T14 | 5 | 1.8457        |\n| 2019.06.13T15 |   | 1.8457        |\n| 2019.06.13T16 | 3 | 2.2169        |\n| 2019.06.13T17 |   | 2.2169        |\n| 2019.06.13T18 | 5 | 2.2401        |\n| 2019.06.13T19 | 3 | 2.4072        |\n\n```\nselect *, tmkurtosis(t, x, 1w) from m\n```\n\n| t             | x | tmkurtosis\\_t |\n| ------------- | - | ------------- |\n| 2019.06.13T13 | 1 |               |\n| 2019.06.13T13 |   |               |\n| 2019.06.13T13 | 3 |               |\n| 2019.06.13T13 | 4 | 1.5           |\n| 2019.06.13T14 | 5 | 1.8457        |\n| 2019.06.13T15 |   | 1.8457        |\n| 2019.06.13T16 | 3 | 2.2169        |\n| 2019.06.13T17 |   | 2.2169        |\n| 2019.06.13T18 | 5 | 2.2401        |\n| 2019.06.13T19 | 3 | 2.4072        |\n\nRelated Functions: [mkurtosis](https://docs.dolphindb.com/en/Functions/m/mkurtosis.html), [kurtosis](https://docs.dolphindb.com/en/Functions/k/kurtosis.html)\n"
    },
    "tmkurtosisTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmkurtosisTopN.html",
        "signatures": [
            {
                "full": "tmkurtosisTopN(T, X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "tmkurtosisTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmkurtosisTopN](https://docs.dolphindb.com/en/Functions/t/tmkurtosisTopN.html)\n\n\n\n#### Syntax\n\ntmkurtosisTopN(T, X, S, window, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\n#### Arguments\n\n**biased** (optional) is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the moving kurtosis of the first *top* elements.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\nT=2023.01.03+1..10\nX = [2, 1, 4, 3, 4, 3, 1, 5, 8, 2]\nS = [5, 8, 1, , 1, 1, 3, 2, 5 ,1]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X do not participate in calculation\ntmkurtosisTopN(T,X,S,6,4)\n// output\n[,,1.5,1.5,1.2798,1.628,2,2,1.8457,1.64]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12 2023.01.13 2023.01.14 2023.01.15 2023.01.16\nX=8 3 1 2 5 2 5 4 2 6\nS=1 5 2 3 1 1 2 4 5 3\nt=table(T as time, X as val, S as id)\nselect tmkurtosisTopN(time,val,id,6,4) as topN from t\n```\n\n| topN   |\n| ------ |\n|        |\n|        |\n| 1.5    |\n| 1.5    |\n| 1.8457 |\n| 2.1852 |\n| 1.1522 |\n| 1      |\n| 1      |\n| 2.1852 |\n\nRelated function: [tmkurtosis](https://docs.dolphindb.com/en/Functions/t/tmkurtosis.html)\n"
    },
    "tmlast": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmlast.html",
        "signatures": [
            {
                "full": "tmlast(T, X, window)",
                "name": "tmlast",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmlast](https://docs.dolphindb.com/en/Functions/t/tmlast.html)\n\n\n\n#### Syntax\n\ntmlast(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nReturn the last element of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmlast(t, x, 3) from m\n```\n\n| t | x  | tmlast\\_t |\n| - | -- | --------- |\n| 1 | 1  | 1         |\n| 1 | 4  | 4         |\n| 1 |    |           |\n| 2 | -1 | -1        |\n| 5 |    |           |\n| 6 | 4  | 4         |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmlast(t, x, 3d) from m\n```\n\n| t          | x  | tmlast\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 4         |\n| 2021.01.04 |    |           |\n| 2021.01.05 | -1 | -1        |\n| 2021.01.07 | 2  | 2         |\n| 2021.01.08 | 4  | 4         |\n\n```\nselect *, tmlast(t, x, 1w) from m\n```\n\n| t          | x  | tmlast\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 4         |\n| 2021.01.04 |    |           |\n| 2021.01.05 | -1 | -1        |\n| 2021.01.07 | 2  | 2         |\n| 2021.01.08 | 4  | 4         |\n\nRelated functions: [last](https://docs.dolphindb.com/en/Functions/l/last.html)\n"
    },
    "tmLowRange": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmLowRange.html",
        "signatures": [
            {
                "full": "tmLowRange(T, X, window)",
                "name": "tmLowRange",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmLowRange](https://docs.dolphindb.com/en/Functions/t/tmLowRange.html)\n\n#### Syntax\n\ntmLowRange(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nFor each element *Xi* in a sliding window of *X*, count the continuous nearest neighbors to its left that are larger than *Xi*. NULLs are treated as the minimum values.\n\nIf *X* is a matrix, conduct the aforementioned calculation within each column of *X*.\n\n#### Examples\n\n```\nt = [0, 1, 2, 3, 7, 8, 9, 10, 11]\nx = [NULL, 3.1, NULL, 3.0, 2.9, 2.8, 3.1, NULL, 3.2]\ntmLowRange(t, x, window=3)\n// output: [,0,1,0,0,1,0,2,0]\n\ntmLowRange(t, x, window=4)\n// output: [,0,1,0,0,1,0,3,0]\n\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\ntmLowRange(index, data, 4h)\n// output: [0,1,0,0,0,3,0,1,0,1]\n```\n\n"
    },
    "tmmax": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmmax.html",
        "signatures": [
            {
                "full": "tmmax(T, X, window)",
                "name": "tmmax",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmmax](https://docs.dolphindb.com/en/Functions/t/tmmax.html)\n\n\n\n#### Syntax\n\ntmmax(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving maximum of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmmax(t, x, 3) from m\n```\n\n| t | x  | tmmax\\_t |\n| - | -- | -------- |\n| 1 | 1  | 1        |\n| 1 | 4  | 4        |\n| 1 |    | 4        |\n| 2 | -1 | 4        |\n| 5 |    |          |\n| 6 | 4  | 4        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmmax(t, x, 3d) from m\n```\n\n| t          | x  | tmmax\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | -1       |\n| 2021.01.07 | 2  | 2        |\n| 2021.01.08 | 4  | 4        |\n\n```\nselect *, tmmax(t, x, 1w) from m\n```\n\n| t          | x  | tmmax\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | 4        |\n| 2021.01.07 | 2  | 4        |\n| 2021.01.08 | 4  | 4        |\n\nRelated functions: [mmax](https://docs.dolphindb.com/en/Functions/m/mmax.html), [max](https://docs.dolphindb.com/en/Functions/m/max.html)\n"
    },
    "tmmed": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmmed.html",
        "signatures": [
            {
                "full": "tmmed(T, X, window)",
                "name": "tmmed",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmmed](https://docs.dolphindb.com/en/Functions/t/tmmed.html)\n\n\n\n#### Syntax\n\ntmmed(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving median of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmmed(t, x, 3) from m\n```\n\n| t | x  | tmmed\\_t |\n| - | -- | -------- |\n| 1 | 1  | 1        |\n| 1 | 4  | 2.5      |\n| 1 |    | 2.5      |\n| 2 | -1 | 1        |\n| 5 |    |          |\n| 6 | 4  | 4        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmmed(t, x, 3d) from m\n```\n\n| t          | x  | tmmed\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | -1       |\n| 2021.01.07 | 2  | 0.5      |\n| 2021.01.08 | 4  | 3        |\n\n```\nselect *, tmmed(t, x, 1w) from m\n```\n\n| t          | x  | tmmed\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | 1.5      |\n| 2021.01.07 | 2  | 2        |\n| 2021.01.08 | 4  | 3        |\n\nRelated functions: [mmed](https://docs.dolphindb.com/en/Functions/m/mmed.html), [med](https://docs.dolphindb.com/en/Functions/m/med.html)\n"
    },
    "tmmin": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmmin.html",
        "signatures": [
            {
                "full": "tmmin(T, X, window)",
                "name": "tmmin",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmmin](https://docs.dolphindb.com/en/Functions/t/tmmin.html)\n\n\n\n#### Syntax\n\ntmmin(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving minimum of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmmin(t, x, 3) from m\n```\n\n| t | x  | tmmin\\_t |\n| - | -- | -------- |\n| 1 | 1  | 1        |\n| 1 | 4  | 1        |\n| 1 |    | 1        |\n| 2 | -1 | -1       |\n| 5 |    |          |\n| 6 | 4  | 4        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmmin(t, x, 3d) from m\n```\n\n| t          | x  | tmmin\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | -1       |\n| 2021.01.07 | 2  | -1       |\n| 2021.01.08 | 4  | 2        |\n\n```\nselect *, tmmin(t, x, 1w) from m\n```\n\n| t          | x  | tmmin\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | -1       |\n| 2021.01.07 | 2  | -1       |\n| 2021.01.08 | 4  | -1       |\n\nRelated functions: [mmin](https://docs.dolphindb.com/en/Functions/m/mmin.html), [min](https://docs.dolphindb.com/en/Functions/m/min.html)\n"
    },
    "tmove": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmove.html",
        "signatures": [
            {
                "full": "tmove(T, X, window)",
                "name": "tmove",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmove](https://docs.dolphindb.com/en/Functions/t/tmove.html)\n\n\n\n#### Syntax\n\ntmove(T, X, window)\n\n#### Arguments\n\n**T** is a non-strictly increasing vector of temporal or integral type. It cannot contain NULL values.\n\n**X** is a vector with the same length as *T*.\n\n**window** is a positive integer or DURATION type.\n\n#### Details\n\nFor each element *T i* in *T*, return the element in *X* which is at the same position as (*T i-window*) in *T*. If there is no match of (*T i - window*) in *T*, return the corresponding element in *X* at the previous adjacent time of (*Ti - window*).\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmove(t, x, 3) from m\n```\n\n| t | x  | tmove\\_t |\n| - | -- | -------- |\n| 1 | 1  |          |\n| 1 | 4  |          |\n| 1 |    |          |\n| 2 | -1 |          |\n| 5 |    | -1       |\n| 6 | 4  | -1       |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.09\nX = 5 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmove(t, x, 3d) from m\n```\n\n| t          | x  | tmove\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 | 5  |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 | 4        |\n| 2021.01.07 | 2  |          |\n| 2021.01.09 | 4  | -1       |\n\n```\nselect *, tmove(t, x, 1w) from m\n```\n\n| t          | x  | tmove\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 | 5  |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 |          |\n| 2021.01.07 | 2  |          |\n| 2021.01.09 | 4  | 4        |\n\nRelated function: [move](https://docs.dolphindb.com/en/Functions/m/move.html)\n"
    },
    "tmovingWindowData": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmovingWindowData.html",
        "signatures": [
            {
                "full": "tmovingWindowData(T, X, window, [leftClosed=false])",
                "name": "tmovingWindowData",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[leftClosed=false]",
                        "name": "leftClosed",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [tmovingWindowData](https://docs.dolphindb.com/en/Functions/t/tmovingWindowData.html)\n\n#### Syntax\n\ntmovingWindowData(T, X, window, \\[leftClosed=false])\n\n#### Arguments\n\n**T** is a non-strictly increasing vector of integral or temporal type.\n\n**X** is a vector of the same size as *T*.\n\n**window** is a positive integer or a DURATION value indicating the size of a time-based window.\n\n**leftClosed** (optional) is a Boolean indicating whether the left boundary of window is included. The default value is false.\n\n#### Details\n\nReturn an array vector where each row indicates the elements of a window sliding over *X*.\n\n#### Examples\n\n```\nT = 2022.01.01T09:00:00 + 1 1 2 3 6 7 9 10 13 14\nS = 1..10\ntmovingWindowData(T, S, 3s)\n// output\n[[1],[1,2],[1,2,3],[1,2,3,4],[5],[5,6],[6,7],[7,8],[9],[9,10]]\n\ntmovingWindowData(T, S, 3s, leftClosed=true)\n// output\n[[1],[1,2],[1,2,3],[1,2,3,4],[4,5],[5,6],[5,6,7],[6,7,8],[8,9],[9,10]]\n\n// output the calculation result of metrics with a 10-minute sliding window in the reactive state engine\nn = 100\nDateTime = 2023.01.01T09:00:00 + rand(10000, n).sort!()\nSecurityID = take(`600021`600022`600023`600024`600025, n)\nPrice = 1.0 + rand(1.0, n) \nt = table(1:0, `DateTime`SecurityID`Price, [TIMESTAMP, SYMBOL, DOUBLE])\ntableInsert(t, DateTime, SecurityID, Price)\noutput = table(100:0, `SecurityID`DateTime`PriceNew, [SYMBOL, DATETIME, DOUBLE[]])\n\nengine = createReactiveStateEngine(name=\"rseEngine\", metrics=[<DateTime>, <tmovingWindowData(DateTime, Price,10m)>], dummyTable=t, outputTable=output, keyColumn=`SecurityID, keepOrder=true)\nengine.append!(t)\ndropStreamEngine(`rseEngine)\n```\n\n"
    },
    "tmpercentile": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmpercentile.html",
        "signatures": [
            {
                "full": "tmpercentile(T, X, percent, window, [interpolation='linear'])",
                "name": "tmpercentile",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "percent",
                        "name": "percent"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    }
                ]
            }
        ],
        "markdown": "### [tmpercentile](https://docs.dolphindb.com/en/Functions/t/tmpercentile.html)\n\n\n\n#### Syntax\n\ntmpercentile(T, X, percent, window, \\[interpolation='linear'])\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the common parameters and windowing logic.\n\n#### Parameters\n\n**percent** is an integer or floating number between 0 and 100.\n\n**interpolation** (optional) is a string indicating the interpolation method to use if the specified percentile is between two elements in *X* (assuming the i-th and (i+1)-th element in the sorted *X*) . It can take the following values:\n\n* 'linear': ![](https://docs.dolphindb.com/en/images/tmlinear.png) where ![](https://docs.dolphindb.com/en/images/tmfraction.png)\n\n* 'lower': ![](https://docs.dolphindb.com/en/images/xi.png)\n\n* 'higher': ![](https://docs.dolphindb.com/en/images/higher.png)\n\n* 'nearest': ![](https://docs.dolphindb.com/en/images/xi.png) or ![](https://docs.dolphindb.com/en/images/higher.png) that is closest to the specified percentile\n\n* 'midpoint': ![](https://docs.dolphindb.com/en/images/midpoint.png)\n\nThe default value of *interpolation* is 'linear'.\n\n#### Details\n\nReturn the percentile rank of each element of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmpercentile(t, x, 50, 3) from m\n```\n\n| t | x  | tmpercentile\\_t |\n| - | -- | --------------- |\n| 1 | 1  | 1               |\n| 1 | 4  | 2.5             |\n| 1 |    | 2.5             |\n| 2 | -1 | 1               |\n| 5 |    |                 |\n| 6 | 4  | 4               |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmpercentile(t, x, 50, 3d) from m\n```\n\n| t          | x  | tmpercentile\\_t |\n| ---------- | -- | --------------- |\n| 2021.01.02 |    |                 |\n| 2021.01.02 | 4  | 4               |\n| 2021.01.04 |    | 4               |\n| 2021.01.05 | -1 | -1              |\n| 2021.01.07 | 2  | 0.5             |\n| 2021.01.08 | 4  | 3               |\n\n```\nselect *, tmpercentile(t, x, 50, 1w) from m\n```\n\n| t          | x  | tmpercentile\\_t |\n| ---------- | -- | --------------- |\n| 2021.01.02 |    |                 |\n| 2021.01.02 | 4  | 4               |\n| 2021.01.04 |    | 4               |\n| 2021.01.05 | -1 | 1.5             |\n| 2021.01.07 | 2  | 2               |\n| 2021.01.08 | 4  | 3               |\n\nRelated Functions: [percentile](https://docs.dolphindb.com/en/Functions/p/percentile.html), [mpercentile](https://docs.dolphindb.com/en/Functions/m/mpercentile.html)\n"
    },
    "tmprod": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmprod.html",
        "signatures": [
            {
                "full": "tmprod(T, X, window)",
                "name": "tmprod",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmprod](https://docs.dolphindb.com/en/Functions/t/tmprod.html)\n\n\n\n#### Syntax\n\ntmprod(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving product of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 3 5 8 15 15 20\nX = 5 2 4 1 2 8 9 10\nm=table(T as t, X as x)\nselect *, tmprod(t, x, 3) from m\n```\n\n| t  | x  | tmprod\\_t |\n| -- | -- | --------- |\n| 1  | 5  | 5         |\n| 1  | 2  | 10        |\n| 3  | 4  | 40        |\n| 5  | 1  | 4         |\n| 8  | 2  | 2         |\n| 15 | 8  | 8         |\n| 15 | 9  | 72        |\n| 20 | 10 | 10        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmprod(t, x, 3d) from m\n```\n\n| t          | x  | tmprod\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 4         |\n| 2021.01.04 |    | 4         |\n| 2021.01.05 | -1 | -1        |\n| 2021.01.07 | 2  | -2        |\n| 2021.01.08 | 4  | 8         |\n\n```\nselect *, tmprod(t, x, 1w) from m\n```\n\n| t          | x  | tmprod\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 4         |\n| 2021.01.04 |    | 4         |\n| 2021.01.05 | -1 | -1        |\n| 2021.01.07 | 2  | -2        |\n| 2021.01.08 | 4  | 8         |\n\nRelated functions: [mprod](https://docs.dolphindb.com/en/Functions/m/mprod.html), [prod](https://docs.dolphindb.com/en/Functions/p/prod.html)\n"
    },
    "tmrank": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmrank.html",
        "signatures": [
            {
                "full": "tmrank(T, X, ascending, window, [ignoreNA=true], [tiesMethod='min'], [percent=false])",
                "name": "tmrank",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "ascending",
                        "name": "ascending"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='min']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'min'"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [tmrank](https://docs.dolphindb.com/en/Functions/t/tmrank.html)\n\n\n\n#### Syntax\n\ntmrank(T, X, ascending, window, \\[ignoreNA=true], \\[tiesMethod='min'], \\[percent=false])\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the common parameters and windowing logic.\n\n#### Arguments\n\n**ascending** is a Boolean value. The default value is true indicating the sorting direction is ascending.\n\n**ignoreNA** (optional) is a Boolean value indicating whether NULL values are ignored in ranking. The default value is true. If NULL values participate in the ranking, they are ranked the lowest.\n\n**tiesMethod** (optional) is a string indicating how to rank the group of records with the same value (i.e., ties):\n\n* \"min\": lowest rank of the group\n\n* \"max\": highest rank of the group\n\n* \"average\": average rank of the group\n\n**percent** is a Boolean value, indicating whether to display the returned rankings in percentile form. The default value is false.\n\n#### Details\n\nReturn the rank of each element of *X* in a sliding window.\n\n#### Examples\n\n```\ntmrank(1 1 3 5 8 15 15 20, 5 2 4 1 2 8 9 10, ascending=true, window=3)\n// output\n[0,0,1,0,0,0,1,0]\n\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.14 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\n\ntmrank(index, data, ascending=true, window=4h)\n// output\n[0,,1,2,0,,0,,1,0]\n\ntmrank(index, data, ascending=true, window=2d)\n// output\n[0,,1,2,3,,1,,4,1]\n```\n\nRelated functions: [mrank](https://docs.dolphindb.com/en/Functions/m/mrank.html), [rank](https://docs.dolphindb.com/en/Functions/r/rank.html)\n"
    },
    "tmskew": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmskew.html",
        "signatures": [
            {
                "full": "tmskew(T, X, window, [biased=true])",
                "name": "tmskew",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [tmskew](https://docs.dolphindb.com/en/Functions/t/tmskew.html)\n\n\n\n#### Syntax\n\ntmskew(T, X, window, \\[biased=true])\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the common parameters and windowing logic.\n\n#### Parameters\n\n**biased** (optional) is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\n#### Details\n\nCalculate the moving skewness of *X* in a sliding window.\n\n#### Examples\n\n```\ntmskew(1 1 3 5 8 15 15 20, 5 2 4 1 2 8 9 10, 3)\n// output\n[,0,-0.381801774160607,0,,,0,]\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\ntmskew(index, data, 4h)\n// output\n[,,,-0.3818,,,0,0,0,0.7071]\ntmskew(index, data, 2d)\n// output\n[,,0,-0.3818,-0.4347,-0.4347,-0.37,-0.37,-0.5653,-0.4363]\n```\n\nRelated Functions: [mskew](https://docs.dolphindb.com/en/Functions/m/mskew.html), [skew](https://docs.dolphindb.com/en/Functions/s/skew.html)\n"
    },
    "tmskewTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmskewTopN.html",
        "signatures": [
            {
                "full": "tmskewTopN(T, X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "tmskewTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmskewTopN](https://docs.dolphindb.com/en/Functions/t/tmskewTopN.html)\n\n\n\n#### Syntax\n\ntmskewTopN(T, X, S, window, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\n#### Arguments\n\n**biased** (optional) is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the moving skewness of the first *top* elements.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X do not participate in calculation\ntmskewTopN(T,X,S,6,4)\n// output\n[,0,0.3818,0.3818,-0.2138,-0.4933,-0.8164]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmskewTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n|        |\n|        |\n| 0      |\n| 0      |\n| 0.5280 |\n| 0.7071 |\n\nRelated function: [tmskew](https://docs.dolphindb.com/en/Functions/t/tmskew.html)\n"
    },
    "tmstd": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmstd.html",
        "signatures": [
            {
                "full": "tmstd(T, X, window)",
                "name": "tmstd",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmstd](https://docs.dolphindb.com/en/Functions/t/tmstd.html)\n\n\n\n#### Syntax\n\ntmstd(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the standard deviation of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 3 5 8 15 15 20\nX = 5 2 4 1 2 8 9 10\nm=table(T as t, X as x)\nselect *, tmstd(t, x, 3) from m\n```\n\n| t  | x  | tmstd\\_t |\n| -- | -- | -------- |\n| 1  | 5  |          |\n| 1  | 2  | 2.1213   |\n| 3  | 4  | 1.5275   |\n| 5  | 1  | 2.1213   |\n| 8  | 2  |          |\n| 15 | 8  |          |\n| 15 | 9  | 0.7071   |\n| 20 | 10 |          |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmstd(t, x, 3d) from m\n```\n\n| t          | x  | tmstd\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 |          |\n| 2021.01.07 | 2  | 2.1213   |\n| 2021.01.08 | 4  | 1.4142   |\n\n```\nselect *, tmstd(t, x, 1w) from m\n```\n\n| t          | x  | tmstd\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 | 3.5355   |\n| 2021.01.07 | 2  | 2.5166   |\n| 2021.01.08 | 4  | 2.3629   |\n\nRelated Functions: [mstd](https://docs.dolphindb.com/en/Functions/m/mstd.html), [std](https://docs.dolphindb.com/en/Functions/s/std.html)\n"
    },
    "tmstdp": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmstdp.html",
        "signatures": [
            {
                "full": "tmstdp(T, X, window)",
                "name": "tmstdp",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmstdp](https://docs.dolphindb.com/en/Functions/t/tmstdp.html)\n\n\n\n#### Syntax\n\ntmstdp(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the population standard deviation of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 3 5 8 15 15 20\nX = 5 2 4 1 2 8 9 10\nm=table(T as t, X as x)\nselect *, tmstdp(t, x, 3) from m\n```\n\n| t  | x  | tmstdp\\_t |\n| -- | -- | --------- |\n| 1  | 5  | 0         |\n| 1  | 2  | 1.5       |\n| 3  | 4  | 1.2472    |\n| 5  | 1  | 1.5       |\n| 8  | 2  | 0         |\n| 15 | 8  | 0         |\n| 15 | 9  | 0.5       |\n| 20 | 10 | 0         |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmstdp(t, x, 3d) from m\n```\n\n| t          | x  | tmstdp\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 0         |\n| 2021.01.04 |    | 0         |\n| 2021.01.05 | -1 | 0         |\n| 2021.01.07 | 2  | 1.5       |\n| 2021.01.08 | 4  | 1         |\n\n```\nselect *, tmstdp(t, x, 1w) from m\n```\n\n| t          | x  | tmstdp\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 0         |\n| 2021.01.04 |    | 0         |\n| 2021.01.05 | -1 | 2.5       |\n| 2021.01.07 | 2  | 2.0548    |\n| 2021.01.08 | 4  | 2.0463    |\n\nRelated Functions: [mstdp](https://docs.dolphindb.com/en/Functions/m/mstdp.html), [stdp](https://docs.dolphindb.com/en/Functions/s/stdp.html)\n"
    },
    "tmstdpTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmstdpTopN.html",
        "signatures": [
            {
                "full": "tmstdpTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmstdpTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmstdpTopN](https://docs.dolphindb.com/en/Functions/t/tmstdpTopN.html)\n\n\n\n#### Syntax\n\ntmstdpTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the population standard deviation of the first *top* elements.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X do not participate in calculation\ntmstdpTopN(T,X,S,6,4)\n// output\n[0,0.5,1.2472,1.2472,1.299,0.8291,1.2247]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmstdpTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n| 0      |\n| 0      |\n| 1      |\n| 0.8164 |\n| 1.6996 |\n| 1.4142 |\n\nRelated function: [tmstdp](https://docs.dolphindb.com/en/Functions/t/tmstdp.html)\n"
    },
    "tmstdTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmstdTopN.html",
        "signatures": [
            {
                "full": "tmstdTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmstdTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmstdTopN](https://docs.dolphindb.com/en/Functions/t/tmstdTopN.html)\n\n\n\n#### Syntax\n\ntmstdTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the unbiased sample standard deviation of the first *top* elements.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X do not participate in calculation\ntmstdTopN(T,X,S,6,4)\n// output\n[,0.7071,1.5275,1.5275,1.5,0.9574,1.4142]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmstdTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n|        |\n|        |\n| 1.4142 |\n| 1      |\n| 2.0816 |\n| 1.732  |\n\nRelated function: [tmstd](https://docs.dolphindb.com/en/Functions/t/tmstd.html)\n"
    },
    "tmsum": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmsum.html",
        "signatures": [
            {
                "full": "tmsum(T, X, window)",
                "name": "tmsum",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmsum](https://docs.dolphindb.com/en/Functions/t/tmsum.html)\n\n\n\n#### Syntax\n\ntmsum(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving sum of *X* in a sliding window.\n\n#### Examples\n\n```\ntmsum(1 1 3 5 8 15 15 20, 5 2 4 1 2 8 9 10, 3)\n// output\n[5,7,11,5,2,8,17,10]\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\ntmsum(index, data, 4h)\n// output\n[1,1,4,8,13,13,16,8,8,11]\ntmsum(index, data, 1d)\n// output\n[1,1,4,8,13,13,16,16,21,24]\n```\n\nRelated functions: [msum](https://docs.dolphindb.com/en/Functions/m/msum.html), [sum](https://docs.dolphindb.com/en/Functions/s/sum.html)\n"
    },
    "tmsum2": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmsum2.html",
        "signatures": [
            {
                "full": "tmsum2(T, X, window)",
                "name": "tmsum2",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmsum2](https://docs.dolphindb.com/en/Functions/t/tmsum2.html)\n\n\n\n#### Syntax\n\ntmsum2(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving sum of squares of all elements of *X* in a sliding window.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\ntmsum2(1 1 3 5 8 15 15 20, 5 2 4 1 2 8 9 10, 3)\n// output\n[25,29,45,17,4,64,145,100]\n\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\ntmsum2(index, data, 4h)\n// output\n[1,1,10,26,51,51,60,34,34,43]\n\ntmsum2(index, data, 1d)\n// output\n[1,1,10,26,51,51,60,60,85,94]\n```\n\nRelated Functions: [sum2](https://docs.dolphindb.com/en/Functions/s/sum2.html)\n"
    },
    "tmsumTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmsumTopN.html",
        "signatures": [
            {
                "full": "tmsumTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmsumTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmsumTopN](https://docs.dolphindb.com/en/Functions/t/tmsumTopN.html)\n\n\n\n#### Syntax\n\ntmsumTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* by *S* in the order specified by *ascending*, then sums up the first *top* elements.\n\n**Return value**:\n\n* If *X* is an integer, a vector of LONG type is returned.\n\n* If *X* is a floating-point number, a vector of DOUBLE type is returned.\n\n#### Examples\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X do not participate in calculation\ntmsumTopN(T,X,S,6,4)\n// output\n[2,3,7,7,11,13,12]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmsumTopN(time,val,id,4,3) as topN from t\n```\n\n| topN |\n| ---- |\n| 8    |\n| 3    |\n| 4    |\n| 6    |\n| 8    |\n| 9    |\n\nRelated function: [tmsum](https://docs.dolphindb.com/en/Functions/t/tmsum.html)\n"
    },
    "tmTopRange": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmTopRange.html",
        "signatures": [
            {
                "full": "tmTopRange(T, X, window)",
                "name": "tmTopRange",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmTopRange](https://docs.dolphindb.com/en/Functions/t/tmTopRange.html)\n\n#### Syntax\n\ntmTopRange(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nFor each element *Xi* in a sliding window of *X*, count the continuous nearest neighbors to its left that are smaller than *Xi*. NULLs are treated as the minimum values.\n\n#### Examples\n\n```\nt = [0, 1, 2, 3, 7, 8, 9, 10, 11]\nx = [NULL, 3.1, NULL, 3.0, 2.9, 2.8, 3.1, NULL, 3.2];\ntmTopRange(t, x, window=3);\n//output: [,1,0,1,0,0,2,0,2]\n\ntmTopRange(t, x, window=4);\n// output: [,1,0,1,0,0,2,0,3]\n\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\ntmTopRange(index, data, 4h)\n// output: [0,0,2,3,4,0,1,0,3,0]\n```\n\n"
    },
    "tmvar": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmvar.html",
        "signatures": [
            {
                "full": "tmvar(T, X, window)",
                "name": "tmvar",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmvar](https://docs.dolphindb.com/en/Functions/t/tmvar.html)\n\n\n\n#### Syntax\n\ntmvar(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving variance of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 3 5 8 15 15 20\nX = 5 2 4 1 2 8 9 10\nm=table(T as t, X as x)\nselect *, tmvar(t, x, 3) from m\n```\n\n| t  | x  | tmvar\\_t |\n| -- | -- | -------- |\n| 1  | 5  |          |\n| 1  | 2  | 4.5      |\n| 3  | 4  | 2.3333   |\n| 5  | 1  | 4.5      |\n| 8  | 2  |          |\n| 15 | 8  |          |\n| 15 | 9  | 0.5      |\n| 20 | 10 |          |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmvar(t, x, 3d) from m\n```\n\n| t          | x  | tmvar\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 |          |\n| 2021.01.07 | 2  | 4.5      |\n| 2021.01.08 | 4  | 2        |\n\n```\nselect *, tmvar(t, x, 1w) from m\n```\n\n| t          | x  | tmvar\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 | 12.5     |\n| 2021.01.07 | 2  | 6.333    |\n| 2021.01.08 | 4  | 5.5833   |\n\nRelated Functions: [mvar](https://docs.dolphindb.com/en/Functions/m/mvar.html), [var](https://docs.dolphindb.com/en/Functions/v/var.html)\n"
    },
    "tmvarp": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmvarp.html",
        "signatures": [
            {
                "full": "tmvarp(T, X, window)",
                "name": "tmvarp",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmvarp](https://docs.dolphindb.com/en/Functions/t/tmvarp.html)\n\n\n\n#### Syntax\n\ntmvarp(T, X, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving population variance of *X* in a sliding window.\n\n#### Examples\n\n```\nT = 1 1 3 5 8 15 15 20\nX = 5 2 4 1 2 8 9 10\nm=table(T as t, X as x)\nselect *, tmvarp(t, x, 3) from m\n```\n\n| t  | x  | tmvarp\\_t |\n| -- | -- | --------- |\n| 1  | 5  | 0         |\n| 1  | 2  | 2.25      |\n| 3  | 4  | 1.5556    |\n| 5  | 1  | 2.25      |\n| 8  | 2  | 0         |\n| 15 | 8  | 0         |\n| 15 | 9  | 0.25      |\n| 20 | 10 | 0         |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmvarp(t, x, 3d) from m\n```\n\n| t          | x  | tmvarp\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 0         |\n| 2021.01.04 |    | 0         |\n| 2021.01.05 | -1 | 0         |\n| 2021.01.07 | 2  | 2.25      |\n| 2021.01.08 | 4  | 1         |\n\n```\nselect *, tmvarp(t, x, 1w) from m\n```\n\n| t          | x  | tmvarp\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 0         |\n| 2021.01.04 |    | 0         |\n| 2021.01.05 | -1 | 6.25      |\n| 2021.01.07 | 2  | 4.2222    |\n| 2021.01.08 | 4  | 4.1875    |\n\nRelated Functions: [mvarp](https://docs.dolphindb.com/en/Functions/m/mvarp.html), [varp](https://docs.dolphindb.com/en/Functions/v/varp.html)\n"
    },
    "tmvarpTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmvarpTopN.html",
        "signatures": [
            {
                "full": "tmvarTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmvarTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmvarpTopN](https://docs.dolphindb.com/en/Functions/t/tmvarpTopN.html)\n\n\n\n#### Syntax\n\ntmvarTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the population variance of the first *top* elements.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X do not participate in calculation\ntmvarpTopN(T,X,S,6,4)\n// output\n[0,0.25,1.5555,1.5555,1.6875,0.6875,1.5]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmvarpTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n| 0      |\n| 0      |\n| 1      |\n| 0.6666 |\n| 2.8888 |\n| 2      |\n\nRelated function: [tmvarp](https://docs.dolphindb.com/en/Functions/t/tmvarp.html)\n"
    },
    "tmvarTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmvarTopN.html",
        "signatures": [
            {
                "full": "tmvarTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmvarTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmvarTopN](https://docs.dolphindb.com/en/Functions/t/tmvarTopN.html)\n\n\n\n#### Syntax\n\ntmvarTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* by *S* in the order specified by *ascending*, then calculates the unbiased sample variance of the first *top* elements.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X do not participate in calculation\ntmvarTopN(T,X,S,6,4)\n// output\n[,0.5,2.3333,2.3333,2.25,0.9166,2]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmvarTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n|        |\n|        |\n| 2      |\n| 1      |\n| 4.3333 |\n| 3      |\n\nRelated function: [tmvar](https://docs.dolphindb.com/en/Functions/t/tmvar.html)\n"
    },
    "tmwavg": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmwavg.html",
        "signatures": [
            {
                "full": "tmwavg(T, X, Y, window)",
                "name": "tmwavg",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmwavg](https://docs.dolphindb.com/en/Functions/t/tmwavg.html)\n\n\n\n#### Syntax\n\ntmwavg(T, X, Y, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving average of *X* with *Y* as weights in a sliding window.\n\nThe weights in a sliding window are automatically adjusted so that the sum of weights for all non-Null elements in the sliding window is 1.\n\n#### Examples\n\n```\nT= 1 1 1 1 2 5 6 8 9 10\nX = 1..10\nY = double(1..10)\\10\nm = table(T as t,X as x, Y as y)\nselect *, tmwavg(t, x, y, 3) from m\n```\n\n| t  | x  | y   | tmwavg\\_t |\n| -- | -- | --- | --------- |\n| 1  | 1  | 0.1 | 1         |\n| 1  | 2  | 0.2 | 1.6667    |\n| 1  | 3  | 0.3 | 2.3333    |\n| 1  | 4  | 0.4 | 3         |\n| 2  | 5  | 0.5 | 3.6667    |\n| 5  | 6  | 0.6 | 6         |\n| 6  | 7  | 0.7 | 6.5385    |\n| 8  | 8  | 0.8 | 7.5333    |\n| 9  | 9  | 0.9 | 8.5294    |\n| 10 | 10 | 1   | 9.0741    |\n\n```\nT = 2021.01.02 2021.01.06 join 2021.01.07..2021.01.14\nX = 1..10\nY = double(1..10)\\10\nm=table(T as t,X as x, Y as y)\nselect *, tmwavg(t, y, x, 3) from m\n```\n\n| t          | x  | y   | tmwavg\\_t |\n| ---------- | -- | --- | --------- |\n| 2021.01.02 | 1  | 0.1 | 0.1       |\n| 2021.01.06 | 2  | 0.2 | 0.2       |\n| 2021.01.07 | 3  | 0.3 | 0.26      |\n| 2021.01.08 | 4  | 0.4 | 0.3222    |\n| 2021.01.09 | 5  | 0.5 | 0.4167    |\n| 2021.01.10 | 6  | 0.6 | 0.5133    |\n| 2021.01.11 | 7  | 0.7 | 0.6111    |\n| 2021.01.12 | 8  | 0.8 | 0.7095    |\n| 2021.01.13 | 9  | 0.9 | 0.8083    |\n| 2021.01.14 | 10 | 1   | 0.9074    |\n\n```\nselect *, tmwavg(t, y, x, 1w) from m\n```\n\n| t          | x  | y   | tmwavg\\_t |\n| ---------- | -- | --- | --------- |\n| 2021.01.02 | 1  | 0.1 | 0.1       |\n| 2021.01.06 | 2  | 0.2 | 0.1667    |\n| 2021.01.07 | 3  | 0.3 | 0.2333    |\n| 2021.01.08 | 4  | 0.4 | 0.3       |\n| 2021.01.09 | 5  | 0.5 | 0.3857    |\n| 2021.01.10 | 6  | 0.6 | 0.45      |\n| 2021.01.11 | 7  | 0.7 | 0.5148    |\n| 2021.01.12 | 8  | 0.8 | 0.58      |\n| 2021.01.13 | 9  | 0.9 | 0.6667    |\n| 2021.01.14 | 10 | 1   | 0.7571    |\n\nRelated functions: [wavg](https://docs.dolphindb.com/en/Functions/w/wavg.html), [mwavg](https://docs.dolphindb.com/en/Functions/m/mwavg.html)\n"
    },
    "tmwsum": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmwsum.html",
        "signatures": [
            {
                "full": "tmwsum(T, X, Y, window)",
                "name": "tmwsum",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmwsum](https://docs.dolphindb.com/en/Functions/t/tmwsum.html)\n\n\n\n#### Syntax\n\ntmwsum(T, X, Y, window)\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the moving sum of *X* with *Y* as weights in a sliding window.\n\nThe weights in a sliding window are automatically adjusted so that the sum of weights for all non-NULL elements in the sliding window is 1.\n\n#### Example\n\n```\nT = 1 1 1 1 2 5 6 8 9 10\nX = 1..10\nY = double(1..10)\\10\nm = table(T as t,X as x, Y as y)\nselect *, tmwsum(t, y, x, 3) from m\n```\n\n| t  | x  | y   | tmwsum\\_t |\n| -- | -- | --- | --------- |\n| 1  | 1  | 0.1 | 0.1       |\n| 1  | 2  | 0.2 | 0.5       |\n| 1  | 3  | 0.3 | 1.4       |\n| 1  | 4  | 0.4 | 3         |\n| 2  | 5  | 0.5 | 5.5       |\n| 5  | 6  | 0.6 | 3.6       |\n| 6  | 7  | 0.7 | 8.5       |\n| 8  | 8  | 0.8 | 11.3      |\n| 9  | 9  | 0.9 | 14.5      |\n| 10 | 10 | 1   | 24.5      |\n\n```\nT = 2021.01.02 2021.01.06 join 2021.01.07..2021.01.14\nX = 1..10\nY = double(1..10)\\10\nm=table(T as t,X as x, Y as y)\nselect *, tmwsum(t, y, x, 3) from m\n```\n\n| t          | x  | y   | tmwsum\\_t |\n| ---------- | -- | --- | --------- |\n| 2021.01.02 | 1  | 0.1 | 0.1       |\n| 2021.01.06 | 2  | 0.2 | 0.4       |\n| 2021.01.07 | 3  | 0.3 | 1.3       |\n| 2021.01.08 | 4  | 0.4 | 2.9       |\n| 2021.01.09 | 5  | 0.5 | 5         |\n| 2021.01.10 | 6  | 0.6 | 7.7       |\n| 2021.01.11 | 7  | 0.7 | 11        |\n| 2021.01.12 | 8  | 0.8 | 14.9      |\n| 2021.01.13 | 9  | 0.9 | 19.4      |\n| 2021.01.14 | 10 | 1   | 24.5      |\n\n```\nselect *, tmwsum(t, y, x, 1w) from m\n```\n\n| t          | x  | y   | tmwsum\\_t |\n| ---------- | -- | --- | --------- |\n| 2021.01.02 | 1  | 0.1 | 0.1       |\n| 2021.01.06 | 2  | 0.2 | 0.5       |\n| 2021.01.07 | 3  | 0.3 | 1.4       |\n| 2021.01.08 | 4  | 0.4 | 3         |\n| 2021.01.09 | 5  | 0.5 | 5.4       |\n| 2021.01.10 | 6  | 0.6 | 9         |\n| 2021.01.11 | 7  | 0.7 | 13.9      |\n| 2021.01.12 | 8  | 0.8 | 20.3      |\n| 2021.01.13 | 9  | 0.9 | 28        |\n| 2021.01.14 | 10 | 1   | 37.1      |\n\nRelated functions: [wsum](https://docs.dolphindb.com/en/Functions/w/wsum.html), [mwsum](https://docs.dolphindb.com/en/Functions/m/mwsum.html)\n"
    },
    "tmwsumTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tmwsumTopN.html",
        "signatures": [
            {
                "full": "tmwsumTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmwsumTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmwsumTopN](https://docs.dolphindb.com/en/Functions/t/tmwsumTopN.html)\n\n\n\n#### Syntax\n\ntmwsumTopN(T, X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\nPlease see [tmTopN](https://docs.dolphindb.com/en/Functions/Themes/tmTopN.html) for the parameters and windowing logic.\n\n#### Details\n\nWithin a sliding window of given length (measured by time), the function stably sorts *X* and *Y* by *S* in the order specified by *ascending*, then calculates the moving sums of *X* with *Y* as weights.\n\n**Return value**: a vector of DOUBLE type\n\n#### Examples\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nY=[1, 7, 8, 9, 0, 5, 8]\nS = [5, 8, 1, , 1, 1, 3]\n// The NULL values in S are ignored in data sorting, and the corresponding elements in X and Y do not participate in calculation\ntmwsumTopN(T,X,Y,S,6,4)\n// output\n[2,9,41,41,41,49,55]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nY=1 7 8 9 0 5\nS=1 5 2 3 1 1\nt=table(T as time, X as val1, Y as val2, S as id)\nselect tmwsumTopN(time,val1,val2,id,4,3) as topN from t\n```\n\n| topN |\n| ---- |\n| 8    |\n| 21   |\n| 29   |\n| 47   |\n| 26   |\n| 28   |\n\nRelated function: [tmwsum](https://docs.dolphindb.com/en/Functions/t/tmwsum.html)\n"
    },
    "toCharArray": {
        "url": "https://docs.dolphindb.com/en/Functions/t/toCharArray.html",
        "signatures": [
            {
                "full": "toCharArray(X)",
                "name": "toCharArray",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [toCharArray](https://docs.dolphindb.com/en/Functions/t/toCharArray.html)\n\n\n\n#### Syntax\n\ntoCharArray(X)\n\n#### Arguments\n\n**X** a scalar/vector of the STRING/BLOB/SYMBOL data type.\n\n#### Details\n\nSplit a string into a vector of the CHAR data type.\n\n* If *X* is a scalar, return a vector.\n\n* If *X* is a vector, return an array vector.\n\n#### Examples\n\n```\nstr = \"It is great!\\n\"\nprint str.toCharArray()\n// output\n['I','t',' ','i','s',' ','g','r','e','a','t','!',10]\n\nstr1 = [\"A#\", \"B C\", \"D\\t\"]\nprint str1.toCharArray()\n// output\n[['A','#'],['B',' ','C'],['D',9]]\n```\n\n```\n//Compress a vector and save it in a binary file\nx=1..100\n//A string of BLOB type uses the first 4 bytes to identify its length\ny=blob(compress(x).concat())\ndir = WORK_DIR+\"/toCharArray.bin\"\ng = file(dir, \"w\")\n//Use toCharArray to convert a string of BLOB type, only the correct data will be written to the file (except for the header)\ng.write(y.toCharArray())   //467 bytes were written\ng.close()\n\n// output\ndir1 = WORK_DIR+\"/toCharArray1.bin\"\ng1 = file(dir1, \"w\")\ng1.write(y)    //471 bytes were written\ng1.close()\n```\n\nRelated Functions: [split](https://docs.dolphindb.com/en/Functions/s/split.html)\n"
    },
    "today": {
        "url": "https://docs.dolphindb.com/en/Functions/t/today.html",
        "signatures": [
            {
                "full": "today()",
                "name": "today",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [today](https://docs.dolphindb.com/en/Functions/t/today.html)\n\n\n\n#### Syntax\n\ntoday()\n\n#### Arguments\n\nNone\n\n#### Details\n\nReturn the current date.\n\n#### Examples\n\n```\ntoday();\n// output\n2019.03.30\n```\n"
    },
    "toJson": {
        "url": "https://docs.dolphindb.com/en/Functions/t/toJson.html",
        "signatures": [
            {
                "full": "toJson(X)",
                "name": "toJson",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [toJson](https://docs.dolphindb.com/en/Functions/t/toJson.html)\n\n\n\n#### Syntax\n\ntoJson(X)\n\n#### Arguments\n\n**X** can be any data type.\n\n#### Details\n\nConvert a DolphinDB object to JSON format. The result includes 5 key-value pairs: name, form, type, size and value.\n\nFor different data forms, the maximum length of the data to be converted differs:\n\n| Data Forms | Max Length |\n| ---------- | ---------- |\n| matrix     | 300000     |\n| set        | 300000     |\n| vector     | 300000     |\n| dict       | 300000     |\n| table      | 100000     |\n\n#### Examples\n\n```\nx=1 2 3\ny=toJson(x)\ny;\n// output\n{\"name\":\"x\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[1,2,3]}\n\nt=table(1 2 3 as id, 10 20 30 as val)\ntoJson(t);\n// output\n{\"name\":\"t\",\"form\":\"table\",\"size\":\"3\",\"value\":[{\"name\":\"id\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[1,2,3]},{\"name\":\"val\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[10,20,30]}]}\n\n// The length of set exceeds 30000, and toJson can only convert the first 30000 elements\nx=set(1..400001)\ny=toJson(x)\nsize(fromJson(y))\n// output\n300000\n```\n\nRelated function: [fromJson](https://docs.dolphindb.com/en/Functions/f/fromJson.html)\n"
    },
    "topRange": {
        "url": "https://docs.dolphindb.com/en/Functions/t/topRange.html",
        "signatures": [
            {
                "full": "topRange(X)",
                "name": "topRange",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [topRange](https://docs.dolphindb.com/en/Functions/t/topRange.html)\n\n\n\n#### Syntax\n\ntopRange(X)\n\n#### Arguments\n\n**X** is a vector/tuple/matrix/table\n\n#### Details\n\nFor each element *Xi* in *X*, count the continuous nearest neighbors to its left that are smaller than *Xi*.\n\nFor each element in X, the function return the maximum length of a window to the left of *X* where it is the max/min. For example, after how many days a stock hits a new high.\n\n#### Examples\n\n```\ntopRange([13.5, 13.6, 13.4, 13.3, 13.5, 13.9, 13.1, 20.1, 20.2, 20.3])\n// output\n[0,1,0,0,2,5,0,7,8,9]\n\nm = matrix(1.5 2.6 3.2 1.4 2.5 2.2 3.7 2.0, 1.6 2.3 4.2 5.6 4.1 3.2 4.4 6.9)\ntopRange(m)\n```\n\n| #0 | #1 |\n| -- | -- |\n| 0  | 0  |\n| 1  | 1  |\n| 2  | 2  |\n| 0  | 3  |\n| 1  | 0  |\n| 0  | 0  |\n| 6  | 2  |\n| 0  | 7  |\n\n```\n//Simulate the stock price of stock A for 8 days. Use topRange to calculate after how many days the stock hit a new high\ntrades = table(take(`A, 8) as sym,  2022.01.01 + 1..8 as date, 39.70 39.72 39.80 39.78 39.83 39.92 40.00 40.03 as price)\nselect *, topRange(price) from trades\n```\n\n| id | date       | price | topRange\\_price |\n| -- | ---------- | ----- | --------------- |\n| A  | 2022.01.02 | 39.7  | 0               |\n| A  | 2022.01.03 | 39.72 | 1               |\n| A  | 2022.01.04 | 39.8  | 2               |\n| A  | 2022.01.05 | 39.78 | 0               |\n| A  | 2022.01.06 | 39.83 | 4               |\n| A  | 2022.01.07 | 39.92 | 5               |\n| A  | 2022.01.08 | 40    | 6               |\n| A  | 2022.01.09 | 40.03 | 7               |\n\nRelated function: [lowRange](https://docs.dolphindb.com/en/Functions/l/lowRange.html)\n"
    },
    "toStdJson": {
        "url": "https://docs.dolphindb.com/en/Functions/t/toStdJson.html",
        "signatures": [
            {
                "full": "toStdJson(obj)",
                "name": "toStdJson",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    }
                ]
            }
        ],
        "markdown": "### [toStdJson](https://docs.dolphindb.com/en/Functions/t/toStdJson.html)\n\n\n\n#### Syntax\n\ntoStdJson(obj)\n\n#### Arguments\n\n**obj** cannot be of data form matrix or pair, nor can it be of data type UUID, IPADDR, INT128, COMPRESSED, or system types.\n\n#### Details\n\nConvert a DolphinDB object to JSON format.\n\n#### Examples\n\n```\nx=1 2 3\ntoStdJson(x);\n// output\n[1, 2, 3]\n\nt=table(1 2 3 as id, 10 20 30 as val)\ntoStdJson(t);\n// output\n[{\"id\": 1,\"val\": 10},{\"id\": 2,\"val\": 20},{\"id\": 3,\"val\": 30}]\n\nb = set(2012.06.13T13:30:10 2017.07.10T14:10:12)\ntoStdJson(b);\n// output\n[\"2017.07.10 14:10:12\",\"2012.06.13 13:30:10\"]\n\nb = dict(int,datetime)\nb[0] = 2012.06.13 13:30:10\nb[1] = 2017.07.10 14:10:12\ntoStdJson(b);\n// output\n{\"1\": \"2017.07.10 14:10:12\",\"0\": \"2012.06.13 13:30:10\"}\n\nt1=table(`x`y`z as b, 2012.06.13 13:30:10 2012.06.13 13:30:10 2012.06.13 13:30:10 as c,10.8 7.6 3.5 as F)\ntoStdJson(t1);\n// output\n[{\"b\": \"x\",\"c\": \"2012.06.13 13:30:10\",\"F\": 10.8},{\"b\": \"y\",\"c\": \"2012.06.13 13:30:10\",\"F\": 7.6},{\"b\": \"z\",\"c\": \"2012.06.13 13:30:10\",\"F\": 3.5}]\n```\n\nRelated function: [toJson](https://docs.dolphindb.com/en/Functions/t/toJson.html)\n"
    },
    "toUTF8": {
        "url": "https://docs.dolphindb.com/en/Functions/t/toUTF8.html",
        "signatures": [
            {
                "full": "toUTF8(str, encode)",
                "name": "toUTF8",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "encode",
                        "name": "encode"
                    }
                ]
            }
        ],
        "markdown": "### [toUTF8](https://docs.dolphindb.com/en/Functions/t/toUTF8.html)\n\n\n\n#### Syntax\n\ntoUTF8(str, encode)\n\n#### Arguments\n\n**str** is a string scalar/vector.\n\n**encode** is a string indicating the original encoding name. It must use lowercase.\n\n#### Details\n\nChange the encoding of strings to UTF-8.\n\nFor the Windows version, encode can only be \"gbk\".\n\n#### Examples\n\n```\ntoUTF8(\"DolphinDB\",\"gbk\");\n// output\nDolphinDB\n\ntoUTF8([\"hello\",\"world\"],\"euc-cn\");\n// output\n[\"hello\",\"world\"]\n```\n\nRelated functions: [convertEncode](https://docs.dolphindb.com/en/Functions/c/convertEncode.html), [fromUTF8](https://docs.dolphindb.com/en/Functions/f/fromUTF8.html)\n"
    },
    "transDS!": {
        "url": "https://docs.dolphindb.com/en/Functions/t/transDS!.html",
        "signatures": [
            {
                "full": "transDS!(ds, tranFunc)",
                "name": "transDS!",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "tranFunc",
                        "name": "tranFunc"
                    }
                ]
            }
        ],
        "markdown": "### [transDS!](https://docs.dolphindb.com/en/Functions/t/transDS!.html)\n\n\n\n#### Syntax\n\ntransDS!(ds, tranFunc)\n\n#### Arguments\n\n**ds** is a data source or a list of data sources. It is the sole argument of all the functions in *transFunc*.\n\n**tranFunc** is a function to be applied to *ds*.\n\n#### Details\n\nApply data transforming functions to a data source or a list of data sources.\n\n#### Examples\n\nIn the following example, the data type of column *trade\\_time* from the DFS table \"trades1\" is converted into NANOTIMESTAMP and inserted into the DFS table \"trades2\".\n\n```\ndb=database(\"dfs://stock1\",VALUE,`A`B`C`D)\nn=200000\ntrade_time=2018.01.02T06:12:03.458+1..n\nsym=rand(`A`B`C`D,n)\nqty=rand(100.0,n)\nprice=rand(100.0,n)\nt=table(trade_time,sym,qty,price)\ntrades1=db.createPartitionedTable(t,`trades1,`sym).append!(t);\n\nds=sqlDS(<select * from trades1>);\n\ndef convertNanotimestamp(t){\n   return select nanotimestamp(trade_time), sym, qty, price from t\n}\n\nds.transDS!(convertNanotimestamp);\n\ndb=database(\"dfs://stock2\",VALUE,`A`B`C`D)\nt=table(1:0,`trade_time`sym`qty`price,[NANOTIMESTAMP,SYMBOL,DOUBLE,DOUBLE])\ntrades2=db.createPartitionedTable(t,`trades2,`sym);\n\nmr(ds,append!{trades2},,,false);\n\nexec count(*) from trades2;\n// output\n200000\n```\n"
    },
    "transFreq": {
        "url": "https://docs.dolphindb.com/en/Functions/t/transFreq.html",
        "signatures": [
            {
                "full": "transFreq(X, rule, [closed], [label], [origin='start_day'])",
                "name": "transFreq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "rule",
                        "name": "rule"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    },
                    {
                        "full": "[label]",
                        "name": "label",
                        "optional": true
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    }
                ]
            }
        ],
        "markdown": "### [transFreq](https://docs.dolphindb.com/en/Functions/t/transFreq.html)\n\n\n\n#### Syntax\n\ntransFreq(X, rule, \\[closed], \\[label], \\[origin='start\\_day'])\n\n#### Arguments\n\n**X** is a scalar/vector of temporal type.\n\n**rule** is a string that can take the following values:\n\n| Values of parameter \"rule\" | Corresponding DolphinDB function |\n| -------------------------- | -------------------------------- |\n| \"B\"                        | businessDay                      |\n| \"W\"                        | weekEnd                          |\n| \"WOM\"                      | weekOfMonth                      |\n| \"LWOM\"                     | lastWeekOfMonth                  |\n| \"M\"                        | monthEnd                         |\n| \"MS\"                       | monthBegin                       |\n| \"BM\"                       | businessMonthEnd                 |\n| \"BMS\"                      | businessMonthBegin               |\n| \"SM\"                       | semiMonthEnd                     |\n| \"SMS\"                      | semiMonthBegin                   |\n| \"Q\"                        | quarterEnd                       |\n| \"QS\"                       | quarterBegin                     |\n| \"BQ\"                       | businessQuarterEnd               |\n| \"BQS\"                      | businessQuarterBegin             |\n| \"A\"                        | yearEnd                          |\n| \"AS\"                       | yearBegin                        |\n| \"BA\"                       | businessYearEnd                  |\n| \"BAS\"                      | businessYearBegin                |\n| \"D\"                        | date                             |\n| \"H\"                        | hourOfDay                        |\n| \"min\"                      | minuteOfHour                     |\n| \"S\"                        | secondOfMinute                   |\n| \"L\"                        | millisecond                      |\n| \"U\"                        | microsecond                      |\n| \"N\"                        | nanosecond                       |\n\nThe strings above can also be used with positive integers for parameter *rule*. For example, \"2M\" means the end of every two months. In addition, *rule* can also be set as the identifier of the trading calendar, e.g., the Market Identifier Code of an exchange, or a user-defined calendar name. Positive integers can also be used with identifiers. For example, \"2XNYS\" means every two trading days of New York Stock Exchange.\n\n**closed** (optional) is a string indicating which boundary of the interval is closed.\n\n* The default value is 'left' for all values of *rule* except for 'M', 'A', 'Q', 'BM', 'BA', 'BQ', and 'W' which all have a default of 'right'.\n\n* The default is 'right' if *origin* is 'end' or 'end\\_day'.\n\n**label** (optional) is a string indicating which boundary is used to label the interval.\n\n* The default value is 'left' for all values of *rule* except for 'M', 'A', 'Q', 'BM', 'BA', 'BQ', and 'W' which all have a default of 'right'.\n\n* The default is 'right' if *origin* is 'end' or 'end\\_day'.\n\n**origin** (optional) is a string or a scalar of the same data type as *X*, indicating the timestamp where the intervals start. It can be 'epoch', start', 'start\\_day', 'end', 'end\\_day' or a user-defined time object. The default value is 'start\\_day'.\n\n* 'epoch': *origin* is 1970-01-01\n\n* 'start': *origin* is the first value of the timeseries\n\n* 'start\\_day': *origin* is 00:00 of the first day of the timeseries\n\n* 'end': *origin* is the last value of the timeseries\n\n* 'end\\_day': *origin* is 24:00 of the last day of the timeseries\n\n#### Details\n\nFor each element of *X*, conduct a transformation as specified with parameter *rule*. The result has the same length as *X*.\n\n#### Examples\n\n```\ntransFreq(2020.11.08 2020.11.09 2020.11.18, \"SM\");\n// output\n[2020.10.31,2020.10.31,2020.11.15]\n\ntransFreq(2020.08.08 2020.11.18, \"Q\");\n// output\n[2020.09.30,2020.12.31]\n\ntransFreq(2020.08.08 2020.11.18, \"2Q\");\n// output\n[2020.09.30,2021.03.31]\n```\n\n```\ns = temporalAdd(2022.01.01 00:00:00,1..8,`m);\n\ns.transFreq(rule=\"3min\");\n// output\n[2022.01.01T00:00:00,2022.01.01T00:00:00,2022.01.01T00:03:00,2022.01.01T00:03:00,2022.01.01T00:03:00,2022.01.01T00:06:00,2022.01.01T00:06:00,2022.01.01T00:06:00]\n\ns.transFreq(rule=`3min,closed=`right);\n// output\n[2022.01.01T00:00:00,2022.01.01T00:00:00,2022.01.01T00:00:00,2022.01.01T00:03:00,2022.01.01T00:03:00,2022.01.01T00:03:00,2022.01.01T00:06:00,2022.01.01T00:06:00]\n\ns.transFreq(rule=`3min,closed=`right,origin=`end);\n// output\n[2021.12.31T23:59:00,2021.12.31T23:59:00,2022.01.01T00:02:00,2022.01.01T00:02:00,2022.01.01T00:02:00,2022.01.01T00:05:00,2022.01.01T00:05:00,2022.01.01T00:05:00]\n```\n"
    },
    "transpose": {
        "url": "https://docs.dolphindb.com/en/Functions/t/transpose.html",
        "signatures": [
            {
                "full": "transpose(X)",
                "name": "transpose",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [transpose](https://docs.dolphindb.com/en/Functions/t/transpose.html)\n\n\n\n#### Syntax\n\ntranspose(X)\n\nAlias: flip\n\n#### Arguments\n\n**X** is a tuple/matrix/table/dictionary/array vector/columnar tuple. If *X* is an array vector or columnar tuple, the number of elements in each row must be the same.\n\n#### Details\n\n* If *X* is a tuple: all elements of the tuple must have the same length. Return a tuple of the same length as each element of *X*. The n-th element of the result is a vector composed of the n-th element of each element of *X*.\n\n* If *X* is a matrix: return the transpose of *X*.\n\n* If *X* is a table: convert *X* into an ordered dictionary. The dictionary keys are column names. Each dictionary value is a vector of the corresponding column.\n\n* If *X* is a dictionary: convert *X* into a table. The dictionary keys must be of STRING type, and dictionary values can be scalars or vectors of the same length. The column names of the table are the dictionary keys, and each column is the corresponding dictionary value.\n\n* If *X* is an array vector or columnar tuple: switch data from columns to rows, or vice versa.\n\n#### Examples\n\nExample 1: transpose of a tuple:\n\n```\nx=(`A`B`C,1 2 3);\nx.transpose();\n// output: ((\"A\",1),(\"B\",2),(\"C\",3))\n```\n\nExample 2: transpose of a matrix:\n\n```\nx=1..6 $ 3:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ntranspose x;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 2  | 3  |\n| 4  | 5  | 6  |\n\nExample 3: convert a table into a dictionary:\n\n```\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nt = table(timestamp, sym, qty, price);\nt;\n```\n\n| timestamp | sym | qty  | price  |\n| --------- | --- | ---- | ------ |\n| 09:34:07  | C   | 2200 | 49.6   |\n| 09:36:42  | MS  | 1900 | 29.46  |\n| 09:36:51  | MS  | 2100 | 29.52  |\n| 09:36:59  | MS  | 3200 | 30.02  |\n| 09:32:47  | IBM | 6800 | 174.97 |\n| 09:35:26  | IBM | 5400 | 175.23 |\n| 09:34:16  | C   | 1300 | 50.76  |\n| 09:34:26  | C   | 2500 | 50.32  |\n| 09:38:12  | C   | 8800 | 51.29  |\n\n```\ntranspose(t);\n/*\ntimestamp->[09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym->[C,MS,MS,MS,IBM,IBM,C,C,C]\nqty->[2200,1900,2100,3200,6800,5400,1300,2500,8800]\nprice->[49.6,29.46,29.52,30.02,174.97,175.23,50.76,50.32,51.29]\n*/\n```\n\nExample 4: convert a dictionary into a table:\n\n```\nz=dict(`id`val,[`a`b`c,1 2 3]);\nz;\n/*\nval->[1,2,3]\nid->[a,b,c]\n*/\ntranspose(z);\n```\n\n| val | id |\n| --- | -- |\n| 1   | a  |\n| 2   | b  |\n| 3   | c  |\n\n```\n// When the value of a dictionary contains both a scalar and a vector, the scalar will be automatically filled to match the length of the vector.\nz1=dict(`id`val,[`a,1 2 3]);\nz1;\ntranspose(z1)\n```\n\n| val | id |\n| --- | -- |\n| 1   | a  |\n| 2   | a  |\n| 3   | a  |\n"
    },
    "triggerCheckpointForIMOLTP": {
        "url": "https://docs.dolphindb.com/en/Functions/t/triggerCheckpointForIMOLTP.html",
        "signatures": [
            {
                "full": "triggerCheckpointForIMOLTP([force=false], [sync=false])",
                "name": "triggerCheckpointForIMOLTP",
                "parameters": [
                    {
                        "full": "[force=false]",
                        "name": "force",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[sync=false]",
                        "name": "sync",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [triggerCheckpointForIMOLTP](https://docs.dolphindb.com/en/Functions/t/triggerCheckpointForIMOLTP.html)\n\n#### Syntax\n\ntriggerCheckpointForIMOLTP(\\[force=false], \\[sync=false])\n\n#### Arguments\n\n**force** (optional) is a Boolean value that determines whether to force a checkpoint operation. The default value is false.\n\n**sync** (optional) is a Boolean value to determine whether to force a checkpoint to be performed asynchronously. The default value is false.\n\n#### Details\n\nManually trigger a checkpoint operation for IMOLTP databases.\n\n**Note**: Specify the configuration parameter *enableIMOLTPEngine* and*enableIMOLTPCheckpoint* before execution.\n\n"
    },
    "triggerNodeReport": {
        "url": "https://docs.dolphindb.com/en/Functions/t/triggerNodeReport.html",
        "signatures": [
            {
                "full": "triggerNodeReport(nodeAlias)",
                "name": "triggerNodeReport",
                "parameters": [
                    {
                        "full": "nodeAlias",
                        "name": "nodeAlias"
                    }
                ]
            }
        ],
        "markdown": "### [triggerNodeReport](https://docs.dolphindb.com/en/Functions/t/triggerNodeReport.html)\n\n\n\n#### Syntax\n\ntriggerNodeReport(nodeAlias)\n\n#### Arguments\n\n**nodeAlias** is a STRING scalar indicating the node alias.\n\n#### Details\n\nForce the specified data node to report the chunk information to the controller to update the metadata maintained on the controller.\n\n#### When to use this function:\n\nThis command is used to solve the problem when the chunk information is not reported after a data node is restarted.\n\n1. Check whether the node is alive with field \"state\" returned by function `getClusterPerf`;\n\n2. Check the chunk information with fields \"replicas\" and \"replicaCount\" by calling `getClusterChunksStatus`;\n\n3. If the node is alive but the numbers of replicas do not match, you can search the corresponding chunk ID in the log of the controller. Find out the data node that has not reported and call this command on the node to trigger its report.\n\n4. If the command does not take effect, please restart the data node.\n"
    },
    "triggerPKEYCompaction": {
        "url": "https://docs.dolphindb.com/en/Functions/t/triggerPKEYCompaction.html",
        "signatures": [
            {
                "full": "triggerPKEYCompaction(chunkId, [async=true])",
                "name": "triggerPKEYCompaction",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    },
                    {
                        "full": "[async=true]",
                        "name": "async",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [triggerPKEYCompaction](https://docs.dolphindb.com/en/Functions/t/triggerPKEYCompaction.html)\n\n\n\n#### Syntax\n\ntriggerPKEYCompaction(chunkId, \\[async=true])\n\n#### Arguments\n\n**chunkId** is a STRING scalar or vectorindicating the target chunk ID(s).\n\n**async**(optional) is a BOOL scalar determining whether to enable asynchronous compaction.\n\n* If true (default), return immediately after job submission.\n* If false, return after all jobs complete.\n\n#### Details\n\nIn the PKEY engine, use this function to manually trigger the compaction all level files stored at level 0 for optimal reading performance.\n\n#### Examples\n\n```\ntriggerPKEYCompaction(chunkId=\"1486f935-6f87-479c-b341-34c6a303d4f9\", async=false)\n```\n"
    },
    "triggerTSDBCompaction": {
        "url": "https://docs.dolphindb.com/en/Functions/t/triggerTSDBCompaction.html",
        "signatures": [
            {
                "full": "triggerTSDBCompaction(chunkId, [level=0])",
                "name": "triggerTSDBCompaction",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    },
                    {
                        "full": "[level=0]",
                        "name": "level",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [triggerTSDBCompaction](https://docs.dolphindb.com/en/Functions/t/triggerTSDBCompaction.html)\n\n\n\n#### Syntax\n\ntriggerTSDBCompaction(chunkId, \\[level=0])\n\n#### Arguments\n\n**chunkId** is a STRING scalar indicating the chunk ID.\n\n**level** (optional) is an integer in \\[0,3] that specifies at which level the compaction is triggered. The default value is 0, meaning compaction is triggered at level 0.\n\nNote: If *keepDuplicates* of the table is set to ALL, *level* cannot be 3.\n\n#### Details\n\nIn the TSDB engine, use this command to manually trigger the compaction of TSDB level files at specific levelof all level files stored at level 0 for optimal reading performance.\n\n#### Examples\n\nThere are 2 file types in a chunk, the file chunk containing information about the database and table schema, and the tablet chunk storing data. Compaction of level files can only be conducted within a tablet chunk. Set \"type=1\" to filter the IDs of tablet chunks.\n\n```\nchunkIds = exec chunkId from getChunksMeta() where type=1\nfor (x in chunkIds) {\n    triggerTSDBCompaction(x)\n}\n```\n"
    },
    "tril": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tril.html",
        "signatures": [
            {
                "full": "tril(X, [k=0])",
                "name": "tril",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k=0]",
                        "name": "k",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [tril](https://docs.dolphindb.com/en/Functions/t/tril.html)\n\n\n\n#### Syntax\n\ntril(X, \\[k=0])\n\n#### Arguments\n\n**X** is a matrix.\n\n**k** (optional) is an integer.\n\n#### Details\n\nIf *k* is not specified: return the lower triangular portion of matrix *X*.\n\nIf *k* is specified: return the elements on and below the k-th diagonal of *X*.\n\n#### Examples\n\n```\nm=matrix(1 2 3, 4 5 6, 7 8 9);\nm;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 7    |\n| 2    | 5    | 8    |\n| 3    | 6    | 9    |\n\n```\ntril(m);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 0    | 0    |\n| 2    | 5    | 0    |\n| 3    | 6    | 9    |\n\n```\ntril(m,1);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 0    |\n| 2    | 5    | 8    |\n| 3    | 6    | 9    |\n\n```\ntril(m,-1);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 0    | 0    | 0    |\n| 2    | 0    | 0    |\n| 3    | 6    | 0    |\n\nRelated function: [triu](https://docs.dolphindb.com/en/Functions/t/triu.html)\n"
    },
    "trim": {
        "url": "https://docs.dolphindb.com/en/Functions/t/trim.html",
        "signatures": [
            {
                "full": "trim(X)",
                "name": "trim",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [trim](https://docs.dolphindb.com/en/Functions/t/trim.html)\n\n\n\n#### Syntax\n\ntrim(X)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n#### Details\n\nTrim all white spaces around the string.\n\n#### Examples\n\n```\nx=[\"  t1\", \" t2 \"];\ntrim(x);\n// output\n[\"t1\",\"t2\"]\n```\n\nRelated function: [strip](https://docs.dolphindb.com/en/Functions/s/strip.html)\n"
    },
    "trima": {
        "url": "https://docs.dolphindb.com/en/Functions/t/trima.html",
        "signatures": [
            {
                "full": "trima(X, window)",
                "name": "trima",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [trima](https://docs.dolphindb.com/en/Functions/t/trima.html)\n\n\n\n#### Syntax\n\ntrima(X, window)\n\nPlease see [TALib](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the Triangular Moving Average (trima) for *X* in a sliding window of the given length.\n\nThe formula is: ![](https://docs.dolphindb.com/en/images/trima.png)\n\nwhere *w1 = (window + 1)/2* (rounded up); *w2 = (window + 1)/2* (rounded down).\n\n#### Examples\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\ntrima(x,3);\n// output\n[,,12.274999999999998,18.625,18.662500000000001,15.225000000000001,11.59375]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\ntrima(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n| 12.2749 | 15.5000 |\n| 12.5499 | 17.5000 |\n| 12.5249 | 19.2500 |\n| 12.0499 | 18.2500 |\n| 11.5750 | 13.7500 |\n\nRelated functions: [sma](https://docs.dolphindb.com/en/Functions/s/sma.html), [wma](https://docs.dolphindb.com/en/Functions/w/wma.html), [trima](https://docs.dolphindb.com/en/Functions/t/trima.html)\n"
    },
    "triu": {
        "url": "https://docs.dolphindb.com/en/Functions/t/triu.html",
        "signatures": [
            {
                "full": "triu(X, [k=0])",
                "name": "triu",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k=0]",
                        "name": "k",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [triu](https://docs.dolphindb.com/en/Functions/t/triu.html)\n\n\n\n#### Syntax\n\ntriu(X, \\[k=0])\n\n#### Arguments\n\n**X** is a matrix.\n\n**k** (optional) is an integer.\n\n#### Details\n\nIf *k* is not specified: return the upper triangular portion of matrix *X*.\n\nIf *k* is specified: return the elements on and above the k-th diagonal of *X*.\n\n#### Examples\n\n```\nm=matrix(1 2 3, 4 5 6, 7 8 9);\nm;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 7    |\n| 2    | 5    | 8    |\n| 3    | 6    | 9    |\n\n```\ntriu(m);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 7    |\n| 0    | 5    | 8    |\n| 0    | 0    | 9    |\n\n```\ntriu(m,1);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 0    | 4    | 7    |\n| 0    | 0    | 8    |\n| 0    | 0    | 0    |\n\n```\ntriu(m,-1);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 7    |\n| 2    | 5    | 8    |\n| 0    | 6    | 9    |\n\nRelated function: [tril](https://docs.dolphindb.com/en/Functions/t/tril.html)\n"
    },
    "trueRange": {
        "url": "https://docs.dolphindb.com/en/Functions/t/trueRange.html",
        "signatures": [
            {
                "full": "trueRange(high, low, close)",
                "name": "trueRange",
                "parameters": [
                    {
                        "full": "high",
                        "name": "high"
                    },
                    {
                        "full": "low",
                        "name": "low"
                    },
                    {
                        "full": "close",
                        "name": "close"
                    }
                ]
            }
        ],
        "markdown": "### [trueRange](https://docs.dolphindb.com/en/Functions/t/trueRange.html)\n\n\n\n#### Syntax\n\ntrueRange(high, low, close)\n\n#### Arguments\n\nThe 3 parameters are numeric vectors of equal length.\n\nUsually, **high** is the highest price of the current period; **low** is the lowest price of the current period; **close** is the closing price of the current period.\n\n#### Details\n\nReturn a vector of the same length as each of the input vectors.\n\nThe result for each position is the maximum of | *high* - *low* |, | *high* - last period *close* | and | last period *close* - *low* |.\n\n#### Examples\n\n```\nsym=take(`A`B,10)\ndate=2020.01.01 2020.01.01 2020.01.02 2020.01.02 2020.01.03 2020.01.03 2020.01.04 2020.01.04 2020.01.05 2020.01.05\nhigh=[11.48,10.23,12.26,10.7,12.24,10.45,12.3,10.51,12.24,10.49]\nlow=[10.91,9.41,11.18,10,11.71,9.83,11.62,9.91,11.1,9.6]\nclose=[11.38,10.22,12.1,10.31,11.89,10.21,12.13,10.47,11.35,9.81]\nt=table(sym,date,high,low,close)\nselect sym,trueRange(high,low,close) as trange from t context by sym;\n```\n\n| sym | trange |\n| --- | ------ |\n| A   |        |\n| A   | 1.08   |\n| A   | 0.53   |\n| A   | 0.68   |\n| A   | 1.14   |\n| B   |        |\n| B   | 0.7    |\n| B   | 0.62   |\n| B   | 0.6    |\n| B   | 0.89   |\n"
    },
    "truncate": {
        "url": "https://docs.dolphindb.com/en/Functions/t/truncate.html",
        "signatures": [
            {
                "full": "truncate(dbUrl, tableName)",
                "name": "truncate",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [truncate](https://docs.dolphindb.com/en/Functions/t/truncate.html)\n\n\n\n#### Syntax\n\ntruncate(dbUrl, tableName)\n\n#### Arguments\n\n**dbUrl** is a string indicating the DFS path of a database.\n\n**tableName** is a string indicating the table name.\n\n#### Details\n\nRemove all rows from a DFS table but keep its schema. Command `truncate` is faster than the [delete](https://docs.dolphindb.com/en/Programming/SQLStatements/delete.html) statement and the [dropPartition](https://docs.dolphindb.com/en/Functions/d/dropPartition.html) function.\n\nIt is suggested to call function [dropTable](https://docs.dolphindb.com/en/Functions/d/dropTable.html) if you want to delete the schema of the table.\n\n#### Example\n\n```\nn=1000000\nID=rand(150, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID = database(, RANGE, 0 50 100 150)\n\ndbName=\"dfs://compoDB\"\nif(existsDatabase(dbName)){\n\n      dropDatabase(dbName)\n}\ndb = database(dbName, COMPO, [dbDate, dbID])\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n\ntruncate(dbName, `pt)\n```\n"
    },
    "tTest": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tTest.html",
        "signatures": [
            {
                "full": "tTest(X, [Y], [mu=0.0], [confLevel=0.95], [equalVar=false])",
                "name": "tTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    },
                    {
                        "full": "[mu=0.0]",
                        "name": "mu",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[confLevel=0.95]",
                        "name": "confLevel",
                        "optional": true,
                        "default": "0.95"
                    },
                    {
                        "full": "[equalVar=false]",
                        "name": "equalVar",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [tTest](https://docs.dolphindb.com/en/Functions/t/tTest.html)\n\n\n\n#### Syntax\n\ntTest(X, \\[Y], \\[mu=0.0], \\[confLevel=0.95], \\[equalVar=false])\n\n#### Arguments\n\n**X** is a numeric vector indicating the sample for the t-test.\n\n**Y** (optional) is a numeric vector indicating the second sample for a paired-sample t-test.\n\n**mu** (optional) is a floating number. If *Y* is not specified, *mu* is the mean value of *X* in the null hypothesis; if *Y* is specified, *mu* is the difference in the mean values of *X* and *Y* in the null hypothesis.The default value is 0.\n\n**confLevel** (optional) is a floating number between 0 and 1 indicating the confidence level of the test. The default value is 0.95.\n\n**equalVar** (optional) is a Boolean value indicating whether the variance of *X* and *Y* are the same in the null hypothesis. The default value is false.\n\n#### Details\n\nIf *Y* is not specified, conduct a one-sample t-test on *X*. If *Y* is specified, conduct a paired-sample t-test on *X* and *Y*.\n\nReturn a dictionary with the following keys:\n\n* stat: a table with p-value and confidence interval under 3 alternative hypotheses.\n\n* df: degree of freedom\n\n* confLevel: confidence level\n\n* method: type of t-test used\n\n* tValue: t-stat\n\n#### Examples\n\nOne-sample t-test:\n\n```\nx = norm(10.0, 1.0, 20)\ntTest(x, , 10.0);\n\n// output\nstat->\nalternativeHypothesis        pValue   lowerBound upperBound\n---------------------------- -------- ---------- ----------\ntrue mean is not equal to 10 0.499649 9.68582    10.621998\ntrue mean is less than 10    0.750176 -Infinity  10.540616\ntrue mean is greater than 10 0.249824 9.767202   Infinity\n\ndf->19\nconfLevel->0.95\nmethod->One sample t-test\ntValue->0.688192\n```\n\nPaired-sample t-test with equal sample variance:\n\n```\nx = norm(10.0, 1.0, 20)\ny = norm(4.0, 1.0, 10)\ntTest(x, y, 6.0, , true);\n\n// output\nstat->\nalternativeHypothesis                pValue   lowerBound upperBound\n------------------------------------ -------- ---------- ----------\ndifference of mean is not equal to 6 0.438767 5.539812   7.03262\ndifference of mean is less than 6    0.780616 -Infinity  6.906078\ndifference of mean is greater than 6 0.219384 5.666354   Infinity\n\ndf->28\nconfLevel->0.95\nmethod->Two sample t-test\ntValue->0.785483\n```\n\nPaired-sample t-test with no restriction on sample variance:\n\n```\nx = norm(10.0, 1.0, 20)\ny = norm(1.0, 2.0, 10)\ntTest(x, y, 9.0);\n\n// output\nstat->\nalternativeHypothesis          pValue   lowerBound upperBound\n------------------------------ ----------------- ---------- ----------\ntrue difference of mean is n...0.983376 7.752967   10.271656\ntrue difference of mean is l...0.508312 -Infinity  10.04285\ntrue difference of mean is g...0.491688 7.981773   Infinity\n\ndf->12.164434\nconfLevel->0.95\nmethod->Welch two sample t-test\ntValue->0.021269\n```\n"
    },
    "tupleSum": {
        "url": "https://docs.dolphindb.com/en/Functions/t/tupleSum.html",
        "signatures": [
            {
                "full": "tupleSum(X)",
                "name": "tupleSum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [tupleSum](https://docs.dolphindb.com/en/Functions/t/tupleSum.html)\n\n\n\n#### Syntax\n\ntupleSum(X)\n\n#### Arguments\n\n**X** is a tuple.\n\n#### Details\n\nSummarize individual results from multiple *map* calls. If each *map* call returns a tuple with *N* non-tuple objects, the input for `tupleSum` function would be a tuple of *N* tuples. Each child tuple contains *m* objects with identical data form and data type, where *m* is the number of *map* calls. If there is a single *map* call, however, `tupleSum` accepts the results of the *map* call as the input, and simply returns the input as the output.\n\nThe result of the function `tupleSum` always has the same format as the *map* call result. If the *map* call returns a tuple with at least 2 non-tuple objects, then `tupleSum` returns a tuple containing the same number of non-tuple objects.\n\n#### Examples\n\n```\nx = [(1 2, 3 4, 5 6), (0.5, 0.6, 0.7)];\ntupleSum(x);\n// output\n([9,12],1.8)\n```\n\nIf the *map* call return a single non-tuple object, then *tupleSum* also returns a single non-tuple object.\n\n```\nx = [(1 2, 3 4, 5 6)];\ntupleSum(x);\n// output\n[9,12]\n```\n"
    },
    "type": {
        "url": "https://docs.dolphindb.com/en/Functions/t/type.html",
        "signatures": [
            {
                "full": "type(X)",
                "name": "type",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [type](https://docs.dolphindb.com/en/Functions/t/type.html)\n\n\n\n#### Syntax\n\ntype(X)\n\n#### Arguments\n\n**X** can be any data type that the system supports.\n\n#### Details\n\nReturn an integer indicating the data type of X. Please refer to [Data Types](https://docs.dolphindb.com/en/Programming/DataTypesandStructures/DataTypes/DataTypes.html) for details.\n\n#### Examples\n\n```\nx=3;\nx;\n// output\n3\n\ntype(x);\n// output\n4\n// INT\n\ntype(1.2);\n// output\n16\n// DOUBLE\n\ntype(\"Hello\");\n// output\n18\n// STRING\n```\n"
    },
    "typestr": {
        "url": "https://docs.dolphindb.com/en/Functions/t/typestr.html",
        "signatures": [
            {
                "full": "typestr(X)",
                "name": "typestr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [typestr](https://docs.dolphindb.com/en/Functions/t/typestr.html)\n\n\n\n#### Syntax\n\ntypestr(X)\n\n#### Arguments\n\n**X** can be any data type that the system supports.\n\n#### Details\n\nReturn a string indicating the data type of X. Please refer to [Data Types](https://docs.dolphindb.com/en/Programming/DataTypesandStructures/DataTypes/DataTypes.html) for details.\n\n#### Examples\n\n```\nx=3;\nx;\n// output\n3\n\ntypestr x;\n// output\nINT\n\ntypestr 1.2;\n// output\nDOUBLE\n\ntypestr `Hello;\n// output\nSTRING\n```\n"
    },
    "accumulate": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/accumulate.html",
        "signatures": [
            {
                "full": "accumulate(func, X, [init], [consistent=false])",
                "name": "accumulate",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "func:A([init], X)",
                "name": "func:A",
                "parameters": [
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            },
            {
                "full": "func:AC([init], X)",
                "name": "func:AC",
                "parameters": [
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [accumulate](https://docs.dolphindb.com/en/Functions/Templates/accumulate.html)\n\n\n\n#### Syntax\n\naccumulate(func, X, \\[init], \\[consistent=false])\n\nor\n\n\\[init] \\<operator>:A X (where  is false)\n\nor\n\n\\[init] \\<operator>:AC X (where  is true)\n\nor\n\nfunc:A(\\[init], X) (where  is false)\n\nor\n\nfunc:AC(\\[init], X) (where  is true)\n\n#### Arguments\n\n**func** is a function for iteration.\n\n**X** is data or iteration rule.\n\n**init** is the initial value to be passed to *func*.\n\n**consistent** is a Boolean value specifying how the data types and forms of the iteration results are determined. The default value is false, meaning the data types and forms are determined by the result of each iteration. Otherwise, they are the same as the first output. Note that if the data forms of iteration results are different, *consistent* must be set to false.\n\n#### Details\n\nThe `accumulate` template applies *func* to *init* and *X* for accumulating iteration (i.e. the result of an iteration is passed forward to the next). Unlike the template `reduce` that returns only the last result, the template `accumulate` outputs result of each iteration.\n\n1. When *func* is a unary function, *X* can be a non-negative integer, a unary function or NULL. In all these cases, *init* must be specified.\n\n   The function first returns *init* as the initial value, then applies *func* iteratively until a certain condition specified in *X* is satisfied.\n\n   * If *X* is an integer, *func* iterates *X* times, outputting (*X*+1) elements. Note that when *X* is negative, it is treated as 0.\n\n   * If *X* is unspecified or NULL, the iteration continues until the next output is the same as the current one.\n\n   * If *X* is a unary function, it must return a Boolean value to determine the termination of iteration. The iteration continues until *X* returns false for the current output.\n\n2. When *func* is a binary function, *X* can be a vector, matrix or table.\n\n   The function first applies *func* to *init* and X\\[0], and then iterates over the current output and the next element in *X*. If *init* is unspecified, the first output is X\\[0].\n\n   `accumulate` is equivalent to the execution of the pseudo code below:\n\n   ```\n   result[0]=iif(init==NULL,X[0],<function>(init,X[0]));\n\n   for(i:1~size(X)-1){\n\n       result[i]=<function>(result[i-1], X[i]);\n\n   }\n\n   return result;\n   ```\n\n3. When *func* is a ternary function, *X* must be a tuple with 2 elements. The iteration rule is the same as that of a binary function.\n\n#### Examples\n\n*func* is a unary function:\n\n```\n//define a unary function\ndef func1(x){\n    if(x<5){\n            return x*3\n    }\n    else{\n            return x+3\n    }\n}\n\n//when X is an integer, the size of the result is X + 1\naccumulate(func1, 5, 1)\n// output\n[1,3,9,12,15,18]\n\n//X is a unary function \"condition\". As condition returns false during the 3rd iteration, the system stops iteration and outputs the results of the first two iterations.\ndef condition(x){\nreturn x<9\n}\naccumulate(func1, condition, 1)\n// output\n[1,3,9]\n\n//when X is NULL or unspecified, define a UDF func2 for iteration.\ndef func2(x){\n    if(x<5){\n            return x*3\n    }\n    else{\n            return 6\n    }\n}\n\n//As the results of the 3rd and 4th iterations are the same, the function stops iteration and outputs the results of the first three iterations.\naccumulate(func2,NULL,1)\n// output\n[1,3,9,6]\n```\n\nWhen *func* is a binary function, `accumulate` on a vector:\n\n```\nx = 1 2 3;\naccumulate(add, 1 2 3);\n// output\n[1,3,6]\n// equivalent to [1, 1+2, 3+3]\n\n1 +:A x;\n// output\n[2,4,7]\n// equivalent to [1+1, 2+2, 4+3]\n\naccumulate(-, 2, x);\n// output\n[1,-1,-4]\n// equivalent to [2-1, 1-2, -1-3]\n\naccumulate(mul, x);\n// output\n[1,2,6]\n// equivalent to [1, 1*2, 2*3]\n\ndef facts(a) {return 1*:A 1..a;};\nfacts 5;\n// output\n[1,2,6,24,120]\n// calculate cumulative factorization\n\ndef f1(a,b): a+log(b);\naccumulate(f1, 1..5, 0);\n// output\n[0,0.693147,1.791759,3.178054,4.787492]\n// the example above calculates cumulative sum of log(1) to log(i)\n// note the result from the previous step will be given to the first parameter of the function.\n// 0+log(1)=0, 0+log(2)=0.693147, 0.693147+log(3)=1.791759, ......\n\naccumulate(f1, 1..5);\n// output\n[1,1.693147,2.791759,4.178053,5.787491]\n// since the initial condition is ignored here, the data type of the first element of the input vector determines the date type of the result.\n```\n\n`accumulate` on a matrix:\n\n```\nx=1..12$3:4;\nx;\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 1    | 4    | 7    | 10   |\n| 2    | 5    | 8    | 11   |\n| 3    | 6    | 9    | 12   |\n\n```\n+ :A x;\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 1    | 5    | 12   | 22   |\n| 2    | 7    | 15   | 26   |\n| 3    | 9    | 18   | 30   |\n\nWhen *func* is a ternary function:\n\n```\ndef fun3(x,y,z){\n  return x+y+z\n}\naccumulate(fun3,[[1,2,3],[10,10,10]],5)\n// output\n[16,28,41]\n```\n"
    },
    "aggrTopN": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/aggrTopN.html",
        "signatures": [
            {
                "full": "aggrTopN(func, funcArgs, sortingCol, top, [ascending=true])",
                "name": "aggrTopN",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "sortingCol",
                        "name": "sortingCol"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [aggrTopN](https://docs.dolphindb.com/en/Functions/Templates/aggrTopN.html)\n\n\n\n#### Syntax\n\naggrTopN(func, funcArgs, sortingCol, top, \\[ascending=true])\n\n#### Arguments\n\n**func** is an aggregate function.\n\n**funcArgs** are the parameters of *func*. It can be a scalar or vector. It is a tuple if there are more than 1 parameter of *func*.\n\n**sortingCol** is a numeric/temporal vector, based on which *funcArgs* are sorted.\n\n**top** is an integer or floating-point number.\n\n* If it is an integer, select the first *top* rows of records for calculation.\n\n* If it is a floating-point number, the value should be less than 1.0 to indicate a percentage. The function will select *top* of the rows in *funcArgs* for calculation. If the result is less than 1, select the first row. If the result is not an integer, it is rounded down and at least one row is selected.\n\n**ascending** is a Boolean value indicating whether to sort the *sortingCol* in ascending order. It is an optional parameter and the default value is true.\n\n#### Details\n\nAfter sorting *funcArgs* based on *sortingCol*, `aggrTopN` applies *func* to the first *top* elements in *funcArgs*. NULL value in *sortingCol* is treated as the minimum value.\n\n#### Examples\n\n```\naggrTopN(func=sum, funcArgs=1 2 3 4 5, sortingCol=5 1 2 3 4, top=3, ascending=false)\n// output\n10\n\naggrTopN(func=corr,funcArgs=[1..5, 3 9 4 2 5], sortingCol=2 3 4 5 3, top=3)\n// output\n0.052414\n```\n\n`aggrTopN` takes the first 3 elements for calculation as top is set to 3. There are three occurrences of 3 in the following example, and only three *sortingCol* elements are selected.\n\n```\naggrTopN(func=min,funcArgs=1 6 4 -6 4 5, sortingCol=2 3 3 3 4 5, top=3)\n// output\n1\n```\n\nCalculate the average price of the highest 25% of the daily trading volume for each stock.\n\n```\nt = table(`A`A`A`B`B`B`B`B`B`B`B as sym, 09:30:06 09:30:28 09:31:46 09:31:59 09:30:19 09:30:43 09:31:23 09:31:56 09:30:44 09:31:25 09:31:57 as time, 10 20 10 30 20 40 30 30 30 20 40 as volume, 10.05 10.06 10.07 10.05 20.12 20.13 20.14 20.15 20.12 20.13 20.16 as price);\nt;\n```\n\n| sym | time     | volume | price |\n| --- | -------- | ------ | ----- |\n| A   | 09:30:06 | 10     | 10.05 |\n| A   | 09:30:28 | 20     | 10.06 |\n| A   | 09:31:46 | 10     | 10.07 |\n| B   | 09:31:59 | 30     | 10.05 |\n| B   | 09:30:19 | 20     | 20.12 |\n| B   | 09:30:43 | 40     | 20.13 |\n| B   | 09:31:23 | 30     | 20.14 |\n| B   | 09:31:56 | 30     | 20.15 |\n| B   | 09:30:44 | 30     | 20.12 |\n| B   | 09:31:25 | 20     | 20.13 |\n| B   | 09:31:57 | 40     | 20.16 |\n\n```\nselect aggrTopN(func=avg, funcArgs=price, sortingCol=volume, top=0.25, ascending=false) from t group by sym\n```\n\n| sym | aggrTopN\\_avg |\n| --- | ------------- |\n| A   | 10.06         |\n| B   | 20.145        |\n"
    },
    "byColumn": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/byColumn.html",
        "signatures": [
            {
                "full": "byColumn(func, X, [Y])",
                "name": "byColumn",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            },
            {
                "full": "func:V(X)",
                "name": "func:V",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            },
            {
                "full": "func:V(X, [Y])",
                "name": "func:V",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [byColumn](https://docs.dolphindb.com/en/Functions/Templates/byColumn.html)\n\n\n\n#### Syntax\n\nbyColumn(func, X, \\[Y])\n\nOr\n\nfunc:V(X)\n\nOr\n\nfunc:V(X, \\[Y])\n\n#### Arguments\n\n**func** is a unary function. When function with multiple parameters is specified for *func*, partial application is used to fix part of the parameters. It can be a vector function (where the input vector and output vector are of equal length) or an aggregate function.\n\n**X** is a matrix/table/tuple/array vector/columnar tuple.\n\n**Y** is a matrix/table/tuple/array vector/columnar tuple.\n\n#### Details\n\nApplies the specified function to each column of the matrix *X*.\n\nIf *func* is a unary function, apply the specified function to each column of *X*; if *func* is a binary function, apply func(Xi, Yi) to each column of *X* and *Y*.\n\n`byColumn` can be used in a reactive state engine.\n\n**Calculation rules**:\n\n* If *X*/*Y* is a matrix, table, or tuple, `byColumn` applies *func* to each column of *X*/*Y*.\n\n* If *X*/*Y* is an array vector or columnar tuple, `byRow` applies *func* to each row of the transpose of *X*/*Y*.\n\n  * If *func* is a vector function, `byColumn` returns the transpose of the result.\n\n  * If *func* is an aggregate function, `byColumn` directly returns a vector. Certain aggregate functions in DolphinDB are optimized to work natively by column, requiring no transpose of the input *X*/*Y*. These include: sum, sum2, avg, min, max, count, imax, imin, imaxLast, iminLast, prod, std, stdp, var, varp, skew, kurtosis, any, all, corr, covar, wavg, wsum, beta, euclidean, dot, tanimoto.\n\n**Return values**:\n\n* If *func* is an aggregate function\n\n  * If *X*/*Y* is a matrix, array vector, or columnar tuple, `byColumn` returns a vector of the same size as the number of columns in *X*/*Y*.\n\n  * If *X*/*Y* is a tuple, `byColumn` returns a tuple.\n\n  * If *X*/*Y* is a table, `byColumn` returns a table.\n\n* If *func* is a vector function, `byColumn` returns a result with the same form and dimension as *X*/*Y*.\n\n#### Examples\n\nWhen *func* is a unary function that does not support matrix operations, the `byColumn` function is equivalent to `each`.\n\n```\ndef myvfunc(x): var(x).log()\nm = matrix(1.1 2.3 2.1 3.5 4.2, 3.3 2.5 4.2 5.1 0, -1 3.3 2 1.7 2.3)\nbyColumn(myvfunc, m)\n// output\n[0.3974329364109,1.334211281249665,0.945072533299607]\n```\n\nTo specify a function with multiple parameters for *func*:\n\n```\nbyColumn(add{2}, m)\n// output\ncol1 col2 col3\n3.1  5.3  1\n4.3  4.5  5.3\n4.1  6.2  4\n5.5  7.1  3.7\n6.2  2    4.3\n\nbyColumn(add{1 2 3 4 5}, m)\n// output\ncol1 col2 col3\n2.1  4.3  0\n4.3  4.5  5.3\n5.1  7.2  5\n7.5  9.1  5.7\n9.2  5    7.3\n```\n\nWhen *func* is a user-defined function:\n\n```\ndef my_func(x){\nreturn iif(x > 0, 1, -1)\n}\nm = matrix(3 -6 5 0, 2 -9 -4 5)\nbyColumn(my_func, m)\n// output\ncol1 col2\n1    1\n-1   -1\n1    -1\n-1    1\n```\n\nWhen *func* is a nested function:\n\n```\nm = matrix(1 5 3 , 7 5 2)\nbyColumn(accumulate{def (x, y):iif(x > 5, y-1, y+1), ,1}, m)\n// output\ncol1 col2\n2    8\n6    4\n2    3\n```\n\nIf *func* is a multivariate function, it is necessary to fix part of the parameters using partial application.\n\n```\nbyColumn(autocorr{,2},m)\n// output\n[-0.05,-0.28,-0.06]\n```\n\n*X*/*Y* is a matrix.\n\n```\nm=matrix([1 3 4 2,1 2 2 1])\nmax:V(m)\n// output\n[4,2]\n\ncummax:V(m)\n// output\ncol1\tcol2\n1\t1\n3\t2\n4\t2\n4\t2\n\nn=matrix([11 5 9 2,8 5 3 2])\ncorr:V(m,n)\n// output\n[-0.09,-0.21]\n```\n\n*X*/*Y* is a table.\n\n```\nqty1 = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nqty2 = 2100 1800  6800 5400 1300 2400 8500 4100 3200\nt = table(qty1, qty2);\nmax:V(t) \n// output\nqty1\tqty2\n8,800\t8,500\n\ncummax:V(t) \n// output\nqty1\tqty2\n2,200\t2,100\n2,200\t2,100\n2,200\t6,800\n3,200\t6,800\n6,800\t6,800\n6,800\t6,800\n6,800\t8,500\n6,800\t8,500\n8,800\t8,500\n\n\nqty3 = 7800 5400 5300 2500 1800 2200 3900 3100 1200\nqty4 = 3200 2800 6400 8300 2300 3800 2900 1600 2900\nt1 = table(qty3, qty4);\ncorr:V(t,t1)   \n// output\nqty1\tqty2\n-0.7267\t0.4088\n```\n\n*X*/*Y* is a tuple.\n\n```\ntp=[1 3 4 2,1 2 2 1]\nsum:V(tp)  \n// output\n(10,6) \n\ncummax:V(tp) \n// output\n([1,3,4,4],[1,2,2,2]) \n\ntp1=[11 23 14 21,10 12 32 21]\ncorr:V(tp,tp1)\n// output  \n(0.25,0.37)\n```\n\n*X*/*Y* is an array vector.\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5 4, 6 7 8, 1 9 10]);\nsum:V(a) \n// output\n[12,23,25] \n\ncummax:V(a)\n// output\n[[1,2,3],[4,5,4],[6,7,8],[6,9,10]]\n\nb=array(DOUBLE[], 0, 10).append!([11.8 21.2 23.9, 83.3 90.2 78.2, 86.5 52 36.5, 10.1 12.4 16.8])\ncorr:V(a,b)  \n// output\n[0.95,-0.13,-0.46]\n```\n\n*X*/*Y* is a columnar tuple.\n\n```\nctp=[1 3 4 2,1 2 2 1]\nctp.setColumnarTuple!()\nsum:V(ctp) \n// output \n[2,5,6,3]\n\ncummax:V(ctp)\n// output\n([1,3,4,2],[1,3,4,2])\n\nctp1=[11 23 14 21,10 12 32 21]\nctp1.setColumnarTuple!()\ncorr:V(ctp,ctp1) \n// output\n[,1,-1,]\n```\n\nRelated function: [byRow](https://docs.dolphindb.com/en/Functions/Templates/byRow.html)\n"
    },
    "byRow": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/byRow.html",
        "signatures": [
            {
                "full": "byRow(func, X, [Y])",
                "name": "byRow",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            },
            {
                "full": "func:H(X)",
                "name": "func:H",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            },
            {
                "full": "func:H(X, [Y])",
                "name": "func:H",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [byRow](https://docs.dolphindb.com/en/Functions/Templates/byRow.html)\n\n\n\n#### Syntax\n\nbyRow(func, X, \\[Y])\n\nOr\n\nfunc:H(X)\n\nOr\n\nfunc:H(X, \\[Y])\n\n#### Arguments\n\n**func** is either a vector function (both input and output are vectors of equal length) or an aggregate function.\n\n**X** is a matrix/table/tuple/array vector/columnar tuple.\n\n**Y** is a matrix/table/tuple/array vector/columnar tuple.\n\nFor the arguments and calculation rules of other row-based functions, refer to [Row-Based Functions](https://docs.dolphindb.com/en/Functions/Themes/rowFunctions.html).\n\n#### Details\n\nApply the specified function to each row of a matrix.\n\nIf *func* is a unary function, apply the specified function to each row of *X*; if *func* is a binary function, apply func(Xi, Yi) to each row of *X* and *Y*.\n\n**Note**: Since version 2.00.11, `byRow` can achieve the roles of row-based functions with equivalent performance and can be applied to all row-based scenarios. For example, `byRow(sum, X)` is equivalent to `rowSum(X)`.\n\n**Calculation rules**:\n\n* If *X*/*Y* is a matrix, table, or tuple, `byRow` applies *func* to each column of the transpose of *X*/*Y*.\n\n  * If *func* is a vector function, `byRow` returns the transpose of the result of *func*.\n\n  * If *func* is an aggregate function, `byRow` directly returns a vector. Certain aggregate functions in DolphinDB are optimized to work natively by row, requiring no transpose of the input *X*/*Y*. These include: sum, sum2, avg, min, max, count, imax, imin, imaxLast, iminLast, prod, std, stdp, var, varp, skew, kurtosis, any, all, corr, covar, wavg, wsum, beta, euclidean, dot, tanimoto.\n\n* If *X*/*Y* is an array vector or columnar tuple, `byRow` applies *func* to each row of *X*/*Y*.\n\n**Return Value**:\n\n* If *func* is an aggregate function, `byRow` returns a vector of the same size as the number of rows in *X*/*Y*.\n\n* If *func* is a vector function, `byRow` returns a result with the same form and dimension as *X*/*Y*.\n\n#### Examples\n\n*X*/*Y* is a matrix.\n\n```\nm=matrix([1 3 4 2,1 2 2 1])\nmax:H(m)\n// output\n[1,3,4,2]\n\ncummax:H(m) \n// output\ncol1\tcol2\n1\t1\n3\t3\n4\t4\n2\t2\n\nn=matrix([11 5 9 2,8 5 3 2])\ncorr:H(m,n)\n// output\n[,,1,]\n```\n\n*X*/*Y* is a table.\n\n```\nqty1 = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nqty2 = 2100 1800  6800 5400 1300 2400 8500 4100 3200\nt = table(qty1, qty2);\nmax:H(t) \n// output\n[2200,1900,6800,5400,6800,5400,8500,4100,8800]\n\ncummax:H(t) \n// output\nqty1\tqty2\n2,200\t2,200\n1,900\t1,900\n2,100\t6,800\n3,200\t5,400\n6,800\t6,800\n5,400\t5,400\n1,300\t8,500\n2,500\t4,100\n8,800\t8,800\n\nqty3 = 7800 5400 5300 2500 1800 2200 3900 3100 1200\nqty4 = 3200 2800 6400 8300 2300 3800 2900 1600 2900\nt1 = table(qty3, qty4);\ncorr:H(t,t1)   \n// output\n[1,1,1,1,-1,-1,-1,-1,-1]\n```\n\n*X*/*Y* is a tuple.\n\n```\ntp=[1 3 4 2,1 2 2 1]\nsum:H(tp)  \n// output\n[2,5,6,3] \n\ncummax:H(tp) \n// output\n([1,3,4,2],[1,3,4,2]) \n\ntp1=[11 23 14 21,10 12 32 21]\ncorr:H(tp,tp1) \n// output \n[,1,-1,]\n```\n\n*X*/*Y* is an array vector.\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5 4, 6 7 8, 1 9 10]);\nsum:H(a) \n// output\n[6,13,21,20] \n\ncummax:H(a)\n// output\n[[1,2,3],[4,5,5],[6,7,8],[1,9,10]]\n\nb=array(DOUBLE[], 0, 10).append!([11.8 21.2 23.9, 83.3 90.2 78.2, 86.5 52 36.5, 10.1 12.4 16.8])\ncorr:H(a,b)  \n// output\n[0.95,0.90,-0.97,0.82]\n```\n\n*X*/*Y* is a columnar tuple.\n\n```\nctp=[1 3 4 2,1 2 2 1]\nctp.setColumnarTuple!()\nsum:H(ctp)  \n// output\n[10,6]\n\ncummax:H(ctp)\n// output\n([1,3,4,4],[1,2,2,2])\n\nctp1=[11 23 14 21,10 12 32 21]\nctp1.setColumnarTuple!()\n\ncorr:H(ctp,ctp1)\n// output\n[0.25, 0.37]\n```\n\n```\nm=matrix(1 1, 2 3, 2 1);\nm;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 2    | 2    |\n| 1    | 3    | 1    |\n\n```\nbyRow(add{10 20 30},m);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 11   | 22   | 32   |\n| 11   | 23   | 31   |\n\n```\nbyRow(mode,m);\n// output\n[2,1]\n```\n\n```\nb=array(DOUBLE[], 0, 10).append!([11.8 21.2 23.9, 83.3 90.2 78.2 86.5, 10.1 12.4 16.8])\nbyRow(add{100},b)\n// output\n[111.8 121.2 123.9,183.3 190.2 178.2 86.5,110.1 112.4 116.8]\n\nbyRow(imax,b)\n// output\n[2,1,2]\n```\n\nRelated function: [byColumn](https://docs.dolphindb.com/en/Functions/Templates/byColumn.html)\n"
    },
    "call": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/call.html",
        "signatures": [
            {
                "full": "call(func, args...)",
                "name": "call",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [call](https://docs.dolphindb.com/en/Functions/Templates/call.html)\n\n\n\n#### Syntax\n\ncall(func, args...)\n\n#### Arguments\n\n**func** is a function.\n\n**args** are the required parameters of *func*.\n\n#### Details\n\nCall a function with the specified parameters. It is often used with function [each](https://docs.dolphindb.com/en/Functions/Templates/each.html)/[peach](https://docs.dolphindb.com/en/Functions/Templates/peach.html) or [loop](https://docs.dolphindb.com/en/Functions/Templates/loop.html)/[ploop](https://docs.dolphindb.com/en/Functions/Templates/ploop.html) to call multiple functions.\n\n#### Examples\n\n```\ncall(sum, 1..10);\n// output\n55\n// equivalent to sum(1..10)\n\neach(call, [avg, sum], [0..10, 0..100]);\n// output\n[5,5050]\n\neach(call{, 1..3},(sin,log));\n// note that call{, 1..3} is a partial application.\n```\n\n| sin      | log      |\n| -------- | -------- |\n| 0.841471 | 0        |\n| 0.909297 | 0.693147 |\n| 0.14112  | 1.098612 |\n"
    },
    "contextby": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/contextby.html",
        "signatures": [
            {
                "full": "contextby(func, funcArgs, groupingCol, [sortingCol], [semanticFilter=1])",
                "name": "contextby",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "groupingCol",
                        "name": "groupingCol"
                    },
                    {
                        "full": "[sortingCol]",
                        "name": "sortingCol",
                        "optional": true
                    },
                    {
                        "full": "[semanticFilter=1]",
                        "name": "semanticFilter",
                        "optional": true,
                        "default": "1"
                    }
                ]
            },
            {
                "full": "func:X(funcArgs, groupingCol, [sortingCol], [semanticFilter=1])",
                "name": "func:X",
                "parameters": [
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "groupingCol",
                        "name": "groupingCol"
                    },
                    {
                        "full": "[sortingCol]",
                        "name": "sortingCol",
                        "optional": true
                    },
                    {
                        "full": "[semanticFilter=1]",
                        "name": "semanticFilter",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [contextby](https://docs.dolphindb.com/en/Functions/Templates/contextby.html)\n\n\n\n#### Syntax\n\ncontextby(func, funcArgs, groupingCol, \\[sortingCol], \\[semanticFilter=1])\n\nor\n\nfuncArg func:X groupingCol\n\nor\n\nfunc:X(funcArgs, groupingCol, \\[sortingCol], \\[semanticFilter=1])\n\n#### Arguments\n\n**func** is a function. For the second use case, *func* can only have one parameter (*funcArg*).\n\n**funcArgs** are the parameters of *func*. It is a tuple if there are more than 1 parameter of *func*.\n\n**groupingCol** is the grouping variable(s). It can be one or multiple vectors.\n\n**sortingCol** is an optional argument for within group sorting before applying *func*.\n\n**semanticFilter** (optional) is a positive integer indicating which columns to include in calculations when *funcArgs* is a table. The possible values are:\n\n* 0 - All columns\n* 1 (default) - Columns of FLOATING, INTEGRAL, and DECIMAL categories, excluding the COMPRESSED data type.\n* 2 - Columns of TEMPORAL category.\n* 3 - Columns of LITERAL category, excluding the BLOB data type.\n* 4 - Columns of FLOATING, INTEGRAL, DECIMAL, and TEMPORAL categories, excluding the COMPRESSED data type.\n\nThe vectors in *groupingCol*, *sortingCol* and each of the function argument in *funcArgs* all have the same size.\n\n#### Details\n\nCalculate `func(funcArgs)` for each *groupingCol* group. The result is a vector of the same size as each of the input arguments other than *func*. If *func* is an aggregate function, all elements within the same group have identical result. We can use *sortingCol* to sort the within-group data before the calculation.\n\nNote: The keyword `defg` must be used to declare an aggregate function.\n\n#### Examples\n\n```\nsym=`IBM`IBM`IBM`MS`MS`MS\nprice=172.12 170.32 175.25 26.46 31.45 29.43\nqty=5800 700 9000 6300 2100 5300\ntrade_date=2013.05.08 2013.05.06 2013.05.07 2013.05.08 2013.05.06 2013.05.07;\ncontextby(avg, price, sym);\n// output\n[172.563,172.563,172.563,29.113,29.113,29.113]\n\nprice avg :X sym;\n// output\n[172.563,172.563,172.563,29.113,29.113,29.113]\n\nprice at price>contextby(avg, price,sym);\n// output\n[175.25,31.45,29.43]\n\nprice at price>price avg :X sym;\n// output\n[175.25,31.45,29.43]\n\nsym at price>contextby(avg, price,sym);\n// output\n[\"IBM\",\"MS\",\"MS\"]\n\n// calculate volume-weighted average price (vwap)\ncontextby(wavg, [price, qty], sym);\n// output\n[173.856,173.856,173.856,28.374,28.374,28.374]\n\ncontextby(ratios, price, sym, trade_date) - 1;\n// output\n[-0.01786,,0.028946,-0.100917,,-0.064229]\n```\n\nMultiple vectors for *groupingCol* :\n\n```\nsym=`IBM`IBM`IBM`IBM`IBM`IBM`MS`MS`MS`MS`MS`MS\ndate=2020.12.01 + 0 0 0 1 1 1 0 0 0 1 1 1\nqty=5800 700 9000 1000 3500 3900 6300 2100 5300 7800 1200 4300\ncontextby(cumsum, qty, [sym,date]);\n// output\n[5800,6500,15500,1000,4500,8400,6300,8400,13700,7800,9000,13300]\n```\n\nWe can embed a *contextby* template into a SQL query:\n\n```\nt1=table(trade_date,sym,qty,price);\nt1;\n```\n\n| trade\\_date | sym | qty  | price  |\n| ----------- | --- | ---- | ------ |\n| 2013.05.08  | IBM | 5800 | 172.12 |\n| 2013.05.06  | IBM | 700  | 170.32 |\n| 2013.05.07  | IBM | 9000 | 175.25 |\n| 2013.05.08  | MS  | 6300 | 26.46  |\n| 2013.05.06  | MS  | 2100 | 31.45  |\n| 2013.05.07  | MS  | 5300 | 29.43  |\n\n```\n// select orders with a price higher than the average price of the group\nselect trade_date, sym, qty, price from t1 where price > contextby(avg, price,sym);\n```\n\n| trade\\_date | sym | qty  | price  |\n| ----------- | --- | ---- | ------ |\n| 2013.05.07  | IBM | 9000 | 175.25 |\n| 2013.05.06  | MS  | 2100 | 31.45  |\n| 2013.05.07  | MS  | 5300 | 29.43  |\n\n```\n// add 1 day to all trade dates in t1\ncontextby(temporalAdd{,1d}, t1, t1.sym,,2)\n```\n\n<table id=\"table_x4v_cj2_xbc\"><thead><tr><th align=\"left\">\n\ntrade\\_date\n\n</th><th align=\"left\">\n\nsym\n\n</th><th align=\"left\">\n\nqty\n\n</th><th align=\"left\">\n\nprice\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\n2013.05.09\n\n</td><td align=\"left\">\n\nIBM\n\n</td><td align=\"left\">\n\n5,800\n\n</td><td align=\"left\">\n\n172.12\n\n</td></tr><tr><td align=\"left\">\n\n2013.05.07\n\n</td><td align=\"left\">\n\nIBM\n\n</td><td align=\"left\">\n\n700\n\n</td><td align=\"left\">\n\n170.32\n\n</td></tr><tr><td align=\"left\">\n\n2013.05.08\n\n</td><td align=\"left\">\n\nIBM\n\n</td><td align=\"left\">\n\n9,000\n\n</td><td align=\"left\">\n\n175.25\n\n</td></tr><tr><td align=\"left\">\n\n2013.05.09\n\n</td><td align=\"left\">\n\nMS\n\n</td><td align=\"left\">\n\n6,300\n\n</td><td align=\"left\">\n\n26.46\n\n</td></tr><tr><td align=\"left\">\n\n2013.05.07\n\n</td><td align=\"left\">\n\nMS\n\n</td><td align=\"left\">\n\n2,100\n\n</td><td align=\"left\">\n\n31.45\n\n</td></tr><tr><td align=\"left\">\n\n2013.05.08\n\n</td><td align=\"left\">\n\nMS\n\n</td><td align=\"left\">\n\n5,300\n\n</td><td align=\"left\">\n\n29.43\n\n</td></tr></tbody>\n</table>\n"
    },
    "cross": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/cross.html",
        "signatures": [
            {
                "full": "cross(func, X, [Y])",
                "name": "cross",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            },
            {
                "full": "func:C(X, [Y])",
                "name": "func:C",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [cross](https://docs.dolphindb.com/en/Functions/Templates/cross.html)\n\n\n\n#### Syntax\n\ncross(func, X, \\[Y])\n\nor\n\nX \\<operator>:C Y\n\nor\n\nfunc:C(X, \\[Y])\n\n#### Arguments\n\n**func** is a binary function.\n\n**X** and **Y** can be pair/vector/matrix. They can have different data forms and sizes.\n\n**Y** is optional. If *Y* is not specified, perform `cross(func, X, X)` where *func* must be a symmetric binary function, such as [corr](https://docs.dolphindb.com/en/Functions/c/corr.html) .\n\n#### Details\n\nApply *func* to the permutation of all individual elements of *X* and *Y* and return a matrix.\n\nAssume *X* has m elements and *Y* has n elements. The template returns an m (rows) by n (columns) matrix. Below is the pseudo code for the `cross` template.\n\n```\nfor(i:0~(size(X)-1)){\nfor(j:0~(size(Y)-1)){\n  result[i,j]=<function>(X[i], Y[j]);\n}\n}\nreturn result;\n```\n\nIf *X* and *Y* are matrices, the iteration is over the columns of *X* and *Y* .\n\nIf the result of `func(X[i], Y[j])` is a scalar, the result of the `cross` template is a matrix.\n\nIf the result of `func(X[i], Y[j])` is a vector, the result of the `cross` template is a tuple with m elements. Each of the element is a tuple with n elements.\n\n#### Examples\n\n`cross` with two vectors:\n\n```\nx=1 2;\ny=3 5 7;\nx+:C y;\n```\n\n| lable | 3 | 5 | 7 |\n| ----- | - | - | - |\n| 1     | 4 | 6 | 8 |\n| 2     | 5 | 7 | 9 |\n\n```\ncross(mul, x, y);\n```\n\n| lable | 3 | 5  | 7  |\n| ----- | - | -- | -- |\n| 1     | 3 | 5  | 7  |\n| 2     | 6 | 10 | 14 |\n\n```\ncross(pow, x, y);\n```\n\n| lable | 3 | 5  | 7   |\n| ----- | - | -- | --- |\n| 1     | 1 | 1  | 1   |\n| 2     | 8 | 32 | 128 |\n\n`cross` with two matrices:\n\n```\nm = 1..6$2:3;\nm;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 3    | 5    |\n| 2    | 4    | 6    |\n\n```\nn=1..4$2:2;\nn;\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 3    |\n| 2    | 4    |\n\n```\ncross(**, m, n);\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 5    | 11   |\n| 11   | 25   |\n| 17   | 39   |\n\n`cross` with a vector and a matrix:\n\n```\ndef topsum(x,n){return sum x[0:n]};\na=1..18$6:3;\na;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 7    | 13   |\n| 2    | 8    | 14   |\n| 3    | 9    | 15   |\n| 4    | 10   | 16   |\n| 5    | 11   | 17   |\n| 6    | 12   | 18   |\n\n```\nb=2 4;\na topsum :C b;\n```\n\n| 2  | 4  |\n| -- | -- |\n| 3  | 10 |\n| 15 | 34 |\n| 27 | 58 |\n\n`cross` with tuple type results:\n\n```\nx=1 2\ny=1..6$2:3\ncross(add, x, y);\n// output\n(([2,3],[4,5],[6,7]),([3,4],[5,6],[7,8]))\n\nx=1 2\ny=1..6$3:2\ncross(add, x, y);\n// output\n(([2,3,4],[5,6,7]),([3,4,5],[6,7,8]))\n```\n"
    },
    "each": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/each.html",
        "signatures": [
            {
                "full": "each(func, args...)",
                "name": "each",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            },
            {
                "full": "func:E(args...)",
                "name": "func:E",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [each](https://docs.dolphindb.com/en/Functions/Templates/each.html)\n\n#### Syntax\n\neach(func, args...) (apply a function to each element of the specified parameters)\n\nor\n\nF :E X (apply a function to each element of X)\n\nor\n\nX < operator > :E Y (apply an operator to each element of X and Y)\n\nor\n\nfunc:E(args...)\n\n#### Arguments\n\n**func** is a function.\n\n**args** are the required parameters of *func*.\n\n**operator** is a binary operator.\n\n**X** / **Y** can be pair/vector/matrix/table/array vector/dictionary. *X* and *Y* must have the same dimensions.\n\n#### Details\n\nApply a function (specified by *func* or *operator*) to each element of *args* / *X* / *Y*.\n\n* For matrices, calculate in each column;\n\n* For tables, calculate in each row;\n\n* For array vectors, calculate in each row;\n\n* For dictionaries, calculate each value.\n\nThe data type and form of the return value are determined by each calculation result. It returns a vector or matrix if all calculation results have the same data type and form, otherwise it returns a tuple.\n\nThe difference between `func(X)` and `func :E X` is that the former treats *X* as the one input variable while the later takes each element in *X* as an input variable. If *func* is a vector function, avoid using `:E` since element-wise operations are very slow with a large number of elements.\n\n#### Examples\n\nSuppose we need to calculate the daily compensation for 3 workers. Their working hours are stored in vector x=\\[9,6,8]. Their hourly rate is $10 under 8 hours and $20 beyond 8 hours. Consider the following function `wage`:\n\n```\nx=[9,6,8]\ndef wage(x){if(x<=8) return 10*x; else return 20*x-80}\nwage x;\n// output\nThe vector can't be converted to bool scalar.\n```\n\n*wage(x)* does not return a result, as x<=8, i.e., \\[9,6,8]<=8 returns a vector of conditions \\[0,1,1], not a scalar condition that is required by `if`.\n\nIn contrast, consider the following solutions:\n\n```\neach(wage, x);\n// output\n[100,60,80]\n\nwage :E x;\n// output\n[100,60,80]\n\ndef wage2(x){return iif(x<=8, 10*x, 20*x-80)};\n// the iif function is an element-wise conditional operation\n\nwage2(x);\n// output\n[100,60,80]\n```\n\nSimilarly, `each` can also be applied to a function with more than one parameter.\n\n```\ndef addeven(x,y){if (x%2==0) return x+y; else return 0}\nx1=1 2 3\nx2=4 5 6;\neach(addeven, x1, x2);\n// output\n[0,7,0]\n```\n\n`each` with a tuple:\n\n```\nt = table(1 2 3 as id, 4 5 6 as value, `IBM`MSFT`GOOG as name);\nt;\n```\n\n| id | value | name |\n| -- | ----- | ---- |\n| 1  | 4     | IBM  |\n| 2  | 5     | MSFT |\n| 3  | 6     | GOOG |\n\n```\neach(max, t[`id`value]);\n// output\n[3,6]\n```\n\n`each` with matrices:\n\n```\nm=1..12$4:3;\nm;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 5    | 9    |\n| 2    | 6    | 10   |\n| 3    | 7    | 11   |\n| 4    | 8    | 12   |\n\n```\neach(add{1 2 3 4}, m);\n// add{1 2 3 4} is a partial application, which adds [1, 2, 3, 4] to each of the 3 columns\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 2    | 6    | 10   |\n| 4    | 8    | 12   |\n| 6    | 10   | 14   |\n| 8    | 12   | 16   |\n\n```\nx=1..6$2:3;\ny=6..1$2:3;\nx;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 3    | 5    |\n| 2    | 4    | 6    |\n\n```\ny;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 6    | 4    | 2    |\n| 5    | 3    | 1    |\n\n```\neach(**, x, y);\n// output\n[16,24,16]\n// e.g., 24=3*4+4*3\n```\n\nWhen there are multiple objects passed in as *args / X / Y*, the function takes the element at the same position from each object as arguments for each calculation.\n\n```\nm1 = matrix(1 3 6, 4 6 8, 5 -1 3)\nm2 = matrix(3 -6 0, 2 NULL 3, 6 7 9)\neach(corr, m1, m2)\n// equal to corr(m1[0], m2[0]) join corr(m1[1], m2[1]) join corr(m1[2], m2[2])\n// output\n[-0.216777, 1, -0.142857]\n```\n\n*each* supports dictionary:\n\n```\nd=dict(`a`b`c, [[1, 2, 3],[4, 5, 6], [7, 8, 9]])\neach(sum, d)\n// output\nb->15\nc->24\na->6\n```\n\nWhen *func* is a user-defined function that operates on dictionaries whose keys are STRINGs, the *each* template combines each dictionary and outputs a table following these rules:\n\n* The table schema is only determined by the first dictionary whose values are appended to the first row, and keys are treated as column names. The number of keys is the number of columns.\n\n* Iterate through the remaining dictionary and append each dictionary value as a new row in the table. Specifically:\n\n  * When a dictionary key matches a column name, append the corresponding value to that column.\n\n  * For any extra keys in the dictionary that don't match columns, discard those values.\n\n  * For any extra column names without matching keys, fill in missing values as NULL.\n\n```\ndays = 2023.01.01..2023.01.10\ndef mf(day) {  \n    out = dict(STRING, ANY)\n    if(day==2023.01.05){\n        out[\"v\"] = 3\n    }\n    else{\n        out[\"day\"] = day\n        out[\"v\"] = 1\n    }\n    return out\n}\neach(mf, days)\n// output\nv   day\n1   2023.01.01\n1   2023.01.02\n1   2023.01.03\n1   2023.01.04\n3\n1   2023.01.06\n1   2023.01.07\n1   2023.01.08\n1   2023.01.09\n1   2023.01.10\n```\n\nSince version 2.00.12/3.00.0, when *args* contain a dictionary, the `each` function can be applied to a function with more than one arguments with the dictionary as the first argument.\n\nFor example, for each value of column \"id\", use function `sumbars` to calculate the cumulative sum in the backward direction until the value is no smaller than 3. For each value of column \"id2\", calculate the cumulative sum in the backward direction until the value is no smaller than 5. Since `sumbars` is applied to each column with a different *Y* (3 and 5, respectively), a binary function must be used with `each`. The first parameter is a dictionary converted by function `transpose`, with column names as keys and column values as values. Function `sumbars` will be applied to each value of keys \"id\" and \"id2\". Subsequently, the result is converted back into a table format using the `transpose` function.\n\n```\nt = table(1..10 as id, 2..11 as id2)\nsumbars:E(t.transpose(), 3 5).transpose()\n```\n\n| id | id2 |\n| -- | --- |\n| 0  | 0   |\n| 2  | 2   |\n| 1  | 2   |\n| 1  | 1   |\n| 1  | 1   |\n| 1  | 1   |\n| 1  | 1   |\n| 1  | 1   |\n| 1  | 1   |\n| 1  | 1   |\n\nIn the example below, we use the function `call` in a partial application that applies each of `[sin, log]` to vector 1..3\n\n```\n// when \"functionName\" is empty, it will be filled with function names dynamically.\neach(call{, 1..3},(sin,log));\n```\n\n| sin      | log      |\n| -------- | -------- |\n| 0.841471 | 0        |\n| 0.909297 | 0.693147 |\n| 0.14112  | 1.098612 |\n\n#### Performance Tips\n\n* Template `peach` is recommended for tasks that take a long time to execute.\n\n  ```\n  m=rand(1,20000:5000)\n  timer f=peach(mskew{,8},m)\n  Time elapsed: 3134.71 ms\n\n  timer f=mskew(m,8)\n  Time elapsed: 8810.485 ms\n  ```\n\n* Template `:E (each)` is not recommended when there is a large number of elements. In those scenarios we should look for more efficient vector solutions.\n\n  ```\n  x=rand(16, 1000000);\n  timer(10){each(wage, x)};\n  Time elapsed: 38164.9 ms\n\n  timer(10){iif(x<8,10*x,20*x-80)};\n  Time elapsed: 81.516 ms\n  ```\n\n"
    },
    "eachLeft": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/eachLeft.html",
        "signatures": [
            {
                "full": "eachLeft(func, X, Y, [consistent=false])",
                "name": "eachLeft",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "func:L(X, Y)",
                "name": "func:L",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            },
            {
                "full": "func:LC(X, Y)",
                "name": "func:LC",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [eachLeft](https://docs.dolphindb.com/en/Functions/Templates/eachLeft.html)\n\n\n\n#### Syntax\n\neachLeft(func, X, Y, \\[consistent=false])\n\nor\n\nX \\<operator>:L Y (when  = false)\n\nor\n\nX \\<operator>:LC Y (when  = true)\n\nor\n\nfunc:L(X, Y) (when  = false)\n\nor\n\nfunc:LC(X, Y) (when  = true)\n\n#### Arguments\n\n**func** is a binary function.\n\n**X**/ **Y** is a vector/matrix/table/array vector/dictionary.\n\n**consistent** is a Boolean value. The default value is false, indicating that the data type of the result is determined by each calculation result. Otherwise, the data type of the result is the same as the data type of the first calculation result. Note that if the data forms of result are inconsistent, *consistent* can only be specified as false. Otherwise, an error will be reported.\n\n#### Details\n\nCalculate `func(X(i),Y)` for each element of *X*.\n\n* `X(i)` is each element when *X* is a vector.\n\n* `X(i)` is each column when *X* is a matrix.\n\n* `X(i)` is each row when *X* is a table.\n\n* `X(i)` is each row when *X* is an array vector.\n\n* `X(i)` is each value when *X* is a dictionary.\n\nIf *func* supports vector operation and the input is a vector, we should use the vector function/operator directly instead of the `eachLeft` template for better performance.\n\n#### Examples\n\n`eachLeft` with 2 vectors:\n\n```\nx = 4 3 2 1\ny = 3 0 6;\nx +:L y;\n```\n\n| 4  | 3 | 2 | 1 |\n| -- | - | - | - |\n| 7  | 6 | 5 | 4 |\n| 4  | 3 | 2 | 1 |\n| 10 | 9 | 8 | 7 |\n\n```\neachLeft(pow, x, y);\n```\n\n| 4    | 3   | 2  | 1 |\n| ---- | --- | -- | - |\n| 64   | 27  | 8  | 1 |\n| 1    | 1   | 1  | 1 |\n| 4096 | 729 | 64 | 1 |\n\n`eachLeft` with a vector and a matrix:\n\n```\nx=1..6$2:3;\nx;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 3    | 5    |\n| 2    | 4    | 6    |\n\n```\nx ** :L 1 1;\n// output\n[3,7,11]\n```\n\n`eachLeft` with 2 matrices:\n\n```\ny=6..1$2:3;\ny;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 6    | 4    | 2    |\n| 5    | 3    | 1    |\n\n```\nz = x **:L y;\nz;\n\n// output\n(#0 #1 #2\n-- -- --\n16 10 4\n,#0 #1 #2\n-- -- --\n38 24 10\n,#0 #1 #2\n-- -- --\n60 38 16\n)\n```\n\n```\ntypestr z;\nANY VECTOR\n```\n\n`eachLeft` with a dictionary and a vector:\n\n```\nd=dict(`a`b`c, [[1, 2, 3],[4, 5, 6], [7, 8, 9]])\neachLeft(add,d,10 20 30)\n// output\na->[11,22,33]\nb->[14,25,36]\nc->[17,28,39]\n```\n"
    },
    "eachPost": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/eachPost.html",
        "signatures": [
            {
                "full": "eachPost(func, X, [post], [consistent=false])",
                "name": "eachPost",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[post]",
                        "name": "post",
                        "optional": true
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "func:O(X, [post])",
                "name": "func:O",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[post]",
                        "name": "post",
                        "optional": true
                    }
                ]
            },
            {
                "full": "func:OC(X, [post])",
                "name": "func:OC",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[post]",
                        "name": "post",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [eachPost](https://docs.dolphindb.com/en/Functions/Templates/eachPost.html)\n\n\n\n#### Syntax\n\neachPost(func, X, \\[post], \\[consistent=false])\n\nor\n\nX \\<operator>:O \\[post] (when  = false)\n\nor\n\nX \\<operator>:OC \\[post] (when  = true)\n\nor\n\nfunc:O(X, \\[post]) (when  = false)\n\nor\n\nfunc:OC(X, \\[post]) (when  = true)\n\n#### Arguments\n\n**func** is a binary function.\n\n**X** is a vector/matrix/table. When *X* is a matrix, *post* must be a scalar or vector; when *X* is a table, *post* must be a scalar or table. When *post* is absent, the first element in the result would be NULL.\n\n**consistent** is a Boolean value. The default value is false, indicating that the data type of the result is determined by each calculation result. Otherwise, the data type of the result is the same as the data type of the first calculation result. Note that if the data forms of result are inconsistent, *consistent* can only be specified as false. Otherwise, an error will be reported.\n\n#### Details\n\nApply *func* over all pairs of consecutive elements of the object. It is equivalent to: `F(X[0], X[1]), F(X[1], X[2]), ..., F(X[n], post)`.\n\n#### Examples\n\n```\nx=1..10;\neachPost(sub, x);\n// output\n[-1,-1,-1,-1,-1,-1,-1,-1,-1,]\n// equivalent to [1-2, 2-3, ..., 9-10, NULL]\n\n+:O x;\n// output\n[3,5,7,9,11,13,15,17,19,]\n// equivalent to [1+2, 2+3, ..., 9+10, NULL]\n\nx +:O 0;\n// output\n[3,5,7,9,11,13,15,17,19,10]\n// equivalent to [1+2, 2+3, ..., 9+10, 10+0]\n\nx=1..12$3:4;\nx;\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 1    | 4    | 7    | 10   |\n| 2    | 5    | 8    | 11   |\n| 3    | 6    | 9    | 12   |\n\n```\n-:O x;\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| -3   | -3   | -3   |      |\n| -3   | -3   | -3   |      |\n| -3   | -3   | -3   |      |\n\n```\neachPost(\\, x, x[0]);\n```\n\n| col1 | col2     | col3     | col4 |\n| ---- | -------- | -------- | ---- |\n| 0.25 | 0.571429 | 0.7      | 10   |\n| 0.4  | 0.625    | 0.727273 | 5.5  |\n| 0.5  | 0.666667 | 0.75     | 4    |\n\n```\ndef f1(a,b){\n    return (a[`x])+(a[`y])+(b[`x])+(b[`y])\n}\n\nt = table(1 2 3 as x,2 3 4 as y)\nt1 = table(1 as x,2 as y)\neachPost(f1,t,t1)\n// output\n(8,12,[10])\n```\n"
    },
    "eachPre": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/eachPre.html",
        "signatures": [
            {
                "full": "eachPre(func, X, [pre], [consistent=false])",
                "name": "eachPre",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[pre]",
                        "name": "pre",
                        "optional": true
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "func:P([pre], X)",
                "name": "func:P",
                "parameters": [
                    {
                        "full": "[pre]",
                        "name": "pre",
                        "optional": true
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            },
            {
                "full": "func:PC([pre], X)",
                "name": "func:PC",
                "parameters": [
                    {
                        "full": "[pre]",
                        "name": "pre",
                        "optional": true
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [eachPre](https://docs.dolphindb.com/en/Functions/Templates/eachPre.html)\n\n\n\n#### Syntax\n\neachPre(func, X, \\[pre], \\[consistent=false])\n\nor\n\n\\[pre] \\<operator>:P X (when  = false)\n\nor\n\n\\[pre] \\<operator>:PC X (when  = true)\n\nor\n\nfunc:P(\\[pre], X) (when  = false)\n\nor\n\nfunc:PC(\\[pre], X) (when  = true)\n\n#### Arguments\n\n**func** is a binary function.\n\n**X** is a vector/matrix/table. When *X* is a matrix, *pre* must be a scalar or vector; when *X* is a table, *pre* must be a scalar or table. When *pre* is absent, the first element in the result would be NULL.\n\n**consistent** is a Boolean value. The default value is false, indicating that the data type of the result is determined by each calculation result. Otherwise, the data type of the result is the same as the data type of the first calculation result. Note that if the data forms of result are inconsistent, *consistent* can only be specified as false. Otherwise, an error will be reported.\n\n#### Details\n\nApply *func* over all pairs of consecutive elements of *X*. It is equivalent to: `F(X[0], pre), F(X[1], X[0]), ..., F(X[n], X[n-1])`.\n\nThe built-in functions [ratios](https://docs.dolphindb.com/en/Functions/r/ratios.html) and [deltas](https://docs.dolphindb.com/en/Functions/d/deltas.html) are also implemented by the `eachPre` template. They are defined as:\n\n* `function deltas(a){return a[0] -:P a}`\n\n* `function ratios(a){return a[0] :P a}`\n\n#### Examples\n\n```\nx=1..10;\n\neachPre(sub, x);\n// output\n[,1,1,1,1,1,1,1,1,1]\n// equivalent to [NULL, 2-1, ..., 10-9]\n\n-:P x;\n// output\n[,1,1,1,1,1,1,1,1,1]\n// same as above\n\neachPre(+, x);\n// output\n[,3,5,7,9,11,13,15,17,19]\n// equivalent to [NULL, 2+1, ..., ]\n\n0 +:P x;\n// output\n[1,3,5,7,9,11,13,15,17,19]\n// equivalent to [1+0, 2+1, ..., ]\n\nx=1..12$3:4;\n// output\nx;\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 1    | 4    | 7    | 10   |\n| 2    | 5    | 8    | 11   |\n| 3    | 6    | 9    | 12   |\n\n```\n- :P x;\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n|      | 3    | 3    | 3    |\n|      | 3    | 3    | 3    |\n|      | 3    | 3    | 3    |\n\n```\neachPre(\\, x, x[0]);\n```\n\n| col1 | col2 | col3 | col4     |\n| ---- | ---- | ---- | -------- |\n| 1    | 4    | 1.75 | 1.428571 |\n| 1    | 2.5  | 1.6  | 1.375    |\n| 1    | 2    | 1.5  | 1.333333 |\n\n```\ndef f1(a,b){\n    return (a[`x])+(a[`y])+(b[`x])+(b[`y])\n}\n\nt = table(1 2 3 as x,2 3 4 as y)\nt1 = table(1 as x,2 as y)\neachPre(f1,t,t1)\n\n// output\n([6],8,12)\n```\n"
    },
    "eachRight": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/eachRight.html",
        "signatures": [
            {
                "full": "eachRight(func, X, Y, [consistent=false])",
                "name": "eachRight",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "func:R(X, Y)",
                "name": "func:R",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            },
            {
                "full": "func:RC(X, Y)",
                "name": "func:RC",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [eachRight](https://docs.dolphindb.com/en/Functions/Templates/eachRight.html)\n\n\n\n#### Syntax\n\neachRight(func, X, Y, \\[consistent=false])\n\nor\n\nX \\<operator>:R Y (when  = false)\n\nor\n\nX \\<operator>:RC Y (when  = true)\n\nor\n\nfunc:R(X, Y) (when  = false)\n\nor\n\nfunc:RC(X, Y) (when  = true)\n\n#### Arguments\n\n**func** is a binary function.\n\n**X**/ **Y** is a vector/matrix/table/array vector/dictionary.\n\n**consistent** is a Boolean value. The default value is false, indicating that the data type of the result is determined by each calculation result. Otherwise, the data type of the result is the same as the data type of the first calculation result. Note that if the data forms of result are inconsistent, *consistent* can only be specified as false. Otherwise, an error will be reported.\n\n#### Details\n\nCalculate `func(X, Y(i))` for each element of *Y*.\n\n* `Y(i)` is each element when *Y* is a vector.\n\n* `Y(i)` is each column when *Y* is a matrix.\n\n* `Y(i)` is each row when *Y* is a table.\n\n* `Y(i)` is each row when *Y* is an array vector.\n\n* `Y(i)` is each value when *Y* is a dictionary.\n\nIf the function/operator supports vector operation and the input itself is a vector, we should avoid the `eachRight` template and use the vector function/operator directly instead for better performance.\n\n#### Examples\n\n`eachRight` with 2 vectors:\n\n```\nx = 4 3 2 1\ny = 3 0 6;\neachRight(add, x, y);\n```\n\n| 3 | 0 | 6  |\n| - | - | -- |\n| 7 | 4 | 10 |\n| 6 | 3 | 9  |\n| 5 | 2 | 8  |\n| 4 | 1 | 7  |\n\n```\nx pow :R y;\n```\n\n| 3  | 0 | 6    |\n| -- | - | ---- |\n| 64 | 1 | 4096 |\n| 27 | 1 | 729  |\n| 8  | 1 | 64   |\n| 1  | 1 | 1    |\n\n`eachRight` with a matrix and a vector:\n\n```\nx=1..6$2:3;\nx;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 3    | 5    |\n| 2    | 4    | 6    |\n\n```\n1 1 ** :R x;\n// output\n[3,7,11]\n```\n\n`eachRight` with 2 matrices:\n\n```\ny=6..1$3:2;\ny;\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 6    | 3    |\n| 5    | 2    |\n| 4    | 1    |\n\n```\neachRight(**, x, y);\n// output\n(#0\n--\n41\n56\n,#0\n--\n14\n20\n)\n```\n\n`eachRight` with a dictionary and a vector:\n\n```\nd=dict(`a`b`c, [[1, 2, 3],[4, 5, 6], [7, 8, 9]])\neachRight(add,10 20 30,d)\n// output\na->[11,22,33]\nb->[14,25,36]\nc->[17,28,39]\n```\n"
    },
    "groupby": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/groupby.html",
        "signatures": [
            {
                "full": "groupby(func, funcArgs, groupingCol)",
                "name": "groupby",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "groupingCol",
                        "name": "groupingCol"
                    }
                ]
            },
            {
                "full": "func:G(funcArgs, groupingCol)",
                "name": "func:G",
                "parameters": [
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "groupingCol",
                        "name": "groupingCol"
                    }
                ]
            }
        ],
        "markdown": "### [groupby](https://docs.dolphindb.com/en/Functions/Templates/groupby.html)\n\n\n\n#### Syntax\n\ngroupby(func, funcArgs, groupingCol)\n\nor\n\nfuncArg func:G groupingCol\n\nor\n\nfunc:G(funcArgs, groupingCol)\n\n#### Arguments\n\n**func** is a function. For the second use case, *func* can only have one parameter (*funcArg*).\n\n**funcArgs** is a vector or a tuple with multiple vectors specifying the arguments of *func*.\n\n**groupingCol** is a vector or a tuple with vectors of the same length indicating the grouping column(s). A grouping column and each argument in *funcArgs*are vectors of the same size.\n\n#### Details\n\nFor each group, calculate `func(funcArgs)` and return a scalar/vector/dictionary.\n\n**Return value**: A table, where the number of rows is the same as the number of groups.\n\n#### Examples\n\n```\nsym=`IBM`IBM`IBM`MS`MS`MS$symbol;\nprice=172.12 170.32 175.25 26.46 31.45 29.43;\nqty=5800 700 9000 6300 2100 5300;\ntrade_date=2013.05.08 2013.05.06 2013.05.07 2013.05.08 2013.05.06 2013.05.07;\ngroupby(avg, price, sym);\n```\n\n| sym | avg\\_price |\n| --- | ---------- |\n| IBM | 172.563333 |\n| MS  | 29.113333  |\n\n```\nprice avg :G sym;\n```\n\n| sym | avg\\_price |\n| --- | ---------- |\n| IBM | 172.563333 |\n| MS  | 29.113333  |\n\n```\n// calculate the weighted average price of each stock\ngroupby(wavg, [price, qty], sym);\n```\n\n| sym | avg\\_price |\n| --- | ---------- |\n| IBM | 173.856129 |\n| MS  | 28.373869  |\n\n```\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C$SYMBOL\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\n\ngroupby(max, price, [sym,minute(timestamp)])\n```\n\n| sym | groupingKey | max\\_price |\n| --- | ----------- | ---------- |\n| C   | 09:34m      | 50.76      |\n| C   | 09:38m      | 51.29      |\n| IBM | 09:32m      | 174.97     |\n| IBM | 09:35m      | 175.23     |\n| MS  | 09:36m      | 30.02      |\n"
    },
    "loop": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/loop.html",
        "signatures": [
            {
                "full": "loop(func, args...)",
                "name": "loop",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            },
            {
                "full": "func:U(args…)",
                "name": "func:U",
                "parameters": [
                    {
                        "full": "args…",
                        "name": "args…"
                    }
                ]
            }
        ],
        "markdown": "### [loop](https://docs.dolphindb.com/en/Functions/Templates/loop.html)\n\n\n\n#### Syntax\n\nloop(func, args...)\n\nor\n\nfunc:U(args…)\n\nor\n\nfunc:U X\n\nor\n\nX func:U Y\n\n#### Arguments\n\n**func** is a function.\n\n**args/X/Y** are the required parameters of *func*.\n\n#### Details\n\nThe `loop` template is very similar to the `each` template. Their difference is about the data form and data type of the function call results.\n\n* For the `each` template, the data types and forms of the return value are determined by each calculation result. It returns a vector or matrix if all calculation results have the same data type and form, otherwise it returns a tuple.\n\n* The `loop` template always returns a tuple.\n\n#### Examples\n\nUse a matrix as the input.\n\n```\nm=matrix([1 3 4 2,1 2 2 1])\nmax:U(m) \n// output\n(4,2)\nn=matrix([11 5 9 2,8 5 3 2])\nm add:U n\n// output\n([12,8,13,4],[9,7,5,3])\n```\n\nUse an array vector as the input.\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5 4, 6 7 8, 1 9 10]);\nsum:U(a)\n// output\n(6,9,21,19)\n```\n\nUse `loop` to convert a vector to a tuple.\n\n```\na=[1,2,3,4,5]\nasis:U(a)\n// output\n(1,2,3,4,5)\n```\n"
    },
    "moving": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/moving.html",
        "signatures": [
            {
                "full": "moving(func, funcArgs, window, [minPeriods])",
                "name": "moving",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [moving](https://docs.dolphindb.com/en/Functions/Templates/moving.html)\n\n\n\n#### Syntax\n\nmoving(func, funcArgs, window, \\[minPeriods])\n\n#### Arguments\n\n**func** is an aggregate function.\n\n**Note:** When using this parameter, the keyword used to define the corresponding aggregation function is `defg`. For details, refer to [Tutorial: User Defined Aggregate Functions](https://docs.dolphindb.com/en/Tutorials/udaf.html).\n\n**funcArgs** are the parameters of *func*. They can be vectors/dictionaries/tables/matrices. It is a tuple if there are more than one parameter of *func*, and all parameters must have the same size.\n\n**window** is the moving window size.\n\n**minPeriods** is a positive integer indicating the minimum number of observations in a window in order to generate a result. The default value is the value of *window*.\n\n#### Details\n\nApply the function/operator to a moving window of the given objects.\n\nThe `moving` template always returns a vector with the same number of elements as the number of rows in the input arguments. It starts calculating when the moving window size is reached for the first time, and the moving window is always shifted by 1 element to the right thereafter.\n\nEach of the built-in moving functions such as [msum](https://docs.dolphindb.com/en/Functions/m/msum.html), [mcount](https://docs.dolphindb.com/en/Functions/m/mcount.html) and [mavg](https://docs.dolphindb.com/en/Functions/m/mavg.html) is optimized for its specific task. Therefore, they have much better performance than the `moving` template.\n\n#### Examples\n\nCalculate the moving beta of AAPL against the market (SPY) with a 10-day moving window.\n\n```\ndate=2016.08.01..2016.08.31\ndate=date[1<=weekday(date)<=5]\naaplRet=0.0177 -0.0148 0.0125 0.0008 0.0152 0.0083 0.0041 -0.0074 -0.0006 0.0023 0.0120 -0.0009 -0.0015 -0.0013 0.0026 -0.0078 0.0031 -0.0075 -0.0043 -0.0059 -0.0011 -0.0077 0.0009\nspyRet=-0.0008 -0.0064 0.0029 0.0011 0.0082 -0.0006 0.0006 -0.0025 0.0046 -0.0009 0.0029 -0.0052 0.0019 0.0022 -0.0015 0.0000 0.0020 -0.0051 -0.0007 -0.0019 0.0049 -0.0016 -0.0028\nt=table(date, aaplRet, spyRet);\nt;\n```\n\n| date       | aaplRet | spyRet  |\n| ---------- | ------- | ------- |\n| 2016.08.01 | 0.0177  | -0.0008 |\n| 2016.08.02 | -0.0148 | -0.0064 |\n| 2016.08.03 | 0.0125  | 0.0029  |\n| 2016.08.04 | 0.0008  | 0.0011  |\n| 2016.08.05 | 0.0152  | 0.0082  |\n| 2016.08.08 | 0.0083  | -0.0006 |\n| 2016.08.09 | 0.0041  | 0.0006  |\n| 2016.08.10 | -0.0074 | -0.0025 |\n| 2016.08.11 | -0.0006 | 0.0046  |\n| 2016.08.12 | 0.0023  | -0.0009 |\n| 2016.08.15 | 0.012   | 0.0029  |\n| 2016.08.16 | -0.0009 | -0.0052 |\n| 2016.08.17 | -0.0015 | 0.0019  |\n| 2016.08.18 | -0.0013 | 0.0022  |\n| 2016.08.19 | 0.0026  | -0.0015 |\n| 2016.08.22 | -0.0078 | 0       |\n| 2016.08.23 | 0.0031  | 0.002   |\n| 2016.08.24 | -0.0075 | -0.0051 |\n| 2016.08.25 | -0.0043 | -0.0007 |\n| 2016.08.26 | -0.0059 | -0.0019 |\n| 2016.08.29 | -0.0011 | 0.0049  |\n| 2016.08.30 | -0.0077 | -0.0016 |\n| 2016.08.31 | 0.0009  | -0.0028 |\n\n```\n// calculate moving beta\nupdate t set beta=moving(beta, [aaplRet, spyRet],10);\nt;\n```\n\n| date       | aaplRet | spyRet  | beta     |\n| ---------- | ------- | ------- | -------- |\n| 2016.08.01 | 0.0177  | -0.0008 |          |\n| 2016.08.02 | -0.0148 | -0.0064 |          |\n| 2016.08.03 | 0.0125  | 0.0029  |          |\n| 2016.08.04 | 0.0008  | 0.0011  |          |\n| 2016.08.05 | 0.0152  | 0.0082  |          |\n| 2016.08.08 | 0.0083  | -0.0006 |          |\n| 2016.08.09 | 0.0041  | 0.0006  |          |\n| 2016.08.10 | -0.0074 | -0.0025 |          |\n| 2016.08.11 | -0.0006 | 0.0046  |          |\n| 2016.08.12 | 0.0023  | -0.0009 | 1.601173 |\n| 2016.08.15 | 0.012   | 0.0029  | 1.859846 |\n| 2016.08.16 | -0.0009 | -0.0052 | 1.248804 |\n| 2016.08.17 | -0.0015 | 0.0019  | 1.114282 |\n| 2016.08.18 | -0.0013 | 0.0022  | 1.064296 |\n| 2016.08.19 | 0.0026  | -0.0015 | 0.512656 |\n| 2016.08.22 | -0.0078 | 0       | 0.614963 |\n| 2016.08.23 | 0.0031  | 0.002   | 0.642491 |\n| 2016.08.24 | -0.0075 | -0.0051 | 0.70836  |\n| 2016.08.25 | -0.0043 | -0.0007 | 0.977279 |\n| 2016.08.26 | -0.0059 | -0.0019 | 1.064465 |\n| 2016.08.29 | -0.0011 | 0.0049  | 0.422221 |\n| 2016.08.30 | -0.0077 | -0.0016 | 0.793236 |\n| 2016.08.31 | 0.0009  | -0.0028 | 0.588027 |\n\nAbout the role of *minPeriods* :\n\n```\nmoving(avg, 1..4, 3);\n// output\n[,,2,3]\n\nmoving(avg, 1..4, 3, 1);\n// output\n[1,1.5,2,3]\n```\n\nIf the function used in the moving template has multiple parameters, they must have the same size. For functions with parameters of different sizes, such as [percentile](https://docs.dolphindb.com/en/Functions/p/percentile.html), we can use [PartialApplication](https://docs.dolphindb.com/en/Programming/FunctionalProgramming/PartialApplication.html) to generate a new function. Please see the example below:\n\n```\nmoving(percentile{,50},1..20, 10);\n// output\n[,,,,,,,,,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5]\n```\n\n#### Performance Tip\n\nWhen we calculate moving averages, we should use the built-in function of `mavg` instead of the moving template, as the built-in functions are optimized and run faster than template functions.\n\n```\nn=1000000\nx=norm(0,1, n);\ntimer mavg(x, 10);\nTime elapsed: 3.501ms\n\ntimer moving(avg, x, 10);\nTime elapsed: 976.03ms\n```\n"
    },
    "nullCompare": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/nullCompare.html",
        "signatures": [
            {
                "full": "nullCompare(func, X, Y)",
                "name": "nullCompare",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [nullCompare](https://docs.dolphindb.com/en/Functions/Templates/nullCompare.html)\n\n\n\n#### Syntax\n\nnullCompare(func, X, Y)\n\n#### Arguments\n\n**func** is the operator `<`, `>`, `>=`, `<=`, or the function `between`, `in`.\n\n**X** and **Y** can be scalars, pairs, vectors, matrices, or sets. If both *X* and *Y* are vectors or matrices, they must be of the same length or dimension.\n\n**Note:**\n\n*X* and *Y* do not support the following data types currently: STRING, SYMBOL, IPADDR, UUID, BLOB, INT128.\n\n#### Details\n\nReturn a Boolean value which is the result of `func(X,Y)`. Return NULL if the calculation involves NULL values. This function is not affected by the configuration paramter *nullAsMinValueForComparison*.\n\n#### Examples\n\nWhen *nullAsMinValueForComparison*=true, a NULL value is treated as the minimum value in data comparison. Function `nullCompare`, however, returns NULL values, which is not affected by the configuration paramter *nullAsMinValueForComparison*.\n\n```\nNULL < 3\n# output\ntrue\n\nnullCompare(<, NULL, 3)\n# output\nNULL\n\n```\n\n```\n\nm1=matrix(1 2 NULL, NULL 8 4, 4 7 2 )\nm2 = 1..9$3:3\nm1>m2\n```\n\n| col1  | col2  | col3  |\n| ----- | ----- | ----- |\n| false | false | false |\n| false | true  | false |\n| false | false | false |\n\n```\nnullCompare(>,m1,m2)\n```\n\n| col1  | col2  | col3  |\n| ----- | ----- | ----- |\n| false |       | false |\n| false | true  | false |\n|       | false | false |\n\n```\nnullCompare(between, 4 5 NULL, 4:9)\n# output\n[1,1,]\n```\n"
    },
    "pcall": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/pcall.html",
        "signatures": [
            {
                "full": "pcall(func, args...)",
                "name": "pcall",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [pcall](https://docs.dolphindb.com/en/Functions/Templates/pcall.html)\n\n\n\n#### Syntax\n\npcall(func, args...)\n\n#### Arguments\n\n**func** is an aggregate function. The output of the function must be a vector or a table with the same length as all vectors or table columns in *args*.\n\n**args** are the arguments of *func*. Each argument must be a table, a vector or a tuple of vectors. All the vectors or table columns in *args* must have the same length.\n\n#### Details\n\nConduct parallel computing of a vector function. `pcall` divides each argument into multiple parts and conducts the calculation in parallel. If the length of the vectors or table columns of the input variables is less than 100,000, `pcall` will not conduct the calculation in parallel.\n\n#### Examples\n\n```\nx = rand(1.0, 10000000);\ntimer(10) sin(x);\nTime elapsed: 739.561 ms\n\ntimer(10) pcall(sin, x);\nTime elapsed: 404.56 ms\n```\n"
    },
    "pcross": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/pcross.html",
        "signatures": [
            {
                "full": "pcross(func, X, [Y])",
                "name": "pcross",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [pcross](https://docs.dolphindb.com/en/Functions/Templates/pcross.html)\n\n\n\n#### Syntax\n\npcross(func, X, \\[Y])\n\npcross is the parallel computing version of template function cross .\n"
    },
    "peach": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/peach.html",
        "signatures": [
            {
                "full": "peach(func, args...)",
                "name": "peach",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [peach](https://docs.dolphindb.com/en/Functions/Templates/peach.html)\n\n\n\n#### Syntax\n\npeach(func, args...)\n\n#### Details\n\n`peach` is the parallel computing version of template function `each`. For tasks that take a long time to finish, `peach` can save a significant amount of time over `each`. For light tasks, however, `peach` may take longer than `each` as the overhead of parallel function call is not trivial.\n\nRefer to [DistributedComputing](https://docs.dolphindb.com/en/Database/DatabaseandDistributedComputing/DistributedComputing.html) for the details of Parallel Function Call.\n\n#### Examples\n\n```\nm=rand(1,20000:5000)\ntimer f=peach(mskew{,8},m)\nTime elapsed: 3134.71 ms\n\ntimer f=mskew(m,8)\nTime elapsed: 8810.485 ms\n```\n"
    },
    "pivot": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/pivot.html",
        "signatures": [
            {
                "full": "pivot(func, funcArgs, rowAlignCol, colAlignCol)",
                "name": "pivot",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "rowAlignCol",
                        "name": "rowAlignCol"
                    },
                    {
                        "full": "colAlignCol",
                        "name": "colAlignCol"
                    }
                ]
            }
        ],
        "markdown": "### [pivot](https://docs.dolphindb.com/en/Functions/Templates/pivot.html)\n\n\n\n#### Syntax\n\npivot(func, funcArgs, rowAlignCol, colAlignCol)\n\n#### Arguments\n\n**func** is an aggregate function.\n\n**funcArgs** are the parameters of *func*. It is a tuple if there are more than 1 parameter of *func*.\n\n**rowAlignCol** is the grouping variable for the rows of the result.\n\n**colAlignCol** is the grouping variable for the columns of the result.\n\n*rowAlignCol*, *colAlignCol*, and each of the function argument in *funcArgs* are vectors of the same size.\n\n#### Details\n\nRearrange the results of an aggregate function as a matrix.\n\nAssume *rowAlignCol* has n unique elements and *colAlignCol* has m unique elements. The template will return an *n* (row) by m (column) matrix, with unique values of *rowAlignCol* as row labels and unique values of *colAlignCol* as column labels. For each element of the matrix, the given function is applied conditional on *rowAlignCol* and *colAlignCol* equal to corresponding values indicated by the cell's row and column labels.\n\n#### Examples\n\nA trader needs to calculate the volume-weighted average prices (vwap) for each stock in every minute, and the pair-wise correlations of stock returns based on the vwap price series. The data are in a table with 4 columns: sym, price, qty, and trade\\_time.\n\nWe first use the `pivot` template to pivot the data to a vwap price matrix with the time as row label and the stock symbol as column label. Then we use the [cross](https://docs.dolphindb.com/en/Functions/Templates/cross.html) template to calculate the pairwise correlation.\n\n```\nsyms=`600300`600400`600500$SYMBOL\nsym=syms[0 0 0 0 0 0 0 1 1 1 1 1 1 1 2 2 2 2 2 2 2]\ntime=09:40:00+1 30 65 90 130 185 195 10 40 90 140 160 190 200 5 45 80 140 170 190 210\nprice=172.12 170.32 172.25 172.55 175.1 174.85 174.5 36.45 36.15 36.3 35.9 36.5 37.15 36.9 40.1 40.2 40.25 40.15 40.1 40.05 39.95\nvolume=100 * 10 3 7 8 25 6 10 4 5 1 2 8 6 10 2 2 5 5 4 4 3\nt1=table(sym, time, price, volume);\nt1;\n```\n\n| sym    | time     | price  | volume |\n| ------ | -------- | ------ | ------ |\n| 600300 | 09:40:01 | 172.12 | 1000   |\n| 600300 | 09:40:30 | 170.32 | 300    |\n| 600300 | 09:41:05 | 172.25 | 700    |\n| 600300 | 09:41:30 | 172.55 | 800    |\n| 600300 | 09:42:10 | 175.1  | 2500   |\n| 600300 | 09:43:05 | 174.85 | 600    |\n| 600300 | 09:43:15 | 174.5  | 1000   |\n| 600400 | 09:40:10 | 36.45  | 400    |\n| 600400 | 09:40:40 | 36.15  | 500    |\n| 600400 | 09:41:30 | 36.3   | 100    |\n| 600400 | 09:42:20 | 35.9   | 200    |\n| 600400 | 09:42:40 | 36.5   | 800    |\n| 600400 | 09:43:10 | 37.15  | 600    |\n| 600400 | 09:43:20 | 36.9   | 1000   |\n| 600500 | 09:40:05 | 40.1   | 200    |\n| 600500 | 09:40:45 | 40.2   | 200    |\n| 600500 | 09:41:20 | 40.25  | 500    |\n| 600500 | 09:42:20 | 40.15  | 500    |\n| 600500 | 09:42:50 | 40.1   | 400    |\n| 600500 | 09:43:10 | 40.05  | 400    |\n| 600500 | 09:43:30 | 39.95  | 300    |\n\nAlign the data on the dimensions of time and sym, and calculate the vwap price for every minute in each minute:\n\n```\nstockprice=pivot(wavg, [t1.price, t1.volume], minute(t1.time), t1.sym)\nstockprice.round(2);\n```\n\n| label  | 600300 | 600400 | 600500 |\n| ------ | ------ | ------ | ------ |\n| 09:40m | 171.7  | 36.28  | 40.15  |\n| 09:41m | 172.41 | 36.3   | 40.25  |\n| 09:42m | 175.1  | 36.38  | 40.13  |\n| 09:43m | 174.63 | 36.99  | 40.01  |\n\nThe step above can also use the following SQL statement to get the same result:\n\n```\nstockreturn = each(ratios, stockprice)-1\nstockreturn;\n```\n\n| label  | 600300    | 600400   | 600500    |\n| ------ | --------- | -------- | --------- |\n| 09:40m |           |          |           |\n| 09:41m | 0.004108  | 0.000459 | 0.002491  |\n| 09:42m | 0.015602  | 0.002204 | -0.003037 |\n| 09:43m | -0.002677 | 0.016871 | -0.003006 |\n\nCalculate stock returns in each minute:\n\n```\ncross(corr, stockreturn, stockreturn);\n```\n\n| label  | 600300    | 600400    | 600500    |\n| ------ | --------- | --------- | --------- |\n| 600300 | 1         | -0.719182 | -0.151824 |\n| 600400 | -0.719182 | 1         | -0.577578 |\n| 600500 | -0.151824 | -0.577578 | 1         |\n\nCalculate pair-wise correlation:\n\n```\npivot(count, price, minute(time), sym);\n```\n\n| label  | 600300 | 600400 | 600500 |\n| ------ | ------ | ------ | ------ |\n| 09:40m | 2      | 2      | 2      |\n| 09:41m | 2      | 1      | 1      |\n| 09:42m | 1      | 2      | 2      |\n| 09:43m | 2      | 2      | 2      |\n\nCount the number of observations within each minute for each stock:\n\n```\npivot(last, price, minute(time), sym);\n```\n\n| label  | 600300 | 600400 | 600500 |\n| ------ | ------ | ------ | ------ |\n| 09:40m | 170.32 | 36.15  | 40.2   |\n| 09:41m | 172.55 | 36.3   | 40.25  |\n| 09:42m | 175.1  | 36.5   | 40.1   |\n| 09:43m | 174.5  | 36.9   | 39.95  |\n"
    },
    "ploop": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/ploop.html",
        "signatures": [
            {
                "full": "ploop(func, args...)",
                "name": "ploop",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [ploop](https://docs.dolphindb.com/en/Functions/Templates/ploop.html)\n\n\n\n#### Syntax\n\nploop(func, args...)\n\nploop is the parallel computing version of template function loop . Refer to  for the details of Parallel Function Call.\n"
    },
    "reduce": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/reduce.html",
        "signatures": [
            {
                "full": "reduce(func, X, [init], [consistent=false])",
                "name": "reduce",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "reduce:T(X, [init])",
                "name": "reduce:T",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    }
                ]
            },
            {
                "full": "reduce:TC(X, [init])",
                "name": "reduce:TC",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [reduce](https://docs.dolphindb.com/en/Functions/Templates/reduce.html)\n\n\n\n#### Syntax\n\nreduce(func, X, \\[init], \\[consistent=false])\n\nor\n\n\\[init] \\<operator>:T X (when  = false)\n\nor\n\n\\[init] \\<operator>:TC X (when  = true)\n\nor\n\nreduce:T(X, \\[init]) (when  = false)\n\nor\n\nreduce:TC(X, \\[init]) (when  = true)\n\n#### Arguments\n\n**func** is a function.\n\n* When *func* is a unary function, *X* can be a non-negative integer, a unary function, or a NULL value. *init* must be specified, which is the parameter of *func*.\n\n* When *func* is a binary function, *X* can be vector/matrix/table. *init* is the initial value.\n\n* When *func* is a ternary function, *X* must be a tuple with 2 elements, representing the last two parameters of *func*.\n\n**consistent** is a Boolean value. The default value is false, indicating that the data type of the result is determined by each calculation result. Otherwise, the data type of the result is the same as the data type of the first calculation result. Note that if the data forms of each result are inconsistent, *consistent* can only be specified as false. Otherwise, an error will be reported.\n\n#### Details\n\nThe function of `reduce` is the same as `accumulate`. Unlike the template `accumulate` that returns result of each iteration, the template `reduce` outputs only the last result. Refer to [accumulate](https://docs.dolphindb.com/en/Functions/Templates/accumulate.html) for more information.\n\n```\nresult=<function>(init,X[0]);\nfor(i:1~size(X)){\nresult=<function>(result, X[i]);\n}\nreturn result;\n```\n\n#### Examples\n\nWhen *func* is a unary function:\n\n```\n// define a unary function\ndef func1(x){\n  if(x<5){\n          return x*3\n  }\n  else{\n          return x+3\n  }\n}\n\n// when X is an integer, iterate for X times\nreduce(func1, 5, 1)\n// output\n18\n\n// when X is a unary function condition, the 3rd iteration stops as the condition returns false\ndef condition(x){\n  return x<9\n}\nreduce(func1, condition, 1)\n// output\n9\n\n// when X is NULL or unspecified, define a UDF func2 for iteration\ndef func2(x){\n  if(x<5){\n          return x*3\n  }\n  else{\n          return 6\n  }\n}\n\n//As the results of the 3rd and 4th iterations are the same, the function stops iteration and outputs the result\nreduce(func2,NULL,1)\n// output\n6\n```\n\nWhen *func* is a binary function, and *X* is a vector:\n\n```\nreduce(mul, 1..10);\n// factorization of 10\n3628800\n\n// the corresponding accumulate template for the operation above\n*:A 1..10;\n[1,2,6,24,120,720,5040,40320,362880,3628800]\n\n2 *:T 1..10;\n7257600\n\ndef f1(a,b):a+log(b);\nreduce(f1, 1..5, 0);\n4.787492\n```\n\n`reduce` on a matrix:\n\n```\nx=1..12$3:4;\nx;\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 1    | 4    | 7    | 10   |\n| 2    | 5    | 8    | 11   |\n| 3    | 6    | 9    | 12   |\n\n```\n+ :T x;\n// output\n[22,26,30]\n```\n\nWhen *func* is a ternary function:\n\n```\ndef fun3(x,y,z){\n  return x+y+z\n}\nreduce(fun3,[[1,2,3],[10,10,10]],5)\n// output\n41\n```\n"
    },
    "rolling": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/rolling.html",
        "signatures": [
            {
                "full": "rolling(func, funcArgs, window, [step=1])",
                "name": "rolling",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[step=1]",
                        "name": "step",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [rolling](https://docs.dolphindb.com/en/Functions/Templates/rolling.html)\n\n\n\n#### Syntax\n\nrolling(func, funcArgs, window, \\[step=1])\n\n#### Arguments\n\n**func** is an aggregate or vectorized function.\n\n**funcArgs** are the arguments passed to *func*, which can be vectors, matrices, or tables. It is a tuple if there are more than 1 parameter of *func*, and all arguments must have the same size (the number of elements of a vector or rows of a matrix).\n\n**window** is the window size.\n\n**step** (optional) is the count or interval that windows slide. The default value is 1. If *func* is a vectorized function, *step* must be equal to *window*.\n\n#### Details\n\nThe `rolling` function applies *func* to a moving window of *funcArgs*. It starts calculating when the window size is reached for the first time, then calculates with frequency specified by *step*.\n\nSimilar to the `moving` function, windows in `rolling` function are always along rows.\n\nThe differences of `rolling` and `moving` functions lie in:\n\n* The *func* parameter in `rolling` function supports aggregate or vectorized functions, whereas *func* in `moving` function only supports aggregate functions.\n\n* When *func* is specified as an aggregate function,\n\n  * *step* can be specified in `rolling` function.\n\n  * `rolling` does not return NULL values of the first (*window* -1) elements.\n\n#### Examples\n\nExample 1. When *func* is a vectorized function:\n\n```\nm = matrix(3 4 6 8 5 2 0 -2, 2 9 NULL 1 3 -4 2 1, NULL 8 9 8 0 1 9 -3)\nrolling(cummax, m, 4, 4)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 3    | 2    |      |\n| 4    | 9    | 8    |\n| 6    | 9    | 9    |\n| 8    | 9    | 9    |\n| 5    | 3    | 0    |\n| 5    | 3    | 1    |\n| 5    | 3    | 9    |\n| 5    | 3    | 9    |\n\n```\nrolling(cumsum, m, 3, 3)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 3    | 2    |      |\n| 7    | 11   | 8    |\n| 13   | 11   | 17   |\n| 8    | 1    | 8    |\n| 13   | 4    | 8    |\n| 15   | 0    | 9    |\n\nExample 2. When *func* is a aggregate function:\n\n```\nrolling(sum, m, 4)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 21   | 12   | 25   |\n| 23   | 13   | 25   |\n| 21   | 0    | 18   |\n| 15   | 2    | 18   |\n| 5    | 2    | 7    |\n\nCalculate the rolling beta of AAPL against the market (SPY) with the moving window of size 10 and frequency of 5.\n\n```\ndate=2016.08.01..2016.08.31\ndate=date[1<=weekday(date)<=5]\naaplRet=0.0177 -0.0148 0.0125 0.0008 0.0152 0.0083 0.0041 -0.0074 -0.0006 0.0023 0.0120 -0.0009 -0.0015 -0.0013 0.0026 -0.0078 0.0031 -0.0075 -0.0043 -0.0059 -0.0011 -0.0077 0.0009\nspyRet=-0.0008 -0.0064 0.0029 0.0011 0.0082 -0.0006 0.0006 -0.0025 0.0046 -0.0009 0.0029 -0.0052 0.0019 0.0022 -0.0015 0.0000 0.0020 -0.0051 -0.0007 -0.0019 0.0049 -0.0016 -0.0028\nt=table(date, aaplRet, spyRet);\nt;\n```\n\n| date       | aaplRet | spyRet  |\n| ---------- | ------- | ------- |\n| 2016.08.01 | 0.0177  | -0.0008 |\n| 2016.08.02 | -0.0148 | -0.0064 |\n| 2016.08.03 | 0.0125  | 0.0029  |\n| 2016.08.04 | 0.0008  | 0.0011  |\n| 2016.08.05 | 0.0152  | 0.0082  |\n| 2016.08.08 | 0.0083  | -0.0006 |\n| 2016.08.09 | 0.0041  | 0.0006  |\n| 2016.08.10 | -0.0074 | -0.0025 |\n| 2016.08.11 | -0.0006 | 0.0046  |\n| 2016.08.12 | 0.0023  | -0.0009 |\n| 2016.08.15 | 0.012   | 0.0029  |\n| 2016.08.16 | -0.0009 | -0.0052 |\n| 2016.08.17 | -0.0015 | 0.0019  |\n| 2016.08.18 | -0.0013 | 0.0022  |\n| 2016.08.19 | 0.0026  | -0.0015 |\n| 2016.08.22 | -0.0078 | 0       |\n| 2016.08.23 | 0.0031  | 0.002   |\n| 2016.08.24 | -0.0075 | -0.0051 |\n| 2016.08.25 | -0.0043 | -0.0007 |\n| 2016.08.26 | -0.0059 | -0.0019 |\n| 2016.08.29 | -0.0011 | 0.0049  |\n| 2016.08.30 | -0.0077 | -0.0016 |\n| 2016.08.31 | 0.0009  | -0.0028 |\n\n```\nbetas = rolling(beta, [aaplRet, spyRet], 10,5);\ndates = rolling(last, date, 10,5);\ntable(dates, betas);\n```\n\n| dates      | betas    |\n| ---------- | -------- |\n| 2016.08.12 | 1.601173 |\n| 2016.08.19 | 0.512656 |\n| 2016.08.26 | 1.064465 |\n\nIf *funcArgs* is a matrix with row labels, the row labels are retained in the output.\n\n```\nminBar = 2024.03.08T10:00:00 + 0..9\naaplClose = [170.88,170.88,170.90,171.05,171.18,171.30,171.51,171.49,171.31,171.14]\nibmClose = [150.15,150.18,150.20,150.05,150.18,150.25,150.32,150.30,150.31,150.20]\nm = matrix(aaplClose, ibmClose).rename!(minBar, `aapl`ibm)\nrolling(func=avg, funcArgs=m, window=5, step=2)\n```\n\n| label               | aapl    | ibm     |\n| :------------------ | :------ | :------ |\n| 2024.03.08T10:00:00 | 170.978 | 150.152 |\n| 2024.03.08T10:00:02 | 171.188 | 150.2   |\n| 2024.03.08T10:00:04 | 171.358 | 150.272 |\n"
    },
    "segmentby": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/segmentby.html",
        "signatures": [
            {
                "full": "segmentby(func, funcArgs, segment)",
                "name": "segmentby",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "segment",
                        "name": "segment"
                    }
                ]
            }
        ],
        "markdown": "### [segmentby](https://docs.dolphindb.com/en/Functions/Templates/segmentby.html)\n\n\n\n#### Syntax\n\nsegmentby(func, funcArgs, segment)\n\n#### Arguments\n\n**func** is a function.\n\n**funcArgs** are the parameters of *func*. It is a tuple if there are more than 1 parameter of *func*.\n\n**segment** is the grouping variable.\n\n*segment* and each of the function argument in *funcArgs* are vectors of the same size.\n\n#### Details\n\n`segmentby` is very similar to [contextby](https://docs.dolphindb.com/en/Functions/Templates/contextby.html) except for how groups are determined. With `contextby`, a group includes all elements with the same value. With `segmentby`, only a block of equal value elements counts as a group. 2 blocks of equal value elements separated by different values are treated as 2 groups.\n\n#### Examples\n\n```\nret = 0.01 -0.02 0.03 -0.04 0.03 -0.02 0.05 -0.01 0.03 -0.04 0.05 -0.04\nposition = 1 1 1 1 -1 -1 -1 -1 1 1 1 1\nt = table(ret, position);\nt;\n```\n\n| ret   | position |\n| ----- | -------- |\n| 0.01  |          |\n| -0.02 | 1        |\n| 0.03  | 1        |\n| -0.04 | 1        |\n| 0.03  | -1       |\n| -0.02 | -1       |\n| 0.05  | -1       |\n| -0.01 | -1       |\n| 0.03  | 1        |\n| -0.04 | 1        |\n| 0.05  | 1        |\n| -0.04 | 1        |\n\n```\nupdate t set cumret=contextby(cumsum, ret, position);\nt;\n```\n\n| ret   | position | cumret |\n| ----- | -------- | ------ |\n| 0.01  | 1        | 0.01   |\n| -0.02 | 1        | -0.01  |\n| 0.03  | 1        | 0.02   |\n| -0.04 | 1        | -0.02  |\n| 0.03  | -1       | 0.03   |\n| -0.02 | -1       | 0.01   |\n| 0.05  | -1       | 0.06   |\n| -0.01 | -1       | 0.05   |\n| 0.03  | 1        | 0.01   |\n| -0.04 | 1        | -0.03  |\n| 0.05  | 1        | 0.02   |\n| -0.04 | 1        | -0.02  |\n\n```\nupdate t set cumret=segmentby(cumsum, ret, position);\nt;\n```\n\n| ret   | position | cumret |\n| ----- | -------- | ------ |\n| 0.01  | 1        | 0.01   |\n| -0.02 | 1        | -0.01  |\n| 0.03  | 1        | 0.02   |\n| -0.04 | 1        | -0.02  |\n| 0.03  | -1       | 0.03   |\n| -0.02 | -1       | 0.01   |\n| 0.05  | -1       | 0.06   |\n| -0.01 | -1       | 0.05   |\n| 0.03  | 1        | 0.03   |\n| -0.04 | 1        | -0.01  |\n| 0.05  | 1        | 0.04   |\n| -0.04 | 1        | 0      |\n"
    },
    "talib": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/talib.html",
        "signatures": [
            {
                "full": "talib(func, args...)",
                "name": "talib",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [talib](https://docs.dolphindb.com/en/Functions/Templates/talib.html)\n\n\n\n#### Syntax\n\ntalib(func, args...)\n\n#### Arguments\n\n**func** is a function.\n\n**args** are the parameters of *func*.\n\nPlease see [TALib](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Details\n\nRegarding the NULL value handling, the differences between DolphinDB's built-in moving functions and Python TA-lib lie in:\n\n* DolphinDB moving functions: The calculation in the sliding window starts from the first element.\n\n* Python TA-lib: Keep the NULL values at the beginning of data in the output. The calculation in the sliding window starts from the first non-NULL value.\n\nTo process data starting with consecutive NULL values in the same way as Python TA-Lib, you can call DolphinDB built-in functions with the higher-order function `talib`.\n\n#### Examples\n\nSee the differences of function `talib` and DolphinDB built-in functions with the following example:\n\n```\nmsum(NULL 1 2 3 4 5 6 7 8 9, 3)\n// output\n[,,3,6,9,12,15,18,21,24]\n\ntalib(msum, NULL 1 2 3 4 5 6 7 8 9, 3)\n// output\n[,,,6,9,12,15,18,21,24]\n```\n"
    },
    "tmoving": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/tmoving.html",
        "signatures": [
            {
                "full": "tmoving(func, T, funcArgs, window, [excludedPeriod])",
                "name": "tmoving",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[excludedPeriod]",
                        "name": "excludedPeriod",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [tmoving](https://docs.dolphindb.com/en/Functions/Templates/tmoving.html)\n\n\n\n#### Syntax\n\ntmoving(func, T, funcArgs, window, \\[excludedPeriod])\n\n#### Arguments\n\n**func** is a function.\n\n**T** is a non-strictly increasing vector of temporal or integral type. It cannot contain NULL values.\n\n**funcArgs** are the parameters of *func*. They can be vectors/dictionaries/tables. It is a tuple if there are more than one parameter of *func*, and all parameters must have the same size.\n\n**window** is a scalar of positive integer or DURATION type indicating the size of the sliding window. For each element *Ti* in *T*, the range of the corresponding window is \\[*Ti* - window + 1,*Ti*].\n\n**excludedPeriod** is a pair of time values (of TIME, NANOTIME, MINUTE, and SECOND type) representing the start and end time of the period which is excluded from the calculation. When the *excludedPeriod* is set, the input *T*\n\ncannot contain the time range specified by *excludedPeriod*and must be of TIMESTAMP, NANOTIMESTAMP, TIME, and NANOTIME types. Note that *excludedPeriod* must be within a calendar day and cannot be longer than the value of (24 - *window*).\n\nPlease see [tmFunctions](https://docs.dolphindb.com/en/Functions/Themes/tmFunctions.html) for the parameters and windowing logic.\n\n#### Details\n\nApply the function/operator to a sliding window of the given objects.\n\nThe `tmoving` template always returns a vector with the same number of elements as the number of rows in the input arguments.\n\nEach of the built-in tm-functions such as [tmsum](https://docs.dolphindb.com/en/Functions/t/tmsum.html), [tmcount](https://docs.dolphindb.com/en/Functions/t/tmcount.html) and [tmavg](https://docs.dolphindb.com/en/Functions/t/tmavg.html) is optimized for its specific use case. Therefore, they have much better performance than the `tmoving` template.\n\n#### Examples\n\n```\ndate=2021.08.01 2021.08.02 2021.08.02 2021.08.02 2021.08.03 2021.08.04 2021.08.05 2021.08.06 2021.08.09 2021.08.10 2021.08.14\nvalue=1..11\nt = table(date,value)\ntimer(100) select date, value, tmoving(avg,date,value,3d) from t;\n// output\nTime elapsed: 1.995 ms\ntimer(100) select date, value, tmavg(date, value, 3d) from t;\n// output\nTime elapsed: 0.997 ms\n```\n\nAs shown in the output, when the window slides to 2021.08.09, the range is \\[2021.08.07, 2021.08.08, 2021.08.09]. As the values in 2021.08.07 and 2021.08.08 are missing, they do not participate in the calculation.\n\n| date       | value | tmoving\\_sum |\n| ---------- | ----- | ------------ |\n| 2021.08.01 | 1     | 1            |\n| 2021.08.02 | 2     | 1.5          |\n| 2021.08.02 | 3     | 2            |\n| 2021.08.02 | 4     | 2.5          |\n| 2021.08.03 | 5     | 3            |\n| 2021.08.04 | 6     | 4            |\n| 2021.08.05 | 7     | 6            |\n| 2021.08.06 | 8     | 7            |\n| 2021.08.09 | 9     | 9            |\n| 2021.08.10 | 10    | 9.5          |\n| 2021.08.14 | 11    | 11           |\n\nThe following example specifies the *excludedPeriod* parameter. The closing hours from 11:30 to 13:00 will be excluded from the calculation.\n\n```\nexcludedPeriod=(11:30:00:13:00:00)\nts=timestamp(2023.11.01T11:21:00+1..500) join timestamp(2023.11.01T13:00:00+1..500)\nt=table(ts, rand(10.0,size(ts)) as price)\n\n// with excludedPeriod specified\nres1=select ts, tmoving(func=avg, T=ts, funcArgs=price, window=1m, excludedPeriod=excludedPeriod) from t\n// without excludedPeriod specified\nres2=select ts, tmoving(func=avg, T=ts, funcArgs=price, window=1m) from t\n\n// results for two situations\nselect * from res1 where ts between timestamp(2023.11.01T13:00:00) and timestamp(2023.11.01T13:01:00)\n\nselect * from res2 where ts between timestamp(2023.11.01T13:00:00) and timestamp(2023.11.01T13:01:00)\n```\n\nThe following example specifies multiple *funcArgs* parameters to calculate the minimum value of bond prices after reaching their peak within a 5-minute rolling window.\n\n```\ndata_time = 2023.01.01T00:00:00 + 0..5 * 3600000  \nlast_price_bond = 100 + rand(10.0, 10) \n\ndefg getMinPrice(data_time, last_price_bond){\n        maxPriceTime = atImax(last_price_bond, data_time)\n        maxPrice = max(last_price_bond)\n        newPriceList = min(iif(data_time<maxPriceTime, maxPrice, last_price_bond))\n        return min(newPriceList)\n}\ncalTime = \"5m\"\ntmoving(getMinPrice, data_time, [data_time, last_price_bond], duration(calTime))\n```\n"
    },
    "twindow": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/twindow.html",
        "signatures": [
            {
                "full": "twindow(func, funcArgs, T, range, [prevailing=false], [excludedPeriod])",
                "name": "twindow",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "range",
                        "name": "range"
                    },
                    {
                        "full": "[prevailing=false]",
                        "name": "prevailing",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[excludedPeriod]",
                        "name": "excludedPeriod",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [twindow](https://docs.dolphindb.com/en/Functions/Templates/twindow.html)\n\n\n\n#### Syntax\n\ntwindow(func, funcArgs, T, range, \\[prevailing=false], \\[excludedPeriod])\n\n#### Arguments\n\n**func** is an aggregate function.\n\n**funcArgs** is the argument(s) of *func*. If *func* has multiple parameters, *funcArgs* is a tuple.\n\n**T** is a non-strictly increasing vector of integers or temporal type.\n\n**range** is a data pair of INT or DURATION type (both boundaries are inclusive).\n\n**prevailing** is a BOOLEAN. The default value is false. When *prevailing* = true, the rules to determine the left boundary of the window is the same as applied in [pwj](https://docs.dolphindb.com/en/Programming/SQLStatements/TableJoiners/windowjoin.html).\n\n**excludedPeriod** is a pair of time values (of TIME, NANOTIME, MINUTE, and SECOND type) representing the start and end time of the period which is excluded from the calculation. When the *excludedPeriod* is set, the input *T*cannot contain the time range specified by *excludedPeriod*and must be of TIMESTAMP, NANOTIMESTAMP, TIME, and NANOTIME types. Note that *excludedPeriod* must be within a calendar day and cannot be longer than the value of (24 - *range*).\n\n#### Details\n\nApply *func* over a sliding window of *funcArgs*. Each element in *funcArgs* corresponds to a window that is determined by *T* and *range*. The result has the same dimension as that of *funcArgs* (If *funcArgs* is a tuple, the result has the same dimension as that of each element in the tuple).\n\nSuppose *range* is set to d1:d2, the windows are determined based on the following rules:\n\n1. When *range* is an integral pair:\n\n   * *T* is a vector of integral type: For element Ti in *T*, the window range is \\[Ti+d1, Ti+d2].\n\n   * *T* is a vector of temporal type: *range* has the precision of *T* by default. For element Ti in *T*, the window range is \\[temporalAdd(Ti, d1, unit), temporalAdd(Ti, d2, unit)], where \"unit\" indicates the precision of *T*.\n\n2. When *range* is a duration pair, *T* can only be a vector of temporal type. For element Ti in *T*, the window range is \\[temporalAdd(Ti, d1), temporalAdd(Ti, d2)].\n\nCompared with the *tmoving* function, `twindow` has more flexible windows. `tmoving` can be considered roughly as a special case of `twindow`, where the right boundary of the *range* parameter is 0. However, when the window is measured by time, note the following differences regarding how to determine window boundaries:\n\n1. With `twindow`, when the right boundary of the window matches multiple identical values, all records with the identical value participate in the calculation. When the left boundary of the window matches multiple identical values, if *prevailing* = true, only the last record with the identical value participates in the calculation; if *prevailing* = false, all records with the identical value participate in the calculation.\n\n2. With the `tm` functions, the range of the window is (Ti - window, Ti] or (temporalAdd(Ti, -window), Ti] where the left boundary is exclusive. The current record is included as the last element in the corresponding window, regardless of whether the following records have identical values.\n\n#### Examples\n\nWhen *prevailing* = false, if the left boundary of the window matches multiple identical values, the calculation window includes all records with the identical value.\n\n```\nt = 2021.01.02 2021.01.02 2021.01.06 2021.03.09 2021.03.10 2021.03.12 2021.03.12\nx = -5 5 NULL -1 2 4 -8\ntwindow(func=min,funcArgs=x,T=t,range=0:2)\n// output\n[-5, -5, , -1, -8, -8, -8]\n```\n\nWhen *prevailing* = true, if the left boundary of the window matches multiple identical values, the calculation window only includes the last record with the identical value.\n\n```\ntwindow(func=min, funcArgs=x, T=t, range=0:3, prevailing=true)\n// output\n[5, 5, ,-8, -8, -8, -8]\n```\n\n```\ntwindow(func=max, funcArgs=x, T=t, range=0d:3d)\n// output\n[5, 5, , 4, 4, 4, 4]\n\ntwindow(func=max, funcArgs=x, T=t, range=0:3, prevailing=true)\n// output\n[5, 5, , 4, 4, -8, -8]\n\ntwindow(func=max, funcArgs=x, T=t, range=0M:3M)\n// output\n[5, 5, 4, 4, 4, 4, 4]\n\ntwindow(func=max, funcArgs=x, T=t, range=0M:3M, prevailing=true)\n// output\n[5, 5, 4, 4, 4, -8, -8]\n\ny = 4.8 9.6 7.1 3.3 5.9 2.7 6.9\ntwindow(func=corr, funcArgs=(x,y), T=t, range=0:3)\n// output\n[1, 1,  , -0.685, -0.7893, -1, -1]\n\n```\n\n```\n\nt1 = table(`A`A`B`B`C`C as sym, 09:56:03 09:56:07 09:56:02 09:56:05 09:56:04 09:56:06 as time, 10.6 10.7 20.6 11.6 11.7 19.6 as price)\nselect *, twindow(func=avg, funcArgs=t1.price, T=t1.time, range=2s:4s) from t1 context by sym\n```\n\n| sym | time     | price | window\\_avg |\n| --- | -------- | ----- | ----------- |\n| A   | 09:56:03 | 10.6  | 10.7        |\n| A   | 09:56:07 | 10.7  |             |\n| B   | 09:56:02 | 20.6  | 11.6        |\n| B   | 09:56:05 | 11.6  |             |\n| C   | 09:56:04 | 11.7  | 19.6        |\n| C   | 09:56:06 | 19.6  |             |\n\nThe following example specifies the *excludedPeriod* parameter. The closing hours from 11:30 to 13:00 will be excluded from the calculation.\n\n```\nexcludedPeriod=(11:30:00:13:00:00)\nts=timestamp(2023.11.01T11:21:00+1..500) join timestamp(2023.11.01T13:00:00+1..500)\nt=table(ts, rand(10.0,size(ts)) as price)\n\n// with excludedPeriod specified\nres1=select ts, twindow(func=avg, T=ts, funcArgs=price, range=-1m:0m, excludedPeriod=excludedPeriod) from t\n// without excludedPeriod specified\nres2=select ts, twindow(func=avg, T=ts, funcArgs=price, range=-1m:0m) from t\n\n// results for two situations\nselect * from res1 where ts between timestamp(2023.11.01T13:00:00) and timestamp(2023.11.01T13:01:00)\n\nselect * from res2 where ts between timestamp(2023.11.01T13:00:00) and timestamp(2023.11.01T13:01:00)\n```\n"
    },
    "unifiedCall": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/unifiedCall.html",
        "signatures": [
            {
                "full": "unifiedCall(func, args)",
                "name": "unifiedCall",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args",
                        "name": "args"
                    }
                ]
            }
        ],
        "markdown": "### [unifiedCall](https://docs.dolphindb.com/en/Functions/Templates/unifiedCall.html)\n\n\n\n#### Syntax\n\nunifiedCall(func, args)\n\n#### Arguments\n\n**func** is a function.\n\n**args** is a tuple. Each element is a parameter of *func*.\n\n#### Details\n\nCall a function with the specified parameters. Similar to [call](https://docs.dolphindb.com/en/Functions/Templates/call.html), it can be used in [each](https://docs.dolphindb.com/en/Functions/Templates/each.html)/[peach](https://docs.dolphindb.com/en/Functions/Templates/peach.html) or [loop](https://docs.dolphindb.com/en/Functions/Templates/loop.html)/[ploop](https://docs.dolphindb.com/en/Functions/Templates/ploop.html) to call a set of functions. The difference is that the size of *args* in call function is determined by the function passed in by the parameter *func*, whereas the size of args in `unifiedCall` is always 1. All arguments of the function used in function call is assembled in a tuple for function `unifiedCall`.\n\n#### Examples\n\n```\nunifiedCall(sum, [1..10])\n// output\n55\n\nunifiedCall(add, ([1,2,3,4,5,6,7,8,9,10],2))\n// output\n[3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\n```\n\n```\n\neach(unifiedCall, [std, max], [[matrix(1 3 5 7 9, 1 4 7 10 13)], [0..100]]);\n```\n\n| col1   | col2 |\n| ------ | ---- |\n| 3.1623 | 100  |\n| 4.7434 | 100  |\n\n```\ndef f(a,b){return (a+2)*b}\nunifiedCall(f, (5,10))\n//output\n70\n```\n"
    },
    "window": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/window.html",
        "signatures": [
            {
                "full": "window(func, funcArgs, range)",
                "name": "window",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "range",
                        "name": "range"
                    }
                ]
            }
        ],
        "markdown": "### [window](https://docs.dolphindb.com/en/Functions/Templates/window.html)\n\n\n\n#### Syntax\n\nwindow(func, funcArgs, range)\n\n#### Arguments\n\n**func** is an aggregate function.\n\n**funcArgs** is the argument(s) of *func*. It is a tuple if there are more than one parameter of *func*.\n\n**range** is a pair of integers or duration values (both boundaries are inclusive).\n\nNote: If *range* is of DURATION type, *funcArgs* must be an indexed matrix or an indexed series.\n\n#### Details\n\nApply *func* over a sliding window of *funcArgs*. Each element in *funcArgs* corresponds to a window that is determined by *range*. The result has the same dimension as that of *funcArgs* (If *funcArgs* is a tuple, the result has the same dimension as that of each element in the tuple).\n\nSuppose *range* is set to d1:d2, the windows are determined based on the following rules:\n\n1. When *funcArgs* is a vector, *range* must be a pair of integers. For the ith element in *funcArgs*, the corresponding window contains elements at position \\[i+d1, i+d2].\n\n2. When *funcArgs* is an indexed series or indexed matrix:\n\n* If *funcArgs* is indexed by time, for fi (the ith element in the index of *funcArgs*), the corresponding window contains elements at index \\[temporalAdd(fi, d1), temporalAdd(fi, d2)].\n\n* If *funcArgs* is indexed by integral values, *range* must also be integral. For fi (the ith element in the index of *funcArgs*), the corresponding window contains elements at index \\[fi+d1, fi+d2].\n\nCompared with the *moving* function, the *window* function has a more flexible window. *moving* can be roughly considered as a special case of window, where the right boundary of the *range* parameter is 0. However, please note the following differences:\n\n1. When the window is based on element counts, *moving* returns null when the number of windowed elements does not satisfy the *minPeriods*, whereas `window` does not have a minimum count requirement.\n\n2. When the window is based on time, the left boundary of the window of *moving* is exclusive and the right boundary is inclusive; whereas both boundaries of the window of `window` are inclusive. In this example:\n\n   Suppose a window with the size of \"3d\" slides over an index of DATETIME type to apply calculation. For the point \"2022.01.05T09:00:00\" in the index, the range of the corresponding window in `moving` is (2022.01.02T09:00:00,2022.01.05T09:00:00], whereas it's \\[2022.01.03T09:00:00,2022.01.05T09:00:00] in `window` (with the *range* parameter specified as \"-2d:0d\").\n\n#### Examples\n\n*funcArgs* is a vector. For the ith element of *x*, the range of the window is \\[i+1,i+3].\n\n```\nx = 5 4 NULL -1 2 4\nwindow(min, x, 1:3)\n// output\n[-1, -1, -1, 2, 4, ]\n\ny = 4.8 9.6 7.1 3.3 5.9 2.7\nwindow(corr, (x, y), 1:3)\n// output\n[1, 1, -0.623, -1, , ]\n```\n\n*funcArgs* is a series indexed by time. The range of the window is \\[temporalAdd(ti 1d), temporalAdd(ti, 3d)] where ti is the i-th element of t.\n\n```\nt = 2021.01.02 2021.01.05 2021.01.06 2021.01.09 2021.01.10 2021.01.12\nx1 = indexedSeries(t, x)\nwindow(min, x1, 1d:3d)\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2021.01.02 | 4    |\n| 2021.01.05 |      |\n| 2021.01.06 | -1   |\n| 2021.01.09 | 2    |\n| 2021.01.10 | 4    |\n| 2021.01.12 |      |\n\n*funcArgs* is a matrix indexed by time. The range of the window is \\[temporalAdd(ti, 1d), temporalAdd(ti, 3d)], where ti is the ith element of t.\n\n```\nt= 2021.01.02 2021.01.05  2021.01.06  2021.01.09 2021.01.10 2021.01.12\nm=matrix(5 4 NULL -1 2 4, 3 2 8 1 0 5)\nm1=m.rename!(t, `a`b).setIndexedMatrix!()\nwindow(min, m1, 1d:3d)\n```\n\n| label      | a  | b |\n| ---------- | -- | - |\n| 2021.01.02 | 4  | 2 |\n| 2021.01.05 |    | 8 |\n| 2021.01.06 | -1 | 1 |\n| 2021.01.09 | 2  | 0 |\n| 2021.01.10 | 4  | 5 |\n| 2021.01.12 |    |   |\n\n```\nt1 = table(`A`A`B`B`C`C as sym, 09:56:03 09:56:07 09:56:02 09:56:05 09:56:04 09:56:06 as time, 10.6 10.7 20.6 11.6 11.7 19.6 as price)\nselect *, window(avg, t1.time.indexedSeries(t1.price), 2s:4s) from t1 context by sym\n```\n\n| sym | time     | price | window\\_avg |\n| --- | -------- | ----- | ----------- |\n| A   | 09:56:03 | 10.6  | 10.7        |\n| A   | 09:56:07 | 10.7  |             |\n| B   | 09:56:02 | 20.6  | 11.6        |\n| B   | 09:56:05 | 11.6  |             |\n| C   | 09:56:04 | 11.7  | 19.6        |\n| C   | 09:56:06 | 19.6  |             |\n"
    },
    "withNullFill": {
        "url": "https://docs.dolphindb.com/en/Functions/Templates/withNullFill.html",
        "signatures": [
            {
                "full": "withNullFill(func, x, y, fillValue)",
                "name": "withNullFill",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "y",
                        "name": "y"
                    },
                    {
                        "full": "fillValue",
                        "name": "fillValue"
                    }
                ]
            }
        ],
        "markdown": "### [withNullFill](https://docs.dolphindb.com/en/Functions/Templates/withNullFill.html)\n\n\n\n#### Syntax\n\nwithNullFill(func, x, y, fillValue)\n\n#### Arguments\n\n**func** is a DolphinDB built-in function with two inputs, such as `+`, `-`, `*`, `/`, `\\`, `%`, `pow`, `and`, `or`, etc.\n\n**x** and **y** are vectors or matrices.\n\n**fillValue** is a scalar.\n\n#### Details\n\nIf only 1 of the elements at the same location of *x* and *y* is NULL, replace the NULL value with *fillValue* in the calculation. If both elements at the same location of *x* and *y* are NULL, return NULL.\n\n#### Examples\n\n```\nx = 0 1 NULL NULL 2\ny = 1 NULL 2 NULL 3;\nadd(x,y);\n// output\n[1,,,,5]\n\nwithNullFill(add, x, y, 0);\n// output\n[1,1,2,,5]\n\nm=matrix(1..5, y);\nm;\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 1    |\n| 2    |      |\n| 3    | 2    |\n| 4    |      |\n| 5    | 3    |\n\n```\nadd(x, m);\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 1    |\n| 3    |      |\n|      |      |\n|      |      |\n| 7    | 5    |\n\n```\nwithNullFill(add, x, m, 0);\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 1    |\n| 3    | 1    |\n| 3    | 2    |\n| 4    |      |\n| 7    | 5    |\n"
    },
    "undef": {
        "url": "https://docs.dolphindb.com/en/Functions/u/undef.html",
        "signatures": [
            {
                "full": "undef(obj, [objType=VAR])",
                "name": "undef",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[objType=VAR]",
                        "name": "objType",
                        "optional": true,
                        "default": "VAR"
                    }
                ]
            }
        ],
        "markdown": "### [undef](https://docs.dolphindb.com/en/Functions/u/undef.html)\n\n\n\n#### Syntax\n\nundef(obj, \\[objType=VAR])\n\nor\n\nundef all\n\n#### Arguments\n\n**obj** is a string or a string vector indicating the names of objects to be undefined. To undefine all the variables in a category, use the unquoted \"all\" for *obj*.\n\n**objType** (optional) is type of objects to be undefined. The types can be: VAR (variable), SHARED (shared variable) or DEF (function definition). The default value is VAR.\n\nTo delete all user-defined objects in the system except shared variables, use \"undef all\".\n\n#### Details\n\nRelease variables or function definitions from the memory. You can also release a local variable (VAR) from the memory using \"= NULL\".\n\n#### Examples\n\n```\nundef all;\nx=1\nundef(`x);\nx=1\ny=2\nundef(`x`y);\nshare table(1..3 as x, 4..6 as y) as t\nundef(`t, SHARED);\n```\n\n```\ndef f(a){return a+1}\nundef(`f, DEF);\na=1\nb=2\nundef all, VAR;\n```\n"
    },
    "ungroup": {
        "url": "https://docs.dolphindb.com/en/Functions/u/ungroup.html",
        "signatures": [
            {
                "full": "ungroup(X)",
                "name": "ungroup",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ungroup](https://docs.dolphindb.com/en/Functions/u/ungroup.html)\n\n#### Syntax\n\nungroup(X)\n\n#### Arguments\n\n**X** must be a table object.\n\n#### Details\n\nFor table *X*, where some columns are array vectors or columnar tuples, returns the normalized table, with one row for each element of the flattened array vector or columnar tuple.\n\nIf *X* does not contain array vectors or columnar tuples or the number of rows for *X* is 0, returns *X* directly.\n\n#### Examples\n\n```\nx = array(INT[], 0).append!([1 2 3, 4 5, 6 7 8, 9 10])\nt = table(1 2 3 4 as id, x as vol)\nungroup(t)\n\n// output\nid vol\n-- -------\n1  1\n1  2\n1  3\n2  4\n2  5\n3  6\n3  7\n3  8\n4  9\n4  10  \n\n// create a table where the column price is a columnar tuple\nsym = `st1`st2`st3\nprice = [[3.1,2.5,2.8], [3.1,3.3], [3.2,2.9,3.3]]\nt = table(sym, price)\nt;\n```\n\n| sym | price                   |\n| --- | ----------------------- |\n| st1 | \\[3.1000,2.5000,2.8000] |\n| st2 | \\[3.1000,3.3000]        |\n| st3 | \\[3.2000,2.9000,3.3000] |\n\n```\nungroup(t)\n```\n\n| sym | price |\n| --- | ----- |\n| st1 | 3.1   |\n| st1 | 2.5   |\n| st1 | 2.8   |\n| st2 | 3.1   |\n| st2 | 3.3   |\n| st3 | 3.2   |\n| st3 | 2.9   |\n| st3 | 3.3   |\n\n```\nsym = `st1`st2`st2`st1`st3`st1`st3`st2`st3\nvolume = 106 115 121 90 130 150 145 123 155;\nt = table(sym, volume);\nt;\n\nt1 = select toArray(volume) as volume_all from t group by sym;\nt1;\n```\n\n| sym | volume\\_all    |\n| --- | -------------- |\n| st1 | \\[106,90,150]  |\n| st2 | \\[115,121,123] |\n| st3 | \\[130,145,155] |\n\n```\nungroup(t1)\n```\n\n| sym | volume\\_all |\n| --- | ----------- |\n| st1 | 106         |\n| st1 | 90          |\n| st1 | 150         |\n| st2 | 115         |\n| st2 | 121         |\n| st2 | 123         |\n| st3 | 130         |\n| st3 | 145         |\n| st3 | 155         |\n\n"
    },
    "unifiedExpr": {
        "url": "https://docs.dolphindb.com/en/Functions/u/unifiedExpr.html",
        "signatures": [
            {
                "full": "unifiedExpr(objs, optrs)",
                "name": "unifiedExpr",
                "parameters": [
                    {
                        "full": "objs",
                        "name": "objs"
                    },
                    {
                        "full": "optrs",
                        "name": "optrs"
                    }
                ]
            }
        ],
        "markdown": "### [unifiedExpr](https://docs.dolphindb.com/en/Functions/u/unifiedExpr.html)\n\n\n\n#### Syntax\n\nunifiedExpr(objs, optrs)\n\n#### Arguments\n\n**objs** is a tuple with no less than 2 elements.\n\n**optrs** is a vector of binary operators and the length is size(objs)-1.\n\n#### Details\n\nConnect the operands in *objs* with the binary operators in *optrs* to generate metacode of a multivariate expression. You can execute the metacode with function [eval](https://docs.dolphindb.com/en/Functions/e/eval.html).\n\n#### Examples\n\n```\nunifiedExpr((1, 2), add)\n// output\n<1 + 2>\n\nt=table(1..3 as price1, 4..6 as price2, 5..7 as price3)\na=sqlColAlias(unifiedExpr((sqlCol(\"price1\"), sqlCol(\"price2\"), sqlCol(\"price3\")), take(add, 2)))\nsql(select=(sqlCol(`price1),sqlCol(`price2),sqlCol(`price3),a), from=t).eval()\n```\n\n| price1 | price2 | price3 | price1\\_add |\n| ------ | ------ | ------ | ----------- |\n| 1      | 4      | 5      | 10          |\n| 2      | 5      | 6      | 13          |\n| 3      | 6      | 7      | 16          |\n\nRelated function: [binaryExpr](https://docs.dolphindb.com/en/Functions/b/binaryExpr.html)\n"
    },
    "union": {
        "url": "https://docs.dolphindb.com/en/Functions/u/union.html",
        "signatures": [
            {
                "full": "union(X, Y)",
                "name": "union",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [union](https://docs.dolphindb.com/en/Functions/u/union.html)\n\n\n\n#### Syntax\n\nunion(X, Y) or X|Y\n\n#### Arguments\n\n**X** and **Y** are sets.\n\n#### Details\n\nReturn the union of two sets.\n\n#### Examples\n\n```\nx=set([5,5,3,4]);\ny=set(8 9 9 4 6);\nx | y;\n// output\nset(8,9,6,4,3,5)\n```\n"
    },
    "unionAll": {
        "url": "https://docs.dolphindb.com/en/Functions/u/unionAll.html",
        "signatures": [
            {
                "full": "unionAll(tableA, tableB, [byColName=false])",
                "name": "unionAll",
                "parameters": [
                    {
                        "full": "tableA",
                        "name": "tableA"
                    },
                    {
                        "full": "tableB",
                        "name": "tableB"
                    },
                    {
                        "full": "[byColName=false]",
                        "name": "byColName",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "unionAll(tables, [partition=true], [byColName=false])",
                "name": "unionAll",
                "parameters": [
                    {
                        "full": "tables",
                        "name": "tables"
                    },
                    {
                        "full": "[partition=true]",
                        "name": "partition",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[byColName=false]",
                        "name": "byColName",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "unionAll(tables, tableB)",
                "name": "unionAll",
                "parameters": [
                    {
                        "full": "tables",
                        "name": "tables"
                    },
                    {
                        "full": "tableB",
                        "name": "tableB"
                    }
                ]
            }
        ],
        "markdown": "### [unionAll](https://docs.dolphindb.com/en/Functions/u/unionAll.html)\n\n\n\n#### Syntax\n\nunionAll(tableA, tableB, \\[byColName=false])\n\nor\n\nunionAll(tables, \\[partition=true], \\[byColName=false])\n\nor\n\nunionAll(tables, tableB)\n\n#### Arguments\n\n* For the first scenario, **tableA** and **tableB** are 2 tables with the same number of columns.\n\n* For the second scenario,\n\n  * **tables** is a list of tables with the same number of columns;\n\n  * **partition** (optional) is a Boolean parameter with the default value of true.\n\n  * **byColName** (optional) is a Boolean value indicating whether the table combination is conducted along columns with the same name. If *byColName* =false, the table combination is conducted based on the order of columns regardless of column names.\n\n* For the third scenario, **tables** is a tuple where the elements represent in-memory tables with the same number of columns. tableB is also an in-memory table having the the same number of columns. This form is often used to specify the *finalFunc* parameter of the `mr` function.\n\n**Note:** The following table types are supported: `table`, `keyedTable`, `indexedTable`, `latestKeyedTable`, `latestIndexedTable`. *tableB* of the third scenario can also be a partitioned in-memory table.\n\n#### Details\n\nFor the first scenario, combine 2 tables into a single table. The result is an unpartitioned in-memory table.\n\nFor the second scenario, combine multiple tables into a single table. If *partitioned* is set to \"false\", the result is an unpartitioned in-memory table; if *partitioned* is set to \"true\", the result is a partitioned in-memory table with sequential domain. The default value is \"true\".\n\nIf *byColName* =false, all tables to be combined must have identical number of columns.\n\nIf *byColName* =true, the tables to be combined can have different number of columns. If a column does not exist in a table, it is filled with NULL values in the final result.\n\n#### Examples\n\nScenario 1. Combine two in-memory tables.\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x)\nt2=table(4 5 6 as id, 14 15 16 as x)\nre=unionAll(t1,t2)\nre;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n| 6  | 16 |\n\n```\ntypestr(re);\n// output\nIN-MEMORY TABLE\n```\n\nScenario 2. Combine multiple in-memory tables.\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x)\nt2=table(4 5 6 as id, 14 15 16 as x)\nt3=table(7 8 as id, 17 18 as x)\nre=unionAll([t1,t2,t3])\nselect * from re;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n| 6  | 16 |\n| 7  | 17 |\n| 8  | 18 |\n\n```\ntypestr(re);\n// output\nSEGMENTED IN-MEMORY TABLE\n```\n\nSpecifies *byColName*\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x)\nt2=table(14 15 16 as x, 4 5 6 as id)\nunionAll(t1,t2,true);\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n| 6  | 16 |\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x)\nt2=table(14 15 16 as x, 4 5 6 as id)\nunionAll(t1,t2);\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 14 | 4  |\n| 15 | 5  |\n| 16 | 6  |\n\nFrom the examples above, please make sure column names and their order are identical in all tables to be combined if *byColName* is not specified (i.e., *byColName* =false).\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x, 21 22 23 as y)\nt2=table(4 5 6 as id, 14 15 16 as x)\nunionAll(t1,t2,true);\n```\n\n| id | x  | y  |\n| -- | -- | -- |\n| 1  | 11 | 21 |\n| 2  | 12 | 22 |\n| 3  | 13 | 23 |\n| 4  | 14 |    |\n| 5  | 15 |    |\n| 6  | 16 |    |\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x, 21 22 23 as y)\nt2=table(4 5 6 as id, 14 15 16 as x)\nunionAll(t1, t2) => The number of columns of the table to insert must be the same as that of the original table.\n```\n\nFrom the examples above, if the tables to be combined have different number of columns, we must set *byColName* =true.\n\nScenario 3: Combine multiple in-memory tables and a partitioned in-memory table. Update the partitioned in-memory table with the combination result.\n\n```\ndef testFunc(data, off){\n    return select *, price * (1-off) as `discountPrice from data\n}\nn = 100\ndates = 2021.01.01..2021.12.31\nt = table(take(dates, 365 * n).sort() as `date, `sym + take(1..n, 365 * n).sort()$STRING as `sym, round(10 + norm(0, 2, 365 * n), 2) as `price)\n\ndb = database(\"\", VALUE, 2021.01.01..2021.12.31)\ntrade = db.createPartitionedTable(table=t, tableName=\"trade\", partitionColumns=`date).append!(t)\ndb = database(\"\", RANGE, date(month(dates.first()) .. (month(dates.last()) + 1)))\noutputT=table(1:0, `date`sym`price`discountPrice, [DATE,SYMBOL,DOUBLE,DOUBLE])\nports = db.createPartitionedTable(outputT, \"ports\", `date)\n//map reduce\nmr(sqlDS(<select * from trade>), testFunc{,0.3},,unionAll{,ports})\n\nselect * from ports\n```\n"
    },
    "unpack": {
        "url": "https://docs.dolphindb.com/en/Functions/u/unpack.html",
        "signatures": [
            {
                "full": "unpack(format, buf)",
                "name": "unpack",
                "parameters": [
                    {
                        "full": "format",
                        "name": "format"
                    },
                    {
                        "full": "buf",
                        "name": "buf"
                    }
                ]
            }
        ],
        "markdown": "### [unpack](https://docs.dolphindb.com/en/Functions/u/unpack.html)\n\n\n\n#### Syntax\n\nunpack(format, buf)\n\n#### Arguments\n\n**format** is a format string.\n\n* A format character may be preceded by an integral repeat count. For example, the format string '4h' means exactly the same as 'hhhh'.\n\n* Whitespace characters between formats are ignored; a count and its format must not contain whitespace though.\n\n* For the 's' format character, the count is interpreted as the length of the bytes, not a repeat count like for the other format characters; for example, '10s' means a single 10-byte string, while '10c' means 10 characters. If a count is not given, it defaults to 1. The string is truncated or padded with null bytes as appropriate to make it fit.\n\n**buf** is a bytes object of STRING or BLOB type. The size of *buf* in bytes must match the size required by the format.\n\n#### Details\n\nUnpack from the *buf* according to the format string specified by *format*. The result is a tuple with the unpacked data even if it contains exactly one item.\n\n#### Examples\n\n```\nres = pack(\"N\",1);\nres1 = unpack(\"N\", res);\nprint(res1)\n// output\n(1)\n\nres = pack(\"3s i\", `123, 3)\nres1 = unpack(\"3s i\",  res);\nprint(res1)\n// output\n(\"123\",3)\n\nres = pack(\"3s i\", `123, 3)\nres2 = unpack(\"3s i\",  blob(res));\nprint(res2)\n// output\n(\"123\",3)\n```\n\n#### Appendix\n\nPlease see [Appendix: Format Characters](https://docs.dolphindb.com/en/Functions/appendix.md#) for the format mapping.\n\nThe first character of the format string can be used to indicate the byte order, size and alignment of the packed data, see [Appendix: Byte Order, Size, and Alignment](https://docs.dolphindb.com/en/Functions/appendix.md#). If the first character is not one of these characters, '@' is assumed.\n\nRelated functions: [pack](https://docs.dolphindb.com/en/Functions/p/pack.html)\n"
    },
    "unpivot": {
        "url": "https://docs.dolphindb.com/en/Functions/u/unpivot.html",
        "signatures": [
            {
                "full": "unpivot(obj, keyColNames, valueColNames, [func])",
                "name": "unpivot",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "keyColNames",
                        "name": "keyColNames"
                    },
                    {
                        "full": "valueColNames",
                        "name": "valueColNames"
                    },
                    {
                        "full": "[func]",
                        "name": "func",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [unpivot](https://docs.dolphindb.com/en/Functions/u/unpivot.html)\n\n\n\n#### Syntax\n\nunpivot(obj, keyColNames, valueColNames, \\[func])\n\n#### Arguments\n\n**obj** is a table.\n\n**keyColNames** is a STRING scalar/vector indicating column name(s).\n\n**valueColNames** is a vector of column names. The specified columns will be converted into a single column. Note the values in these columns must have the same data type.\n\n**func** (optional) indicates a function that is applied to *valueColNames* before they're converted into one column.\n\n#### Details\n\nConvert the columns specified by *valueColNames* into a single column.\n\nReturn a table with columns arranged in the following order: the columns specified by *keyColNames*, the \"valueType\" column, and the \"value\" column:\n\n* The \"valueType\" column holds the results of *func*applied on the columns specified by *valueColNames*if *func*is specified, otherwise \"valueType\" holds the column names specified by *valueColNames*.\n\n* The \"value\" column holds the corresponding values of these columns.\n\n#### Examples\n\n```\nt=table(1..3 as id, 2010.01.01 + 1..3 as time, 4..6 as col1, 7..9 as col2, 10..12 as col3, `aaa`bbb`ccc as col4, `ddd`eee`fff as col5, 'a' 'b' 'c' as col6);\nt;\n```\n\n| id | time       | col1 | col2 | col3 | col4 | col5 | col6 |\n| -- | ---------- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 1  | 2010.01.02 | 4    | 7    | 10   | aaa  | ddd  | 'a'  |\n| 2  | 2010.01.03 | 5    | 8    | 11   | bbb  | eee  | 'b'  |\n| 3  | 2010.01.04 | 6    | 9    | 12   | ccc  | fff  | 'c'  |\n\n```\nt.unpivot(`id, `col1`col2);\n```\n\n| id | valueType | value |\n| -- | --------- | ----- |\n| 1  | col1      | 4     |\n| 2  | col1      | 5     |\n| 3  | col1      | 6     |\n| 1  | col2      | 7     |\n| 2  | col2      | 8     |\n| 3  | col2      | 9     |\n\n```\nf = def(x): x.split(\"col\")[1];\nt.unpivot(`id, `col1`col2, f);\n```\n\n| id | valueType | value |\n| -- | --------- | ----- |\n| 1  | 1         | 4     |\n| 2  | 1         | 5     |\n| 3  | 1         | 6     |\n| 2  | 2         | 8     |\n| 3  | 2         | 9     |\n\n```\nt.unpivot(, `col1`col2);\n```\n\n| valueType | value |\n| --------- | ----- |\n| col1      | 4     |\n| col1      | 5     |\n| col1      | 6     |\n| col2      | 7     |\n| col2      | 8     |\n| col2      | 9     |\n\n```\nf = def(x): x.regexReplace(\"col\", \"var\")\nt.unpivot(`id, `col1`col2`col3, f);\n```\n\n| id | valueType | value |\n| -- | --------- | ----- |\n| 1  | var1      | 4     |\n| 2  | var1      | 5     |\n| 3  | var1      | 6     |\n| 1  | var2      | 7     |\n| 2  | var2      | 8     |\n| 3  | var2      | 9     |\n| 1  | var3      | 10    |\n| 2  | var3      | 11    |\n| 3  | var3      | 12    |\n\n```\nt.unpivot(`time, `col4`col5)\n```\n\n| time       | valueType | value |\n| ---------- | --------- | ----- |\n| 2010.01.02 | col4      | aaa   |\n| 2010.01.03 | col4      | bbb   |\n| 2010.01.04 | col4      | ccc   |\n| 2010.01.02 | col5      | ddd   |\n| 2010.01.03 | col5      | eee   |\n| 2010.01.04 | col5      | fff   |\n\n```\nt = table(1..3 as id, 2010.01.01 + 1..3 as time, 8.1 9.2 11.3 as bid1, 12.4 11.1 10.5 as bid2, 10.1 10.2 10.3 as bid3, 10.1 10.2 10.3 as bid4, 10.1 11.2 9.3 as bid5, 7.7 8.2 10.5 as ask1, 11.4 10.1 9.5 as ask2, 9.6 9.2 11.3 as ask3, 12.1 7.2 8.3 as ask4, 10.1 12.5 8.9 as ask5);\nt;\nt1 = t.unpivot(`id`time, `bid1`bid2`bid3`bid4`bid5);\nt2 = t.unpivot(, `ask1`ask2`ask3`ask4`ask5);\nre = rename!(t1, `valueType`value, `bid_type`bid_value) join rename!(t2, `valueType`value, `ask_type`ask_value)\nre;\n```\n\n| id | time       | bid\\_type | bid\\_value | ask\\_type | ask\\_value |\n| -- | ---------- | --------- | ---------- | --------- | ---------- |\n| 1  | 2010.01.02 | bid1      | 8.1        | ask1      | 8.1        |\n| 2  | 2010.01.03 | bid1      | 9.2        | ask1      | 9.2        |\n| 3  | 2010.01.04 | bid1      | 11.3       | ask1      | 11.3       |\n| 1  | 2010.01.02 | bid2      | 12.4       | ask2      | 12.4       |\n| 2  | 2010.01.03 | bid2      | 11.1       | ask2      | 11.1       |\n| 3  | 2010.01.04 | bid2      | 10.5       | ask2      | 10.5       |\n| 1  | 2010.01.02 | bid3      | 10.1       | ask3      | 10.1       |\n| 2  | 2010.01.03 | bid3      | 10.2       | ask3      | 10.2       |\n| 3  | 2010.01.04 | bid3      | 10.3       | ask3      | 10.3       |\n| 1  | 2010.01.02 | bid4      | 10.1       | ask4      | 10.1       |\n| 2  | 2010.01.03 | bid4      | 10.2       | ask4      | 10.2       |\n| 3  | 2010.01.04 | bid4      | 10.3       | ask4      | 10.3       |\n| 1  | 2010.01.02 | bid5      | 10.1       | ask5      | 10.1       |\n| 2  | 2010.01.03 | bid5      | 11.2       | ask5      | 11.2       |\n| 3  | 2010.01.04 | bid5      | 9.3        | ask5      | 9.3        |\n"
    },
    "unregisterSnapshotEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/u/unregisterSnapshotEngine.html",
        "signatures": [
            {
                "full": "unregisterSnapshotEngine(dbName, tableName)",
                "name": "unregisterSnapshotEngine",
                "parameters": [
                    {
                        "full": "dbName",
                        "name": "dbName"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [unregisterSnapshotEngine](https://docs.dolphindb.com/en/Functions/u/unregisterSnapshotEngine.html)\n\n\n\n#### Syntax\n\nunregisterSnapshotEngine(dbName, tableName)\n\n#### Arguments\n\n**dbName** is a string indicating the name of a distributed database.\n\n**tableName** is a string indicating the name of a DFS table.\n\n#### Details\n\nUnregister a snapshot engine for a DFS table. In cluster mode, use this function to unregister the snapshot engine for the DFS table on all nodes.\n\n#### Examples\n\n```\nunregisterSnapshotEngine(\"dfs://compoDB\",\"pt\")\n```\n"
    },
    "unsubscribeTable": {
        "url": "https://docs.dolphindb.com/en/Functions/u/unsubscribeTable.html",
        "signatures": [
            {
                "full": "unsubscribeTable([server], tableName, [actionName], [removeOffset=true], [raftGroup])",
                "name": "unsubscribeTable",
                "parameters": [
                    {
                        "full": "[server]",
                        "name": "server",
                        "optional": true
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[actionName]",
                        "name": "actionName",
                        "optional": true
                    },
                    {
                        "full": "[removeOffset=true]",
                        "name": "removeOffset",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [unsubscribeTable](https://docs.dolphindb.com/en/Functions/u/unsubscribeTable.html)\n\n\n\n#### Syntax\n\nunsubscribeTable(\\[server], tableName, \\[actionName], \\[removeOffset=true], \\[raftGroup])\n\n#### Arguments\n\n**server** (optional) is a string indicating the alias of a server or the xdb connection to a server where the stream table is located. If it is unspecified or an empty string (\"\"), it means the local instance.\n\n**tableName** is a string indicating the name of the shared stream table to be unsubscribed on the aforementioned server.\n\n**actionName** (optional) is a string indicating the name assigned to the handler. It can have letters, digits and underscores. If actionName is specified when the subscription is initiated, it must be specified in unsubscribeTable as well.\n\n**removeOffset** (optional) is a Boolean value indicating whether to delete the offset of the latest record that has been calculated. (set *persistOffset* = true in [subscribeTable](https://docs.dolphindb.com/en/Functions/s/subscribeTable.html) to keep the offset of latest record.)\n\n**raftGroup** (optional) is the raft group ID specified in function `subscribeTable`. Specify it in `unsubscribeTable` to disable high availability on the subscriber. If the parameter is not specified, the subscription information will be kept in the raft group and the new leader will resubscribe to the stream table.\n\n**Note:** The command `unsubscribeTable` can only be executed on the leader node if the parameter *raftGroup* is specified.\n\n#### Details\n\nStop subscribing to data from the publisher. All messages of the topic in the message queue of the execution thread will be deleted.\n\nWhen `unsubscribeTable` is called, unprocessed messages in the queue of the stream execution thread will be deleted.\n\n#### Examples\n\nCreate table \"trades\" on the publisher.\n\n```\nt=streamTable(100:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nshare t as trades\nt=NULL\n```\n\nCreate table \"trades2\" on the subscriber to stream data from table \"trades\" from the publisher:\n\n```\nt=streamTable(100:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nshare t as trades2\nt=NULL\nh=xdb(\"localhost\",8902)\nsubscribeTable(server=h, tableName=\"trades\", actionName=\"sub1\", handler=trades2);\n// output\nlocalhost:8902:node1/trades/sub1\n```\n\nTo unsubscribe from table \"trades\":\n\n```\nunsubscribeTable(h, \"trades\",\"sub1\");\n```\n"
    },
    "update!": {
        "url": "https://docs.dolphindb.com/en/Functions/u/update!.html",
        "signatures": [
            {
                "full": "update!(table, colNames, newValues, [filter])",
                "name": "update!",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "newValues",
                        "name": "newValues"
                    },
                    {
                        "full": "[filter]",
                        "name": "filter",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [update!](https://docs.dolphindb.com/en/Functions/u/update!.html)\n\n\n\n#### Syntax\n\nupdate!(table, colNames, newValues, \\[filter])\n\n#### Arguments\n\n**table** is a DolphinDB table. It can be a partitioned in-memory table.\n\n**colNames** is a string scalar/vector indicating the columns to be updated.\n\n**newValues** is a piece of metacode with the operations for the specified columns. Metacode is objects or expressions within \"<\" and \">\". For details about metacode, please refer to [Metaprogramming](https://docs.dolphindb.com/en/Programming/Metaprogramming/functional_meta.html).\n\n**filter** (optional) is a piece of metacode with filterting conditions.\n\n#### Details\n\nUpdate columns of a table in place. If a column in *colNames* doesn't exist, create a new column; otherwise update the existing column. If a *filter* is specified, only rows satisfying the filtering condition will be updated.\n\nThis operation is parallel if the table is a partitioned table and if the parallel processing feature is enabled (when the configuration parameter *localExcutors* > 0).\n\n#### Examples\n\n```\nn=20000000\nworkDir = \"C:/DolphinDB/Data\"\nif(!exists(workDir)) mkdir(workDir)\ntrades=table(rand(`IBM`MSFT`GM`C`YHOO`GOOG,n) as sym, 2000.01.01+rand(365,n) as date, 10.0+rand(2.0,n) as price, rand(1000,n) as qty)\ntrades.saveText(workDir + \"/trades.txt\");\n\ntrades = ploadText(workDir + \"/trades.txt\")\nselect top 10 * from trades;\n```\n\n| sym  | date       | price     | qty |\n| ---- | ---------- | --------- | --- |\n| MSFT | 2000.10.09 | 10.123936 | 569 |\n| IBM  | 2000.09.22 | 10.825785 | 834 |\n| MSFT | 2000.09.13 | 10.467937 | 418 |\n| IBM  | 2000.08.06 | 10.159152 | 252 |\n| IBM  | 2000.09.01 | 10.614444 | 400 |\n| MSFT | 2000.05.03 | 10.40847  | 253 |\n| MSFT | 2000.02.20 | 11.470027 | 431 |\n| YHOO | 2000.11.09 | 11.570013 | 518 |\n| GOOG | 2000.03.02 | 10.206973 | 630 |\n| C    | 2000.07.09 | 10.477621 | 287 |\n\n```\ntrades.update!(`qty, <qty+10>)\nselect top 10 * from trades;\n```\n\n| sym  | date       | price     | qty |\n| ---- | ---------- | --------- | --- |\n| MSFT | 2000.10.09 | 10.123936 | 579 |\n| IBM  | 2000.09.22 | 10.825785 | 844 |\n| MSFT | 2000.09.13 | 10.467937 | 428 |\n| IBM  | 2000.08.06 | 10.159152 | 262 |\n| IBM  | 2000.09.01 | 10.614444 | 410 |\n| MSFT | 2000.05.03 | 10.40847  | 263 |\n| MSFT | 2000.02.20 | 11.470027 | 441 |\n| YHOO | 2000.11.09 | 11.570013 | 528 |\n| GOOG | 2000.03.02 | 10.206973 | 640 |\n| C    | 2000.07.09 | 10.477621 | 297 |\n\n```\ntrades.update!(`qty`price, <[qty*2, price/2]>)\nselect top 10 * from trades;\n```\n\n| sym  | date       | price    | qty  |\n| ---- | ---------- | -------- | ---- |\n| MSFT | 2000.10.09 | 5.061968 | 1158 |\n| IBM  | 2000.09.22 | 5.412893 | 1688 |\n| MSFT | 2000.09.13 | 5.233969 | 856  |\n| IBM  | 2000.08.06 | 5.079576 | 524  |\n| IBM  | 2000.09.01 | 5.307222 | 820  |\n| MSFT | 2000.05.03 | 5.204235 | 526  |\n| MSFT | 2000.02.20 | 5.735014 | 882  |\n| YHOO | 2000.11.09 | 5.785007 | 1056 |\n| GOOG | 2000.03.02 | 5.103487 | 1280 |\n| C    | 2000.07.09 | 5.238811 | 594  |\n\n```\ntrades.update!(`qty`price, <[qty*2, price/2]>, <(sym in `IBM`MSFT`GM`GOOG) and date>=2000.07.01>)\nselect top 10 * from trades;\n```\n\n| sym  | date       | price    | qty  |\n| ---- | ---------- | -------- | ---- |\n| MSFT | 2000.10.09 | 2.530984 | 2316 |\n| IBM  | 2000.09.22 | 2.706446 | 3376 |\n| MSFT | 2000.09.13 | 2.616984 | 1712 |\n| IBM  | 2000.08.06 | 2.539788 | 1048 |\n| IBM  | 2000.09.01 | 2.653611 | 1640 |\n| MSFT | 2000.05.03 | 5.204235 | 526  |\n| MSFT | 2000.02.20 | 5.735014 | 882  |\n| YHOO | 2000.11.09 | 5.785007 | 1056 |\n| GOOG | 2000.03.02 | 5.103487 | 1280 |\n| C    | 2000.07.09 | 5.238811 | 594  |\n"
    },
    "updateLicense": {
        "url": "https://docs.dolphindb.com/en/Functions/u/updateLicense.html",
        "signatures": [
            {
                "full": "updateLicense()",
                "name": "updateLicense",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [updateLicense](https://docs.dolphindb.com/en/Functions/u/updateLicense.html)\n\n\n\n#### Syntax\n\nupdateLicense()\n\n#### Arguments\n\nNone\n\n#### Details\n\nUpdate the license without restarting the node.\n\nAfter replacing the license file, executing this function can update the license without restarting the node. You can execute [getLicenseExpiration](https://docs.dolphindb.com/en/Functions/g/getLicenseExpiration.html) to check whether the license file has been updated.\n\nThe function only takes effect on the node where it is executed. For a cluster, it must be executed on all controllers, agents, and data nodes.\n\nNote:\n\n* The license for update must satisfy the following conditions (which can be checked with function [license](https://docs.dolphindb.com/en/Functions/l/license.html)):\n\n  * The client name (clientName) and the authorization mode (authorization) of the license must be the same as the original license.\n\n  * The number of nodes (maxNodes), memory size (maxMemoryPerNode) and the number of CPU cores (maxCoresPerNode) authorized by the license cannot be smaller than the original ones.\n\n* Online update is not supported if the original authorization is site.\n\n* Since version 1.30.21/2.00.9, DolphinDB process can be bound to specific CPU cores. If the binding cores are changed in the license to be replaced, DolphinDB must be rebooted after the upgrade.\n\n#### Examples\n\n```\nupdateLicense()\n// output\nauthorization->commercial\nlicenseType->0\nmaxMemoryPerNode->32\nmaxCoresPerNode->8\nclientName->test license\nbindCPU->true\nexpiration->2022.03.01\nmaxNodes->8\nversion->\nmodules->-1\n```\n"
    },
    "updateMarketHoliday": {
        "url": "https://docs.dolphindb.com/en/Functions/u/updateMarketHoliday.html",
        "signatures": [
            {
                "full": "updateMarketHoliday(marketName, holiday)",
                "name": "updateMarketHoliday",
                "parameters": [
                    {
                        "full": "marketName",
                        "name": "marketName"
                    },
                    {
                        "full": "holiday",
                        "name": "holiday"
                    }
                ]
            }
        ],
        "markdown": "### [updateMarketHoliday](https://docs.dolphindb.com/en/Functions/u/updateMarketHoliday.html)\n\n#### Syntax\n\nupdateMarketHoliday(marketName, holiday)\n\n#### Arguments\n\n**marketName** is a STRING scalar, indicating the identifier of the trading calendar, e.g., the Market Identifier Code of an exchange, or a user-defined calendar name.\n\n**holiday** is a vector of DATE type, indicating weekday holidays.\n\n**holiday** is a vector of DATE type, indicating holiday dates or trading dates.\n\n* When *dateType*='holidayDate', *holiday* should be specified as the dates of weekday holidays.\n\n* When *dateType*='tradingDate', *holiday* should be specified as trading dates.\n\n#### Details\n\nUpdates file of holiday dates or trading datesthe holiday calendar named *marketName* in memory online and synchronizes updates to the file in *marketHolidayDir*. If the file does not exist in memory, an error will be reported.\n\n**Note:**\n\n* It can only be executed by an administrator.\n\n* It only takes effect on the current node. In a cluster, `pnodeRun` can be used to call this function on all data/compute nodes.\n\n* If you have manually modified the trading calendar under *marketHolidayDir* and want to synchronize updates to memory without restarting the server, you can use function `loadText` to load the updated CSV file to an in-memory table and convert it to a vector (holiday), then update the holiday to memory by `updateMarketHoliday`.\n\n#### Examples\n\n```\naddMarketHoliday(\"CFFEX\",2022.01.03 2022.01.05)\ntemporalAdd(2022.01.01,1,\"CFFEX\")\n// output\n2022.01.04\n\nindex = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.04]\ns = indexedSeries(index, 1..4)\ns.resample(\"CFFEX\", sum);\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2021.12.31 | 6    |\n| 2022.01.04 | 4    |\n\n```\nupdateMarketHoliday(\"CFFEX\",2022.01.03 2022.01.04)\ntemporalAdd(2022.01.01,1,\"CFFEX\")\n// output\n2022.01.05\n```\n\nRelated functions: [addMarketHoliday](https://docs.dolphindb.com/en/Functions/a/addMarketHoliday.html), [getMarketCalendar](https://docs.dolphindb.com/en/Functions/g/getMarketCalendar.html)\n\n"
    },
    "updatePKEYDeleteBitmap": {
        "url": "https://docs.dolphindb.com/en/Functions/u/updatePKEYDeleteBitmap.html",
        "signatures": [
            {
                "full": "updatePKEYDeleteBitmap(chunkId)",
                "name": "updatePKEYDeleteBitmap",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    }
                ]
            }
        ],
        "markdown": "### [updatePKEYDeleteBitmap](https://docs.dolphindb.com/en/Functions/u/updatePKEYDeleteBitmap.html)\n\n\n\n#### Syntax\n\nupdatePKEYDeleteBitmap(chunkId)\n\n#### Arguments\n\n**chunkId**is a STRING scalar or vector indicating the target chunk ID(s).\n\n#### Details\n\nRefresh the PKEY engine's delete bitmap and clear the staging buffer when finished.\n\n#### Examples\n\n```\nupdatePKEYDeleteBitmap(chunkId=\"1486f935-6f87-479c-b341-34c6a303d4f9\")\n```\n"
    },
    "updateRule": {
        "url": "https://docs.dolphindb.com/en/Functions/u/updateRule.html",
        "signatures": [
            {
                "full": "updateRule(engineName, key, rules)",
                "name": "updateRule",
                "parameters": [
                    {
                        "full": "engineName",
                        "name": "engineName"
                    },
                    {
                        "full": "key",
                        "name": "key"
                    },
                    {
                        "full": "rules",
                        "name": "rules"
                    }
                ]
            }
        ],
        "markdown": "### [updateRule](https://docs.dolphindb.com/en/Functions/u/updateRule.html)\n\n\n\n#### Syntax\n\nupdateRule(engineName, key, rules)\n\n#### Arguments\n\n**engineName**is a STRING scalar indicating the engine name.\n\n**key**is a scalar of STRING or INT type that specifies the key of rule set to be updated.\n\n**rules**is a tuple of metacode indicating the rules to be updated.\n\n#### Details\n\nIf the specified *key*already exists in the rule engine, update the corresponding value with *rules*;\n\nIf the *key*does not exist in the rule engine, add the *rules*.\n\n**Return value**: true if successful, otherwise false.\n\n#### Examples\n\n```\n// create a rule engine\nx = [1, 2, NULL]\ny = [ [ < value>1 > ], [ < price<2 >, < price>6 > ], [ < value*price>10 > ] ]\nruleSets = dict(x, y)\nnames = `sym`value`price`quatity\ntypes = [INT, DOUBLE, DOUBLE, DOUBLE]\ndummy = table(10:0, names, types)\noutputNames = `sym`value`price`rule\noutputTypes = [INT, DOUBLE, DOUBLE, BOOL[]]\noutputTable = table(10:0, outputNames, outputTypes)\ntest = createRuleEngine(\"ruleEngineTest\",ruleSets,dummy ,`sym`value`price, outputTable,  \"all\",`sym)\n\ntest.append!(table(1 as sym, 0 as value, 2 as price, 3 as quatity))\ntest.append!(table(3 as sym, 6 as value, 1 as price, 3 as quatity))\n// outputTable\n1\t0\t2\t[false]\n3\t6\t1\t[false]\n\n// modify the rule for sym=1 to value >=0\nupdateRule(\"ruleEngineTest\", 1, [ <value >= 0>])\ntest.append!(table(1 as sym, 0 as value, 2 as price, 3 as quatity))\n// outputTable\n1\t0\t2\t[true]\n\n// add the rule value > 5 for sym=3  \nupdateRule(\"ruleEngineTest\",3,[<value>5>])\ntest.append!(table(3 as sym, 6 as value, 1 as price, 3 as quatity))\n// outputTable\n3\t6\t1\t[true]\n```\n"
    },
    "upper": {
        "url": "https://docs.dolphindb.com/en/Functions/u/upper.html",
        "signatures": [
            {
                "full": "upper(X)",
                "name": "upper",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [upper](https://docs.dolphindb.com/en/Functions/u/upper.html)\n\n\n\n#### Syntax\n\nupper(X)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n#### Details\n\nConvert all characters in a string or a list of strings into upper cases.\n\n#### Examples\n\n```\nx = `Ibm`C`AapL;\nx.upper();\n// output\n[\"IBM\",\"C\",\"AAPL\"]\n\n(`Thl).upper();\n// output\nTHL\n```\n\nRelated function: [lower](https://docs.dolphindb.com/en/Functions/l/lower.html)\n"
    },
    "upsert!": {
        "url": "https://docs.dolphindb.com/en/Functions/u/upsert!.html",
        "signatures": [
            {
                "full": "upsert!(obj, newData, [ignoreNull=false], [keyColNames], [sortColumns])",
                "name": "upsert!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "newData",
                        "name": "newData"
                    },
                    {
                        "full": "[ignoreNull=false]",
                        "name": "ignoreNull",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColNames]",
                        "name": "keyColNames",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns]",
                        "name": "sortColumns",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [upsert!](https://docs.dolphindb.com/en/Functions/u/upsert!.html)\n\n\n\n#### Syntax\n\nupsert!(obj, newData, \\[ignoreNull=false], \\[keyColNames], \\[sortColumns])\n\n#### Arguments\n\n**obj** is a keyed table, indexed table, or a DFS table.\n\n**newData** is an in-memory table.\n\n**ignoreNull** (optional) is a Boolean value. If set to true, for the NULL values in *newData*, the corresponding elements in *obj* are not updated. The default value is false.\n\n**keyColNames** (optional) is a STRING scalar/vector. When *obj* is a DFS table, *keyColNames* and the partitioning columns are considered as the key columns.\n\n**sortColumns** (optional) is a STRING scalar or vector. The updated partitions will be sorted on *sortColumns* (only within each partition, not across partitions).\n\n**Note:**\n\n* *sortColumns* is supported in `upsert!` only with the OLAP engine.\n* To specify *sortColumns*, *obj* must be a DFS table.\n* When *obj* is an empty table, setting *sortColumns* has no effect. That is, the system will not sort the inserted data.\n* Parameters *ignoreNull*, *keyColNames*, *sortColumns* are not supported for DFS tables in the PKEY database.\n\n#### Details\n\nInsert rows into a keyed table or indexed table if the values of the primary key do not already exist, or update them if they do.\n\n**Note:**\n\n* When using this function, please make sure the corresponding columns in table *newData* and *obj* are arranged in the same order, or the system may generate the wrong result or throw an error.\n\n* If *obj* is a DFS table with duplicated \"keys\" (as specified by keyColNames), `upsert!` on rows with duplicated keys only updates the first row.\n\n#### Examples\n\n`upsert!` a keyed table:\n\n```\nsym=`A`B`C\ndate=take(2021.01.06, 3)\nx=1 2 3\ny=5 6 7\nt=keyedTable(`sym`date, sym, date, x, y)\nt;\n```\n\n| sym | date       | x | y |\n| --- | ---------- | - | - |\n| A   | 2021.01.06 | 1 | 5 |\n| B   | 2021.01.06 | 2 | 6 |\n| C   | 2021.01.06 | 3 | 7 |\n\n```\nnewData = table(`A`B`C`D as sym, take(2021.01.06, 4) as date, NULL NULL 300 400 as x, NULL 600 700 800 as y);\nnewData;\n```\n\n| sym | date       | x   | y   |\n| --- | ---------- | --- | --- |\n| A   | 2021.01.06 |     |     |\n| B   | 2021.01.06 |     | 600 |\n| C   | 2021.01.06 | 300 | 700 |\n| D   | 2021.01.06 | 400 | 800 |\n\n```\nupsert!(t, newData, ignoreNull=true)\nt;\n```\n\n| sym | date       | x   | y   |\n| --- | ---------- | --- | --- |\n| A   | 2021.01.06 | 1   | 5   |\n| B   | 2021.01.06 | 2   | 600 |\n| C   | 2021.01.06 | 300 | 700 |\n| D   | 2021.01.06 | 400 | 800 |\n\nThe example above is for the case when *ignoreNull* = true. Compare it with the following example where *ignoreNull* = false (by default).\n\n```\nsym=`A`B`C\ndate=take(2021.01.06, 3)\nx=1 2 3\ny=5 6 7\nt=keyedTable(`sym`date, sym, date, x, y)\nupsert!(t, newData)\nt;\n```\n\n| sym | date       | x   | y   |\n| --- | ---------- | --- | --- |\n| A   | 2021.01.06 |     |     |\n| B   | 2021.01.06 |     | 600 |\n| C   | 2021.01.06 | 300 | 700 |\n| D   | 2021.01.06 | 400 | 800 |\n\n`upsert!` a DFS table:\n\n```\nID=0 1 2 2\nx=0.1*0..3\nt=table(ID, x)\ndb=database(\"dfs://rangedb128\", VALUE,  0..10)\npt=db.createPartitionedTable(t, `pt, `ID)\npt.append!(t)\nselect * from pt;\n```\n\n| ID | x   |\n| -- | --- |\n| 0  | 0   |\n| 1  | 0.1 |\n| 2  | 0.2 |\n| 2  | 0.3 |\n\n```\nt1=table(1 as ID, 111 as x)\nupsert!(pt, t1, keyColNames=`ID)\nselect * from pt;\n```\n\n| ID | x   |\n| -- | --- |\n| 0  | 0   |\n| 1  | 111 |\n| 2  | 0.2 |\n| 2  | 0.3 |\n\n```\nt1=table(2 as ID, 222 as x)\nupsert!(pt, t1, keyColNames=`ID)\nselect * from pt;\n```\n\n| ID | x   |\n| -- | --- |\n| 0  | 0   |\n| 1  | 111 |\n| 2  | 222 |\n| 2  | 0.3 |\n\nUse `upsert!` to update a DFS table. If *ignoreNull* = true, the records in the target table corresponding to the NULL value of the new data will not be updated.\n\n```\nif(existsDatabase(\"dfs://valuedemo\")) {\n  dropDatabase(\"dfs://valuedemo\")\n}\ndb = database(\"dfs://valuedemo\", VALUE, 1..10)\nt = table(take(1..10, 100) as id, 1..100 as id2, 100..1 as value)\npt = db.createPartitionedTable(t, \"pt\", `id).append!(t)\nt2 = table( 1 2 as id, 1 2 as id2, 1 NULL as value)\nupsert!(pt, t2, true, \"id2\")\n```\n\n```\nif(existsDatabase(\"dfs://upsert\")) {\n  dropDatabase(\"dfs://upsert\")\n}\nsym=`A`B`C`A`D`B`A\ndate=take(2021.12.10,3) join take(2021.12.09, 3) join 2021.12.10\nprice=8.3 7.2 3.7 4.5 6.3 8.4 7.6\nval=10 19 13 9 19 16 10\nt=table(sym, date, price, val)\ndb=database(\"dfs://upsert\", VALUE,  `A`B`C)\npt=db.createPartitionedTable(t, `pt, `sym)\npt.append!(t)\nt1=table(`A`B`E as sym, take(2021.12.09, 3) as date, 11.1 10.5 6.9 as price, 12 9 11 as val)\nupsert!(pt, t1, keyColNames=`sym, sortColumns=`date`val)\nselect * from pt\n```\n\n| sym | date       | price | val |\n| --- | ---------- | ----- | --- |\n| A   | 2021.12.09 | 4.5   | 9   |\n| A   | 2021.12.09 | 11.1  | 12  |\n| A   | 2021.12.10 | 7.6   | 10  |\n| B   | 2021.12.09 | 10.5  | 9   |\n| B   | 2021.12.09 | 8.4   | 16  |\n| C   | 2021.12.10 | 3.7   | 13  |\n| D   | 2021.12.09 | 6.3   | 19  |\n| E   | 2021.12.09 | 6.9   | 11  |\n"
    },
    "uuid": {
        "url": "https://docs.dolphindb.com/en/Functions/u/uuid.html",
        "signatures": [
            {
                "full": "uuid(X)",
                "name": "uuid",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [uuid](https://docs.dolphindb.com/en/Functions/u/uuid.html)\n\n\n\n#### Syntax\n\nuuid(X)\n\n#### Arguments\n\n**X** is a STRING scalar/vector.\n\n#### Details\n\nConvert STRING into UUID data type.\n\n#### Examples\n\n```\nuuid(\"\");\n// output\n00000000-0000-0000-0000-000000000000\n\na=uuid(\"9d457e79-1bed-d6c2-3612-b0d31c1881f6\");\na;\n// output\n9d457e79-1bed-d6c2-3612-b0d31c1881f6\n\ntypestr(a);\n// output\nUUID\n```\n"
    },
    "valueAtRisk": {
        "url": "https://docs.dolphindb.com/en/Functions/v/valueAtRisk.html",
        "signatures": [
            {
                "full": "valueAtRisk(returns, method, [confidenceLevel=0.95])",
                "name": "valueAtRisk",
                "parameters": [
                    {
                        "full": "returns",
                        "name": "returns"
                    },
                    {
                        "full": "method",
                        "name": "method"
                    },
                    {
                        "full": "[confidenceLevel=0.95]",
                        "name": "confidenceLevel",
                        "optional": true,
                        "default": "0.95"
                    }
                ]
            }
        ],
        "markdown": "### [valueAtRisk](https://docs.dolphindb.com/en/Functions/v/valueAtRisk.html)\n\n#### Syntax\n\nvalueAtRisk(returns, method, \\[confidenceLevel=0.95])\n\nAlias: VaR\n\n#### Arguments\n\n**returns** is a numeric vector representing the returns. The element must be greater than -1 and cannot be empty.\n\n**method** is a string indicating the VaR calculation method, which can be:\n\n* 'normal': parametric method with normal distribution\n* 'logNormal': parametric method with log-normal distribution\n* 'historical': historical method\n* 'monteCarlo': Monte Carlo simulation\n\n**confidenceLevel** (optional) is a numeric scalar representing the confidence level, with a valid range of (0,1). The default value is 0.95.\n\n#### Details\n\nCalculate Value at Risk (VaR) to predict the minimum return within a given confidence level (e.g. 95% or 99%) over a specific time frame.\n\n**Return value**: a DOUBLE value indicating the absolute value of the minimum return.\n\n#### Examples\n\nCalculate VaR using historical method at a confidence level of 0.9 based on given returns:\n\n```\nreturns = [0.0, -0.0023816107391389394, -0.0028351258634076834, 0.00789570628538656, 0.0022056267475062397, -0.004515475812603498, 0.0031189325339843646, 0.010774648811452205, 0.0030816164453268957, 0.02172541561228001, 0.011106185767699728, -0.005369098699244845, -0.0096490689793588, 0.0025152212699484314, 0.017822140037111668, -0.02837536728283525, 0.018373545076599204, -0.0026401111537113003, 0.019524374522517898, -0.010800546314337627, 0.014073362622486131, -0.00398277532382243, 0.008398647051501285, 0.0024056749358184904, 0.007093080335863512, -0.005332549248384733, -0.008471915938733665, -0.0038788486165083342, -0.01308504169086584, 0.00350496242864784, 0.009036118926745962, 0.0013358223875250545, 0.0036426642608267563, 0.003974568474545581, -0.003944066366522669, -0.011969668605022311, 0.015116930499066374, 0.006931427295653037, -0.0032650627551519267, 0.003407880132851648]\nvalueAtRisk(returns, 'historical', 0.9);\n//output: 0.009764216712\n```\n\n"
    },
    "valueChanged": {
        "url": "https://docs.dolphindb.com/en/Functions/v/valueChanged.html",
        "signatures": [
            {
                "full": "valueChanged(X, [mode=\"prev\"])",
                "name": "valueChanged",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[mode=\"prev\"]",
                        "name": "mode",
                        "optional": true,
                        "default": "\"prev\""
                    }
                ]
            }
        ],
        "markdown": "### [valueChanged](https://docs.dolphindb.com/en/Functions/v/valueChanged.html)\n\n\n\n#### Syntax\n\nvalueChanged(X, \\[mode=\"prev\"])\n\n#### Arguments\n\n**X** is a vector/matrix/table/tuple of STRING, BOOL, temporal or numeric type.\n\n**mode** (optional) is a string. It can take the value of \"prev\", \"next\", \"any\" and \"all\". The default value is \"prev\".\n\n* \"prev\": the previous element\n\n* \"next\": the next element\n\n* \"any\": the previous OR the next element\n\n* \"all\": the previous AND the next element\n\n#### Details\n\nCompare each element in *X* with the element specified by mode. Return true if the value is changed, otherwise false. Return false if the compared object does not exist.\n\nFor example, for the first element of `valueChanged(X, [mode=\"prev\"])` and the last element of `valueChanged(X, [mode=\"next\"])`, the function returns false.\n\nIf *X* is a matrix/table, perform the aforementioned operation on each column and return a matrix/table.\n\n#### Examples\n\n```\nx= 1 2 2 2 2 3 NULL 3 4 8\nvalueChanged(x)\n// output\n[false,true,false,false,false,true,true,true,true,true]\n\nvalueChanged(x,\"next\")\n// output\n[true,false,false,false,true,true,true,true,true,false]\n\nvalueChanged(x,\"any\")\n// output\n[true,true,false,false,true,true,true,true,true,true]\n\nvalueChanged(x,\"all\")\n// output\n[false,false,false,false,false,true,true,true,true,false]\n\ntup=(1 2 3, `A`A`B`C, 2021.10.12+1 2 2)\nvalueChanged(tup)\n// output\n([false,true,true],[false,false,true,true],[false,true,false])\n\nm=matrix(1 2 3, 1 2 3, 1 3 3)\nvalueChanged(m)\n```\n\n| col1  | col2  | col3  |\n| ----- | ----- | ----- |\n| false | false | false |\n| true  | true  | true  |\n| true  | true  | false |\n\n```\nid= 1 2 2 2 2 3 3 4 8\nsym=`A + string(1 2 2 2 2 3 3 4 8)\nval=83.8 92.8 8.1 61.4 40.7 67.2 15.2 20.6 96.5\nt=table(id, sym, val)\nvalueChanged(t)\n```\n\n| id    | sym   | val   |\n| ----- | ----- | ----- |\n| false | false | false |\n| true  | true  | true  |\n| false | false | true  |\n| false | false | true  |\n| false | false | true  |\n| true  | true  | true  |\n| false | false | true  |\n| true  | true  | true  |\n| true  | true  | true  |\n\nRelated function: [keys](https://docs.dolphindb.com/en/Functions/k/keys.html)\n"
    },
    "values": {
        "url": "https://docs.dolphindb.com/en/Functions/v/values.html",
        "signatures": [
            {
                "full": "values(X)",
                "name": "values",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [values](https://docs.dolphindb.com/en/Functions/v/values.html)\n\n\n\n#### Syntax\n\nvalues(X)\n\n#### Arguments\n\n**X** is a dictionary/table.\n\n#### Details\n\nReturn all values of a dictionary, or all the columns of a table in a tuple.\n\n#### Examples\n\n```\nz=dict(`INT,`DOUBLE)\nz[5]=7.9\nz[3]=6\nz.values();\n// output\n[6,7.9]\n\nt = table(1 2 3 as id, 4 5 6 as x, `IBM`MSFT`GOOG as name);\nvalues(t);\n// output\n([1,2,3],[4,5,6],[\"IBM\",\"MSFT\",\"GOOG\"])\n```\n\nRelated function: [keys](https://docs.dolphindb.com/en/Functions/k/keys.html)\n"
    },
    "var": {
        "url": "https://docs.dolphindb.com/en/Functions/v/var.html",
        "signatures": [
            {
                "full": "var(X)",
                "name": "var",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [var](https://docs.dolphindb.com/en/Functions/v/var.html)\n\n\n\n#### Syntax\n\nvar(X)\n\n#### Arguments\n\n**X** is a scalar/vector/matrix.\n\n#### Details\n\nIf *X* is a vector, return the the (unbiased) sample standard variance of *X*.\n\nIf *X* is a matrix, calculate the the (unbiased) sample standard variance of each column of *X* and return a vector.\n\nAs with all aggregate functions, NULL values are not included in the calculation.\n\n**Note:** The result is sample variance instead of population variance.\n\n#### Examples\n\n```\nvar(1 1 1);\n// output\n0\nvar(1 2 3);\n// output\n1\n\nm=matrix(1 3 5 7 9, 1 4 7 10 13);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 3  | 4  |\n| 5  | 7  |\n| 7  | 10 |\n| 9  | 13 |\n\n```\nvar(m);\n// output\n[10,22.5]\n```\n\nRelated functions: [covar](https://docs.dolphindb.com/en/Functions/c/covar.html) and [corr](https://docs.dolphindb.com/en/Functions/c/corr.html)\n"
    },
    "varma": {
        "url": "https://docs.dolphindb.com/en/Functions/v/varma.html",
        "signatures": [
            {
                "full": "varma(ds,endogColNames,order,[exog],[trend='c'],[errorCovType='unstructured'],[measurementError=false],[enforceStationarity=true],[enforceInvertibility=true],[trendOffset=1], [maxIter=50])",
                "name": "varma",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "endogColNames",
                        "name": "endogColNames"
                    },
                    {
                        "full": "order",
                        "name": "order"
                    },
                    {
                        "full": "[exog]",
                        "name": "exog",
                        "optional": true
                    },
                    {
                        "full": "[trend='c']",
                        "name": "trend",
                        "optional": true,
                        "default": "'c'"
                    },
                    {
                        "full": "[errorCovType='unstructured']",
                        "name": "errorCovType",
                        "optional": true,
                        "default": "'unstructured'"
                    },
                    {
                        "full": "[measurementError=false]",
                        "name": "measurementError",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[enforceStationarity=true]",
                        "name": "enforceStationarity",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[enforceInvertibility=true]",
                        "name": "enforceInvertibility",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[trendOffset=1]",
                        "name": "trendOffset",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[maxIter=50]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "50"
                    }
                ]
            }
        ],
        "markdown": "### [varma](https://docs.dolphindb.com/en/Functions/v/varma.html)\n\n\n\n#### Syntax\n\nvarma(ds,endogColNames,order,\\[exog],\\[trend='c'],\\[errorCovType='unstructured'],\\[measurementError=false],\\[enforceStationarity=true],\\[enforceInvertibility=true],\\[trendOffset=1], \\[maxIter=50])\n\n#### Details\n\n`varma` analyzes multivariate time series using a Vector Autoregressive Moving-Average (VARMA) model. It returns a dictionary containing the analysis results.\n\n**Return value:** A dictionary containing the following keys:\n\n* params: A floating matrix of estimated parameters for the VARMA model.\n* kAr: An integer representing the order of the vector autoregressive process.\n* kMa: An integer representing the order of the vector moving average part.\n* kTrend: An integer representing the number of trend terms in the VARMA model.\n* nobs: An integer representing the number of observations in the input multivariate time series.\n* aic: A floating-point number representing the Akaike Information Criterion.\n* bic: A floating-point number representing the Bayesian Information Criterion.\n* hqic: A floating-point number representing the Hannan-Quinn Information Criterion.\n* llf: A floating-point number representing the log-likelihood value of the VARMA model.\n\n#### Arguments\n\n* **ds** is an in-memory table or a vector of DATASOURCE type containing the multivariate time series to be analyzed. *ds* cannot be empty.\n* **endogColNames** is a STRING vector indicating the column names of the endogenous variables in *ds*.\n* **order** is a vector with two non-negative integers indicating the number of autoregressive (AR) and moving average (MA) parameters to use.\n* **exog** (optional) is a numeric matrix representing exogenous variables except the endogenous time series. Each column of the matrix represents the time series data of an exogenous variable, and the number of rows must equal the number of rows in *ds*.\n* **trend** (optional) is a string indicating the constant and trend order used in the regression. Possible values:\n  * 'c' (default) - add constant\n  * 'ct' - constant and treand\n  * 'ctt' - constant, linear, and quadratic trend\n  * 'n' - no constant or trend\n* **errorCovType** (optional) is a string scalar specifying the structure of the error term's covariance matrix. Possible values:\n  * 'unstructured' (default): Preserve the lower triangular part of the covariance matrix\n  * 'diagonal': Preserve only the diagonal part\n* **measurementError** (optional) is a boolean scalar indicating whether to assume the endogenous observations were measured with error. Default is false.\n* **enforceStationarity** (optional) is a boolean scalar indicating whether to transform AR parameters to enforce stationarity in the autoregressive component of the model. Default is true.\n* **enforceInvertibility** (optional) is a boolean scalar indicating whether to transform MA parameters to enforce invertibility in the moving average component of the model. Default is true.\n* **trendOffset** (optional) is a positive representing the offset at which time trend values start. Default is 1.\n* **maxIter** (optional) is a positive integer indicating the maximum number of iterations during fitting. Default is 50.\n\n#### Examples\n\nAnalyze the multivariate time series in the *macrodata.csv* file:\n\n```\ndata = loadText(\"macrodata.csv\")\nmy_exog = matrix(DOUBLE, size(data), 1,,1)\ntimer result = vectorARMA(data, [`realgdp, `realcons, `realinv],[1,1],trend=\"c\", exog=my_exog)\nprint(result.params)\n\n/* Output:\nparams->[0.001790301048949,0.00316068649919,-0.007884084373724,-0.338899906387031,0.755151620289276,0.058664894089324,-0.133085850042808,0.327149514373616,0.042496018394458,-2.208341476722053,4.608021740892838,0.302452516000534,0.05672697191516,-0.069554114113286,-0.024169851951263,0.030727418751981,-0.05657124857038,-0.015977698360683,0.249792312785792,-0.171657789522291,-0.075503308800943,0.001790301048949,0.00316068649919,-0.007884084373724,0.007688385840775,0.003912860123486,0.005144416435363,0.030336928784212,-0.016066382781189,0.020321167196668]\nllf->1974.199777819503424\nkAr->1\nkMa->1\nkTrend->1\nnobs->202\naic->-3888.399555639006848\nbic->-3789.151524716970925\nhqic->-3848.243622757993762\n*/\n```\n"
    },
    "varp": {
        "url": "https://docs.dolphindb.com/en/Functions/v/varp.html",
        "signatures": [
            {
                "full": "varp(X)",
                "name": "varp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [varp](https://docs.dolphindb.com/en/Functions/v/varp.html)\n\n\n\n#### Syntax\n\nvarp(X)\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n#### Details\n\nIf *X* is a vector, return the population variance of *X*.\n\nIf *X* is a matrix, ccalculate the population variance of each column and return a vector.\n\nAs with all other aggregate functions, NULL values are ignored in the calculation.\n\n#### Examples\n\n```\nvarp(1 1 1);\n// output\n0\nvarp(1 2 3);\n// output\n0.666667\n\nm=matrix(1 3 5 7 9, 1 4 7 10 13);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 3  | 4  |\n| 5  | 7  |\n| 7  | 10 |\n| 9  | 13 |\n\n```\nvarp(m);\n// output\n[8,18]\n```\n"
    },
    "VaR": {
        "url": "https://docs.dolphindb.com/en/Functions/v/VaR_0.html",
        "signatures": [
            {
                "full": "valueAtRisk(returns, method, [confidenceLevel=0.95])",
                "name": "valueAtRisk",
                "parameters": [
                    {
                        "full": "returns",
                        "name": "returns"
                    },
                    {
                        "full": "method",
                        "name": "method"
                    },
                    {
                        "full": "[confidenceLevel=0.95]",
                        "name": "confidenceLevel",
                        "optional": true,
                        "default": "0.95"
                    }
                ]
            }
        ],
        "markdown": "### [VaR](https://docs.dolphindb.com/en/Functions/v/VaR_0.html)\n\nAlias for [valueAtRisk](https://docs.dolphindb.com/en/Functions/v/valueAtRisk.html)\n\n\nDocumentation for the `valueAtRisk` function:\n### [valueAtRisk](https://docs.dolphindb.com/en/Functions/v/valueAtRisk.html)\n\n#### Syntax\n\nvalueAtRisk(returns, method, \\[confidenceLevel=0.95])\n\nAlias: VaR\n\n#### Arguments\n\n**returns** is a numeric vector representing the returns. The element must be greater than -1 and cannot be empty.\n\n**method** is a string indicating the VaR calculation method, which can be:\n\n* 'normal': parametric method with normal distribution\n* 'logNormal': parametric method with log-normal distribution\n* 'historical': historical method\n* 'monteCarlo': Monte Carlo simulation\n\n**confidenceLevel** (optional) is a numeric scalar representing the confidence level, with a valid range of (0,1). The default value is 0.95.\n\n#### Details\n\nCalculate Value at Risk (VaR) to predict the minimum return within a given confidence level (e.g. 95% or 99%) over a specific time frame.\n\n**Return value**: a DOUBLE value indicating the absolute value of the minimum return.\n\n#### Examples\n\nCalculate VaR using historical method at a confidence level of 0.9 based on given returns:\n\n```\nreturns = [0.0, -0.0023816107391389394, -0.0028351258634076834, 0.00789570628538656, 0.0022056267475062397, -0.004515475812603498, 0.0031189325339843646, 0.010774648811452205, 0.0030816164453268957, 0.02172541561228001, 0.011106185767699728, -0.005369098699244845, -0.0096490689793588, 0.0025152212699484314, 0.017822140037111668, -0.02837536728283525, 0.018373545076599204, -0.0026401111537113003, 0.019524374522517898, -0.010800546314337627, 0.014073362622486131, -0.00398277532382243, 0.008398647051501285, 0.0024056749358184904, 0.007093080335863512, -0.005332549248384733, -0.008471915938733665, -0.0038788486165083342, -0.01308504169086584, 0.00350496242864784, 0.009036118926745962, 0.0013358223875250545, 0.0036426642608267563, 0.003974568474545581, -0.003944066366522669, -0.011969668605022311, 0.015116930499066374, 0.006931427295653037, -0.0032650627551519267, 0.003407880132851648]\nvalueAtRisk(returns, 'historical', 0.9);\n//output: 0.009764216712\n```\n\n"
    },
    "vectorAR": {
        "url": "https://docs.dolphindb.com/en/Functions/v/vectorAR.html",
        "signatures": [
            {
                "full": "vectorAR(ds, endogColNames, [exog], [trend='c'], [maxLag], [ic])",
                "name": "vectorAR",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "endogColNames",
                        "name": "endogColNames"
                    },
                    {
                        "full": "[exog]",
                        "name": "exog",
                        "optional": true
                    },
                    {
                        "full": "[trend='c']",
                        "name": "trend",
                        "optional": true,
                        "default": "'c'"
                    },
                    {
                        "full": "[maxLag]",
                        "name": "maxLag",
                        "optional": true
                    },
                    {
                        "full": "[ic]",
                        "name": "ic",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [vectorAR](https://docs.dolphindb.com/en/Functions/v/vectorAR.html)\n\n\n\n#### Syntax\n\nvectorAR(ds, endogColNames, \\[exog], \\[trend='c'], \\[maxLag], \\[ic])\n\n#### Arguments\n\n**ds** is an in-memory table or a vector consisting of DataSource objects, containing the multivariate time series to be analyzed. *ds* cannot be empty.\n\n**endogColNames** is a STRING vector indicating the column names of the endogenous variables in *ds*. The matrix formed by *endogColNames* extracted from *ds*is the multivariate time series to be analyzed.\n\n**exog** (optional) is a numeric matrix representing exogenous variables except the endogenous time series. Each column of the matrix represents the time series data of an exogenous variable, and the number of rows must equal the number of rows in *ds*.\n\n**trend** (optional) specifies constants and trend orders used in the regression. It can be\n\n* 'c' (default) - add constant\n\n* 'ct' - constant and treand\n\n* 'ctt' - constant, linear, and quadratic trend\n\n* 'n' - no constant or trend\n\n**maxLag** (optional) is a non-negative integer representing the maximum number of lags to check for order selection. If not provided, the default value of is used, where *nobs*indicates the sample size.\n\n**ic** (optional) is a STRING scalar indicating the information criterion to use for VAR order selection. The default value is NULL. It can be:\n\n* 'aic': Akaike\n\n* 'bic': Bayesian/Schwarz\n\n* 'fpe': Final prediction error\n\n* 'hqic': Hannan-Quinn\n\n#### Details\n\nAnalyze multivariate time series using the Vector Autoregression model (VAR model).\n\n\\*\\*Return Value:\\*\\*A dictionary representing the analysis results of the VAR model with the following members:\n\n* params: A floating-point matrix representing the parameters obtained from fitting the VAR model.\n\n* kAr: An integer representing the order of the VAR process.\n\n* kTrend: An integer representing the number of trends in the VAR process.\n\n* nobs: An integer representing the number of observations in the VAR model analysis.\n\n* sigmaU: A floating-point matrix representing the estimated variance of the white noise process.\n\n* sigmaUMle: A floating-point matrix representing the biased maximum likelihood estimate of the noise process covariance.\n\n* aic: A floating-point scalar representing the Akaike Information Criterion.\n\n* bic: A floating-point scalar representing the Bayesian Information Criterion.\n\n* hqic: A floating-point scalar representing the Hannan-Quinn Information Criterion.\n\n* fpe: A floating-point scalar representing the Final Prediction Error Information Criterion.\n\n* llf: A floating-point scalar representing the log-likelihood value of the VAR model.\n\n#### Examples\n\nThis example uses a file named macrodata.csv, taking the *realgdp*, *realcons*, and *realinv*columns as endogenous variables, and sets the *maxlag*to 2. The VAR model is then used to analyze the multivariate time series.\n\nOutput:\n\n```\nnobs->200\nhqic->-27.789187688321\nllf->1962.570824044325\nkTrend->1\naic->-27.929339439671\nfpe->0E-12\nparams->\n#0              #1              #2             \n0.001526972352  0.005459603048  -0.023902520885\n-0.279434735873 -0.100467978082 -1.970973673795\n0.675015751748  0.268639552522  4.414162326990 \n0.033219450793  0.025738726522  0.225478953223 \n0.008221084912  -0.123173927706 0.380785849237 \n0.290457628129  0.232499435917  0.800280917529 \n-0.007320907532 0.023503761040  -0.124079061576\nsigmaU->\n#0             #1             #2            \n0.000057113648 0.000029839495 0.000224637467\n0.000029839495 0.000042830532 0.000034191732\n0.000224637467 0.000034191732 0.001567709895\nsigmaUMle->\n#0             #1             #2            \n0.000055114670 0.000028795112 0.000216775156\n0.000028795112 0.000041331464 0.000032995021\n0.000216775156 0.000032995021 0.001512840049\n\nkAr->2\nbic->-27.583016116183\n```\n"
    },
    "vectorNorm": {
        "url": "https://docs.dolphindb.com/en/Functions/v/vectorNorm.html",
        "signatures": [
            {
                "full": "vectorNorm(x, [ord], [axis], [keepDims])",
                "name": "vectorNorm",
                "parameters": [
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "[ord]",
                        "name": "ord",
                        "optional": true
                    },
                    {
                        "full": "[axis]",
                        "name": "axis",
                        "optional": true
                    },
                    {
                        "full": "[keepDims]",
                        "name": "keepDims",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [vectorNorm](https://docs.dolphindb.com/en/Functions/v/vectorNorm.html)\n\n\n\n#### Syntax\n\nvectorNorm(x, \\[ord], \\[axis], \\[keepDims])\n\n#### Arguments\n\n**x** is a vector or matrix of any numeric type except DECIMAL. It cannot be empty.\n\n**ord**(optional) is an INT, STRING or floating-point scalar indicating the order of norm. Note:\n\n* When *ord* is a string, it must be: 'inf', '-inf', 'nuc', or 'fro'.\n* When *ord* is less than 1, the result is technically not a mathematical \"norm\", but it may still be useful for various numerical purposes.\n\nThe following describes the method for computing the norm based on different *x* and *ord*:\n\n| *ord* | norm for vectors        | norm for matrices            |\n| :---- | :---------------------- | :--------------------------- |\n| None  | 2-norm                  | Frobenius norm               |\n| 0     | sum(x != 0)             | -                            |\n| -1    | sum(abs(x)^ord)^(1/ord) | min(sum(abs(x), axis=0))     |\n| 1     | sum(abs(x)^ord)^(1/ord) | max(sum(abs(x), axis=0))     |\n| -2    | sum(abs(x)^ord)^(1/ord) | 2-norm (largest sing. value) |\n| 2     | sum(abs(x)^ord)^(1/ord) | smallest singular value      |\n| inf   | max(abs(x))             | max(sum(abs(x), axis=1))     |\n| -inf  | min(abs(x))             | min(sum(abs(x), axis=1))     |\n| nuc   | -                       | nuclear norm                 |\n| fro   | -                       | Frobenius norm               |\n| other | sum(abs(x)^ord)^(1/ord) | -                            |\n\n**axis** (optional) is an integer vector or scalar indicating the direction along which to compute the norm. It cannot contain empty elements.\n\n* When *x* is a vector, *axis* can only be 0.\n* When *x* is a matrix, *axis*:\n  * Has a length of no more than 2.\n  * Cannot contain duplicate elements.\n  * Has elements with values of 0 or 1.\n\n**keepDims** (optional): A boolean scalar indicating whether the returned result should maintain the same form as *x*. The default is false.\n\n#### Details\n\nThe function computes a matrix or vector norm. Note that it’s not recommended to use `vectorNorm` in SQL statements.\n\n**Return Value**: An INT, LONG, or DOUBLE scalar, vector, or matrix.\n\n#### Examples\n\nWhen *x* is a vector, compute norms:\n\n```\nx = 1..4\n\nvectorNorm(x) // Output: 5.477225575051661\n\nvectorNorm(x, keepDims=true) // Output: 5.477225575051661\n\nvectorNorm(x, ord=1) // Output: 10\nvectorNorm(x, ord=1, axis=0) // Output: 10 \n\nvectorNorm(x, ord=-1) // Output 0.4800000000000001\nvectorNorm(x, ord=-1, axis=0) // Output double: 10\n\nvectorNorm(x, ord=\"inf\", axis=0) //Output: 4 \nvectorNorm(x, ord=\"-inf\", axis=0) //Output: 1\n\nvectorNorm(x, ord=3) // Output: 4.641588833612778\nvectorNorm(x, ord=-20.689) // Output: 0.9999999714010688\n\nvectorNorm(x, ord=\"fro\") // throw exception\nvectorNorm(x, ord=\"nuc\") // throw exception\n```\n\nWhen *x* is a matrix, compute norms:\n\n```\nx = 1..4$2:2\n\nvectorNorm(x) // Output: 5.477225575051661\nvectorNorm(x, keepDims=true) // Output: 5.477225575051661\n\nvectorNorm(x, ord=1) // Output: 7\nvectorNorm(x, ord=1, axis=0) // Output: 3 7 \nvectorNorm(x, ord=1, axis=1) // Output: 4 6\n\nvectorNorm(x, ord=-1, axis=0) // Output: 0.6666666666666666 1.7142857142857144\nvectorNorm(x, ord=-1, axis=1) // Output: 0.75 1.3333333333333333\n\nvectorNorm(x, ord=1, axis=(0 1)) // Output: 7\nvectorNorm(x, ord=1, axis=(1 0)) // Output: 6 \n\nvectorNorm(x, ord=-1, axis=(0 1)) // Output: 3\nvectorNorm(x, ord=-1, axis=(1 0)) // Output: 4 \n\nvectorNorm(x, ord=\"inf\", axis=(0 1)) // Output: 4 \nvectorNorm(x, ord=\"inf\", axis=(1 0)) // Output: 3 \n\nvectorNorm(x, ord=\"-inf\", axis=(0 1)) // Output: 6 \nvectorNorm(x, ord=\"-inf\", axis=(1 0)) // Output: 7 \n\nvectorNorm(x, ord=\"fro\", axis=(1 0)) // Output: 5.477225575051661\nvectorNorm(x, ord=\"fro\", axis=(0 1)) // Output: 5.477225575051661\n\nvectorNorm(x, ord=-2, axis=(1 0)) // Output: 0.3659661906262574\nvectorNorm(x, ord=-2, axis=(0 1)) // Output: 0.3659661906262574\n\nvectorNorm(x, ord=2, axis=(1 0)) // Output: 5.464985704219043\nvectorNorm(x, ord=2, axis=(0 1)) // Output: 5.464985704219043\n\nvectorNorm(x, ord=\"nuc\", axis=(1 0)) // Output: 5.8309518948453\nvectorNorm(x, ord=\"nuc\", axis=(0 1)) // Output: 5.8309518948453\n\nvectorNorm(x, ord=3) // throw exception\n```\n"
    },
    "version": {
        "url": "https://docs.dolphindb.com/en/Functions/v/version.html",
        "signatures": [
            {
                "full": "version()",
                "name": "version",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [version](https://docs.dolphindb.com/en/Functions/v/version.html)\n\n\n\n#### Syntax\n\nversion()\n\n#### Arguments\n\nNone\n\n#### Details\n\nThis function returns key system information about the DolphinDB server:\n\n* Version number\n\n* Release date\n\n* Operating system\n\n* CPU instruction set\n\n* Compiler version (for JIT/ABI only)\n\n#### Examples\n\n```\nversion();\n//output: 3.00.0 2024.03.31 LINUX x86_64\n```\n"
    },
    "volumeBar": {
        "url": "https://docs.dolphindb.com/en/Functions/v/volumeBar.html",
        "signatures": [
            {
                "full": "volumeBar(X, interval, [label='seq'])",
                "name": "volumeBar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "interval",
                        "name": "interval"
                    },
                    {
                        "full": "[label='seq']",
                        "name": "label",
                        "optional": true,
                        "default": "'seq'"
                    }
                ]
            }
        ],
        "markdown": "### [volumeBar](https://docs.dolphindb.com/en/Functions/v/volumeBar.html)\n\n#### Syntax\n\nvolumeBar(X, interval, \\[label='seq'])\n\n#### Arguments\n\n**X** is a numeric vector.\n\n**interval** is a non-zero number that represents a constant value or percentage that determines the threshold for data grouping.\n\n**label** (optional) is a string used to label the groups. It can be:\n\n* 'seq'(default): label the groups with a sequence of 0, 1, 2, 3...\n\n* 'left': label each group with the sum of all elements before the first element in the group. The first group is labeled with 0.\n\n* 'right': label each group with the sum of all elements up to and including the last element in the group.\n\n#### Details\n\nThis function sequentially accumulates the elements in *X*, and then groups them based on the specified threshold. Once a group is determined, the accumulation starts from the next element and data grouping is performed in the same logic. It returns a vector of the same size as *X* containing the corresponding group number for each element.\n\nElements are divided into groups based on the threshold specified by *interval*.\n\n* If *interval* is positive, elements are labeled into groups when the cumulative sum is no smaller than the threshold;\n\n  * If *interval* is in (0, 1), the threshold is sum(X) \\* *interval*. Note that the threshold is converted to the same data type as *X* for comparison. For example, if *X* is an integer, then the threshold will be set at floor(sum(X) \\* *interval*).\n\n  * Otherwise, the threshold takes the value of *interval*.\n\n* If *interval* is negative, the threshold takes the value of *interval*. Elements are labeled into groups when the cumulative sum is no greater than the threshold.\n\n#### Examples\n\n```\nX =  1 3 4 2 2 1 1 1 1 6 8\nvolumeBar(X, 4)\n// output\n[0,0,1,2,2,3,3,3,3,4,5]\n\nvolumeBar(X, 4, 'left')\n// output\n[0,0,4,8,8,12,12,12,12,16,22]\n\nvolumeBar(X, 4, 'right')\n// output\n[4,4,8,12,12,16,16,16,16,22,30]\n\nX = -6 2 -4 -5 -1 3 -2 -1\nvolumeBar(X, -2)\n// output\n[0,1,1,2,3,3,3,3]\n \nvolumeBar(X, -2, 'left')\n// output\n[0,-6,-6,-8,-13,-13,-13,-13]\n\nvolumeBar(X, -2, 'right')\n// output\n[-6,-8,-8,-13,-14,-14,-14,-14]\n\nsym = `st001`st002`st003`st001`st003`st004\ntime = 2022.01.01 2022.01.01 2022.01.02 2022.01.02 2022.01.03 2022.01.03\nprice = 1.9 2.2 1.8 1.1 2.5 1.9\nt = table(sym, time, price)\nselect *, volumeBar(price, 3) as tag from t \n// output\nsym\ttime\tprice\ttag\nst001\t2022.01.01\t1.9\t0\nst002\t2022.01.01\t2.2\t0\nst003\t2022.01.02\t1.8\t1\nst001\t2022.01.02\t1.1\t1\nst003\t2022.01.03\t2.5\t1\nst004\t2022.01.03\t1.9\t2\n```\n\n"
    },
    "warmupStreamEngine": {
        "url": "https://docs.dolphindb.com/en/Functions/w/warmupStreamEngine.html",
        "signatures": [
            {
                "full": "warmupStreamEngine(engine, msgs)",
                "name": "warmupStreamEngine",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "msgs",
                        "name": "msgs"
                    }
                ]
            }
        ],
        "markdown": "### [warmupStreamEngine](https://docs.dolphindb.com/en/Functions/w/warmupStreamEngine.html)\n\n\n\n#### Syntax\n\nwarmupStreamEngine(engine, msgs)\n\n#### Arguments\n\n**engine** is the table object returned from creating a stream engine.\n\n**msgs** is a table.\n\n#### Details\n\nIngest data into a stream engine without outputting results. When the next batch of data is ingested, the calculation can be sped up with the results that have already been generated.\n\nCurrently it only supports the reactive state engine, and (daily) time series engine.\n\n#### Examples\n\n```\ntrade=table(1000:0, `date`sym`price`volume, [DATE, SYMBOL, DOUBLE, INT])\nn=3000*100\ndate=take(2021.03.08, n)\nsym=take(\"A\"+string(1..3000), n)\nprice=round(rand(100.0, n), 2)\nvolume=rand(100, n)\ntable1 = table(date, sym, price, volume)\noutputTable = table(n:0, `sym`factor1, [STRING,DOUBLE])\nengine = createReactiveStateEngine(\"test\", <ema(volume, 40)>, table1, outputTable, \"sym\")\nwarmupStreamEngine(engine, table1)\ndate=take(2021.03.09, n)\nsym=take(\"A\"+string(1..3000), n)\nprice=round(rand(100.0, n), 2)\nvolume=rand(100, n)\ntable2 = table(date, sym, price, volume)\nengine.append!(table2)\n```\n"
    },
    "wavg": {
        "url": "https://docs.dolphindb.com/en/Functions/w/wavg.html",
        "signatures": [
            {
                "full": "wavg(value, weight)",
                "name": "wavg",
                "parameters": [
                    {
                        "full": "value",
                        "name": "value"
                    },
                    {
                        "full": "weight",
                        "name": "weight"
                    }
                ]
            }
        ],
        "markdown": "### [wavg](https://docs.dolphindb.com/en/Functions/w/wavg.html)\n\n\n\n#### Syntax\n\nwavg(value, weight)\n\n#### Arguments\n\n**value** is the value vector.\n\n**weight** is the weight vector.\n\n#### Details\n\nCalculate the weighted average of *X* with the weight vector *Y*. Please note that the weight vector *Y* is automatically scaled such that the sum of the weights is 1.\n\n#### Examples\n\n```\nwavg(2.2 1.1 3.3, 4 5 6);\n// output\n2.273333\n//  (2.2*4+1.1*5+3.3*6)/(4+5+6)\n\nwavg(1 NULL 1, 1 1 1);\n// output\n1\n```\n\nRelated function: [wsum](https://docs.dolphindb.com/en/Functions/w/wsum.html)\n"
    },
    "wc": {
        "url": "https://docs.dolphindb.com/en/Functions/w/wc.html",
        "signatures": [
            {
                "full": "wc(X)",
                "name": "wc",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [wc](https://docs.dolphindb.com/en/Functions/w/wc.html)\n\n\n\n#### Syntax\n\nwc(X)\n\n#### Arguments\n\n**X** is a string scalar/vector.\n\n#### Details\n\nCount the words in *X*.\n\n#### Examples\n\n```\nwc(`apple);\n// output\n1\n\nwc(\"This is a 7th generation iphone!\");\n// output\n6\n\nwc(\"This is a 7th generation iphone!\" \"I wonder what the 8th generation looks like\");\n// output\n[6,8]\n```\n"
    },
    "wcovar": {
        "url": "https://docs.dolphindb.com/en/Functions/w/wcovar.html",
        "signatures": [
            {
                "full": "wcovar(X, Y, weights)",
                "name": "wcovar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "weights",
                        "name": "weights"
                    }
                ]
            }
        ],
        "markdown": "### [wcovar](https://docs.dolphindb.com/en/Functions/w/wcovar.html)\n\n\n\n#### Syntax\n\nwcovar(X, Y, weights)\n\n#### Arguments\n\n**X**, **Y** and **weights** are vectors of the same size.\n\n#### Details\n\nCalculate the weighted covariance of *X* and *Y* with weights as the weight vector.\n\n#### Examples\n\n```\nx=7 4 5 8 9 3 3 5 2 6 12 1 0 -5 32\ny=1.1 7 8 9 9 5 4 8.6 2 1 -9 -3 5 8 13\nwt=iterate(1,0.9,x.size())\nwcovar(x,y,wt);\n\n// output\n4.201899\n```\n"
    },
    "weekBegin": {
        "url": "https://docs.dolphindb.com/en/Functions/w/weekBegin.html",
        "signatures": [
            {
                "full": "weekBegin(X, [weekday=0], [offset], [n=1])",
                "name": "weekBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weekday=0]",
                        "name": "weekday",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [weekBegin](https://docs.dolphindb.com/en/Functions/w/weekBegin.html)\n\n\n\n#### Syntax\n\nweekBegin(X, \\[weekday=0], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATETIME, DATEHOUR, TIMESTAMP or NANOTIMESTAMP.\n\n**weekday** (optional) is an integer from 0 to 6. 0 means Monday, 1 means Tuesday, ..., and 6 means Sunday. The default value is 0.\n\n**offset** (optional) is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nFor each element of *X*, return the first date of the week that it belongs to and that starts on the day as specified by parameter *weekday*.\n\n* If parameter *weekday*>*weekday(X, false)*: for each element of *X*, return a date that corresponds to the specified *weekday* parameter in the previous calendar week.\n\n* If parameter *weekday*<=*weekday(X, false)*: for each element of *X*, return a date that corresponds to the specified *weekday* parameter in the same calendar week.\n\nIf parameter *offset* is specified, the result is updated every *n* weeks. Please refer to example 2 below. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\nExample 1\n\n```\nt = table(2017.12.01..2017.12.14 as date);\nupdate t set weekday=weekday(date, false), weekBegin=weekBegin(date), weekBegin4=weekBegin(date,4);\nt;\n```\n\n| date       | weekday | weekBegin  | weekBegin4 |\n| ---------- | ------- | ---------- | ---------- |\n| 2017.12.01 | 4       | 2017.11.27 | 2017.12.01 |\n| 2017.12.02 | 5       | 2017.11.27 | 2017.12.01 |\n| 2017.12.03 | 6       | 2017.11.27 | 2017.12.01 |\n| 2017.12.04 | 0       | 2017.12.04 | 2017.12.01 |\n| 2017.12.05 | 1       | 2017.12.04 | 2017.12.01 |\n| 2017.12.06 | 2       | 2017.12.04 | 2017.12.01 |\n| 2017.12.07 | 3       | 2017.12.04 | 2017.12.01 |\n| 2017.12.08 | 4       | 2017.12.04 | 2017.12.08 |\n| 2017.12.09 | 5       | 2017.12.04 | 2017.12.08 |\n| 2017.12.10 | 6       | 2017.12.04 | 2017.12.08 |\n| 2017.12.11 | 0       | 2017.12.11 | 2017.12.08 |\n| 2017.12.12 | 1       | 2017.12.11 | 2017.12.08 |\n| 2017.12.13 | 2       | 2017.12.11 | 2017.12.08 |\n| 2017.12.14 | 3       | 2017.12.11 | 2017.12.08 |\n\nExample 2\n\n```\n t = table(2018.01.03+0..10*3 as date, 0..10 as x);\n update t set weekday=weekday(date, false), weekBegin=weekBegin(date,,2018.01.02,2);\n t;\n```\n\n| date       | x  | weekday | weekBegin  |\n| ---------- | -- | ------- | ---------- |\n| 2018.01.03 | 0  | 2       | 2018.01.01 |\n| 2018.01.06 | 1  | 5       | 2018.01.01 |\n| 2018.01.09 | 2  | 1       | 2018.01.01 |\n| 2018.01.12 | 3  | 4       | 2018.01.01 |\n| 2018.01.15 | 4  | 0       | 2018.01.15 |\n| 2018.01.18 | 5  | 3       | 2018.01.15 |\n| 2018.01.21 | 6  | 6       | 2018.01.15 |\n| 2018.01.24 | 7  | 2       | 2018.01.15 |\n| 2018.01.27 | 8  | 5       | 2018.01.15 |\n| 2018.01.30 | 9  | 1       | 2018.01.29 |\n| 2018.02.02 | 10 | 4       | 2018.01.29 |\n\nExample 3\n\n```\ndate=2012.10.02 2012.10.03 2012.10.07 2012.10.08 2012.10.12 2012.10.16 2012.10.18 2012.10.20 2012.10.25 2012.10.28\ntime=[09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2012.10.02 | 09:34:07 | MSFT | 2200 | 49.6   |\n| 2012.10.03 | 09:36:42 | MSFT | 1900 | 29.46  |\n| 2012.10.07 | 09:36:51 | MSFT | 2100 | 29.52  |\n| 2012.10.08 | 09:36:59 | MSFT | 3200 | 30.02  |\n| 2012.10.12 | 09:32:47 | MSFT | 6800 | 174.97 |\n| 2012.10.16 | 09:35:26 | MSFT | 5400 | 175.23 |\n| 2012.10.18 | 09:34:16 | MSFT | 1300 | 50.76  |\n| 2012.10.20 | 09:34:26 | MSFT | 2500 | 50.32  |\n| 2012.10.25 | 09:38:12 | MSFT | 8800 | 51.29  |\n| 2012.10.28 | 09:38:13 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by weekBegin(date, 4, 2012.10.01, 2);\n```\n\n| weekBegin\\_date | avg\\_price | sum\\_qty |\n| --------------- | ---------- | -------- |\n| 2012.09.28      | 34.65      | 9400     |\n| 2012.10.12      | 100.514    | 24800    |\n| 2012.10.26      | 52.38      | 4500     |\n\nRelated function: [weekEnd](https://docs.dolphindb.com/en/Functions/w/weekEnd.html)\n"
    },
    "weekday": {
        "url": "https://docs.dolphindb.com/en/Functions/w/weekday.html",
        "signatures": [
            {
                "full": "weekday(X, [startFromSunday=true])",
                "name": "weekday",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[startFromSunday=true]",
                        "name": "startFromSunday",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [weekday](https://docs.dolphindb.com/en/Functions/w/weekday.html)\n\n\n\n#### Syntax\n\nweekday(X, \\[startFromSunday=true])\n\n#### Arguments\n\n**X** is a temporal scalar/vector.\n\n**startFromSunday** (optional) is a Boolean value indicating whether a week starts from Sunday. The default value is true. If *startFromSunday*=false, a week starts from Monday.\n\n#### Details\n\nReturn integer(s) to represent of the corresponding weekday(s) of *X*.\n\nIf *startFromSunday*=true, 0 means Sunday, 1 means Monday, ..., and 6 means Saturday.\n\nIf *startFromSunday*=false, 0 means Monday, 1 means Tuesday, ..., and 6 means Sunday.\n\n#### Examples\n\n```\nweekday 2012.12.05;\n// output\n3\n\nweekday(2012.12.05, false);\n// output\n2\n\nweekday 2013.05.23T12:00:00;\n// output\n4\n\nweekday(2014.01.11T23:04:28.113);\n// output\n6\n\nweekday 2012.12.05 2012.12.06 2013.01.05;\n// output\n[3,4,6]\n```\n"
    },
    "weekEnd": {
        "url": "https://docs.dolphindb.com/en/Functions/w/weekEnd.html",
        "signatures": [
            {
                "full": "weekEnd(X, [weekday=6], [offset], [n=1])",
                "name": "weekEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weekday=6]",
                        "name": "weekday",
                        "optional": true,
                        "default": "6"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [weekEnd](https://docs.dolphindb.com/en/Functions/w/weekEnd.html)\n\n\n\n#### Syntax\n\nweekEnd(X, \\[weekday=6], \\[offset], \\[n=1])\n\nAlias: week\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATETIME, DATEHOUR, TIMESTAMP or NANOTIMESTAMP.\n\n**weekday** (optional) is an integer from 0 to 6. 0 means Monday, 1 means Tuesday, ..., and 6 means Sunday. The default value is 6.\n\n**offset** (optional) is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nFor each element of *X*, return the last date of the week that it belongs to and that ends on the day as specified by parameter *weekday*.\n\n* If parameter *weekday*>=*weekday(X, false)*: for each element of *X*, return a date that corresponds to the specified \"weekday\" parameter in the same calendar week.\n\n* If parameter *weekday*<*weekday(X, false)*: for each element of *X*, return a date that corresponds to the specified \"weekday\" parameter in the next calendar week.\n\nIf parameter *offset* is specified, the result is updated every *n* weeks. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\nExample 1\n\n```\nt = table(2017.12.01..2017.12.14 as date)\nupdate t set weekday=weekday(date, false), weekEnd=weekEnd(date), weekEnd4=weekEnd(date,4)\nt;\n```\n\n| date       | weekday | weekEnd    | weekEnd4   |\n| ---------- | ------- | ---------- | ---------- |\n| 2017.12.01 | 4       | 2017.12.04 | 2017.12.01 |\n| 2017.12.02 | 5       | 2017.12.04 | 2017.12.08 |\n| 2017.12.03 | 6       | 2017.12.04 | 2017.12.08 |\n| 2017.12.04 | 0       | 2017.12.04 | 2017.12.08 |\n| 2017.12.05 | 1       | 2017.12.11 | 2017.12.08 |\n| 2017.12.06 | 2       | 2017.12.11 | 2017.12.08 |\n| 2017.12.07 | 3       | 2017.12.11 | 2017.12.08 |\n| 2017.12.08 | 4       | 2017.12.11 | 2017.12.08 |\n| 2017.12.09 | 5       | 2017.12.11 | 2017.12.15 |\n| 2017.12.10 | 6       | 2017.12.11 | 2017.12.15 |\n| 2017.12.11 | 0       | 2017.12.11 | 2017.12.15 |\n| 2017.12.12 | 1       | 2017.12.18 | 2017.12.15 |\n| 2017.12.13 | 2       | 2017.12.18 | 2017.12.15 |\n| 2017.12.14 | 3       | 2017.12.18 | 2017.12.15 |\n\nExample 2\n\n```\nt = table(2018.01.03+0..10*3 as date, 0..10 as x)\nupdate t set weekday=weekday(date, false), weekEnd2=weekEnd(date,,2018.01.02,2)\nt;\n```\n\n| date       | x  | weekday | weekEnd2   |\n| ---------- | -- | ------- | ---------- |\n| 2018.01.03 | 0  | 2       | 2018.01.08 |\n| 2018.01.06 | 1  | 5       | 2018.01.08 |\n| 2018.01.09 | 2  | 1       | 2018.01.22 |\n| 2018.01.12 | 3  | 4       | 2018.01.22 |\n| 2018.01.15 | 4  | 0       | 2018.01.22 |\n| 2018.01.18 | 5  | 3       | 2018.01.22 |\n| 2018.01.21 | 6  | 6       | 2018.01.22 |\n| 2018.01.24 | 7  | 2       | 2018.02.05 |\n| 2018.01.27 | 8  | 5       | 2018.02.05 |\n| 2018.01.30 | 9  | 1       | 2018.02.05 |\n| 2018.02.02 | 10 | 4       | 2018.02.05 |\n\nExample 3\n\n```\ndate=2012.10.02 2012.10.03 2012.10.07 2012.10.08 2012.10.12 2012.10.16 2012.10.18 2012.10.20 2012.10.25 2012.10.28\ntime=[09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2012.10.02 | 09:34:07 | MSFT | 2200 | 49.6   |\n| 2012.10.03 | 09:36:42 | MSFT | 1900 | 29.46  |\n| 2012.10.07 | 09:36:51 | MSFT | 2100 | 29.52  |\n| 2012.10.08 | 09:36:59 | MSFT | 3200 | 30.02  |\n| 2012.10.12 | 09:32:47 | MSFT | 6800 | 174.97 |\n| 2012.10.16 | 09:35:26 | MSFT | 5400 | 175.23 |\n| 2012.10.18 | 09:34:16 | MSFT | 1300 | 50.76  |\n| 2012.10.20 | 09:34:26 | MSFT | 2500 | 50.32  |\n| 2012.10.25 | 09:38:12 | MSFT | 8800 | 51.29  |\n| 2012.10.28 | 09:38:13 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by weekEnd(date, 4, 2012.10.01, 2);\n```\n\n| weekEnd\\_date | avg\\_price | sum\\_qty |\n| ------------- | ---------- | -------- |\n| 2012.10.05    | 39.53      | 4100     |\n| 2012.10.19    | 92.1       | 18800    |\n| 2012.11.02    | 51.33      | 15800    |\n\nRelated function: [weekBegin](https://docs.dolphindb.com/en/Functions/w/weekBegin.html)\n"
    },
    "weekOfMonth": {
        "url": "https://docs.dolphindb.com/en/Functions/w/weekOfMonth.html",
        "signatures": [
            {
                "full": "weekOfMonth(X, [week=0], [weekday=0], [offset], [n=1])",
                "name": "weekOfMonth",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[week=0]",
                        "name": "week",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[weekday=0]",
                        "name": "weekday",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [weekOfMonth](https://docs.dolphindb.com/en/Functions/w/weekOfMonth.html)\n\n\n\n#### Syntax\n\nweekOfMonth(X, \\[week=0], \\[weekday=0], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**week** (optional) is an integer from 0 to 3 indicating the i-th week of a month. The default value is 0.\n\n**weekday** (optional) is an integer from 0 to 6. 0 means Monday, 1 means Tuesday, ..., and 6 means Sunday. The default value is 0.\n\n**offset** (optional) is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nIn the calendar month of *X*, suppose the \"week\"-th \"weekday\" is d.\n\n* If *X*\\<d: return the week-th \"weekday\" in the previous calendar month.\n\n* If *X*>=d: return the week-th \"weekday\" in the current calendar month.\n\nIf parameter *offset* is specified, the result is updated every *n* months. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nweekOfMonth(2019.11.01,2,4);\n// output\n2019.10.18\n\nweekOfMonth(2019.11.20,2,4);\n2019.11.15\n\ndate=2012.01.02 2012.02.03 2012.03.07 2012.04.08 2012.05.12 2012.06.16 2012.07.18 2012.08.20 2012.09.25 2012.10.28\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by weekOfMonth(date,3,4,2012.01.01,2);\n```\n\n| weekOfMonth\\_date | avg\\_price | sum\\_qty |\n| ----------------- | ---------- | -------- |\n| 2011.12.23        | 39.53      | 4100     |\n| 2012.02.24        | 29.77      | 5300     |\n| 2012.04.27        | 175.1      | 12200    |\n| 2012.06.22        | 50.54      | 3800     |\n| 2012.08.24        | 51.29      | 8800     |\n| 2012.10.26        | 52.38      | 4500     |\n"
    },
    "weekOfYear": {
        "url": "https://docs.dolphindb.com/en/Functions/w/weekOfYear.html",
        "signatures": [
            {
                "full": "weekOfYear(X)",
                "name": "weekOfYear",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [weekOfYear](https://docs.dolphindb.com/en/Functions/w/weekOfYear.html)\n\n\n\n#### Syntax\n\nweekOfYear(X)\n\n#### Arguments\n\n**X** is a scalar/vector of type DATE, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n#### Details\n\nReturn the week number for *X*.\n\nNote:\n\n* Each week starts on Sunday. The first week of the year has more than 4 days.\n\n* If 31 December is on a Monday, Tuesday or Wednesday, it is in week 01 of the next year. If it is on a Thursday, it is in week 53 of the year just ending; if on a Friday it is in week 52 (or 53 if the year just ending is a leap year); if on a Saturday or Sunday, it is in week 52 of the year just ending.\n\n#### Examples\n\n```\nweekOfYear(2012.01.07);\n// output\n1\n\nweekOfYear(2013.01.07);\n// output\n2\n\nweekOfYear(2012.07.02);\n// output\n27\n\nweekOfYear([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n// output\n[24,43,1,14]\n```\n\nRelated function: [dayOfYear](https://docs.dolphindb.com/en/Functions/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.com/en/Functions/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.com/en/Functions/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.com/en/Functions/m/monthOfYear.html), [hourOfDay](https://docs.dolphindb.com/en/Functions/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.com/en/Functions/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.com/en/Functions/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.com/en/Functions/m/millisecond.html), [microsecond](https://docs.dolphindb.com/en/Functions/m/microsecond.html), [nanosecond](https://docs.dolphindb.com/en/Functions/n/nanosecond.html)\n"
    },
    "wilder": {
        "url": "https://docs.dolphindb.com/en/Functions/w/wilder.html",
        "signatures": [
            {
                "full": "wilder(X, window)",
                "name": "wilder",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [wilder](https://docs.dolphindb.com/en/Functions/w/wilder.html)\n\n\n\n#### Syntax\n\nwilder(X, window)\n\nPlease see [TALib](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the Exponential Moving Average (ema) for *X* in a sliding window of the given length.\n\nDifferent from [ema](https://docs.dolphindb.com/en/Functions/e/ema.html), the function `wilder` uses Welles Wilder's Moving Average Formula, which is:\n\n![](https://docs.dolphindb.com/en/images/wilderxk.png)\n\nwhere ![](https://docs.dolphindb.com/en/images/wilderxk_name.png) is the k-th exponential moving average, n is the length of sliding window, and X\\_k is the k-th element of the vector X.\n\n#### Examples\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\nwilder(x,3);\n// output\n[,,12.299999999999998,12.466666666666668,12.27777777777778,12.051851851851854,11.767901234567903]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\nwilder(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n| 12.3    | 15.6667 |\n| 12.4667 | 16.7778 |\n| 12.2778 | 18.1852 |\n| 12.0519 | 16.1235 |\n| 11.7679 | 14.0823 |\n\nRelated functions: [ema](https://docs.dolphindb.com/en/Functions/e/ema.html), [gema](https://docs.dolphindb.com/en/Functions/g/gema.html), [tema](https://docs.dolphindb.com/en/Functions/t/tema.html)\n"
    },
    "winsorize!": {
        "url": "https://docs.dolphindb.com/en/Functions/w/winsorize!.html",
        "signatures": [
            {
                "full": "winsorize(X, limit, [inclusive=true], [nanPolicy='upper'])",
                "name": "winsorize",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "limit",
                        "name": "limit"
                    },
                    {
                        "full": "[inclusive=true]",
                        "name": "inclusive",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[nanPolicy='upper']",
                        "name": "nanPolicy",
                        "optional": true,
                        "default": "'upper'"
                    }
                ]
            }
        ],
        "markdown": "### [winsorize!](https://docs.dolphindb.com/en/Functions/w/winsorize!.html)\n\nAlias for [winsorize](https://docs.dolphindb.com/en/Functions/w/winsorize.html)\n\n\nDocumentation for the `winsorize` function:\n### [winsorize](https://docs.dolphindb.com/en/Functions/w/winsorize.html)\n\n\n\n#### Syntax\n\nwinsorize(X, limit, \\[inclusive=true], \\[nanPolicy='upper'])\n\nAlias: winsorize!\n\n#### Arguments\n\n**X** is a vector.\n\n**limit** is a scalar or a vector with 2 elements indicating the percentages to cut on each side of *X*, with respect to the number of unmasked data, as floats between 0 and 1. If *limit* is a scalar, it means the percentages to cut on both sides of X. If *limit* has n elements (including NULLs), the (n \\* limit\\[0])-th smallest element and the (n \\* limit\\[1])-th largest element are masked, and the total number of unmasked data after trimming is n \\* (1-sum(limit)). The value of one element of *limit* can be set to 0 to indicate no masking is conducted on this side.\n\n**inclusive** (optional) is a Boolean type scalar or a vector of 2 elements indicating whether the number of data being masked on each side should be truncated (true) or rounded (false).\n\n**nanPolicy** (optional) is a string indicating how to handle NULL values. The following options are available (default is 'upper'):\n\n* 'upper': allows NULL values and treats them as the largest values of *X*.\n\n* 'lower': allows NULL values and treats them as the smallest values of *X*.\n\n* 'raise': throws an error.\n\n* 'omit': performs the calculations without masking NULL values.\n\n#### Details\n\nReturn a winsorized version of the input array.\n\n#### Examples\n\n```\nx=1..10\n// output\nwinsorize(x, 0.1);\n[2,2,3,4,5,6,7,8,9,9]\n\nwinsorize(x, 0.12 0.17);\n// output\n[2,2,3,4,5,6,7,8,9,9]\n\nwinsorize(x, 0.12 0.17, inclusive=false);\n// output\n[2,2,3,4,5,6,7,8,8,8]\n\n\nx=1..20;\nx[19:]=NULL;\nx;\n// output\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,]\n\nwinsorize(x, 0.1);\n// output\n[3,3,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,18,18]\n\nwinsorize(x, 0.1, nanPolicy='upper');\n// output\n[3,3,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,18,18]\n\nwinsorize(x, 0.1, nanPolicy='lower');\n// output\n[2,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,17,17,2]\n```\n"
    },
    "winsorize": {
        "url": "https://docs.dolphindb.com/en/Functions/w/winsorize.html",
        "signatures": [
            {
                "full": "winsorize(X, limit, [inclusive=true], [nanPolicy='upper'])",
                "name": "winsorize",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "limit",
                        "name": "limit"
                    },
                    {
                        "full": "[inclusive=true]",
                        "name": "inclusive",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[nanPolicy='upper']",
                        "name": "nanPolicy",
                        "optional": true,
                        "default": "'upper'"
                    }
                ]
            }
        ],
        "markdown": "### [winsorize](https://docs.dolphindb.com/en/Functions/w/winsorize.html)\n\n\n\n#### Syntax\n\nwinsorize(X, limit, \\[inclusive=true], \\[nanPolicy='upper'])\n\nAlias: winsorize!\n\n#### Arguments\n\n**X** is a vector.\n\n**limit** is a scalar or a vector with 2 elements indicating the percentages to cut on each side of *X*, with respect to the number of unmasked data, as floats between 0 and 1. If *limit* is a scalar, it means the percentages to cut on both sides of X. If *limit* has n elements (including NULLs), the (n \\* limit\\[0])-th smallest element and the (n \\* limit\\[1])-th largest element are masked, and the total number of unmasked data after trimming is n \\* (1-sum(limit)). The value of one element of *limit* can be set to 0 to indicate no masking is conducted on this side.\n\n**inclusive** (optional) is a Boolean type scalar or a vector of 2 elements indicating whether the number of data being masked on each side should be truncated (true) or rounded (false).\n\n**nanPolicy** (optional) is a string indicating how to handle NULL values. The following options are available (default is 'upper'):\n\n* 'upper': allows NULL values and treats them as the largest values of *X*.\n\n* 'lower': allows NULL values and treats them as the smallest values of *X*.\n\n* 'raise': throws an error.\n\n* 'omit': performs the calculations without masking NULL values.\n\n#### Details\n\nReturn a winsorized version of the input array.\n\n#### Examples\n\n```\nx=1..10\n// output\nwinsorize(x, 0.1);\n[2,2,3,4,5,6,7,8,9,9]\n\nwinsorize(x, 0.12 0.17);\n// output\n[2,2,3,4,5,6,7,8,9,9]\n\nwinsorize(x, 0.12 0.17, inclusive=false);\n// output\n[2,2,3,4,5,6,7,8,8,8]\n\n\nx=1..20;\nx[19:]=NULL;\nx;\n// output\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,]\n\nwinsorize(x, 0.1);\n// output\n[3,3,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,18,18]\n\nwinsorize(x, 0.1, nanPolicy='upper');\n// output\n[3,3,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,18,18]\n\nwinsorize(x, 0.1, nanPolicy='lower');\n// output\n[2,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,17,17,2]\n```\n"
    },
    "wls": {
        "url": "https://docs.dolphindb.com/en/Functions/w/wls.html",
        "signatures": [
            {
                "full": "wls(Y, X, W, [intercept=true], [mode=0])",
                "name": "wls",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "W",
                        "name": "W"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [wls](https://docs.dolphindb.com/en/Functions/w/wls.html)\n\n\n\n#### Syntax\n\nwls(Y, X, W, \\[intercept=true], \\[mode=0])\n\n#### Arguments\n\n**Y** is a dependent variable.\n\n**X** is an independent variable.\n\n*Y* is a vector. *X* can be a matrix, table or tuple. When *X* is a matrix, if the number of rows is equal to the length of *Y*, each column of *X* is a factor. If the number of rows is not equal to the length of *Y*, but the number of columns is equal to the length of *Y*, each row of *X* is a factor.\n\n**W** is a vector indicating the weight in which each element is a non-negative.\n\n**intercept** (optional) is a Boolean variable that indicates whether to include the intercept in regression. The default value is true. When it is true, the system automatically adds a column of \"1\" to *X* to generate the intercept.\n\n**mode** (optional) is an integer that could be 0, 1, or 2.\n\n* 0: a vector of the coefficient estimates\n\n* 1: a table with coefficient estimates, standard error, t-statistics, and p-value\n\n* 2: a dictionary with all statistics\n\nANOVA (one-way analysis of variance)\n\n| Source of Variance | DF (degree of freedom) | SS (sum of square)             | MS (mean of square)               | F (F-score) | Significance |\n| ------------------ | ---------------------- | ------------------------------ | --------------------------------- | ----------- | ------------ |\n| Regression         | p                      | sum of squares regression, SSR | regression mean square, MSR=SSR/R | MSR/MSE     | p-value      |\n| Residual           | n-p-1                  | sum of squares error, SSE      | mean square error, MSE=MSE/E      |             |              |\n| Total              | n-1                    | sum of squares total, SST      |                                   |             |              |\n\nRegressionStat (Regression statistics)\n\n| Item         | Description                                                                                                                                   |\n| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------- |\n| R2           | R-squared                                                                                                                                     |\n| AdjustedR2   | The adjusted R-squared corrected based on the degrees of freedom by comparing the sample size to the number of terms in the regression model. |\n| StdError     | The residual standard error/deviation corrected based on the degrees of freedom.                                                              |\n| Observations | The sample size.                                                                                                                              |\n\nCoefficient\n\n| Item     | Description                                                             |\n| -------- | ----------------------------------------------------------------------- |\n| factor   | Independent variables                                                   |\n| beta     | Estimated regression coefficients                                       |\n| StdError | Standard error of the regression coefficients                           |\n| tstat    | t statistic, indicating the significance of the regression coefficients |\n\nResidual: the difference between each predicted value and the actual value.\n\n#### Details\n\nReturn the result of an weighted-least-squares regression of *Y* on *X*.\n\n#### Examples\n\n```\nx1=1 3 5 7 11 16 23\nx2=2 8 11 34 56 54 100\ny=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\nw=rand(10,7)\nwls(y, x1, w)\n\n// output\n[-17.6177  4.0016]\n\nwls(y, (x1,x2), w);\n\n// output\n[-17.4168  3.0481 0.2214]\n```\n\n```\nwls(y, (x1,x2), w, 1, 1);\n```\n\n| factor    | beta     | stdError | tstat   | pvalue |\n| --------- | -------- | -------- | ------- | ------ |\n| Intercept | -17.4168 | 4.8271   | -3.6081 | 0.0226 |\n| x1        | 3.0481   | 1.6232   | 1.8779  | 0.1336 |\n| x2        | 0.2214   | 0.3699   | 0.5986  | 0.5817 |\n\n```\nwls(y, (x1,x2), w,1, 2);\n\n// output\nCoefficient->\nfactor    beta      stdError tstat     pvalue\n--------- --------- -------- --------- --------\nintercept -10.11392 4.866583 -2.078239 0.106234\nx1        3.938138  2.061191 1.910613  0.128655\nx2        -0.088542 0.446667 -0.198227 0.852534\n\nResidual->[6.452866,3.207839,-3.002812,-5.642629,-6.147264,-12.515038,5.590914]\nRegressionStat->\nitem         statistics\n------------ ----------\nR2           0.957998\nAdjustedR2   0.936997\nStdError     17.172833\nObservations 7\n\nANOVA->\nBreakdown  DF SS           MS           F         Significance\n---------- -- ------------ ------------ --------- ------------\nRegression 2  26905.306594 13452.653297 45.616718 0.001764\nResidual   4  1179.624835  294.906209\nTotal      6  28084.931429\n```\n\n```\nx=matrix(1 4 8 2 3, 1 4 2 3 8, 1 5 1 1 5);\nw=rand(8,5)\nwls(1..5, x,w,0,1);\n```\n\n| factor | beta   | stdError | tstat   | pvalue |\n| ------ | ------ | -------- | ------- | ------ |\n| beta0  | 0.0026 | 1.4356   | 0.0018  | 0.9988 |\n| beta1  | -1     | 1.2105   | -0.8261 | 0.5605 |\n| beta2  | 0.4511 | 0.5949   | 0.7582  | 0.587  |\n| beta3  | 1.687  | 1.7389   | 0.9701  | 0.5097 |\n"
    },
    "wma": {
        "url": "https://docs.dolphindb.com/en/Functions/w/wma.html",
        "signatures": [
            {
                "full": "wma(X, window)",
                "name": "wma",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [wma](https://docs.dolphindb.com/en/Functions/w/wma.html)\n\n\n\n#### Syntax\n\nwma(X, window)\n\nPlease see [TALib](https://docs.dolphindb.com/en/Functions/Themes/TALib.html) for the parameters and windowing logic.\n\n#### Details\n\nCalculate the Weighted Moving Average (wma) for *X* in a sliding window of the given length.\n\nThe formula is: ![](https://docs.dolphindb.com/en/images/wma.png)\n\n#### Examples\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\nwma(x,3);\n// output\n[,,12.383333333333332,12.633333333333334,12.316666666666668,11.9,11.450000000000001]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\nwma(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n| 12.3833 | 16.3333 |\n| 12.6333 | 18      |\n| 12.3167 | 19.8333 |\n| 11.9    | 16.1667 |\n| 11.45   | 12.5    |\n\nRelated functions: [sma](https://docs.dolphindb.com/en/Functions/s/sma.html), [trima](https://docs.dolphindb.com/en/Functions/t/trima.html)\n"
    },
    "write": {
        "url": "https://docs.dolphindb.com/en/Functions/w/write.html",
        "signatures": [
            {
                "full": "write(handle, object, [offset=0], [length])",
                "name": "write",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "object",
                        "name": "object"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [write](https://docs.dolphindb.com/en/Functions/w/write.html)\n\n\n\n#### Syntax\n\nwrite(handle, object, \\[offset=0], \\[length])\n\n#### Details\n\nConvert the specified buffer to a stream of bytes and then save to the file. The buffer could be a scalar or a vector with various data types. If an error occurs, an IOException is raised. Otherwise, the function returns the number of elements (not the number of bytes) written.\n\nThe `read!` function reads a given number of elements to the buffer. For example, if the buffer is an INT vector, the function will convert the bytes from the file to INT. Both `write` and `read!` function involve the conversion between streams of bytes and multi-byte words, which is termed as endianness in computer science. The big endianness has the most significant byte in the lowest address whereas the little endianness has the least significant byte in the lowest address. The `write` function always uses the endianness of the operating system. The `read!` function can convert the endianness if the endianness of the file is different from the one of the operating system. When one uses the `file` function to open a file, there is an optional boolean argument to indicate if the file adopts the little endian format. By default, it is the endianness of the operating system.\n\n#### Examples\n\n```\nx=10h\ny=0h\nfile(\"test.bin\",\"w\").write(x);\n// output\n1\nfile(\"test.bin\",\"r\",true).read!(y);\n// output\n1\n// assume the file format is little endianness\ny;\n// output\n10\nfile(\"test.bin\",\"r\",false).read!(y);\n// output\n1\n// assume the file format is big endianness\ny;\n// output\n2560\n```\n"
    },
    "writeBytes": {
        "url": "https://docs.dolphindb.com/en/Functions/w/writeBytes.html",
        "signatures": [
            {
                "full": "writeBytes(handle, bytes)",
                "name": "writeBytes",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "bytes",
                        "name": "bytes"
                    }
                ]
            }
        ],
        "markdown": "### [writeBytes](https://docs.dolphindb.com/en/Functions/w/writeBytes.html)\n\n\n\n#### Syntax\n\nwriteBytes(handle, bytes)\n\n#### Details\n\nWrite the entire buffer to the file. The buffer must be a char scalar or char vector. If the operation succeeds, it returns the actual number of bytes written; otherwise, an IOException will be raised.\n\n#### Examples\n\n```\n// define a file copy function\ndef fileCopy(source, target){\n   s = file(source)\n   len = s.seek(0,TAIL)\n   s.seek(0,HEAD)\n   t = file(target,\"w\")\n   if(len==0) return\n   do{\n       buf = s.readBytes(min(len,1024))\n       t.writeBytes(buf)\n       len -= buf.size()\n   }while(len)\n};\n\nfileCopy(\"test.txt\",\"testcopy.txt\");\n```\n"
    },
    "writeLine": {
        "url": "https://docs.dolphindb.com/en/Functions/w/writeLine.html",
        "signatures": [
            {
                "full": "writeLine(handle, line, [windowsLineEnding])",
                "name": "writeLine",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "line",
                        "name": "line"
                    },
                    {
                        "full": "[windowsLineEnding]",
                        "name": "windowsLineEnding",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [writeLine](https://docs.dolphindb.com/en/Functions/w/writeLine.html)\n\n\n\n#### Syntax\n\nwriteLine(handle, line, \\[windowsLineEnding])\n\n#### Arguments\n\nThe optional Boolean parameter *windowsLineEnding* is the line ending character. If the parameter is not specified, the line ending character would be:\n\n* \\r\\n if *handle* is a socket\n\n* \\n if *handle* is a file and the operation system is not Windows\n\n* \\r\\n if *handle* is a file and the operating system is Windows\n\n#### Details\n\nWrite a line to the given handle. The function will automatically append a line delimiter to the string. Thus the string shouldn't end with a line delimiter. If the operation succeeds, it returns 1; otherwise, an IOException will be raised.\n\n#### Examples\n\n```\nx=`IBM`MSFT`GOOG`YHOO`ORCL\neachRight(writeLine, file(\"test.txt\",\"w\"), x);\n// output\n[1,1,1,1,1]\n\nfin = file(\"test.txt\")\ndo{\n   x=fin.readLine()\n   if(x.isVoid()) break\n   print x\n}\nwhile(true);\n\n// output\nIBM\nMSFT\nGOOG\nYHOO\nORCL\n```\n"
    },
    "writeLines": {
        "url": "https://docs.dolphindb.com/en/Functions/w/writeLines.html",
        "signatures": [
            {
                "full": "writeLines(handle, object, [offset=0], [length], [windowsLineEnding])",
                "name": "writeLines",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "object",
                        "name": "object"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    },
                    {
                        "full": "[windowsLineEnding]",
                        "name": "windowsLineEnding",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [writeLines](https://docs.dolphindb.com/en/Functions/w/writeLines.html)\n\n\n\n#### Syntax\n\nwriteLines(handle, object, \\[offset=0], \\[length], \\[windowsLineEnding])\n\n#### Arguments\n\n**length** is the number of lines from the handle to read.\n\n#### Details\n\nWrite a given number of lines to the handle.\n\n#### Examples\n\n```\ntimer(10){\n   x=rand(`IBM`MSFT`GOOG`YHOO`ORCL,10240)\n   eachRight(writeLine, file(\"test.txt\",\"w\"),x)\n   fin = file(\"test.txt\")\n   do{ y=fin.readLine() } while(!y.isVoid())\n    fin.close()\n};\n\n// output\nTime elapsed: 277.548 ms\n\ntimer(10){\n   x=rand(`IBM`MSFT`GOOG`YHOO`ORCL,10240)\n   file(\"test.txt\",\"w\").writeLines(x)\n   fin = file(\"test.txt\")\n   do{ y=fin.readLines(1024) } while(y.size()==1024)\n   fin.close()\n};\n\n// output\nTime elapsed: 28.003 ms\n```\n"
    },
    "writeLog": {
        "url": "https://docs.dolphindb.com/en/Functions/w/writeLog.html",
        "signatures": [
            {
                "full": "writeLog(X1, [X2, X3….Xn])",
                "name": "writeLog",
                "parameters": [
                    {
                        "full": "X1",
                        "name": "X1"
                    },
                    {
                        "full": "[X2",
                        "name": "[X2"
                    },
                    {
                        "full": "X3….Xn]",
                        "name": "X3….Xn]"
                    }
                ]
            }
        ],
        "markdown": "### [writeLog](https://docs.dolphindb.com/en/Functions/w/writeLog.html)\n\n\n\n#### Syntax\n\nwriteLog(X1, \\[X2, X3….Xn])\n\n#### Arguments\n\n**X1**, **X2**, **X3** ... **Xn** are the strings to be written into the log file. Each string is a line in the log file.\n\n#### Details\n\nWrite a message into the log file. It must be executed by a logged-in user.\n\n#### Examples\n\n```\nwriteLog(\"This is a message written into the log file.\")\nwriteLog(\"line1.\",\"line2.\",\"line3\");\n\n// Check the log file.\n// output\nSun Aug 06 16:41:05 2017 <INFO> :This is a message written into the log file.\nSun Aug 06 16:50:35 2017 <INFO> :line1.\nSun Aug 06 16:50:35 2017 <INFO> :line2.\nSun Aug 06 16:50:35 2017 <INFO> :line3\n```\n"
    },
    "writeLogLevel": {
        "url": "https://docs.dolphindb.com/en/Functions/w/writeLogLevel.html",
        "signatures": [
            {
                "full": "writeLogLevel(level, X1, [X2, X3,...,Xn])",
                "name": "writeLogLevel",
                "parameters": [
                    {
                        "full": "level",
                        "name": "level"
                    },
                    {
                        "full": "X1",
                        "name": "X1"
                    },
                    {
                        "full": "[X2",
                        "name": "[X2"
                    },
                    {
                        "full": "X3",
                        "name": "X3"
                    },
                    {
                        "full": "...",
                        "name": "..."
                    },
                    {
                        "full": "Xn]",
                        "name": "Xn]"
                    }
                ]
            }
        ],
        "markdown": "### [writeLogLevel](https://docs.dolphindb.com/en/Functions/w/writeLogLevel.html)\n\n\n\n#### Syntax\n\nwriteLogLevel(level, X1, \\[X2, X3,...,Xn])\n\n#### Arguments\n\n**level** indicates the log level. It accepts these values in ascending order of importance: DEBUG (0), INFO (1), WARNING (2), and ERROR (3).\n\n**X1**, **X2**, **X3**, ... **Xn** is the content to be written to the log file. Each *Xi* is a line in the log file. The following data types are supported: Logical, Integral, Temporal, Floating, Literal, and Decimal.\n\n#### Details\n\nThe command writes logs of the specified level to the log files. It can only be called by an administrator.\n\n**Note:** The specified *level* must be equal to or higher than the log level configured by the *logLevel* parameter or set by the `setLogLevel` function, otherwise the logs will not be written to the log file.\n\n#### Examples\n\n```\nwriteLogLevel(INFO,111111111111,\"This is an INFO message\") \n// Check the log file.\n<INFO> :111111111111\n<INFO> :This is an INFO message\n```\n\nRelated functions: [writeLog](https://docs.dolphindb.com/en/Functions/w/writeLog.html), [setLogLevel](https://docs.dolphindb.com/en/Functions/s/setLogLevel.html)\n"
    },
    "writeObject": {
        "url": "https://docs.dolphindb.com/en/Functions/w/writeObject.html",
        "signatures": [
            {
                "full": "writeObject(handle, object)",
                "name": "writeObject",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "object",
                        "name": "object"
                    }
                ]
            }
        ],
        "markdown": "### [writeObject](https://docs.dolphindb.com/en/Functions/w/writeObject.html)\n\n\n\n#### Syntax\n\nwriteObject(handle, object)\n\n#### Details\n\nCan write all data structures including scalar, vector, matrix, set, dictionary and table to the handle. It must be executed by a logged-in user.\n\n#### Examples\n\n```\na1=10.5\na2=1..10\na3=cross(*,1..5,1..10)\na4=set(`IBM`MSFT`GOOG`YHOO)\na5=dict(a4.keys(),125.6 53.2 702.3 39.7)\na6=table(1 2 3 as id, `Jenny`Tom`Jack as name)\na7=(1 2 3, \"hello world!\", 25.6);\nfout=file(\"test.bin\",\"w\")\nfout.writeObject(a1)\nfout.writeObject(a2)\nfout.writeObject(a3)\nfout.writeObject(a4)\nfout.writeObject(a5)\nfout.writeObject(a6)\nfout.writeObject(a7)\nfout.close();\n```\n"
    },
    "writeRecord": {
        "url": "https://docs.dolphindb.com/en/Functions/w/writeRecord.html",
        "signatures": [
            {
                "full": "writeRecord(handle, object, [offset=0], [length])",
                "name": "writeRecord",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "object",
                        "name": "object"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [writeRecord](https://docs.dolphindb.com/en/Functions/w/writeRecord.html)\n\n\n\n#### Syntax\n\nwriteRecord(handle, object, \\[offset=0], \\[length])\n\n#### Arguments\n\n**handle** is a binary file handle.\n\n**object** is a table or a tuple with array elements of equal sizes.\n\n**offset** (optional) specifies the starting row position.\n\n**length** (optional) indicates the number of rows to be written.\n\n#### Details\n\nConvert DolphinDB objects such as tables or tuples to binary files. The function returns with the number of rows written to *handle*.\n\n#### Examples\n\n```\nt=table(1..10000 as id, 1..10000+100 as value);\n\nf1=file(\"C:/DolphinDB/a.bin\", \"w\");\nf1.writeRecord(t);\n// output\n10000\n\nf2=file(\"C:/DolphinDB/b.bin\", \"w\");\nf2.writeRecord(t, 100, 1000);\n// output\n1000\n\nf3=file(\"C:/DolphinDB/c.bin\", \"w\");\nf3.writeRecord(t, 100, 10000);\n// output\nThe optional argument length is invalid.\n```\n"
    },
    "wslr": {
        "url": "https://docs.dolphindb.com/en/Functions/w/wslr.html",
        "signatures": [
            {
                "full": "wslr(Y, X, W, [mse=false])",
                "name": "wslr",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "W",
                        "name": "W"
                    },
                    {
                        "full": "[mse=false]",
                        "name": "mse",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [wslr](https://docs.dolphindb.com/en/Functions/w/wslr.html)\n\n#### Syntax\n\nwslr(Y, X, W, \\[mse=false])\n\n#### Arguments\n\n**Y** is a numeric vector indicating the dependent variable.\n\n**X**is a numeric vector indicating the independent variable.\n\n**W** is a numeric vector indicating the weights, where all elements are non-negative.\n\nThe length of *Y*, *X*and *W*must be equal.\n\n**mse** (optional) is a Boolean scalar specifying whether to output the mean squared error (mse). The default value is false.\n\n#### Details\n\n`wslr` (weighted single linear regression) calculates the weighted linear regression of *Y* on *X*.\n\n**Return value**: A tuple, containing the regression coefficients *beta*, intercept *alpha*, and mean squared error *mse* (if *mse*set to true).\n\n![](https://docs.dolphindb.com/en/images/wslr1.svg)\n\n![](https://docs.dolphindb.com/en/images/wslr2.svg)\n\nwhere *n* is the number of non-empty values.\n\nComparing `wls` and `wlsr`:\n\n* `wls` returns a vector, while `wslr` returns a tuple.\n\n* `wls` is a vector function, while `wslr` is an aggregate function.\n\n* Only `wls` can be applied to DFS tables.\n\n#### Examples\n\n```\nx = [0.78,0.38,0.2,0.52,0.12,0.49,0.02,0.67,0.94,0.85]\ny = [0.11,0.63,0.19,0.36,0.02,0.35,0.98,0.07,0.55,0.43]\nw = [0.05665,0.155172,0.142857,0.236453,0.125616,0.061576,0.064039,0.051724,0.004926,0.100985]\nwslr(y,x,w)\n//output: (0.385342531009792,-0.076256407696962)\nwslr(y,x,w,true)\n//output: (0.385342531009792,-0.076256407696962,0.007842049148797)\n```\n\nSince `wls` is a vector function, it cannot be directly used with `moving` but requires a user-defined function. `wlsr`, on the other hand, can be directly combined with `moving`.\n\n```\ns = [\"001\",\"002\",\"003\",\"004\",\"005\",\"006\",\"007\",\"008\",\"009\",\"010\"]\ny = [0.2531,0.5672,0.8347,0.6436,0.699,0.3732,0.0676,0.9129,0.0167,0.755]\nx = [0.5782,0.8064,0.5035,0.7857,0.5955,0.4156,0.7609,0.093,0.6504,0.9092]\nw = [0,0.095909021199675,0.195930114343433,0.300024080233914,0.408136784222979]\n\nt = table(s,y,x)\nselect moving(wslr{,,w,true},[y,x],5,5) as `bate`alpha`mse from t\n```\n\n<table id=\"table_itl_gcs_z1c\"><thead><tr><th>\n\nbate\n\n</th><th>\n\nalpha\n\n</th><th>\n\nmse\n\n</th></tr></thead><tbody><tr><td>\n\n</td><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n</td><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n</td><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n</td><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n1.0968659790128028\n\n</td><td>\n\n-0.6117304039349463\n\n</td><td>\n\n0.0004078518285504836\n\n</td></tr><tr><td>\n\n0.14198850512877909\n\n</td><td>\n\n0.7741808484080007\n\n</td><td>\n\n0.005713017371341482\n\n</td></tr><tr><td>\n\n0.7303333678486678\n\n</td><td>\n\n-0.6250737654103594\n\n</td><td>\n\n0.01852879218352463\n\n</td></tr><tr><td>\n\n1.0082522818242372\n\n</td><td>\n\n-1.1740015481453143\n\n</td><td>\n\n0.006523442161727362\n\n</td></tr><tr><td>\n\n1.0214599029781481\n\n</td><td>\n\n-1.4342061326057263\n\n</td><td>\n\n0.002086531347398113\n\n</td></tr><tr><td>\n\n0.6657822330605759\n\n</td><td>\n\n-0.25445296261591593\n\n</td><td>\n\n0.04738923724610222\n\n</td></tr></tbody>\n</table>\n\n"
    },
    "wsum": {
        "url": "https://docs.dolphindb.com/en/Functions/w/wsum.html",
        "signatures": [
            {
                "full": "wsum(X, Y)",
                "name": "wsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [wsum](https://docs.dolphindb.com/en/Functions/w/wsum.html)\n\n\n\n#### Syntax\n\nwsum(X, Y)\n\n#### Arguments\n\n**X** / **Y** can be a scalar, vector, matrix or table.\n\n#### Details\n\nReturn the inner product of two vectors with the same length.\n\nPlease note that the data type of the result is DOUBLE, even if both *X* and *Y* are integers.\n\n#### Examples\n\n```\nwsum(7 8 9, 1 2 3);\n// output\n50\n// 7*1 + 8*2 + 9*3 = 50\n```\n\nRelated function: [wavg](https://docs.dolphindb.com/en/Functions/w/wavg.html)\n"
    },
    "wsum2": {
        "url": "https://docs.dolphindb.com/en/Functions/w/wsum2.html",
        "signatures": [
            {
                "full": "wsum2(X, Y)",
                "name": "wsum2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [wsum2](https://docs.dolphindb.com/en/Functions/w/wsum2.html)\n\n\n\n#### Syntax\n\nwsum2(X, Y)\n\n#### Arguments\n\n**X** / **Y** can be a scalar, vector, matrix or table.\n\n#### Details\n\n`wsum2` returns the weighted sum of squares of *X* and *Y*.\n\nPlease note that the data type of the result is DOUBLE, even if both *X* and *Y* are integers.\n\n#### Examples\n\n```\nwsum2(3 4 1, 1 2 3);\n// output\n44\n// 9*1 + 16*2 + 1*3 = 44\n```\n\nRelated: [wsum](https://docs.dolphindb.com/en/Functions/w/wsum.html)\n"
    },
    "xdb": {
        "url": "https://docs.dolphindb.com/en/Functions/x/xdb.html",
        "signatures": [
            {
                "full": "xdb(siteAlias, [userId], [password])",
                "name": "xdb",
                "parameters": [
                    {
                        "full": "siteAlias",
                        "name": "siteAlias"
                    },
                    {
                        "full": "[userId]",
                        "name": "userId",
                        "optional": true
                    },
                    {
                        "full": "[password]",
                        "name": "password",
                        "optional": true
                    }
                ]
            },
            {
                "full": "xdb(host, port, [userId], [password])",
                "name": "xdb",
                "parameters": [
                    {
                        "full": "host",
                        "name": "host"
                    },
                    {
                        "full": "port",
                        "name": "port"
                    },
                    {
                        "full": "[userId]",
                        "name": "userId",
                        "optional": true
                    },
                    {
                        "full": "[password]",
                        "name": "password",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [xdb](https://docs.dolphindb.com/en/Functions/x/xdb.html)\n\n\n\n#### Syntax\n\nxdb(siteAlias, \\[userId], \\[password])\n\nor\n\nxdb(host, port, \\[userId], \\[password])\n\n#### Arguments\n\n**siteAlias** is the alias of the remote node. It needs to be defined in configuration.\n\n**host** is the host name (IP address or website) of the remote node.\n\n**port** is the port number of the remote node.\n\n**userId** and **password** (optional) are based on the user's profile. They are used if the administrator has enabled [UserAccessControl](https://docs.dolphindb.com/en/Maintenance/UserAccessControl.html).\n\n#### Details\n\nConnect to a remote site. This remote site must be on. If the connection is successful, it returns the handle of the remote connection.\n\nSince DolphinDB 2.00.10.10, users can determine whether to limit the number of failed login attempts by setting the configuration *enhancedSecurityVerification*. If it is not specified, no limit will be applied; if it is set to true, a user's account will be blocked for 10 minutes if the password is entered wrongly 5 times in a minute.\n\n#### Examples\n\n```\nh2=xdb(\"local8081\");\nh2;\n// output\n\"Conn[localhost:8081:1166953221]\"\n\nh21=xdb(\"localhost\",8081);\nh21;\n// output\n\"Conn[localhost:8081:1441295757]\"\n\nh4=xdb(\"local8083\",\"userAdm\",\"passAdm\");\nh4;\n// output\n\"Conn[localhost:8083:1166953221]\"\n\nh41=xdb(\"localhost\",8083, \"user001\",\"pass001\");\nh41;\n// output\n\"Conn[localhost:8083:597793698]\"\n```\n"
    },
    "xor": {
        "url": "https://docs.dolphindb.com/en/Functions/x/xor.html",
        "signatures": [
            {
                "full": "xor(X, Y)",
                "name": "xor",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [xor](https://docs.dolphindb.com/en/Functions/x/xor.html)\n\n\n\n#### Syntax\n\nxor(X, Y)\n\n#### Arguments\n\n**X** and **Y** can be a scalar, pair, vector or matrix.\n\n#### Details\n\nPair each elements in *X* and *Y* to perform the \"exclusive or\" operation.\n\n#### Examples\n\n```\n1 xor 0\n// output\n1\n\nx = 5 6 7\nx xor 0\n// output\n[1,1,1]\n\nx = 1 2 3\ny = 2 1 3\nx xor y\n// output\n[0,0,0]\n\ntrue xor false\n// output\n1\n```\n\nRelated function: [or](https://docs.dolphindb.com/en/Programming/Operators/OperatorReferences/or.html), [not](https://docs.dolphindb.com/en/Functions/n/not.html)\n"
    },
    "year": {
        "url": "https://docs.dolphindb.com/en/Functions/y/year.html",
        "signatures": [
            {
                "full": "year(X)",
                "name": "year",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [year](https://docs.dolphindb.com/en/Functions/y/year.html)\n\n\n\n#### Syntax\n\nyear(X)\n\n#### Arguments\n\n**X** is a temporal scalar/vector.\n\n#### Details\n\nReturn the corresponding year(s). The data type of the result is INTEGER.\n\n#### Examples\n\n```\nyear(2012.12.03);\n// output\n2012\n\nyear(2012.12.03 2011.11.05);\n// output\n[2012,2011]\n\n(2012.12.03).year();\n// output\n2012\n```\n\nRelated functions: [second](https://docs.dolphindb.com/en/Functions/s/second.html), [minute](https://docs.dolphindb.com/en/Functions/m/minute.html), [hour](https://docs.dolphindb.com/en/Functions/h/hour.html), [date](https://docs.dolphindb.com/en/Functions/d/date.html), [month](https://docs.dolphindb.com/en/Functions/m/month.html)\n"
    },
    "yearBegin": {
        "url": "https://docs.dolphindb.com/en/Functions/y/yearBegin.html",
        "signatures": [
            {
                "full": "yearBegin(X, [startingMonth=1], [offset], [n=1])",
                "name": "yearBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [yearBegin](https://docs.dolphindb.com/en/Functions/y/yearBegin.html)\n\n\n\n#### Syntax\n\nyearBegin(X, \\[startingMonth=1], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**startingMonth** (optional) is an integer between 1 and 12 indicating a month. The default value is 1.\n\n**offset** (optional) is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the first day of the year that *X* belongs to and that starts in the month of *startingMonth*.\n\nIf parameter *offset* is specified, the result is updated every *n* years. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nyearBegin(2012.06.12, 10);\n// output\n2011.10.01\n\nyearBegin(2012.06.12, 4);\n// output\n2012.04.01\n\nyearBegin(2012.06.12);\n// output\n2012.01.01\n\nyearBegin(2012.06.12, 1, 2009.04.03, 2);\n// output\n2011.01.01\n\ndate=2011.04.25+(1..10)*365\ntime = take(09:30:00, 10);\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2012.04.24 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2013.04.24 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2014.04.24 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2015.04.24 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.04.23 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2017.04.23 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2018.04.23 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2019.04.23 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2020.04.22 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2021.04.22 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by yearBegin(date, 10, 2010.10.01, 2);\n```\n\n| yearBegin\\_date | avg\\_price | sum\\_qty |\n| --------------- | ---------- | -------- |\n| 2010.10.01      | 49.6       | 2200     |\n| 2012.10.01      | 29.49      | 4000     |\n| 2014.10.01      | 102.495    | 10000    |\n| 2016.10.01      | 112.995    | 6700     |\n| 2018.10.01      | 50.805     | 11300    |\n| 2020.10.01      | 52.38      | 4500     |\n\nRelated functions: [yearEnd](https://docs.dolphindb.com/en/Functions/y/yearEnd.html), [businessYearBegin](https://docs.dolphindb.com/en/Functions/b/businessYearBegin.html), [businessYearEnd](https://docs.dolphindb.com/en/Functions/b/businessYearEnd.html)\n"
    },
    "yearEnd": {
        "url": "https://docs.dolphindb.com/en/Functions/y/yearEnd.html",
        "signatures": [
            {
                "full": "yearEnd(X, [endingMonth=12], [offset], [n=1])",
                "name": "yearEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[endingMonth=12]",
                        "name": "endingMonth",
                        "optional": true,
                        "default": "12"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [yearEnd](https://docs.dolphindb.com/en/Functions/y/yearEnd.html)\n\n\n\n#### Syntax\n\nyearEnd(X, \\[endingMonth=12], \\[offset], \\[n=1])\n\n#### Arguments\n\n**X** is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.\n\n**endingMonth** (optional) is an integer between 1 and 12 indicating a month. The default value is 12.\n\n**offset** (optional) is a scalar of the same data type as *X*. It must be no greater than the minimum value of *X*. The default value is the minimum value of *X*.\n\n**n** (optional) is a positive integer. The default value is 1.\n\n#### Details\n\nReturn the last day of the year that *X* belongs to and that ends in the month of *endingMonth*.\n\nIf parameter *offset* is specified, the result is updated every *n* years. Parameter *offset* works only if parameter *n*>1.\n\n#### Examples\n\n```\nyearEnd(2012.06.12, 3);\n// output\n2013.03.31\n\nyearEnd(2012.06.12, 9);\n// output\n2012.09.30\n\nyearEnd(2012.06.12);\n// output\n2012.12.31\n\nyearEnd(2012.06.12, 12, 2009.04.03, 2);\n// output\n2013.12.31\n\ndate=2011.04.25+(1..10)*365\ntime = take(09:30:00, 10);\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2012.04.24 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2013.04.24 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2014.04.24 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2015.04.24 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.04.23 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2017.04.23 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2018.04.23 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2019.04.23 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2020.04.22 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2021.04.22 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by yearEnd(date, 4, 2010.04.01, 2);\n```\n\n| yearEnd\\_date | avg\\_price | sum\\_qty |\n| ------------- | ---------- | -------- |\n| 2012.04.30    | 49.6       | 2200     |\n| 2014.04.30    | 29.49      | 4000     |\n| 2016.04.30    | 102.495    | 10000    |\n| 2018.04.30    | 112.995    | 6700     |\n| 2020.04.30    | 50.805     | 11300    |\n| 2022.04.30    | 52.38      | 4500     |\n\nRelated functions: [yearBegin](https://docs.dolphindb.com/en/Functions/y/yearBegin.html), [businessYearBegin](https://docs.dolphindb.com/en/Functions/b/businessYearBegin.html), [businessYearEnd](https://docs.dolphindb.com/en/Functions/b/businessYearEnd.html)\n"
    },
    "zigzag": {
        "url": "https://docs.dolphindb.com/en/Functions/z/zigzag.html",
        "signatures": [
            {
                "full": "zigzag(HL, [change=10], [percent=true], [retrace=false], [lastExtreme=true])",
                "name": "zigzag",
                "parameters": [
                    {
                        "full": "HL",
                        "name": "HL"
                    },
                    {
                        "full": "[change=10]",
                        "name": "change",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[percent=true]",
                        "name": "percent",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[retrace=false]",
                        "name": "retrace",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[lastExtreme=true]",
                        "name": "lastExtreme",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [zigzag](https://docs.dolphindb.com/en/Functions/z/zigzag.html)\n\n\n\n#### Syntax\n\nzigzag(HL, \\[change=10], \\[percent=true], \\[retrace=false], \\[lastExtreme=true])\n\n#### Details\n\n**HL** is a numeric vector or a numeric matrix with two columns.\n\n**change** (optional) is the minimum threshold for extreme value movement.\n\n**percent** (optional) is a Boolean value indicating whether *change* is used as a percentage.\n\n**retrace** (optional) is a Boolean value. The default value is false.\n\n* true: *change* represents a retracement of the previous move.\n\n* false: *change* represents the change between the extreme points.\n\nNote: If *percent*=false, *retrace* can only take \"false\". Setting it to true has no effect.\n\n**lastExtreme** (optional) is a Boolean value indicating whether to output the last point if multiple consecutive points have the same value. The default value is true.\n\n#### Details\n\n`zigzag` is mainly used to filter values with smaller movements in *HL*. Only extreme points that satisfy the conditions will be output.\n\nIf *HL* is a vector, return a vector with the same length as *HL*; if *HL* is a matrix, return a vector with the same number of rows as *HL*.\n\n#### Examples\n\n```\nt = table(1.1 2.3 4.45 3.67 4.9 as `low, 1.3 2.8 4.9 3.73 6.28 as `high)\nHL = matrix(t[`low], t[`high])\nzz = zigzag(HL, change=10, percent=true, retrace=false, lastExtreme=true)\n```\n\n| 0   | 1 | 2    | 3    | 4   |\n| --- | - | ---- | ---- | --- |\n| 1.2 |   | 4.45 | 3.73 | 4.9 |\n\n```\nHL = 1.2 3 3.1 14 14.5 14.7 25.0 17.8 19 10\nzz = zigzag(HL, change=10, percent=true, retrace=false, lastExtreme=true)\n```\n\n| 0   | 1 | 2 | 3 | 4 | 5 | 6  | 7 | 8 | 9  |\n| --- | - | - | - | - | - | -- | - | - | -- |\n| 1.2 |   |   |   |   |   | 25 |   |   | 10 |\n"
    },
    "zscore": {
        "url": "https://docs.dolphindb.com/en/Functions/z/zscore.html",
        "signatures": [
            {
                "full": "zscore(X)",
                "name": "zscore",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [zscore](https://docs.dolphindb.com/en/Functions/z/zscore.html)\n\n\n\n#### Syntax\n\nzscore(X)\n\n#### Arguments\n\n**X** is a vector/matrix.\n\n#### Details\n\nIf *X* is a vector, return the zscore for all elements of *X*.\n\nIf *X* is a matrix, the zscore calculation is conducted within each column of *X*.\n\nAs with all aggregate functions, NULL values are not included in the calculation.\n\nPlease note that the calculation uses sample standard deviation instead of population standard deviation.\n\n#### Examples\n\n```\nzscore(1 2 3 4 5);\n// output\n[-1.264911,-0.632456,0,0.632456,1.264911]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nzscore(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| -1 | -1 |\n| 0  | 0  |\n| 1  | 1  |\n"
    },
    "zTest": {
        "url": "https://docs.dolphindb.com/en/Functions/z/zTest.html",
        "signatures": [
            {
                "full": "zTest(X, [Y], [mu=0.0], [sigmaX=1.0], [sigmaY=1.0], [confLevel=0.95])",
                "name": "zTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    },
                    {
                        "full": "[mu=0.0]",
                        "name": "mu",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[sigmaX=1.0]",
                        "name": "sigmaX",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[sigmaY=1.0]",
                        "name": "sigmaY",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[confLevel=0.95]",
                        "name": "confLevel",
                        "optional": true,
                        "default": "0.95"
                    }
                ]
            }
        ],
        "markdown": "### [zTest](https://docs.dolphindb.com/en/Functions/z/zTest.html)\n\n\n\n#### Syntax\n\nzTest(X, \\[Y], \\[mu=0.0], \\[sigmaX=1.0], \\[sigmaY=1.0], \\[confLevel=0.95])\n\n#### Arguments\n\n**X** is a numeric vector indicating the sample for the Z-test.\n\n**Y** (optional) is a numeric vector indicating the second sample for a paired-sample Z-test. It is optional.\n\n**mu** (optional) is a floating number. If *Y* is not specified, *mu* is the mean value of *X* in the null hypothesis; if *Y* is specified, *mu* is the difference in the mean values of *X* and *Y* in the null hypothesis. It is optional and the default value is 0.\n\n**sigmaX** (optional) is a floating number indicating the standard deviation of *X*. It is optional and the default value is 1.\n\n**sigmaY** (optional) is a floating number indicating the standard deviation of *Y*. It is optional and the default value is 1.\n\n**confLevel** (optional) is a floating number between 0 and 1 indicating the confidence level of the test. It is optional and the default value is 0.95.\n\n#### Details\n\nIf *Y* is not specified, conduct a one-sample Z-test on *X*. If *Y* is specified, conduct a paired-sample Z-test on *X* and *Y*.\n\nReturn a dictionary with the following keys:\n\n* stat: a table with p-value and confidence interval under 3 alternative hypotheses.\n\n* confLevel: confidence level\n\n* method: \"One sample Z-test\" if *Y* is not specified; \"Two sample Z-test\" if *Y* is specified.\n\n* zValue: Z-stat\n\n#### Examples\n\nOne-sample Z-test:\n\n```\nx = norm(5.0, 2.0, 30)\nzTest(x, , 5.0, 2.0);\n\n// output\nstat->\n\nalternativeHypothesis       pValue   lowerBound upperBound\n--------------------------- -------- ---------- -----------\ntrue mean is not equal to 5 0.035765 3.517659   4.949014\ntrue mean is less than 5    0.017882 -Infinity  4.833952\ntrue mean is greater than 5 0.982118 3.632721   Infinity\n\nconfLevel->0.95\nmethod->One sample z-test\nzValue->-2.099594\n```\n\nPaired-sample Z-test:\n\n```\nx = norm(5.0, 2.0, 30)\ny = norm(10.0, 3.0, 40)\nzTest(x, y, -5.0, 2.0, 3.0);\n\n// output\nstat->\n\n------------------------------------- -------- ---------- -----------\nalternativeHypothesis                 pValue   lowerBound upperBound\ndifference of mean is not equal to -5 0.976133 -6.191162  -3.844655\ndifference of mean is less than -5    0.488067 -Infinity  -4.033283\ndifference of mean is greater than -5 0.511933 -6.002533  Infinity\n\nconfLevel->0.95\nmethod->Two sample z-test\nzValue->-0.029917\n```\n"
    }
}
