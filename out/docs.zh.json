{
    "abs": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/abs.html",
        "signatures": [
            {
                "full": "abs(X)",
                "name": "abs",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [abs](https://docs.dolphindb.cn/zh/funcs/a/abs.html)\n\n\n\n#### 语法\n\nabs(X)\n\n#### 参数\n\n**X** 是可以标量、数据对、向量、矩阵或表。\n\n#### 详情\n\n对 *X* 内每个元素求绝对值并返回。\n\n#### 例子\n\n```\nabs(-2.0);\n// output: \n2\n\nabs(-2 -3 4);\n// output:\n[2, 3, 4]\n```\n"
    },
    "acf": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/acf.html",
        "signatures": [
            {
                "full": "acf(X, maxLag)",
                "name": "acf",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "maxLag",
                        "name": "maxLag"
                    }
                ]
            }
        ],
        "markdown": "### [acf](https://docs.dolphindb.cn/zh/funcs/a/acf.html)\n\n\n\n#### 语法\n\nacf(X, maxLag)\n\n#### 参数\n\n**X** 是一个向量。\n\n#### 详情\n\n计算 *X* 的1阶至 *maxLag* 阶的自相关系数。\n\n#### 例子\n\n```\nn=10000\nx=array(DOUBLE, n, n, NULL)\nx[0]=1\nr=rand(0.05, n)-0.025\nfor(i in 0:(n-1)){\n   x[i+1]=-0.8*x[i]+r[i]\n}\n\nacf = acf(x, 20)\nplot(acf,chartType=BAR)\n```\n\n相关函数： [autocorr](https://docs.dolphindb.cn/zh/funcs/a/autocorr.html)\n"
    },
    "acos": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/acos.html",
        "signatures": [
            {
                "full": "acos(X)",
                "name": "acos",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html)\n\n\n\n#### 语法\n\nacos(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 的反余弦。\n\n#### 例子\n\n```\nacos(1.000000 0.540302 -0.416147);\n// output: [0,1,2]\n```\n\n相关函数：[asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html), [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html), [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html), [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html), [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html), [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html), [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html), [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html), [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html), [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html), [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n"
    },
    "acosh": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/acosh.html",
        "signatures": [
            {
                "full": "acosh(X)",
                "name": "acosh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html)\n\n\n\n#### 语法\n\nacosh(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 的反双曲余弦。\n\n#### 例子\n\n```\nacosh(1 2 3);\n// output: [0,1.316958,1.762747]\n```\n\n相关函数：[asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html), [acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html), [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html), [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html), [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html), [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html), [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html), [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html), [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html), [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html), [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n"
    },
    "adaBoostClassifier": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/adaBoostClassifier.html",
        "signatures": [
            {
                "full": "adaBoostClassifier(ds, yColName, xColNames, numClasses, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=10], [minImpurityDecrease=0.0], [learningRate=0.1], [algorithm='SAMME.R'], [randomSeed])",
                "name": "adaBoostClassifier",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "numClasses",
                        "name": "numClasses"
                    },
                    {
                        "full": "[maxFeatures=0]",
                        "name": "maxFeatures",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[numTrees=10]",
                        "name": "numTrees",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[numBins=32]",
                        "name": "numBins",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[maxDepth=10]",
                        "name": "maxDepth",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[minImpurityDecrease=0.0]",
                        "name": "minImpurityDecrease",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[learningRate=0.1]",
                        "name": "learningRate",
                        "optional": true,
                        "default": "0.1"
                    },
                    {
                        "full": "[algorithm='SAMME.R']",
                        "name": "algorithm",
                        "optional": true,
                        "default": "'SAMME.R'"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [adaBoostClassifier](https://docs.dolphindb.cn/zh/funcs/a/adaBoostClassifier.html)\n\n\n\n#### 语法\n\nadaBoostClassifier(ds, yColName, xColNames, numClasses, \\[maxFeatures=0], \\[numTrees=10], \\[numBins=32], \\[maxDepth=10], \\[minImpurityDecrease=0.0], \\[learningRate=0.1], \\[algorithm='SAMME.R'], \\[randomSeed])\n\n#### 参数\n\n**ds** 是数据源，通常用 `sqlDS` 函数生成。\n\n**yColName** 是字符串，表示数据源中作为因变量（所属分类）的列名。\n\n**xColNames** 是字符串标量或向量，表示数据源中作为自变量的列名。\n\n**numClasses** 是正整数，表示分类数目。y 列的取值必须是\\[0, numClasses)之间的整数。\n\n**maxFeatures** 是一个整数或浮点数，表示一次分裂节点选取的特征个数或比例。默认值是0。\n\n* 如果 *maxFeatures* 为正整数，则在一次分裂时选取 *maxFeatures* 个特征。\n* 如果 *maxFeatures* =0，则在一次分裂时选取全部特征。\n* 如果 *maxFeatures* 是一个0和1之间的浮点数，则在一次分裂时选取 int(特征列数量 \\* *maxFeatures*)个特征。\n\n**numTrees** 是正整数，表示产生树的最大个数，即停止提升时的最大迭代次数。如果能够完美训练，学习会提前中止。默认值为10。\n\n**numBins** 是正整数，表示离散化连续特征时的桶数。默认值为32。增加 *numBins* 会使算法考虑更多的分裂节点的决策值，产生更好的分裂结果，但也会提高计算量和通讯量。\n\n**maxDepth** 是正整数，表示树的最大深度。默认值为10。\n\n**minImpurityDecrease** 是浮点数，如果分裂产生的基尼指数纯度减少值大于或等于这个值，节点会继续分裂。\n\n**learningRate** 是正浮点数，表示迭代过程中的每个分类器对下一个分类器的样本权重的影响。\n\n**algorithm** 是一个字符串，表示所使用的算法，可以取值 \"SAMME.R\" 或 \"SAMME\"。默认值为 \"SAMME.R\"。\n\n**randomSeed** 是随机数生成器使用的种子。\n\n#### 详情\n\n进行 AdaBoost 分类。返回结果是字典，包含以下 key：numClasses, minImpurityDecrease, maxDepth, numBins, numTrees, maxFeatures, model, modelName, xColNames, learningRate, algorithm。其中 model 是一个元组，保存了训练生成的树；modelName 为 \"AdaBoost Classifier\"\n\n生成的模型可以作为 `predict` 函数的输入。\n\n#### 例子\n\n用模拟数据训练一个 AdaBoost 分类模型\n\n```\nt = table(100:0, `cls`x0`x1, [INT,DOUBLE,DOUBLE])\nn=5\ncls = take(0, n)\nx0 = norm(0, 10, n)\nx1 = norm(0, 10, n)\ninsert into t values (cls, x0, x1)\ncls = take(1, n)\nx0 = norm(1, 10, n)\nx1 = norm(1, 10, n)\ninsert into t values (cls, x0, x1)\nmodel = adaBoostClassifier(sqlDS(<select * from t>), `cls, `x0`x1, 2);\n```\n\n把模型用于预测\n\n```\nt1 = table(-0.5 0 1 2 as x0, -2 0 1 3 as x1)\npredict(model, t1);\n```\n\n保存模型到磁盘，以及加载保存的模型\n\n```\nsaveModel(model, \"C:/DolphinDB/data/classifierModel.bin\");\nloadModel(\"C:/DolphinDB/data/classifierModel.bin\");\n```\n\n相关函数：[adaBoostRegressor](https://docs.dolphindb.cn/zh/funcs/a/adaBoostRegressor.html), [randomForestClassifier](https://docs.dolphindb.cn/zh/funcs/r/randomForestClassifier.html), [randomForestRegressor](https://docs.dolphindb.cn/zh/funcs/r/randomForestRegressor.html)\n"
    },
    "adaBoostRegressor": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/adaBoostRegressor.html",
        "signatures": [
            {
                "full": "adaBoostRegressor(ds, yColName, xColNames, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=10], [minImpurityDecrease=0.0], [learningRate=0.1], [loss='linear'], [randomSeed])",
                "name": "adaBoostRegressor",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[maxFeatures=0]",
                        "name": "maxFeatures",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[numTrees=10]",
                        "name": "numTrees",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[numBins=32]",
                        "name": "numBins",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[maxDepth=10]",
                        "name": "maxDepth",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[minImpurityDecrease=0.0]",
                        "name": "minImpurityDecrease",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[learningRate=0.1]",
                        "name": "learningRate",
                        "optional": true,
                        "default": "0.1"
                    },
                    {
                        "full": "[loss='linear']",
                        "name": "loss",
                        "optional": true,
                        "default": "'linear'"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [adaBoostRegressor](https://docs.dolphindb.cn/zh/funcs/a/adaBoostRegressor.html)\n\n\n\n#### 语法\n\nadaBoostRegressor(ds, yColName, xColNames, \\[maxFeatures=0], \\[numTrees=10], \\[numBins=32], \\[maxDepth=10], \\[minImpurityDecrease=0.0], \\[learningRate=0.1], \\[loss='linear'], \\[randomSeed])\n\n#### 参数\n\n**ds** 是数据源，通常用 `sqlDS` 函数生成。\n\n**yColName** 是字符串，表示数据源中作为因变量（所属分类）的列名。\n\n**xColNames** 是字符串标量或向量，表示数据源中作为自变量的列名。\n\n**numClasses** 是正整数，表示分类数目。y列的取值必须是\\[0, numClasses)之间的整数。\n\n**maxFeatures** 是一个整数或浮点数，表示一次分裂节点选取的特征个数或比例。默认值是0。\n\n* 如果 *maxFeatures* 为正整数，则在一次分裂时选取 *maxFeatures* 个特征。\n* 如果 *maxFeatures* =0 ，则在一次分裂时选取全部特征。\n* 如果 *maxFeatures* 是一个0和1之间的浮点数，则在一次分裂时选取 int(特征列数量\\*maxFeatures)个特征。\n\n**numTrees** 是正整数，表示产生树的最大个数，即停止提升时的最大迭代次数。如果能够完美训练，学习会提前中止。默认值为10。\n\n**numBins** 是正整数，表示离散化连续特征时的桶数。默认值为32。增加 *numBins* 会使算法考虑更多的分裂节点的决策值，产生更好的分裂结果，但也会提高计算量和通讯量。\n\n**maxDepth** 是正整数，表示树的最大深度。默认值为10。\n\n**minImpurityDecrease** 是浮点数，如果分裂产生的基尼指数纯度减少值大于或等于这个值，节点会继续分裂。\n\n**learningRate** 是正浮点数，表示迭代过程中的每个分类器对下一个分类器的样本权重的影响。\n\n**algorithm** 是一个字符串，表示所使用的算法，可以取值 \"SAMME.R\" 或 \"SAMME\"。默认值为 \"SAMME.R\"。\n\n**loss** 是一个字符串，表示在提升迭代时，更新样本权重时所用的损失函数，可以取值 \"linear\", \"square\" 或 \"exponential\"。默认值为 \"linear\"。\n\n**randomSeed** 是随机数生成器使用的种子。\n\n#### 详情\n\n进行 AdaBoost 回归。返回结果是字典，包含以下 key：numClasses, minImpurityDecrease, maxDepth, numBins, numTrees, maxFeatures, model, modelName, xColNames, learningRate, loss. 其中 model 是一个元组，保存了训练生成的树；modelName 为 \"AdaBoost Regressor\"。\n\n生成的模型可以作为 `predict` 函数的输入\n\n#### 例子\n\n用模拟数据训练一个 AdaBoost 分类模型\n\n```\nn=10\nx1 = rand(1.0, n)\nx2 = rand(1.0, n)\nb0 = 1\nb1 = 1\nb2 = -2\nerr = norm(0, 0.2, n)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(y, x1, x2)\nmodel = adaBoostRegressor(sqlDS(<select * from t>), `y, `x1`x2);\n```\n\n把模型用于预测\n\n```\nt1 = table(0 0.4 0.7 1 as x1, 0.9 0.2 0.1 0 as x2)\npredict(model, t1);\n```\n\n保存模型到磁盘及加载保存的模型\n\n```\nsaveModel(model, \"C:/DolphinDB/data/regressionModel.bin\")\nloadModel(\"C:/DolphinDB/data/regressionModel.bin\");\n```\n\n相关函数：[adaBoostClassifier](https://docs.dolphindb.cn/zh/funcs/a/adaBoostClassifier.html), [randomForestClassifier](https://docs.dolphindb.cn/zh/funcs/r/randomForestClassifier.html), [randomForestRegressor](https://docs.dolphindb.cn/zh/funcs/r/randomForestRegressor.html)\n"
    },
    "add": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/add.html",
        "signatures": [
            {
                "full": "add(X, Y)",
                "name": "add",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [add](https://docs.dolphindb.cn/zh/funcs/a/add.html)\n\n\n\n#### 语法\n\nadd(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量或矩阵。如果 *X* 和 *Y* 中其中一个是数据对、向量或矩阵，另一个参数的长度或维度必须相同。\n\n#### 详情\n\n对 *X* 和 *Y* 内的元素逐个求和并返回。\n\n#### 例子\n\n```\nadd(3,2)\n// output\n5\n\n1:2+6\n// output\n7:8\n\n1:2+3:4\n// output\n4 : 6\n\n3+1..3\n// output\n[4,5,6]\n\nadd(1..3, 4..6)\n// output\n[5,7,9]\n\n(1..3).add(4..6)\n// output\n[5,7,9]\n\nx=reshape(1..6, 3:2)\nx\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\nx+1.5\n```\n\n| 0   | 1   |\n| --- | --- |\n| 2.5 | 5.5 |\n| 3.5 | 6.5 |\n| 4.5 | 7.5 |\n\n```\ny=reshape(5..10, 3:2)\ny\n```\n\n| 0 | 1  |\n| - | -- |\n| 5 | 8  |\n| 6 | 9  |\n| 7 | 10 |\n\n```\nx+y\n```\n\n| 0  | 1  |\n| -- | -- |\n| 6  | 12 |\n| 8  | 14 |\n| 10 | 16 |\n\n参见 [\"+\" 运算符](https://docs.dolphindb.cn/zh/progr/operators/add.html)\n\n相关函数：[sub](https://docs.dolphindb.cn/zh/funcs/s/sub.html)\n"
    },
    "addAccessControl": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addAccessControl.html",
        "signatures": [
            {
                "full": "addAccessControl(table)",
                "name": "addAccessControl",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [addAccessControl](https://docs.dolphindb.cn/zh/funcs/a/addAccessControl.html)\n\n\n\n#### 语法\n\naddAccessControl(table)\n\n#### 参数\n\n**table** 共享表或者流数据引擎对象。\n\n#### 详情\n\n用户可使用此命令，限制其他用户访问该用户创建的共享表或者流数据引擎。进行此项操作后，其他用户只有被管理员赋予访问权限后，才可访问该用户创建的共享表或者流数据引擎。\n\n**Note:**\n\n1. 只能由创建 *table* 的用户或者管理员执行该命令。\n2. 如果管理员已经为其他用户 grant/deny/revoke 该表的权限，则该表自动添加权限限制，其他未经授权的用户无法再访问该表，建表用户无需调用 `addAccessControl` 对表进行访问管理。\n\n#### 例子\n\n创建一组用户，进行权限管理。\n\n```\nlogin(`admin, `123456)\ncreateUser(`u1, \"111111\");\ncreateUser(`u2, \"222222\");\ncreateUser(`u3, \"333333\");\n```\n\n流数据引擎：\n\n```\n// 用户 u1 创建流数据引擎 agg1\nlogin(`u1, \"111111\")\nshare streamTable(1000:0, `time`sym`volume, [TIMESTAMP, SYMBOL, INT]) as trades\noutput1 = table(10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT])\nagg1 = createTimeSeriesEngine(name=\"agg1\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"agg1\", offset=0, handler=append!{agg1}, msgAsTable=true);\n// 给 agg1 增加访问控制\naddAccessControl(agg1)\n\n// 用户 u2 访问\nlogin(`u2, \"222222\")\n\n// 注入数据\ninsert into trades values(2018.10.08T01:01:01.785,`A,10) # OK!\ninsert into agg1 values(2018.10.08T01:01:01.785,`A,10) # ERROR: No access to table [agg1]\n\n// 注销引擎\ndropStreamEngine(\"agg1\") # No access to drop stream engine agg1\n```\n\n共享内存表：\n\n```\nlogin(`u1, \"111111\")\nt = table(take(`a`b`c`, 10) as sym, 1..10 as val)\nshare t as st;\naddAccessControl(`st)\n\nlogin(`u3, \"333333\")\nselect * from st # ERROR: No access to shared table [st]\ninsert into st values(`a, 4) # ERROR: No access to shared table [st]\n```\n"
    },
    "addColumn": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addColumn.html",
        "signatures": [
            {
                "full": "addColumn(table, colNames, colTypes)",
                "name": "addColumn",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            }
        ],
        "markdown": "### [addColumn](https://docs.dolphindb.cn/zh/funcs/a/addColumn.html)\n\n\n\n#### 语法\n\naddColumn(table, colNames, colTypes)\n\n#### 参数\n\n**table** 内存表、流数据表、分布式表或维度表。\n\n**colNames** 是字符串标量或向量，表示要添加的列的名称。\n\n**colTypes** 是表示数据类型的标量或向量。\n\n#### 详情\n\n给数据表添加新的列。若对分布式表、维度表或流数据表添加新列，不能使用 SQL update 语句，只能使用 `addColumn` 命令。\n\n**Note:**\n\n* 分布式表或维度表通过 `addColumn` 命令添加新列后，需要使用 `loadTable` 后，才能更新追加的新列。\n* 从 2.00.5 版本开始，添加的列中允许包含特殊字符。\n\n#### 例子\n\n例1： 给分布式表增加列\n\n```\nID=1..6\nx=1..6\\5\nt1=table(ID, x)\ndb=database(\"dfs://rangedb\",RANGE,  1 4 7)\npt = db.createPartitionedTable(t1, `pt, `ID)\npt.append!(t1);\naddColumn(pt,[\"price\", \"qty\"],[DOUBLE, INT]);\n```\n\n增加列后，在插入新结构数据之前，仍然可以插入原来结构的数据。\n\n```\nt2=table(1 as ID, 1.2 as x)\npt.append!(t2)\nselect * from pt;\n```\n\n| ID | x   | price | qty |\n| -- | --- | ----- | --- |\n| 1  | 0.2 |       |     |\n| 2  | 0.4 |       |     |\n| 3  | 0.6 |       |     |\n| 1  | 1.2 |       |     |\n| 4  | 0.8 |       |     |\n| 5  | 1   |       |     |\n| 6  | 1.2 |       |     |\n\n一旦插入了新结构的数据，就不能插入原来结构的数据。\n\n```\nt3=table(1 as ID, 1.6 as x, 10.0 as price, 6 as qty)\npt.append!(t3)\nselect * from pt;\n```\n\n| ID | x   | price | qty |\n| -- | --- | ----- | --- |\n| 1  | 0.2 |       |     |\n| 2  | 0.4 |       |     |\n| 3  | 0.6 |       |     |\n| 1  | 1.2 |       |     |\n| 1  | 1.6 | 10    | 6   |\n| 4  | 0.8 |       |     |\n| 5  | 1   |       |     |\n| 6  | 1.2 |       |     |\n\n```\nt4=table(2 as ID, 2.2 as x)\npt.append!(t4);\n// output\nThe data to append contains fewer columns than the schema.\n```\n\n例2：给流数据表增加列\n\n```\nn=10\nticker = rand(`MSFT`GOOG`FB`ORCL`IBM,n)\nx=rand(1.0, n)\nt=streamTable(ticker, x)\nshare t as st\naddColumn(st,[\"price\", \"qty\"],[DOUBLE, INT])\ninsert into st values(\"MSFT\",12.0,25.46,256)\nselect * from st;\n```\n\n| ticker | x                 | price | qty |\n| ------ | ----------------- | ----- | --- |\n| MSFT   | 0.743241031421349 |       |     |\n| FB     | 0.254624255700037 |       |     |\n| FB     | 0.947473830310628 |       |     |\n| FB     | 0.904140035156161 |       |     |\n| MSFT   | 0.193251194199547 |       |     |\n| MSFT   | 0.416090324753895 |       |     |\n| MSFT   | 0.479371337918565 |       |     |\n| ORCL   | 0.69910929678008  |       |     |\n| GOOG   | 0.131539688445628 |       |     |\n| MSFT   | 0.472390263108537 |       |     |\n| MSFT   | 12                | 25.46 | 256 |\n"
    },
    "addFunctionView": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addFunctionView.html",
        "signatures": [
            {
                "full": "addFunctionView(udf|moduleName)",
                "name": "addFunctionView",
                "parameters": [
                    {
                        "full": "udf|moduleName",
                        "name": "udf|moduleName"
                    }
                ]
            }
        ],
        "markdown": "### [addFunctionView](https://docs.dolphindb.cn/zh/funcs/a/addFunctionView.html)\n\n\n\n#### 语法\n\naddFunctionView(udf|moduleName)\n\n#### 参数\n\n**udf** 是用户自定义函数。\n\n**moduleName** 是一个字符串标量，代表模块名称。\n\n**Note:**\n\n* 不支持匿名函数。\n* 自定义函数只能接收标量、数据对或常规数组作为默认参数。\n* *moduleName* 相应模块必须放置于节点的 modules 目录下\n* 若 modules 目录下同时存在名为 *moduleName* 的 dos 和 dom 文件，则优先加载 dos 文件。\n* 如果在当前节点使用use \\<moduleName> 的方式加载模块使用，即使同名模块和函数已通过 addFunctionView 封装，也会优先使用最新加载的模块。\n\n#### 详情\n\n函数视图是封装了访问数据库以及相关计算语句的一种特殊的自定义函数。函数视图提供了一种灵活的方式来控制用户访问数据库和表。用户即使不具备读写数据库原始数据的权限，也可通过执行函数视图，间接访问数据库，得到所需计算结果。例如，用户不能查看个别患者的名称和年龄等原始数据，但是可以获取患者的总数与平均年龄。\n\n与其他自定义函数会话隔离不同，函数视图可以实现会话之间的共享。函数视图的定义持久化存储在控制节点，因此如果 DolphinDB 集群重启，之前定义的函数视图仍然可以使用。\n\n使用 [grant](https://docs.dolphindb.cn/zh/funcs/g/grant.html), [deny](https://docs.dolphindb.cn/zh/funcs/d/deny.html) 或 [revoke](https://docs.dolphindb.cn/zh/funcs/r/revoke.html) 命令对用户的 VIEW\\_EXEC 权限进行操作时，用户自定义函数可以作为这些命令的 objs 参数。\n\n`addFunctionView` 只能由管理员或拥有 VIEW\\_OWNER 权限的普通用户执行。\n\n#### 例子\n\n下例中，自定义函数 `getSpread` 计算 `dfs://TAQ/quotes` 表中指定股票的平均买卖报价差。用户 user1 不具有读取 `dfs://TAQ/quotes` 表的权限。将函数 `getSpread` 定义为函数视图， 并赋予用户 user1 执行该视图的权限。虽然 user1 不具备读取 `dfs://TAQ/quotes` 表的权限，但可通过执行 `getSpread` 函数，对 `dfs://TAQ/quotes` 表的数据进行计算，来获得指定股票的买卖报价差。\n\n由于 `dfs://TAQ/quotes` 是分布式数据库，以下代码需要由系统管理员在控制节点上执行。用户 user1 可在任意数据节点/计算节点运行 `getSpread` 函数。\n\n```\ndef getSpread(s, d){\n return select avg((ofr-bid)/(ofr+bid)*2) as spread from loadTable(\"dfs://TAQ\",\"quotes\") where symbol=s, date=d\n}\n\naddFunctionView(getSpread)\n\n// grant 操作需在控制节点执行\ngrant(\"user1\", VIEW_EXEC, \"getSpread\")\n```\n\n确保在节点的 modules 下已存在 test.dos，模块 test 中定义了函数 f1 和 f2。\n\n```\n addFunctionView(\"test\")\n\n//为用户 user1 授权执行模块 test 下的函数 f1\ngrant(\"user1\", VIEW_EXEC, \"test::f1\")\n//为用户 user1 授权执行模块 test 下的所有函数\ngrant(`user1, VIEW_EXEC, \"test::*\")\n\n//用户可使用全限定名调用相应函数\ntest::f1()\n```\n\n相关命令： [dropFunctionView](https://docs.dolphindb.cn/zh/funcs/d/dropFunctionView.html)\n"
    },
    "addGpFunction": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addgpfunction.html",
        "signatures": [
            {
                "full": "addGpFunction(engine, func)",
                "name": "addGpFunction",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    }
                ]
            }
        ],
        "markdown": "### [addGpFunction](https://docs.dolphindb.cn/zh/funcs/a/addgpfunction.html)\n\n#### 语法\n\naddGpFunction(engine, func)\n\n**Note:**\n\n社区版 License 暂不支持该函数，如需使用此功能，请联系技术支持。\n\n#### 详情\n\n在现有训练函数的基础上增加用户自定义函数，用于初始化公式树和进化时使用。支持的算子详见附录。\n\n#### 参数\n\n**engine**通过函数 `createGPLearnEngine` 创建引擎的返回对象。\n\n**func** 用户自定义函数。自定义函数目前不支持复杂赋值、if、for 等语句，只支持 return 语句，return 值为已支持的训练函数的组合。例如：\n\n```\ndef f(x, y){\n  return cos(x+y)\n}\n```\n\n#### 例子\n\n```\ndef f(x, y){\n  return cos(x+y)\n}\naddGpFunction(engine,f)\n```\n\n#### 附录\n\n目前已支持的训练函数：\n\n**Note:** 对于所有的 m 系列函数，如果当前窗口小于 n，则会直接返回 0。而 DolphinDB 默认返回空值。\n\n| 函数名             | 入参数量 | 描述                               |\n| --------------- | ---- | -------------------------------- |\n| add(x,y)        | 2    | 加法                               |\n| sub(x,y)        | 2    | 减法                               |\n| mul(x,y)        | 2    | 乘法                               |\n| div(x,y)        | 2    | 除法， 如果除数的绝对值小于0.001，返回1          |\n| max(x,y)        | 2    | 最大值                              |\n| min(x,y)        | 2    | 最小值                              |\n| sqrt(x)         | 1    | 按照绝对值开方                          |\n| log(x)          | 1    | `iif(x < 0.001, 0, log(abs(x)))` |\n| neg(x)          | 1    | 相反数                              |\n| reciprocal(x)   | 1    | 倒数，如果x的绝对值小于0.001，将返回0           |\n| abs(x)          | 1    | 绝对值                              |\n| sin(x)          | 1    | 正弦函数                             |\n| cos(x)          | 1    | 余弦函数                             |\n| tan(x)          | 1    | 正切函数                             |\n| sig(x)          | 1    | sigmoid函数                        |\n| mdiff(x, n)     | 1    | x的n阶差分                           |\n| mcovar(x, y, n) | 2    | 滑动窗口为n时，x和y的协方差                  |\n| mcorr(x, y, n)  | 2    | 滑动窗口为n时，x和y的相关性                  |\n| mstd(x, n)      | 1    | 滑动窗口为n时，x的样本标准差                  |\n| mmax(x, n)      | 1    | 滑动窗口为n时，x的最大值                    |\n| mmin(x, n)      | 1    | 滑动窗口为n时，x的最小值                    |\n| msum(x, n)      | 1    | 滑动窗口为n时，x的和                      |\n| mavg(x, n)      | 1    | 滑动窗口为n时，x的平均数                    |\n| mprod(x, n)     | 1    | 滑动窗口为n时，x的积                      |\n| mvar(x, n)      | 1    | 滑动窗口为n时，x的样本方差                   |\n| mvarp(x, n)     | 1    | 滑动窗口为n时，x的总体方差                   |\n| mstdp(x, n)     | 1    | 滑动窗口为n时，x的总体标准差                  |\n| mimin(x, n)     | 1    | 滑动窗口为n时，x的最小值下标                  |\n| mimax(x, n)     | 1    | 滑动窗口为n时，x的最大值下标                  |\n| mbeta(x, y, n)  | 2    | 滑动窗口为n时，x在y上的回归系数的最小二乘估计         |\n| mwsum(x, y, n)  | 2    | 滑动窗口为n时，x和y的内积                   |\n| mwavg(x, y, n)  | 2    | 滑动窗口为n时，x以y为权重的加权平均值             |\n\n\n\n**Related information**\n\n[Shark GPLearn 快速上手](https://docs.dolphindb.cn/zh/tutorials/gplearn.html)\n"
    },
    "addGroupMember": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addGroupMember.html",
        "signatures": [
            {
                "full": "addGroupMember(userIds, groupIds)",
                "name": "addGroupMember",
                "parameters": [
                    {
                        "full": "userIds",
                        "name": "userIds"
                    },
                    {
                        "full": "groupIds",
                        "name": "groupIds"
                    }
                ]
            }
        ],
        "markdown": "### [addGroupMember](https://docs.dolphindb.cn/zh/funcs/a/addGroupMember.html)\n\n\n\n#### 语法\n\naddGroupMember(userIds, groupIds)\n\n#### 参数\n\n**userIds** 是一个表示用户名称的字符串。\n\n**groupIds** 是一个表示群组名称的字符串。\n\n*userIds* 和 *groupIds* 不能同时为向量。\n\n#### 详情\n\n把用户添加到群组：\n\n* 添加一个用户到一个群组\n* 添加多个用户到一个群组\n* 添加一个用户到多个群组\n\n该操作可能会因为组所具有的权限而使入组用户的权限发生改变。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n添加一个用户（Even）到一个群组（adm 组）：\n\n```\naddGroupMember(\"Even\", \"adm\");\n```\n\n添加多个用户（Alice 和 CardiB）到一个群组（adm 组）：\n\n```\naddGroupMember([\"Alice\",\"CardiB\"], \"adm\"); \n```\n\n添加一个用户（Carlos）到多个群组（adm 组和 prof 组）：\n\n```\naddGroupMember(\"Carlos\", [\"adm\",\"prof\"]);\n```\n"
    },
    "addMarketHoliday": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addMarketHoliday.html",
        "signatures": [
            {
                "full": "addMarketHoliday(marketName, holiday, [dateType = 'holidayDate'])",
                "name": "addMarketHoliday",
                "parameters": [
                    {
                        "full": "marketName",
                        "name": "marketName"
                    },
                    {
                        "full": "holiday",
                        "name": "holiday"
                    },
                    {
                        "full": "[dateType = 'holidayDate']",
                        "name": "[dateType = 'holidayDate']"
                    }
                ]
            }
        ],
        "markdown": "### [addMarketHoliday](https://docs.dolphindb.cn/zh/funcs/a/addMarketHoliday.html)\n\n#### 语法\n\naddMarketHoliday(marketName, holiday, \\[dateType = 'holidayDate'])\n\n#### 详情\n\n在线添加一个交易市场节假日或交易日文件，通过此文件生成一个交易日历。调用该函数后，在 *marketHolidayDir* 指定的目录下会生成一个和 *marketName* 同名的 csv 文件。\n\n**Note:**\n\n* 该函数只能由管理员调用。\n* 该函数仅对当前节点有效。集群环境中，通过 `pnodeRun` 调用该函数，使其在其它节点生效。\n\n#### 参数\n\n**marketName** 字符串标量，表示交易日历标识，例如：国外交易所的 ISO Code、国内交易所简称或自定义交易日历名称。\n\n**Note:**\n\n* *marketName* 必须由4个大写字母组成，且不能与 *marketHolidayDir* 下的文件名相同。\n\n**holiday** DATE 类型向量，表示日期。\n\n* 当 *dateType*='holidayDate' 时，*holiday* 需要指定为休市日期，因为系统默认周末为休市日，所以 *holiday* 只需指定非周末的休市日期。\n* 当 *dateType*='tradingDate' 时，*holiday* 需要指定为交易日期。\n\n**dateType** 字符串，用于指定交易日历文件的数据是休市日期还是交易日期。可选值为 ‘holidayDate’（默认）或 'tradingDate'。\n\n#### 例子\n\n以下例子展示如何通过该函数手动添加名为 \"DCBA\" 的交易日历标识。\n\n```\naddMarketHoliday(\"DCBA\",2022.01.03 2022.01.05)\n```\n\n运行后，在 `/server/marketHoliday/` 路径下会新增一个名为 `DCBA.csv` 的文件，其中包含了已添加的节假日。\n\n![](https://docs.dolphindb.cn/zh/images/addMarketHoliday.png \"DCBA\")\n\n**Note:** 使用该函数添加已存在于交易日历中的交易日历标识时，会出现 `The added market '<marketName>' already exists.` 的提示，说明该交易日历标识已存在于 `/server/marketHoliday/` 目录下，不需要重复添加。\n\n```\ntemporalAdd(2022.01.01,1,\"DCBA\")\n```\n\n返回：2022.01.04\n\n```\nindex = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.04]\ns = indexedSeries(index, 1..4)\ns.resample(\"DCBA\", sum);\n```\n\n返回：\n\n```\nlabel\tcol1\n2021.12.31   6\n2022.01.04   4\n```\n\n新创建一个交易日历，其数据为交易日期：\n\n```\ntradingDates=[2024.02.08, 2024.02.09, 2024.02.18, 2024.02.19, 2024.02.20, 2024.02.21]\naddMarketHoliday(marketName=\"AAAA\", holiday=tradingDates, dateType='tradingDate')\n```\n\n运行以上代码后，在 `/server/marketHoliday/` 路径下会新增一个名为 *AAAA.csv*的文件，包含1列数据，字段名称为 tradingDate，数据为 tradingDates。\n\n```\ntemporalAdd(2024.02.09, 1, \"AAAA\") \n```\n\n返回：2024.02.18\n\n```\ntemporalAdd(2024.02.21, 1, \"AAAA\")\n//计算得到的日期如果不在 AAAA.csv 文件中记录，则会报错：The returned date does not exist in trading calendar [AAAA].\n```\n\n\n\n**Related information**\n\n[updateMarketHoliday](https://docs.dolphindb.cn/zh/funcs/u/updateMarketHoliday.html)\n\n[getMarketCalendar](https://docs.dolphindb.cn/zh/funcs/g/getMarketCalendar.html)\n\n[getTradingCalendarType](https://docs.dolphindb.cn/zh/funcs/g/gettradingcalendartype.html)\n"
    },
    "addMetrics": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addMetrics.html",
        "signatures": [
            {
                "full": "addMetrics(engine, newMetrics, newMetricsSchema, [windowSize], [fill])",
                "name": "addMetrics",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "newMetrics",
                        "name": "newMetrics"
                    },
                    {
                        "full": "newMetricsSchema",
                        "name": "newMetricsSchema"
                    },
                    {
                        "full": "[windowSize]",
                        "name": "windowSize",
                        "optional": true
                    },
                    {
                        "full": "[fill]",
                        "name": "fill",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [addMetrics](https://docs.dolphindb.cn/zh/funcs/a/addMetrics.html)\n\n\n\n#### 语法\n\naddMetrics(engine, newMetrics, newMetricsSchema, \\[windowSize], \\[fill])\n\n别名：extendMetrics\n\n#### 参数\n\n**engine** 是流数据引擎，即 [createTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesEngine.html) 等函数返回的抽象表对象。请注意，暂不支持 [createAnomalyDetectionEngine](https://docs.dolphindb.cn/zh/funcs/c/createAnomalyDetectionEngine.html) 和 [createReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createReactiveStateEngine.html) 引擎。\n\n**newMetrics** 是元代码，表示流数据引擎增加的计算指标。可以是一个或多个表达式、系统内置或用户自定义函数，也可以是一个常量标量/向量。当指定为常量向量时，对应的输出列应该设置为数组向量类型。\n\n**newMetricsSchema** 是表对象，指定新增的计算指标在输出表中的列名和数据类型。\n\n**windowSize** 是一个正整数，表示新增指标的计算窗口长度。仅适用于时间序列引擎，且必须为已指定的窗口长度之一。若未指定，默认值为第一个已指定的窗口长度。\n\n**fill** 可选参数，一个标量或向量，指定某个分组的某个窗口无数据时的处理方法。可取以下值：\n\n* 'none': 不输出结果。\n* 'null': 输出结果为 NULL。\n* 'ffill': 输出上一个有数据的窗口的结果。\n* '具体数值'：该值的数据类型需要和对应的 *metrics* 计算结果的类型保持一致。\n\n*fill* 可以输入向量，长度与 *metrics* 元素个数保持一致，表示为每个 *metrics* 指定不同的 *fill* 方式。若为向量，向量中各项只能是 'null', 'ffill' 或一个数值，不能是 'none'。\n\n#### 详情\n\n动态增加流数据引擎的计算指标。\n\n#### 例子\n\n使用流数据时间序列引擎计算 sum(x) 指标。\n\n```\nshare streamTable(10000:0,`time`id`x, [TIMESTAMP,SYMBOL,INT]) as t\noutput1 = table(10000:0, `time`sum_x, [TIMESTAMP,INT])\nagg1 = createTimeSeriesEngine(name=`agg1, windowSize=100, step=50, metrics=<sum(x)>, dummyTable=t, outputTable=output1, timeColumn=`time)\nsubscribeTable(tableName=\"t\", actionName=\"agg1\", offset=0, handler=append!{agg1}, msgAsTable=true)\nn=500\ntime=2019.01.01T00:00:00.000+(1..n)\nid=take(`ABC`DEF, n)\nx=1..n\ninsert into t values(time, id, x);\nselect * from output1;\n```\n\n| time                    | sum\\_x |\n| ----------------------- | ------ |\n| 2019.01.01T00:00:00.050 | 1,225  |\n| 2019.01.01T00:00:00.100 | 4,950  |\n| 2019.01.01T00:00:00.150 | 9,950  |\n| 2019.01.01T00:00:00.200 | 14,950 |\n| 2019.01.01T00:00:00.300 | 24,950 |\n| 2019.01.01T00:00:00.350 | 29,950 |\n| 2019.01.01T00:00:00.400 | 34,950 |\n| 2019.01.01T00:00:00.450 | 39,950 |\n| 2019.01.01T00:00:00.500 | 44,950 |\n\n给时间序列引擎增加 avg(x) 指标，该指标在输出表中的名称为 avg\\_x，数据类型为 DOUBLE。\n\n```\nnewMetricsSchema= table(1:0, [`avg_x], [DOUBLE])\naddMetrics(agg1, <avg(x)>, newMetricsSchema);\nn=300\ntime=2019.01.01T00:00:00.500+(1..n)\nid=take(`ABC`DEF, n)\nx=500+1..n\ninsert into t values(time, id, x);\nselect * from output1;\n```\n\n| time                    | sum\\_x | avg\\_x |\n| ----------------------- | ------ | ------ |\n| 2019.01.01T00:00:00.050 | 1,225  |        |\n| 2019.01.01T00:00:00.100 | 4,950  |        |\n| 2019.01.01T00:00:00.150 | 9,950  |        |\n| 2019.01.01T00:00:00.200 | 14,950 |        |\n| 2019.01.01T00:00:00.250 | 19,950 |        |\n| 2019.01.01T00:00:00.300 | 24,950 |        |\n| 2019.01.01T00:00:00.350 | 29,950 |        |\n| 2019.01.01T00:00:00.400 | 34,950 |        |\n| 2019.01.01T00:00:00.450 | 39,950 |        |\n| 2019.01.01T00:00:00.500 | 44,950 |        |\n| 2019.01.01T00:00:00.550 | 49,950 | 525    |\n| 2019.01.01T00:00:00.600 | 54,950 | 550    |\n| 2019.01.01T00:00:00.650 | 59,950 | 599.5  |\n| 2019.01.01T00:00:00.700 | 64,950 | 649.5  |\n| 2019.01.01T00:00:00.750 | 69,950 | 699.5  |\n| 2019.01.01T00:00:00.800 | 74,950 | 749.5  |\n"
    },
    "addNode": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addNode.html",
        "signatures": [
            {
                "full": "addNode(host, port, alias, [saveConfig=true], [nodeType='datanode'], [computeGroup])",
                "name": "addNode",
                "parameters": [
                    {
                        "full": "host",
                        "name": "host"
                    },
                    {
                        "full": "port",
                        "name": "port"
                    },
                    {
                        "full": "alias",
                        "name": "alias"
                    },
                    {
                        "full": "[saveConfig=true]",
                        "name": "saveConfig",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[nodeType='datanode']",
                        "name": "nodeType",
                        "optional": true,
                        "default": "'datanode'"
                    },
                    {
                        "full": "[computeGroup]",
                        "name": "computeGroup",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [addNode](https://docs.dolphindb.cn/zh/funcs/a/addNode.html)\n\n#### 语法\n\naddNode(host, port, alias, \\[saveConfig=true], \\[nodeType='datanode'], \\[computeGroup])\n\n#### 参数\n\n**host** 是字符串标量或向量，表示新增节点的 IP 地址。\n\n**port** 是正整数标量或向量，表示新增节点的端口号。\n\n**alias** 是字符串标量或向量，表示新增节点的别名。\n\n**saveConfig** 是一个布尔值，表示是否在增加节点的同时，将节点信息保存到 cluster.nodes 配置文件。默认值为 true。\n\n**nodeType** 是字符串标量或向量，表示新增节点类型。支持 'datanode' 和 'computenode' 两个选项。\n\n**computeGroup** 可选参数，字符串标量，用于指定计算节点所属的计算组名称。若未设置此参数，则表示该计算节点未加入任何计算组，不会缓存数据。\n\n**Note:** 参数 *host*, *port*, *alias*, *nodeType* 的长度须保持一致。\n\n#### 详情\n\n增加数据节点或计算节点。仅限 admin 用户调用。\n\n新增加的节点为关闭状态，需要通过 Web 集群管理器或命令行启动它。\n\n**Note:**\n\n在新服务器上增加节点前需要先部署代理节点。详情参考教程： [多服务器集群部署](https://docs.dolphindb.cn/zh/tutorials/multi_machine_cluster_deployment.html)。\n\n#### 例子\n\n增加一个别名为 “node1” 的数据节点。\n\n```\naddNode(\"192.168.1.103\",8900,\"node1\");\n```\n\n增加一个别名为 “orca4” 的计算节点到计算组 \"orca\"。\n\n```\naddNode(\"192.168.1.243\", 23796, \"orca4\", true, 'computenode', \"orca\");\n```\n\n"
    },
    "addRangePartitions": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addRangePartitions.html",
        "signatures": [
            {
                "full": "addRangePartitions(dbHandle, newRanges, [level=0], [locations])",
                "name": "addRangePartitions",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "newRanges",
                        "name": "newRanges"
                    },
                    {
                        "full": "[level=0]",
                        "name": "level",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[locations]",
                        "name": "locations",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [addRangePartitions](https://docs.dolphindb.cn/zh/funcs/a/addRangePartitions.html)\n\n\n\n#### 语法\n\naddRangePartitions(dbHandle, newRanges, \\[level=0], \\[locations])\n\n#### 参数\n\n**dbHandle** 是数据库句柄。\n\n**newRanges** 是向量，表示新的分区。它必须按升序排序，并且第一个元素必须与数据库的原分区方案的最后一个元素相同。\n\n**level** 是整数。当分区类型为 COMPO，并且每层分区为 RANGE 时，需要使用 *level* 参数指定 RANGE 分区所在的层。它是可选参数。默认值为0。\n\n**locations** 是字符串标量或向量。如果目标数据库创建时，指定了 *locations* 参数，增加新的分区时可以使用 *locations* 参数指定新增分区的位置。它是可选参数。\n\n#### 详情\n\n给数据库增加新的分区。目标数据库必须是 RANGE 分区类型或 COMPO 分区类型并且至少其中一层分区为 RANGE 类型。返回的结果是一个整数，表示新增的分区数量。注意，只能在最后一个现有数据分区后面添加分区，不能在第一个现有数据分区前面添加分区。\n\n#### 例子\n\n下面的例子是给分区类型为 COMPO 的数据库新增\\[101, 150), \\[150,200)和\\[200,250)分区，但无法新增 \\[50,100) 分区。\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(date, ID, x);\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID=database(, RANGE, 0 50 101);\ndb = database(\"dfs://compoDB\", COMPO, [dbDate,dbID]);\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n\naddRangePartitions(db,101 150 200 250,1)\n// output\n3\n```\n\n添加新的分区后，需要重新加载数据库。\n\n```\ndb=database(\"dfs://compoDB\")\npt=loadTable(db,\"pt\")\n\nt1=table(rand(2017.08.07..2017.08.11,n) as date, rand(101..249,n) as ID, rand(10.0,n) as x)\npt.append!(t1);\n\nselect count(*) from loadTable(\"dfs://compoDB\",\"pt\");\n// output\n2000000\n```\n"
    },
    "addReactiveMetrics": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addreactivemetrics.html",
        "signatures": [
            {
                "full": "addReactiveMetrics(name, metricNames, metrics)",
                "name": "addReactiveMetrics",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metricNames",
                        "name": "metricNames"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    }
                ]
            }
        ],
        "markdown": "### [addReactiveMetrics](https://docs.dolphindb.cn/zh/funcs/a/addreactivemetrics.html)\n\n\n\n#### 语法\n\naddReactiveMetrics(name, metricNames, metrics)\n\n#### 参数\n\n**name** 字符串，表示需要增加指标的 narrowReactiveStateEngine 的名称。\n\n**metricNames** 字符串标量或向量，表示 narrowReactiveStateEngine 增加的计算指标的名称。\n\n**metrics** 以元代码的格式表示计算指标，支持输入元组，表示流数据引擎增加的计算指标。计算指标与 *metricNames* 指定的名称一一对应。\n\n#### 详情\n\n动态增加 narrowReactiveStateEngine 的计算指标。更新后的计算指标在引擎后续注入的数据时生效。\n\n#### 例子\n\n```\ndummy = streamTable(1:0, [\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"upToDatePrice\",\"qty\",\"value\"], [STRING,STRING,STRING,TIMESTAMP,TIMESTAMP,DOUBLE,DOUBLE,INT]) \noutputTable = streamTable(1:0,[\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"metricNames\",\"factorValue\"], [STRING,STRING,STRING, TIMESTAMP,TIMESTAMP,STRING,DOUBLE])\nfactor = [<createTime>, <updateTime>,<cumsum(qty)>]\nNarrowtest = createNarrowReactiveStateEngine(name=\"narrowtest1\",metrics=factor,metricNames=\"factor1\",dummyTable=dummy,outputTable=outputTable,keyColumn=[\"securityID1\",\"securityID2\",\"securityID3\"])\nnum = 5\ntmp = table(take(\"A\" + lpad(string(1..4),4,\"0\"),num) as securityID1,take(\"CC.HH\" + lpad(string(21..34),4,\"0\"),num) as securityID2,take(\"FFICE\" + lpad(string(13..34),4,\"0\"),num) as securityID3, 2023.09.01 00:00:00+(1..num) as createTime, 2023.09.01 00:00:00+(1..num) as updateTime,100.0+(1..num) as upToDatePrice, 130.0+(1..num) as qty,take(1..3,num) as value)\nNarrowtest.append!(tmp)\n\nselect * from outputTable\n```\n\n| securityID1 | securityID2 | securityID3 | createTime              | updateTime              | metricNames | factorValue |\n| ----------- | ----------- | ----------- | ----------------------- | ----------------------- | ----------- | ----------- |\n| A0001       | CC.HH0021   | FFICE0013   | 2023.09.01T00:00:01.000 | 2023.09.01T00:00:01.000 | factor1     | 131         |\n| A0002       | CC.HH0022   | FFICE0014   | 2023.09.01T00:00:02.000 | 2023.09.01T00:00:02.000 | facto1      | 132         |\n| A0003       | CC.HH0023   | FFICE0015   | 2023.09.01T00:00:03.000 | 2023.09.01T00:00:03.000 | facto1      | 133         |\n| A0004       | CC.HH0024   | FFICE0016   | 2023.09.01T00:00:04.000 | 2023.09.01T00:00:04.000 | facto1      | 134         |\n| A0001       | CC.HH0025   | FFICE0017   | 2023.09.01T00:00:05.000 | 2023.09.01T00:00:05.000 | facto1      | 135         |\n\n```\nmetrics = [<cumavg(upToDatePrice)>]\naddReactiveMetrics(\"narrowtest1\", \"factor2\", metrics)\n\n//新增计算指标后，再次向引擎注入数据，则会输出更新后的指标计算结果\ntmp1 = table(\"A5\" as securityID1,\"CC.HH0033\" as securityID2,\"FFICE0034\" as securityID3, 2023.09.01 00:00:11 as createTime, 2023.09.01 00:00:09 as updateTime,59 as upToDatePrice,100 as qty,13 as value)\nNarrowtest.append!(tmp1)\nselect * from outputTable where securityID1=\"A5\"\n```\n\n<table id=\"table_lk3_kcx_yzb\"><tbody><tr><td>\n\nsecurityID1\n\n</td><td>\n\nsecurityID2\n\n</td><td>\n\nsecurityID3\n\n</td><td>\n\ncreateTime\n\n</td><td>\n\nupdateTime\n\n</td><td>\n\nmetricNames\n\n</td><td>\n\nfactorValue\n\n</td></tr><tr><td>\n\nA5\n\n</td><td>\n\nCC.HH0033\n\n</td><td>\n\nFFICE0034\n\n</td><td>\n\n2023.09.01T00:00:11.000\n\n</td><td>\n\n2023.09.01T00:00:09.000\n\n</td><td>\n\nfacto1\n\n</td><td>\n\n100\n\n</td></tr><tr><td>\n\nA5\n\n</td><td>\n\nCC.HH0033\n\n</td><td>\n\nFFICE0034\n\n</td><td>\n\n2023.09.01T00:00:11.000\n\n</td><td>\n\n2023.09.01T00:00:09.000\n\n</td><td>\n\nfacto2\n\n</td><td>\n\n59\n\n</td></tr></tbody>\n</table>相关函数：[createNarrowReactiveStateEngine](../c/createnarrowreactivestateengine.md)，[getReactiveMetrics](../g/getreactivemetrics.md)\n"
    },
    "addValuePartitions": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addValuePartitions.html",
        "signatures": [
            {
                "full": "addValuePartitions(dbHandle, newValues, [level=0], [locations])",
                "name": "addValuePartitions",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "newValues",
                        "name": "newValues"
                    },
                    {
                        "full": "[level=0]",
                        "name": "level",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[locations]",
                        "name": "locations",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [addValuePartitions](https://docs.dolphindb.cn/zh/funcs/a/addValuePartitions.html)\n\n\n\n#### 语法\n\naddValuePartitions(dbHandle, newValues, \\[level=0], \\[locations])\n\n#### 参数\n\n**dbHandle** 是数据库句柄。\n\n**newValues** 是标量或向量，表示新的分区。\n\n**level** 是整数。当分区类型为 COMPO，并且每层分区为 VALUE 时，需要使用 *level* 参数指定 VALUE 分区所在的层。它是可选参数。默认值为0\n\n**locations** 是字符串标量或向量。如果目标数据库创建时，指定了 *locations* 参数，增加新的分区时可以使用 *locations* 参数指定新增分区的位置。它是可选参数。\n\n#### 详情\n\n给数据库增加新的分区。目标数据库必须是 VALUE 分区类型或 COMPO 分区类型并且至少其中一层分区为 VALUE 类型。\n\n如果配置参数 *newValuePartitionPolicy*=add，系统会自动为新的数据增加分区。\n\n#### 例子\n\n下面的例子是给分区类型为 COMPO 的数据库新增2017.08.12到2017.08.20分区。\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndbID=database(, RANGE, 0 50 100);\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndb = database(\"dfs://compoDB\", COMPO, [dbID, dbDate]);\npt = db.createPartitionedTable(t, `pt, `ID`date)\npt.append!(t)\n\naddValuePartitions(db,2017.08.12..2017.08.20,1)\n// output\n9\n```\n\n添加新的分区后，需要重新加载数据库。\n\n```\ndb=database(\"dfs://compoDB\")\npt=loadTable(db,\"pt\")\n\nt1=table(0..99 as ID,take(2017.08.12,100) as date,rand(10.0,100) as x)\npt.append!(t1)\n\nselect count(*) from loadTable(\"dfs://compoDB\",\"pt\")\n// output\n1000100\n```\n"
    },
    "addVolumes": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/addVolumes.html",
        "signatures": [
            {
                "full": "addVolumes(volumes)",
                "name": "addVolumes",
                "parameters": [
                    {
                        "full": "volumes",
                        "name": "volumes"
                    }
                ]
            }
        ],
        "markdown": "### [addVolumes](https://docs.dolphindb.cn/zh/funcs/a/addVolumes.html)\n\n\n\n#### 语法\n\naddVolumes(volumes)\n\n#### 参数\n\n**volumes** 是字符串标量或向量，表示磁盘卷的路径。\n\n#### 详情\n\n动态增加磁盘卷，使新增磁盘卷马上可以使用而无需重启集群。\n\n**Note:** 此命令并不会改变集群配置文件。使用该命令后请更改配置文件，否则集群重启后将不能写入新增的磁盘卷。\n\n#### 例子\n\n```\naddVolumes(\"/home/dolphindb/data\")\n```\n"
    },
    "adfuller": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/adfuller.html",
        "signatures": [
            {
                "full": "adfuller(X, [maxLag], [regression=\"c\"], [autoLag=\"aic\"], [store=false], [regResults=false])",
                "name": "adfuller",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[maxLag]",
                        "name": "maxLag",
                        "optional": true
                    },
                    {
                        "full": "[regression=\"c\"]",
                        "name": "regression",
                        "optional": true,
                        "default": "\"c\""
                    },
                    {
                        "full": "[autoLag=\"aic\"]",
                        "name": "autoLag",
                        "optional": true,
                        "default": "\"aic\""
                    },
                    {
                        "full": "[store=false]",
                        "name": "store",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[regResults=false]",
                        "name": "regResults",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [adfuller](https://docs.dolphindb.cn/zh/funcs/a/adfuller.html)\n\n#### 语法\n\nadfuller(X, \\[maxLag], \\[regression=\"c\"], \\[autoLag=\"aic\"], \\[store=false], \\[regResults=false])\n\n#### 详情\n\n进行 Augmented Dickey-Fuller (ADF) 单位根检验。用于在序列相关性存在的情况下测试单变量过程中是否存在单位根。\n\n以字典的形式输出 ADF 检验的结果，字典包括以下内容：\n\n* adfStat：浮点数标量，表示检验的统计值\n* pValue：浮点数标量，表示 MacKinnon 近似 p 值\n* usedLag：整数标量，使用的滞后期的数值\n* nobs：整数标量，用于 ADF 回归和关键值计算的观测数量\n* criticalValues：字典，在 1％、5％ 和 10％ 水平上的检验统计量的临界值\n* icBest：浮点数标量，仅在 autoLag 不设置为\"max\" 时返回，表示最大化的信息准则\n* resultStore：字典，当 regResults 或者 store 设置为 true 时，把回归结果保存在 resultStore 中返回\n\n#### 参数\n\n**X**数值向量，表示需要进行单位根检验的时间序列数据。*X* 中的所有元素不能完全相同且不能包含空值。\n\n**maxLag**非负整数，指定检验中使用的最大滞后期，默认值为 12\\*(nobs/100)^(1/4)，其中 nobs 代表样本数量。\n\n**regression**字符串，指定在回归中使用的常数和趋势阶数。取值有如下选择：\n\n* \"c\"：默认值，表示只使用常数。\n* \"ct：使用常数和趋势。\n* \"ctt\"：使用常数、线性趋势和二次趋势。\n* \"n\"：不使用常数和趋势。\n\n**autoLag** 字符串，指定在 0\\~maxLag 中自动确定滞后期长度时使用的方法。取值有如下选择：\n\n* \"aic\"：默认值，表示使用 Akaike Information Criterion 来确定滞后期数值。\n* \"bic\"：表示使用 Bayesian information criterion 来确定滞后期数值。\n* \"tstat\"：将滞后期初始值设为 maxLag，然后逐步减 1，直到上一个滞后期数值的 t 统计量在 5% 显著性水平上显著。\n* \"max\"：将滞后期数值设置为 maxLag。\n\n**store**：布尔标量。设置为 true 时，除了返回 ADF 统计值，还会把回归结果放在一个字典中返回。默认值为 false。\n\n**regResults**：布尔值。设置为 true 时，返回完整的回归结果，相比于 *store*=true 的结果额外包含一个字典 autoLagResult，记录在自动滞后阶数选择过程中使用的信息准则的结果。默认值为 false。\n\n#### 例子\n\n```\ndata = 234 267 289 301 312 323 334 345 356 367\nadfuller(data);\n```\n\n输出为字典：\n\n```\npValue->0.000375626192024\nusedLag->0\nnobs->9\nicBest->-195.234657936244450\nadfStat->-4.341905848945339\ncriticalValues->[-4.473135048010974,-3.289880603566529,-2.772382345679012]\n```\n\n"
    },
    "align": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/align.html",
        "signatures": [
            {
                "full": "align(left, right, [how='outer'], [byRow], [view=true])",
                "name": "align",
                "parameters": [
                    {
                        "full": "left",
                        "name": "left"
                    },
                    {
                        "full": "right",
                        "name": "right"
                    },
                    {
                        "full": "[how='outer']",
                        "name": "how",
                        "optional": true,
                        "default": "'outer'"
                    },
                    {
                        "full": "[byRow]",
                        "name": "byRow",
                        "optional": true
                    },
                    {
                        "full": "[view=true]",
                        "name": "view",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [align](https://docs.dolphindb.cn/zh/funcs/a/align.html)\n\n\n\n#### 语法\n\nalign(left, right, \\[how='outer'], \\[byRow], \\[view=true])\n\n#### 参数\n\n**left/right**包含标签的矩阵/索引矩阵/索引序列。\n\n**how** 矩阵的对齐方法。通过将矩阵的行列标签进行 join 操作，来实现标签对齐。可选值为：'outer' (or 'fj'), 'inner' (or 'ej'), 'left' (or 'lj'), or 'asof ('aj')'，表示不同的连接方式。默认值是 'outer'，即外连接。\n\n**byRow** 布尔值或空值。若为 true，表示按行标签对齐；若为 false，表示按列标签对齐。默认为空值，表示同时按照行列标签对齐。此时，若行、列的连接方式相同，*how* 需指定一个连接方式；否则，*how* 需指定两个连接方式，格式为\"行对齐方式,列对齐方式\"，例如 *how*=\"outer,inner\"，逗号前后不能有空格或其他符号。\n\n**Note:**\n\n*left* 和 *right* 指定的矩阵必须包含 *byRow* 指定的对齐标签，且标签的数据类型需要兼容。目前支持以下类型的标签：整型、浮点型、时间类型、STRING 类型、SYMBOL 类型。其中 INT, SHORT, LONG, CHAR 互相兼容， FLOAT 和 DOUBLE 类型互相兼容，STRING 和 SYMBOL 类型也互相兼容。\n\n**view** 布尔值，默认值是 true，表示生成原矩阵的一个视图（浅拷贝），若原数据发生改变，视图的数据也会相应变化。若为 false，则生成一个新的矩阵（深拷贝）。\n\n#### 详情\n\n按照 *how* 指定的方法，将 *left* 和 *right* 根据 *byRow* 指定的行/列标签进行对齐。返回一个长度为2的元组，其元素分别为两个矩阵按标签对齐后的对象。\n\n**Note:**\n\n* 返回矩阵不保留输入矩阵的属性，如：输入索引矩阵，返回非索引矩阵。\n* 通过函数 `rename!` 设置普通矩阵的标签；通过 exec + pivot by 也会生成以 pivot by 指定列为标签的矩阵。\n\n#### 背景\n\n在 2.00.8 版本前，用户需要通过索引矩阵和索引序列来支持矩阵的对齐运算，其标签必须是严格递增的。索引矩阵和索引序列在进行二元运算时，系统会自动以 \"outer\" 方式进行对齐，然后进行运算。\n\n引入 `align` 函数后，标签矩阵的对齐功能得到拓展，使得矩阵对齐和运算更加灵活。对比之前的对齐方式，`align` 函数具有以下优势：\n\n* 支持普通的标签矩阵对齐，标签的单调性不再受限制；\n* 对齐的方法更加多样化。\n\n#### 例子\n\n```\n// 对齐包含重复标签的矩阵\nx1 = [09:00:00, 09:00:01, 09:00:03]\nx2 = [09:00:00, 09:00:03, 09:00:03, 09:00:04]\nm1 = matrix(1 2 3, 2 3 4, 3 4 5).rename!(x1)\nm2 = matrix(11 12 13, 12 13 14, 13 14 15, 14 15 16).rename!(x2)\na, b = align(m1, m2, 'fj', false);\na;\n```\n\n| 09:00:00 | 09:00:01 | 09:00:03 | 09:00:03 | 09:00:04 |\n| -------- | -------- | -------- | -------- | -------- |\n| 1        | 2        | 3        | 3        |          |\n| 2        | 3        | 4        | 4        |          |\n| 3        | 4        | 5        | 5        |          |\n\n```\nb;\n```\n\n| 09:00:00 | 09:00:01 | 09:00:03 | 09:00:03 | 09:00:04 |\n| -------- | -------- | -------- | -------- | -------- |\n| 11       |          | 12       | 13       | 14       |\n| 12       |          | 13       | 14       | 15       |\n| 13       |          | 14       | 15       | 16       |\n\n```\na+b;\n```\n\n| 09:00:00 | 09:00:01 | 09:00:03 | 09:00:03 | 09:00:04 |\n| -------- | -------- | -------- | -------- | -------- |\n| 12       |          | 15       | 16       |          |\n| 14       |          | 17       | 18       |          |\n| 16       |          | 19       | 20       |          |\n\n```\nm = align(m1, m2, 'aj', false);\nm[0];\n```\n\n| 09:00:00 | 09:00:01 | 09:00:03 |\n| -------- | -------- | -------- |\n| 1        | 2        | 3        |\n| 2        | 3        | 4        |\n| 3        | 4        | 5        |\n\n```\nm[1];\n```\n\n| 09:00:00 | 09:00:01 | 09:00:03 |\n| -------- | -------- | -------- |\n| 11       | 11       | 13       |\n| 12       | 12       | 14       |\n| 13       | 13       | 15       |\n\n```\n// 定义一个价格表 pt, 一个交易量的表 vt\ntimestamp = [09:00:00, 09:00:02, 09:00:03, 09:00:06, 09:00:08]\nid= ['st1', 'st2', 'st1', 'st1', 'st2']\nprice = [197.8, 197.5, 198.4, 198.6, 198.6]\npt = table(timestamp, id, price)\n\ntimestamp = [09:00:00, 09:00:01, 09:00:02, 09:00:05, 09:00:08]\nid = ['st1', 'st2', 'st2', 'st3', 'st2']\nvol = [200, 300, 150, 200, 180]\nvt = table(timestamp, id, vol)\n\n// 利用 pivot by 获取价格矩阵和交易量矩阵，pivot by 指定的列将作为矩阵的标签\nm1 = exec vol from vt pivot by timestamp, id\nm2 = exec price from pt pivot by timestamp, id\n\n// 使用 full join 对齐两个矩阵\nm = align(m1, m2, how='aj,fj')\n\n// 计算得到交易金额的矩阵\nre = m[0] * m[1]\nre;\n```\n\n| label    | st1   | st2   | st3 |\n| -------- | ----- | ----- | --- |\n| 09:00:00 | 39560 |       |     |\n| 09:00:01 |       |       |     |\n| 09:00:02 |       | 29625 |     |\n| 09:00:03 |       |       |     |\n| 09:00:05 |       |       |     |\n| 09:00:08 |       | 35748 |     |\n"
    },
    "all": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/all.html",
        "signatures": [
            {
                "full": "all(func, args...)",
                "name": "all",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [all](https://docs.dolphindb.cn/zh/funcs/ho_funcs/all.html)\n\n#### 语法\n\nall(func, args...)\n\n#### 详情\n\n把函数应用到参数的每一个元素。只要函数调用返回false，*all* 高阶函数就会停止执行，并返回false。如果所有的函数调用都返回true，*all* 高阶函数将返回true。\n\n如果args是一个矩阵，*all* 高阶函数将会按列执行；如果args是一个表格，它将会按行执行。\n\n#### 参数\n\n* **func** 是一个函数名。\n* **args** 是函数func的参数。它们可以是向量、矩阵或表。它们的数据形式可以不尽相同，但是长度必须相同，即向量中元素的个数，或矩阵中列的数量，或表中行的数量需要相同。\n\n#### 例子\n\n*all* 高阶函数用于向量。\n\n```\nx = 1 2 NULL 11 NULL 13 NULL 102 103;\ny = x cut 3;\ny;\n// output\n([1,2,],[11,,13],[,102,103])\n\nall(hasNull, y);\n// output\n1\n// 检查是否 [1,2,],[11,,13],[,102,103]都含有 NULL值\n\nx = 1 25 7 15 11 197 16 18 23;\ny = x cut 3;\ny;\n// output\n([1,25,7],[15,11,197],[16,18,23])\n\nall(in, 7 11 23, y);\n// output\n1\n// 检查是否 7在[1, 25, 7] 中, 11在[15,11,197] 中以及 23在[16,18,23]中。\n\nall(in, 7 8 23, y);\n// output\n0\n// 由于8不在[15, 11, 197]中，返回false\n\nall(lt, 1 2 3, 4 5 6);\n// output\n1\n// 检查是否 1<4, 2<5 以及3<6\n\nall(lt, 1 2 7, 4 5 6);\n// output\n0\n//返回false，因为7>6\n```\n\n*all* 高阶函数作用在矩阵上，按列遍历。\n\n```\nx=1..6$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nall(in, 1 4 5, x);\n// output\n1\n\nall(in, 1 2 5, x);\n// output\n0\n// 返回 false，因为2不在x的第二列中\n```\n\n*all* 高阶函数作用在表上，按行遍历。下例中，定义了一个名为 *varscompare* 的函数用于比较表中的两个变量。\n\n```\nx=table(1 2 3 as a, 4 5 6 as b);\nx;\n```\n\n| a | b |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\ndef varscompare(t):t.a<t.b;\nall(varscompare, x);\n// output\n1\n\ny=table(1 7 3 as a, 4 5 6 as b);\n// output\ny;\n```\n\n| a | b |\n| - | - |\n| 1 | 4 |\n| 7 | 5 |\n| 3 | 6 |\n\n```\nall(varscompare, y);\n// output\n0\n// 返回 false，因为7>5\n```\n\n"
    },
    "and": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/and.html",
        "signatures": [
            {
                "full": "and(X, Y)",
                "name": "and",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [and](https://docs.dolphindb.cn/zh/funcs/a/and.html)\n\n\n\n#### 语法\n\nand(X, Y) 或 X && Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量或矩阵。\n\n#### 详情\n\n对 *X* 和 *Y* 内的元素逐个进行逻辑与（logical AND）的运算并返回结果。\n\n#### 例子\n\n```\n1 && 3;\n// output\n1\n\nx=1 2 3\nx && 0\n// output\n[0,0,0]\n\nx=1 2 3\ny=0 1 0\nx && y\n// output\n[0,1,0]\n\nt=table(1 2 2 3 as id, 4 5 6 5 as value)\nt\n```\n\n| id | value |\n| -- | ----- |\n| 1  | 4     |\n| 2  | 5     |\n| 2  | 6     |\n| 3  | 5     |\n\n```\nselect id, value from t where id=2 and value=5;   // SQL query\n```\n\n| id | value |\n| -- | ----- |\n| 2  | 5     |\n\n相关函数：[or](https://docs.dolphindb.cn/zh/funcs/o/or.html), [not](https://docs.dolphindb.cn/zh/funcs/n/not.html)\n"
    },
    "anova": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/anova.html",
        "signatures": [
            {
                "full": "anova(X)",
                "name": "anova",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [anova](https://docs.dolphindb.cn/zh/funcs/a/anova.html)\n\n\n\n#### 语法\n\nanova(X)\n\n#### 参数\n\n**X** 是一个矩阵或所有列均为数值的表。\n\n#### 详情\n\n对 *X* 进行单因素方差分析（one-way ANOVA）。*X* 中的每一列都被视为一个单独的组。\n\n返回的结果是一个字典，包含以下 key 值：\n\n* pValue：p 值\n* fValue：F 统计量\n* ssBetween：组间平方和\n* dfBetween：组间自由度\n* ssWithin：组内平方和\n* dfWithin：组内自由度\n\n#### 例子\n\n```\na=300 287 301 400 211 399 412 312 390 412\nb=240 259 302 311 210 402 390 298 347 380\nc=210 230 213 210 220 208 290 300 201 201\nm=matrix(a,b,c)\nanova(m);\n\n// output\npValue->0.000515\nfValue->10.15459\nssBetween->70528.066667\ndfBetween->2\nssWithin->93763.4\ndfWithin->27\n```\n"
    },
    "any": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/any.html",
        "signatures": [
            {
                "full": "any(func, args...)",
                "name": "any",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [any](https://docs.dolphindb.cn/zh/funcs/ho_funcs/any.html)\n\n#### 语法\n\nany(func, args...)\n\n#### 详情\n\n把函数应用到参数的每一个元素。只要函数调用返回true，*any* 高阶函数就会停止执行，并返回true。如果所有的函数调用都返回false，*any* 高阶函数将返回false。\n\n如果args是一个矩阵，*any模* 板将会按列执行；如果args是一个表格，它将会按行执行。\n\n#### 参数\n\n* **func** 是一个函数名。\n* **args** 是函数F的参数。它们可以是向量、矩阵或表。它们的数据形式可以不尽相同，但是长度必须相同，即向量中元素的个数，或矩阵中列的数量，或表中行的数量必须相同。\n\n#### 例子\n\n*any* 高阶函数用于向量：\n\n```\nx = 1 2 3 11 12 13 NULL 102 103;\ny = x cut 3;\ny;\n// output\n([1,2,3],[11,12,13],[,102,103])\n\nany(hasNull, y);\n// output\n1\n// 检查是否 [1,2,],[11,,13],[,102,103]中任意一个含有 NULL值\n\nx=1 25 7 15 11 197 16 18 23;\ny=x cut 3;\ny;\n// output\n([1,25,7],[15,11,197],[16,18,23])\n\nany(in, 7 8 23, y);\n// output\n1\n// 返回true，因为虽然8不在[15, 11, 197]中, 但7在[1, 25, 7]中\n\nany(in, 8 20 19, y);\n// output\n0\n// 8不在[1, 25, 7]中，20不在[15, 11, 197]中并且19不在[16, 18, 23]中\n\nany(lt, 4 5 6, 1 2 3);\n// output\n0\n// 检查是否4<1, 5<2并且6<3\n\nany(<, 4 5 6, 1 7 3);\n// output\n1\n// 返回true，因为5<7\n```\n\n*any* 高阶函数用于矩阵，按列遍历。\n\n```\nx=1..6$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nany(in, 6 1 4, x);\n// output\n0\n\nany(in, 3 4 2, x);\n// output\n1\n// 返回 true，因为4在x的第二列中\n```\n\n*any* 高阶函数用于数据表，按行遍历。下例中，定义了一个名为 varscompare 的函数用于比较表中的两个变量。\n\n```\nx=table(1 2 3 as a, 4 5 6 as b);\nx;\n```\n\n| a | b |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\ndef varscompare(t): t.a>t.b;\nany(varscompare, x);\n// output\n0\n\ny=table(1 7 3 as a, 4 5 6 as b);\ny;\n```\n\n| a | b |\n| - | - |\n| 1 | 4 |\n| 7 | 5 |\n| 3 | 6 |\n\n```\nany(varscompare, y);\n// output\n1\n// 返回true，因为7>5\n```\n\n"
    },
    "append!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/append!.html",
        "signatures": [
            {
                "full": "append!(obj, newData)",
                "name": "append!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "newData",
                        "name": "newData"
                    }
                ]
            }
        ],
        "markdown": "### [append!](https://docs.dolphindb.cn/zh/funcs/a/append!.html)\n\n\n\n#### 语法\n\nappend!(obj, newData)\n\n别名：push!\n\n#### 详情\n\n将 *newData* 中的数据追加到 *obj*。在 DolphinDB 中，函数中的感叹号(!)表示直接修改数据本身（就地操作）。\n\n**Note:**\n\n1. 该函数不会检查两表中各列列名与顺序，只要两表中对应位置的列的数据类型一致，即可执行。如果两表中各列顺序有差别，该操作不会自动对齐各列。所以，对数据表进行 `append!` 操作时，请检查两表中各列列名与顺序，以免出错。绝大部分情况下两表中各列列名与顺序应当完全一致。\n2. 请注意：若数据库为分区，且分区列为字符串类型，则追加的分区列数据不能包含空格， “/t”。\n\n#### 参数\n\n**obj** 必须是本地变量：向量、元组、矩阵、表或集合。\n\n**newData** 可以是标量、向量、元组、表或集合。\n\n* 如果 *obj* 是向量，则 *newData* 必须是标量或向量、或元素类型与 *obj* 中元素类型一致的元组。结果是比 *obj* 更长的向量。\n* 如果 *obj* 是元组，则 *newData* 必须是标量、向量或元组。若 *newData* 为向量，则作为整体追加到元组；若 *newData* 为元组，当配置项 *appendTupleAsAWhole*=true 时，作为整体追加，*appendTupleAsAWhole*=wrong 时，将 *newData* 的每一个元素依次追加。\n* 如果 *obj* 是矩阵，则 *newData* 必须是长度为 *obj* 行数倍数的向量。结果是新的矩阵，行数和 *obj* 相同，具有更多的列数。\n* 如果 *obj* 是表，则 *newData* 必须是一个列数和 *obj* 相同的表。结果是和 *obj* 具有相同列数和列名的表，但行数比 *obj* 多。\n* 如果 *newData* 和 *obj* 的数据类型不同，`append!` 函数会尝试将 *newData* 转换为 *obj* 的数据类型。如果无法转换，将返回一个错误信息。\n\n#### 例子\n\n```\nx = 1 2 3\nx.append!(4)\nx\n// output\n[1,2,3,4]\nappend!(x, 5 6)\nx\n// output\n[1,2,3,4,5,6]\nx.append!(7.2)\nx\n// output\n[1,2,3,4,5,6,7]\n// 7.2 的数据类型从 DOUBLE 转化为 INT，所以值变为7\nx.append!(`XOM)\n// output\nIncompatible type. Expected: INT, Actual: STRING\n\nx=array(INT, 0, 10)\n// x 是一个空的向量\nx\n// output\n[]\nx.append!(1)\nx\n// output\n[]\nx=array(SYMBOL, 0, 100)\nappend!(x, `TEST)\nx\n// output\n[\"TEST\"]\n\nx=1..6$3:2\nx\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\nx.append!(7..12)\nx\n```\n\n| 0 | 1 | 2 | 3  |\n| - | - | - | -- |\n| 1 | 4 | 7 | 10 |\n| 2 | 5 | 8 | 11 |\n| 3 | 6 | 9 | 12 |\n\n```\nx=set(1 2 3 4)\nx.append!(6)\n// output\nx\nset(6,1,2,3,4)\n\nt1=table(1 2 3 as x, 4 5 6 as y)\nt2=table(1.1 2.2 3.3 as a, 4.4 5.5 6.6 as b)\nt1.append!(t2)\nt1\n```\n\n| x | y |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n| 1 | 4 |\n| 2 | 6 |\n| 3 | 7 |\n\n使用 `append!` 把数据添加到分布式表。下面的例子需要在集群中执行。相关配置可参考：[功能配置](https://docs.dolphindb.cn/zh/db_distr_comp/cfg/function_configuration.html)。\n\n```\nn=1000000\nt=table(rand(`IBM`MS`APPL`AMZN,n) as symbol, rand(10.0, n) as value)\ndb = database(\"dfs://rangedb_tradedata\", RANGE, `A`F`M`S`ZZZZ)\nTrades = db.createPartitionedTable(t, \"Trades\", \"symbol\")\n```\n\n上面的脚本根据表 t 的结构创建了空表 Trades。接着，把表 t 的数据追加到表 Trades 中。\n\n```\nTrades.append!(t)\nselect count(*) from Trades;\n\n// output\n1000000\n```\n\n把其他表的数据追加到表 Trades 中。\n\n```\nn=500000\nt1=table(rand(`FB`GE`MSFT,n) as symbol, rand(100.0, n) as value)\nTrades.append!(t1)\nselect count(*) from Trades\n\n// output\n1500000\n```\n\n配置项 *appendTupleAsAWhole* 的不同设置值将影响追加元组的行为。\n\n```\nx = (1,\"X\")\ny = (2,\"Y\")\nx.append!(y)\nprint(x)\n// 配置参数 appendTupleAsAWhole=true 时\n(1,\"X\",(2,\"Y\"))\n// 配置参数 appendTupleAsAWhole=false 时\n(1,\"X\",2,\"Y\")\n```\n"
    },
    "appendForJoin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/appendForJoin.html",
        "signatures": [
            {
                "full": "appendForJoin(engine, isLeftTable, data)",
                "name": "appendForJoin",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "isLeftTable",
                        "name": "isLeftTable"
                    },
                    {
                        "full": "data",
                        "name": "data"
                    }
                ]
            }
        ],
        "markdown": "### [appendForJoin](https://docs.dolphindb.cn/zh/funcs/a/appendForJoin.html)\n\n\n\n#### 语法\n\nappendForJoin(engine, isLeftTable, data)\n\n#### 参数\n\n**engine** 是流数据 join 引擎，即 [createAsofJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createAsofJoinEngine.html) 等函数返回的抽象表对象。目前支持以下 join 引擎:\n\n* createAsofJoinEngine\n* createEquiJoinEngine\n* createLookupJoinEngine\n* createWindowJoinEngine\n* createLeftSemiJoinEngine\n\n**isLeftTable** 布尔类型，插入左表还是右表。\n\n**data** 将要插入表中的数据。\n\n#### 详情\n\n将数据插入流数据 join 引擎中。\n\n**Note:** 使用订阅函数 [subscribeTable](https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html) 为流数据 join 引擎订阅数据时，*handler* 参数需要为 `appendForJoin`、[getLeftStream](https://docs.dolphindb.cn/zh/funcs/g/getLeftStream.html) 或 [getRightStream](https://docs.dolphindb.cn/zh/funcs/g/getRightStream.html) 函数。\n\n#### 例子\n\n```\nleftTable=table(1:0, `timestamp`sym`price, [TIMESTAMP, SYMBOL, DOUBLE])\nrightTable=table(1:0, `timestamp`sym`val, [TIMESTAMP, SYMBOL, DOUBLE])\noutput=table(100:0, `timestamp`sym`price`val`total, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE])\najEngine=createAsofJoinEngine(\"test1\", leftTable, rightTable, output, <[price, val, price*val]>, `sym, `timestamp, false, 7)\n\ntmp1=table(take(2012.01.01T00:00:00.000+[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) as timestamp, take(`AAPL, 10) join take(`IBM, 10) as sym, double(1..20) as price)\ntmp2=table(take(2012.01.01T00:00:00.000+[1, 2, 3, 4, 4, 4, 4, 4, 4, 4], 20) as timestamp, take(`AAPL, 10) join take(`IBM, 10) as sym, double(1..20) as val)\n\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.001))\nappendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.001))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.002))\nappendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.002))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.003))\nappendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.003))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.004))\nappendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.004))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.005))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.006))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.007))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.008))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.009))\nappendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.010))\n\nsleep(5000)\n```\n"
    },
    "appendForPrediction": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/appendforprediction.html",
        "signatures": [
            {
                "full": "appendForPrediction(engine, data)",
                "name": "appendForPrediction",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "data",
                        "name": "data"
                    }
                ]
            }
        ],
        "markdown": "### [appendForPrediction](https://docs.dolphindb.cn/zh/funcs/a/appendforprediction.html)\n\n\n\n#### 语法\n\nappendForPrediction(engine, data)\n\n#### 详情\n\n与函数 `createYieldCurveEngine` 结合使用，用于计算债券的预测值。\n\n#### 参数\n\n**engine** 字符串，表示用于预测的债券曲线拟合引擎名。\n\n**data** 表，表示进行预测的数据。注意：须与对应债券曲线拟合引擎中参数 *predictDummyTable* 的结构保持一致。\n\n#### 例子\n\n首先创建一个曲线拟合引擎。\n\n```\n//指定传入表结构、资产类型、拟合算法\ndummyTable = table(1:0, `symbol`sendingtime`askDirtyPrice1`bidDirtyPrice1`midDirtyPirce1`askyield1`bidyield1`midyield1`timetoMaturity`assetType`datasource`clearRate, \n                        [SYMBOL, TIMESTAMP,DECIMAL32(3),DECIMAL32(3),DECIMAL32(3),DECIMAL32(3),DECIMAL32(3),DECIMAL32(3),DOUBLE,INT,INT,STRING])\nassetType=[0,1,2]\nfitMethod=[<piecewiseLinFit(timetoMaturity, midyield1, 10)>,\n            <nss(timetoMaturity,bidyield1,\"ns\")>,\n            <piecewiseLinFit(timetoMaturity, askyield1, 5)>]\n//指定模型输出表\nmodelOutput=table(1:0, `time`assetType`dataSource`clearRate`model,\n                        [TIMESTAMP,INT,INT,SYMBOL,BLOB])\n\n//基于上述参数创建曲线拟合引擎\nengine = createYieldCurveEngine(name=\"test\", dummyTable=dummyTable,assetType=assetType,fitMethod=fitMethod,\n                                keyColumn=`assetType`dataSource`clearRate, modelOutput=modelOutput,\n                                frequency=10, fitAfterPredict=false)\n```\n\n然后进行预测。\n\n```\ndata = table(take(`a`b`c, 30) as  symbol, take(now(), 30) as time, decimal32(rand(10.0, 30),3) as p1,  decimal32(rand(10.0, 30),3) as p2,  decimal32(rand(10.0, 30),3) as p3, decimal32(rand(10.0, 30),3) as p4,  decimal32(rand(10.0, 30),3) as p5,  decimal32(rand(10.0, 30),3) as p6, (rand(10.0, 30)+10).sort() as timetoMaturity, take(0 1 2, 30) as assetType, take([1], 30) as datasource, take(\"1\", 30) as clearRate)\nappendForPrediction(engine, data) \n//Output: 30   \n```\n\n**相关函数**[createYieldCurveEngine](https://docs.dolphindb.cn/zh/funcs/c/createyieldcurveengine.html)\n"
    },
    "appendMsg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/appendMsg.html",
        "signatures": [
            {
                "full": "appendMsg(engine, msgBody, msgId)",
                "name": "appendMsg",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "msgBody",
                        "name": "msgBody"
                    },
                    {
                        "full": "msgId",
                        "name": "msgId"
                    }
                ]
            }
        ],
        "markdown": "### [appendMsg](https://docs.dolphindb.cn/zh/funcs/a/appendMsg.html)\n\n\n\n#### 语法\n\nappendMsg(engine, msgBody, msgId)\n\n#### 参数\n\n**engine** 是内置流数据引擎，即 [createReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createReactiveStateEngine.html) 等函数返回的抽象表对象。\n\n**msgBody** 是将要写入流数据引擎的消息。\n\n**msgId** 是写入数据之前，流数据引擎已接收到的最后一条消息的 ID。ID 从订阅发布的第一条消息开始计数。\n\n#### 详情\n\n当流数据引擎启用快照机制（snapshot）且未开启 RaftGroup 时，订阅函数 [subscribeTable](https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html) 的handler参数必须为 `appendMsg` 函数，将数据写入流数据引擎。\n\n#### 例子\n\n```\nshare streamTable(10000:0,`time`sym`price, [TIMESTAMP,SYMBOL,DOUBLE]) as trades\noutput1 =table(10000:0, `time`sym`avgPrice, [TIMESTAMP,SYMBOL,DOUBLE]);\n\nengine1 = createTimeSeriesEngine(name=`engine1, windowSize=100, step=50, metrics=<avg(price)>, dummyTable=trades, outputTable=output1, timeColumn=`time, keyColumn=`sym, snapshotDir=\"C:/DolphinDB/Data/snapshotDir\", snapshotIntervalInMsgCount=100)\nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=appendMsg{engine1}, msgAsTable=true, handlerNeedMsgId=true)\n\nn=500\ntimev=2021.03.12T15:00:00.000 + (1..n join 1..n)\nsymv = take(`A, n) join take(`B, n)\npricev = (100+cumsum(rand(1.0,n)-0.5)) join (200+cumsum(rand(1.0,n)-0.5))\nt=table(timev as time, symv as sym, pricev as price).sortBy!(`time)\ntrades.append!(t)\n\nselect * from output1\n```\n"
    },
    "appendTuple!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/appendTupel_.html",
        "signatures": [
            {
                "full": "appendTuple!(X, Y, [wholistic=false])",
                "name": "appendTuple!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[wholistic=false]",
                        "name": "wholistic",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [appendTuple!](https://docs.dolphindb.cn/zh/funcs/a/appendTupel_.html)\n\n\n\n#### 语法\n\nappendTuple!(X, Y, \\[wholistic=false])\n\n#### 参数\n\n**X** 是一个元组。\n\n**Y** 是一个元组。\n\n**wholistic** 是一个 bool 标量，默认值为 false。\n\n#### 详情\n\n将 *Y* 中的数据追加到 *X* 中。\n\n* 当 *wholistic* 为 true 时，将 *Y* 整体作为一个元素追加到 *X* 中\n* 当 *wholistic* 为 false 时，将 *Y* 中的每一个元素依次追加到 *X* 中\n* 当 *X* 是列式元组时，*Y* 中元素必须与 *X* 中元素类型一致，且 *wholistic* 只能为 false\n\n#### 例子\n\n```\nx = (1,\"X\")\ny = ([2,3],\"Y\")\nx.appendTuple!(y,true)\nprint(x)\n// output\n(1,\"X\",([2,3],\"Y\"))\n\nx.appendTuple!(y,false)\nprint(x)\n// output\n(1,\"X\",([2,3],\"Y\"),[2,3],\"Y\")\n\nx = [[1,2,3],4]\nx.setColumnarTuple!()\nx.appendTuple!((5,6),false)\nprint(x)\n([1,2,3],4,5,6)\n```\n"
    },
    "array": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/array.html",
        "signatures": [
            {
                "full": "array(dataType|template, [initialSize], [capacity], [defaultValue])",
                "name": "array",
                "parameters": [
                    {
                        "full": "dataType|template",
                        "name": "dataType|template"
                    },
                    {
                        "full": "[initialSize]",
                        "name": "initialSize",
                        "optional": true
                    },
                    {
                        "full": "[capacity]",
                        "name": "capacity",
                        "optional": true
                    },
                    {
                        "full": "[defaultValue]",
                        "name": "defaultValue",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [array](https://docs.dolphindb.cn/zh/funcs/a/array.html)\n\n\n\n#### 语法\n\narray(dataType|template, \\[initialSize], \\[capacity], \\[defaultValue])\n\n#### 参数\n\n**dataType** 是向量的数据类型。\n\n**template** 是一个已有向量。这个已有向量的数据类型决定了新向量的数据类型。\n\n**initialSize** 是正整数，表示向量的初始长度，即该向量新建时的元素数量。\n\n**capacity** 是正整数，表示向量的容量，即该向量新建时系统为该向量分配的内存（以元素数为单位）。当元素数超过capacity时，系统会自动扩充容量。系统首先会分配当前容量1.2\\~2倍的内存，然后复制数据到新的内存空间，最后释放原来的内存。\n\n**defaultValue** 是向量的默认值。若指定，则只能是标量。若不指定：对于多数数据类型，默认值是 0；对于字符串和符号（Symbol），默认值是 NULL。\n\n#### 详情\n\n返回一个向量。\n\n#### 例子\n\n```\nx=array(INT, 10, 100, 1)\n// 初始长度是 10；容量是 100；默认值是 1。\nx\n// output\n[1,1,1,1,1,1,1,1,1,1]\n\nx=array(INT, 0)\n// 初始化一个空向量\nx\n// output\n[]\nx.append!(1..10)\n// output\n[1,2,3,4,5,6,7,8,9,10]\n\ny=array(x)\ny\n// output\n[0,0,0,0,0,0,0,0,0,0]\n\nsyms=array(SYMBOL, 0, 100)\n// 一个空的符号向量，容量是 100.\ntypestr syms\n// output\nFAST SYMBOL VECTOR\n```\n"
    },
    "arrayVector": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/arrayVector.html",
        "signatures": [
            {
                "full": "arrayVector(index, value)",
                "name": "arrayVector",
                "parameters": [
                    {
                        "full": "index",
                        "name": "index"
                    },
                    {
                        "full": "value",
                        "name": "value"
                    }
                ]
            }
        ],
        "markdown": "### [arrayVector](https://docs.dolphindb.cn/zh/funcs/a/arrayVector.html)\n\n\n\n#### 语法\n\narrayVector(index, value)\n\n#### 参数\n\n**index** 是一个严格单调递增的正整型向量。\n\n**value** 是一个向量。其元素类型必须是 `arrayVector` 支持的类型。\n\n#### 详情\n\n根据 *index* 中的元素对 *value* 进行分割，将 *value* 转换为一个数组向量。*index* 中元素的个数表示转换后数组向量的行数；*index* 中的每个元素值， 代表数组向量中，每行向量的最后一个元素对应原本 *value* 中的位置（从1开始编号）。如下图所示：\n\n![](https://docs.dolphindb.cn/zh/images/arrayVector01.png \"Index\")\n\n**Note:** *index* 中元素的最大值不能超过 *value* 的长度。\n\n#### 例子\n\n```\narrayVector(2 3 4, [1,2,3,4])\n\n[[1,2],[3],[4]]\n\narrayVector(1 4 7, [1.0,2.1,4.1,6.8,0.5,2.2,2])\n\n[[1],[2.1,4.1,6.8],[0.5,2.2,2]]\n\nvalue = 2022.01.01 + 0..20\nindex = 7 14 21\narrayVector(index, value)\n\n[[2022.01.01,2022.01.02,2022.01.03,2022.01.04,2022.01.05,2022.01.06,2022.01.07],[2022.01.08,2022.01.09,2022.01.10,2022.01.11,2022.01.12,2022.01.13,2022.01.14],[2022.01.15,2022.01.16,2022.01.17,2022.01.18,2022.01.19,2022.01.20,2022.01.21]]\n```\n\n相关函数：[fixedLengthArrayVector](https://docs.dolphindb.cn/zh/funcs/f/fixedLengthArrayVector.html)\n"
    },
    "asFreq": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/asFreq.html",
        "signatures": [
            {
                "full": "asFreq(X, rule, [closed], [label], [origin='start_day'])",
                "name": "asFreq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "rule",
                        "name": "rule"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    },
                    {
                        "full": "[label]",
                        "name": "label",
                        "optional": true
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    }
                ]
            }
        ],
        "markdown": "### [asFreq](https://docs.dolphindb.cn/zh/funcs/a/asFreq.html)\n\n\n\n#### 语法\n\nasFreq(X, rule, \\[closed], \\[label], \\[origin='start\\_day'])\n\n#### 详情\n\n转换给定数据的时间频率。与 [resample](https://docs.dolphindb.cn/zh/funcs/r/resample.html) 函数不同，该函数不可使用聚合函数对数据进行处理。\n\n#### 参数\n\n**X** 是有时间类型索引的矩阵（由 `setIndexedMatrix!` 创建）或序列（由 `setIndexedSeries!` 创建）。\n\n**rule** 可以是一个字符串，可取以下值，亦可为一个时间类型的向量。\n\n| Y 参数取值 | 对应 DolphinDB 函数      |\n| ------ | -------------------- |\n| \"B\"    | businessDay          |\n| \"W\"    | weekEnd              |\n| \"WOM\"  | weekOfMonth          |\n| \"LWOM\" | lastWeekOfMonth      |\n| \"M\"    | monthEnd             |\n| \"MS\"   | monthBegin           |\n| \"BM\"   | businessMonthEnd     |\n| \"BMS\"  | businessMonthBegin   |\n| \"SM\"   | semiMonthEnd         |\n| \"SMS\"  | semiMonthBegin       |\n| \"Q\"    | quarterEnd           |\n| \"QS\"   | quarterBegin         |\n| \"BQ\"   | businessQuarterEnd   |\n| \"BQS\"  | businessQuarterBegin |\n| \"REQ\"  | fy5253Quarter        |\n| \"A\"    | yearEnd              |\n| \"AS\"   | yearBegin            |\n| \"BA\"   | businessYearEnd      |\n| \"BAS\"  | businessYearBegin    |\n| \"RE\"   | fy5253               |\n| \"D\"    | date                 |\n| \"H\"    | hourOfDay            |\n| \"min\"  | minuteOfHour         |\n| \"S\"    | secondOfMinute       |\n| \"L\"    | millisecond          |\n| \"U\"    | microsecond          |\n| \"N\"    | nanosecond           |\n\n上述字符串亦可配合使用数字（必须为正整数），例如 \"2M\" 表示频率为每两个月月末。此外，*rule* 也可以是交易日历标识（国外交易所的 ISO Code、国内交易所简称或自定义交易日历名称），以便基于交易日历进行计算。交易日历也可以配合使用数字，表示多个交易日，此时只能指定由4个大写字母组成的交易日历标识。例如：“2XSHG”，表示上海证券交易所每两个交易日。\n\n**closed** 字符串，表示分组区间哪一个边界是闭合的。\n\n* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，*closed* 的默认取值为 'right' ，否则，*closed* 的默认取值为 'left'。\n* *origin* 取 'end' 或者 'end\\_day' 时，*closed* 的默认值为 'right'。\n\n**label** 字符串，表示将分组区间的哪一个边界作为 *label* 输出。\n\n* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，*label* 的默认取值为 'right' ，否则，*label* 的默认取值为 'left'。\n* *origin* 取 'end' 或者 'end\\_day' 时，*label* 的默认值为 'right'。\n\n**origin** 字符串或和 *X* 具有相同时间类型的标量，表示基于时间戳调整分组。取值为 'epoch', start', 'start\\_day', 'end', 'end\\_day' 或自定义的时间对象，默认值为 'start\\_day'。\n\n* 'epoch'：分组起始点为1970-01-01。\n* 'start'：分组起始点为时间序列的第一个值。\n* 'start\\_day'：分组起始点是时间序列的第一个值对应日期的午夜零点。\n* 'end'：分组起始点是时间序列的最后一个时间戳。\n* 'end\\_day'：分组起始点是时间序列的最后一个时间戳对应日期的午夜24点（即下一日的零点）。\n\n#### 例子\n\n```\nindex = [2000.01.01, 2000.01.31, 2000.02.15, 2000.02.20, 2000.03.31, 2000.04.16, 2000.05.06, 2000.08.31]\ns = indexedSeries(index, 1..8)\ns\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.01 | 1 |\n| 2000.01.31 | 2 |\n| 2000.02.15 | 3 |\n| 2000.02.20 | 4 |\n| 2000.03.31 | 5 |\n| 2000.04.16 | 6 |\n| 2000.05.06 | 7 |\n| 2000.08.31 | 8 |\n\n```\ns.asFreq(\"M\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.31 | 2 |\n| 2000.02.29 |   |\n| 2000.03.31 | 5 |\n| 2000.04.30 |   |\n| 2000.05.31 |   |\n| 2000.06.30 |   |\n| 2000.07.31 |   |\n| 2000.08.31 | 8 |\n\n```\ns.asFreq(\"2M\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.31 | 2 |\n| 2000.03.31 | 5 |\n| 2000.05.31 |   |\n| 2000.07.31 |   |\n\n```\nindex = [2020.01.01, 2020.01.03, 2020.01.06]\ns = indexedSeries(index, 1..3)\ns\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.03 | 2 |\n| 2020.01.06 | 3 |\n\n```\ns.asFreq(\"D\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.02 |   |\n| 2020.01.03 | 2 |\n| 2020.01.04 |   |\n| 2020.01.05 |   |\n| 2020.01.06 | 3 |\n\n```\ns.asFreq(\"2D\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.03 | 2 |\n| 2020.01.05 |   |\n\n```\nindex = temporalAdd(2022.10.01 23:30:00,7*(0..8),`m)\ns = indexedSeries(index, 3*(0..8))\ns.asFreq(\"8min\")\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:28:00 |      |\n| 2022.10.01T23:36:00 |      |\n| 2022.10.01T23:44:00 | 6    |\n| 2022.10.01T23:52:00 |      |\n| 2022.10.02T00:00:00 |      |\n| 2022.10.02T00:08:00 |      |\n| 2022.10.02T00:16:00 |      |\n| 2022.10.02T00:24:00 |      |\n\n```\ns.asFreq(rule=`8min,closed=`right)\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:36:00 |      |\n| 2022.10.01T23:44:00 | 6    |\n| 2022.10.01T23:52:00 |      |\n| 2022.10.02T00:00:00 |      |\n| 2022.10.02T00:08:00 |      |\n| 2022.10.02T00:16:00 |      |\n| 2022.10.02T00:24:00 |      |\n| 2022.10.02T00:32:00 |      |\n\n```\ns.asFreq(rule=`8min,closed=`right,origin=`end)\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:30:00 | 0    |\n| 2022.10.01T23:38:00 |      |\n| 2022.10.01T23:46:00 |      |\n| 2022.10.01T23:54:00 |      |\n| 2022.10.02T00:02:00 |      |\n| 2022.10.02T00:10:00 |      |\n| 2022.10.02T00:18:00 |      |\n| 2022.10.02T00:26:00 | 24   |\n"
    },
    "asfreq": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/asfreq1.html",
        "signatures": [
            {
                "full": "asFreq(X, rule, [closed], [label], [origin='start_day'])",
                "name": "asFreq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "rule",
                        "name": "rule"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    },
                    {
                        "full": "[label]",
                        "name": "label",
                        "optional": true
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    }
                ]
            }
        ],
        "markdown": "### [asfreq](https://docs.dolphindb.cn/zh/funcs/a/asfreq1.html)\n\n是 [asFreq](https://docs.dolphindb.cn/zh/funcs/a/asFreq.html) 的别名。\n\n\n以下是 `asFreq` 函数的文档：\n### [asFreq](https://docs.dolphindb.cn/zh/funcs/a/asFreq.html)\n\n\n\n#### 语法\n\nasFreq(X, rule, \\[closed], \\[label], \\[origin='start\\_day'])\n\n#### 详情\n\n转换给定数据的时间频率。与 [resample](https://docs.dolphindb.cn/zh/funcs/r/resample.html) 函数不同，该函数不可使用聚合函数对数据进行处理。\n\n#### 参数\n\n**X** 是有时间类型索引的矩阵（由 `setIndexedMatrix!` 创建）或序列（由 `setIndexedSeries!` 创建）。\n\n**rule** 可以是一个字符串，可取以下值，亦可为一个时间类型的向量。\n\n| Y 参数取值 | 对应 DolphinDB 函数      |\n| ------ | -------------------- |\n| \"B\"    | businessDay          |\n| \"W\"    | weekEnd              |\n| \"WOM\"  | weekOfMonth          |\n| \"LWOM\" | lastWeekOfMonth      |\n| \"M\"    | monthEnd             |\n| \"MS\"   | monthBegin           |\n| \"BM\"   | businessMonthEnd     |\n| \"BMS\"  | businessMonthBegin   |\n| \"SM\"   | semiMonthEnd         |\n| \"SMS\"  | semiMonthBegin       |\n| \"Q\"    | quarterEnd           |\n| \"QS\"   | quarterBegin         |\n| \"BQ\"   | businessQuarterEnd   |\n| \"BQS\"  | businessQuarterBegin |\n| \"REQ\"  | fy5253Quarter        |\n| \"A\"    | yearEnd              |\n| \"AS\"   | yearBegin            |\n| \"BA\"   | businessYearEnd      |\n| \"BAS\"  | businessYearBegin    |\n| \"RE\"   | fy5253               |\n| \"D\"    | date                 |\n| \"H\"    | hourOfDay            |\n| \"min\"  | minuteOfHour         |\n| \"S\"    | secondOfMinute       |\n| \"L\"    | millisecond          |\n| \"U\"    | microsecond          |\n| \"N\"    | nanosecond           |\n\n上述字符串亦可配合使用数字（必须为正整数），例如 \"2M\" 表示频率为每两个月月末。此外，*rule* 也可以是交易日历标识（国外交易所的 ISO Code、国内交易所简称或自定义交易日历名称），以便基于交易日历进行计算。交易日历也可以配合使用数字，表示多个交易日，此时只能指定由4个大写字母组成的交易日历标识。例如：“2XSHG”，表示上海证券交易所每两个交易日。\n\n**closed** 字符串，表示分组区间哪一个边界是闭合的。\n\n* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，*closed* 的默认取值为 'right' ，否则，*closed* 的默认取值为 'left'。\n* *origin* 取 'end' 或者 'end\\_day' 时，*closed* 的默认值为 'right'。\n\n**label** 字符串，表示将分组区间的哪一个边界作为 *label* 输出。\n\n* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，*label* 的默认取值为 'right' ，否则，*label* 的默认取值为 'left'。\n* *origin* 取 'end' 或者 'end\\_day' 时，*label* 的默认值为 'right'。\n\n**origin** 字符串或和 *X* 具有相同时间类型的标量，表示基于时间戳调整分组。取值为 'epoch', start', 'start\\_day', 'end', 'end\\_day' 或自定义的时间对象，默认值为 'start\\_day'。\n\n* 'epoch'：分组起始点为1970-01-01。\n* 'start'：分组起始点为时间序列的第一个值。\n* 'start\\_day'：分组起始点是时间序列的第一个值对应日期的午夜零点。\n* 'end'：分组起始点是时间序列的最后一个时间戳。\n* 'end\\_day'：分组起始点是时间序列的最后一个时间戳对应日期的午夜24点（即下一日的零点）。\n\n#### 例子\n\n```\nindex = [2000.01.01, 2000.01.31, 2000.02.15, 2000.02.20, 2000.03.31, 2000.04.16, 2000.05.06, 2000.08.31]\ns = indexedSeries(index, 1..8)\ns\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.01 | 1 |\n| 2000.01.31 | 2 |\n| 2000.02.15 | 3 |\n| 2000.02.20 | 4 |\n| 2000.03.31 | 5 |\n| 2000.04.16 | 6 |\n| 2000.05.06 | 7 |\n| 2000.08.31 | 8 |\n\n```\ns.asFreq(\"M\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.31 | 2 |\n| 2000.02.29 |   |\n| 2000.03.31 | 5 |\n| 2000.04.30 |   |\n| 2000.05.31 |   |\n| 2000.06.30 |   |\n| 2000.07.31 |   |\n| 2000.08.31 | 8 |\n\n```\ns.asFreq(\"2M\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2000.01.31 | 2 |\n| 2000.03.31 | 5 |\n| 2000.05.31 |   |\n| 2000.07.31 |   |\n\n```\nindex = [2020.01.01, 2020.01.03, 2020.01.06]\ns = indexedSeries(index, 1..3)\ns\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.03 | 2 |\n| 2020.01.06 | 3 |\n\n```\ns.asFreq(\"D\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.02 |   |\n| 2020.01.03 | 2 |\n| 2020.01.04 |   |\n| 2020.01.05 |   |\n| 2020.01.06 | 3 |\n\n```\ns.asFreq(\"2D\")\n```\n\n| lable      | 0 |\n| ---------- | - |\n| 2020.01.01 | 1 |\n| 2020.01.03 | 2 |\n| 2020.01.05 |   |\n\n```\nindex = temporalAdd(2022.10.01 23:30:00,7*(0..8),`m)\ns = indexedSeries(index, 3*(0..8))\ns.asFreq(\"8min\")\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:28:00 |      |\n| 2022.10.01T23:36:00 |      |\n| 2022.10.01T23:44:00 | 6    |\n| 2022.10.01T23:52:00 |      |\n| 2022.10.02T00:00:00 |      |\n| 2022.10.02T00:08:00 |      |\n| 2022.10.02T00:16:00 |      |\n| 2022.10.02T00:24:00 |      |\n\n```\ns.asFreq(rule=`8min,closed=`right)\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:36:00 |      |\n| 2022.10.01T23:44:00 | 6    |\n| 2022.10.01T23:52:00 |      |\n| 2022.10.02T00:00:00 |      |\n| 2022.10.02T00:08:00 |      |\n| 2022.10.02T00:16:00 |      |\n| 2022.10.02T00:24:00 |      |\n| 2022.10.02T00:32:00 |      |\n\n```\ns.asFreq(rule=`8min,closed=`right,origin=`end)\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.10.01T23:30:00 | 0    |\n| 2022.10.01T23:38:00 |      |\n| 2022.10.01T23:46:00 |      |\n| 2022.10.01T23:54:00 |      |\n| 2022.10.02T00:02:00 |      |\n| 2022.10.02T00:10:00 |      |\n| 2022.10.02T00:18:00 |      |\n| 2022.10.02T00:26:00 | 24   |\n"
    },
    "asin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/asin.html",
        "signatures": [
            {
                "full": "asin(X)",
                "name": "asin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html)\n\n\n\n#### 语法\n\nasin(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 的反正弦。\n\n#### 例子\n\n```\nasin(0 0.5 1);\n// output\n[0,0.523599,1.570796]\n```\n\n相关函数：[acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html), [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html), [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html), [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html), [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html), [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html), [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html), [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html), [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html), [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html), [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n"
    },
    "asinh": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/asinh.html",
        "signatures": [
            {
                "full": "asinh(X)",
                "name": "asinh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html)\n\n\n\n#### 语法\n\nasinh(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 的反双曲正弦。\n\n#### 例子\n\n```\nasinh(0.841471 0.909297 0.141120);\n// output\n[0.764725,0.815761,0.140656]\n```\n\n相关函数：[asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html), [acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html), [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html), [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html), [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html), [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html), [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html), [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html), [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html), [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html), [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n"
    },
    "asis": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/asIs.html",
        "signatures": [
            {
                "full": "asis(X)",
                "name": "asis",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [asis](https://docs.dolphindb.cn/zh/funcs/a/asIs.html)\n\n\n\n#### 语法\n\nasis(X)\n\n#### 参数\n\n**X** 可以是任意数据类型。\n\n#### 详情\n\n返回 *X* 的浅拷贝。\n\n#### 例子\n\n```\na = 1 2 3\nb = asis(a)\na[0] = 0\nb\n// output\n[0, 2, 3]\nb[1] = 4\n// output\na;\n[0, 4, 3]\n```\n\n相关函数：[copy](https://docs.dolphindb.cn/zh/funcs/c/copy.html)\n"
    },
    "asof": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/asof.html",
        "signatures": [
            {
                "full": "asof(X, Y)",
                "name": "asof",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [asof](https://docs.dolphindb.cn/zh/funcs/a/asof.html)\n\n\n\n#### 语法\n\nasof(X, Y)\n\n#### 参数\n\n**X** 必须是一个递增的向量、索引序列、索引矩阵；\n\n**Y** 可以是标量、向量、数组向量、元组、矩阵、字典、表。\n\n#### 详情\n\n对于每个 *Y* 中的元素 y，`asof` 返回 *X* 中不大于 y 的元素的最大序号（从 0 开始编号）。如果没有找到，则返回-1。\n\n#### 例子\n\n```\nasof(1..100, 60 200 -10)\n// output\n[59,99,-1]\n\n0 0 0 1 1 1 1 2 2 3 asof 1\n// output\n6\n```\n"
    },
    "at": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/at.html",
        "signatures": [
            {
                "full": "at(X, [index])",
                "name": "at",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[index]",
                        "name": "index",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [at](https://docs.dolphindb.cn/zh/funcs/a/at.html)\n\n#### 语法\n\nat(X, \\[index])\n\n#### 参数\n\n如果只指定了一个参数，***X*** 是布尔表达式或向量。\n\n如果指定了两个参数：\n\n***X***可以是一个标量、向量（常规向量/元组/数组向量)、矩阵、表、字典、数据对、函数。\n\n***index*** 可以是一个布尔表达式/布尔值、标量、向量（常规向量/元组/数组向量)、数据对。\n\n#### 详情\n\n* 在第一种情况下，函数返回 *X* 中结果为 true 的元素位置。\n* 在第二种情况下:\n  * 如果 *index* 是布尔表达式，`at` 函数返回 *X* 中 *index* 为 true 的位置的元素。 `at` 函数等价于中括号运算符 \\[]。 比如，`X.at(X>3)` 和 `X[X>3]` 相同。\n  * 如果 *index* 是向量，以向量中的值作为索引值，寻找 *X* 中该索引位置的值并返回。\n  * 若 *X* 是函数，*index* 为元组，则 *index* 中每一个元素均作为 *X* 的参数使用。\n  * 如果 *index* 是数据对，如 a:b, 则表示索引范围为 \\[a,b)，寻找 *X* 中该范围的值并返回。\n  * 如果 *index* 是数组向量，对于 *index* 中的每行元素都作为一个索引值，寻找 *X* 中对应该索引位置的元素，然后返回一个和 *index* 结构相同的数组向量。\n\n**Note:**\n\n* *index* 作为索引值或索引范围时，若其值不在 \\[0, size(*X*) - 1] 内，则超出 \\[0, size(*X*) - 1] 的值所对应的位置返回空值。\n* 若 *X* 是函数， *index* 为元组，则 index 中每一个元素均作为 X 的参数适用。\n\n#### 例子\n\n```\nx=5 7 0 4 2 3\nat(x>3)\n//output：[0, 1, 3]\n// 在位置 0, 1 和 3，x>3 为 true\n\n// 和 x>3 相比\nx>3;\n//output：[1, 1, 0, 1, 0, 0]\n\nx[x>3]\n//output：[5, 7, 4]\n\nx at x>3\n//output：[5, 7, 4]\n\nx=5 7 0 0 0 3\nat(x==0)\n//output：[2, 3, 4]\n\nx[x==0]\n//output：[0, 0, 0]\n\nshares=500 1000 1000 600 2000\nprices=25.5 97.5  19.2 38.4 101.5\nprices[shares>800]\n//output：[97.5, 19.2, 101.5]\n\nprices at shares>800\n//output: [97.5, 19.2, 101.5]\n```\n\n```\nm=(1..6).reshape(2:3)\nm;\n```\n\n| 0 | 1 | 2 |\n| - | - | - |\n| 1 | 3 | 5 |\n| 2 | 4 | 6 |\n\n```\nat(m>3)\n//output：[3,4,5]\n\nm[m>3] // 等价于 m at m>3\n```\n\n返回：\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n|      |      | 5    |\n|      | 4    | 6    |\n\n注意区分 *index* 是向量和元组的两种不同场景：\n\n```\nm at [0,2]  // 选择第 0 列和第 2 列\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 5 |\n| 2 | 6 |\n\n```\nm at (0,2) // 查找特定行列的元素\n//output: 5\n```\n\n```\nm at 0:2 // 选择第 0 列和第 1 列\n```\n\n返回：\n\n| 0 | 1 |\n| - | - |\n| 1 | 3 |\n| 2 | 4 |\n\n*index* 是数组向量的情况：\n\n```\na = array(INT[], 0, 10).append!([0 2 3, 0 5, 0 8 8, 9 10])\nb =[1, 2, 3]\nat(b, a)\n//output: [[1,3, ], [1, ], [1, , ], [ , ]]\n\nat(a,a>3)\n//output: [,[5],[8,8],[9,10]]\n```\n\n下例中，score 是一个简单元组，包含 2 个元素，60 和 70。第二行中，`at` 函数使用 `add` 函数作为 *X*，将 score 中的每个元素作为 `add` 的入参，并将 `at` 的计算结果赋予 result。\n\n```\nscore = (60, 70);\nresult = at(add,score)\nprint result\n\n//output: 130\n```\n\n"
    },
    "atan": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/atan.html",
        "signatures": [
            {
                "full": "atan(X)",
                "name": "atan",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html)\n\n\n\n#### 语法\n\natan(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 的反正切。\n\n#### 例子\n\n```\natan 0.000000 1.557408 -2.185040;\n// output\n[0,1,-1.141593]\n```\n\n相关函数：[asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html), [acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html), [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html), [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html), [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html), [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html), [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html), [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html), [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html), [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html), [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n"
    },
    "atanh": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/atanh.html",
        "signatures": [
            {
                "full": "atanh(X)",
                "name": "atanh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html)\n\n\n\n#### 语法\n\natanh(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 的反双曲正切。\n\n#### 例子\n\n```\natanh 0.000000 0.557408 -0.185040;\n// output\n[0,0.629065,-0.187196]\n```\n\n相关函数：[asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html), [acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html), [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html), [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html), [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html), [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html), [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html), [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html), [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html), [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html), [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n"
    },
    "atImax": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/atImax.html",
        "signatures": [
            {
                "full": "atImax(location, value)",
                "name": "atImax",
                "parameters": [
                    {
                        "full": "location",
                        "name": "location"
                    },
                    {
                        "full": "value",
                        "name": "value"
                    }
                ]
            }
        ],
        "markdown": "### [atImax](https://docs.dolphindb.cn/zh/funcs/a/atImax.html)\n\n\n\n#### 语法\n\natImax(location, value)\n\n#### 参数\n\n**location** 和 **value** 是向量、矩阵或表。\n\n#### 详情\n\n找出 *location* 中最大值所在的位置，然后返回 *value* 中该位置对应的值。如果 *location* 中有多个相同的最大值，则取第一个最大值所在的位置。\n\n若 *location* 和 *value* 是矩阵，则 *location* 和 *value* 的每列一一对应，分别计算 `atImax`。\n\natImax(location, value) 相当于 value\\[imax(location)]。\n\n#### 例子\n\n```\natImax(3 5 1 2, 9 7 5 3)\n// output\n7\n\nm1=matrix(9 2 1 5 6 9, 3 1 3 NULL 5 2, 2 8 1 2 3 4)\nm2=matrix(1..6, 1..6, 1..6)\natImax(m1,m2)\n// output\n[1,5,2]\n```\n\n相关函数：[imax](https://docs.dolphindb.cn/zh/funcs/i/imax.html), [atImin](https://docs.dolphindb.cn/zh/funcs/a/atImin.html)\n"
    },
    "atImin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/atImin.html",
        "signatures": [
            {
                "full": "atImin(location, value)",
                "name": "atImin",
                "parameters": [
                    {
                        "full": "location",
                        "name": "location"
                    },
                    {
                        "full": "value",
                        "name": "value"
                    }
                ]
            }
        ],
        "markdown": "### [atImin](https://docs.dolphindb.cn/zh/funcs/a/atImin.html)\n\n\n\n#### 语法\n\natImin(location, value)\n\n#### 参数\n\n**location** 和 **value** 是向量、矩阵或表。\n\n#### 详情\n\n找出 *location* 中最小值所在的位置，然后返回 *value* 中该位置对应的值。如果 *location* 中有多个相同的最小值，则取第一个最小值所在的位置。\n\n若 *location* 和 *value* 是矩阵，则 *location* 和 *value* 的每列一一对应，分别计算 `atImin`。\n\natImin(location, value) 相当于 value\\[imin(location)]。\n\n#### 例子\n\n```\natImin(3 5 1 2, 9 7 5 3)\n// output\n5\n\nm1=matrix(9 2 1 5 6 9, 3 1 3 NULL 5 2, 2 8 1 2 3 4)\nm2=matrix(1..6, 1..6, 1..6)\natImin(m1,m2)\n// output\n[3,2,3]\n```\n\n相关函数：[imin](https://docs.dolphindb.cn/zh/funcs/i/imin.html), [atImax](https://docs.dolphindb.cn/zh/funcs/a/atImax.html)\n"
    },
    "autocorr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/autocorr.html",
        "signatures": [
            {
                "full": "autocorr(X, lag)",
                "name": "autocorr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "lag",
                        "name": "lag"
                    }
                ]
            }
        ],
        "markdown": "### [autocorr](https://docs.dolphindb.cn/zh/funcs/a/autocorr.html)\n\n\n\n#### 语法\n\nautocorr(X, lag)\n\n#### 参数\n\n**X** 是一个向量。\n\n**lag** 是一个正整数。\n\n#### 详情\n\n计算 *X* 的 *lag* 阶自相关系数。请注意，计算时两个时间序列所用的均值均为 *X*的均值，而非两个时间序列各自的均值。\n\n#### 例子\n\n```\nn=10000\nx=array(DOUBLE, n, n, NULL)\nx[0]=1\nr=rand(0.05, n)-0.025\nfor(i in 0:(n-1)){\n    x[i+1]=-0.8*x[i]+r[i]\n}\n\nautocorr(x, 1)\n// output\n-0.808343\n\nautocorr(x, 2)\n// output\n0.661018\n```\n\n相关函数： [acf](https://docs.dolphindb.cn/zh/funcs/a/acf.html)\n"
    },
    "avg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/a/avg.html",
        "signatures": [
            {
                "full": "avg(X)",
                "name": "avg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [avg](https://docs.dolphindb.cn/zh/funcs/a/avg.html)\n\n\n\n#### 语法\n\navg(X)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量、矩阵或表。\n\n#### 详情\n\n* 若 *X* 为向量，计算 *X* 的平均值。\n* 若 *X* 为矩阵，计算每列的平均值，返回一个向量。\n* 若 *X* 为表，计算每列的平均值，返回一个表。\n\n该函数与 [mean](https://docs.dolphindb.cn/zh/funcs/m/mean.html) 函数完全相同。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\navg(1 2 3 NULL)\n// output\n2\n\nm=matrix(1 2 3, 4 5 6)\nm\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\navg(m)\n// output\n[2,5]\n```\n"
    },
    "backup": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/backup.html",
        "signatures": [
            {
                "full": "backup(backupDir, dbPath|sqlObj, [force=false], [parallel=false], [snapshot=true], [tableName], [partition])",
                "name": "backup",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath|sqlObj",
                        "name": "dbPath|sqlObj"
                    },
                    {
                        "full": "[force=false]",
                        "name": "force",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[parallel=false]",
                        "name": "parallel",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[snapshot=true]",
                        "name": "snapshot",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    },
                    {
                        "full": "[partition]",
                        "name": "partition",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html)\n\n\n\n#### 语法\n\nbackup(backupDir, dbPath|sqlObj, \\[force=false], \\[parallel=false], \\[snapshot=true], \\[tableName], \\[partition])\n\n#### 参数\n\n**backupDir** 字符串，表示存放备份数据的目录。如需备份到 AWS S3 存储路径，此参数的值应以 `s3://` 开头。\n\n**dbPath** 字符串，表示数据库路径。若指定该参数，以分区为单位拷贝文件进行备份。\n\n**sqlObj** SQL 元代码，表示备份的数据。若指定该参数，则仅对 SQL 语句过滤出的数据进行备份。\n\n**force** 布尔值，表示是否进行全量备份。进行非首次备份时，若 *force* = true，系统将待备份数据全部进行备份；否则仅备份有修改或新增的分区数据。\n\n**parallel** 布尔值，表示是否对一个数据表下不同分区进行并行备份。默认值为 false。\n\n以下参数仅在指定 *dbPath* 时有效：\n\n**snapshot** 布尔值，仅在参数 *partition* 为空时有效。表示进行非首次备份时，源数据库中若存在被删除的表/分区，是否同步将备份中对应的表/分区删除。 若设置为 true，则备份文件中存在已经被删除的分区或表，会同步进行删除；否则不会删除。\n\n**tableName** 字符串标量或向量，表示表名。若不指定，表示数据库下的所有表。\n\n**partition** 表示分区，若不指定，则表示所有分区。有两种指定模式：\n\n* 指定路径：以 \"/\" 开头的字符串标量或向量，表示数据库目录下单个或多个分区的路径。请注意对组合分区，路径必须包括所有层次分区。\n* 指定条件：以分区列的一个或多个值作为过滤条件。对于组合分区，*partition*是一个元组，每个元素代表一层分区的过滤条件，如果某层分区不需要过滤，那么相应的过滤条件需置为空。需要注意的是，对于范围分区，需要指定为分区内的一个值。\n\n  假如一个组合分区数据库 \"dfs\\://compoDB\"，一级分区采用值分区：2017.08.07；二级分区采用哈希分区：Key0 和 Key1。分区数据的路径分别为：\\<HomeDir>/storage/CHUNKS/compoDB/20170807/Key0 和 \\<HomeDir>/storage/CHUNKS/compoDB/20170807/Key1。若要备份单个分区 20170807/Key0，指定路径时需要设置 *partition* = \"/20170807/Key0\"；指定条件时需要设置 *partition* = \\[2017.08.07, 0]。若要备份两个分区 20170807/Key0 和 20170807/Key1，则 *partition* 指定为 \\[\"/20170807/Key0\", \"/20170807/Key1\"]；指定条件时需要设置 *partition* = \\[2017.08.07,\\[0,1]]。\n\n#### 详情\n\n以分区为单位，备份分布式表的数据。返回一个整数，表示备份成功的分区数量。该函数必须要用户登录后才能执行。\n\n**Note:**\n\n* 若 [database](https://docs.dolphindb.cn/zh/funcs/d/database.html) 创建数据库时，指定 *chunkGranularity* = 'DATABASE'，则只能通过 SQL 语句备份数据。\n* 若 *backupDir* 目录已存在备份文件，则再次向该目录备份数据时，需保证备份方式（*dbPath* 或 *sqlObj*）一致，否则将备份失败。\n* 若 ***backupDir*** 指定为 AWS S3 存储路径，则只能以分区方式备份，即只支持 *dbPath*，不支持 *sqlObj*。\n* 若 ***backupDir*** 指定为 AWS S3 存储路径，需要在数据节点的配置中添加配置项 *preloadModules=plugins::awss3*，同时设置 *s3AccessKeyId*、*s3SecretAccessKey* 和 *s3Region*。\n\n#### 补充说明\n\n备份时指定 *dbPath* 和 *sqlObj* 的功能列表：\n\n| 功能     | dbPath             | sqlObj                             |\n| ------ | ------------------ | ---------------------------------- |\n| 一键备份整库 | 支持                 | 不支持                                |\n| 数据一致性  | 保证数据一致性            | 不完全保证                              |\n| 增量备份   | 支持同步已修改、新增及删除的分区数据 | 只支持同步已修改或新增的分区数据，不支持同步已删除的分区数据     |\n| 断点续传   | 支持                 | 不支持                                |\n| 灵活语法   | 不支持                | SQL 语句，具有灵活语法，支持备份整张表或仅备份满足查询条件的数据 |\n| 性能     | 拷贝文件方式，内存消耗小，速度快   | 序列化方式，内存消耗大，速度慢                    |\n\n#### 例子\n\n创建一个组合分区的数据库 dfs\\://compoDB。\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID=database(, RANGE, 0 50 100);\ndb = database(\"dfs://compoDB\", COMPO, [dbDate, dbID])\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t)\n```\n\n例1. 备份表 pt 的所有数据。\n\n```\nbackup(\"/home/DolphinDB/backup\",<select * from loadTable(\"dfs://compoDB\",\"pt\")>,true);\n// output\n10\n```\n\n例2. 备份表 pt 中日期超过2017.08.10的数据。\n\n```\nbackup(\"/home/DolphinDB/backup\",<select * from loadTable(\"dfs://compoDB\",\"pt\") where date>2017.08.10>,true);\n// output\n2\n```\n\n例3. 备份数据库中表数据。\n\n(1) 备份指定表或所有表\n\n```\n// dfs://compoDB 数据库下创建第2张表\npt1 = db.createPartitionedTable(t, `pt1, `date`ID)\npt1.append!(t)\n\n// 同时备份数据库中的两张表\nbackup(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",force=true);\n// output\n20\n```\n\n(2) partition 指定分区范围\n\n```\n// 备份数据库中表 pt 的指定的5个分区\npartitions=[\"/20170807/0_50\",\"/20170808/0_50\",\"/20170809/0_50\",\"/20170810/0_50\",\"/20170811/0_50\"]\nbackup(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",force=true,tableName=`pt,partition=partitions);\n// output\n5\n```\n\n(3) partition 指定过滤条件。请注意，对于范围分区，指定分区范围内的一个值，表示整个分区。\n\n```\n// 备份数据库中表 pt 的一级分区 20170807 内的 50_100 的分区\npartitions=[2017.08.07,50]\nbackup(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",force=true,tableName=`pt,partition=partitions);\n// output\n1\n// 备份数据库中表 pt 的所有一级分区内的 0_50 的分区\npartitions=[,[0]]\nbackup(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",force=true,tableName=`pt,partition=partitions);\n// output\n5\n```\n\n例4. 通过下例说明 *snapshot* 参数的作用\n\n```\n// 删除表 pt 中分区\"/20170811/0_50\"\ndb.dropPartition(\"/20170811/0_50\",`pt)\n//再次备份，指定snapshot=false\nbackup(backupDir=\"/home/DolphinDB/backup1\",dbPath=\"dfs://compoDB\",force=true,snapshot=false,tableName=`pt);\n// output\n9\n// 从备份中恢复的分区仍包含 /20170811/0_50 这个分区，说明备份文件中并没有删除/20170811/0_50 这个分区\nrestore(backupDir=\"/home/DolphinDB/backup1\",dbPath=\"dfs://compoDB\",tableName=`pt,partition=\"%\",force=true)\n// output\n[\"dfs://compoDB/20170807/0_50/9m9\",\"dfs://compoDB/20170807/50_100/9m9\",\"dfs://compoDB/20170808/0_50/9m9\",\n    \"dfs://compoDB/20170808/50_100/9m9\",\"dfs://compoDB/20170809/0_50/9m9\",\"dfs://compoDB/20170809/50_100/9m9\",\n    \"dfs://compoDB/20170810/0_50/9m9\",\"dfs://compoDB/20170810/50_100/9m9\",\"dfs://compoDB/20170811/0_50/9m9\",\n    \"dfs://compoDB/20170811/50_100/9m9\"]\n\n// 再次删除表pt中分区\"/20170811/0_50\"\ndb.dropPartition(\"/20170811/0_50\",`pt)\n\n// 再次备份，指定snapshot=true\nbackup(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",force=true,snapshot=true,tableName=`pt);\n// output\n9\n// 从备份中恢复的分区不包含 /20170811/0_50 这个分区，说明备份文件中删除了/20170811/0_50 这个分区\nrestore(backupDir=\"/home/DolphinDB/backup\",dbPath=\"dfs://compoDB\",tableName=`pt,partition=\"%\",force=true)\n// output\n[\"dfs://compoDB/20170807/0_50/9m9\",\"dfs://compoDB/20170807/50_100/9m9\",\"dfs://compoDB/20170808/0_50/9m9\",\n    \"dfs://compoDB/20170808/50_100/9m9\",\"dfs://compoDB/20170809/0_50/9m9\",\"dfs://compoDB/20170809/50_100/9m9\",\n    \"dfs://compoDB/20170810/0_50/9m9\",\"dfs://compoDB/20170810/50_100/9m9\",\"dfs://compoDB/20170811/50_100/9m9\"]\n```\n\n相关函数：[backupDB](https://docs.dolphindb.cn/zh/funcs/b/backupDB.html), [backupTable](https://docs.dolphindb.cn/zh/funcs/b/backupTable.html), [restore](https://docs.dolphindb.cn/zh/funcs/r/restore.html), [migrate](https://docs.dolphindb.cn/zh/funcs/m/migrate.html)\n"
    },
    "backupDB": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/backupDB.html",
        "signatures": [
            {
                "full": "backupDB(backupDir, dbPath)",
                "name": "backupDB",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    }
                ]
            }
        ],
        "markdown": "### [backupDB](https://docs.dolphindb.cn/zh/funcs/b/backupDB.html)\n\n\n\n#### 语法\n\nbackupDB(backupDir, dbPath)\n\n#### 参数\n\n**backupDir** 字符串，表示存放备份数据的目录。\n\n**dbPath** 字符串，表示数据库路径。\n\n#### 详情\n\n备份数据库到指定路径。\n\n该函数是 [backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html) 函数的特例，其等价于调用 `backup(backupDir, dbPath, force=false, parallel=true, snapshot=true)`。 调用该函数可以简化代码，方便用户一次性备份整个数据库。\n\n#### 例子\n\n```\ndbName = \"dfs://compoDB2\"\nn=1000\nID=rand(\"a\"+string(1..10), n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10, n)\nt=table(ID, date, x)\ndb1 = database(, VALUE, 2017.08.07..2017.08.11)\ndb2 = database(, HASH,[INT, 20])\nif(existsDatabase(dbName)){\n  dropDatabase(dbName)\n}\ndb = database(dbName, COMPO,[ db1,db2])\n\n// 创建2个表\npt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\npt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\nbackupDB(backupDir, dbName)\n```\n\n相关函数：[backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html), [backupTable](https://docs.dolphindb.cn/zh/funcs/b/backupTable.html), [restore](https://docs.dolphindb.cn/zh/funcs/r/restore.html), [restoreDB](https://docs.dolphindb.cn/zh/funcs/r/restoreDB.html), [restoreTable](https://docs.dolphindb.cn/zh/funcs/r/restoreTable.html), [migrate](https://docs.dolphindb.cn/zh/funcs/m/migrate.html)\n"
    },
    "backupSettings": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/backupsettings.html",
        "signatures": [
            {
                "full": "backupSettings(fileName, [userPermission=true], [functionView=true])",
                "name": "backupSettings",
                "parameters": [
                    {
                        "full": "fileName",
                        "name": "fileName"
                    },
                    {
                        "full": "[userPermission=true]",
                        "name": "userPermission",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[functionView=true]",
                        "name": "functionView",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [backupSettings](https://docs.dolphindb.cn/zh/funcs/b/backupsettings.html)\n\n\n\n#### 语法\n\nbackupSettings(fileName, \\[userPermission=true], \\[functionView=true])\n\n#### 参数\n\n**fileName** STRING 类型标量，指定备份文件的存储路径，可以为绝对路径或相对于 \\<HomeDir> 的相对路径。\n\n**userPermission** BOOL 类型标量，表示是否备份用户权限。默认值为 true，表示备份用户权限。\n\n**functionView** BOOL 类型标量，表示是否备份函数视图。默认值为 true，表示备份函数视图。\n\n#### 详情\n\n此函数只能由管理员在控制节点执行，备份当前数据库系统中的所有用户、用户权限信息和函数视图，并将备份文件保存到指定路径。\n\n函数返回一个向量，依次列出已成功备份的用户名和函数视图名称。\n\n与函数 [restoreSettings](https://docs.dolphindb.cn/zh/funcs/r/restoresettings.html) 搭配使用，可以在数据库迁移时实现用户、用户权限及函数视图的迁移。\n\n#### 例子\n\n```\n// 备份用户、权限信息、函数视图\nbackupSettings(fileName=\"/home/ddb/backup/permission.back\", userPermission=true, functionView=true)\n// 备份用户、权限信息，不备份函数视图\nbackupSettings(fileName=\"/home/ddb/backup/permission.back\", userPermission=true, functionView=false)\n// 备份用户、函数视图，不备份权限信息\nbackupSettings(fileName=\"/home/ddb/backup/permission.back\", userPermission=false, functionView=true)\n// 备份用户，不备份权限信息和函数视图\nbackupSettings(fileName=\"/home/ddb/backup/permission.back\", userPermission=false, functionView=false)\n```\n\n相关函数：[restoreSettings](https://docs.dolphindb.cn/zh/funcs/r/restoresettings.html)\n"
    },
    "backupTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/backupTable.html",
        "signatures": [
            {
                "full": "backupTable(backupDir, dbPath, tableName)",
                "name": "backupTable",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [backupTable](https://docs.dolphindb.cn/zh/funcs/b/backupTable.html)\n\n\n\n#### 语法\n\nbackupTable(backupDir, dbPath, tableName)\n\n#### 参数\n\n**backupDir** 字符串，表示存放备份数据的目录。\n\n**dbPath** 字符串，表示数据库路径。\n\n**tableName** 字符串，表示表名。\n\n#### 详情\n\n备份数据库中的表到指定路径。\n\n该函数是 [backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html) 函数的特例，其等价于调用 `backup(backupDir, dbPath, force=false, parallel=true, snapshot=true, tableName)`。 调用该函数可以简化代码，方便用户一次性备份数据库的一张表。\n\n#### 例子\n\n```\ndbName = \"dfs://compoDB2\"\nn=1000\nID=rand(\"a\"+string(1..10), n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10, n)\nt=table(ID, date, x)\ndb1 = database(, VALUE, 2017.08.07..2017.08.11)\ndb2 = database(, HASH,[INT, 20])\nif(existsDatabase(dbName)){\n  dropDatabase(dbName)\n}\ndb = database(dbName, COMPO,[ db1,db2])\n\n// 创建2个表\npt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\npt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\nbackupTable(backupDir,dbName,`pt1)\n// output\n50\n```\n\n相关函数：[backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html), [backupDB](https://docs.dolphindb.cn/zh/funcs/b/backupDB.html), [restore](https://docs.dolphindb.cn/zh/funcs/r/restore.html), [restoreDB](https://docs.dolphindb.cn/zh/funcs/r/restoreDB.html), [restoreTable](https://docs.dolphindb.cn/zh/funcs/r/restoreTable.html), [migrate](https://docs.dolphindb.cn/zh/funcs/m/migrate.html)\n"
    },
    "bar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bar.html",
        "signatures": [
            {
                "full": "bar(X, interval, [closed='left'])",
                "name": "bar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "interval",
                        "name": "interval"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    }
                ]
            }
        ],
        "markdown": "### [bar](https://docs.dolphindb.cn/zh/funcs/b/bar.html)\n\n\n\n#### 语法\n\nbar(X, interval, \\[closed='left'])\n\n相关函数：[dailyAlignedBar](https://docs.dolphindb.cn/zh/funcs/d/dailyAlignedBar.html)\n\n#### 参数\n\n**X** 是一个整型/时间类型的标量或向量。\n\n**interval** 是一个大于0的整型/DURATION 类型的标量或和 *X* 长度相同的向量。\n\n*interval* 是 DURATION 类型时，支持以下时间单位（区分大小写）：w, d, H, m, s, ms, us, ns。\n\n**Note:** 由于 *interval* 不支持年(y)和月(M)的时间单位，如果需要对 *X* 以年或月进行分组时，可以调用 [year](https://docs.dolphindb.cn/zh/funcs/y/year.html) 或 [month](https://docs.dolphindb.cn/zh/funcs/m/month.html) 对 *X* 进行转换后，指定 *interval* 为整数进行计算。可以参考例2。\n\n**closed** 字符串，可选值为 'left' 或 'right'。 表示 *X* 中可被 *interval* 整除的元素，归为某个分组的左边界（即该组第一个元素，此时*closed*=‘left’），还是归为某个分组的右边界（即该组最后一个元素，此时*closed*=‘right’）。\n\n对应的分组计算公式为：\n\n*closed* = 'left'时，*X*-(*X* % *interval*)，表示将余数为 0 的值作为一个分组的左边界。\n\n*closed* = 'right'时，iif((*X* % *interval*) == 0, *X*, *X* + (*interval*-(*X* % *interval*)))，表示将余数为 0 的值作为一个分组的右边界。\n\n#### 详情\n\n`bar` 基于 *interval* 指定的长度，根据分组计算公式，对 *X* 进行分组。它返回一个和 *X* 具有相同长度的向量。\n\n#### 例子\n\n例1.\n\n```\nbar(100,3);               // 100-(100%3)=100-1=99\n// output\n99\n\nbar(0..15, 3)\n// output\n[0,0,0,3,3,3,6,6,6,9,9,9,12,12,12,15]\n\nx=[7,4,5,8,9,3,3,5,2,6,12,1,0,-5,32]\nbar(x, 5)\n// output\n[5,0,5,5,5,0,0,5,0,5,10,0,0,-5,30]\n\nt=table(2021.01.01T01:00:00..2021.01.01T01:00:29 as time, rand(1.0, 30) as x)\nselect max(x) from t group by bar(time,5s)\n```\n\n| bar\\_time           | max\\_x   |\n| ------------------- | -------- |\n| 2021.01.01T01:00:00 | 0.539024 |\n| 2021.01.01T01:00:05 | 0.793327 |\n| 2021.01.01T01:00:10 | 0.958522 |\n| 2021.01.01T01:00:15 | 0.96987  |\n| 2021.01.01T01:00:20 | 0.827086 |\n| 2021.01.01T01:00:25 | 0.617353 |\n\n例2. 以3个月进行分组，需要将 `bar` 函数中的 *X* 转为月份：\n\n```\nt=table(take(2018.01.01T01:00:00+1..10,10) join take(2018.02.01T02:00:00+1..10,10) join take(2018.03.01T08:00:00+1..10,10) join take(2018.04.01T08:00:00+1..10,10) join take(2018.05.01T08:00:00+1..10, 10) as time, rand(1.0, 50) as x)\nselect max(x) from t group by bar(month(time), 3);\n```\n\n| bar      | max\\_x |\n| -------- | ------ |\n| 2018.01M | 0.9868 |\n| 2018.04M | 0.9243 |\n\n例3. 将日期按照周分组，计算每周的最大值。根据 *closed* 不同，计算结果有所区别。\n\n```\nt=table(2022.01.01 + 1..20  as time, rand(100, 20) as x)\n```\n\n| time       | x  |\n| ---------- | -- |\n| 2022.01.02 | 6  |\n| 2022.01.03 | 29 |\n| 2022.01.04 | 71 |\n| 2022.01.05 | 56 |\n| 2022.01.06 | 93 |\n| 2022.01.07 | 34 |\n| 2022.01.08 | 77 |\n| 2022.01.09 | 18 |\n| 2022.01.10 | 62 |\n| 2022.01.11 | 33 |\n| 2022.01.12 | 34 |\n| 2022.01.13 | 64 |\n| 2022.01.14 | 80 |\n| 2022.01.15 | 63 |\n| 2022.01.16 | 17 |\n| 2022.01.17 | 66 |\n| 2022.01.18 | 85 |\n| 2022.01.19 | 27 |\n| 2022.01.20 | 77 |\n| 2022.01.21 | 27 |\n\n```\nselect max(x) from t group by bar(time, 7d);\n```\n\n| bar\\_time  | max\\_x |\n| ---------- | ------ |\n| 2021.12.30 | 71     |\n| 2022.01.06 | 93     |\n| 2022.01.13 | 85     |\n| 2022.01.20 | 77     |\n\n```\nprint  select max(x) from t group by bar(time, 7d, closed='right');\n```\n\n| bar\\_time  | max\\_x |\n| ---------- | ------ |\n| 2021.01.06 | 93     |\n| 2022.01.13 | 77     |\n| 2022.01.20 | 85     |\n| 2022.01.27 | 27     |\n\n例4. 计算分钟 k 线时，n 需要转换为 NANOTIMESTAMP，此时若使用整型计算可能造成类型溢出，需要将数据类型转换成 LONG。\n\n```\nn = 1000000\nnano = (09:30:00.000000000 + rand(long(6.5*60*60*1000000000), n)).sort!()\nprice = 100+cumsum(rand(0.02, n)-0.01)\nvolume = rand(1000, n)\nsymbol = rand(`600519`000001`600000`601766, n)\ntradeNano = table(symbol, nano, price, volume).sortBy!(`symbol`nano)\nundef(`nano`price`volume`symbol)\nbarMinutes = 7\nitv = barMinutes*60*long(1000000000)\n\nOHLC_nano=select first(price) as open, max(price) as high, min(price) as low, last(price) as close, sum(volume) as volume from tradeNano group by symbol, bar(nano, itv) as barStart\n```\n"
    },
    "base64Decode": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/base64Decode.html",
        "signatures": [
            {
                "full": "base64Decode(X)",
                "name": "base64Decode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [base64Decode](https://docs.dolphindb.cn/zh/funcs/b/base64Decode.html)\n\n\n\n#### 语法\n\nbase64Decode(X)\n\n#### 参数\n\n**X** 字符串标量或向量。\n\n#### 详情\n\n将 Base64 编码的数据解码为二进制数据。\n\n返回值：BLOB 类型标量或向量。\n\n#### 例子\n\n```\nbase64Decode(base64Encode(`hello))\n// output\nhello\n\nbase64Decode(base64Encode(`hello`world))\n// output\n[\"hello\",\"world\"]\n```\n\n相关函数：[base64Encode](https://docs.dolphindb.cn/zh/funcs/b/base64Encode.html)\n"
    },
    "base64Encode": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/base64Encode.html",
        "signatures": [
            {
                "full": "base64Encode(X)",
                "name": "base64Encode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [base64Encode](https://docs.dolphindb.cn/zh/funcs/b/base64Encode.html)\n\n\n\n#### 语法\n\nbase64Encode(X)\n\n#### 参数\n\n**X** 字符串标量或向量。\n\n#### 详情\n\n将 *X* 转换为 Base64 编码格式。\n\n返回值：字符串标量或向量。\n\n#### 例子\n\n```\nbase64Encode(`hello) \n// output\naGVsbG8=\n\nbase64Encode(`hello`world) \n// output\n[\"aGVsbG8=\",\"d29ybGQ=\"]\n\nbase64Encode(\"\")\n// output\n\"\"\n```\n\n相关函数：[base64Decode](https://docs.dolphindb.cn/zh/funcs/b/base64Decode.html)\n"
    },
    "beta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/beta.html",
        "signatures": [
            {
                "full": "beta(Y, X)",
                "name": "beta",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [beta](https://docs.dolphindb.cn/zh/funcs/b/beta.html)\n\n\n\n#### 语法\n\nbeta(Y, X)\n\n#### 参数\n\n**Y** 和 **X** 是相同长度的数值型向量、维度相同的矩阵或表。若 *X* 是表，只对其内数值型和布尔型的列进行计算。\n\n#### 详情\n\n返回 *Y* 在 *X* 上的回归系数的最小二乘估计。\n\n#### 例子\n\n```\nx=1 3 5 7 11 16 23\ny=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\n\nbeta(y,x);\n// output\n3.378632\n```\n"
    },
    "between": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/between.html",
        "signatures": [
            {
                "full": "between(X, a:b)",
                "name": "between",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "a:b",
                        "name": "a:b"
                    }
                ]
            }
        ],
        "markdown": "### [between](https://docs.dolphindb.cn/zh/funcs/b/between.html)\n\n\n\n#### 语法\n\nbetween(X, a:b)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量或矩阵；\n\n**a:b** 是一个表示范围的数据对。\n\n#### 详情\n\n检查 *X* 的每个元素是否在 a 和 b 之间（两个边界都是包含在内的）。返回结果的长度或维度与 *X* 相同。\n\n#### 例子\n\n```\nbetween([1, 5.5, 6, 8], 1:6);\n// output\n[1,1,1,0]\n// 1, 5.5 和 6 在 1 和 6 之间，但 8 不是。\n\nbetween(1 2.4 3.6 2 3.9, 2.4:3.6);\n// output\n[0,1,1,0,0]\n```\n\n`between` 可以搭配 `select` 使用，用于筛选列的范围：\n\n```\nt = table(`abb`aac`aaa as sym, 1.8 2.3 3.7 as price);\nselect * from t where price between 1:3;\n```\n\n| sym | price |\n| --- | ----- |\n| abb | 1.8   |\n| aac | 2.3   |\n\n下例说明数据对 a:b 中出现空值的处理方式。若配置 *nullAsMinValueForComparison* =true，则 NULL 值当同数据类型的而最小值处理， 若配置 *nullAsMinValueForComparison* =false，则 NULL 值仍保留为 NULL。也可以使用 [nullCompare](https://docs.dolphindb.cn/zh/funcs/ho_funcs/nullCompare.html) 函数，无论 *nullAsMinValueForComparison* 设置为何值都保留 NULL 值。\n\n```\nbetween(10,:10)\n// output\ntrue      // 配置 nullAsMinValueForComparison=true 时的返回结果\nbetween(10,:10)\n// output\nNULL     // 配置 nullAsMinValueForComparison=false 时的返回结果\nnullCompare(between, 10, :10)\n// output\nNULL\n```\n"
    },
    "bfill": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bfill.html",
        "signatures": [
            {
                "full": "bfill(obj, [limit])",
                "name": "bfill",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [bfill](https://docs.dolphindb.cn/zh/funcs/b/bfill.html)\n\n\n\n#### 语法\n\nbfill(obj, \\[limit])\n\n#### 参数\n\n**obj** 可以是向量、矩阵或表。\n\n**limit** 是正整数，表示需要填充的 NULL 值的数量。\n\n#### 详情\n\n* 如果*obj*是一个向量，使用 NULL 值后的非空元素来填充 NULL 值。\n* 如果*obj*是一个矩阵或表，对于表中的每一列，使用 NULL 值后的非空元素来填充 NULL 值。\n\n该函数会返回一个新的对象，不会改变输入的对象。函数 [bfill!](https://docs.dolphindb.cn/zh/funcs/b/bfill_.html) 会改变输入的对象。\n\n#### 例子\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.bfill();\n// output\n[1,2,3,4,4,4,4,5,6]\n\nx=1 2 3 NULL NULL NULL 4 5 6\nx.bfill(1);\n// output\n[1,2,3,,,4,4,5,6]\n\nx.bfill!(2);\nx;\n// output\n[1,2,3,,4,4,4,5,6]\n\ndate=[2012.06.12,2012.06.12,2012.06.13,2012.06.14,2012.06.15]\nsym=[\"IBM\",\"MSFT\",\"IBM\",\"MSFT\",\"MSFT\"]\nprice=[,,26.56,,50.76]\nqty=[,,4500,5600,6800]\ntimestamp=[09:34:07,09:35:26,09:36:42,09:36:51,09:36:59]\nt=table(date,timestamp,sym,price,qty)\nt;\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  |       |      |\n| 2012.06.12 | 09:35:26  | MSFT |       |      |\n| 2012.06.13 | 09:36:42  | IBM  | 26.56 | 4500 |\n| 2012.06.14 | 09:36:51  | MSFT |       | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 6800 |\n\n```\nt.bfill()\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 26.56 | 4500 |\n| 2012.06.12 | 09:35:26  | MSFT | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  | 26.56 | 4500 |\n| 2012.06.14 | 09:36:51  | MSFT | 50.76 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 6800 |\n\n```\nselect date, timestamp, sym, price.bfill() as price, qty.bfill() as qty from t context by sym;\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  | 26.56 | 4500 |\n| 2012.06.12 | 09:35:26  | MSFT | 50.76 | 5600 |\n| 2012.06.14 | 09:36:51  | MSFT | 50.76 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 6800 |\n"
    },
    "bfill!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bfill_.html",
        "signatures": [
            {
                "full": "bfill!(obj, [limit])",
                "name": "bfill!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [bfill!](https://docs.dolphindb.cn/zh/funcs/b/bfill_.html)\n\n\n\n#### 语法\n\nbfill!(obj, \\[limit])\n\n#### 参数\n\n**obj** 可以是向量或表。\n\n**limit** 是正整数，表示需要填充的 NULL 值的数量。\n\n#### 详情\n\n* 如果*obj*是一个向量，使用 NULL 值后的非空元素来填充 NULL 值。\n* 如果*obj*是一个表，对于表中的每一列，使用 NULL 值后的非空元素来填充 NULL 值。\n\n#### 例子\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.bfill!()\nx;\n// output\n[1,2,3,4,4,4,4,5,6]\n\nx=1 2 3 NULL NULL NULL 4 5 6\nx.bfill!(1)\nx;\n// output\n[1,2,3,,,4,4,5,6]\n\ndate=[2012.06.12,,2012.06.13,2012.06.14,2012.06.15]\nsym=[\"IBM\",\"MSFT\",\"IBM\",\"MSFT\",\"MSFT\"]\nprice=[40.56,26.56,,,50.76]\nqty=[2200,4500,1200,5600,]\ntimestamp=[09:34:07,,09:36:42,09:36:51,09:36:59]\nt=table(date,timestamp,sym,price,qty)\n\nbfill!(t)\nt\n```\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 40.56 | 2200 |\n| 2012.06.13 | 09:36:42  | MSFT | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  | 50.76 | 1200 |\n| 2012.06.14 | 09:36:51  | MSFT | 50.76 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 |      |\n\n如果只需要填充表中的某些列，需要使用 [update](https://docs.dolphindb.cn/zh/progr/sql/update.html) 语句和 [bfill](https://docs.dolphindb.cn/zh/funcs/b/bfill.html) 函数。具体请参考 [bfill](https://docs.dolphindb.cn/zh/funcs/b/bfill.html) 的例子。\n"
    },
    "bigarray": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bigarray.html",
        "signatures": [
            {
                "full": "bigarray(dataType|template, [initialSize], [capacity], [defaultValue])",
                "name": "bigarray",
                "parameters": [
                    {
                        "full": "dataType|template",
                        "name": "dataType|template"
                    },
                    {
                        "full": "[initialSize]",
                        "name": "initialSize",
                        "optional": true
                    },
                    {
                        "full": "[capacity]",
                        "name": "capacity",
                        "optional": true
                    },
                    {
                        "full": "[defaultValue]",
                        "name": "defaultValue",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [bigarray](https://docs.dolphindb.cn/zh/funcs/b/bigarray.html)\n\n\n\n#### 语法\n\nbigarray(dataType|template, \\[initialSize], \\[capacity], \\[defaultValue])\n\n#### 参数\n\n**dataType** 是大数组的数据类型。\n\n**template** 是已有的大数组。已有的大数组作为模板，它的数据类型决定了新的大数组的数据类型。\n\n**initialSize** 是正整数，表示大数组的初始长度，即该大数组新建时的元素数量。如果第一个参数是数据类型，*initialSize*是必需参数。如果第一个参数是已有的大数组，*initialSize*是可选参数。\n\n**capacity** 是正整数，表示大数组的容量，即该大数组新建时系统为该大数组分配的内存（以元素数为单位）。当元素数超过 *capacity* 时，系统会自动扩充容量。系统首先会分配当前容量1.2\\~2倍的内存，然后复制数据到新的内存空间，最后释放原来的内存。\n\n**defaultValue** 是大数组的默认值。如果不指定默认值，对于多数数据类型，默认值是 0。对于字符串和符号（Symbol），默认值是 NULL。\n\n#### 详情\n\n大数组是专门为进行大数据分析的用户设计的。常规的数组使用连续的内存。如果没有足够的连续内存，就会产生内存不足的异常。大数组由许多小的内存块组成，而不是一个大的内存块。所以，大数组缓解了内存碎片问题。但这可能会对某些操作造成轻微的性能损失。对于多数不需要担心内存碎片问题的用户而言，应该使用常规数组，而不是大数组。\n\n大数组的最小容量是 16 MB。用户可以用 `bigarray` 函数声明一个大数组。\n\n操作大数组的方法和操作一个常规数组一样。\n\n当我们调用 [array](https://docs.dolphindb.cn/zh/funcs/a/array.html) 函数时，如果没有足够的连续内存块，或数组占据的内存超过了一个特定的阈值（默认的阈值是 2048 MB），系统会改为创建一个大数组。\n\n#### 例子\n\n```\nx=bigarray(INT,10,10000000);\nx;\n// output\n[0,0,0,0,0,0,0,0,0,0]\n\n// 默认值设为 1\nx=bigarray(INT,10,10000000,1);\nx;\n// output\n[1,1,1,1,1,1,1,1,1,1]\n\nx=bigarray(INT,0,10000000).append!(1..100);\nx[0];\n// output\n1\nsum x;\n// output\n5050\n\nx[x>50&&x<60];\n// output\n[51,52,53,54,55,56,57,58,59]\n\nx=array(DOUBLE, 40000000);\ntypestr x;\n// output\nHUGE DOUBLE VECTOR\n```\n\n数组和大数组的性能比较：\n\n```\n// 对于顺序操作，数组和大数组的表现几乎相同。\nn=20000000\nx=rand(10000, n)\ny=rand(1.0, n)\nbx= bigarray(INT, 0, n).append!(x)\nby= bigarray(DOUBLE,0,n).append!(y);\n\ntimer(100) wavg(x,y);\n// output\nTime elapsed: 4869.74 ms\ntimer(100) wavg(bx,by);\n// output\nTime elapsed: 4762.89 ms\n\ntimer(100) x*y;\n// output\nTime elapsed: 7525.22 ms\ntimer(100) bx*by;\n// output\nTime elapsed: 7791.83 ms\n\n// 对于随机访问，大数组有轻微的性能损失。\nindices = shuffle 0..(n-1);\ntimer(10) x[indices];\n// output\nTime elapsed: 2942.29 ms\ntimer(10) bx[indices];\n// output\nTime elapsed: 3547.22 ms\n```\n"
    },
    "binaryExpr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/binaryExpr.html",
        "signatures": [
            {
                "full": "binaryExpr(X, Y, optr)",
                "name": "binaryExpr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "optr",
                        "name": "optr"
                    }
                ]
            }
        ],
        "markdown": "### [binaryExpr](https://docs.dolphindb.cn/zh/funcs/b/binaryExpr.html)\n\n\n\n#### 语法\n\nbinaryExpr(X, Y, optr)\n\n#### 参数\n\n**X** 可以是一个标量/向量/矩阵。\n\n**Y** 可以是一个标量或者和 *X* 具有相同类型的量。\n\n**optr** 是一个二元运算符。\n\n#### 详情\n\n使用 *optr* 指定的二元运算符，将 *X* 与 *Y* 连接，成一个二元运算的元代码。使用 [eval](https://docs.dolphindb.cn/zh/funcs/e/eval.html) 函数可以执行 `binaryExpr` 函数生成的元代码。\n\n#### 例子\n\n```\nbinaryExpr(1, 1, +).eval()\n// output\n2\n\nbinaryExpr(1 2.2 3, 1 2 3, *).eval()\n// output\n[1 4.4 9]\n\nbinaryExpr(`id`st`nm, `fff, +).eval()\n// output\n[\"idfff\",\"stfff\",\"nmfff\"]\n\n\na = matrix(1 2, 3 4)\nb = matrix(4 2, 5 1)\nbinaryExpr(a, b, dot).eval()\n```\n\n| #0 | #1 |\n| -- | -- |\n| 10 | 8  |\n| 16 | 14 |\n\n相关函数： [unifiedExpr](https://docs.dolphindb.cn/zh/funcs/u/unifiedExpr.html)\n"
    },
    "binsrch": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/binsrch.html",
        "signatures": [
            {
                "full": "binsrch(X, Y)",
                "name": "binsrch",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [binsrch](https://docs.dolphindb.cn/zh/funcs/b/binsrch.html)\n\n\n\n#### 语法\n\nbinsrch(X, Y)\n\n#### 参数\n\n**X** 必须是一个递增向量；\n\n**Y** 可以是标量、向量、元组、数组向量、矩阵、字典、表。\n\n#### 详情\n\n`binsrch` 即二分查找。对于每一个 *Y* 中的元素，`binsrch` 确定它在 *X* 中的位置。如果没有找到，返回 -1。\n\n为了充分发挥性能，应当使用 `binsrch` 在一个有序的长向量 *X* 中查找一个较短的 *Y*。要在一个长的未排序的向量中查找一个较长向量，应当使用 [find](https://docs.dolphindb.cn/zh/funcs/f/find.html) 函数，后者使用散列表实现。但是构造一个散列表会花一些时间和内存。另外也请参见相关函数 [in](https://docs.dolphindb.cn/zh/funcs/i/in.html)。\n\n#### 例子\n\n```\n1..100 binsrch 12 6 88 102;\n// output\n[11,5,87,-1]\n```\n"
    },
    "bitAnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bitAnd.html",
        "signatures": [
            {
                "full": "bitAnd(X, Y)",
                "name": "bitAnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [bitAnd](https://docs.dolphindb.cn/zh/funcs/b/bitAnd.html)\n\n\n\n#### 语法\n\nbitAnd(X, Y)或 X & Y\n\n#### 参数\n\n**X** 和 **Y** 可以是数值型的标量，向量，矩阵，或数据表。\n\n#### 详情\n\n返回位运算与（`bitAnd`）的结果\n\n#### 例子\n\n```\nx=1 0 1;\ny=0 1 1;\nx&y;\n// output\n[0,0,1]\n```\n"
    },
    "bitNot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bitNot.html",
        "signatures": [
            {
                "full": "bitNot(X)",
                "name": "bitNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [bitNot](https://docs.dolphindb.cn/zh/funcs/b/bitNot.html)\n\n\n\n#### 语法\n\nbitNot(X)\n\n#### 参数\n\n**X** 可以是数值型的标量，向量，矩阵，或数据表。\n\n#### 详情\n\n返回按位取反的结果。\n\n#### 例子\n\n```\nbitNot(3)\n// output\n-4\n\nav = array\\(INT\\[\\], 0, 10\\).append!\\(\\[1 2 3, 4 5\\]\\)\nbitNot\\(av\\)\n// output\n\\[\\[-2,-3,-4\\],\\[-5,-6\\]\\]\n```\n"
    },
    "bitOr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bitOr.html",
        "signatures": [
            {
                "full": "bitOr(X, Y)",
                "name": "bitOr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [bitOr](https://docs.dolphindb.cn/zh/funcs/b/bitOr.html)\n\n\n\n#### 语法\n\nbitOr(X, Y) 或 X | Y\n\n#### 参数\n\n**X** 和 **Y** 可以是数值型的标量，向量，矩阵，或数据表。\n\n#### 详情\n\n返回位运算或（`bitOr`）的结果。\n\n#### 例子\n\n```\nx=1 0 1;\ny=0 1 1;\nx | y;\n// output\n[1,1,1]\n```\n"
    },
    "bitXor": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bitXor.html",
        "signatures": [
            {
                "full": "bitXor(X, Y)",
                "name": "bitXor",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [bitXor](https://docs.dolphindb.cn/zh/funcs/b/bitXor.html)\n\n\n\n#### 语法\n\nbitXor(X, Y) 或 X ^ Y\n\n#### 参数\n\n**X** 和 **Y** 可以是数值型的标量，向量，矩阵，或数据表。\n\n#### 详情\n\n返回位运算异或（`bitXOr`）的结果。\n\n#### 例子\n\n```\nx=1 0 1;\ny= 0 1 1;\nx^y;\n// output\n[1,1,0]\n```\n"
    },
    "blob": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/blob.html",
        "signatures": [
            {
                "full": "blob(X)",
                "name": "blob",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [blob](https://docs.dolphindb.cn/zh/funcs/b/blob.html)\n\n\n\n#### 语法\n\nblob(X)\n\n#### 参数\n\n**X** 是一个字符串标量或向量。\n\n#### 详情\n\n将一个字符串转为 BLOB 类型。\n\n注意：\n\n* BLOB 类型不支持任何计算。\n\n#### 例子\n\n```\nstr=\"hello\"\nblob(str)\n// output\nhello\n\nt=table(1..10 as id, \"A\"+string(1..10) as sym, 2012.01.01..2012.01.10 as date, rand(100.0, 10) as val, rand(uuid(), 10) as uid)\nstr=toJson(t)\nblob(str)\n```\n\n通过 `blob` 将超长字符串转为 BLOB 类型后，可作为内存表的一个字段使用：\n\n```\nd = dict(1..10000,  rand(1.0, 10000))\nstr=toStdJson(d);\nt=table(blob(str) as jsonStr)\n```\n\nTSDB 引擎的分布式表也支持变长字符 BLOB 类型：\n\n```\ndbPath=\"dfs://testBlobDB\"\nif(existsDatabase(dbPath)){\ndropDatabase(dbPath)\n}\nn=2000000\nt=table(n:0,`date`id`type`num`blob,[DATETIME,INT,SYMBOL,DOUBLE,BLOB])\ndb1=database(\"\",VALUE,2020.01.01..2020.01.10)\ndb2=database(\"\",HASH,[INT,10])\n\ndb=database(directory=dbPath,partitionType=COMPO,partitionScheme=[db1,db2],engine='TSDB')\npt1=createPartitionedTable(dbHandle=db,table=t,tableName=`pt1,partitionColumns=`date`id,sortColumns=`type)\n\ndate=concatDateTime(take(2020.01.01..2020.01.10,n),take(00:00:00..23:23:59,n))\nid=rand(1..1000,n)\ntype=rand(`A`B`C`D`E,n)\nnum=rand(100.0,n)\n\nblob=take(blob(string(1..10)),n)\n\nt1=table(date,id,type,num,blob)\npt1.append!(t1)\nselect *  from pt1\n```\n"
    },
    "bondAccrInt": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bondaccrint.html",
        "signatures": [
            {
                "full": "bondAccrInt(settlement, maturity, coupon, frequency, [par=100], [basis=1])",
                "name": "bondAccrInt",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "coupon",
                        "name": "coupon"
                    },
                    {
                        "full": "frequency",
                        "name": "frequency"
                    },
                    {
                        "full": "[par=100]",
                        "name": "par",
                        "optional": true,
                        "default": "100"
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [bondAccrInt](https://docs.dolphindb.cn/zh/funcs/b/bondaccrint.html)\n\n\n\n#### 语法\n\nbondAccrInt(settlement, maturity, coupon, frequency, \\[par=100], \\[basis=1])\n\n别名：fiAccrInt\n\n#### 详情\n\n返回有价证券的应付利息（Accrued Interest），是一个 DOUBLE 类型的标量或向量。应付利息是自上次票息支付（last coupon payment）到交易日（settlement）所赚取的利息。\n\n另外，应付利息（Accrued Interest）常用来计算除息价格（Clean Price）。相关计算公式为：*除息价格（Clean Price） = 含息价格（Dirty Price）- 应付利息（Accrued Interest）*。\n\n#### 参数\n\n* **settlement** DATE 类型标量或向量，表示有价证券的结算日，即购买日期。\n* **maturity** DATE 类型标量或向量，表示有价证券的到期日（有价证券有效期截止时的日期）。\n* **coupon** 数值型标量或向量，表示有价证券的年息票利率。\n* **frequency** 整型标量或向量，表示年付息次数。可选值为：\n  * 1：按年支付\n  * 2：按半年期支付\n  * 4：按季支付\n  * 12：按月支付\n* **par** 可选参数，数值型标量或向量，表示证券的票面值，默认值为 100。\n* **basis** 可选参数，整型标量或向量，表示要使用的日计数基准类型，默认值为 1。可选值为：\n\n  | Basis | 日计数基准            |\n  | ----- | ---------------- |\n  | 0     | US (NASD) 30/360 |\n  | 1 或省略 | 实际/实际            |\n  | 2     | 实际/360           |\n  | 3     | 实际/365           |\n  | 4     | 欧洲 30/360        |\n\n#### 例子\n\n假设有一张面值为 1000 的债券，购买日期为 2024 年 1 月 1 日，到期日期为 2030 年 12 月 31 日，年息票利率为 10%，每年付息 2 次（半年付息），以 US (NASD) 30/360 为日计数基准。\n\n```\nbondAccrInt(settlement=2024.01.01, maturity=2030.12.31, coupon=0.1, frequency=2, par=1000, basis=0)\n//output:0.277778\n```\n\n**Related information**\n\n[bondDirtyPrice](https://docs.dolphindb.cn/zh/funcs/b/bondDirtyPrice.html)\n"
    },
    "bondCashflow": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bondCashflow.html",
        "signatures": [
            {
                "full": "bondCashflow(settlement, maturity, coupon, [frequency], [basis=1], [bondType=0])",
                "name": "bondCashflow",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "coupon",
                        "name": "coupon"
                    },
                    {
                        "full": "[frequency]",
                        "name": "frequency",
                        "optional": true
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[bondType=0]",
                        "name": "bondType",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [bondCashflow](https://docs.dolphindb.cn/zh/funcs/b/bondCashflow.html)\n\n\n\n#### 语法\n\nbondCashflow(settlement, maturity, coupon, \\[frequency], \\[basis=1], \\[bondType=0])\n\n#### 详情\n\n计算面值为 100 元的债券的现金流，支持固息债券，零息债券和贴现债券。返回 DOUBLE 类型的 vector 或 array vector。\n\n#### 参数\n\n注意：如果输入参数中，部分为标量，其余为向量时，则会将标量当作与向量长度相同、所有元素值等于该标量的向量；且所有向量的长度必须一致。\n\n**settlement** DATE 类型标量或向量，表示有价证券的结算日，即购买日期。\n\n**maturity** DATE 类型标量或向量，表示有价证券的到期日（有价证券有效期截止时的日期）。\n\n**coupon** 数值型标量或向量，非负数，表示有价证券的年息票利率。\n\n**frequency** 可选参数，整型标量或向量，表示年付息次数。注意：\n\n* 若计算零息债券或者贴现债券，则无需填写该参数。\n\n* 若计算固息债券则必填该参数，可选值为：\n\n  * 1：按年支付。\n\n  * 2：按半年期支付。\n\n  * 4：按季支付。\n\n  * 12：按月支付。\n\n**basis** 可选参数，整型标量或向量，与 *settlement* 等长，表示要使用的日计数基准类型。默认值为 1。可选值为：\n\n| Basis | 日计数基准            |\n| ----- | ---------------- |\n| 0     | US (NASD) 30/360 |\n| 1 或省略 | 实际/实际            |\n| 2     | 实际/360           |\n| 3     | 实际/365           |\n| 4     | 欧洲 30/360        |\n\n**bondType** 可选参数，整型标量或向量，表示输入的债券类型。默认值为 0。可选值为：\n\n* 0：固息债券，即定期（季度、半年或一年）按息票利率支付利息。\n\n* 1：贴现债券，即没有利息支付，以贴现方式发行的债券，期末 FV=面值。\n\n* 2：零息债券，即期末一次性支付利息和面值，期末 FV=面值+利息。\n\n#### 例子\n\n现计算 2022 年 9 月 28 日购买，到期日分别是 2023 年 9 月 28 日和 2024 年 9 月 28 日的两个固息债券的现金流。其年息票利率均为 0.025，付息频率为每 3 个月一次，日计数基准为实际/实际。\n\n```\nsettlement=2022.09.28\nmaturity=[2023.09.28, 2024.09.28]\ncoupon=0.025\nfrequency=4\nbasis=1\nbondCashflow(settlement, maturity, coupon, frequency, basis)；\n\n/* output\n\n[[0.625,0.625,0.625,100.625],[0.625,0.625,0.625,0.625,0.625,0.625,0.625,100.625]]\n\n*/\n```\n"
    },
    "bondConvexity": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bondconvexity.html",
        "signatures": [
            {
                "full": "bondConvexity(settlement, maturity, coupon, yield, [frequency], [basis=1], [bondType=0])",
                "name": "bondConvexity",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "coupon",
                        "name": "coupon"
                    },
                    {
                        "full": "yield",
                        "name": "yield"
                    },
                    {
                        "full": "[frequency]",
                        "name": "frequency",
                        "optional": true
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[bondType=0]",
                        "name": "bondType",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [bondConvexity](https://docs.dolphindb.cn/zh/funcs/b/bondconvexity.html)\n\n\n\n#### 语法\n\nbondConvexity(settlement, maturity, coupon, yield, \\[frequency], \\[basis=1], \\[bondType=0])\n\n别名：fiConvexity\n\n#### 详情\n\n返回定期付息的面值为 100 的有价证券的债券凸性。凸性指债券价格与利率间非线性关系的一种量度，表示为债券价格对利率的二阶导数。\n\n返回值：DOUBLE 类型的标量或向量。\n\n#### 参数\n\n* **settlement** 是 DATE 类型标量或向量，表示有价证券的结算日，即购买日期。\n* **maturity** 是 DATE 类型标量或向量，与 *settlement* 等长，表示有价证券的到期日（有价证券有效期截止时的日期）。\n* **coupon** 是数值型标量或向量，表示有价证券的年息票利率。\n* **yield** 是数值型标量或向量，表示有价证券的年收益率。\n* **frequency** 是整型标量或向量，表示年付息次数。当参数 *bondType*（详见后文介绍）指定为 1 或 2 时无需指定此参数，*bondType* 为 0 或省略时则必须指定此参数。可选值为：\n  * 1：按年支付；\n  * 2：按半年期支付；\n  * 4：按季支付；\n  * 12：按月支付。\n* **basis**为可选参数，是整型标量或向量，表示要使用的日计数基准类型。可选值为：\n\n| Basis | 日计数基准            |\n| ----- | ---------------- |\n| 0     | US (NASD) 30/360 |\n| 1 或省略 | 实际/实际            |\n| 2     | 实际/360           |\n| 3     | 实际/365           |\n| 4     | 欧洲 30/360        |\n\n* **bondType** 可选参数，整型标量或向量，表示债券的类型。可选值为 0, 1, 2，默认值为 0 。\n\n* * 0：固息债券，定期（季度、半年或一年）按息票利率支付利息；\n\n* 1：贴现债券，没有利息支付，以贴现方式发行的债券，期末FV=面值。\n\n* 2：零息债券，期末一次性支付利息和面值，期末FV=面值+利息；\n\n注意：如果以上参数是向量，则长度必须一致。\n\n#### 例子\n\n现计算 2023 年 1 月 1 日购买，2030 年 12 月 31 日到期的债券的凸度。其年息票利率为 0.05，预计收益率为 0.06，付息频率为每年一次，日计数基准为实际/实际。\n\n```\nbondConvexity(settlement=2023.01.01, maturity=2030.12.31, coupon=0.05, yield=0.06, frequency=1, basis=1)\n// output\n50.78238914091385\n```\n"
    },
    "bondDirtyPrice": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bondDirtyPrice.html",
        "signatures": [
            {
                "full": "bondDirtyPrice(settlement, maturity, coupon, yield, [frequency], [basis=1], [bondType=0])",
                "name": "bondDirtyPrice",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "coupon",
                        "name": "coupon"
                    },
                    {
                        "full": "yield",
                        "name": "yield"
                    },
                    {
                        "full": "[frequency]",
                        "name": "frequency",
                        "optional": true
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[bondType=0]",
                        "name": "bondType",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [bondDirtyPrice](https://docs.dolphindb.cn/zh/funcs/b/bondDirtyPrice.html)\n\n\n\n#### 语法\n\nbondDirtyPrice(settlement, maturity, coupon, yield, \\[frequency], \\[basis=1], \\[bondType=0])\n\n别名：fiDirtyPrice\n\n#### 详情\n\n返回定期付息的面值 100 的有价证券的含息价格。\n\n#### 参数\n\n* **settlement** DATE 类型标量或向量，表示有价证券的结算日，即购买日期。\n\n* **maturity** DATE 类型标量或向量，与 *settlement* 等长，表示有价证券的到期日（有价证券有效期截止时的日期）。\n\n* **coupon** 数值型标量或向量，表示有价证券的年息票利率。\n\n* **yield** 数值型标量或向量，表示有价证券的年收益率。\n\n* **frequency** 整型标量或向量，表示年付息次数。当参数 *bondType*（详见后文介绍）指定为 1 或 2 时无需指定此参数，*bondType* 为 0 或省略时则必须指定此参数。可选值为：\n  * 1：按年支付；\n  * 2：按半年期支付；\n  * 4：按季支付；\n  * 12：按月支付。\n\n* **basis** 可选参数，整型标量或向量，表示要使用的日计数基准类型。可选值为：\n\n| Basis | 日计数基准            |\n| ----- | ---------------- |\n| 0     | US (NASD) 30/360 |\n| 1或省略  | 实际/实际            |\n| 2     | 实际/360           |\n| 3     | 实际/365           |\n| 4     | 欧洲 30/360        |\n\n* **bondType** 可选参数，整型标量或向量，表示债券的类型。可选值为 0, 1, 2，默认值为 0 。\n  * 0：固息债券，定期（季度、半年或一年）按息票利率支付利息；\n  * 1：贴现债券，没有利息支付，以贴现方式发行的债券，期末FV=面值。\n  * 2：零息债券，期末一次性支付利息和面值，期末FV=面值+利息；\n\n注意：如果以上参数是向量，则长度必须一致。\n\n#### 例子\n\n假设有一张债券，发行日期为 2023年1月1日，到期日期为 2030年12月31日，年息票利率为 5%，预期收益率为 6%，每年付息 2 次（半年付息），以实际/实际为日计数基准。\n\n```\nbondDirtyPrice(settlement=2023.01.01,maturity=2030.12.31,coupon=0.05,yield=0.06,frequency=2,basis=1)\n```\n\n返回：93.73475540066079\n"
    },
    "bondDuration": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bondDuration.html",
        "signatures": [
            {
                "full": "bondDuration(settlement, maturity, coupon, yield, [frequency], [basis=1], [bondType=0])",
                "name": "bondDuration",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "coupon",
                        "name": "coupon"
                    },
                    {
                        "full": "yield",
                        "name": "yield"
                    },
                    {
                        "full": "[frequency]",
                        "name": "frequency",
                        "optional": true
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[bondType=0]",
                        "name": "bondType",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [bondDuration](https://docs.dolphindb.cn/zh/funcs/b/bondDuration.html)\n\n\n\n#### 语法\n\nbondDuration(settlement, maturity, coupon, yield, \\[frequency], \\[basis=1], \\[bondType=0])\n\n别名：fiDuration\n\n#### 详情\n\n返回面值为 100 的有价证券的一个 Macauley 久期。 久期定义为现金流现值的加权平均值，并用作债券价格对收益率变化的响应的度量值。\n\n返回值：DOUBLE 类型的标量或向量。\n\n#### 参数\n\n* **settlement** DATE 类型标量或向量，表示有价证券的结算日，即购买日期。\n\n* **maturity** DATE 类型标量或向量，与 *settlement* 等长，表示有价证券的到期日（有价证券有效期截止时的日期）。\n\n* **coupon** 数值型标量或向量，表示有价证券的年息票利率。\n\n* **yield** 数值型标量或向量，表示有价证券的年收益率。\n\n* **frequency** 整型标量或向量，表示年付息次数。当参数 *bondType*（详见后文介绍）指定为 1 或 2 时无需指定此参数，*bondType* 为 0 或省略时则必须指定此参数。 可选值为：\n  * 1：按年支付；\n  * 2：按半年期支付；\n  * 4：按季支付；\n  * 12：按月支付。\n\n* **basis** 可选参数，整型标量或向量，表示要使用的日计数基准类型。可选值为：\n\n| Basis | 日计数基准            |\n| ----- | ---------------- |\n| 0     | US (NASD) 30/360 |\n| 1或省略  | 实际/实际            |\n| 2     | 实际/360           |\n| 3     | 实际/365           |\n| 4     | 欧洲 30/360        |\n\n* **bondType** 可选参数，整型标量或向量，表示债券的类型。可选值为 0, 1, 2，默认值为 0 。\n  * 0：固息债券，定期（季度、半年或一年）按息票利率支付利息；\n  * 1：贴现债券，没有利息支付，以贴现方式发行的债券，期末FV=面值。\n  * 2：零息债券，期末一次性支付利息和面值，期末FV=面值+利息；\n\n注意：如果以上参数是向量，则长度必须一致。\n\n#### 例子\n\n现计算 2023年1月1日 购买，2030年12月31日 到期的债券的久期。其年息票利率为 0.05，预计收益率为 0.06，付息频率为每年一次，日计数基准为实际/实际。\n\n```\nbondDuration(settlement=2023.01.01, maturity=2030.12.31, coupon=0.05, yield=0.06, frequency=1, basis=1)\n```\n\n返回：6.737695071685634\n"
    },
    "bondYield": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bondyield.html",
        "signatures": [
            {
                "full": "bondYield(settlement, maturity, coupon, price, redemption, frequency, [basis=1], [method='newton'], [maxIter])",
                "name": "bondYield",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "coupon",
                        "name": "coupon"
                    },
                    {
                        "full": "price",
                        "name": "price"
                    },
                    {
                        "full": "redemption",
                        "name": "redemption"
                    },
                    {
                        "full": "frequency",
                        "name": "frequency"
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[method='newton']",
                        "name": "method",
                        "optional": true,
                        "default": "'newton'"
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [bondYield](https://docs.dolphindb.cn/zh/funcs/b/bondyield.html)\n\n\n\n#### 语法\n\nbondYield(settlement, maturity, coupon, price, redemption, frequency, \\[basis=1], \\[method='newton'], \\[maxIter])\n\n#### 详情\n\n通过债券净价（Clean Price）计算有价债券的收益率（Yield）。返回 DOUBLE 类型的标量或向量。注意：\n\n* 如果结算日（settlement）距离到期日（maturity）不足一个票息期（coupon period），则收益率按以下方式计算：\n\n![](https://docs.dolphindb.cn/zh/tutorials/images/yield.png)\n\n* 部分参数说明：\n  * A：票息期开始日至结算日之间的天数（应计利息天数）。\n\n  * DSR：从结算日期到赎回日期之间的天数。\n\n  * E ：一个票息期内的天数。\n\n* 如果在到期日之前有多个票息期，则通过牛顿法等优化算法迭代地调整收益率的值，使基于该收益率计算得到的债券净价接近用户输入的实际价格。本函数将收益率的初值设置为年息票利率（Annual Coupon Rate）。\n\n#### 参数\n\n**settlement** DATE 类型标量或向量，表示有价证券的结算日，即购买日期。\n\n**maturity** DATE 类型标量或向量，非负数，表示有价证券的到期日（有价证券有效期截止时的日期）。\n\n**coupon** 数值型标量或向量，表示有价证券的年息票利率。\n\n**price** 数值型标量或向量，表示有价证券净价（按面值为 ￥100 计算）。\n\n**redemption** 数值型标量或向量，表示面值 ￥100 的有价证券的清偿价格。\n\n**frequency** 整型标量或向量，表示年付息次数。可选值为：\n\n* 1：按年支付。\n\n* 2：按半年期支付。\n\n* 4：按季支付。\n\n* 12：按月支付。\n\n**basis** 可选参数，整型标量或向量，与 *settlement* 等长，表示要使用的日计数基准类型。默认值为 1。可选值为：\n\n| Basis | 日计数基准            |\n| ----- | ---------------- |\n| 0     | US (NASD) 30/360 |\n| 1     | 实际/实际            |\n| 2     | 实际/360           |\n| 3     | 实际/365           |\n| 4     | 欧洲 30/360        |\n\n**method**可选参数，字符串标量或向量，表示求解收益率所使用的优化算法，可选值为：\n\n* “newton“：表示使用 Newton 算法，默认值。\n\n* “brent“：表示使用 brent 算法。\n\n* “nm“：表示使用 Nelder-Mead 单纯形算法。\n\n* “bfgs“：表示使用 bfgs 算法。\n\n* “lbfgs“ ：表示使用 lbfgs 算法。\n\n**maxIter** 可选参数，整型标量或向量，表示求解收益率时优化算法的最大迭代次数。默认值为 100。\n\n注意：如果输入参数中部分为标量，其余为向量时，则会将标量当作与向量长度相同，所有元素值等于该标量的向量。所有向量的长度必须一致。\n\n#### 例子\n\n假设有一张净价为 95.04287 的债券，交易日期为 2008年2月15日，到期日期为 2016年11月15日，年息票利率为 5.75%，债券赎回价格为 100 元，每年付息 2 次（半年付息），以 US (NASD) 30/360 为日计数基准，分别使用 'newton', 'nm', 'brentq', 'bfgs','lbfgs' 优化算法计算其收益率。\n\n```\nsettlement = 2008.02.15\nmaturity = 2016.11.15\ncoupon = 0.0575\nprice = 95.04287\nredemption = 100\nfrequency = 2\nbasis = 0\nmethod = ['newton', 'nm', 'brentq', 'bfgs','lbfgs']\nbondYield(settlement, maturity, coupon, price, redemption, frequency, basis, method)\n// Output:[0.065000006880755,0.064999847412109,0.065000006880759,0.064999999976412,0.065000004967984]\n```\n\n**相关函数**：[bondDirtyPrice](https://docs.dolphindb.cn/zh/funcs/b/bondDirtyPrice.html)\n"
    },
    "bool": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bool.html",
        "signatures": [
            {
                "full": "bool(X)",
                "name": "bool",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [bool](https://docs.dolphindb.cn/zh/funcs/b/bool.html)\n\n\n\n#### 语法\n\nbool(X)\n\n#### 详情\n\n把输入转换为布尔值。\n\n#### 参数\n\n**X** 可以是任意的数据类型。\n\n#### 例子\n\n```\nx=bool();\nx;\n```\n\n返回：null\n\n```\ntypestr x;\n```\n\n返回：BOOL\n\n```\nbool(`true);\n```\n\n返回：true\n\n```\nbool(`false);\n```\n\n返回：false\n\n```\nbool(`true`false)\n```\n\n返回：\\[true, false]\n\n```\nbool(100.2);\n```\n\n返回：true\n\n```\nbool(0);\n```\n\n返回：false\n"
    },
    "brentq": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/brentq.html",
        "signatures": [
            {
                "full": "brentq(f, a, b, [xtol], [rtol], [maxIter], [funcDataParam])",
                "name": "brentq",
                "parameters": [
                    {
                        "full": "f",
                        "name": "f"
                    },
                    {
                        "full": "a",
                        "name": "a"
                    },
                    {
                        "full": "b",
                        "name": "b"
                    },
                    {
                        "full": "[xtol]",
                        "name": "xtol",
                        "optional": true
                    },
                    {
                        "full": "[rtol]",
                        "name": "rtol",
                        "optional": true
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[funcDataParam]",
                        "name": "funcDataParam",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [brentq](https://docs.dolphindb.cn/zh/funcs/b/brentq.html)\n\n\n\n#### 语法\n\nbrentq(f, a, b, \\[xtol], \\[rtol], \\[maxIter], \\[funcDataParam])\n\n#### 参数\n\n**f** 是一个返回值为一个数值的函数。函数在 \\[a, b] 内连续且 f(a) 与 f(b) 的正负号需要相反。\n\n**a** 是一个数值标量，指定区间的左边界。\n\n**b** 是一个数值标量，指定区间的右边界。\n\n**xtol** 是一个数值标量，用于指定求解结果的精度，默认值为 2e-12。\n\n**rtol** 是一个数值标量，用于指定求解结果的精度，默认值为 4 倍的 DOUBLE 类型的机器精度。\n\n**maxIter** 是一个整形标量，指定 Brent 的最大迭代次数，默认值为 100 。\n\n**funcDataParam** 是一个向量，指定函数 f 的其他参数。\n\n#### 详情\n\n使用 Brent 方法在一个给定区间 \\[a, b] 内求出函数 f(x) 的一个根 x0，使得 f(x0)=0 ，求解精度满足 `|x-x0| <= (xtol + rtol* |x0| )`，其中 x 是精确根，x0 为计算结果。\n\n返回值为长度为2的向量 res：\n\n* res\\[0] 是一个字符串标量，表示求解状态。共有三种求解状态：\n  * CONVERGED， 表示得到符合预期的解；\n  * SIGNERR，表示 f(a) 与 f(b) 同号，不满足正负号相反的要求；\n  * CONVERR，表示达到最大迭代次数\n* res\\[1] 是一个数值标量，表示求得的根。\n\n#### 例子\n\n求解 f(x) = x^2 - 1 在 \\[-2,0], \\[0,2] 的根\n\n```\ndef f(x) {\n    return (pow(x, 2) - 1)\n}\n\nroot1 = brentq(f, -2, 0)\nroot2 = brentq(f, 0, 2)\nprint(\"root1 : \", root1)\nprint(\"root2 : \", root2)\n```\n\n返回如下：\n\n```\nroot1 :\n(\"CONVERGED\",-1)\nroot2 :\n(\"CONVERGED\",1)\n```\n\n求解带有额外参数的函数 f(x,b) 在 \\[0,2] 的根：\n\n```\ndef f(x, b) {\n    return (pow(x, 2) - b)\n}\nroot = brentq(f, 0, 2, 2e-12, 1e-9, 100, [2])\nprint(\"root : \", root)\n```\n\n返回如下：\n\n```\nroot : \n(\"CONVERGED\",1.414213562373136)\n```\n"
    },
    "brute": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/brute.html",
        "signatures": [
            {
                "full": "brute(func, ranges, [ns=20], [finish=fmin])",
                "name": "brute",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "ranges",
                        "name": "ranges"
                    },
                    {
                        "full": "[ns=20]",
                        "name": "ns",
                        "optional": true,
                        "default": "20"
                    },
                    {
                        "full": "[finish=fmin]",
                        "name": "finish",
                        "optional": true,
                        "default": "fmin"
                    }
                ]
            }
        ],
        "markdown": "### [brute](https://docs.dolphindb.cn/zh/funcs/b/brute.html)\n\n\n\n#### 语法\n\nbrute(func, ranges, \\[ns=20], \\[finish=fmin])\n\n#### 详情\n\n通过穷举法在给定范围内最小化一个函数。穷举法使用网格搜索，即计算多维网格点上每个点处的函数值，以找到函数的全局最小值。\n\n注意：穷举法效率低下，其原因是网格点的数量呈指数级增加。因此，即使网格间距较粗、或者问题仅为中等大小等情况，也可能需要很长的运行时间，还可能遇到内存限制。\n\n#### 参数\n\n**func** 函数名，表示需要最小化的目标函数。注意：其返回值须是数值标量类型。\n\n**ranges** 元组类型，表示每个参数分量的数值范围。*ranges* 中每个元素为形如`(low, high)`或`(low, high, num)`的元组。其中 `low` 和 `high` 都是数值类型，`low` 表示该参数分量的最低取值，`high` 表示该参数分量的最高取值；`num` 为正整数，表示沿轴线的网格点数量，即该参数分量在范围内的取值个数。\n\n**ns** 可选参数，正整数标量，表示沿轴线的网格点数量。优先取 *ranges* 元素`(low, high, num)`中的 `num` 值；若 *ranges*中未设置\\*，\\*则 `num` 为 *ns*。该参数默认值为 20。\n\n**finish** 可选参数，函数名，表示一个优化函数。其输入需满足 `finish(func, X)`；输出应返回一个字典，包含键`\"xopt\"`和`\"fopt\"`，且值为数值类型。默认值为函数 `fmin`。将穷举法网格搜索的结果作为初始猜测，使用该函数对目标函数进行优化。注意：也可传入“NULL”，表示直接返回穷举法网格搜索的结果，不进行优化。\n\n#### 返回值\n\n返回一个字典，字典有以下成员：\n\n* xopt：浮点数向量，使目标函数最小化的参数值。\n* fopt：浮点数标量，目标函数最小值。fopt=func(xopt)。\n\n#### 例子\n\n以下自定义一个函数 `f`，传入指定 *ranges* 和 *ns* 值，计算 `f` 函数在 *ranges* 内最小化的参数值和对应的最小值。\n\n```\ndef f(z) {\n\ta = 2\n\tb = 3\n\tc = 7\n\td = 8\n\tee = 9\n\tf = 10\n\tg = 44\n\th = -1\n\ti = 2\n\tj = 26\n\tk = 1\n\tl = -2\n\tscale = 0.5\n\tx = z[0]\n\ty = z[1]\n\tf1 = a * square(x) + b * x * y + c * square(y) + d * x + ee* y + f\n\tf2 = -g * exp(-(square(x-h)+square(y-i)) / scale)\n\tf3 =  -j * exp(-(square(x-k)+square(y-l)) / scale)\n\treturn f1+f2+f3\n}\nranges=((-4, 3.75),(-4, 3.75))\nbrute(f, ranges, 32)\n\n/* Ouput:\n\nfopt->-3.408581876799\nxopt->[-1.056651921797,1.808348429512]\n\n*/\n```\n"
    },
    "bucket": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bucket.html",
        "signatures": [
            {
                "full": "bucket(vector, dataRange, bucketNum, [includeOutbound=false])",
                "name": "bucket",
                "parameters": [
                    {
                        "full": "vector",
                        "name": "vector"
                    },
                    {
                        "full": "dataRange",
                        "name": "dataRange"
                    },
                    {
                        "full": "bucketNum",
                        "name": "bucketNum"
                    },
                    {
                        "full": "[includeOutbound=false]",
                        "name": "includeOutbound",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [bucket](https://docs.dolphindb.cn/zh/funcs/b/bucket.html)\n\n\n\n#### 语法\n\nbucket(vector, dataRange, bucketNum, \\[includeOutbound=false])\n\n#### 参数\n\n**vector** 一个数值或时间向量。\n\n**dataRange** 表示数据范围的数据对。包括下限值，不包括上限值。\n\n**bucketNum** 桶的数量。输入向量中在 *dataRange* 的范围内的元素个数，必须是 *bucketNum* 的倍数。\n\n**includeOutbound** 一个可选的布尔值，表明是否包括小于下限的值，以及大于或等于上限的值。默认值为 false。\n\n#### 详情\n\n返回一个和 *vector* 相同长度的向量，表明根据 *dataRange* 和 *bucketNum* 所给出的分类规则，每一个元素应该属于哪个桶。\n\n例如，*dataRange* 是 0:10，*bucketNum* 是 2，则两个桶分别是 \\[0, 5) 和 \\[5, 10)，桶的编号分别为0和1。如果 *includeOutbound* 为true，这个例子会产生 4 个桶，即 <0, \\[0, 5), \\[5,10) 和 >=10。如果 *includeOutbound* 为false，任何小于下限或大于等于上限的值会返回 NULL。\n\n#### 例子\n\n```\nbucket(9 23 54 36 46 12, 12:54, 2);\n// output\n[,0,,1,1,0]\n\nbucket(9 23 54 36 46 12, 12:54, 2, 1);\n// output\n[0,1,3,2,2,1]\n```\n"
    },
    "bucketCount": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/bucketCount.html",
        "signatures": [
            {
                "full": "bucketCount(vector, dataRange, bucketNum, [includeOutbound=false])",
                "name": "bucketCount",
                "parameters": [
                    {
                        "full": "vector",
                        "name": "vector"
                    },
                    {
                        "full": "dataRange",
                        "name": "dataRange"
                    },
                    {
                        "full": "bucketNum",
                        "name": "bucketNum"
                    },
                    {
                        "full": "[includeOutbound=false]",
                        "name": "includeOutbound",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [bucketCount](https://docs.dolphindb.cn/zh/funcs/b/bucketCount.html)\n\n\n\n#### 语法\n\nbucketCount(vector, dataRange, bucketNum, \\[includeOutbound=false])\n\n#### 参数\n\n**vector** 一个数值或时间向量。\n\n**dataRange** 一对表示数据返回的值，包括下限，不包括上限。\n\n**bucketNum** 桶的数量。输入向量中在 *dataRange* 的范围内的元素个数必须是 *bucketNum* 的倍数。\n\n**includeOutbound** 一个可选的布尔值，表明是否包括小于下限的值，和大于等于上限的值。默认值为 false。\n\n#### 详情\n\n函数 `bucketCount` 有和 [bucket](https://docs.dolphindb.cn/zh/funcs/b/bucket.html) 相同的参数，但是返回每个桶中元素的计数。\n\n#### 例子\n\n```\nbucketCount(9 23 54 36 46 12, 12:54, 2);\n// output\n[2,2]\n\nbucketCount(9 23 54 36 46 12, 12:54, 2, 1);\n// output\n[1,2,2,1]\n```\n"
    },
    "businessDay": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/businessDay.html",
        "signatures": [
            {
                "full": "businessDay(X, [offset], [n=1])",
                "name": "businessDay",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessDay](https://docs.dolphindb.cn/zh/funcs/b/businessDay.html)\n\n\n\n#### 语法\n\nbusinessDay(X, \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n如果 *X* 所在的日期是工作日（周一到周五），返回 *X* 的日期，反之返回 *X* 最近的工作日。\n\n如果指定了*offset*，表示从 *offset* 开始，结果每隔 *n* 个工作日更新一次。注意，只有当 *n*>1时，*offset* 才会生效。\n\n#### 例子\n\n```\nbusinessDay(2019.01.06);\n// output\n2019.01.04\n\nbusinessDay(2019.01.04);\n// output\n2019.01.04\n\ndate=2019.01.06 + 1..10\nbusinessDay = businessDay(date)\nbusinessDay2 = businessDay(date,min(date),2)\ntable(date, businessDay, businessDay2);\n```\n\n| date       | businessDay | businessDay2 |\n| ---------- | ----------- | ------------ |\n| 2019.01.07 | 2019.01.07  | 2019.01.07   |\n| 2019.01.08 | 2019.01.08  | 2019.01.07   |\n| 2019.01.09 | 2019.01.09  | 2019.01.09   |\n| 2019.01.10 | 2019.01.10  | 2019.01.09   |\n| 2019.01.11 | 2019.01.11  | 2019.01.11   |\n| 2019.01.12 | 2019.01.11  | 2019.01.11   |\n| 2019.01.13 | 2019.01.11  | 2019.01.11   |\n| 2019.01.14 | 2019.01.14  | 2019.01.11   |\n| 2019.01.15 | 2019.01.15  | 2019.01.15   |\n| 2019.01.16 | 2019.01.16  | 2019.01.15   |\n"
    },
    "businessMonthBegin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/businessMonthBegin.html",
        "signatures": [
            {
                "full": "businessMonthBegin(X, [offset], [n=1])",
                "name": "businessMonthBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessMonthBegin](https://docs.dolphindb.cn/zh/funcs/b/businessMonthBegin.html)\n\n\n\n#### 语法\n\nbusinessMonthBegin(X, \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在月份的第一个工作日（周一到周五）\n\n如果指定了*offset*，表示从 *offset* 开始，结果每隔 *n* 月更新一次。注意，只有当 *n*>1时，*offset* 才会生效。\n\n#### 例子\n\n```\nbusinessMonthBegin(2018.09.12);\n// output\n2018.09.03\n\nbusinessMonthBegin(2018.09.12, 2018.07.12, 3);\n// output\n2018.07.02\n\ndate=2016.04.12+(1..10)*30\ntime = take(09:30:00, 10)\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2016.05.12 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2016.06.11 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2016.07.11 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2016.08.10 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.09.09 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2016.10.09 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2016.11.08 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2016.12.08 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2017.01.07 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2017.02.06 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by businessMonthBegin(date,2016.01.01,2);\n```\n\n| businessMonthBegin\\_date | avg\\_price | sum\\_qty |\n| ------------------------ | ---------- | -------- |\n| 2016.05.02               | 39.53      | 4100     |\n| 2016.07.01               | 29.77      | 5300     |\n| 2016.09.01               | 175.1      | 12200    |\n| 2016.11.01               | 50.54      | 3800     |\n| 2017.01.02               | 51.835     | 13300    |\n\n相关函数：[businessMonthEnd](https://docs.dolphindb.cn/zh/funcs/b/businessMonthEnd.html), [monthBegin](https://docs.dolphindb.cn/zh/funcs/m/monthBegin.html), [monthEnd](https://docs.dolphindb.cn/zh/funcs/m/monthEnd.html), [semiMonthBegin](https://docs.dolphindb.cn/zh/funcs/s/semiMonthBegin.html), [semiMonthEnd](https://docs.dolphindb.cn/zh/funcs/s/semiMonthEnd.html)\n"
    },
    "businessMonthEnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/businessMonthEnd.html",
        "signatures": [
            {
                "full": "businessMonthEnd(X, [offset], [n=1])",
                "name": "businessMonthEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessMonthEnd](https://docs.dolphindb.cn/zh/funcs/b/businessMonthEnd.html)\n\n\n\n#### 语法\n\nbusinessMonthEnd(X, \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在月份的最后一个工作日（周一到周五）。\n\n如果指定了*offset*，表示从 *offset* 开始，结果每隔 *n* 月更新一次。注意，只有当 *n*>1 时，*offset* 才会生效。\n\n#### 例子\n\n```\nbusinessMonthEnd(2010.10.12);\n// output\n2010.10.29\n\nbusinessMonthEnd(2010.10.12, 2000.03.31, 3);\n// output\n2010.12.31\n\ndate=2016.04.12+(1..10)*30\ntime = take(09:30:00, 10)\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2016.05.12 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2016.06.11 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2016.07.11 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2016.08.10 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.09.09 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2016.10.09 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2016.11.08 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2016.12.08 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2017.01.07 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2017.02.06 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by businessMonthEnd(date,2016.01.31,2);\n```\n\n| businessMonthEnd\\_date | avg\\_price | sum\\_qty |\n| ---------------------- | ---------- | -------- |\n| 2016.06.30             | 39.53      | 4100     |\n| 2016.08.31             | 29.77      | 5300     |\n| 2016.10.31             | 175.1      | 12200    |\n| 2016.12.30             | 50.54      | 3800     |\n| 2017.02.28             | 51.835     | 13300    |\n\n相关函数：[businessMonthBegin](https://docs.dolphindb.cn/zh/funcs/b/businessMonthBegin.html), [monthBegin](https://docs.dolphindb.cn/zh/funcs/m/monthBegin.html), [monthEnd](https://docs.dolphindb.cn/zh/funcs/m/monthEnd.html), [semiMonthBegin](https://docs.dolphindb.cn/zh/funcs/s/semiMonthBegin.html), [semiMonthEnd](https://docs.dolphindb.cn/zh/funcs/s/semiMonthEnd.html)\n"
    },
    "businessQuarterBegin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/businessQuarterBegin.html",
        "signatures": [
            {
                "full": "businessQuarterBegin(X, [startingMonth=1], [offset], [n=1])",
                "name": "businessQuarterBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessQuarterBegin](https://docs.dolphindb.cn/zh/funcs/b/businessQuarterBegin.html)\n\n\n\n#### 语法\n\nbusinessQuarterBegin(X, \\[startingMonth=1], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**startingMonth** 是1到12之间的整数，表示一年的起始月份。默认值是1。\n\n**offset** 是与 **X** 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在季度的第一个工作日（周一到周五）。\n\n如果指定了*offset*，表示从 *offset* 开始，结果每隔 *n* 个季度更新一次。注意，只有当 *n*>1 时，*offset* 才会生效。\n\n#### 例子\n\n```\nbusinessQuarterBegin(2012.06.12);\n// output\n2012.04.02\n\nbusinessQuarterBegin(2012.06.12, 3);\n// output\n2012.06.01\n\nbusinessQuarterBegin(2012.06.12, 8, 2011.08.01, 3);\n// output\n2012.05.01\n\ndate=2011.04.25+(1..10)*90\ntime = take(09:30:00, 10)\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2011.07.24 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2011.10.22 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2012.01.20 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2012.04.19 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2012.07.18 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2012.10.16 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2013.01.14 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2013.04.14 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2013.07.13 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2013.10.11 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by businessQuarterBegin(date, 10, 2010.10.01, 2);\n```\n\n| businessQuarterBegin\\_date | avg\\_price | sum\\_qty |\n| -------------------------- | ---------- | -------- |\n| 2011.04.01                 | 49.6       | 2200     |\n| 2011.10.03                 | 29.49      | 4000     |\n| 2012.04.02                 | 102.495    | 10000    |\n| 2012.10.01                 | 112.995    | 6700     |\n| 2013.04.01                 | 50.805     | 11300    |\n| 2013.10.01                 | 52.38      | 4500     |\n\n相关函数：[businessQuarterEnd](https://docs.dolphindb.cn/zh/funcs/b/businessQuarterEnd.html), [quarterBegin](https://docs.dolphindb.cn/zh/funcs/q/quarterBegin.html), [quarterEnd](https://docs.dolphindb.cn/zh/funcs/q/quarterEnd.html)\n"
    },
    "businessQuarterEnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/businessQuarterEnd.html",
        "signatures": [
            {
                "full": "businessQuarterEnd(X, [endingMonth=12], [offset], [n=1])",
                "name": "businessQuarterEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[endingMonth=12]",
                        "name": "endingMonth",
                        "optional": true,
                        "default": "12"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessQuarterEnd](https://docs.dolphindb.cn/zh/funcs/b/businessQuarterEnd.html)\n\n\n\n#### 语法\n\nbusinessQuarterEnd(X, \\[endingMonth=12], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**startingMonth** 是1到12之间的整数，表示一年的结束月份。默认值是12。\n\n**offset** 是与 **X** 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在季度的最后一个工作日（周一到周五）。\n\n如果指定了*offset*，表示从 *offset* 开始，结果每隔 *n* 个季度更新一次。注意，只有当 *n*>1 时，offset 才会生效。\n\n#### 例子\n\n```\nbusinessQuarterEnd(2012.04.12);\n// output\n2012.06.30\n\nbusinessQuarterEnd(2012.04.12, 2);\n// output\n2012.05.31\n\nbusinessQuarterEnd(2012.04.12, 8, 2011.08.01, 3);\n// output\n2012.05.31\n\ndate=2011.04.25+(1..10)*90\ntime = take(09:30:00, 10)\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2011.07.24 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2011.10.22 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2012.01.20 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2012.04.19 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2012.07.18 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2012.10.16 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2013.01.14 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2013.04.14 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2013.07.13 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2013.10.11 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by businessQuarterEnd(date, , 2010.06.01, 2)\n```\n\n| businessQuarterEnd\\_date | avg\\_price | sum\\_qty |\n| ------------------------ | ---------- | -------- |\n| 2011.12.30               | 39.53      | 4100     |\n| 2012.06.29               | 29.77      | 5300     |\n| 2012.12.31               | 175.1      | 12200    |\n| 2013.06.28               | 50.54      | 3800     |\n| 2013.12.31               | 51.835     | 13300    |\n\n相关函数：[businessQuarterBegin](https://docs.dolphindb.cn/zh/funcs/b/businessQuarterBegin.html), [quarterBegin](https://docs.dolphindb.cn/zh/funcs/q/quarterBegin.html), [quarterEnd](https://docs.dolphindb.cn/zh/funcs/q/quarterEnd.html)\n"
    },
    "businessYearBegin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/businessYearBegin.html",
        "signatures": [
            {
                "full": "businessYearBegin(X, [startingMonth=1], [offset], [n=1])",
                "name": "businessYearBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessYearBegin](https://docs.dolphindb.cn/zh/funcs/b/businessYearBegin.html)\n\n\n\n#### 语法\n\nbusinessYearBegin(X, \\[startingMonth=1], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**startingMonth** 是1到12之间的整数，表示一年的起始月份。默认值是1。\n\n**offset** 是与 **X** 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回最近一个小于等于 *X* 的年度首个工作日（周一到周五）。\n\n如果指定了*offset*，表示从 *offset* 开始，结果每隔 *n* 年更新一次。注意，只有当 *n*> 1时，*offset* 才会生效。\n\n#### 例子\n\n```\nbusinessYearBegin(2012.06.12);\n// output\n2012.01.02\n\nbusinessYearBegin(2022.01.01);\n// output\n2021.01.01\n\nbusinessYearBegin(2012.06.13 10:10:10.008,5);\n// output\n2012.05.01\n\ndate=2011.10.25 2012.10.25 2013.10.25 2014.10.25 2015.10.25 2016.10.25 2017.10.25 2018.10.25 2019.10.25 2020.10.25\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by businessYearBegin(date,1,2011.10.01,2)\n```\n\n| businessYearBegin\\_date | avg\\_price | sum\\_qty |\n| ----------------------- | ---------- | -------- |\n| 2011.01.03              | 39.53      | 4100     |\n| 2013.01.01              | 29.77      | 5300     |\n| 2015.01.01              | 175.1      | 12200    |\n| 2017.01.02              | 50.54      | 3800     |\n| 2019.01.01              | 51.835     | 13300    |\n\n相关函数：[businessYearEnd](https://docs.dolphindb.cn/zh/funcs/b/businessYearEnd.html), [yearBegin](https://docs.dolphindb.cn/zh/funcs/y/yearBegin.html), [yearEnd](https://docs.dolphindb.cn/zh/funcs/y/yearEnd.html)\n"
    },
    "businessYearEnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/b/businessYearEnd.html",
        "signatures": [
            {
                "full": "businessYearEnd(X, [endingMonth=12], [offset], [n=1])",
                "name": "businessYearEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[endingMonth=12]",
                        "name": "endingMonth",
                        "optional": true,
                        "default": "12"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [businessYearEnd](https://docs.dolphindb.cn/zh/funcs/b/businessYearEnd.html)\n\n\n\n#### 语法\n\nbusinessYearEnd(X, \\[endingMonth=12], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**endingMonth** 是1到12之间的整数，表示一年的结束月份。默认值是12。\n\n**offset** 是与 **X** 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在年份的最后一个工作日（周一到周五）。\n\n如果指定了*offset*，表示从 *offset* 开始，结果每隔 *n* 年更新一次。注意，只有当 *n*>1 时，*offset* 才会生效。\n\n#### 例子\n\n```\nbusinessYearEnd(2012.06.12, 3);\n// output\n2013.03.29\n\nbusinessYearEnd(2012.06.12, 9);\n// output\n2012.09.28\n\nbusinessYearEnd(2012.06.12);\n// output\n2012.12.31\n\nbusinessYearEnd(2012.06.12, 12, 2009.04.03, 2);\n// output\n2013.12.31\n\ndate=2011.04.25+(1..10)*365\ntime = take(09:30:00, 10)\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2012.04.24 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2013.04.24 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2014.04.24 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2015.04.24 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.04.23 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2017.04.23 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2018.04.23 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2019.04.23 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2020.04.22 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2021.04.22 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by businessYearEnd(date, 4, 2010.04.01, 2);\n```\n\n| businessYearEnd\\_date | avg\\_price | sum\\_qty |\n| --------------------- | ---------- | -------- |\n| 2012.04.30            | 49.6       | 2200     |\n| 2014.04.30            | 29.49      | 4000     |\n| 2016.04.29            | 102.495    | 10000    |\n| 2018.04.30            | 112.995    | 6700     |\n| 2020.04.30            | 50.805     | 11300    |\n| 2022.04.29            | 52.38      | 4500     |\n\n相关函数：[businessYearBegin](https://docs.dolphindb.cn/zh/funcs/b/businessYearBegin.html), [yearBegin](https://docs.dolphindb.cn/zh/funcs/y/yearBegin.html), [yearEnd](https://docs.dolphindb.cn/zh/funcs/y/yearEnd.html)\n"
    },
    "cacheDSNow": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cacheDSNow.html",
        "signatures": [
            {
                "full": "cacheDSNow(ds)",
                "name": "cacheDSNow",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    }
                ]
            }
        ],
        "markdown": "### [cacheDSNow](https://docs.dolphindb.cn/zh/funcs/c/cacheDSNow.html)\n\n\n\n#### 语法\n\ncacheDSNow(ds)\n\n#### 参数\n\n**ds** 是数据源或数据源列表。\n\n#### 详情\n\n函数 `cacheDSNow` 立即执行并缓存数据源和缓存行的总数。\n\n#### 例子\n\n```\nPTNDB_DIR = \"/home/db_testing\"\ndbName = database(PTNDB_DIR + \"/NYSETAQByName\")\nTrades = dbName.loadTable(`Trades)\n\nds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\nds.cacheDSNow()        # cache the data immediately\nds.clearDSCacheNow()  # clear the cache immediately\n```\n"
    },
    "cacheDS!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cacheDS_.html",
        "signatures": [
            {
                "full": "cacheDS!(ds)",
                "name": "cacheDS!",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    }
                ]
            }
        ],
        "markdown": "### [cacheDS!](https://docs.dolphindb.cn/zh/funcs/c/cacheDS_.html)\n\n\n\n#### 语法\n\ncacheDS!(ds)\n\n#### 参数\n\n**ds** 是数据源或数据源列表。\n\n#### 详情\n\n函数 `cacheDS!` 会在下次执行，并缓存数据。它返回 true 或 false 表示此操作成功或失败。\n\n#### 例子\n\n```\nPTNDB_DIR = \"/home/db_testing\"\ndbName = database(PTNDB_DIR + \"/NYSETAQByName\")\nTrades = dbName.loadTable(`Trades)\n\nds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\nds.cacheDS!()        // cache the data\nds.clearDSCache!()  // clear the cache\n```\n"
    },
    "cachedTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cachedTable.html",
        "signatures": [
            {
                "full": "cachedTable(updateFunc, retentionSeconds)",
                "name": "cachedTable",
                "parameters": [
                    {
                        "full": "updateFunc",
                        "name": "updateFunc"
                    },
                    {
                        "full": "retentionSeconds",
                        "name": "retentionSeconds"
                    }
                ]
            }
        ],
        "markdown": "### [cachedTable](https://docs.dolphindb.cn/zh/funcs/c/cachedTable.html)\n\n\n\n#### 语法\n\ncachedTable(updateFunc, retentionSeconds)\n\n#### 参数\n\n**updateFunc** 是一个函数。它必须是无参数的，并且返回对象是一个表。\n\n**retentionSeconds** 是一个正整数，表示数据更新的时间间隔，单位是秒。\n\n#### 详情\n\n创建一种特殊类型的内存表：缓存表。如果查询缓存表的时间与上次数据更新时间相距等于或超过 *retentionSeconds* 秒，会自动执行 *updateFunc* 以更新缓存表。\n\n如果需要多线程访问缓存表，需要将缓存表共享。\n\n#### 例子\n\n下例定义一个一元函数 f1，在传入 cachedTable 时，需要通过部分应用的方式将 f1 转为无参数函数，即为 cachedTable 的 *updateFunc* 参数传入 f1{t}。\n\n```\ndef f1(mutable t){\n    update t set id=id+1\n    return t\n}\nt=table(1..5 as id, 15 25 35 45 55 as val)\nct=cachedTable(f1{t}, 2);\n\nselect * from ct;\n```\n\n| id | val |\n| -- | --- |\n| 2  | 15  |\n| 3  | 25  |\n| 4  | 35  |\n| 5  | 45  |\n| 6  | 55  |\n\n```\nsleep(2100)\nselect * from ct\n```\n\n| id | val |\n| -- | --- |\n| 3  | 15  |\n| 4  | 25  |\n| 5  | 35  |\n| 6  | 45  |\n| 7  | 55  |\n\n```\nct=NULL;\n```\n"
    },
    "cancelConsoleJob": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cancelConsoleJob.html",
        "signatures": [
            {
                "full": "cancelConsoleJob(rootJobId)",
                "name": "cancelConsoleJob",
                "parameters": [
                    {
                        "full": "rootJobId",
                        "name": "rootJobId"
                    }
                ]
            }
        ],
        "markdown": "### [cancelConsoleJob](https://docs.dolphindb.cn/zh/funcs/c/cancelConsoleJob.html)\n\n\n\n#### 语法\n\ncancelConsoleJob(rootJobId)\n\n#### 参数\n\n**rootJobId** 是作业的 ID，是一个字符串标量或者向量。若为向量，表示同时取消多个作业。\n\n#### 详情\n\n取消已经提交但是尚未完成的交互式任务。如果要取消批处理作业，请使用 [cancelJob](https://docs.dolphindb.cn/zh/funcs/c/cancelJob.html)。\n\n`cancelConsoleJob` 在当前正在执行的子任务完成后，才会取消任务。因此， `cancelConsoleJob` 并不是马上生效。如果 `cancelConsoleJob` 的对象是没有子任务的任务，该命令不生效。\n\n#### 例子\n\n在一个节点的某个会话中，执行以下代码：\n\n```\npt = loadTable(\"dfs://TAQ\", `quotes)\nselect count(*) from pt;\n```\n\n在同一个节点的其他会话中，使用 [getConsoleJobs](https://docs.dolphindb.cn/zh/funcs/g/getConsoleJobs.html) 获取要取消的交互式任务的 ID，然后使用 `cancelConsoleJob` 来取消该任务。\n\n```\ncancelConsoleJob(\"bf768327-776d-40a7-8a8d-00a6cfd054e3\");\n```\n"
    },
    "cancelJob": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cancelJob.html",
        "signatures": [
            {
                "full": "cancelJob(jobId)",
                "name": "cancelJob",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    }
                ]
            }
        ],
        "markdown": "### [cancelJob](https://docs.dolphindb.cn/zh/funcs/c/cancelJob.html)\n\n\n\n#### 语法\n\ncancelJob(jobId)\n\n#### 参数\n\n**jobId** 是批处理作业的 ID，是一个字符串标量或向量。若为向量，表示同时取消多个批处理作业。\n\n#### 详情\n\n取消已经提交但尚未完成的批处理作业。2.00.7 版本后，若执行 cancelJob 时，发现某个 jobId 不存在，系统不再抛出异常，而是将包含 jobId 的报错信息输出到日志。\n\n从 2.00.11 版本开始，系统对该操作进行了权限管理的增强。管理员（包括普通管理员和超级管理员）具有取消任何用户创建的批处理作业的权限，而普通用户只能取消自己创建的批处理作业。\n\n#### 例子\n\n```\ndef writeData(num){\n   n=10\n   month=take(2000.01M..2016.12M, n)\n   x=rand(1.0, n)\n   tt=table(month, x)\n   if(existsDatabase(\"dfs://test_db\")){\n       dropDatabase(\"dfs://test_db\")\n   }\n   db=database(\"dfs://test_db\", VALUE, 2000.01M..2016.12M)\n   pt = db.createPartitionedTable(tt, `pt, `month)\n   for(x in 1..num){\n       pt.append!(tt)\n       sleep(1000)\n   }\n}\n\nmyJobId=\"writeData\"+temporalFormat(datetime(now()),\"yyyyMMddHHmmss\")\nsubmitJob(myJobId,\"write data to dfs table\",writeData,120);\ncancelJob(myJobId);\n```\n\n取消集群中所有未完成的 job。\n\n```\ndef cancelAllBatchJob(){\n   jobids=exec jobid from getRecentJobs() where endTime=NULL\n   cancelJob(jobids)\n}\npnodeRun(cancelAllBatchJob)\n```\n"
    },
    "cancelPKEYCompactionTask": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cancelpkeycompactiontask.html",
        "signatures": [
            {
                "full": "cancelPKEYCompactionTask(chunkId)",
                "name": "cancelPKEYCompactionTask",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    }
                ]
            }
        ],
        "markdown": "### [cancelPKEYCompactionTask](https://docs.dolphindb.cn/zh/funcs/c/cancelpkeycompactiontask.html)\n\n\n\n#### 语法\n\ncancelPKEYCompactionTask(chunkId)\n\n#### 详情\n\n取消目标分区正在执行的 compaction 任务。\n\n#### 参数\n\n**chunkId** STRING 类型标量，表示 chunk 对应的 ID。\n\n#### 例子\n\n```\ntriggerPKEYCompaction(chunkId=\"1486f935-6f87-479c-b341-34c6a303d4f9\", async=false)\n```\n"
    },
    "cancelRebalanceTask": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cancelRebalanceTask.html",
        "signatures": [
            {
                "full": "cancelRebalanceTask(taskId)",
                "name": "cancelRebalanceTask",
                "parameters": [
                    {
                        "full": "taskId",
                        "name": "taskId"
                    }
                ]
            }
        ],
        "markdown": "### [cancelRebalanceTask](https://docs.dolphindb.cn/zh/funcs/c/cancelRebalanceTask.html)\n\n\n\n#### 语法\n\ncancelRebalanceTask(taskId)\n\n#### 参数\n\n**taskId** 是一个字符串标量或向量，表示再平衡任务的 ID，可以通过 [getRecoveryTaskStatus](https://docs.dolphindb.cn/zh/funcs/g/getRecoveryTaskStatus.html) 获得。\n\n#### 详情\n\n取消已经提交但尚未开始执行的再平衡任务。该命令只能由管理员在控制节点上执行。\n"
    },
    "cancelRecoveryTask": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cancelRecoveryTask.html",
        "signatures": [
            {
                "full": "cancelRecoveryTask(taskId)",
                "name": "cancelRecoveryTask",
                "parameters": [
                    {
                        "full": "taskId",
                        "name": "taskId"
                    }
                ]
            }
        ],
        "markdown": "### [cancelRecoveryTask](https://docs.dolphindb.cn/zh/funcs/c/cancelRecoveryTask.html)\n\n\n\n#### 语法\n\ncancelRecoveryTask(taskId)\n\n#### 参数\n\n**taskId** 是一个字符串标量或向量，表示副本恢复任务的 ID，可以通过 [getRecoveryTaskStatus](https://docs.dolphindb.cn/zh/funcs/g/getRecoveryTaskStatus.html) 获得。\n\n#### 详情\n\n取消已经提交但尚未开始执行的副本恢复任务。该命令只能由管理员在控制节点上执行。\n"
    },
    "cast": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cast.html",
        "signatures": [
            {
                "full": "cast(X, Y)",
                "name": "cast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cast](https://docs.dolphindb.cn/zh/funcs/c/cast.html)\n\n\n\n#### 语法\n\ncast(X, Y) 或 X $ Y\n\n#### 详情\n\n* 把一个数据类型转换成另一个\n* 改变一个矩阵的形状\n* 将向量转换成矩阵\n\n#### 参数\n\n**X** 可以是任意数据形式。\n\n**Y** 是数据类型或数据对。\n\n#### 例子\n\n```\nx=8.9$INT;\nx;\n```\n\n返回：9\n\n```\nx=1..10;\nx;\n```\n\n返回：\\[1,2,3,4,5,6,7,8,9,10]\n\n```\ntypestr x;\n```\n\n返回：FAST INT VECTOR\n\n```\nx/2;\n```\n\n返回：\\[0,1,1,2,2,3,3,4,4,5]\n\n```\nx=x$DOUBLE;\ntypestr x;\n```\n\n返回：FAST DOUBLE VECTOR\n\n```\nx/2;\n```\n\n返回：\\[0.5,1,1.5,2,2.5,3,3.5,4,4.5,5]\n\n```\nx=`IBM`MS;\ntypestr x;\n```\n\n返回：STRING VECTOR\n\n```\nx=x$SYMBOL;\ntypestr x;\n```\n\n返回：FAST SYMBOL VECTOR\n\n```\nx=`128.9;\ntypestr x;\n```\n\n返回：STRING\n\n```\nx=x$INT;\nx;\n```\n\n返回：128\n\n```\ntypestr x;\n```\n\n返回：INT\n\n以下这个例子将向量转换为矩阵：\n\n```\nm=1..8$2:4;\nm;\n```\n\n得到：\n\n| 0 | 1 | 2 | 3 |\n| - | - | - | - |\n| 1 | 3 | 5 | 7 |\n| 2 | 4 | 6 | 8 |\n\n以下例子改变一个矩阵的形状：\n\n```\nm$4:2;\n```\n\n得到：\n\n| 0 | 1 |\n| - | - |\n| 1 | 5 |\n| 2 | 6 |\n| 3 | 7 |\n| 4 | 8 |\n\n```\nm$1:size(m);\n```\n\n得到：\n\n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n| - | - | - | - | - | - | - | - |\n| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |\n"
    },
    "cbrt": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cbrt.html",
        "signatures": [
            {
                "full": "cbrt(X)",
                "name": "cbrt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cbrt](https://docs.dolphindb.cn/zh/funcs/c/cbrt.html)\n\n\n\n#### 语法\n\ncbrt(X)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 的立方根。返回结果的数据类型为 DOUBLE 类型。\n\n#### 例子\n\n```\ncbrt(8);\n// output\n2\n\ncbrt(8 12 16);\n// output\n[2,2.289428,2.519842]\n\ncbrt(1..6$2:3);\n```\n\n| 0        | 1        | 2        |\n| -------- | -------- | -------- |\n| 1        | 1.44225  | 1.709976 |\n| 1.259921 | 1.587401 | 1.817121 |\n"
    },
    "cdfBeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfBeta.html",
        "signatures": [
            {
                "full": "cdfBeta(alpha, beta, X)",
                "name": "cdfBeta",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfBeta](https://docs.dolphindb.cn/zh/funcs/c/cdfBeta.html)\n\n\n\n#### 语法\n\ncdfBeta(alpha, beta, X)\n\n#### 参数\n\n形状参数 **alpha** 和 **beta** 都是正数。\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回 Beta 分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfBeta(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0, 0.116056, 0.976416]\n\ncdfBeta(2.31, 0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.002451, 0.032995, 0.116056, 0.280532, 0.597694]\n```\n"
    },
    "cdfBinomial": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfBinomial.html",
        "signatures": [
            {
                "full": "cdfBinomial(trials, p, X)",
                "name": "cdfBinomial",
                "parameters": [
                    {
                        "full": "trials",
                        "name": "trials"
                    },
                    {
                        "full": "p",
                        "name": "p"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfBinomial](https://docs.dolphindb.cn/zh/funcs/c/cdfBinomial.html)\n\n\n\n#### 语法\n\ncdfBinomial(trials, p, X)\n\n#### 参数\n\n**trials** 是正整数。\n\n**p** 是0到1之间的浮点数。\n\n**trials** 和 **p** 是形状参数。\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回二项分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfBinomial(10, 0.1, [1, 5, 9]);\n// output\n[0.736099, 0.999853, 1]\n\ncdfBinomial(12,0.627, [1, 3, 5, 7, 9]);\n// output\n[0.000154, 0.009085, 0.114844, 0.483879, 0.88373]\n```\n"
    },
    "cdfChiSquare": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfChiSquare.html",
        "signatures": [
            {
                "full": "cdfChiSquare(df, X)",
                "name": "cdfChiSquare",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfChiSquare](https://docs.dolphindb.cn/zh/funcs/c/cdfChiSquare.html)\n\n\n\n#### 语法\n\ncdfChiSquare(df, X)\n\n#### 参数\n\n**df** 是正数，表示卡方分布的自由度。\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回卡方分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfChiSquare(1, [-1, 0, 0.5, 1, 2]);\n// output\n[0, 0, 0.5205, 0.682689, 0.842701]\n\ncdfChiSquare(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.24817, 0.416118, 0.5205, 0.597216, 0.657218]\n```\n"
    },
    "cdfExp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfExp.html",
        "signatures": [
            {
                "full": "cdfExp(mean, X)",
                "name": "cdfExp",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfExp](https://docs.dolphindb.cn/zh/funcs/c/cdfExp.html)\n\n\n\n#### 语法\n\ncdfExp(mean, X)\n\n#### 参数\n\n**mean** 是指数分布的均值。\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回指数分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfExp(1, [-1, 0, 0.5, 1, 2]);\n// output\n[0, 0, 0.393469, 0.632121, 0.864665]\n\ncdfExp(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.095163, 0.259182, 0.393469, 0.503415, 0.59343]\n```\n"
    },
    "cdfF": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfF.html",
        "signatures": [
            {
                "full": "cdfF(numeratorDF, denominatorDF, X)",
                "name": "cdfF",
                "parameters": [
                    {
                        "full": "numeratorDF",
                        "name": "numeratorDF"
                    },
                    {
                        "full": "denominatorDF",
                        "name": "denominatorDF"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfF](https://docs.dolphindb.cn/zh/funcs/c/cdfF.html)\n\n\n\n#### 语法\n\ncdfF(numeratorDF, denominatorDF, X)\n\n#### 参数\n\n**numeratorDF** 和 **denominatorDF** 都是正数，表示 F 分布的自由度。\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回 F 分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfF(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0.000444, 0.245679, 0.35098]\n\ncdfF(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.07078, 0.176153, 0.245679, 0.295996, 0.334766]\n```\n"
    },
    "cdfGamma": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfGamma.html",
        "signatures": [
            {
                "full": "cdfGamma(shape, scale, X)",
                "name": "cdfGamma",
                "parameters": [
                    {
                        "full": "shape",
                        "name": "shape"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfGamma](https://docs.dolphindb.cn/zh/funcs/c/cdfGamma.html)\n\n\n\n#### 语法\n\ncdfGamma(shape, scale, X)\n\n#### 参数\n\n形状参数 **shape** 是正数。\n\n尺度参数 **scale** 是正数。\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回 Gamma 分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfGamma(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0, 0.127367, 0.38032]\n\ncdfGamma(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.004754, 0.048388, 0.127367, 0.225351, 0.329391]\n```\n"
    },
    "cdfKolmogorov": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfKolmogorov.html",
        "signatures": [
            {
                "full": "cdfKolmogorov(X)",
                "name": "cdfKolmogorov",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfKolmogorov](https://docs.dolphindb.cn/zh/funcs/c/cdfKolmogorov.html)\n\n\n\n#### 语法\n\ncdfKolmogorov(X)\n\n#### 参数\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回 Kolmogorov 分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfKolmogorov([0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[1, 0.999991, 0.963945, 0.711235, 0.392731]\n\ncdfKolmogorov([1,2,3]);\n// output\n[0.27, 0.000671, 3.045996E-8]\n```\n"
    },
    "cdfLogistic": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfLogistic.html",
        "signatures": [
            {
                "full": "cdfLogistic(mean, s, X)",
                "name": "cdfLogistic",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "s",
                        "name": "s"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfLogistic](https://docs.dolphindb.cn/zh/funcs/c/cdfLogistic.html)\n\n\n\n#### 语法\n\ncdfLogistic(mean, s, X)\n\n#### 参数\n\n**mean** 是 Logistic 分布的均值。\n\n**s** 是 Logistic 分布的尺度参数。\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回 Logistic 分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfLogistic( 2.31, 0.627, [0.5, 0.3, 0.5, 0.7, 0.1]);\n```\n\n输出返回：\\[0.052812, 0.03895, 0.052812, 0.071241, 0.028617]\n"
    },
    "cdfNormal": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfNormal.html",
        "signatures": [
            {
                "full": "cdfNormal(mean, stdev, X)",
                "name": "cdfNormal",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "stdev",
                        "name": "stdev"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfNormal](https://docs.dolphindb.cn/zh/funcs/c/cdfNormal.html)\n\n\n\n#### 语法\n\ncdfNormal(mean, stdev, X)\n\n#### 参数\n\n**mean** 是正态分布的均值。\n\n**stdev** 是正态分布的标准差。\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回均值为 *mean*，标准差为 *stdev* 的正态分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfNormal(0,1,-2.33);\n// output\n0.009903\n\ncdfNormal(10, 20, -30);\n// output\n0.02275\n```\n"
    },
    "cdfPoisson": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfPoisson.html",
        "signatures": [
            {
                "full": "cdfPoisson(mean, X)",
                "name": "cdfPoisson",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfPoisson](https://docs.dolphindb.cn/zh/funcs/c/cdfPoisson.html)\n\n\n\n#### 语法\n\ncdfPoisson(mean, X)\n\n#### 参数\n\n**mean** 是泊松分布的均值。\n\n**X** 是整型标量或向量。\n\n#### 详情\n\n返回泊松分布的累计分布函数的值。\n\n#### 例子\n\n```\ncdfPoisson(1, [-1, 0, 1, 2, 3]);\n// output\n[0, 0.367879, 0.735759, 0.919699, 0.981012]\n\ncdfPoisson(1, [1, 3, 5, 7, 9]);\n// output\n[0.735759, 0.981012, 0.999406, 0.99999, 1]\n```\n"
    },
    "cdfStudent": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfStudent.html",
        "signatures": [
            {
                "full": "cdfStudent(df, X)",
                "name": "cdfStudent",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfStudent](https://docs.dolphindb.cn/zh/funcs/c/cdfStudent.html)\n\n\n\n#### 语法\n\ncdfStudent(df, X)\n\n#### 参数\n\n**df** 是正数，表示 t 分布的自由度。\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回 t 分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfStudent(1, [-1, 0, 0.5, 1, 2]);\n// output\n[0.25, 0.5, 0.647584, 0.75, 0.852416]\n\ncdfStudent(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.531726, 0.592774, 0.647584, 0.6944, 0.733262]\n```\n"
    },
    "cdfUniform": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfUniform.html",
        "signatures": [
            {
                "full": "cdfUniform(lower, upper, X)",
                "name": "cdfUniform",
                "parameters": [
                    {
                        "full": "lower",
                        "name": "lower"
                    },
                    {
                        "full": "upper",
                        "name": "upper"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfUniform](https://docs.dolphindb.cn/zh/funcs/c/cdfUniform.html)\n\n\n\n#### 语法\n\ncdfUniform(lower, upper, X)\n\n#### 参数\n\n**lower** 和 **upper** 是数值型标量，表示连续均匀分布的下限和上限。\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回均匀分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfUniform(0.627, 2.31, [0.001, 0.5, 0.999]);\n// output\n[0, 0, 0.221034]\n\ncdfUniform(0.627, 2.31, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0, 0, 0, 0.043375, 0.16221]\n```\n"
    },
    "cdfWeibull": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfWeibull.html",
        "signatures": [
            {
                "full": "cdfWeibull(alpha, beta, X)",
                "name": "cdfWeibull",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfWeibull](https://docs.dolphindb.cn/zh/funcs/c/cdfWeibull.html)\n\n\n\n#### 语法\n\ncdfWeibull(alpha, beta, X)\n\n#### 参数\n\n形状参数 **alpha** 和 **beta** 都是正数。\n\n**X** 是数值型标量或向量。\n\n#### 详情\n\n返回 Weibull 分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfWeibull(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0, 0.447241, 0.946762]\n\ncdfWeibull(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.014295, 0.166535, 0.447241, 0.724646, 0.90021]\n```\n"
    },
    "cdfZipf": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cdfZipf.html",
        "signatures": [
            {
                "full": "cdfZipf(num, exponent, X)",
                "name": "cdfZipf",
                "parameters": [
                    {
                        "full": "num",
                        "name": "num"
                    },
                    {
                        "full": "exponent",
                        "name": "exponent"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cdfZipf](https://docs.dolphindb.cn/zh/funcs/c/cdfZipf.html)\n\n\n\n#### 语法\n\ncdfZipf(num, exponent, X)\n\n#### 参数\n\n**num** 是正整数。\n\n**exponent** 是非负数。\n\n**X** 是数值型向量。\n\n#### 详情\n\n返回 Zipf 分布的累计密度函数的值。\n\n#### 例子\n\n```\ncdfZipf(10, 0.5, [1, 3, 5, 7, 9]);\n// output\n[0.199164, 0.454981, 0.643631, 0.800216, 0.937019]\n```\n"
    },
    "cds": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cds.html",
        "signatures": [
            {
                "full": "cds(settlement, maturity, evalDate, notional, spread, riskFree, recovery, isSeller, frequency, calendar, [convention='Following'], [termDateConvention='Following'], [rule='CDS'], [basis=1])",
                "name": "cds",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "evalDate",
                        "name": "evalDate"
                    },
                    {
                        "full": "notional",
                        "name": "notional"
                    },
                    {
                        "full": "spread",
                        "name": "spread"
                    },
                    {
                        "full": "riskFree",
                        "name": "riskFree"
                    },
                    {
                        "full": "recovery",
                        "name": "recovery"
                    },
                    {
                        "full": "isSeller",
                        "name": "isSeller"
                    },
                    {
                        "full": "frequency",
                        "name": "frequency"
                    },
                    {
                        "full": "calendar",
                        "name": "calendar"
                    },
                    {
                        "full": "[convention='Following']",
                        "name": "convention",
                        "optional": true,
                        "default": "'Following'"
                    },
                    {
                        "full": "[termDateConvention='Following']",
                        "name": "termDateConvention",
                        "optional": true,
                        "default": "'Following'"
                    },
                    {
                        "full": "[rule='CDS']",
                        "name": "rule",
                        "optional": true,
                        "default": "'CDS'"
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [cds](https://docs.dolphindb.cn/zh/funcs/c/cds.html)\n\n\n\n#### 语法\n\ncds(settlement, maturity, evalDate, notional, spread, riskFree, recovery, isSeller, frequency, calendar, \\[convention='Following'], \\[termDateConvention='Following'], \\[rule='CDS'], \\[basis=1])\n\n#### 详情\n\n本函数对信用违约互换（Credit Default Swap，CDS）进行估值计算。成功执行后将返回 CDS 的估值，是一个 DOUBLE 类型的标量或向量。\n\n#### 参数\n\n**settlement** DATE 类型标量或向量，表示 CDS 合约的生效日。\n\n**maturity** DATE 类型标量或向量，表示 CDS 合约的到期日。\n\n注意：*settlement*应早于对应的 *maturity*。\n\n**evalDate**DATE 类型标量或向量，表示估值日。\n\n注意：*evalDate* 不应晚于对应的 *settlement*。\n\n**notional**数值类型标量或向量，非负数，表示 CDS 合约的名义本金。\n\n**spread** 数值类型标量或向量，表示 CDS 利差，是 CDS 买方每期需支付给 CDS 卖方的金额，以 CDS 的名义本金的百分比形式报价，以基点（bps）表示。\n\n**riskFree**数值类型标量或向量，非负数，表示无风险利率。\n\n**recovery**数值类型标量或向量，表示回收率，有效范围是(0,1)，指的是在发生信用事件（如违约）后，债券持有人预计能够收回的金额占违约债券面值的百分比。\n\n**isSeller** 整数类型标量或向量，表示交易方为买方还是卖方，有两个可选值：\n\n* 1：表示交易方为卖方。\n\n* 0：表示交易方为卖方。\n\n**frequency** 表示买方向卖方支付金额的频率，支持两种输入类型：\n\n* 整数标量或向量：表示买方每年向卖方支付金额的次数；比如输入 1，表示每年付息 1 次，即按年支付；输入 2，表示每年付息 2 次，即按半年期支付。\n\n* DURATION 标量或向量：表示买方每隔多久向卖方进行一次支付。比如输入 duration(\\`3M)，表示每隔 3 个月支付一次，即按季度支付。\n\n<table id=\"table_w31_tqx_bdc\"><thead><tr><th align=\"left\">\n\n可选值\n\n</th><th align=\"left\">\n\n含义\n\n</th></tr></thead><tbody><tr><td>\n\n1 / 1y\n\n</td><td>\n\n表示每年付息1次\n\n</td></tr><tr><td>\n\n2 / 6M\n\n</td><td>\n\n表示每年付息2次 / 每6个月付息1次\n\n</td></tr><tr><td>\n\n3 / 4M\n\n</td><td>\n\n表示每年付息3次 / 每4个月付息1次\n\n</td></tr><tr><td>\n\n4 / 3M\n\n</td><td>\n\n表示每年付息4次 / 每3个月付息1次\n\n</td></tr><tr><td>\n\n6 / 2M\n\n</td><td>\n\n表示每年付息6次 / 每2个月付息1次\n\n</td></tr><tr><td>\n\n12 / 1M\n\n</td><td>\n\n表示每年付息12次 / 每月付息1次\n\n</td></tr><tr><td>\n\n13 / 4w\n\n</td><td>\n\n表示每年付息13次 / 每4周付息1次\n\n</td></tr><tr><td>\n\n26 / 2w\n\n</td><td>\n\n表示每年付息26次 / 每2周付息1次\n\n</td></tr><tr><td>\n\n52 / 1w\n\n</td><td>\n\n表示每年付息52次 / 每周付息1次\n\n</td></tr><tr><td>\n\n365 / 1d\n\n</td><td>\n\n表示每年付息365次 / 每天付息1次\n\n</td></tr></tbody>\n</table>**calendar** 字符串类型标量或向量，表示使用的市场日历类型，请参阅[交易日历](https://docs.dolphindb.cn/zh/modules/MarketHoliday/mkt_calendar.html#11-%E6%9F%A5%E8%AF%A2%E4%BA%A4%E6%98%93%E6%97%A5%E5%8E%86-getmarketcalendar)。\n\n**convention** 可选参数，字符串标量或向量，表示把非工作日调整到工作日的方法，可选值为：\n\n* 'Following'：表示选择给定假日后的第一个工作日，默认值。\n\n* 'ModifiedFollowing'：表示选择给定假日后的第一个工作日，除非该工作日属于不同的月份，此时应选择假日前的第一个工作日。\n\n* 'Preceding'：表示选择给定假日前的第一个工作日。\n\n* 'ModifiedPreceding'：表示选择给定假日前的第一个工作日，除非该工作日属于不同的月份，此时应选择假日后的第一个工作日。\n\n* 'Unadjusted'：表示不做调整。\n\n* 'HalfMonthModifiedFollowing'：表示选择给定假日后的第一个工作日，除非该工作日跨越了月中（15 日）或月末，此时应选择假日前的第一个工作日。\n\n* 'Nearest'：表示选择离给定假日最近的工作日。如果前一个和后一个工作日距离给定假日同样远，则默认选择后一个工作日。\n\n**termDateConvention** 可选参数，字符串标量或向量，表示如果最后一个日期是非工作日，将其调整到工作日的方法，可选值同 convention。默认值为'Following'。\n\n**rule** 可选参数，字符串标量或向量，表示日期列表的生成规则，可选值为：\n\n* 'Backward'：表示从终止日期向生效日期倒向生成。\n\n* 'Forward'：表示从生效日期向终止日期正向生成。\n\n* 'Zero'：表示在生效日期和终止日期之间不生成中间日期。\n\n* 'ThirdWednesday'：表示除了生效日期和终止日期，其他日期落在当月的第三个星期三（正向生成）。\n\n* 'ThirdWednesdayInclusive'：表示所有日期，包括生效日期和终止日期，均落在当月的第三个星期三（正向生成）。\n\n* 'Twentieth'：表示除生效日期外，所有日期均落在当月 20 日（用于新兴市场 CDS 时间表）。终止日期也相应调整。\n\n* 'TwentiethIMM'：表示除生效日期外，所有日期均落在 IMM（International Money Market）月份的 20 日（用于 CDS 时间表）。终止日期也相应调整。\n\n* 'OldCDS'：表示除生效日期外，所有日期均落在 IMM（International Money Market）月份的 20 日（用于CDS时间表）。终止日期也相应调整。但日期端点不受限制，并允许短尾或长尾票息期（旧 CDS 惯例）。\n\n* 'CDS'：表示使用[自 2009 年“大爆炸”改革以来的信用衍生品标准规则](https://www.isda.org/2009/03/12/big-bang-protocol/)。默认值。\n\n* 'CDS2015'：表示[使用自 2015 年 12 月 20 日以来的信用衍生品标准规则](https://www.isda.org/2015/07/07/amending-when-single-name-cds-roll-to-new-on-the-run-contracts/)。\n\n**basis** 可选参数，整型标量或向量，表示要使用的日计数基准类型。可选值为：\n\n| Basis | 日计数基准            |\n| ----- | ---------------- |\n| 0     | US (NASD) 30/360 |\n| 1或省略  | 实际/实际            |\n| 2     | 实际/360           |\n| 3     | 实际/365           |\n| 4     | 欧洲 30/360        |\n\n注意：如果输入参数中，部分为标量，其余为向量时，则会将标量当作与向量长度相同、所有元素值等于该标量的向量；且所有向量的长度必须一致。\n\n#### 例子\n\n自定义参数，计算 CDS 的估值。\n\n```\nvalDate = 2007.05.15     \nsettlement = 2007.05.16\nmaturity = 2007.08.16\nnotional = 1000000.0\nspread = 0.0150\nriskFreeRate = 0.01\nrecoveryRate = 0.5\nisSeller = true\nfrequency = 4\nconvention = 'Following'\ntermDateConvention = 'Unadjusted'\nrule = 'TwentiethIMM'\nbasis = 3\ncds(settlement, maturity, valDate, notional, spread, riskFreeRate, recoveryRate, isSeller, frequency, 'CCFX', convention, termDateConvention, rule, basis)\n// Output: -5.448913728297157\n```\n"
    },
    "ceil": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/ceil.html",
        "signatures": [
            {
                "full": "ceil(X)",
                "name": "ceil",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ceil](https://docs.dolphindb.cn/zh/funcs/c/ceil.html)\n\n\n\n#### 语法\n\nceil(X)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n#### 详情\n\n函数 [floor](https://docs.dolphindb.cn/zh/funcs/f/floor.html) 和 *ceil* 分别把一个实数映射到小于等于它的最大整数，和大于等于它的最小整数。函数 [round](https://docs.dolphindb.cn/zh/funcs/r/round.html) 根据四舍五入规则把一个实数映射到最接近的整数。\n\n#### 例子\n\n```\nceil(2.1);\n// output\n3\nceil(2.9);\n// output\n3\nceil(-2.1);\n// output\n-2\n\nfloor(2.1);\n// output\n2\nfloor(2.9);\n// output\n2\nfloor(-2.1);\n// output\n-3\n\nround(2.1);\n// output\n2\nround(2.9);\n// output\n3\nround(-2.1);\n// output\n-2\n\nm = 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9 10$2:5;\nm;\n```\n\n| 0   | 1   | 2   | 3   | 4   |\n| --- | --- | --- | --- | --- |\n| 1.1 | 3.3 | 5.5 | 7.7 | 9.9 |\n| 2.2 | 4.4 | 6.6 | 8.8 | 10  |\n\n```\nceil(m);\n```\n\n| 0 | 1 | 2 | 3 | 4  |\n| - | - | - | - | -- |\n| 2 | 4 | 6 | 8 | 10 |\n| 3 | 5 | 7 | 9 | 10 |\n"
    },
    "cell": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cell.html",
        "signatures": [
            {
                "full": "cell(obj, row, col)",
                "name": "cell",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "row",
                        "name": "row"
                    },
                    {
                        "full": "col",
                        "name": "col"
                    }
                ]
            }
        ],
        "markdown": "### [cell](https://docs.dolphindb.cn/zh/funcs/c/cell.html)\n\n\n\n#### 语法\n\ncell(obj, row, col)\n\n#### 参数\n\n**obj** 矩阵或表。\n\n**row** 非负整数，表示行坐标。\n\n**col** 非负整数，表示列坐标。\n\n#### 详情\n\n返回一个位于对应行列的标量，等价于 `obj[row, col]`。*cell* 函数通常比 `obj[row, col]` 运行地更快。\n\n#### 例子\n\n```\nx=(1..6).reshape(3:2);\nx;\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\nx.cell(0,0);\n// output\n1\nx.cell(0,1);\n// output\n4\ncell(x,1,1);\n// output\n5\n\ncell(x,2,0);\n// output\n3\n```\n"
    },
    "cells": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cells.html",
        "signatures": [
            {
                "full": "cells(obj, row, col)",
                "name": "cells",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "row",
                        "name": "row"
                    },
                    {
                        "full": "col",
                        "name": "col"
                    }
                ]
            }
        ],
        "markdown": "### [cells](https://docs.dolphindb.cn/zh/funcs/c/cells.html)\n\n\n\n#### 语法\n\ncells(obj, row, col)\n\n#### 参数\n\n**obj** 矩阵。\n\n**row** 整型向量，表示行坐标。\n\n**col** 与 *row* 等长的整型向量，表示列坐标。\n\n#### 详情\n\n返回一个由矩阵中 *row* 和 *col* 定位的元素组成的向量。\n\n#### 例子\n\n```\nm=(1..15).reshape(3:5)\nm;\n```\n\n| col1 | col2 | col3 | col4 | col5 |\n| ---- | ---- | ---- | ---- | ---- |\n| 1    | 4    | 7    | 10   | 13   |\n| 2    | 5    | 8    | 11   | 14   |\n| 3    | 6    | 9    | 12   | 15   |\n\n```\n// 取矩阵中下标为 [0,1] 和 [0,2] 两个元素\ncells(m, 0 0, 1 2)\n// output\n[4,7]\n// 取矩阵对角线上的元素\nindex = 0..2\ncells(m, index, index)\n// output\n[1, 5, 9]\n```\n"
    },
    "changePwd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/changePwd.html",
        "signatures": [
            {
                "full": "changePwd(oldPwd, newPwd)",
                "name": "changePwd",
                "parameters": [
                    {
                        "full": "oldPwd",
                        "name": "oldPwd"
                    },
                    {
                        "full": "newPwd",
                        "name": "newPwd"
                    }
                ]
            }
        ],
        "markdown": "### [changePwd](https://docs.dolphindb.cn/zh/funcs/c/changePwd.html)\n\n\n\n#### 语法\n\nchangePwd(oldPwd, newPwd)\n\n#### 参数\n\n**oldPwd** 表示用户旧密码的字符串。\n\n**newPwd** 表示用户新密码的字符串。它不能包含空格或控制字符。\n\n从 2.00.10.10 开始，用户可以通过配置项 *enhancedSecurityVerification* 控制是否对 newPwd 进行复杂性校验。若不设置 *enhancedSecurityVerification*，则不校验；若设置 *enhancedSecurityVerification*=true，则要求新密码必须满足以下条件：\n\n* 字符个数为8\\~20\n* 至少包含一个大写字母\n* 至少包含以下字符之一：!\"#$%&'()\\*+,-./:;<=>?@\\[]^\\_\\`{|}\\~。\n\n**Note:** 该函数只能在控制节点、数据节点和计算节点运行。\n\n#### 详情\n\n修改用户密码。\n\n#### 例子\n\n```\nchangePwd(\"LTmp4389.\", \"T5139pm.\");\n```\n"
    },
    "char": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/char.html",
        "signatures": [
            {
                "full": "char(X)",
                "name": "char",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [char](https://docs.dolphindb.cn/zh/funcs/c/char.html)\n\n\n\n#### 语法\n\nchar(X)\n\n#### 详情\n\n把输入转换为 CHAR 数据类型。\n\n#### 参数\n\n**X** 可以是任意数据类型。\n\n#### 例子\n\n```\nx=char();\nx;\n```\n\n返回：null\n\n```\ntypestr x;\n```\n\n返回：CHAR\n\n```\na=char(99);\na;\n```\n\n返回：'c'\n\n```\ntypestr a;\n```\n\n返回：CHAR\n\n```\nchar(a+5);\n```\n\n返回：'h'\n\n```\nchar(\"990\");\n```\n\n返回：`Failed to convert the string to CHAR`\n\n**Note:** `char` 函数会把输入的字符串识别为 ASCII 码，超出 ASCII 码范围的输入字符无法转换。\n"
    },
    "charAt": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/charAt.html",
        "signatures": [
            {
                "full": "charAt(X, Y)",
                "name": "charAt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [charAt](https://docs.dolphindb.cn/zh/funcs/c/charAt.html)\n\n\n\n#### 语法\n\ncharAt(X, Y)\n\n#### 参数\n\n**X** 是字符串标量或向量。\n\n**Y** 是整型标量或与 *X* 长度相同的整型向量。\n\n#### 详情\n\n返回字符串中指定位置的字符。返回的结果是 CHAR 类型。\n\n#### 例子\n\n```\ns=charAt(\"abc\",2);\ns;\n// output\n'c'\n\ntypestr(s);\n// output\nCHAR\n\ncharAt([\"hello\",\"world\"],[3,4]);\n// output\n['l','d']\n```\n"
    },
    "checkBackup": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/checkBackup.html",
        "signatures": [
            {
                "full": "checkBackup(backupDir, dbPath, [tableName], [partition])",
                "name": "checkBackup",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    },
                    {
                        "full": "[partition]",
                        "name": "partition",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [checkBackup](https://docs.dolphindb.cn/zh/funcs/c/checkBackup.html)\n\n\n\n#### 语法\n\ncheckBackup(backupDir, dbPath, \\[tableName], \\[partition])\n\n#### 参数\n\n**backupDir** 字符串，表示存放备份数据的目录。\n\n**dbPath** 字符串，表示数据库路径。\n\n**tableName** 字符串标量或向量，表示表名。若不指定，表示指定数据库下的所有表。\n\n**partition** 表示分区。是字符串，表示备份分区的相对路径。分区路径可以包含通配符(\"%\"和\"?\")，\"?\"表示单个字符，\"%\"表示0，1或多个字符。\n\n* 若仅检查某个分区，输入分区的相对路径或者\"%/\"+”分区名称”。举例：要检查 \"dfs\\://compoDB\" 下的分区”20170810/50\\_100”，输入 \"/compoDB/20170807/0\\_50\" 或者 \"%/20170807/0\\_50\"。\n* 若需要检查所有分区，直接输入\"%\"。\n\n#### 详情\n\n检查备份文件的的完整性和准确性。若所有备份文件均完整且准确，则返回一个空表；否则返回异常的备份文件信息，此时可通过在 `backup` 函数设置 *force* = true 开启强制备份以恢复受损的备份分区数据。\n\n#### 例子\n\n```\ndbName = \"dfs://compoDB2\"\nn=1000\nID=rand(\"a\"+string(1..10), n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10, n)\nt=table(ID, date, x)\ndb1 = database(, VALUE, 2017.08.07..2017.08.11)\ndb2 = database(, HASH,[INT, 20])\nif(existsDatabase(dbName)){\n   dropDatabase(dbName)\n}\ndb = database(dbName, COMPO,[ db1,db2])\n\n// 创建2个表\npt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\npt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\n// SQL 元代码方式备份 pt1\nbackup(backupDir=backupDir1, sqlObj=<select * from pt1>, parallel=true)\n// 拷贝文件方式备份 pt2\nbackup(backupDir=backupDir2, dbName, parallel=true, tableName=`pt2)\n\n// pt2 备份文件都正常，pt1 中一个 chunk 文件出现问题\ncheckBackup(backupDir=backupDir2, dbPath=dbName, tableName=\"pt2\")  // 返回一个空表\ncheckBackup(backupDir=backupDir1, dbPath=dbName, tableName=\"pt1\")  // 返回出错的 chunk 信息\n```\n\n| dbName              | tableName                 | chunkPath                            | chunkID        | partitionPath |\n| ------------------- | ------------------------- | ------------------------------------ | -------------- | ------------- |\n| dfs\\://compoDB2 pt1 | /compoDB2/20170807/Key2/9 | 4ae71414-8bfe-4283-b04c-b2e48e90be08 | /20170807/Key2 |               |\n\n上例中，通过调用 *checkBackup* 函数，可以发现在 pt1 中存在损坏的 chunk 文件。此时，设置 *force* = true 再次强制备份，以恢复受损文件。\n\n```\nbackup(backupDir1, <select * from pt1>,force=true, parallel=true)\ncheckBackup(backupDir=backupDir1, dbPath=dbName, tableName=\"pt1\")  // 返回一个空表\n```\n"
    },
    "chiSquareTest": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/chiSquareTest.html",
        "signatures": [
            {
                "full": "chiSquareTest(X, [Y])",
                "name": "chiSquareTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [chiSquareTest](https://docs.dolphindb.cn/zh/funcs/c/chiSquareTest.html)\n\n\n\n#### 语法\n\nchiSquareTest(X, \\[Y])\n\n#### 参数\n\n**X** 是一个数值向量、矩阵或表。\n\n如果 *X* 是一个向量，那么 *Y* 是一个与 *X* 长度相同的向量；如果 *X* 是矩阵或表，那么无需指定 *Y*。\n\n#### 详情\n\n如果 *X* 是一个向量，进行 Chi-square Goodness-of-fit 检验 *X* 是否与 *Y* 的概率分布一致；如果 *X* 是矩阵或表，对 *X* 进行 Pearson's Chi-squared 检验。返回的结果是一个字典，包含以下 key：\n\n* pValue：p 值\n* df：自由度\n* chiSquaredValue：chi-square 统计量\n* method：如果 *X* 为向量，*method* 为字符串 \"Chi-square goodness of fit test\"；如果 *X* 为矩阵或表，*method* 为字符串 \"Pearson's Chi-squared test\"。\n\n#### 例子\n\n例1. *X* 是一个向量。\n\n```\nx=rand(10.0,50)\ny=rand(10.0,50)\nchiSquareTest(x,y);\n\n// output\npValue->0\ndf->49\nchiSquaredValue->947.388015\nmethod->Chi-square goodness of fit test\n```\n\n例2. *X* 是一个矩阵。\n\n```\nx = matrix([762, 484], [327, 239], [468, 477])\nx.rename!(`female`male, `Democrat`Independent`Republican)\nx;\n```\n\n|        | Democrat | Independent | Republican |\n| ------ | -------- | ----------- | ---------- |\n| female | 762      | 327         | 468        |\n| male   | 484      | 239         | 477        |\n\n```\nchiSquareTest(x);\n// output\npValue->2.953589E-7\ndf->2\nchiSquaredValue->30.070149\nmethod->Pearson's Chi-squared test\n```\n"
    },
    "cholesky": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cholesky.html",
        "signatures": [
            {
                "full": "cholesky(obj, [lower=true])",
                "name": "cholesky",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[lower=true]",
                        "name": "lower",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [cholesky](https://docs.dolphindb.cn/zh/funcs/c/cholesky.html)\n\n\n\n#### 语法\n\ncholesky(obj, \\[lower=true])\n\n#### 参数\n\n**obj** 是一个对称正定矩阵。\n\n**lower** 是一个布尔值，表示是否使用输入矩阵的下三角来计算分解。默认值为 true，表示使用下三角计算。如果 *lower* 为 false，表示使用上三角计算。\n\n#### 详情\n\n对矩阵进行 Cholesky 分解。\n\n#### 例子\n\n```\nm=[1, 0, 1, 0, 2, 0, 1, 0, 3]$3:3\nL=cholesky(m);\nL;\n```\n\n| #0 | #1       | #2       |\n| -- | -------- | -------- |\n| 1  | 0 96.56  | 0        |\n| 0  | 1.414214 | 0        |\n| 1  | 0        | 1.414214 |\n\n```\nL**transpose(L);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 0  | 1  |\n| 0  | 2  | 0  |\n| 1  | 0  | 3  |\n\n```\ncholesky(m, false);\n```\n\n| #0 | #1       | #2       |\n| -- | -------- | -------- |\n| 1  | 0        | 1        |\n| 0  | 1.414214 | 0        |\n| 0  | 0        | 1.414214 |\n"
    },
    "cj": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cj.html",
        "signatures": [
            {
                "full": "cj(X, Y)",
                "name": "cj",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cj](https://docs.dolphindb.cn/zh/funcs/c/cj.html)\n\n\n\n#### 语法\n\ncj(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是表。\n\n#### 详情\n\n这个函数对两个表执行交叉连接，产生它们的笛卡儿积。如果 *X* 有 n 行，*Y* 有 m 行，那么 cj(X,Y) 有 n\\*m 行。\n\n#### 例子\n\n```\na=table(1..3 as x,`IBM`C`AAPL as y)\nb=table(172.3 25 106.5 as z)\nc=cj(a,b);\nc;\n```\n\n| x | y    | z     |\n| - | ---- | ----- |\n| 1 | IBM  | 172.3 |\n| 1 | IBM  | 25    |\n| 1 | IBM  | 106.5 |\n| 2 | C    | 172.3 |\n| 2 | C    | 25    |\n| 2 | C    | 106.5 |\n| 3 | AAPL | 172.3 |\n| 3 | AAPL | 25    |\n| 3 | AAPL | 106.5 |\n\n```\n// 与此相对，join(<-) 只是将两个表的列合并\na join b;\n```\n\n| x | y    | z     |\n| - | ---- | ----- |\n| 1 | IBM  | 172.3 |\n| 2 | C    | 25    |\n| 3 | AAPL | 106.5 |\n"
    },
    "cleanOutdateLogFiles": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cleanOutdateLogFiles.html",
        "signatures": [
            {
                "full": "cleanOutdateLogFiles([retentionTime=30])",
                "name": "cleanOutdateLogFiles",
                "parameters": [
                    {
                        "full": "[retentionTime=30]",
                        "name": "retentionTime",
                        "optional": true,
                        "default": "30"
                    }
                ]
            }
        ],
        "markdown": "### [cleanOutdateLogFiles](https://docs.dolphindb.cn/zh/funcs/c/cleanOutdateLogFiles.html)\n\n\n\n#### 语法\n\ncleanOutdateLogFiles(\\[retentionTime=30])\n\n#### 参数\n\n**retentionTime** 系统日志的保留时间，默认是 30（单位：天）。\n\n#### 详情\n\n手动触发超过 *retentionTime* 时间的系统日志的清理。\n"
    },
    "clearAllCache": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clearAllCache.html",
        "signatures": [
            {
                "full": "clearAllCache()",
                "name": "clearAllCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [clearAllCache](https://docs.dolphindb.cn/zh/funcs/c/clearAllCache.html)\n\n\n\n#### 语法\n\nclearAllCache()\n\n#### 参数\n\n无\n\n#### 详情\n\n清除以下缓存数据：\n\n* 维度表在内存中的缓存\n* OLAP 引擎分区表中已经载入内存的数据\n* TSDB 引擎的 Level File 索引的缓存\n* TSDB 引擎中 SYMBOL 类型的字典编码的缓存\n* 分布式计算中 map-reduce 任务的中间结果\n\n#### 例子\n\n```\nclearAllCache();\n```\n"
    },
    "clearAllIOTDBLatestKeyCache": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clearalliotdblatestkeycache.html",
        "signatures": [
            {
                "full": "clearAllIOTDBLatestKeyCache()",
                "name": "clearAllIOTDBLatestKeyCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [clearAllIOTDBLatestKeyCache](https://docs.dolphindb.cn/zh/funcs/c/clearalliotdblatestkeycache.html)\n\n\n\n#### 语法\n\nclearAllIOTDBLatestKeyCache()\n\n#### 参数\n\n无\n\n#### 详情\n\n用于清理最新值缓存表缓存。\n\n#### 例子\n\n```\nclearAllIOTDBLatestKeyCache()\n```\n"
    },
    "clearAllIOTDBStaticTableCache": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clearalliotdbstatictablecache.html",
        "signatures": [
            {
                "full": "clearAllIOTDBStaticTableCache()",
                "name": "clearAllIOTDBStaticTableCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [clearAllIOTDBStaticTableCache](https://docs.dolphindb.cn/zh/funcs/c/clearalliotdbstatictablecache.html)\n\n\n\n#### 语法\n\nclearAllIOTDBStaticTableCache()\n\n#### 参数\n\n无\n\n#### 详情\n\n用于清理静态表缓存。\n\n#### 例子\n\n```\nclearAllIOTDBStaticTableCache()\n```\n"
    },
    "clearAllTSDBSymbolBaseCache": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clearalltsdbsymbolbasecache.html",
        "signatures": [
            {
                "full": "clearAllTSDBSymbolBaseCache()",
                "name": "clearAllTSDBSymbolBaseCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [clearAllTSDBSymbolBaseCache](https://docs.dolphindb.cn/zh/funcs/c/clearalltsdbsymbolbasecache.html)\n\n\n\n#### 语法\n\nclearAllTSDBSymbolBaseCache()\n\n#### 参数\n\n无\n\n#### 详情\n\n清除缓存中所有未被使用的 symbolBase。其中，未被使用的 symbolBase 是指其对应分区的数据不在 Cache Engine 中，也不在执行的任何事务中。\n\n#### 例子\n\n```\nclearAllTSDBSymbolBaseCache();\n```\n"
    },
    "clearCachedDatabase": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clearCachedDatabase.html",
        "signatures": [
            {
                "full": "clearCachedDatabase(dbUrl, [tableName])",
                "name": "clearCachedDatabase",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [clearCachedDatabase](https://docs.dolphindb.cn/zh/funcs/c/clearCachedDatabase.html)\n\n\n\n#### 语法\n\nclearCachedDatabase(dbUrl, \\[tableName])\n\n#### 参数\n\n**dbUrl** 一个字符串，表示分布式数据库的路径。\n\n**tableName** 一个字符串，表示数据表的表名，可以是维度表或分布式表。\n\n#### 详情\n\n清理从数据库加载到内存的数据表的缓存。通过函数 [getSessionMemoryStat](https://docs.dolphindb.cn/zh/g/getSessionMemoryStat.dita) 可以查看系统中的不同缓存的占用情况。\n"
    },
    "clearCachedModules": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clearCachedModules.html",
        "signatures": [
            {
                "full": "clearCachedModules()",
                "name": "clearCachedModules",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [clearCachedModules](https://docs.dolphindb.cn/zh/funcs/c/clearCachedModules.html)\n\n\n\n#### 语法\n\nclearCachedModules()\n\n#### 参数\n\n无\n\n#### 详情\n\n清除缓存的 module。更新 module 文件后，通过该命令清除 module 缓存，执行 use 语句时，会重新从文件加载 module，无需重启节点。\n\n**Note:** 只有管理员（admin）才能执行该命令。\n\n#### 例子\n\n定义并导入一个 module\n\n```\nmodule printLog\ndef printLog(){\nprint \"hello\"\n}\n```\n\n加载模块\n\n```\nuse printLog\nprintLog()\n// output\nhello\n```\n\n修改 module\n\n```\nmodule printLog\ndef printLog(){\nprint \"hello new\"\n}\n```\n\n再次加载模块前，需要调用 `clearCachedModules` 以清除之前缓存的 module。\n\n```\nlogin(\"admin\", \"123456\")\n\nclearCachedModules();\n\nuse printLog\nprintLog()\n// output\nhello new\n```\n"
    },
    "clearComputeNodeCache": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clearcomputenodecache.html",
        "signatures": [
            {
                "full": "clearComputeNodeCache()",
                "name": "clearComputeNodeCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [clearComputeNodeCache](https://docs.dolphindb.cn/zh/funcs/c/clearcomputenodecache.html)\n\n\n\n#### 语法\n\nclearComputeNodeCache()\n\n#### 参数\n\n无\n\n#### 详情\n\n应用于计算组中的计算节点上，清空该节点的内存缓存和磁盘缓存。注意：执行该函数并不保证所有缓存内容被清空。\n"
    },
    "clearComputeNodeDiskCache": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clearcomputenodediskcache.html",
        "signatures": [
            {
                "full": "clearComputeNodeDiskCache()",
                "name": "clearComputeNodeDiskCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [clearComputeNodeDiskCache](https://docs.dolphindb.cn/zh/funcs/c/clearcomputenodediskcache.html)\n\n\n\n#### 语法\n\nclearComputeNodeDiskCache()\n\n#### 参数\n\n无\n\n#### 详情\n\n应用于计算组中的计算节点上，清空该节点的磁盘缓存。注意：执行该函数并不保证所有磁盘缓存内容被清空。\n"
    },
    "clearDSCacheNow": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clearDSCacheNow.html",
        "signatures": [
            {
                "full": "clearDSCacheNow(ds)",
                "name": "clearDSCacheNow",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    }
                ]
            }
        ],
        "markdown": "### [clearDSCacheNow](https://docs.dolphindb.cn/zh/funcs/c/clearDSCacheNow.html)\n\n\n\n#### 语法\n\nclearDSCacheNow(ds)\n\n#### 参数\n\n**ds** 是数据源或数据源列表。\n\n#### 详情\n\n函数 `clearDSCacheNow` 立即清除数据源和缓存。\n\n#### 例子\n\n```\nPTNDB_DIR = \"/home/db_testing\"\ndbName = database(PTNDB_DIR + \"/NYSETAQByName\")\nTrades = dbName.loadTable(`Trades)\n\nds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\nds.cacheDSNow()        // cache the data immediately\nds.clearDSCacheNow()  // clear the cache immediately\n```\n"
    },
    "clearDSCache!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clearDSCache_.html",
        "signatures": [
            {
                "full": "clearDSCache!(ds)",
                "name": "clearDSCache!",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    }
                ]
            }
        ],
        "markdown": "### [clearDSCache!](https://docs.dolphindb.cn/zh/funcs/c/clearDSCache_.html)\n\n\n\n#### 语法\n\nclearDSCache!(ds)\n\n#### 参数\n\n**ds** 是数据源或数据源列表。\n\n#### 详情\n\n`clearDSCache!` 函数指示系统在下次执行数据源之后清除缓存。\n\n#### 例子\n\n```\nPTNDB_DIR = \"/home/db_testing\"\ndbName = database(PTNDB_DIR + \"/NYSETAQByName\")\nTrades = dbName.loadTable(`Trades)\n\nds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\nds.cacheDS!()        // cache the data\nds.clearDSCache!()  // clear the cache\n```\n"
    },
    "clearTablePersistence": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clearTablePersistence.html",
        "signatures": [
            {
                "full": "clearTablePersistence(table)",
                "name": "clearTablePersistence",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [clearTablePersistence](https://docs.dolphindb.cn/zh/funcs/c/clearTablePersistence.html)\n\n\n\n#### 语法\n\nclearTablePersistence(table)\n\n#### 参数\n\n**table** 是一个表。\n\n#### 详情\n\n停止将流数据表持久化到磁盘，然后删除磁盘上表的内容，但仍然保留表的结构。\n\n#### 例子\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt = streamTable(100:0, colName, colType);\nenableTableShareAndPersistence(table=t, tableName=`st, cacheSize=1200000)\ngo;\n```\n\n```\nfor(s in 0:200){\n    n=10000\n    time=2019.01.01T00:00:00.000+s*n+1..n\n    x=rand(10.0, n)\n    insert into st values(time, x)\n}\nclearTablePersistence(st);\n```\n\n相关函数：[enableTablePersistence](https://docs.dolphindb.cn/zh/funcs/e/enableTablePersistence.html), [disableTablePersistence](https://docs.dolphindb.cn/zh/funcs/d/disableTablePersistence.html)\n"
    },
    "clear!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clear_.html",
        "signatures": [
            {
                "full": "clear!(X)",
                "name": "clear!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [clear!](https://docs.dolphindb.cn/zh/funcs/c/clear_.html)\n\n\n\n#### 语法\n\nclear!(X)\n\n#### 参数\n\n**X** 可以是向量、矩阵、集合、字典、内存表。\n\n#### 详情\n\n函数 `clear!` 用来清除 *X* 中的所有内容。对 *X* 执行该函数后，*X* 仍然存在，保持原有的数据类型，可以追加新的数据。\n\n#### 例子\n\n```\nx=1 2 3;\nclear!(x);\n\n// output\n[]\ntypestr x;\n\n// output\nFAST INT VECTOR\nsize x;\n\n// output\n0\nx.append!(1..6);\n\n// output\n[1,2,3,4,5,6]\n\ny=set(8 9 4 6);\ny.clear!();\n\n// output\nset()\n\nx=1..3;\ny=4..6;\nz=dict(x,y);\nz;\n\n// output\n3->6\n1->4\n2->5\nz.clear!();\n\nt = table(1 2 3 as id, 1.0 2.0 3.0 as value)\nt.clear!()\n```\n"
    },
    "clip": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clip.html",
        "signatures": [
            {
                "full": "clip(X,Y,Z)",
                "name": "clip",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "Z",
                        "name": "Z"
                    }
                ]
            }
        ],
        "markdown": "### [clip](https://docs.dolphindb.cn/zh/funcs/c/clip.html)\n\n\n\n#### 语法\n\nclip(X,Y,Z)\n\n#### 参数\n\n**X** 是一个数值型或时间类型的标量、向量、矩阵、表或 value 为数值型或时间类型的字典。\n\n**Y** 是一个数值型或时间类型的标量、向量、矩阵或表。\n\n**Z** 是一个数值型或时间类型的标量、向量、矩阵或表。\n\n*X*, *Y*, *Z* 数据类型必须匹配：\n\n* 若 *X* 为整型，*Y*、*Z* 必须为整型。\n\n* 若 *X* 为浮点型或 DECIMAL，*Y*、*Z* 可以为整型、浮点型或 DECIMAL 类型。\n\n* 若 *X* 为时间类型，*Y*、*Z* 必须为同类型的时间类型。\n\nX, Y, Z 的数据形式须满足以下要求：\n\n* 当 *X* 是标量或字典时，*Y* 和 *Z* 必须为标量。\n\n* 当 *X* 是向量时，*Y* 和 *Z* 可以是标量或与 *X*维度相同的向量。\n\n* 当 *X* 是矩阵时，*Y* 和 *Z* 可以是标量或与 *X* 维度相同的矩阵。\n\n* 当 *X* 是表时，*Y* 和 *Z* 可以是标量或与 *X* 维度相同的表。\n\n#### 详情\n\n返回一个与 X 数据形式和数据类型完全相同的 X'。\n\nX\\` 的值满足以下规则（当 X 为字典时，下述\"X'的元素\"表示字典 X\\` 的 value）：\n\n* 当 Y 和 Z 为标量时，X\\` 的元素被限制在 \\[Y, Z] 区间内：\n\n  * 1.1 Y 或 Z 为 NULL 表示对区间下界或上界不做限制。\n\n  * 1.2 若 Y 大于 Z，则 X\\` 中所有元素设为 Z。\n\n  * 1.3 对于 X 中落在 \\[Y, Z] 范围内的元素，其在 X' 中保留原值；对于超出该范围的元素，X' 中相应位置的值将被替换为最近的边界值，即小于 Y 的元素被设为 Y，大于 Z 的元素被设为 Z。\n\n* 当 Y 和 Z 为向量、矩阵或表时，对 X 中每个元素 x，根据相应位置的 \\[y, z] 组成的范围进行限制：\n\n  * 2.1 超出该范围的 x 依然按照上述规则进行处理。\n\n  * 2.2 若 Y 或 Z 某个位置元素为 NULL，则 X' 对应位置元素也为 NULL。\n\n  * 2.3 若 Y 或 Z 某个位置元素满足 y >z，则 X\\` 对应位置元素设为 z。\n\n* 当 Y 或 Z 其中之一为标量，另一个为向量、矩阵或表时：\n\n  * 3.1 标量值代表区间下界或上界固定，向量、矩阵或表中的元素代表不同位置的限制区间的下界或上界。\n\n  * 3.2 标量值为 NULL 表示对下界或上界不做限制，向量、矩阵或表的某一元素为 NULL 代表将 X‘ 对应位置元素设置为空值。\n\n  * 3.3 某个位置元素满足 y >z，则 X\\` 对应位置元素设为 z。\n\n#### 例子\n\n##### Y 和 Z 是标量\n\nY = NULL ，Z = 5 ，根据规则1.1，表示不限制下界，上界为 5，此时仅将表中大于 5 的值置为 5。\n\n```\nX = table(1..10 as val1, 10..1 as val2)\nY = NULL\nZ = 5\nclip(X,Y,Z)\n```\n\n<table id=\"table_bx3_tlm_cdc\"><thead><tr><th>\n\nval1\n\n</th><th>\n\nval2\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n4\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n3\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n2\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n1\n\n</td></tr></tbody>\n</table>Y 大于 Z （6&gt;3），根据规则1.2， X' 中所有元素被置为 3。\n\n```\nX = 1..10\nY = 6\nZ = 3\nclip(X,Y,Z)\n// output:[3,3,3,3,3,3,3,3,3,3]\n```\n\nY 和 Z 组成区间 \\[3,5]，根据规则1.3，X’ 中 value 小于3的值（1和2）被置为3，大于5的值（6）被置为5，其他元素得到保留。\n\n```\nX = dict(`a`b`c`d`e`f,[1,2,3,4,5,6])\nY = 3\nZ = 5\nclip(X,Y,Z)\n/*\noutput:\na->3\nb->3\nc->3\nd->4\ne->5\nf->5\n*/\n```\n\n##### Y 和 Z 是向量、矩阵或表\n\nY 和 Z 为与 X 维度相同的向量，用区间 \\[y\\[i], z\\[i]] 对 X\\[i] 进行限制：\n\n* X\\[0] 在 \\[Y\\[0],Z\\[0]] 区间内（1属于\\[0,3]），根据规则2.1，保留其值\n\n* X\\[3] 小于 Y\\[3]（4<5），根据规则2.1，X'\\[3] 置为 5（Y\\[3]）\n\n* X\\[9] 大于 Z\\[9]（10>9），根据规则2.1，X'\\[9] 置为 9（Z\\[9]）\n\n* Y\\[7] 和 Z\\[6] 为 NULL，根据规则2.2 ，X'\\[6] 和 X'\\[7] 为 NULL\n\n* Y\\[8] 大于 Z\\[8]（7>5），根据规则2.3，X'\\[8] 置为 5（Z\\[8]）\n\n```\nX = [1,2,3,4,5,6,7,8,9,10]\nY = [0,1,2,5,6,6,6,NULL,7,7]\nZ = [3,4,5,6,7,8,NULL,5,5,9]\nclip(X,Y,Z)\n// output:[1,2,3,5,6,6,,,5,9]\n```\n\n##### Y 或 Z 其中之一为标量，另一个为向量、矩阵或表\n\n下例中 Y 为 4，Z 为与 X 维度相同的矩阵，对 X 中元素 x\\[i,j]，用区间 \\[4,Z\\[i,j]] 对其进行限制：\n\n* X\\[0,0] 小于 Y（1<4），根据规则3.1， X'\\[0,0] 置为 4\n\n* Z\\[0,2] 为 NULL，根据规则3.2，X'\\[0,2] 置为 NULL\n\n* Y 大于 Z\\[1,2]（4>3），根据规则3.3， X'\\[1,2] 置为 3（Z\\[1,2]）\n\n```\nX = 1..8$2:4\nY = 4\nZ = [5,6,5,6,NULL,3,5,6]$2:4\nclip(X,Y,Z)\n// output:\n#0 #1 #2 #3\n-- -- -- --\n4  4     5 \n4  4  3  6 \n```\n"
    },
    "clip!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/clip_.html",
        "signatures": [
            {
                "full": "clip(X,Y,Z)",
                "name": "clip",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "Z",
                        "name": "Z"
                    }
                ]
            }
        ],
        "markdown": "### [clip!](https://docs.dolphindb.cn/zh/funcs/c/clip_.html)\n\n是 [clip](https://docs.dolphindb.cn/zh/funcs/c/clip.html) 的别名。\n\n\n以下是 `clip` 函数的文档：\n### [clip](https://docs.dolphindb.cn/zh/funcs/c/clip.html)\n\n\n\n#### 语法\n\nclip(X,Y,Z)\n\n#### 参数\n\n**X** 是一个数值型或时间类型的标量、向量、矩阵、表或 value 为数值型或时间类型的字典。\n\n**Y** 是一个数值型或时间类型的标量、向量、矩阵或表。\n\n**Z** 是一个数值型或时间类型的标量、向量、矩阵或表。\n\n*X*, *Y*, *Z* 数据类型必须匹配：\n\n* 若 *X* 为整型，*Y*、*Z* 必须为整型。\n\n* 若 *X* 为浮点型或 DECIMAL，*Y*、*Z* 可以为整型、浮点型或 DECIMAL 类型。\n\n* 若 *X* 为时间类型，*Y*、*Z* 必须为同类型的时间类型。\n\nX, Y, Z 的数据形式须满足以下要求：\n\n* 当 *X* 是标量或字典时，*Y* 和 *Z* 必须为标量。\n\n* 当 *X* 是向量时，*Y* 和 *Z* 可以是标量或与 *X*维度相同的向量。\n\n* 当 *X* 是矩阵时，*Y* 和 *Z* 可以是标量或与 *X* 维度相同的矩阵。\n\n* 当 *X* 是表时，*Y* 和 *Z* 可以是标量或与 *X* 维度相同的表。\n\n#### 详情\n\n返回一个与 X 数据形式和数据类型完全相同的 X'。\n\nX\\` 的值满足以下规则（当 X 为字典时，下述\"X'的元素\"表示字典 X\\` 的 value）：\n\n* 当 Y 和 Z 为标量时，X\\` 的元素被限制在 \\[Y, Z] 区间内：\n\n  * 1.1 Y 或 Z 为 NULL 表示对区间下界或上界不做限制。\n\n  * 1.2 若 Y 大于 Z，则 X\\` 中所有元素设为 Z。\n\n  * 1.3 对于 X 中落在 \\[Y, Z] 范围内的元素，其在 X' 中保留原值；对于超出该范围的元素，X' 中相应位置的值将被替换为最近的边界值，即小于 Y 的元素被设为 Y，大于 Z 的元素被设为 Z。\n\n* 当 Y 和 Z 为向量、矩阵或表时，对 X 中每个元素 x，根据相应位置的 \\[y, z] 组成的范围进行限制：\n\n  * 2.1 超出该范围的 x 依然按照上述规则进行处理。\n\n  * 2.2 若 Y 或 Z 某个位置元素为 NULL，则 X' 对应位置元素也为 NULL。\n\n  * 2.3 若 Y 或 Z 某个位置元素满足 y >z，则 X\\` 对应位置元素设为 z。\n\n* 当 Y 或 Z 其中之一为标量，另一个为向量、矩阵或表时：\n\n  * 3.1 标量值代表区间下界或上界固定，向量、矩阵或表中的元素代表不同位置的限制区间的下界或上界。\n\n  * 3.2 标量值为 NULL 表示对下界或上界不做限制，向量、矩阵或表的某一元素为 NULL 代表将 X‘ 对应位置元素设置为空值。\n\n  * 3.3 某个位置元素满足 y >z，则 X\\` 对应位置元素设为 z。\n\n#### 例子\n\n##### Y 和 Z 是标量\n\nY = NULL ，Z = 5 ，根据规则1.1，表示不限制下界，上界为 5，此时仅将表中大于 5 的值置为 5。\n\n```\nX = table(1..10 as val1, 10..1 as val2)\nY = NULL\nZ = 5\nclip(X,Y,Z)\n```\n\n<table id=\"table_bx3_tlm_cdc\"><thead><tr><th>\n\nval1\n\n</th><th>\n\nval2\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n5\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n4\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n3\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n2\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\n1\n\n</td></tr></tbody>\n</table>Y 大于 Z （6&gt;3），根据规则1.2， X' 中所有元素被置为 3。\n\n```\nX = 1..10\nY = 6\nZ = 3\nclip(X,Y,Z)\n// output:[3,3,3,3,3,3,3,3,3,3]\n```\n\nY 和 Z 组成区间 \\[3,5]，根据规则1.3，X’ 中 value 小于3的值（1和2）被置为3，大于5的值（6）被置为5，其他元素得到保留。\n\n```\nX = dict(`a`b`c`d`e`f,[1,2,3,4,5,6])\nY = 3\nZ = 5\nclip(X,Y,Z)\n/*\noutput:\na->3\nb->3\nc->3\nd->4\ne->5\nf->5\n*/\n```\n\n##### Y 和 Z 是向量、矩阵或表\n\nY 和 Z 为与 X 维度相同的向量，用区间 \\[y\\[i], z\\[i]] 对 X\\[i] 进行限制：\n\n* X\\[0] 在 \\[Y\\[0],Z\\[0]] 区间内（1属于\\[0,3]），根据规则2.1，保留其值\n\n* X\\[3] 小于 Y\\[3]（4<5），根据规则2.1，X'\\[3] 置为 5（Y\\[3]）\n\n* X\\[9] 大于 Z\\[9]（10>9），根据规则2.1，X'\\[9] 置为 9（Z\\[9]）\n\n* Y\\[7] 和 Z\\[6] 为 NULL，根据规则2.2 ，X'\\[6] 和 X'\\[7] 为 NULL\n\n* Y\\[8] 大于 Z\\[8]（7>5），根据规则2.3，X'\\[8] 置为 5（Z\\[8]）\n\n```\nX = [1,2,3,4,5,6,7,8,9,10]\nY = [0,1,2,5,6,6,6,NULL,7,7]\nZ = [3,4,5,6,7,8,NULL,5,5,9]\nclip(X,Y,Z)\n// output:[1,2,3,5,6,6,,,5,9]\n```\n\n##### Y 或 Z 其中之一为标量，另一个为向量、矩阵或表\n\n下例中 Y 为 4，Z 为与 X 维度相同的矩阵，对 X 中元素 x\\[i,j]，用区间 \\[4,Z\\[i,j]] 对其进行限制：\n\n* X\\[0,0] 小于 Y（1<4），根据规则3.1， X'\\[0,0] 置为 4\n\n* Z\\[0,2] 为 NULL，根据规则3.2，X'\\[0,2] 置为 NULL\n\n* Y 大于 Z\\[1,2]（4>3），根据规则3.3， X'\\[1,2] 置为 3（Z\\[1,2]）\n\n```\nX = 1..8$2:4\nY = 4\nZ = [5,6,5,6,NULL,3,5,6]$2:4\nclip(X,Y,Z)\n// output:\n#0 #1 #2 #3\n-- -- -- --\n4  4     5 \n4  4  3  6 \n```\n"
    },
    "close": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/close.html",
        "signatures": [
            {
                "full": "close(X)",
                "name": "close",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [close](https://docs.dolphindb.cn/zh/funcs/c/close.html)\n\n\n\n#### 语法\n\nclose(X)\n\n#### 参数\n\n**X** 是一个文件句柄或远程连接。\n\n#### 详情\n\n关闭一个已打开的文件或远程连接。该函数必须要用户登录后才能执行。\n\n#### 例子\n\n```\nfout.writeLine(\"hello world!\");\n// output\n1\nfout.close();\nfin = file(\"test3.txt\");\nprint fin.readLine();\nhello world!\nfin.close();\n```\n"
    },
    "closeSessions": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/closeSessions.html",
        "signatures": [
            {
                "full": "closeSessions(sessionId)",
                "name": "closeSessions",
                "parameters": [
                    {
                        "full": "sessionId",
                        "name": "sessionId"
                    }
                ]
            }
        ],
        "markdown": "### [closeSessions](https://docs.dolphindb.cn/zh/funcs/c/closeSessions.html)\n\n\n\n#### 语法\n\ncloseSessions(sessionId)\n\n#### 参数\n\n**sessionId** 是一个 LONG 类型的标量或向量，表示一个或多个 session ID。\n\n#### 详情\n\n关闭一个或多个 session。\n\n#### 例子\n\n```\ngetSessionMemoryStat();\n```\n\n| userId                   | sessionId     | memSize | remoteIP    | remotePort | createTime              | lastActiveTime          |\n| ------------------------ | ------------- | ------- | ----------- | ---------- | ----------------------- | ----------------------- |\n| \\_DimensionalTable\\_     | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_SharedTable\\_          | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_OLAPTablet\\_           | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_OLAPCacheEngine\\_      | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_OLAPCachedSymbolBase\\_ | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_DFSMetadata\\_          | 13,571        | 0.0.0.0 |             |            |                         |                         |\n| \\_TSDBCacheEngine\\_      | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_TSDBLevelFileIndex\\_   | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_TSDBCachedSymbolBase\\_ | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_StreamingPubQueue\\_    | 0             | 0.0.0.0 |             |            |                         |                         |\n| \\_StreamingSubQueue\\_    | 0             | 0.0.0.0 |             |            |                         |                         |\n| guest                    | 1,769,725,800 | 16      | 36.27.51.13 | 63,133     | 1970.01.01T00:00:00.000 | 2023.08.31T22:35:27.385 |\n| admin                    | 2,882,591,513 | 6,449   | 36.27.51.13 | 60,812     | 1970.01.01T00:00:00.000 | 2023.08.31T22:18:27.562 |\n\n```\ncloseSessions(getSessionMemoryStat().sessionId[11]);\n```\n"
    },
    "coevent": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/coevent.html",
        "signatures": [
            {
                "full": "coevent(event, eventTime, window, [orderSensitive=false])",
                "name": "coevent",
                "parameters": [
                    {
                        "full": "event",
                        "name": "event"
                    },
                    {
                        "full": "eventTime",
                        "name": "eventTime"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[orderSensitive=false]",
                        "name": "orderSensitive",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [coevent](https://docs.dolphindb.cn/zh/funcs/c/coevent.html)\n\n\n\n#### 语法\n\ncoevent(event, eventTime, window, \\[orderSensitive=false])\n\n#### 参数\n\n**event** 是一个向量，表示事件。\n\n**eventTime** 是一个时间类型或整型类型的向量，表示事件发生时间。它的长度必须与 *event* 相同。\n\n**window** 是一个非负整数，表示时间间隔长度。\n\n**orderSensitive** 是一个可选的布尔值，表示是否区分两个事件的先后顺序。默认值是 false。\n\n#### 详情\n\n统计给定的时间间隔内出现事件对的次数。如果 *eventTime* 中包含 NULL 值，系统会忽略这条记录。\n\n返回的结果是一个表，包含 event1, event2 和 hits 三个字段。event1 和 event2 的数据类型与 *event* 相同，hits 是整数，表示事件对出现的次数。\n\n#### 例子\n\n下例中，sensor\\_id 与 time 分别为发现异常的传感器编号以及发现异常时刻。使用 `coevent` 函数统计5秒钟内两个传感器同时出现异常的次数。\n\n```\nsensor_id=`A`B`C`D`C`A`B\ntime=[2012.06.13T12:30:00,2012.06.13T12:30:02,2012.06.13T12:30:04,2012.06.13T12:30:05,2012.06.13T12:30:06,2012.06.13T12:30:09,2012.06.13T12:30:10];\n\ncoevent(sensor_id, time, 2);\n```\n\n| event1 | event2 | hits |\n| ------ | ------ | ---- |\n| B      | C      | 1    |\n| C      | D      | 2    |\n| C      | C      | 1    |\n| A      | B      | 2    |\n\n```\ncoevent(sensor_id, time, 2, true);\n```\n\n| event1 | event2 | hits |\n| ------ | ------ | ---- |\n| C      | C      | 1    |\n| B      | C      | 1    |\n| C      | D      | 1    |\n| D      | C      | 1    |\n| A      | B      | 2    |\n"
    },
    "coint": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/coint.html",
        "signatures": [
            {
                "full": "coint(Y0, Y1, [trend=\"c\"], [method=\"aeg\"], [maxLag], [autoLag=\"aic\"])",
                "name": "coint",
                "parameters": [
                    {
                        "full": "Y0",
                        "name": "Y0"
                    },
                    {
                        "full": "Y1",
                        "name": "Y1"
                    },
                    {
                        "full": "[trend=\"c\"]",
                        "name": "trend",
                        "optional": true,
                        "default": "\"c\""
                    },
                    {
                        "full": "[method=\"aeg\"]",
                        "name": "method",
                        "optional": true,
                        "default": "\"aeg\""
                    },
                    {
                        "full": "[maxLag]",
                        "name": "maxLag",
                        "optional": true
                    },
                    {
                        "full": "[autoLag=\"aic\"]",
                        "name": "autoLag",
                        "optional": true,
                        "default": "\"aic\""
                    }
                ]
            }
        ],
        "markdown": "### [coint](https://docs.dolphindb.cn/zh/funcs/c/coint.html)\n\n#### 语法\n\ncoint(Y0, Y1, \\[trend=\"c\"], \\[method=\"aeg\"], \\[maxLag], \\[autoLag=\"aic\"])\n\n#### 详情\n\n检验单变量方程中是否存在协整性。结果以字典的形式返回，包括：\n\n* tStat：浮点数标量，表示残差的单位根检验的 t 统计量\n* pValue：浮点数标量，表示 MacKinnon 近似 p 值\n* criticalValues：字典，表示基于回归曲线，在1％、5％和10％水平上的检验统计量的临界值\n\n#### 参数\n\n**Y0** 数值向量，元素不可为空值，表示协整系统中的第一个元素。\n\n**Y1** 数值向量或数值矩阵，元素不可为空值，且元素个数与 Y0 相同。表示协整系统中的其余元素。\n\n**trend**字符串，指定协整方程的回归中使用的趋势项。取值有如下选择：\n\n* \"c\"：默认值，表示只使用常数。\n* \"ct\"：使用常数和趋势。\n* \"ctt\"：使用常数、线性趋势和二次趋势。\n* \"n\"：不使用常数和趋势。\n\n**method**字符串，指定协整检验所使用的方法，支持取值为 “aeg”，代表增广 Engle-Granger 两步协整性检验。\n\n**maxLag**非负整数，作为调用 adfuller 时传递的参数，指定 adfuller 检验中使用的最大滞后期。\n\n**autoLag**字符串，作为调用 `adfuller` 时传递的参数，指定在 0\\~maxLag 中自动确定滞后期长度时使用的方法。取值有如下选择：\n\n* \"aic\"：默认值，表示使用 Akaike Information Criterion 来确定滞后期数值。\n* \"bic\"：表示使用 Bayesian information criterion 来确定滞后期数值。\n* \"tstat\"：将滞后期初始值设为 maxLag，然后逐步减 1，直到上一个滞后期数值的 t 统计量在 5% 显著性水平上显著。\n* \"max\"：将滞后期数值设置为 maxLag。\n\n#### 例子\n\n```\nY0 = 234 267 289 301 312 323 334 345 356;\nY1 = 267 289 301 312 323 334 345 356 367;\ncoint(Y0, Y1);\n```\n\n输出为字典：\n\n```\ntValue->-1.498236972489574\npValue->0.761867238199341\ncriticalValues->[-5.789286875000001,-4.206501875,-3.6171]\n```\n\n"
    },
    "col": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/col.html",
        "signatures": [
            {
                "full": "col(obj, index)",
                "name": "col",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "index",
                        "name": "index"
                    }
                ]
            }
        ],
        "markdown": "### [col](https://docs.dolphindb.cn/zh/funcs/c/col.html)\n\n\n\n#### 语法\n\ncol(obj, index) 或 column(obj, index)\n\n#### 参数\n\n**obj** 可以是向量、矩阵或表。\n\n**index** 是一个整数标量或数据对。\n\n#### 详情\n\n返回向量、矩阵或表的一列。参见相关函数：[row](https://docs.dolphindb.cn/zh/funcs/r/row.html)。\n\n#### 例子\n\n```\nx=1..6$3:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ncol(x,0);\n// output\n[1,2,3]\n\nx.col(1);\n// output\n[4,5,6]\n\na=table(1..3 as x,`IBM`C`AAPL as y);\na;\n```\n\n| x | y    |\n| - | ---- |\n| 1 | IBM  |\n| 2 | C    |\n| 3 | AAPL |\n\n```\na col 1;\n// output\n[\"IBM\",\"C\",\"AAPL\"]\n```\n"
    },
    "cols": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cols.html",
        "signatures": [
            {
                "full": "cols(X)",
                "name": "cols",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cols](https://docs.dolphindb.cn/zh/funcs/c/cols.html)\n\n\n\n#### 语法\n\ncols(X)\n\n#### 参数\n\n**X** 可以是向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 中列的数目。参见相关函数：[rows](https://docs.dolphindb.cn/zh/funcs/r/rows.html)。\n\n#### 例子\n\n```\nx=1..6$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\ncols x;\n// output\n3\n\na=table(1..3 as x,`IBM`C`AAPL as y);\na;\n```\n\n| x | y    |\n| - | ---- |\n| 1 | IBM  |\n| 2 | C    |\n| 3 | AAPL |\n\n```\ncols a;\n// output\n2\n\ny=1 2 3;\ncols(y);\n// output\n1\n// 向量可以被视为一个 n*1 的矩阵\n```\n"
    },
    "columnNames": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/columnNames.html",
        "signatures": [
            {
                "full": "columnNames(X)",
                "name": "columnNames",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [columnNames](https://docs.dolphindb.cn/zh/funcs/c/columnNames.html)\n\n\n\n#### 语法\n\ncolumnNames(X)\n\n#### 参数\n\n**X** 可以是矩阵或表。\n\n#### 详情\n\n返回 *X* 的列名的向量。参见相关函数：[rowNames](https://docs.dolphindb.cn/zh/funcs/r/rowNames.html)。\n\n#### 例子\n\n```\nx=1..6$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nx.rename!(`a`b`c);\n```\n\n| a | b | c |\n| - | - | - |\n| 1 | 3 | 5 |\n| 2 | 4 | 6 |\n\n```\nx.columnNames();\n// output\n[\"a\",\"b\",\"c\"]\n\nt = table(1 2 3 as id, 4 5 6 as value, `IBM`MSFT`GOOG as name);\nt;\n```\n\n| id | value | name |\n| -- | ----- | ---- |\n| 1  | 4     | IBM  |\n| 2  | 5     | MSFT |\n| 3  | 6     | GOOG |\n\n```\ncolumnNames t;\n// output\n[\"id\",\"value\",\"name\"]\n\nt[t.columnNames().tail()];\n// output\n[\"IBM\",\"MSFT\",\"GOOG\"]\n// 获取表的最后一列，返回的结果是一个向量\n```\n"
    },
    "complex": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/complex.html",
        "signatures": [
            {
                "full": "complex(X, Y)",
                "name": "complex",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [complex](https://docs.dolphindb.cn/zh/funcs/c/complex.html)\n\n\n\n#### 语法\n\ncomplex(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是数值型的标量、数据对、向量或矩阵，支持的数据类型为 INTEGRAL 类（COMPRESSED、INT128 除外）和 FLOATING 类。\n\n#### 详情\n\n创建复数 X+Y\\*i。\n\n复数类型的数据长度为16字节，其中低8位的数据存储于 *X* 中，高8位的数据存储于 *Y* 中。\n\n#### 例子\n\n```\ncomplex(2, 5)\n// output: 2.0+5.0i\n\na=1.0 2.3\nb=3 4\ncomplex(a,b)\n\n// output：[1+3i,2.3+4i]\n```\n"
    },
    "compress": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/compress.html",
        "signatures": [
            {
                "full": "compress(X, [method='lz4'])",
                "name": "compress",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[method='lz4']",
                        "name": "method",
                        "optional": true,
                        "default": "'lz4'"
                    }
                ]
            }
        ],
        "markdown": "### [compress](https://docs.dolphindb.cn/zh/funcs/c/compress.html)\n\n\n\n#### 语法\n\ncompress(X, \\[method='lz4'])\n\n#### 参数\n\n**X** 是一个向量或数据表。\n\n**method** 是一个字符串，为压缩算法，可取值为 \"lz4\", \"delta\", \"zstd\" 或 \"chimp\"，默认值为 \"lz4\"。其中，\n\n* lz4 适用于几乎所有数据类型，它侧重于压缩和解压速度，虽然压缩比不是最高的，但解压速度快，适用于需要快速解压的场景。\n* zstd 同样适用于几乎所有数据类型，其压缩比高于 lz4，但解压缩速度较 lz4 慢约1倍。它适用于对压缩比有较高要求的场景。\n* delta 适用于 SHORT, INT, LONG 与时间或日期类型数据。\n* chimp 适用于小数部分长度在三位以内的 DOUBLE 类型的数据。\n\n#### 详情\n\n使用指定压缩算法对向量或数据表进行压缩。压缩某个变量后，需要使用函数 [decompress](https://docs.dolphindb.cn/zh/funcs/d/decompress.html) 将其解压缩后方可使用该变量。\n\n#### 例子\n\n```\nx=1..100000000\ny=compress(x, \"delta\");\n\ny.typestr();\n// output: HUGE COMPRESSED VECTOR\n\nz=compress(x, \"zstd\");\nz.typestr();\n// output: HUGE COMPRESSED VECTOR\n\nselect name, bytes from objs() where name in `x`y;\n```\n\n| name | bytes     |\n| ---- | --------- |\n| x    | 402653952 |\n| y    | 13634544  |\n\n**Note:** 对向量 x 压缩后的结果（y ）使用 `size` 函数，结果为 y 的长度，而不是 x 的长度。若要从 y 中获取 x 的长度或其它信息，需先将 y 解压缩：\n\n```\ny.size();\n// output: 12670932\n\nz=decompress(y);\nz.size();\n// output: 100000000\n```\n\n相关函数：[decompress](https://docs.dolphindb.cn/zh/funcs/d/decompress.html)\n"
    },
    "concat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/concat.html",
        "signatures": [
            {
                "full": "concat(X, Y)",
                "name": "concat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [concat](https://docs.dolphindb.cn/zh/funcs/c/concat.html)\n\n\n\n#### 语法\n\nconcat(X, Y)\n\n#### 参数\n\n**X** 可以是字符串标量/向量、字符标量/向量。\n\n**Y** 是字符串或字符。\n\n若 *X* 或 *Y* 未指定，则它们将被处理为空字符串。\n\n#### 详情\n\n如果 *X* 是字符串或字符：\n\n* 当 *X* 为空时，若 *Y* 是空字符串或空字符，该函数返回一个空字符串；若 *Y* 是非空字符串或非空字符，该函数返回字符串 *Y*。\n* 当 *X* 非空时，无论 *Y* 是否为空，该函数将 *Y* 连接到 *X* 之后，返回新的字符串。\n\n如果 *X* 是字符串向量或字符向量：\n\n* 当 *X* 为空时，无论 *Y* 是否为空，该函数总是返回一个空字符串。\n* 当 *X* 非空时，若 *Y* 是空字符串或空字符，该函数将 *X* 的每个元素依次连接成一个新的字符串并返回；若 *Y* 非空，该函数依次连接 *X* 中每个字符串（字符），并使用 *Y* 对分隔它们隔，返回新的字符串。\n\n**Note:** `concat` 在进行连接之前会将所有参数隐式转换为字符串类型，将空值隐式转换为空字符串。\n\n**返回值：** 字符串（STRING）\n\n#### 例子\n\n```\n// 连接两个字符串\nconcat (`hello, `world);\n// output\nhelloworld\n\n// 返回在 IBM, GOOG 和 APPL 间用 \",\" 分隔的结果\nx = concat(`IBM`GOOG`APPL, \",\");\nx;\n// output\nIBM,GOOG,APPL\n\ntypestr x;\n// output\nSTRING\n\nsize x;\n// output\n1\n\nconcat(string([]),\"a\")\n// output\nNULL\n\nconcat(\"55\",\"\")\n// output\n55\n\n// Y 未指定，将 X 的每个元素直接拼接为1个字符串\nconcat(`a`b`c`d,)\n// output\nabcd\n```\n"
    },
    "concatDateTime": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/concatDateTime.html",
        "signatures": [
            {
                "full": "concatDateTime(date, time)",
                "name": "concatDateTime",
                "parameters": [
                    {
                        "full": "date",
                        "name": "date"
                    },
                    {
                        "full": "time",
                        "name": "time"
                    }
                ]
            }
        ],
        "markdown": "### [concatDateTime](https://docs.dolphindb.cn/zh/funcs/c/concatDateTime.html)\n\n\n\n#### 语法\n\nconcatDateTime(date, time)\n\n别名：concatDT\n\n#### 参数\n\n**date** 可以是 DATE 类型的标量或向量。\n\n**time** 可以是 SECOND、TIME 或 NANOTIME 类型的标量或向量。\n\n如果 *date* 和 *time* 都是向量，它们的长度必须相同。\n\n#### 详情\n\n合并日期和时间。如果 *time* 是 SECOND 类型，返回的结果是 DATETIME 类型；如果 *time* 是 TIME 类型，返回的结果是 TIMESTAMP 类型；如果 *time* 是 NANOTIME，返回的结果是 NANOTIMESTAMP 类型。\n\n#### 例子\n\n```\nconcatDateTime(2019.06.15,13:25:10);\n// output\n2019.06.15T13:25:10\n\nconcatDateTime(2019.06.15,[13:25:10, 13:25:12, 13:25:13]);\n// output\n[2019.06.15T13:25:10,2019.06.15T13:25:12,2019.06.15T13:25:13]\n\ndate=[2019.06.18, 2019.06.20, 2019.06.21, 2019.06.19, 2019.06.18, 2019.06.20]\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26]\nsym = `C`MS`MS`MS`IBM`IBM$SYMBOL\nprice= 49.6 29.46 29.52 30.02 174.97 175.23\nqty = 2200 1900 2100 3200 6800 5400\nt = table(date, time, sym, qty, price);\n\nselect concatDateTime(date,time) as datetime, sym, qty, price from t;\n```\n\n| datetime            | sym | qty  | price  |\n| ------------------- | --- | ---- | ------ |\n| 2019.06.18T09:34:07 | C   | 2200 | 49.6   |\n| 2019.06.20T09:36:42 | MS  | 1900 | 29.46  |\n| 2019.06.21T09:36:51 | MS  | 2100 | 29.52  |\n| 2019.06.19T09:36:59 | MS  | 3200 | 30.02  |\n| 2019.06.18T09:32:47 | IBM | 6800 | 174.97 |\n| 2019.06.20T09:35:26 | IBM | 5400 | 175.23 |\n"
    },
    "concatMatrix": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/concatMatrix.html",
        "signatures": [
            {
                "full": "concatMatrix(X, [horizontal=true])",
                "name": "concatMatrix",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[horizontal=true]",
                        "name": "horizontal",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [concatMatrix](https://docs.dolphindb.cn/zh/funcs/c/concatMatrix.html)\n\n\n\n#### 语法\n\nconcatMatrix(X, \\[horizontal=true])\n\n#### 参数\n\n**X** 由多个矩阵构成的元组。\n\n**horizontal** 布尔值，是否水平拼接矩阵，默认值为 true。若为 false 表示垂直拼接。\n\n#### 详情\n\n水平或垂直拼接多个矩阵。返回一个拼接后的矩阵对象。\n\n如果水平拼接多个矩阵，它们的行数必须相同；如果垂直拼接多个矩阵，它们的列数必须相同。\n\n#### 例子\n\n```\nm1 = matrix(4 0 5, 2 1 8);\nm2 = matrix(2 9 8, 3 7 -3, 6 4 2, 0 5 8);\nm3 = matrix(1 -1 6 2, 1 -3 1 9, 5 3 0 -4, 1 NULL 3 4);\nconcatMatrix([m1, m2]);\n```\n\n| col1 | col2 | col3 | col4 | col5 | col6 |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n| 4    | 2    | 2    | 3    | 6    | 0    |\n| 0    | 1    | 9    | 7    | 4    | 5    |\n| 5    | 8    | 8    | -3   | 2    | 8    |\n\n```\nprint concatMatrix([m2, m3], false);\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 2    | 3    | 6    | 0    |\n| 9    | 7    | 4    | 5    |\n| 8    | -3   | 2    | 8    |\n| 1    | 1    | 5    | 1    |\n| -1   | -3   | 3    |      |\n| 6    | 1    | 0    | 3    |\n| 2    | 9    | 4    | 4    |\n"
    },
    "conditionalFilter": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/conditionalFilter.html",
        "signatures": [
            {
                "full": "conditionalFilter(X, condition, filterMap)",
                "name": "conditionalFilter",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "condition",
                        "name": "condition"
                    },
                    {
                        "full": "filterMap",
                        "name": "filterMap"
                    }
                ]
            }
        ],
        "markdown": "### [conditionalFilter](https://docs.dolphindb.cn/zh/funcs/c/conditionalFilter.html)\n\n\n\n#### 语法\n\nconditionalFilter(X, condition, filterMap)\n\n#### 参数\n\n**X** 是标量或者向量。\n\n**condition** 是标量，或与 *X* 等长的向量。\n\n**filterMap** 是字典，表示过滤条件。\n\n#### 详情\n\n根据给定的字典参数 *filterMap*，若向量 *condition* 中某元素为该字典的 key，而且向量 *X* 中相应位置元素为字典中该 key 值对应的 value 表示的向量中一个元素，或在该 value 表示的数据对的范围中时，返回 true，否则返回 false。\n\n如果 *X* 和 *condition* 都是向量，返回的结果是与它们等长的向量。\n\n#### 例子\n\n例1：\n\n```\nconditionalFilter(1 2 3,`a`b`c, dict(`a`b,1 2));\n// output\n[1,1,0]\n\nconditionalFilter(1 2 3,`a`b`b, dict(`a`b,[1 2,3 4]))\n// output\n[1,0,1]\n```\n\n例2：\n\n从数据表 t 中，提取如下天内指定股票的数据：\n\n2012.06.01: C, MS 2012.06.02: IBM, MS 2012.06.03: MS 2012.06.04: IBM\n\n```\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C$SYMBOL\ndate = 2012.06.01 2012.06.01 2012.06.02 2012.06.03 2012.06.01 2012.06.02 2012.06.02 2012.06.03 2012.06.04\nprice = 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nt = table(sym, date, price, qty)\nt;\n```\n\n| sym | date       | price  | qty  |\n| --- | ---------- | ------ | ---- |\n| C   | 2012.06.01 | 49.60  | 2200 |\n| MS  | 2012.06.01 | 29.46  | 1900 |\n| MS  | 2012.06.02 | 29.52  | 2100 |\n| MS  | 2012.06.03 | 30.02  | 3200 |\n| IBM | 2012.06.01 | 174.97 | 6800 |\n| IBM | 2012.06.02 | 175.23 | 5400 |\n| C   | 2012.06.02 | 50.76  | 1300 |\n| C   | 2012.06.03 | 50.32  | 2500 |\n| C   | 2012.06.04 | 51.29  | 8800 |\n\n```\nfilter = dict(2012.06.01..2012.06.04, [`C`MS, `IBM`MS, `MS, `IBM])\nselect * from t where conditionalFilter(sym, date, filter) order by date, sym;\n```\n\n| sym | date       | price  | qty  |\n| --- | ---------- | ------ | ---- |\n| C   | 2012.06.01 | 49.6   | 2200 |\n| MS  | 2012.06.01 | 29.46  | 1900 |\n| IBM | 2012.06.02 | 175.23 | 5400 |\n| MS  | 2012.06.02 | 29.52  | 2100 |\n| MS  | 2012.06.03 | 30.02  | 3200 |\n\n例3：\n\n*filterMap* 的 value 亦可采用数据对的形式。\n\n```\nt=table(`aaa`aaa`bbb`bbb as id, 2020.09.03 2020.09.10 2020.09.06 2020.09.09 as date)\nt\n```\n\n| id  | date       |\n| --- | ---------- |\n| aaa | 2020.09.03 |\n| aaa | 2020.09.10 |\n| bbb | 2020.09.06 |\n| bbb | 2020.09.09 |\n\n```\nmydict = dict(`aaa`bbb, [2020.09.01 : 2020.09.09,  2020.09.05 : 2020.09.09])\nselect * from t where conditionalFilter(date, id, mydict);\n```\n\n| id  | date       |\n| --- | ---------- |\n| aaa | 2020.09.03 |\n| bbb | 2020.09.06 |\n| bbb | 2020.09.09 |\n"
    },
    "conditionalIterate": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/conditionalIterate.html",
        "signatures": [
            {
                "full": "conditionalIterate(cond, trueValue, falseIterFunc)",
                "name": "conditionalIterate",
                "parameters": [
                    {
                        "full": "cond",
                        "name": "cond"
                    },
                    {
                        "full": "trueValue",
                        "name": "trueValue"
                    },
                    {
                        "full": "falseIterFunc",
                        "name": "falseIterFunc"
                    }
                ]
            }
        ],
        "markdown": "### [conditionalIterate](https://docs.dolphindb.cn/zh/funcs/c/conditionalIterate.html)\n\n\n\n#### 语法\n\nconditionalIterate(cond, trueValue, falseIterFunc)\n\n该函数只能用作响应式状态引擎 metrics 中的函数。\n\n#### 参数\n\n**cond** 布尔表达式/返回值是布尔类型的函数。需要包含输入表中的字段，不支持常量/常量表达式。\n\n**trueValue** 计算公式。计算结果将作为 *cond* 为 true 时的输出值。\n\n**falseIterFunc** 用于进行迭代计算的函数。必须是一个单目函数，其唯一参数是 `conditionalIterate` 对应输出表中的字段。目前只支持以下函数（非单目函数以部分应用形式给出其他参数）：\n\n* 滑动窗口函数：`tmove`, `tmavg`, `tmmax`, `tmmin`, `tmsum`, `mavg`, `mmax`, `mmin`, `mcount`, `msum`\n* 累计窗口函数：`cumlastNot`, `cumfirstNot`\n* 序列相关函数：`ffill`, `move`\n\n若当前记录的 *cond* 为 true 时，触发 *trueValue* 的计算；若当前记录的 *cond* 为 false，则基于 `conditionalIterate` 的历史结果，调用 *falseIterFunc* 进行迭代计算。\n\n**Note:**\n\n* 由于迭代是基于历史数据进行的，因此当前记录的输出是由输出表中的历史结果计算得到的。\n* tm系列函数计算时，时间窗口由当前记录的时间戳确定。由于迭代不包含当前记录，因此实质上的，且计算窗口范围为 (T - window, T)。\n* *trueValue* 和 *falseIterFunc* 计算结果的类型需要兼容，且需要确保 *trueValue* 结果的精度和数据范围大于 *falseIterFunc*。\n\n#### 详情\n\n通过条件迭代实现因子中的递归逻辑。\n\n假设该函数计算结果对应输出表的列为 factor，且迭代仅基于前一个值，对于第 k 条记录(k = 0, 1, 2 …)，其计算逻辑为：\n\n* cond\\[k] == true：factor\\[k] = trueValue\n* cond\\[k] == false：factor\\[k] = falseIterFunc(factor)\\[k-1]\n\n**Note:** 若 *falseIterFunc* 为窗口函数，则会基于前多个 factor 值进行计算。\n\n#### 例子\n\n例1. 通过一个简单的例子，快速了解 `conditionalIterate` 函数的计算逻辑：\n\n```\ntrade = table(take(\"A\", 10) as sym,  take(1 3 6, 10) as val0,  take(10, 10) as val1)\ntrade\n```\n\n| sym | val0 | val1 |\n| --- | ---- | ---- |\n| A   | 1    | 10   |\n| A   | 3    | 10   |\n| A   | 6    | 10   |\n| A   | 1    | 10   |\n| A   | 3    | 10   |\n| A   | 6    | 10   |\n| A   | 1    | 10   |\n| A   | 3    | 10   |\n| A   | 6    | 10   |\n| A   | 1    | 10   |\n\n创建一个响应式状态引擎，并按 sym 列分组进行计算。组内的计算逻辑如下：\n\n* 若满足 val0 > 5，若返回 true，则 *factor\\[k]=trueValue*，即以 val1 值作为输出。\n* 若不满足 val0 > 5，则对应计算公式为 factor\\[k]=falseIterFunc(factor)\\[k-1]。当 k=3 时，对应 val0=1，val1=10，factor=\\[NULL, NULL, 10]，带入公式计算即 msum(\\[NULL, NULL, 10], 3)\\[2]=10；当 k=4 时，对应 val0=3，val1=10，factor=\\[NULL, NULL, 10, 10]，带入公式计算即 msum(\\[NULL, NULL, 10, 10], 3)\\[3]=20，以此类推。\n\n```\ninputTable = streamTable(1:0, `sym`val0`val1, [SYMBOL, INT, INT])\noutputTable = table(100:0, `sym`factor, [STRING, DOUBLE])\nrse = createReactiveStateEngine(name=\"rsTest\", metrics=<conditionalIterate(val0 > 5, val1, msum{, 3})>, dummyTable=inputTable, outputTable=outputTable, keyColumn=\"sym\")\nrse.append!(trade)\nselect * from outputTable\n```\n\n| sym | factor |\n| --- | ------ |\n| A   |        |\n| A   |        |\n| A   | 10     |\n| A   | 10     |\n| A   | 20     |\n| A   | 10     |\n| A   | 40     |\n| A   | 70     |\n| A   | 10     |\n| A   | 120    |\n\n例2. 某因子在函数中算法逻辑如下：\n\n```\ndef factor(TotalVolumeTrade, TotalValueTrade, HighPx, LowPx){\n    factorValue = iif(TotalVolumeTrade < 1500000, pow(HighPx*LowPx, 0.5)-(TotalVolumeTrade/TotalValueTrade), mavg(factor(TotalVolumeTrade, TotalValueTrade, HighPx, LowPx), 3))\n    return factorValue\n}\n```\n\n该函数包含了一个递归操作。若需要在响应式状态引擎中实现上述逻辑，可以通过函数 `conditionalIterate` 实现。具体实现脚本如下：\n\n```\n@state\ndef factor1(TotalVolumeTrade, TotalValueTrade, HighPx, LowPx){\n   factorValue = conditionalIterate(TotalVolumeTrade < 1500000, (pow(HighPx*LowPx, 0.5)-(TotalVolumeTrade/TotalValueTrade)), mavg{,3})\n   return factorValue\n}\n\nSecurityID =  [\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\",\"000001.SZ\"]$SYMBOL\nDate = [2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01,2022.04.01]\nTime = [09:30:00.000,09:30:03.000,09:30:06.000,09:30:09.000,09:30:12.000,09:30:15.000,09:30:18.000,09:30:21.000,09:30:24.000,09:30:27.000]\nTotalVolumeTrade = [844800,1035700,1240100,1304500,1457800,1522400,1550900,1663800,1692100,1767100]\nTotalValueTrade = [12982101,15908020,19038479,20022525,22363886,23349799,23784950,25506625.75,25937850.75,27080561.75]\nHighPx = [15.37,15.37,15.37,15.37,15.37,15.37,15.37,15.37,15.37,15.37]\nLowPx = [15.3,15.3,15.29,15.28,15.24,15.24,15.24,15.22,15.22,15.22]\ntrade = table(SecurityID, Date, Time, TotalVolumeTrade, TotalValueTrade, HighPx, LowPx)\n\nresult = table(1:0, `SecurityID`Date`Time`Factor, `SYMBOL`DATE`TIME`DOUBLE)\n\nfactor=[<Date>,<Time>, <factor1(TotalVolumeTrade, TotalValueTrade, HighPx, LowPx)>]\nrse = createReactiveStateEngine(name=\"rsTest\", metrics=factor, dummyTable=trade, outputTable=result, keyColumn=\"SecurityID\")\nrse.append!(trade)\n\ntrade1 = select *,  (pow(HighPx*LowPx, 0.5)-(TotalVolumeTrade/TotalValueTrade)) as Factor0 from trade\nselect * from lj(trade1, result, `SecurityID`Date`Time)\ndropStreamEngine(\"rsTest\")\n```\n\n部分输出结果如图：\n\n![](https://docs.dolphindb.cn/zh/images/conditionalIterate_output.png)\n\n对于上述蓝框部分的数据，触发 *trueValue* 计算逻辑，因此 Factor 的值等于 Factor0 的计算结果；红框部分的数据触发 *falseIterFunc* 计算逻辑，每条记录的 Factor 是输出表中该记录前三条 Factor 的平均值。\n\n**Related information**\n\n[stateIterate](https://docs.dolphindb.cn/zh/funcs/s/stateIterate.html)\n"
    },
    "constantDesc": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/constantdesc.html",
        "signatures": [
            {
                "full": "constantDesc(obj)",
                "name": "constantDesc",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    }
                ]
            }
        ],
        "markdown": "### [constantDesc](https://docs.dolphindb.cn/zh/funcs/c/constantdesc.html)\n\n\n\n#### 语法\n\nconstantDesc(obj)\n\n#### 参数\n\n**obj**一个对象。\n\n#### 详情\n\n返回一个字典，描述对象 *obj*的相关属性。字典可能包含的 key 及说明如下：\n\n<table id=\"table_dgn_s3m_cdc\"><thead><tr><th>\n\n**key**\n\n</th><th>\n\n**说明**\n\n</th></tr></thead><tbody><tr><td>\n\nform\n\n</td><td>\n\n数据形式\n\n</td></tr><tr><td>\n\nvectorType\n\n</td><td>\n\n向量类型，仅当 *obj*是向量时才有此 key\n\n</td></tr><tr><td>\n\nisIndexedMatrix\n\n</td><td>\n\n是否是索引矩阵，仅当 obj 是矩阵时才有此 key\n\n</td></tr><tr><td>\n\nisIndexedSeries\n\n</td><td>\n\n是否是索引序列，仅当 obj 是矩阵时才有此 key\n\n</td></tr><tr><td>\n\nnullFlag\n\n</td><td>\n\n是否存在 NULL 值，仅当 *obj*是向量、数据对或矩阵时才有此 key\n\n</td></tr><tr><td>\n\nisView\n\n</td><td>\n\n是否是视图，仅当 *obj*是向量、数据对或矩阵时才有此 key\n\n</td></tr><tr><td>\n\ntableType\n\n</td><td>\n\n表的类型，仅当 obj 是表时才有此 key\n\n</td></tr><tr><td>\n\ntype\n\n</td><td>\n\n数据类型\n\n</td></tr><tr><td>\n\ncodeType\n\n</td><td>\n\n元代码的类型，仅当 obj 是元代码时才有此 key\n\n</td></tr><tr><td>\n\nfunctionDefType\n\n</td><td>\n\n函数类型，仅当 obj 是函数是才有此 key\n\n</td></tr><tr><td>\n\nscale\n\n</td><td>\n\n保留的小数位数，仅当 obj 是 DECIMAL 类型数据时才有此 key\n\n</td></tr><tr><td>\n\nisColumnarTuple\n\n</td><td>\n\n是否是列式元组，仅当 obj 是元组且不是视图时才有此 key\n\n</td></tr><tr><td>\n\ncategory\n\n</td><td>\n\n数据类型分类\n\n</td></tr><tr><td>\n\nisTemporary\n\n</td><td>\n\n是否是临时对象\n\n</td></tr><tr><td>\n\nisIndependent\n\n</td><td>\n\n是否独立对象\n\n</td></tr><tr><td>\n\nisReadonly\n\n</td><td>\n\n是否只读对象\n\n</td></tr><tr><td>\n\nisReadonlyArgument\n\n</td><td>\n\n是否是只读参数\n\n</td></tr><tr><td>\n\nisStatic\n\n</td><td>\n\n是否是静态对象\n\n</td></tr><tr><td>\n\nisTransient\n\n</td><td>\n\n是否是瞬态对象\n\n</td></tr><tr><td>\n\ncopyOnWrite\n\n</td><td>\n\n是否写时拷贝\n\n</td></tr><tr><td>\n\nrefCount\n\n</td><td>\n\n被引用的次数\n\n</td></tr><tr><td>\n\naddress\n\n</td><td>\n\n地址的十六进制表示\n\n</td></tr><tr><td>\n\nrows\n\n</td><td>\n\n包含行数\n\n</td></tr><tr><td>\n\ncolumns\n\n</td><td>\n\n包含列数\n\n</td></tr><tr><td>\n\nmemoryAllocated\n\n</td><td>\n\n已分配的内存\n\n</td></tr></tbody>\n</table>## 例子\n\n```\nt = table(1..3 as id, 4..6 as val)\nconstantDesc(t)\n/*\nform->TABLE\ntableType->BASIC\ntype->DICTIONARY\ncategory->MIXED\nisTemporary->false\nisIndependent->true\nisReadonly->false\nisReadonlyArgument->false\nisStatic->false\nisTransient->false\ncopyOnWrite->false\nrefCount->1\naddress->0000000028d2d1e0\nrows->3\ncolumns->2\nmemoryAllocated->208\n*/\n\n\nconstantDesc(lj)\n/*\nform->SCALAR\ntype->FUNCTIONDEF\nfunctionDefType->SYSTEM FUNCTION\ncategory->SYSTEM\nisTemporary->true\nisIndependent->true\nisReadonly->false\nisReadonlyArgument->false\nisStatic->false\nisTransient->false\ncopyOnWrite->false\nrefCount->6\naddress->000000000cabce00\nrows->1\ncolumns->1\nmemoryAllocated->10\n*/\n```\n"
    },
    "contextCount": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/contextCount.html",
        "signatures": [
            {
                "full": "contextCount(X, Y)",
                "name": "contextCount",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [contextCount](https://docs.dolphindb.cn/zh/funcs/c/contextCount.html)\n\n\n\n#### 语法\n\ncontextCount(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 必须是相同长度的向量。\n\n#### 详情\n\n计算 *X* 和 *Y* 中相同位置都不为 NULL 的元素个数。\n\n#### 例子\n\n```\ncontextCount(1 2 3, 1 NULL 3)\n// output\n2\n\ncontextCount(1..3,true false true)\n// output\n3\n\ncontextCount(1 2 NULL, 1 NULL 3)\n// output\n1\n```\n\n相关函数：[contextSum](https://docs.dolphindb.cn/zh/funcs/c/contextSum.html), [contextSum2](https://docs.dolphindb.cn/zh/funcs/c/contextSum2.html)\n"
    },
    "contextSum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/contextSum.html",
        "signatures": [
            {
                "full": "contextSum(X, Y)",
                "name": "contextSum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [contextSum](https://docs.dolphindb.cn/zh/funcs/c/contextSum.html)\n\n\n\n#### 语法\n\ncontextSum(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是向量、矩阵或表。\n\n#### 详情\n\n找出 *X* 和 *Y* 中元素都不为 NULL 的位置，并计算 *X* 中这些位置对应的元素的和。\n\n#### 例子\n\n```\ncontextSum(1 2 3 4 5, 2 3 4 5 6)\n// output\n15\n\ncontextSum(1..3, true false true)\n// output\n6\n\ncontextSum(1 2 NULL, 1 NULL 3)\n// output\n1\n```\n\n相关函数：[contextCount](https://docs.dolphindb.cn/zh/funcs/c/contextCount.html), [contextSum2](https://docs.dolphindb.cn/zh/funcs/c/contextSum2.html)\n"
    },
    "contextSum2": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/contextSum2.html",
        "signatures": [
            {
                "full": "contextSum2(X, Y)",
                "name": "contextSum2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [contextSum2](https://docs.dolphindb.cn/zh/funcs/c/contextSum2.html)\n\n\n\n#### 语法\n\ncontextSum2(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是向量、矩阵或表。\n\n#### 详情\n\n找出 *X* 和 *Y* 中元素都不为 NULL 的位置，并计算 *X* 中这些位置对应的元素的平方和。\n\n即使 *X* 的数据类型是 INT 或 LONG，返回结果的数据类型总是 DOUBLE 类型。\n\n#### 例子\n\n```\ncontextSum2(1 2 3, 10 NULL 30);\n// output\n10\n\ncontextSum2(1 2 3, true false true);\n// output\n14\n```\n\n相关函数：[contextCount](https://docs.dolphindb.cn/zh/funcs/c/contextCount.html), [contextSum](https://docs.dolphindb.cn/zh/funcs/c/contextSum.html)\n"
    },
    "convertEncode": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/convertEncode.html",
        "signatures": [
            {
                "full": "convertEncode(str, srcEncode, destEncode)",
                "name": "convertEncode",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "srcEncode",
                        "name": "srcEncode"
                    },
                    {
                        "full": "destEncode",
                        "name": "destEncode"
                    }
                ]
            }
        ],
        "markdown": "### [convertEncode](https://docs.dolphindb.cn/zh/funcs/c/convertEncode.html)\n\n\n\n#### 语法\n\nconvertEncode(str, srcEncode, destEncode)\n\n#### 参数\n\n**str** 是一个字符串标量或向量。\n\n**srcEncode** 是一个字符串，表示 *str* 原来的编码名称。\n\n**destEncode** 是一个字符串，表示 *str* 的目标编码名称。\n\n#### 详情\n\n转换字符串编码。DolphinDB 对编码名称的大小写敏感，所有编码名称必须用小写表示。\n\nWindow 版本目前仅支持 gbk 和 utf-8 两种编码的相互转换。Linux 版本支持任意两种编码之间的转换。\n\n#### 例子\n\n```\nconvertEncode(\"高性能分布式时序数据库\",\"utf-8\",\"gbk\");\n// output\n高性能分布式时序数据库\n\nconvertEncode([\"hello\",\"DolphinDB\"],\"gbk\",\"utf-8\");\n// output\n[\"hello\",\"DolphinDB\"]\n```\n\n相关函数：[fromUTF8](https://docs.dolphindb.cn/zh/funcs/f/fromUTF8.html), [toUTF8](https://docs.dolphindb.cn/zh/funcs/t/toUTF8.html)\n"
    },
    "convertExcelFormula": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/convertExcelFormula.html",
        "signatures": [
            {
                "full": "convertExcelFormula(formula, colStart, colEnd, rowStart, rowEnd)",
                "name": "convertExcelFormula",
                "parameters": [
                    {
                        "full": "formula",
                        "name": "formula"
                    },
                    {
                        "full": "colStart",
                        "name": "colStart"
                    },
                    {
                        "full": "colEnd",
                        "name": "colEnd"
                    },
                    {
                        "full": "rowStart",
                        "name": "rowStart"
                    },
                    {
                        "full": "rowEnd",
                        "name": "rowEnd"
                    }
                ]
            }
        ],
        "markdown": "### [convertExcelFormula](https://docs.dolphindb.cn/zh/funcs/c/convertExcelFormula.html)\n\n\n\n#### 语法\n\nconvertExcelFormula(formula, colStart, colEnd, rowStart, rowEnd)\n\n#### 参数\n\n**formula** 是字符串标量或向量，表示 Excel 公式。\n\n**colStart** 是字符串标量，表示数据在 Excel 中起始列。\n\n**colEnd** 是字符串标量，表示数据在 Excel 中结束列。\n\n**rowStart** 是整型标量，表示数据在 Excel 中起始行。*rowStart* 值应大于0。\n\n**rowEnd** 是整型标量，表示数据在 Excel 中起始行。*rowEnd* 值应大于等于 *rowStart*。\n\n#### 详情\n\n将 Excel 表达式转换为对应的 DolphinDB 表达式。\n\n该函数目前只支持包含四则运算，逻辑运算，聚合函数的转换。\n\n该函数目前不支持对行和列同时操作的表达式的转换。聚合函数对单列进行计算时，如果处理的行数与实际的行数相同，则将该列进行聚合操作；如果处理行数与实际行数不同，则进行移动聚合操作。\n\n#### 例子\n\n```\nconvertExcelFormula(\"A2+B2\", \"A\", \"Z\", 2, 10);\n// output\ncol0+col1\n\nconvertExcelFormula(\"SUM(A2:C2)\", \"A\", \"Z\", 2, 10);\n// output\nrowSum(col0, col1, col2)\n\nconvertExcelFormula(\"SUM(A2)\", \"A\", \"Z\", 2, 10);\n// output\ncumsum(col0)\n\nconvertExcelFormula(\"SUM(A2:A5)\", \"A\", \"Z\", 2, 10);\n// output\nmsum(col0, 4)\n\nconvertExcelFormula(\"SUM(A2:A10)\", \"A\", \"Z\", 2, 10);\n// output\nsum(col0)\n\nconvertExcelFormula([\"=SUM(A1:A10)\",\"IF(A1>0,B1,0\"], \"A\", \"D\", 1, 10)\n// output\n[\"sum(col0)\",\"iif(col0>0,col1,0)\"]\n```\n"
    },
    "convertTZ": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/convertTZ.html",
        "signatures": [
            {
                "full": "convertTZ(obj, srcTZ, destTZ)",
                "name": "convertTZ",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "srcTZ",
                        "name": "srcTZ"
                    },
                    {
                        "full": "destTZ",
                        "name": "destTZ"
                    }
                ]
            }
        ],
        "markdown": "### [convertTZ](https://docs.dolphindb.cn/zh/funcs/c/convertTZ.html)\n\n\n\n#### 语法\n\nconvertTZ(obj, srcTZ, destTZ)\n\n#### 参数\n\n**obj** 可以是 DATETIME, TIMESTAMP, NANOTIMESTAMP 类型的时间标量或向量。\n\n**srcTZ** 和 **destTZ** 都是字符串，表示时区。\n\n#### 详情\n\n把 *srcTZ* 时区的时间 *obj* 转换成 *destTZ* 时区的时间。\n\n#### 例子\n\n```\nconvertTZ(2016.04.25T08:25:45,\"US/Eastern\",\"Asia/Shanghai\");\n// output\n2016.04.25T20:25:45\n```\n"
    },
    "copy": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/copy.html",
        "signatures": [
            {
                "full": "copy(X)",
                "name": "copy",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [copy](https://docs.dolphindb.cn/zh/funcs/c/copy.html)\n\n\n\n#### 语法\n\ncopy(X)\n\n#### 参数\n\n**X** 可以是任意数据类型。\n\n#### 详情\n\n返回 *X* 的拷贝。\n\n#### 例子\n\n```\nx=1 2 3;\nx.copy();\n// output\n[1,2,3]\n```\n\n相关函数：[asis](https://docs.dolphindb.cn/zh/funcs/a/asIs.html)\n"
    },
    "copyReplicas": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/copyReplicas.html",
        "signatures": [
            {
                "full": "copyReplicas(srcNode, destNode, chunkId)",
                "name": "copyReplicas",
                "parameters": [
                    {
                        "full": "srcNode",
                        "name": "srcNode"
                    },
                    {
                        "full": "destNode",
                        "name": "destNode"
                    },
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    }
                ]
            }
        ],
        "markdown": "### [copyReplicas](https://docs.dolphindb.cn/zh/funcs/c/copyReplicas.html)\n\n\n\n#### 语法\n\ncopyReplicas(srcNode, destNode, chunkId)\n\n#### 参数\n\n**srcNode** 是一个字符串，表示源节点的别名。\n\n**destNode** 是一个字符串，表示目标节点的别名。\n\n**chunkId** 是字符串标量或向量，表示 chunk 的 ID。\n\n#### 详情\n\n把源节点上的一个或多个 chunk 的副本复制到目标节点。如果目标节点上已经存在该 chunk，那么系统将忽略本次操作。该命令只能由管理员在控制节点上执行。\n\n通过 [getRecoveryTaskStatus](https://docs.dolphindb.cn/zh/funcs/g/getRecoveryTaskStatus.html) 函数可以查看任务状态。\n\n#### 例子\n\n把 \"node1\" 上所有 chunk 的副本复制到 \"node2\"。\n\n```\nchunkIds=exec chunkId from pnodeRun(getChunksMeta) where node=\"node1\"\ncopyReplicas(\"node1\",\"node2\",chunkIds);\n```\n"
    },
    "corr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/corr.html",
        "signatures": [
            {
                "full": "corr(X,Y)",
                "name": "corr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [corr](https://docs.dolphindb.cn/zh/funcs/c/corr.html)\n\n\n\n#### 语法\n\ncorr(X,Y)\n\n#### 参数\n\n**Y** 和 **X** 是相同长度的数值型向量、维度相同的矩阵或表。若 *X* 是表，只对其内数值型和布尔型的列进行计算。\n\n#### 详情\n\n计算 *X* 和 *Y* 之间的相关性（correlation）。\n\n#### 例子\n\n```\nx = 7 4 5 8 9 3 3 5 2 6 12 1 0 -5 32\ny=1.1 7 8 9 9 5 4 8.6 2 1 -9 -3 5 8 13\ncorr(x,y);\n// output\n0.238769\n```\n"
    },
    "corrMatrix": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/corrMatrix.html",
        "signatures": [
            {
                "full": "corrMatrix(X)",
                "name": "corrMatrix",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [corrMatrix](https://docs.dolphindb.cn/zh/funcs/c/corrMatrix.html)\n\n\n\n#### 语法\n\ncorrMatrix(X)\n\n#### 参数\n\n**X** 是一个矩阵。\n\n#### 详情\n\n设矩阵 *X* 有 n 列，将其每一列作为一维向量，求 n 维向量的相关矩阵（correlation matrix）。\n\n**Note:**\n\n* 如果矩阵中含有空值，会默认将空值转化为0，然后进行计算。而由于 [corr](https://docs.dolphindb.cn/zh/funcs/c/corr.html) 函数计算时忽略 NULL 值，因此调用 [cross/pcross(corr, X)](https://docs.dolphindb.cn/zh/funcs/ho_funcs/cross.html) 函数计算相关矩阵时也会忽略 NULL 值。\n* 在不含 NULL 值的情况下，虽然该函数计算结果等价于 `cross(corr, X)`，但该函数内部进行了优化，其性能较 [cross/pcross(corr, X)](https://docs.dolphindb.cn/zh/funcs/ho_funcs/cross.html) 函数有大幅提升。\n\n#### 例子\n\n```\nm = rand(10.0, 30)$10:3\ncorrMatrix(m)\n```\n\n输出返回：\n\n| #0                | #1                | #2                |\n| ----------------- | ----------------- | ----------------- |\n| 1                 | 0.167257129736134 | 0.224955585716037 |\n| 0.167257129736134 | 1                 | -0.12066768907057 |\n| 0.224955585716037 | -0.12066768907057 | 1                 |\n\n```\na = rand(1.0, 30000000).reshape(10000:3000)\na.rename!(\"s\" + string(1..3000))\ntimer corrMatrix(a)\n```\n\n输出返回：Time elapsed: 2986.932 ms\n\n```\ntimer pcross(corr, a)\n```\n\n输出返回：Time elapsed: 45629.6 ms\n\n相关函数： [covarMatrix](https://docs.dolphindb.cn/zh/funcs/c/covarMatrix.html)\n"
    },
    "cos": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cos.html",
        "signatures": [
            {
                "full": "cos(X)",
                "name": "cos",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html)\n\n\n\n#### 语法\n\ncos(X)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n#### 详情\n\n返回 *X* 的余弦。\n\n#### 例子\n\n```\ncos 0 1 2;\n// output\n[1,0.540302,-0.416147]\n```\n\n相关函数：[asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html), [acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html), [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html), [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html), [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html), [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html), [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html), [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html), [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html), [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html), [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n"
    },
    "cosh": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cosh.html",
        "signatures": [
            {
                "full": "cosh(X)",
                "name": "cosh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html)\n\n\n\n#### 语法\n\ncosh(X)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n#### 详情\n\n返回 *X* 的双曲余弦。\n\n#### 例子\n\n```\ncosh 0 1 2;\n// output\n[1,1.543081,3.762196]\n```\n\n相关函数：[asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html), [acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html), [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html), [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html), [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html), [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html), [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html), [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html), [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html), [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html), [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n"
    },
    "count": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/count.html",
        "signatures": [
            {
                "full": "count(X)",
                "name": "count",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [count](https://docs.dolphindb.cn/zh/funcs/c/count.html)\n\n\n\n#### 语法\n\ncount(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n[size](https://docs.dolphindb.cn/zh/funcs/s/size.html) 和 `count` 不同。`size` 返回向量/矩阵中元素的个数，而 `count` 返回向量/矩阵中非 NULL 的元素个数。`count` 可以用在 SQL 查询中，而 `size` 不可以。对于表而言，`size` 和 `count` 都返回行数。参见相关函数 [size](https://docs.dolphindb.cn/zh/funcs/s/size.html)。\n\n`count` 用于 SQL 查询时，有如下三种常见用法：\n\n* `select count(*) from pt` ：返回 pt 表中的数据条数。\n* `count(1) from pt` ：若 pt 为空表，则返回1；否则返回 pt 表中数据涉及到的分区数量。\n* `select count(colName) from pt` ：返回列 colName 中的非空数据的个数。\n\n#### 例子\n\n```\ncount(3 NULL 5 6);\n// output\n3\nsize(3 NULL 5 6);\n// output\n4\n\nm=1 2 3 NULL 4 5$2:3;\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 4  |\n| 2  |    | 5  |\n\n```\ncount(m);\n// output\n5\nsize(m);\n// output\n6\n\nt = table(1 NULL 3 as id, 3 NULL 9 as qty);\nt;\n```\n\n| id | qty |\n| -- | --- |\n| 1  | 3   |\n|    |     |\n| 3  | 9   |\n\n```\ncount(t);\n// output\n3\nsize(t);\n// output\n3\n```\n\n```\ndata = table(2023.10.01 + take(0..9,100) as date, take(['A','B','C','D'],100) as sym, 1..100 as val) \n\ndb = database(\"dfs://demo\",VALUE,2023.10.01..2023.10.10)\npt = db.createPartitionedTable(data,`pt,`date)//创建一个分区表\n \npt.append!(data)  //向表中插入数据\n\nselect count(*) from pt;//返回数据条数\n```\n\n| count |\n| ----- |\n| 100   |\n\n```\nselect count(1) from pt;//返回分区数\n```\n\n| count |\n| ----- |\n| 10    |\n"
    },
    "countNanInf": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/countNanInf.html",
        "signatures": [
            {
                "full": "countNanInf(X, [includeNull=false])",
                "name": "countNanInf",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[includeNull=false]",
                        "name": "includeNull",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [countNanInf](https://docs.dolphindb.cn/zh/funcs/c/countNanInf.html)\n\n\n\n#### 语法\n\ncountNanInf(X, \\[includeNull=false])\n\n#### 参数\n\n**X** 是 DOUBLE 类型 的标量/向量/矩阵。\n\n**includeNull** 是一个布尔值。\n\n#### 详情\n\n聚合函数，用于统计 *X* 中 NaN 或 Inf 值的数量。若 *includeNull* 设为 true，NULL 值也会被统计，默认为 false。\n\n相关函数：[isNanInf](https://docs.dolphindb.cn/zh/funcs/i/isNanInf.html)\n"
    },
    "covar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/covar.html",
        "signatures": [
            {
                "full": "covar(X,Y)",
                "name": "covar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [covar](https://docs.dolphindb.cn/zh/funcs/c/covar.html)\n\n\n\n#### 语法\n\ncovar(X,Y)\n\n别名：cov\n\n#### 参数\n\n**Y** 和 **X** 是相同长度的数值型向量、维度相同的矩阵或表。若 *X* 是表，只对其内数值型和布尔型的列进行计算。\n\n#### 详情\n\n计算 *X* 和 *Y* 的协方差（covariance）。\n\n#### 例子\n\n```\nx=7 4 5 8 9 3 3 5 2 6 12 1 0 -5 32\ny=1.1 7 8 9 9 5 4 8.6 2 1 -9 -3 5 8 13\ncovar(x,y);\n// output\n10.881429\n```\n"
    },
    "covarMatrix": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/covarMatrix.html",
        "signatures": [
            {
                "full": "covarMatrix(X)",
                "name": "covarMatrix",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [covarMatrix](https://docs.dolphindb.cn/zh/funcs/c/covarMatrix.html)\n\n\n\n#### 语法\n\ncovarMatrix(X)\n\n#### 参数\n\n**X** 是一个矩阵。\n\n#### 详情\n\n设矩阵 *X* 有 n 列，将其每一列作为一维向量，求 n 维随机变量的协方差矩阵（covariance matrix）。\n\n**Note:**\n\n* 如果矩阵中含有空值，会默认将空值转化为0，然后进行计算。而由于 [covar](https://docs.dolphindb.cn/zh/funcs/c/covar.html) 函数计算时忽略 NULL 值，因此调用 [cross/pcross(covar, X)](https://docs.dolphindb.cn/zh/funcs/ho_funcs/cross.html) 函数计算相关矩阵时也会忽略 NULL 值。\n* 在不含 NULL 值的情况下，虽然该函数计算结果等价于 `cross(covar, X)`，但该函数内部进行了优化，其性能较 [cross/pcross](https://docs.dolphindb.cn/zh/funcs/ho_funcs/cross.html) 函数有大幅提升。\n\n#### 例子\n\n```\nm = rand(10.0, 30)$10:3\ncovarMatrix(m)\n```\n\n| #0                | #1                 | #2                 |\n| ----------------- | ------------------ | ------------------ |\n| 6.116181845352529 | 1.107026927999891  | 1.306707566911273  |\n| 1.107026927999891 | 7.162534080771522  | -0.758517799304199 |\n| 1.306707566911273 | -0.758517799304199 | 5.516744365930221  |\n\n```\na = rand(1.0, 30000000).reshape(10000:3000)\na.rename!(\"s\" + string(1..3000))\ntimer covarMatrix(a)\n// output\nTime elapsed: 2927.264 ms\ntimer pcross(covar, a)\n// output\nTime elapsed: 29484.85 ms\n```\n\n相关函数： [corrMatrix](https://docs.dolphindb.cn/zh/funcs/c/corrMatrix.html)\n"
    },
    "crc32": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/crc32.html",
        "signatures": [
            {
                "full": "crc32(str, [cksum=0])",
                "name": "crc32",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "[cksum=0]",
                        "name": "cksum",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [crc32](https://docs.dolphindb.cn/zh/funcs/c/crc32.html)\n\n\n\n#### 语法\n\ncrc32(str, \\[cksum=0])\n\n#### 参数\n\n**str** 是一个字符串标量、向量或表。\n\n**cksum** 是整型标量或向量。\n\n#### 详情\n\n根据 CRC32 算法，对字符串进行哈希，生成 INT 类型数据。\n\n#### 例子\n\n```\na=crc32(`aa`cc,1);\na;\n// output\n[512829590,-1029100744]\n\ntypestr(a);\n// output\nFAST INT VECTOR\n```\n"
    },
    "createAnomalyDetectionEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createAnomalyDetectionEngine.html",
        "signatures": [
            {
                "full": "createAnomalyDetectionEngine(name, metrics, dummyTable, outputTable, timeColumn, [keyColumn], [windowSize], [step], [garbageSize], [roundTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup],[anomalyDescription])",
                "name": "createAnomalyDetectionEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[windowSize]",
                        "name": "windowSize",
                        "optional": true
                    },
                    {
                        "full": "[step]",
                        "name": "step",
                        "optional": true
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[anomalyDescription]",
                        "name": "anomalyDescription",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createAnomalyDetectionEngine](https://docs.dolphindb.cn/zh/funcs/c/createAnomalyDetectionEngine.html)\n\n\n\n#### 语法\n\ncreateAnomalyDetectionEngine(name, metrics, dummyTable, outputTable, timeColumn, \\[keyColumn], \\[windowSize], \\[step], \\[garbageSize], \\[roundTime=true], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[raftGroup],\\[anomalyDescription])\n\n#### 详情\n\n创建异常检测引擎，返回一个表对象，向该表写入数据意味着将数据注入异常检测引擎进行计算。异常检测引擎会根据异常指标，对每条记录进行检测。\n\n异常检测引擎不支持在 *metrics* 中使用以下函数：`next`, `talibNull`, `linearTimeTrend`, `iterate`；亦不支持在序列相关函数内部嵌套聚合函数，如：`tmsum(sum())`。\n\n为了便于观察和对比计算结果，系统会对第一个数据窗口的起始时间进行调整。调整规则与 [createTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesEngine.html) 相同。\n\n更多流数据引擎的应用场景说明可以参考 [内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)。\n\n#### 计算规则\n\n异常检测引擎会根据不同类型的异常指标采用不同的计算规则。异常指标一般有以下三种类型：\n\n* 某个列与常量对比、列与列之间对比或非聚合函数中没有嵌套聚合函数，例如 qty < 4, qty > price, lt(qty, prev(qty)), isNull(qty) == false 等。对于这类指标，异常检测引擎会对每一条数据进行计算，判断是否符合条件并决定输出。\n* 聚合函数的结果与某个常量值对比、聚合函数结果之间的对比、非聚合函数中仅嵌套聚合函数和常量，例如 avg(qty - price) > 10, percentile(qty, 90) < 100, max(qty) < avg(qty) \\* 2, le(sum(qty), 5) 等。对于这类指标，异常检测引擎会在每个窗口计算时判断计算结果是否符合条件并决定输出。\n* 聚合函数的结果与列对比、非聚合函数中同时嵌套聚合函数和列，例如 avg(qty) > qty, le(med(qty), price) 等。对于这类指标，每当数据到达时，异常检测引擎会将数据与上一个计算窗口的聚合结果对比，判断计算结果是否符合条件并决定输出，直到触发下一次聚合计算。\n\n**Note:**\n\n* 当指标中包含聚合函数，则必须指定窗口长度（由参数 *windowSize* 设置）和计算的时间间隔（由参数 *step* 设置）。每隔一段时间，在固定长度的移动窗口中计算指标。为了便于观察和对比计算结果，系统会对第一个数据窗口的起始时间进行调整，起始窗口的规整规则同时间序列引擎。\n* 若指定了 *keyColumn*，则按照分组分别进行计算。\n\n#### 引擎的其它功能\n\n* 支持数据/状态清理：若 *metrics* 参数指定的指标中使用了聚合函数或序列相关函数，异常检测引擎会保留历史数据，可通过配置 *garbageSize* 参数，使系统清理本次计算不需要的历史数据。若指定了 *keyColumn*，则各分组独立进行数据清理。\n* 快照机制：启用快照机制之后，系统若出现异常，可及时将流数据引擎恢复到最新的快照状态。（详情请参考 *snapshotDir* 和 *snapshotIntervalInMsgCount* 的参数说明）\n* 流数据引擎高可用：若要启用引擎高可用，需在订阅端 raft 组的 leader 节点创建引擎并通过 *raftGroup* 参数开启高可用。开启高可用后，当 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。（详情请参考 *raftGroup* 的参数说明）\n\n#### 参数\n\n**name** 字符串标量，表示异常检测引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**metrics** 以元代码或元组的格式表示异常指标，每个异常指标必须是布尔表达式，如<\\[sum(qty) > 5, avg(qty) > qty, qty < 4]>。有关元代码的更多信息可参考 [元编程](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n**Note:** *metrics* 中使用的列名大小写不敏感，不需要与输入表的列名大小写保持一致。\n\n**dummyTable** 一个表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。\n\n**outputTable** 计算结果的输出表，可以是内存表或分布式表。在调用 `createAnomalyDetectionEngine` 函数之前，需要预先设立输出表。异常检测引擎会将计算结果注入该表。\n\n输出表的各列的顺序如下：\n\n(1) 时间列。其数据类型与 *dummyTable* 的时间列一致，用于存放检测到异常的时间戳。\n\n(2) 分组列。如果 *keyColumn* 不为空，则其后几列和 *keyColumn* 设置的列及其顺序保持一致。\n\n(3) 之后两列分别为 INT类型列 type 和 STRING / SYMBOL 类型列 metric，分别用于记录异常的类型（在 *metrics* 中的下标）和异常条件的内容。\n\n**timeColumn** 字符串标量，该参数用于指定订阅的流数据表中时间列的名称。\n\n**keyColumn** 可选参数，字符串标量或向量，表示分组列名。异常检测引擎会按照 *keyColumn* 对输入的数据分组，计算将在各分组分别进行。\n\n**windowSize** 可选参数，正整数。如果 *metrics* 中包含聚合函数，必须指定 *windowSize*，它表示计算的数据窗口的长度，数据窗口只包含上边界不包含下边界。如果 *metrics* 中不包含聚合函数，该参数无效。\n\n**step** 可选参数，正整数。如果 *metrics* 中包含聚合函数，必须指定 *step*，并且必须能够被 *windowSize* 整除，它表示计算的时间间隔。如果 *metrics* 中不包含聚合函数，该参数无效。\n\n**garbageSize** 可选参数，正整数。它是可选参数，默认值是 2,000（单位为行）。如果没有指定 *keyColumn*，当内存中历史数据的数量超过 *garbageSize* 时，系统会清理本次计算不需要的历史数据。如果指定了 *keyColumn*，意味着需要分组计算时，内存清理是各分组独立进行的。当一个组的历史数据记录数超出 *garbageSize* 时，会清理该组不再需要的历史数据。若一个组的历史数据记录数未超出 *garbageSize*，则该组数据不会被清理。如果 *metrics* 中没有聚合函数，这个参数不起作用。\n\n**roundTime** 可选参数，布尔值，表示若数据时间精度为毫秒或者秒且 *step* > 一分钟，如何对窗口边界值进行规整处理。默认值为 true，表示按照既定的多分钟规则（见以上表格）进行规整。若为 false，则按一分钟规则（见以上表格）进行窗口规整（详情参考 `规整规则表`）。\n\n若要开启快照机制 (snapshot)，必须指定 *snapshotDir* 与 *snapshotIntervalInMsgCount*。\n\n**snapshotDir** 可选参数，字符串，表示保存引擎快照的文件目录。\n\n* 指定的目录必须存在，否则系统会提示异常。\n* 创建流数据引擎时，如果指定了 *snapshotDir*，会检查该目录下是否存在快照。如果存在，会加载该快照，恢复引擎的状态。\n* 多个引擎可以指定同一个目录存储快照，用引擎的名称来区分快照文件。\n* 一个引擎的快照可能会使用三个文件名：\n* 临时存储快照信息：文件名为 \\<engineName>.tmp；\n* 快照生成并刷到磁盘：文件保存为 \\<engineName>.snapshot；\n* 存在同名快照：旧快照自动重命名为 \\<engineName>.old。\n\n**snapshotIntervalInMsgCount** 可选参数，为整数类型，表示每隔多少条数据保存一次流数据引擎快照。\n\n**raftGroup** 是流数据高可用订阅端 raft 组的 ID (大于1的整数，由流数据高可用相关的配置项 *streamingRaftGroups* 指定)。设置该参数表示开启计算引擎高可用。在 leader 节点创建流数据引擎后，会同步在 follower 节点创建该引擎。每次保存的 snapshot 也会同步到 follower。当 raft 组的 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。请注意，若要指定 *raftGroup*，必须同时指定 *snapshotDir*。\n\n**anomalyDescription** 可选参数，字符串向量，长度和 *metrics* 中定义的指标数量相同。指定该参数后，输出表的最后一列将显示异常条件对应的字符串。\n\n#### 例子\n\n例1. 下面的例子使用 `createAnomalyDetectionEngine` 函数创建了一个表 engine，然后通过订阅流数据表 trades 把数据写入到 engine 中，按照 sym 列进行分组聚合运算，并把结果保存在表 outputTable 中。\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(1000:0, `time`sym`type`metric, [TIMESTAMP, SYMBOL, INT, STRING]) as outputTable\nengine = createAnomalyDetectionEngine(name=\"anomalyDetection1\", metrics=<[sum(qty) > 5, avg(qty) > qty, qty < 4]>, dummyTable=trades, outputTable=outputTable, timeColumn=`time, keyColumn=`sym, windowSize=3, step=3)\nsubscribeTable(tableName=\"trades\", actionName=\"anomalyDetectionSub1\", offset=0, handler=append!{engine}, msgAsTable=true)\n\ndef writeData(n){\n     timev = 2018.10.08T01:01:01.001 + 1..n\n     symv =take(`A`B, n)\n     qtyv = n..1\n     insert into trades values(timev, symv, qtyv)\n}\n\nwriteData(6);\n\nselect * from trades;\n```\n\n| time                    | sym | qty |\n| ----------------------- | --- | --- |\n| 2018.10.08T01:01:01.002 | A   | 6   |\n| 2018.10.08T01:01:01.003 | B   | 5   |\n| 2018.10.08T01:01:01.004 | A   | 4   |\n| 2018.10.08T01:01:01.005 | B   | 3   |\n| 2018.10.08T01:01:01.006 | A   | 2   |\n| 2018.10.08T01:01:01.007 | B   | 1   |\n\n```\nselect * from outputTable;\n```\n\n| time                    | sym | type | metric         |\n| ----------------------- | --- | ---- | -------------- |\n| 2018.10.08T01:01:01.003 | A   | 0    | sum(qty) > 5   |\n| 2018.10.08T01:01:01.004 | A   | 1    | avg(qty) > qty |\n| 2018.10.08T01:01:01.005 | B   | 2    | qty < 4        |\n| 2018.10.08T01:01:01.006 | A   | 1    | avg(qty) > qty |\n| 2018.10.08T01:01:01.006 | A   | 2    | qty < 4        |\n| 2018.10.08T01:01:01.006 | B   | 0    | sum(qty) > 5   |\n| 2018.10.08T01:01:01.007 | B   | 1    | avg(qty) > qty |\n| 2018.10.08T01:01:01.007 | B   | 2    | qty < 4        |\n\n下面详细解释异常检测引擎的计算过程：\n\n(1) 指标 sum(qty) > 5 是聚合函数的结果与常量的对比，因此异常检测引擎会在每个窗口计算时进行检测。第一个数据窗口是 2018.10.08T01:01:01.000 到 2018.10.08T01:01:01.002，分别计算 A, B 的 sum(qty)，在 2018.10.08T01:01:01.003 时判断是否符合条件 sum(qty)>5，第二个数据窗口是 2018.10.08T01:01:01.003 到 2018.10.08T01:01:01.005，在 2018.10.08T01:01:01.006 时判断是否符合条件 sum(qty)>5，如此类推。\n\n(2) 指标 avg(qty) > qty 是聚合函数的结果与某列对比，因此每当数据到达时，异常检测引擎会将数据与上一个计算窗口的聚合结果对比，判断计算结果是否符合条件并决定输出，直到触发下一次聚合计算。第一个数据窗口是 2018.10.08T01:01:01.000 到 2018.10.08T01:01:01.002，分别计算 A, B 的 avg(qty)，2018.10.08T01:01:01.003 到 2018.10.08T01:01:01.005 之间的 qty 会与上一个窗口的 avg(qty) 比较，2018.10.08T01:01:01.005 时窗口发生移动，第二个数据窗口为 2018.10.08T01:01:01.003 到 2018.10.08T01:01:01.005，此时计算 A, B 的 avg(qty)，2018.10.08T01:01:01.006 到 2018.10.08T01:01:01.008 之间的 qty 会与上一个窗口的 avg(qty) 比较，如此类推。\n\n(3) 指标 qty < 4 是列与常量对比，因此每次数据进入时，异常检测引擎都会进行判断。\n\n例2. 下例通过 *anomalyDescription* 参数指定输出的异常指标对应的文字信息\n\n```\nshare streamTable(1000:0, `time`temp, [TIMESTAMP, DOUBLE]) as sensordata\n\nshare streamTable(1000:0, `time`anomalyType`anomalyString, [TIMESTAMP, INT, SYMBOL]) as outputTable\nengine = createAnomalyDetectionEngine(name = \"engineB\", metrics=<[temp > 65, temp > percentile(temp, 75)]>, dummyTable = sensordata, outputTable = outputTable, timeColumn = `time, windowSize = 6, step = 3, anomalyDescription=[\"The temperature is higher than 65°C\", \"The temperature is larger than 75% values of the last window\"])\nsubscribeTable(,tableName = \"sensordata\", actionName = \"sensorAnomalyDetection\", offset = 0, handler = append!{engine}, msgAsTable = true)\n\ntimev = 2018.10.08T01:01:01.001 + 1..10\ntempv = 59 66 57 60 63 51 53 52 56 55\ninsert into sensordata values(timev, tempv)\n\nsleep(10)\nselect * from outputTable\n```\n\n| time                    | anomalyType | anomalyString                                                |\n| ----------------------- | ----------- | ------------------------------------------------------------ |\n| 2018.10.08T01:01:01.003 | 0           | The temperature is higher than 65°C                          |\n| 2018.10.08T01:01:01.003 | 1           | The temperature is larger than 75% values of the last window |\n| 2018.10.08T01:01:01.005 | 1           | The temperature is larger than 75% values of the last window |\n| 2018.10.08T01:01:01.006 | 1           | The temperature is larger than 75% values of the last window |\n"
    },
    "createAsofJoinEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createAsofJoinEngine.html",
        "signatures": [
            {
                "full": "createAsofJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, [timeColumn], [useSystemTime=false], [delayedTime], [garbageSize], [sortByTime], [outputElapsedMicroseconds=false])",
                "name": "createAsofJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[delayedTime]",
                        "name": "delayedTime",
                        "optional": true
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[sortByTime]",
                        "name": "sortByTime",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createAsofJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createAsofJoinEngine.html)\n\n\n\n#### 语法\n\ncreateAsofJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, \\[timeColumn], \\[useSystemTime=false], \\[delayedTime], \\[garbageSize], \\[sortByTime], \\[outputElapsedMicroseconds=false])\n\n#### 详情\n\n创建流数据 asof join 引擎。返回一个左、右两表 asof join 后的表对象。注入 asof join 引擎的左、右两表将以 `matchingColumn` + `timeColumn` (或系统时间) 作为连接列，在右表中选取与连接列匹配的，在给定的左表时间戳前且最接近的记录。该引擎适用于两个数据源没有完全匹配的记录，需要按时间段作连接，以获取最新信息的场景。\n\n**Note:** asof join 左表和右表的数据必须按照时间顺序排序。\n\n* 如果没有指定 `delayedTime`，则当右表数据的最新时间大于左表数据的最新时间，才会触发 join, 计算输出。\n* 如果指定了 `delayedTime`，则当左表中数据最新时间与上一条未计算的时间差大于 *delayedTime* 设置值，或者左表中数据在经过 2 \\* *delayedTime* （小于2秒按2秒计算）后还没有 join 输出，就直接触发左右两表 join。\n\n更多流数据引擎的应用场景说明可以参考 [内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)。\n\n#### 参数\n\n**name** 字符串标量，表示 asof join 引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**leftTable** 和 **rightTable** 表对象。结构必须与订阅的流数据表相同。从 2.00.11 版本开始左、右表支持 array vector 类型。\n\n**outputTable** 计算结果的输出表，可以是内存表或分布式表。从 2.00.11 版本开始输出表支持 array vector 类型。在使用 `createAsofJoinEngine` 函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。asof join 引擎会将计算结果注入该表。输出表的各列的顺序如下：\n\n1. 时间列。其中：\n\n   * 若 *useSystemTime* = true，为 TIMESTAMP 类型；\n   * 若 *useSystemTime* = false，数据类型与 *timeColumn* 列一致。\n2. 连接列。与 *matchingColumn* 中的列以及其顺序一致，可为多列。\n3. 计算结果列。可为多列。\n4. 耗时列。如果指定 *outputElapsedMicroseconds* = true，则指定一个 LONG 类型的列用于记录单次响应计算耗时（单位：微秒）。\n5. batchSize 列。如果指定 *outputElapsedMicroseconds* = true, 则指定一个 INT 类型的列，记录单次响应的数据条数。\n\n**metrics** 以元代码的格式表示计算指标，支持输入元组。有关元代码的更多信息可参考 [Metaprogramming](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n* 计算指标可以是一个或多个表达式、系统内置或用户自定义函数、一个常量标量/向量，但不能是聚合函数。当指定为常量向量时，对应的输出列必须设置为数组向量类型，例子参见 [createReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createReactiveStateEngine.html) 中的例4。\n* *metrics* 内支持调用具有多个返回值的函数，且必须指定列名，例如 \\<func(price) as \\`col1\\`col2>。若在 *metrics* 指定了 *leftTable* 和 *rightTable* 中具有相同名称的列，默认取左表的列，可以通过 \"tableName.colName\" 指定该列来自哪个表。\n\n  **Note:** *metrics* 中使用的列名大小写不敏感，不需要与输入表的列名大小写保持一致。\n\n**matchingColumn** 表示连接列的字符串标量/向量/字符串组成的 tuple，支持 Integral, Temporal 或 Literal（UUID 除外）类型。*matchingColumn* 指定规则为：\n\n1. 只有一个连接列：当左表和右表的连接列名相同时，*matchingColumn* 是一个字符串标量，否则是一个长度为 2 的 tuple，例如：左表连接列名为 sym，右表连接列名为 sym1，则 *matchingColumn* = \\[\\[\\`sym],\\[\\`sym1]]。\n2. 有多个连接列：当左表和右表的连接列名相同时，*matchingColumn* 是一个字符串向量，否则是一个长度为 2 的 tuple，例如：左表连接列名为 orderNo, sym，右表连接列名为 orderNo, sym1，则 *matchingColumn* = \\[\\[\\`orderNo, \\`sym], \\[\\`orderNo,\\`sym1]]。\n\n**timeColumn** 可选参数，字符串标量或向量。当 *useSystemTime* = false 时，指定要连接的两个表中时间列的名称。 *leftTable* 和 *rightTable* 时间列名称可以不同，但数据类型需保持一致。当 *leftTable* 和 *rightTable* 时间列名称不同时，*timeColumn* 为一个长度为2的字符串向量。\n\n**useSystemTime** 可选参数，布尔值。表示是否使用数据注入引擎时的系统时间作为时间列进行计算。\n\n* 当 *useSystemTime* = true 时，按照数据进入引擎的时刻（毫秒精度的本地系统时间，与数据中的时间列无关）进行计算。\n* 当 *useSystemTime* = false（缺省值）时，按照数据中的时间列进行计算。\n\n**delayedTime** 可选参数，正整数，单位同 timeColumn 精度一致。表示左表中未联结数据被触发联结并计算输出的最大等待时间。要设置 *delayedTime*， 必须指定 *timeColumn*，更多介绍见详情。\n\n**garbageSize** 可选参数，正整数，默认值是 5,000（单位为行）。随着订阅的流数据不断注入 asof join 引擎，存放在内存中的数据会越来越多，当各分组对应的缓存表（左表或右表）中数据行数超过 *garbageSize* 值时，系统会清理该表中已经触发计算的历史数据。\n\n**sortByTime** 布尔值，表示是否按全局时间顺序输出数据。默认值为 false，表示不按全局时间输出数据，仅在组内按时间顺序输出数据。\n\n**Note:** 当设置 *sortByTime* = true 时，必须保证输入的左表和右表的数据必须全局有序，且不可设置 *delayedTime*。\n\n**outputElapsedMicroseconds** 布尔值，表示是否输出数据的单次响应计算耗时（从触发计算的数据注入引擎到计算完成的耗时），默认为 false。指定参数 *outputElapsedMicroseconds* 后，在定义 *outputTable* 时需要在计算结果列后增加一个 LONG 类型的列和 INT 类型的列，详见 *outputTable* 参数说明。\n\n#### 例子\n\n```\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\nshare streamTable(1:0, `time`sym`bid`ask, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE]) as quotes\nshare table(100:0, `time`sym`price`bid`ask`spread, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as prevailingQuotes\n\najEngine=createAsofJoinEngine(name=\"aj1\", leftTable=trades, rightTable=quotes, outputTable=prevailingQuotes, metrics=<[price, bid, ask, abs(price-(bid+ask)/2)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false)\ntmp1=table(2020.08.27T09:30:00.000+2 8 20 22 23 24 as time, take(`A`B, 6) as sym, 20.01 20.04 20.07 20.08 20.4 20.5 as price)\ntmp2=table(2020.08.27T09:30:00.000+1 5 6 11 19 20 21 as time, take(`A`B, 7) as sym, 20 20.02 20.03 20.05 20.06 20.6 20.4 as bid,  20.01 20.03 20.04 20.06 20.07 20.5 20.6 as ask)\ntmp1.sortBy!(`time)\ntmp2.sortBy!(`time)\n\nsubscribeTable(tableName=\"trades\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{ajEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"quotes\", actionName=\"joinRight\", offset=0, handler=appendForJoin{ajEngine, false}, msgAsTable=true)\n\ntrades.append!(tmp1)\nquotes.append!(tmp2)\n\nsleep(100)\nselect time, sym, bid from prevailingQuotes\n```\n\n| time                    | sym | bid   |\n| ----------------------- | --- | ----- |\n| 2020.08.27T09:30:00.002 | A   | 20    |\n| 2020.08.27T09:30:00.020 | A   | 20.06 |\n| 2020.08.27T09:30:00.008 | B   | 20.02 |\n\n```\n// 清理引擎及变量\nunsubscribeTable(tableName=\"trades\", actionName=\"joinLeft\")\nunsubscribeTable(tableName=\"quotes\", actionName=\"joinRight\")\nundef(`trades,SHARED)\nundef(`quotes,SHARED)\ndropAggregator(name=\"aj1\")\n\n// 定义引擎，设置 sortByTime=true\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\nshare streamTable(1:0, `time`sym`bid`ask, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE]) as quotes\nshare table(100:0, `time`sym`price`bid`ask`spread, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as prevailingQuotes\najEngine=createAsofJoinEngine(name=\"aj1\", leftTable=trades, rightTable=quotes, outputTable=prevailingQuotes, metrics=<[price, bid, ask, abs(price-(bid+ask)/2)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false, sortByTime=true)\n\ntmp1=table(2020.08.27T09:30:00.000+2 8 20 22 23 24 as time, take(`A`B, 6) as sym, 20.01 20.04 20.07 20.08 20.4 20.5 as price)\ntmp2=table(2020.08.27T09:30:00.000+1 5 6 11 19 20 21 as time, take(`A`B, 7) as sym, 20 20.02 20.03 20.05 20.06 20.6 20.4 as bid,  20.01 20.03 20.04 20.06 20.07 20.5 20.6 as ask)\ntmp1.sortBy!(`time)\ntmp2.sortBy!(`time)\n// 只能使用 appendForJoin 插入数据\nsubscribeTable(tableName=\"trades\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{ajEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"quotes\", actionName=\"joinRight\", offset=0, handler=appendForJoin{ajEngine, false}, msgAsTable=true)\n\ntrades.append!(tmp1)\nquotes.append!(tmp2)\n\nsleep(100)\n// 查看结果表，数据按照全局时间顺序输出\n```\n\n| time                    | sym | bid   |\n| ----------------------- | --- | ----- |\n| 2020.08.27T09:30:00.002 | A   | 20    |\n| 2020.08.27T09:30:00.008 | B   | 20.02 |\n| 2020.08.27T09:30:00.020 | A   | 20.06 |\n"
    },
    "createCatalog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createCatalog.html",
        "signatures": [
            {
                "full": "createCatalog(catalog)",
                "name": "createCatalog",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    }
                ]
            }
        ],
        "markdown": "### [createCatalog](https://docs.dolphindb.cn/zh/funcs/c/createCatalog.html)\n\n\n\n#### 语法\n\ncreateCatalog(catalog)\n\n#### 参数\n\n**catalog** 字符串标量，表示 catalog 的名称。\n\n#### 详情\n\n创建一个 catalog。\n\n#### 例子\n\n```\ncreateCatalog(\"catalog1\")\n```\n"
    },
    "createCrossSectionalAggregator": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createCrossSectionalAggregator.html",
        "signatures": [
            {
                "full": "createCrossSectionalEngine(name, [metrics], dummyTable, [outputTable], keyColumn, [triggeringPattern='perBatch'], [triggeringInterval=1000], [useSystemTime=true], [timeColumn], [lastBatchOnly=false], [contextByColumn], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup], [outputElapsedMicroseconds=false], [roundTime=true], [keyFilter])",
                "name": "createCrossSectionalEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[metrics]",
                        "name": "metrics",
                        "optional": true
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "[outputTable]",
                        "name": "outputTable",
                        "optional": true
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "[triggeringPattern='perBatch']",
                        "name": "triggeringPattern",
                        "optional": true,
                        "default": "'perBatch'"
                    },
                    {
                        "full": "[triggeringInterval=1000]",
                        "name": "triggeringInterval",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[useSystemTime=true]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[lastBatchOnly=false]",
                        "name": "lastBatchOnly",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[contextByColumn]",
                        "name": "contextByColumn",
                        "optional": true
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[keyFilter]",
                        "name": "keyFilter",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createCrossSectionalAggregator](https://docs.dolphindb.cn/zh/funcs/c/createCrossSectionalAggregator.html)\n\n是 [createCrossSectionalEngine](https://docs.dolphindb.cn/zh/funcs/c/createCrossSectionalEngine.html) 的别名。\n\n\n以下是 `createCrossSectionalEngine` 函数的文档：\n### [createCrossSectionalEngine](https://docs.dolphindb.cn/zh/funcs/c/createCrossSectionalEngine.html)\n\n\n\n#### 语法\n\ncreateCrossSectionalEngine(name, \\[metrics], dummyTable, \\[outputTable], keyColumn, \\[triggeringPattern='perBatch'], \\[triggeringInterval=1000], \\[useSystemTime=true], \\[timeColumn], \\[lastBatchOnly=false], \\[contextByColumn], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[raftGroup], \\[outputElapsedMicroseconds=false], \\[roundTime=true], \\[keyFilter])\n\n别名：createCrossSectionalAggregator\n\n#### 详情\n\n创建横截面引擎，返回一个以 *keyColumn* 作为键值的键值表。\n\n该表记录了每组最新记录的时间戳（可以是数据自身的时间戳或者系统时间，由参数 *timeColumn* 和 *useSystemTime* 指定）。每次新数据的到来都会更新该表。若指定了 *lastBatchOnly* = true，此时引擎维护的键值表只会保留最新时间戳上不同组的数据。\n\n* 如果没有指定 *metrics* 或*outputTable*，横截面引擎不会利用表中的数据进行任何运算和输出，仅更新表中记录。\n* 如果指定了 *metrics* 和 *outputTable*，横截面引擎会首先更新表中记录，然后对表中的最新记录进行运算，并把结果输出到 *outputTable* 中。\n\n更多流数据引擎的应用场景说明可以参考 [内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)。\n\n##### 计算规则\n\n可选按数据量或时间触发计算，详情请参考 *triggeringPattern* 和 *triggeringInterval* 的参数说明。\n\n**Note:** 若指定了 *contextByColumn*，则数据将按照指定字段分组后在组内进行计算。\n\n##### 引擎的其他功能\n\n* 快照机制：启用快照机制之后，系统若出现异常，可及时将流数据引擎恢复到最新的快照状态。（详情请参考 *snapshotDir* 和 *snapshotIntervalInMsgCount* 的参数说明）\n* 流数据引擎高可用：若要启用引擎高可用，需在订阅端 raft 组的 leader 节点创建引擎并通过 *raftGroup* 参数开启高可用。开启高可用后，当 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。（详情请参考 *raftGroup* 的参数说明）\n\n#### 参数\n\n**name** 字符串标量，表示横截面引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**metrics** 以元代码的格式表示计算指标，支持输入元组。有关元代码的更多信息可参考[元编程](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n* 计算指标可以是系统内置或用户自定义的函数，如 <\\[sum(qty), avg(price)]>；可以对计算结果使用表达式，如 <\\[avg(price1)-avg(price2)]>；也可以对多列进行运算，如 <\\[std(price1-price2)]>。\n* *metrics* 内支持调用具有多个返回值的函数，例如 \\<func(price) as \\`col1\\`col2>（可不指定列名）。\n* *metrics* 中使用的列名大小写不敏感，不要求与输入表的列名大小写保持一致。\n\n**dummyTable** 一个表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。从 3.00.2 版本开始 *dummyTable* 支持包含 array vector 类型列。\n\n**outputTable** 计算结果的输出表，可以是内存表或分布式表。使用 `createCrossSectionalEngine` 函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。\n\n* 如果没有指定 *contextByColumn*， 则输出表各列的顺序如下：\n  * 第一列为 TIMESTAMP 类型，用于存放发生计算的时间戳（如果指定了 *timeColumn* 则是对应记录的时间戳）；\n  * 计算结果列，可为多列。其数据类型必须与 *metrics* 返回结果的数据类型一致。\n  * 耗时列，存储引擎内每个 batch 的计算耗时（单位：微秒），数据类型为 LONG。仅在指定 *outputElapsedMicroseconds*= true 时输出。\n  * 记录数列。存储引擎内每个 batch 的记录数，数据类型为 INT，仅在指定 *outputElapsedMicroseconds*= true 时输出。\n* 如果指定 *contextByColumn*， 则输出表各列的顺序如下：\n  * 第一列为 TIMESTAMP 类型，用于存放发生计算的时间戳（如果指定了 *timeColumn* 则是对应记录的时间戳）；\n  * 第二列为 *contextByColumn* 指定的列；\n  * 计算结果列，可为多列。其数据类型必须与 *metrics* 返回结果的数据类型一致。\n  * 耗时列，存储引擎内每个 batch 的计算耗时（单位：微秒），数据类型为 LONG。仅在指定 *outputElapsedMicroseconds*= true 时输出。\n  * 记录数列。存储引擎内每个 batch 的记录数，数据类型为 INT，仅在指定 *outputElapsedMicroseconds*= true 时输出。\n\n**keyColumn** 字符串标量或向量，指定流数据表中某列的值为横截面引擎的键值。横截面引擎的计算时，仅使用每个键值对应的最新一行记录。\n\n**triggeringPattern** 字符串标量，表示触发计算的方式，每触发一次计算，输出一条结果到输出表。该字符串可选值如下：\n\n* 'perBatch'：*triggeringPattern* 的默认值。每插入一次数据触发一次计算。\n* 'perRow'：插入的每一行数据都会触发一次计算。\n* 'interval'：基于系统时间间隔触发计算。\n* 'keyCount'：若相同时间戳的数据分批次到达，则只有在当前时间戳的记录数达到 *triggeringInterval*，或有更新时间戳的数据到达时，才会触发计算。使用该参数值时，必须指定 *timeColumn*，且 *useSystemTime* = false。若设置 *triggeringPattern* = 'keyCount'，收到的数据中出现的乱序数据会被丢弃，不参与计算。\n* 'dataInterval'：基于数据时间间隔触发计算。使用该参数值时，必须指定 *timeColumn*，且指定 *useSystemTime* = false。\n\n**triggeringInterval** 整数或元组，触发计算规则如下：\n\n* *triggeringPattern* 取值为 'interval' 时，*triggeringInterval* 是一个正整数，表示触发计算的时间间隔，单位为毫秒，默认值为 1000。每经过 *triggeringInterval* 指定的时间间隔，检查引擎中的数据是否被计算。若存在未被计算的数据，则触发一次计算。\n* *triggeringPattern* 取值为 'keyCount' 时：\n  * *triggeringInterval* 可以是一个整数。设置后，在更新的时间戳的数据到来前，当前时间戳的记录数需要累积到 *triggeringInterval* 才会触发计算。\n  * *triggeringInterval* 也可以是一个长度为 2 的 元组。元组的第一个元素是整数，表示触发计算的最新时间戳的记录数量。元组的第二个值可以是整数或者 duration 类型数据。假设设置 *triggeringInterval* = (c1, c2):\n    * 当 c2 为整数时，若收到的最新时间戳 t1 的数据数量小于 c1，这批数据不会触发计算，系统可以继续缓存更新时间戳 t2(t2>t1) 的数据，当 t2 的数据量达到 c2 或者收到更新的时间戳 t3(t3>t2) 的数据时，会触发时间戳 t1 对应数据的计算。注意必须满足 c2 < c1。\n    * 当 c2 为 duration 时，若收到的最新时间戳 t1 的数据数量小于 c1，这批数据不会触发计算，系统收到更新的时间戳 t2(t2>t1) 的数据后，会等待 duration 指定的时间，若在此期间继续收到了 t1 的数据且满足 t1 时间戳的数据总量达到 c1，或者在此期间又收到了更新的时间戳 t3(t3>t2) 的数据，则直接触发 t1 对应数据的计算，等待时间结束后不再触发计算。否则，等待 duration 设置的时间后才会触发 t1 数据的计算。\n* *triggeringPattern* 取值为 'dataInterval' 时，*triggeringInterval* 是一个正整数，单位和数据时间的单位一致，默认值为 1000。从第一条数据的时间戳开始一个窗口，窗口长度为 *triggeringInterval*。一个窗口结束后到达的第一条数据会触发当前窗口内数据的计算输出。输出表的时间为窗口结束的时间戳。\n\n  **Note:**\n\n  * 在 2.00.11.2 及之前版本，每个窗口都会输出。\n  * 从版本 2.00.11.3 起，仅当窗口内有数据插入时才会触发输出。\n\n**useSystemTime** 可选参数，布尔值，表示是否使用数据注入引擎时的系统时间作为计算参照的时间列。\n\n* 若 *useSystemTime* = true，*outputTable* 中第一列（时间列）为系统时间；\n* 若 *useSystemTime* = false，必须指定 *timeColumn*，*outputTable* 中第一列（时间列）为数据的时间戳。\n\n**timeColumn** 是一个字符串。当 *useSystemTime* = false 时，指定订阅的流数据表中时间列的名称。仅支持 TIMESTAMP 类型。\n\n**lastBatchOnly** 可选参数。横截面引擎是否只保留最新时间戳上的数据。当 *lastBatchOnly* = true 时，只能指定 *triggeringPattern* = 'keyCount'，此时横截面引擎维护的键值表只保存最新时间戳的键值数据；否则，更新并保留所有时间戳上的键值数据。\n\n**contextByColumn** 可选参数，字符串标量或向量。设置后，将对横截面引擎中数据按照指定的字段或字段组合分组，并在组内进行指定计算。\n\n* 设置该参数，必须指定 *metrics* 和 *outputTable*.\n* 如果 *metrics* 全为聚合函数，则分组计算结果和 groupby 分组计算结果一致，否则和 contextby 分组计算结果一致。\n\n若要开启快照机制 (snapshot)，必须指定 **snapshotDir** 与 **snapshotIntervalInMsgCount**。\n\n**snapshotDir** 可选参数，字符串，表示保存引擎快照的文件目录。\n\n* 指定的目录必须存在，否则系统会提示异常。\n* 创建流数据引擎时，如果指定了 *snapshotDir*，会检查该目录下是否存在快照。如果存在，会加载该快照，恢复引擎的状态。\n* 多个引擎可以指定同一个目录存储快照，用引擎的名称来区分快照文件。\n* 一个引擎的快照可能会使用三个文件名：\n  * 临时存储快照信息：文件名为 \\<engineName>.tmp；\n  * 快照生成并刷到磁盘：文件保存为 \\<engineName>.snapshot；\n  * 存在同名快照：旧快照自动重命名为 \\<engineName>.old。\n\n**snapshotIntervalInMsgCount** 可选参数，为整数类型，表示每隔多少条数据保存一次流数据引擎快照。\n\n**raftGroup** 是流数据高可用订阅端 raft 组的 ID (大于 1 的整数，由流数据高可用相关的配置项 *streamingRaftGroups* 指定)。设置该参数表示开启计算引擎高可用。在 leader 节点创建流数据引擎后，会同步在 follower 节点创建该引擎。每次保存的 snapshot 也会同步到 follower。当 raft 组的 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。注意，若要指定 *raftGroup*，必须同时指定 *snapshotDir*。\n\n**outputElapsedMicroseconds**布尔值，表示是否输出每个 batch 中数据从注入引擎到计算输出的总耗时，以及每个 batch 包含的总记录数，默认为 false，不输出。\n\n**Note:** *outputElapsedMicroseconds*= true 时，若同时指定 *useSystemTime*=true，则*metrics*中不可使用聚合函数。\n\n**roundTime** 可选参数，布尔值。用于对第一个数据窗口的起始时间进行规整，仅在 *triggeringPattern*=dataInterval 时有效。系统将根据该参数、triggeringInterval 和时间精度来确定规整尺度（alignmentSize）。窗口规整规则同[时序引擎](https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesEngine.html)。\n\n**keyFilter** 可选参数，以元代码形式表示的过滤条件。过滤条件是一个表达式或者函数调用，应用于截面数据中的列（列值为 key），返回一个布尔向量。引擎会从截面数据中过滤出 key 满足条件的数据进行计算。\n\n#### 例子\n\n例1. 横截面引擎 csEngineDemo1 触发计算的方式为 \"perRow\"。6 行数据写入流数据表 trades1，结果亦为 6 行。\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine1=createCrossSectionalEngine(name=\"csEngineDemo1\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades1, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"perRow\", useSystemTime=false, timeColumn=`time)\nsubscribeTable(tableName=\"trades1\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine1}, msgAsTable=true)\ninsert into trades1 values(2020.08.12T09:30:00.000 + 123 234 456 678 890 901, `A`B`A`B`B`A, 10 20 10.1 20.1 20.2 10.2, 20 10 20 30 40 20);\n\nselect * from trades1;\n```\n\n| time                    | sym | price | volume |\n| ----------------------- | --- | ----- | ------ |\n| 2020.08.12T09:30:00.123 | A   | 10    | 20     |\n| 2020.08.12T09:30:00.234 | B   | 20    | 10     |\n| 2020.08.12T09:30:00.456 | A   | 10.1  | 20     |\n| 2020.08.12T09:30:00.678 | B   | 20.1  | 30     |\n| 2020.08.12T09:30:00.890 | B   | 20.2  | 40     |\n| 2020.08.12T09:30:00.901 | A   | 10.2  | 20     |\n\n```\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2020.08.12T09:30:00.123 | 10       | 20     | 200          | 1     |\n| 2020.08.12T09:30:00.234 | 15       | 30     | 400          | 2     |\n| 2020.08.12T09:30:00.456 | 15.05    | 30     | 402          | 2     |\n| 2020.08.12T09:30:00.678 | 15.1     | 50     | 805          | 2     |\n| 2020.08.12T09:30:00.890 | 15.15    | 60     | 1010         | 2     |\n| 2020.08.12T09:30:00.901 | 15.2     | 60     | 1012         | 2     |\n\n例2. 横截面引擎 csEngineDemo2 触发计算的方式为 \"perBatch\"。数据分为 2 个批次写入流数据表 trades2，结果为 2 行。\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades2\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine2=createCrossSectionalEngine(name=\"csEngineDemo2\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades2, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"perBatch\", useSystemTime=false, timeColumn=`time)\nsubscribeTable(tableName=\"trades2\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine2}, msgAsTable=true)\ninsert into trades2 values(2020.08.12T09:30:00.000 + 123 234 456, `A`B`A, 10 20 10.1, 20 10 20);\nsleep(1)\ninsert into trades2 values(2020.08.12T09:30:00.000 + 678 890 901, `B`B`A, 20.1 20.2 10.2, 30 40 20);\n\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2020.08.12T09:30:00.456 | 15.05    | 30     | 402          | 2     |\n| 2020.08.12T09:30:00.901 | 15.2     | 60     | 1012         | 2     |\n\n例3. 横截面引擎 csEngineDemo4 触发计算的方式为 \"keyCount\"。设置 *lastBatchOnly* = true，只有最新时间戳上的数据会参与计算。因为 *metrics* 里聚合函数和非聚合函数混合使用，所以，输出记录行数等于输入记录行数，聚合结果重复输出多行。\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1\nshare table(1:0, `time`factor1`factor2, [TIMESTAMP, DOUBLE,INT]) as outputTable\nagg=createCrossSectionalAggregator(name=\"csEngineDemo4\", metrics=<[price+ 0.1, sum(volume)]>, dummyTable=trades1, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"keyCount\", triggeringInterval=5, useSystemTime=false, timeColumn=`time,lastBatchOnly=true)\nsubscribeTable(tableName=`trades1, actionName=\"csEngineDemo4\", msgAsTable=true, handler=append!{agg})\nnum=10\ntime=array(TIMESTAMP)\ntime=take(2018.01.01T09:30:00.000,num)\nsym=take(\"A\"+string(1..10),num)\nprice=1..num\nvolume=1..num\ntmp=table(time, sym, price, volume)\ntrades1.append!(tmp)\n\n// 第二次输入 5 条数据，lastBatchOnly=true，所以只有最新的 5 条数据参与计算。\nnum=5\ntime = array(TIMESTAMP)\ntime=take(2018.01.01T09:30:01.000,num)\nsym=take(\"A\"+string(1..10),num)\nprice=6..10\nvolume=6..10\ntmp=table(time, sym, price, volume)\ntrades1.append!(tmp)\n```\n\n| time                    | factor1 | factor2 |\n| ----------------------- | ------- | ------- |\n| 2018.01.01T09:30:00.000 | 1.1     | 55      |\n| 2018.01.01T09:30:00.000 | 2.1     | 55      |\n| 2018.01.01T09:30:00.000 | 3.1     | 55      |\n| 2018.01.01T09:30:00.000 | 4.1     | 55      |\n| 2018.01.01T09:30:00.000 | 5.1     | 55      |\n| 2018.01.01T09:30:00.000 | 6.1     | 55      |\n| 2018.01.01T09:30:00.000 | 7.1     | 55      |\n| 2018.01.01T09:30:00.000 | 8.1     | 55      |\n| 2018.01.01T09:30:00.000 | 9.1     | 55      |\n| 2018.01.01T09:30:00.000 | 10.1    | 55      |\n| 2018.01.01T09:30:01.000 | 6.1     | 40      |\n| 2018.01.01T09:30:01.000 | 7.1     | 40      |\n| 2018.01.01T09:30:01.000 | 8.1     | 40      |\n| 2018.01.01T09:30:01.000 | 9.1     | 40      |\n| 2018.01.01T09:30:01.000 | 10.1    | 40      |\n\n例4. 横截面引擎 csEngineDemo3 触发计算的方式为 \"interval\"，每 500 毫秒触发一次计算。向流数据表中写入6行数据，第一次批量写入，间隔 500 毫秒后再次写入。请注意，这里没有指定 *useSystemTime* 参数为 false，会返回计算发生的时刻。\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades3\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine3=createCrossSectionalEngine(name=\"csEngineDemo3\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades3, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"interval\", triggeringInterval=500)\nsubscribeTable(tableName=\"trades3\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine3}, msgAsTable=true);\n\ninsert into trades3 values(2020.08.12T09:30:00.000, `A, 10, 20)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 500, `B, 20, 10)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 1000, `A, 10.1, 20)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 2000, `B, 20.1, 30)\nsleep(500)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 2500, `B, 20.2, 40)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 3000, `A, 10.2, 20);\nsleep(500)\n\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2022.03.02T11:17:02.341 | 15.1     | 50     | 805          | 2     |\n| 2022.03.02T11:17:02.850 | 15.2     | 60     | 1,012        | 2     |\n\n*triggeringPattern* = \"interval\" 时，系统每隔 500ms 触发一次计算，输出一条结果。在计算被触发时，即使同一个 key 有多条记录未被计算，系统也只取最新时间戳上的数据进行计算。\n\n例5. 在股票数据中，有些股票在某一时刻之后就不再更新数据了，此时可通过 *keyFilter* 参数指定过滤条件。当之后收到其它股票数据并触发截面计算时不会计算该股票的数据。以在截面引擎中过滤出1小时内未更新的数据为例：\n\n```\n// 定义休市和过滤数据的逻辑\ndef checkTime(time){\n    maxTime = max(time)\n    if(between(maxTime, 2024.05.22T13:00:00.000:2024.05.22T13:30:00.000)){\n        return time > maxTime - 120*60*1000\n    } else{\n        return time > maxTime - 30*60*1000\n    }\n}\n// 定义截面引擎\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1\nt=keyedTable(`sym,10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT])\nshare table(1:0, `time`factor1`factor2, [TIMESTAMP, DOUBLE, DOUBLE]) as outputTable\n// 指定 keyFilter 为一个函数，过滤出1小时内未更新的数据。 \ncsEngine5=createCrossSectionalEngine(name=\"csEngineDemo5\", metrics=<[avg(price), sum(volume)]>, dummyTable=trades1, outputTable=outputTable, keyColumn=`sym, keyFilter=<checkTime(time)>)\n// 模拟数据，A1 从 2024.05.22T09:32:00.000 之后未收到新的数据\ntime = 2024.05.22T09:30:00.000 join 2024.05.22T09:31:00.000 join 2024.05.22T09:32:00.000 join 2024.05.22T13:30:00.000 join 2024.05.22T13:31:00.000\nsym=`A1`A2`A1`A2`A2\nprice=100.0 100.5 100.3 100.8 100.6\nvolume=100 110 112 200 120\ntmp=table(time, sym, price, volume)\ncsEngine5.append!(tmp)\n// 查看截面引擎中的数据\nselect * from csEngine5\n```\n\n| time                    | sym | price | volume |\n| ----------------------- | --- | ----- | ------ |\n| 2024.05.22T09:32:00.000 | A1  | 100.3 | 112    |\n| 2024.05.22T13:31:00.000 | A2  | 100.6 | 120    |\n\n上面代码通过 *keyFilter* 找到截面引擎中仅 A2 的数据满足要求，因此结果表中仅 A2 的数据参与了计算。\n\n```\nselect * from outputTable\n```\n\n| time                    | factor1 | factor2 |\n| ----------------------- | ------- | ------- |\n| 2024.05.22T05:11:12.259 | 100.6   | 120     |\n\n在以上的例子中， `createCrossSectionalEngine` 的返回结果（以下成为横截面表）是为计算提供的一个中间结果，但横截面表亦可为最终结果。例如若需要定时刷新某只股票的最新交易价格， 按照常规思路是从实时交易表中按代码筛选股票并取出最后一条记录，而交易表的数据量是随着时间快速增长的，如果频繁做这样的查询，无论从系统的资源消耗还是从查询的效能来看都不是最优的做法。 而横截面表永远只保存所有股票的最近一次交易数据，数据量是稳定的，对于这种定时轮询的场景非常合适。\n\n要将横截面表作为最终结果，需要在对 `createCrossSectionalEngine` 中的 *metrics* 与 *outputTable* 这两个参数置空。\n\n```\ntradesCrossEngine=createCrossSectionalEngine(name=\"CrossSectionalDemo\", dummyTable=trades, keyColumn=`sym, triggeringPattern=`perRow)\n```\n"
    },
    "createCrossSectionalEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createCrossSectionalEngine.html",
        "signatures": [
            {
                "full": "createCrossSectionalEngine(name, [metrics], dummyTable, [outputTable], keyColumn, [triggeringPattern='perBatch'], [triggeringInterval=1000], [useSystemTime=true], [timeColumn], [lastBatchOnly=false], [contextByColumn], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup], [outputElapsedMicroseconds=false], [roundTime=true], [keyFilter])",
                "name": "createCrossSectionalEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[metrics]",
                        "name": "metrics",
                        "optional": true
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "[outputTable]",
                        "name": "outputTable",
                        "optional": true
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "[triggeringPattern='perBatch']",
                        "name": "triggeringPattern",
                        "optional": true,
                        "default": "'perBatch'"
                    },
                    {
                        "full": "[triggeringInterval=1000]",
                        "name": "triggeringInterval",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[useSystemTime=true]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[lastBatchOnly=false]",
                        "name": "lastBatchOnly",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[contextByColumn]",
                        "name": "contextByColumn",
                        "optional": true
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[keyFilter]",
                        "name": "keyFilter",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createCrossSectionalEngine](https://docs.dolphindb.cn/zh/funcs/c/createCrossSectionalEngine.html)\n\n\n\n#### 语法\n\ncreateCrossSectionalEngine(name, \\[metrics], dummyTable, \\[outputTable], keyColumn, \\[triggeringPattern='perBatch'], \\[triggeringInterval=1000], \\[useSystemTime=true], \\[timeColumn], \\[lastBatchOnly=false], \\[contextByColumn], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[raftGroup], \\[outputElapsedMicroseconds=false], \\[roundTime=true], \\[keyFilter])\n\n别名：createCrossSectionalAggregator\n\n#### 详情\n\n创建横截面引擎，返回一个以 *keyColumn* 作为键值的键值表。\n\n该表记录了每组最新记录的时间戳（可以是数据自身的时间戳或者系统时间，由参数 *timeColumn* 和 *useSystemTime* 指定）。每次新数据的到来都会更新该表。若指定了 *lastBatchOnly* = true，此时引擎维护的键值表只会保留最新时间戳上不同组的数据。\n\n* 如果没有指定 *metrics* 或*outputTable*，横截面引擎不会利用表中的数据进行任何运算和输出，仅更新表中记录。\n* 如果指定了 *metrics* 和 *outputTable*，横截面引擎会首先更新表中记录，然后对表中的最新记录进行运算，并把结果输出到 *outputTable* 中。\n\n更多流数据引擎的应用场景说明可以参考 [内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)。\n\n##### 计算规则\n\n可选按数据量或时间触发计算，详情请参考 *triggeringPattern* 和 *triggeringInterval* 的参数说明。\n\n**Note:** 若指定了 *contextByColumn*，则数据将按照指定字段分组后在组内进行计算。\n\n##### 引擎的其他功能\n\n* 快照机制：启用快照机制之后，系统若出现异常，可及时将流数据引擎恢复到最新的快照状态。（详情请参考 *snapshotDir* 和 *snapshotIntervalInMsgCount* 的参数说明）\n* 流数据引擎高可用：若要启用引擎高可用，需在订阅端 raft 组的 leader 节点创建引擎并通过 *raftGroup* 参数开启高可用。开启高可用后，当 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。（详情请参考 *raftGroup* 的参数说明）\n\n#### 参数\n\n**name** 字符串标量，表示横截面引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**metrics** 以元代码的格式表示计算指标，支持输入元组。有关元代码的更多信息可参考[元编程](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n* 计算指标可以是系统内置或用户自定义的函数，如 <\\[sum(qty), avg(price)]>；可以对计算结果使用表达式，如 <\\[avg(price1)-avg(price2)]>；也可以对多列进行运算，如 <\\[std(price1-price2)]>。\n* *metrics* 内支持调用具有多个返回值的函数，例如 \\<func(price) as \\`col1\\`col2>（可不指定列名）。\n* *metrics* 中使用的列名大小写不敏感，不要求与输入表的列名大小写保持一致。\n\n**dummyTable** 一个表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。从 3.00.2 版本开始 *dummyTable* 支持包含 array vector 类型列。\n\n**outputTable** 计算结果的输出表，可以是内存表或分布式表。使用 `createCrossSectionalEngine` 函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。\n\n* 如果没有指定 *contextByColumn*， 则输出表各列的顺序如下：\n  * 第一列为 TIMESTAMP 类型，用于存放发生计算的时间戳（如果指定了 *timeColumn* 则是对应记录的时间戳）；\n  * 计算结果列，可为多列。其数据类型必须与 *metrics* 返回结果的数据类型一致。\n  * 耗时列，存储引擎内每个 batch 的计算耗时（单位：微秒），数据类型为 LONG。仅在指定 *outputElapsedMicroseconds*= true 时输出。\n  * 记录数列。存储引擎内每个 batch 的记录数，数据类型为 INT，仅在指定 *outputElapsedMicroseconds*= true 时输出。\n* 如果指定 *contextByColumn*， 则输出表各列的顺序如下：\n  * 第一列为 TIMESTAMP 类型，用于存放发生计算的时间戳（如果指定了 *timeColumn* 则是对应记录的时间戳）；\n  * 第二列为 *contextByColumn* 指定的列；\n  * 计算结果列，可为多列。其数据类型必须与 *metrics* 返回结果的数据类型一致。\n  * 耗时列，存储引擎内每个 batch 的计算耗时（单位：微秒），数据类型为 LONG。仅在指定 *outputElapsedMicroseconds*= true 时输出。\n  * 记录数列。存储引擎内每个 batch 的记录数，数据类型为 INT，仅在指定 *outputElapsedMicroseconds*= true 时输出。\n\n**keyColumn** 字符串标量或向量，指定流数据表中某列的值为横截面引擎的键值。横截面引擎的计算时，仅使用每个键值对应的最新一行记录。\n\n**triggeringPattern** 字符串标量，表示触发计算的方式，每触发一次计算，输出一条结果到输出表。该字符串可选值如下：\n\n* 'perBatch'：*triggeringPattern* 的默认值。每插入一次数据触发一次计算。\n* 'perRow'：插入的每一行数据都会触发一次计算。\n* 'interval'：基于系统时间间隔触发计算。\n* 'keyCount'：若相同时间戳的数据分批次到达，则只有在当前时间戳的记录数达到 *triggeringInterval*，或有更新时间戳的数据到达时，才会触发计算。使用该参数值时，必须指定 *timeColumn*，且 *useSystemTime* = false。若设置 *triggeringPattern* = 'keyCount'，收到的数据中出现的乱序数据会被丢弃，不参与计算。\n* 'dataInterval'：基于数据时间间隔触发计算。使用该参数值时，必须指定 *timeColumn*，且指定 *useSystemTime* = false。\n\n**triggeringInterval** 整数或元组，触发计算规则如下：\n\n* *triggeringPattern* 取值为 'interval' 时，*triggeringInterval* 是一个正整数，表示触发计算的时间间隔，单位为毫秒，默认值为 1000。每经过 *triggeringInterval* 指定的时间间隔，检查引擎中的数据是否被计算。若存在未被计算的数据，则触发一次计算。\n* *triggeringPattern* 取值为 'keyCount' 时：\n  * *triggeringInterval* 可以是一个整数。设置后，在更新的时间戳的数据到来前，当前时间戳的记录数需要累积到 *triggeringInterval* 才会触发计算。\n  * *triggeringInterval* 也可以是一个长度为 2 的 元组。元组的第一个元素是整数，表示触发计算的最新时间戳的记录数量。元组的第二个值可以是整数或者 duration 类型数据。假设设置 *triggeringInterval* = (c1, c2):\n    * 当 c2 为整数时，若收到的最新时间戳 t1 的数据数量小于 c1，这批数据不会触发计算，系统可以继续缓存更新时间戳 t2(t2>t1) 的数据，当 t2 的数据量达到 c2 或者收到更新的时间戳 t3(t3>t2) 的数据时，会触发时间戳 t1 对应数据的计算。注意必须满足 c2 < c1。\n    * 当 c2 为 duration 时，若收到的最新时间戳 t1 的数据数量小于 c1，这批数据不会触发计算，系统收到更新的时间戳 t2(t2>t1) 的数据后，会等待 duration 指定的时间，若在此期间继续收到了 t1 的数据且满足 t1 时间戳的数据总量达到 c1，或者在此期间又收到了更新的时间戳 t3(t3>t2) 的数据，则直接触发 t1 对应数据的计算，等待时间结束后不再触发计算。否则，等待 duration 设置的时间后才会触发 t1 数据的计算。\n* *triggeringPattern* 取值为 'dataInterval' 时，*triggeringInterval* 是一个正整数，单位和数据时间的单位一致，默认值为 1000。从第一条数据的时间戳开始一个窗口，窗口长度为 *triggeringInterval*。一个窗口结束后到达的第一条数据会触发当前窗口内数据的计算输出。输出表的时间为窗口结束的时间戳。\n\n  **Note:**\n\n  * 在 2.00.11.2 及之前版本，每个窗口都会输出。\n  * 从版本 2.00.11.3 起，仅当窗口内有数据插入时才会触发输出。\n\n**useSystemTime** 可选参数，布尔值，表示是否使用数据注入引擎时的系统时间作为计算参照的时间列。\n\n* 若 *useSystemTime* = true，*outputTable* 中第一列（时间列）为系统时间；\n* 若 *useSystemTime* = false，必须指定 *timeColumn*，*outputTable* 中第一列（时间列）为数据的时间戳。\n\n**timeColumn** 是一个字符串。当 *useSystemTime* = false 时，指定订阅的流数据表中时间列的名称。仅支持 TIMESTAMP 类型。\n\n**lastBatchOnly** 可选参数。横截面引擎是否只保留最新时间戳上的数据。当 *lastBatchOnly* = true 时，只能指定 *triggeringPattern* = 'keyCount'，此时横截面引擎维护的键值表只保存最新时间戳的键值数据；否则，更新并保留所有时间戳上的键值数据。\n\n**contextByColumn** 可选参数，字符串标量或向量。设置后，将对横截面引擎中数据按照指定的字段或字段组合分组，并在组内进行指定计算。\n\n* 设置该参数，必须指定 *metrics* 和 *outputTable*.\n* 如果 *metrics* 全为聚合函数，则分组计算结果和 groupby 分组计算结果一致，否则和 contextby 分组计算结果一致。\n\n若要开启快照机制 (snapshot)，必须指定 **snapshotDir** 与 **snapshotIntervalInMsgCount**。\n\n**snapshotDir** 可选参数，字符串，表示保存引擎快照的文件目录。\n\n* 指定的目录必须存在，否则系统会提示异常。\n* 创建流数据引擎时，如果指定了 *snapshotDir*，会检查该目录下是否存在快照。如果存在，会加载该快照，恢复引擎的状态。\n* 多个引擎可以指定同一个目录存储快照，用引擎的名称来区分快照文件。\n* 一个引擎的快照可能会使用三个文件名：\n  * 临时存储快照信息：文件名为 \\<engineName>.tmp；\n  * 快照生成并刷到磁盘：文件保存为 \\<engineName>.snapshot；\n  * 存在同名快照：旧快照自动重命名为 \\<engineName>.old。\n\n**snapshotIntervalInMsgCount** 可选参数，为整数类型，表示每隔多少条数据保存一次流数据引擎快照。\n\n**raftGroup** 是流数据高可用订阅端 raft 组的 ID (大于 1 的整数，由流数据高可用相关的配置项 *streamingRaftGroups* 指定)。设置该参数表示开启计算引擎高可用。在 leader 节点创建流数据引擎后，会同步在 follower 节点创建该引擎。每次保存的 snapshot 也会同步到 follower。当 raft 组的 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。注意，若要指定 *raftGroup*，必须同时指定 *snapshotDir*。\n\n**outputElapsedMicroseconds**布尔值，表示是否输出每个 batch 中数据从注入引擎到计算输出的总耗时，以及每个 batch 包含的总记录数，默认为 false，不输出。\n\n**Note:** *outputElapsedMicroseconds*= true 时，若同时指定 *useSystemTime*=true，则*metrics*中不可使用聚合函数。\n\n**roundTime** 可选参数，布尔值。用于对第一个数据窗口的起始时间进行规整，仅在 *triggeringPattern*=dataInterval 时有效。系统将根据该参数、triggeringInterval 和时间精度来确定规整尺度（alignmentSize）。窗口规整规则同[时序引擎](https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesEngine.html)。\n\n**keyFilter** 可选参数，以元代码形式表示的过滤条件。过滤条件是一个表达式或者函数调用，应用于截面数据中的列（列值为 key），返回一个布尔向量。引擎会从截面数据中过滤出 key 满足条件的数据进行计算。\n\n#### 例子\n\n例1. 横截面引擎 csEngineDemo1 触发计算的方式为 \"perRow\"。6 行数据写入流数据表 trades1，结果亦为 6 行。\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine1=createCrossSectionalEngine(name=\"csEngineDemo1\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades1, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"perRow\", useSystemTime=false, timeColumn=`time)\nsubscribeTable(tableName=\"trades1\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine1}, msgAsTable=true)\ninsert into trades1 values(2020.08.12T09:30:00.000 + 123 234 456 678 890 901, `A`B`A`B`B`A, 10 20 10.1 20.1 20.2 10.2, 20 10 20 30 40 20);\n\nselect * from trades1;\n```\n\n| time                    | sym | price | volume |\n| ----------------------- | --- | ----- | ------ |\n| 2020.08.12T09:30:00.123 | A   | 10    | 20     |\n| 2020.08.12T09:30:00.234 | B   | 20    | 10     |\n| 2020.08.12T09:30:00.456 | A   | 10.1  | 20     |\n| 2020.08.12T09:30:00.678 | B   | 20.1  | 30     |\n| 2020.08.12T09:30:00.890 | B   | 20.2  | 40     |\n| 2020.08.12T09:30:00.901 | A   | 10.2  | 20     |\n\n```\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2020.08.12T09:30:00.123 | 10       | 20     | 200          | 1     |\n| 2020.08.12T09:30:00.234 | 15       | 30     | 400          | 2     |\n| 2020.08.12T09:30:00.456 | 15.05    | 30     | 402          | 2     |\n| 2020.08.12T09:30:00.678 | 15.1     | 50     | 805          | 2     |\n| 2020.08.12T09:30:00.890 | 15.15    | 60     | 1010         | 2     |\n| 2020.08.12T09:30:00.901 | 15.2     | 60     | 1012         | 2     |\n\n例2. 横截面引擎 csEngineDemo2 触发计算的方式为 \"perBatch\"。数据分为 2 个批次写入流数据表 trades2，结果为 2 行。\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades2\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine2=createCrossSectionalEngine(name=\"csEngineDemo2\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades2, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"perBatch\", useSystemTime=false, timeColumn=`time)\nsubscribeTable(tableName=\"trades2\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine2}, msgAsTable=true)\ninsert into trades2 values(2020.08.12T09:30:00.000 + 123 234 456, `A`B`A, 10 20 10.1, 20 10 20);\nsleep(1)\ninsert into trades2 values(2020.08.12T09:30:00.000 + 678 890 901, `B`B`A, 20.1 20.2 10.2, 30 40 20);\n\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2020.08.12T09:30:00.456 | 15.05    | 30     | 402          | 2     |\n| 2020.08.12T09:30:00.901 | 15.2     | 60     | 1012         | 2     |\n\n例3. 横截面引擎 csEngineDemo4 触发计算的方式为 \"keyCount\"。设置 *lastBatchOnly* = true，只有最新时间戳上的数据会参与计算。因为 *metrics* 里聚合函数和非聚合函数混合使用，所以，输出记录行数等于输入记录行数，聚合结果重复输出多行。\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1\nshare table(1:0, `time`factor1`factor2, [TIMESTAMP, DOUBLE,INT]) as outputTable\nagg=createCrossSectionalAggregator(name=\"csEngineDemo4\", metrics=<[price+ 0.1, sum(volume)]>, dummyTable=trades1, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"keyCount\", triggeringInterval=5, useSystemTime=false, timeColumn=`time,lastBatchOnly=true)\nsubscribeTable(tableName=`trades1, actionName=\"csEngineDemo4\", msgAsTable=true, handler=append!{agg})\nnum=10\ntime=array(TIMESTAMP)\ntime=take(2018.01.01T09:30:00.000,num)\nsym=take(\"A\"+string(1..10),num)\nprice=1..num\nvolume=1..num\ntmp=table(time, sym, price, volume)\ntrades1.append!(tmp)\n\n// 第二次输入 5 条数据，lastBatchOnly=true，所以只有最新的 5 条数据参与计算。\nnum=5\ntime = array(TIMESTAMP)\ntime=take(2018.01.01T09:30:01.000,num)\nsym=take(\"A\"+string(1..10),num)\nprice=6..10\nvolume=6..10\ntmp=table(time, sym, price, volume)\ntrades1.append!(tmp)\n```\n\n| time                    | factor1 | factor2 |\n| ----------------------- | ------- | ------- |\n| 2018.01.01T09:30:00.000 | 1.1     | 55      |\n| 2018.01.01T09:30:00.000 | 2.1     | 55      |\n| 2018.01.01T09:30:00.000 | 3.1     | 55      |\n| 2018.01.01T09:30:00.000 | 4.1     | 55      |\n| 2018.01.01T09:30:00.000 | 5.1     | 55      |\n| 2018.01.01T09:30:00.000 | 6.1     | 55      |\n| 2018.01.01T09:30:00.000 | 7.1     | 55      |\n| 2018.01.01T09:30:00.000 | 8.1     | 55      |\n| 2018.01.01T09:30:00.000 | 9.1     | 55      |\n| 2018.01.01T09:30:00.000 | 10.1    | 55      |\n| 2018.01.01T09:30:01.000 | 6.1     | 40      |\n| 2018.01.01T09:30:01.000 | 7.1     | 40      |\n| 2018.01.01T09:30:01.000 | 8.1     | 40      |\n| 2018.01.01T09:30:01.000 | 9.1     | 40      |\n| 2018.01.01T09:30:01.000 | 10.1    | 40      |\n\n例4. 横截面引擎 csEngineDemo3 触发计算的方式为 \"interval\"，每 500 毫秒触发一次计算。向流数据表中写入6行数据，第一次批量写入，间隔 500 毫秒后再次写入。请注意，这里没有指定 *useSystemTime* 参数为 false，会返回计算发生的时刻。\n\n```\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades3\nshare table(1:0, `time`avgPrice`volume`dollarVolume`count, [TIMESTAMP,DOUBLE,INT,DOUBLE,INT]) as outputTable\ncsEngine3=createCrossSectionalEngine(name=\"csEngineDemo3\", metrics=<[avg(price), sum(volume), sum(price*volume), count(price)]>, dummyTable=trades3, outputTable=outputTable, keyColumn=`sym, triggeringPattern=\"interval\", triggeringInterval=500)\nsubscribeTable(tableName=\"trades3\", actionName=\"tradesStats\", offset=-1, handler=append!{csEngine3}, msgAsTable=true);\n\ninsert into trades3 values(2020.08.12T09:30:00.000, `A, 10, 20)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 500, `B, 20, 10)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 1000, `A, 10.1, 20)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 2000, `B, 20.1, 30)\nsleep(500)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 2500, `B, 20.2, 40)\ninsert into trades3 values(2020.08.12T09:30:00.000 + 3000, `A, 10.2, 20);\nsleep(500)\n\nselect * from outputTable;\n```\n\n| time                    | avgPrice | volume | dollarVolume | count |\n| ----------------------- | -------- | ------ | ------------ | ----- |\n| 2022.03.02T11:17:02.341 | 15.1     | 50     | 805          | 2     |\n| 2022.03.02T11:17:02.850 | 15.2     | 60     | 1,012        | 2     |\n\n*triggeringPattern* = \"interval\" 时，系统每隔 500ms 触发一次计算，输出一条结果。在计算被触发时，即使同一个 key 有多条记录未被计算，系统也只取最新时间戳上的数据进行计算。\n\n例5. 在股票数据中，有些股票在某一时刻之后就不再更新数据了，此时可通过 *keyFilter* 参数指定过滤条件。当之后收到其它股票数据并触发截面计算时不会计算该股票的数据。以在截面引擎中过滤出1小时内未更新的数据为例：\n\n```\n// 定义休市和过滤数据的逻辑\ndef checkTime(time){\n    maxTime = max(time)\n    if(between(maxTime, 2024.05.22T13:00:00.000:2024.05.22T13:30:00.000)){\n        return time > maxTime - 120*60*1000\n    } else{\n        return time > maxTime - 30*60*1000\n    }\n}\n// 定义截面引擎\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1\nt=keyedTable(`sym,10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT])\nshare table(1:0, `time`factor1`factor2, [TIMESTAMP, DOUBLE, DOUBLE]) as outputTable\n// 指定 keyFilter 为一个函数，过滤出1小时内未更新的数据。 \ncsEngine5=createCrossSectionalEngine(name=\"csEngineDemo5\", metrics=<[avg(price), sum(volume)]>, dummyTable=trades1, outputTable=outputTable, keyColumn=`sym, keyFilter=<checkTime(time)>)\n// 模拟数据，A1 从 2024.05.22T09:32:00.000 之后未收到新的数据\ntime = 2024.05.22T09:30:00.000 join 2024.05.22T09:31:00.000 join 2024.05.22T09:32:00.000 join 2024.05.22T13:30:00.000 join 2024.05.22T13:31:00.000\nsym=`A1`A2`A1`A2`A2\nprice=100.0 100.5 100.3 100.8 100.6\nvolume=100 110 112 200 120\ntmp=table(time, sym, price, volume)\ncsEngine5.append!(tmp)\n// 查看截面引擎中的数据\nselect * from csEngine5\n```\n\n| time                    | sym | price | volume |\n| ----------------------- | --- | ----- | ------ |\n| 2024.05.22T09:32:00.000 | A1  | 100.3 | 112    |\n| 2024.05.22T13:31:00.000 | A2  | 100.6 | 120    |\n\n上面代码通过 *keyFilter* 找到截面引擎中仅 A2 的数据满足要求，因此结果表中仅 A2 的数据参与了计算。\n\n```\nselect * from outputTable\n```\n\n| time                    | factor1 | factor2 |\n| ----------------------- | ------- | ------- |\n| 2024.05.22T05:11:12.259 | 100.6   | 120     |\n\n在以上的例子中， `createCrossSectionalEngine` 的返回结果（以下成为横截面表）是为计算提供的一个中间结果，但横截面表亦可为最终结果。例如若需要定时刷新某只股票的最新交易价格， 按照常规思路是从实时交易表中按代码筛选股票并取出最后一条记录，而交易表的数据量是随着时间快速增长的，如果频繁做这样的查询，无论从系统的资源消耗还是从查询的效能来看都不是最优的做法。 而横截面表永远只保存所有股票的最近一次交易数据，数据量是稳定的，对于这种定时轮询的场景非常合适。\n\n要将横截面表作为最终结果，需要在对 `createCrossSectionalEngine` 中的 *metrics* 与 *outputTable* 这两个参数置空。\n\n```\ntradesCrossEngine=createCrossSectionalEngine(name=\"CrossSectionalDemo\", dummyTable=trades, keyColumn=`sym, triggeringPattern=`perRow)\n```\n"
    },
    "createDailyTimeSeriesEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createDailyTimeSeriesEngine.html",
        "signatures": [
            {
                "full": "createDailyTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, [timeColumn], [useSystemTime=false], [keyColumn], [garbageSize], [updateTime], [useWindowStartTime], [roundTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [fill='none'], [sessionBegin], [sessionEnd], [mergeSessionEnd=false], [forceTriggerTime], [raftGroup], [forceTriggerSessionEndTime], [keyPurgeFreqInSec], [closed='left'], [outputElapsedMicroseconds=false], [subWindow], [parallelism=1],[acceptedDelay=0], [outputHandler=NULL], [msgAsTable=false], [keyPurgeDaily=true])",
                "name": "createDailyTimeSeriesEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "windowSize",
                        "name": "windowSize"
                    },
                    {
                        "full": "step",
                        "name": "step"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[updateTime]",
                        "name": "updateTime",
                        "optional": true
                    },
                    {
                        "full": "[useWindowStartTime]",
                        "name": "useWindowStartTime",
                        "optional": true
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[fill='none']",
                        "name": "fill",
                        "optional": true,
                        "default": "'none'"
                    },
                    {
                        "full": "[sessionBegin]",
                        "name": "sessionBegin",
                        "optional": true
                    },
                    {
                        "full": "[sessionEnd]",
                        "name": "sessionEnd",
                        "optional": true
                    },
                    {
                        "full": "[mergeSessionEnd=false]",
                        "name": "mergeSessionEnd",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[forceTriggerTime]",
                        "name": "forceTriggerTime",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[forceTriggerSessionEndTime]",
                        "name": "forceTriggerSessionEndTime",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSec]",
                        "name": "keyPurgeFreqInSec",
                        "optional": true
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[subWindow]",
                        "name": "subWindow",
                        "optional": true
                    },
                    {
                        "full": "[parallelism=1]",
                        "name": "parallelism",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[acceptedDelay=0]",
                        "name": "acceptedDelay",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyPurgeDaily=true]",
                        "name": "keyPurgeDaily",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [createDailyTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createDailyTimeSeriesEngine.html)\n\n\n\n#### 语法\n\ncreateDailyTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, \\[timeColumn], \\[useSystemTime=false], \\[keyColumn], \\[garbageSize], \\[updateTime], \\[useWindowStartTime], \\[roundTime=true], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[fill='none'], \\[sessionBegin], \\[sessionEnd], \\[mergeSessionEnd=false], \\[forceTriggerTime], \\[raftGroup], \\[forceTriggerSessionEndTime], \\[keyPurgeFreqInSec], \\[closed='left'], \\[outputElapsedMicroseconds=false], \\[subWindow], \\[parallelism=1],\\[acceptedDelay=0], \\[outputHandler=NULL], \\[msgAsTable=false], \\[keyPurgeDaily=true])\n\n#### 详情\n\n创建流数据日级时间序列引擎。日级时间序列引擎和时间序列引擎窗口划分和计算规则基本一致，但在此基础上做了如下拓展：\n\n* 该引擎只能在一个自然日的指定时间段内（以下统称为 session）进行窗口的聚合计算。一个自然日内，可以指定多个 session， 如 9:00-12:00，13:00-15:00 等。\n* 出现在一个 session 开始之前的数据，日级时序引擎规定将该部分数据合入该 session 的第一个窗口进行计算。\n* 当日最后一个 session 后到来的数据将被丢弃，不会计入第二天的第一个窗口中。\n\n若指定了 *keyColumn* 进行分组，则上述计算将在各分组内独立进行。\n\n更多流数据引擎的应用场景说明可以参考 [内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)。\n\n#### 参数\n\n该引擎是基于时间序列引擎进行的扩展，继承了 `createTimeSeriesEngine` 所有的参数，请参照 `createTimeSeriesEngine` 中参数介绍。这里仅介绍与时间序列引擎不同的参数：\n\n**sessionBegin** 为可选参数，可以是与时间列的数据类型对应的 SECOND、TIME 或 NANOTIME 类型的标量或向量，表示每个时间段的起始时刻。如果 *sessionBegin* 是一个向量，它必须是递增的。\n\n**sessionEnd** 为可选参数，可以是与时间列的数据类型对应的 SECOND、TIME 或 NANOTIME 类型的标量或向量，表示每个时间段的结束时刻。可在 *sessionEnd* 中指定 00:00:00 表示的次日的零点（即当日的 24:00:00）。\n\n**mergeSessionEnd** 为可选参数，是一个布尔值。当 close = 'left' 时，表示每个 session 结束时刻（规整后）的数据是否合入最后一个窗口。默认值为 false，此时该条数据不会合入当前 session 的最后一个窗口，但可以触发最后一个窗口的计算；如果当前 session 不是该自然日内最后一个 session，则该数据会合入下个 session 的第一个窗口。\n\n**forceTriggerSessionEndTime** 可选参数，正整数，单位与 *timeColumn* 的时间精度一致。若 *sessionEnd* 时刻对应的窗口数据长时间未发生计算，通过该参数可以设置系统经过多少时间后触发计算并输出。若不指定 *fill* ，未包含在该窗口内的分组不会输出结果；若指定了 *fill* ，未包含在该窗口内的分组会按照 *fill* 指定的方式输出结果。\n\n**keyPurgeDaily** 为可选参数，是一个布尔值。默认值为 true，表示引擎在收到第一批包含新日期的数据时，先清空之前保存的所有分组，再对这批新数据进行处理。若设置为 false，则引擎不会清理前一天的分组。\n\n**Note:** 系统会对数据窗口的起始时间（*sessionBegin* 和 *sessionEnd*）进行规整。\n\n#### 例子\n\n例1. 设置 *mergeSessionEnd*，将每个 session 结束时刻的数据合入最后一个窗口。\n\n```\nshare streamTable(1000:0, `date`second`sym`volume, [DATE, SECOND, SYMBOL, INT]) as trades\nshare keyedTable(`time`sym, 10000:0, `time`sym`sumVolume, [DATETIME, SYMBOL, INT]) as output1\nengine1 = createDailyTimeSeriesEngine(name=\"engine1\", windowSize=60, step=60, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`date`second, useSystemTime=false, keyColumn=`sym, garbageSize=50, updateTime=2, useWindowStartTime=false, sessionBegin=09:30:00 13:00:00, sessionEnd=11:30:00 15:00:00,mergeSessionEnd=true)\nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=append!{engine1}, msgAsTable=true);\n\ninsert into trades values(2018.10.08,09:25:31,`A,8)\ninsert into trades values(2018.10.08,09:26:01,`B,10)\ninsert into trades values(2018.10.08,09:30:02,`A,26)\ninsert into trades values(2018.10.08,09:30:10,`B,14)\ninsert into trades values(2018.10.08,11:29:46,`A,30)\ninsert into trades values(2018.10.08,11:29:50,`B,11)\ninsert into trades values(2018.10.08,11:30:00,`A,14)\ninsert into trades values(2018.10.08,11:30:00,`B,4)\ninsert into trades values(2018.10.08,13:00:10,`A,16)\ninsert into trades values(2018.10.08,13:00:12,`B,9)\ninsert into trades values(2018.10.08,14:59:56,`A,20)\ninsert into trades values(2018.10.08,14:59:58,`B,20)\ninsert into trades values(2018.10.08,15:00:00,`A,10)\ninsert into trades values(2018.10.08,15:00:00,`B,29)\n\nsleep(1000)\nselect * from output1\n```\n\n| time                | sym | sumVolume |\n| ------------------- | --- | --------- |\n| 2018.10.08T09:31:00 | A   | 34        |\n| 2018.10.08T09:31:00 | B   | 24        |\n| 2018.10.08T11:30:00 | A   | 44        |\n| 2018.10.08T11:30:00 | B   | 15        |\n| 2018.10.08T13:01:00 | A   | 16        |\n| 2018.10.08T13:01:00 | B   | 9         |\n| 2018.10.08T15:00:00 | A   | 30        |\n| 2018.10.08T15:00:00 | B   | 49        |\n\n例2. 设置 *forceTriggerSessionEndTime*，达到系统时间，强制触发计算。\n\n```\nshare streamTable(1000:0, `date`second`sym`volume, [DATE, SECOND, SYMBOL, INT]) as trades\nshare keyedTable(`time`sym, 10000:0, `time`sym`sumVolume, [DATETIME, SYMBOL, INT]) as output1\nengine1 = createDailyTimeSeriesEngine(name=\"engine1\", windowSize=60, step=60, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`date`second, useSystemTime=false, keyColumn=`sym, garbageSize=50, useWindowStartTime=false, sessionBegin=09:30:00 13:00:00, sessionEnd=11:30:00 15:00:00,mergeSessionEnd=true,forceTriggerSessionEndTime=10)\nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=append!{engine1}, msgAsTable=true);\n\ninsert into trades values(date(now()),09:25:31,`A,8)\ninsert into trades values(date(now()),09:26:01,`B,10)\ninsert into trades values(date(now()),09:30:02,`A,26)\ninsert into trades values(date(now()),09:30:10,`B,14)\ninsert into trades values(date(now()),11:29:46,`A,30)\ninsert into trades values(date(now()),11:29:50,`B,11)\ninsert into trades values(date(now()),11:30:00,`B,14)\ninsert into trades values(date(now()),11:30:01,`A,4)\n\nselect * from output1\n```\n\n| time                | sym | sumVolume |\n| ------------------- | --- | --------- |\n| 2022.03.24T09:31:00 | A   | 34        |\n| 2022.03.24T09:31:00 | B   | 24        |\n| 2022.03.24T11:30:00 | A   | 30        |\n\n设置 *forceTriggerSessionEndTime* = 10，则系统到达 11:30:00 后，再经过 10s 就会触发右边界为11:30:00的窗口内数据的计算。\n\n```\nsleep(10000)\nselect * from output1\n```\n\n| time                | sym | sumVolume |\n| ------------------- | --- | --------- |\n| 2022.03.24T09:31:00 | A   | 34        |\n| 2022.03.24T09:31:00 | B   | 24        |\n| 2022.03.24T11:30:00 | A   | 30        |\n| 2022.03.03T11:30:00 | B   | 25        |\n\n例3. 如果 *sessionEnd*- *sessionBegin* 不能整除 step，则会话的最后一个窗口由于长度不足而无法输出。若希望输出该窗口的数据，需要设置 *roundTime* = false，将窗口按一分钟规则规整后输出。\n\n```\n// 清理变量\ndropStreamEngine(\"engine1\")\nunsubscribeTable(tableName=\"trades\", actionName=\"engine1\")\nundef(`trades, SHARED)\nundef(`output1,SHARED)\n\nshare streamTable(1000:0, `date`time`sym`volume, [DATE, TIME, SYMBOL, INT]) as trades\nshare keyedTable(`timestamp`sym, 10000:0, `timestamp`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output1\n\n//创建引擎，指定窗口长度为 10 分钟。最后一个 sessionEnd 是 14:57:00 \nengine1 = createDailyTimeSeriesEngine(name=\"engine1\", windowSize=600000, step=600000, \n  metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`date`time, garbageSize=50, updateTime=2, \n  useSystemTime=false, keyColumn=`sym,  useWindowStartTime=false, mergeSessionEnd=true,\n  sessionBegin=09:30:00.000 13:00:00.000,  sessionEnd=11:30:00.000 14:57:00.000, roundTime=false)\n  \nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, \n  handler=append!{engine1}, msgAsTable=true);\n\n// 模拟数据插入流表。\n// 最后一条数据时间是 14:56:00，按照一分钟规则进行规整，则该条数据将输出到 14:57:00 的窗口中\ninsert into trades values(2024.09.10,14:00:10.988,`A,16)\ninsert into trades values(2024.09.10,14:00:12.458,`B,9)\ninsert into trades values(2024.09.10,14:21:10.772,`A,13)\ninsert into trades values(2024.09.10,14:22:12.090,`B,15)\ninsert into trades values(2024.09.10,14:29:56.953,`A,20)\ninsert into trades values(2024.09.10,14:29:58.537,`B,20)\ninsert into trades values(2024.09.10,14:31:00.612,`A,10)\ninsert into trades values(2024.09.10,14:56:00.000,`B,29)\n\nsleep(1000)\nselect * from output1\n```\n\n| timestamp               | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2024.09.10T14:10:00.000 | A   | 16        |\n| 2024.09.10T14:10:00.000 | B   | 9         |\n| 2024.09.10T14:30:00.000 | A   | 33        |\n| 2024.09.10T14:30:00.000 | B   | 35        |\n| 2024.09.10T14:40:00.000 | A   | 10        |\n| 2024.09.10T14:57:00.000 | B   | 29        |\n\n例4.\n\n设置 *keyPurgeDaily*=false, 则在收到第一批日期是 2024.09.11 的数据时，引擎不会清空日期是 2024.09.10 的分组数据。\n\n```\nshare streamTable(1000:0, `date`second`sym`volume, [DATE,\n              SECOND, SYMBOL, INT]) as trades share table(10000:0, `time`sym`sumVolume, [DATETIME, SYMBOL, INT]) as output1\n            engine1 = createDailyTimeSeriesEngine(name=\"engine1\", windowSize=30*60,\n            step=30*60,    metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1,    timeColumn=`date`second, useSystemTime=false, keyColumn=`sym, garbageSize=50,\n              useWindowStartTime=false, sessionBegin=09:30:00 13:00:00,    sessionEnd=11:30:00 15:00:00,mergeSessionEnd=true, keyPurgeDaily=false,\n              fill=\"null\", forceTriggerTime=60) insert into engine1 values(2024.09.10,13:00:10,`A,16) insert into engine1 values(2024.09.10,13:00:12,`B,9) insert into engine1 values(2024.09.10,13:00:12,`C,9) insert into engine1 values(2024.09.10,14:59:56,`A,20) insert into engine1 values(2024.09.10,14:59:58,`B,20) insert into engine1 values(2024.09.10,15:00:00,`A,10) insert into engine1 values(2024.09.10,15:00:00,`B,29) insert into engine1 values(2024.09.11,09:30:02,`A,26) insert into engine1 values(2024.09.11,09:30:10,`B,14) insert into engine1 values(2024.09.11,10:30:46,`A,30) insert into engine1 values(2024.09.11,10:30:50,`B,11) select * from output1\n```\n\n<table id=\"table_ofx_mry_bdc\"><thead><tr><th align=\"left\">\n\ntime\n\n</th><th align=\"left\">\n\nsym\n\n</th><th align=\"left\">\n\nsumVolume\n\n</th></tr></thead><tbody><tr><td>\n\n2024.09.10T13:30:00\n\n</td><td>\n\nA\n\n</td><td>\n\n16\n\n</td></tr><tr><td>\n\n2024.09.10T13:30:00\n\n</td><td>\n\nB\n\n</td><td>\n\n9\n\n</td></tr><tr><td>\n\n2024.09.10T13:30:00\n\n</td><td>\n\nC\n\n</td><td>\n\n9\n\n</td></tr><tr><td>\n\n2024.09.10T14:00:00\n\n</td><td>\n\nA\n\n</td><td>\n\n11\n\n</td></tr><tr><td>\n\n2024.09.10T14:00:00\n\n</td><td>\n\nB\n\n</td><td>\n\n30\n\n</td></tr><tr><td>\n\n2024.09.10T14:00:00\n\n</td><td>\n\nC\n\n</td><td>\n\n13\n\n</td></tr><tr><td>\n\n2024.09.10T14:30:00\n\n</td><td>\n\nA\n\n</td><td>\n\n20\n\n</td></tr><tr><td>\n\n2024.09.10T14:30:00\n\n</td><td>\n\nB\n\n</td><td>\n\n20\n\n</td></tr><tr><td>\n\n2024.09.10T14:30:00\n\n</td><td>\n\nC\n\n</td><td>\n\n10\n\n</td></tr><tr><td>\n\n2024.09.10T15:00:00\n\n</td><td>\n\nA\n\n</td><td>\n\n30\n\n</td></tr><tr><td>\n\n2024.09.10T15:00:00\n\n</td><td>\n\nB\n\n</td><td>\n\n49\n\n</td></tr><tr><td>\n\n2024.09.10T15:00:00\n\n</td><td>\n\nC\n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n2024.09.11T10:00:00\n\n</td><td>\n\nA\n\n</td><td>\n\n26\n\n</td></tr><tr><td>\n\n2024.09.11T10:00:00\n\n</td><td>\n\nB\n\n</td><td>\n\n14\n\n</td></tr><tr><td>\n\n2024.09.11T10:00:00\n\n</td><td>\n\nC\n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n2024.09.11T10:30:00\n\n</td><td>\n\nA\n\n</td><td>\n\n \n\n</td></tr></tbody>\n</table>从上表的结果可以看出，2024.09.11 的数据中未包含 C 分组，但由于引擎未删除 2024.09.10 中的 C 分组，，因此填充结果中仍然出现了 C 分组。\n\n**Related information**\n\n[createTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesEngine.html)\n"
    },
    "createDeviceEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createdeviceengine.html",
        "signatures": [
            {
                "full": "createDeviceEngine(name, metrics, dummyTable, outputTable, [keyColumn], [keepOrder])",
                "name": "createDeviceEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[keepOrder]",
                        "name": "keepOrder",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createDeviceEngine](https://docs.dolphindb.cn/zh/funcs/c/createdeviceengine.html)\n\n#### 语法\n\ncreateDeviceEngine(name, metrics, dummyTable, outputTable, \\[keyColumn], \\[keepOrder])\n\n#### 详情\n\n创建一个设备引擎，该引擎会将注入输入表的数据，通过 GPU 加速完成 metrics 中定义的计算，将结果输出到输出表。\n\n注意：设备引擎不维护上一批数据的状态。即两批数据写入时，第二批数据的起始状态与第一批状态无关。\n\n#### 参数\n\n**name** 字符串标量，表示设备引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**metrics** 以元代码的形式表示计算公式，可以是一个或多个表达式、系统内置或用户自定义函数（不支持多返回值，for 循环不得嵌套，for 循环次数不能超过100），也可以是个常量标量/向量。当指定为常量向量时，对应的输出列应该设置为数组向量类型。。有关元代码的详情可参考 [Metaprogramming](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。**metrics** 支持的函数包括：\n\n* 单目基础运算操作：not, neg, cast, log, log2, log10 ,log1p ,abs, sign, sqrt, sin, sinh, asin, asinh, cos, cosh, acos, acosh, tan, tanh, atan, atanh, reciprocal, cbrt, exp, exp2, expm1\n\n* 双目基础运算操作：add, sub, mul, div, ratio, pow, lt, gt, le, ge, eq, ne, and, or, or\\_\\_（即`||`运算符，需要注意关于 NULL 的处理依赖于配置项 `logicOrIgnoreNull` ）, max, min\n\n* 双目整型运算（其中 mod 支持 BOOL 类型，其他只支持数值类型)：mod, bitAnd, bitOr, bitXor, lshift, rshift\n\n* 三目运算：iif\n\n* 单目滑动窗口函数：mavg, msum, mcount, mprod, mvar, mvarp, mstd, mstdp, mskew, mkurtosis, mmin, mmax, mimin, mimax, sma, wma, mfirst, mlast, mrank, mmaxPositiveStreak, mmed, mpercentile, mmad（暂不支持参数 *useMedian*）\n\n* 双目滑动窗口函数：sma, ema, wma, dema, tema, trima, t3, wilder, gema, linearTimeTrend, ma, talib（仅支持所有 m 系列和 mTopN 函数，不支持其他函数）, kama\n\n* 其他滑动窗口函数：linearTimeTrend，mslr\n\n* 单目累计窗口函数：cumsum, cumprod, cummin, cummax, cumvar, cumvarp, cumstd, cumstdp, cumnunique, cumfirstNot, cumlastNot, cumavg, cumcount, cumPositiveStreak\n\n* 双目累计窗口函数：cumcorr, cumcovar, cumbeta, cumwsum, cumwavg\n\n* 序列相关函数：deltas, ratios, ffill, move, prev, next, percentChange, iterate, prevState, ewmMean, ewmVar, ewmStd, ewmCov, ewmCorr\n\n  注意：ewmVar, ewmStd, ewmCov, ewmCorr 均不支持设置 adjust=true，且不支持设置 bias=false。\n\n* row系列函数：rowMin, rowMax, rowAnd, rowOr, rowXor, rowProd, rowSum, rowSum2, rowSize, rowCount, rowAvg, rowVar, rowVarp, rowStd, rowStdp\n\n* tm系列函数：tmsum, tmsum2, tmavg, tmprod, tmcount, tmvar, tmvarp, tmstd, tmstdp, tmcovar, tmcorr, tmwavg, tmwsum, tmbeta, tmfirst, tmlast, tmmin, tmmax, tmskew, tmkurtosis, tmove\n\n* 其他函数：TrueRange，topRange，lowRange，stateMavg\n\n注意：自 3.00.1 版本起，当计算结果的绝对值小于 `DBL_EPSILON*10000`(约 2.22\\*10-12)时，所有滑动窗口系列函数和累积窗口系列函数均不会对结果进行约整，而是保留所有精度。\n\n**dummyTable** 一个表对象，注入数据的结构与其 schema 一致。可以含有数据，亦可为空表。\n\n**outputTable** 计算结果的输出表，可以是内存表或分布式表。使用 `createDeviceReactiveEngine`函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。`DeviceReactiveEngine`会将计算结果注入该表。\n\n**keyColumn** 可选参数，字符串标量或向量表示分组列名。计算将在各分组进行。\n\n**keepOrder**可选参数，表示输出表数据是否按照输入时的顺序排序。默认值为 false。设置 *keepOrder* = true，表示输出表按照输入时的顺序排序； *keepOrder* = false，表示输出表按照分组列排序。\n\n#### 例子\n\n```\n// 创建引擎\ndummyTb = table(1:0, `sym`id`value, [SYMBOL,INT,DOUBLE])\nshare table(100:0, `sym`id`flag`value`factor, [SYMBOL,INT,SYMBOL,DOUBLE,DOUBLE]) as result\nde = createDeviceEngine(name=\"myDe\", metrics=[<id>,<\"flag\"+\"_A\">,<value>,<mavg(value,5)>], dummyTable=dummyTb, outputTable=result, keyColumn=\"sym\")\n\n// 准备数据 \ndata1 = table(take(\"A\", 100) as sym, 1..100 as id, double(10+1..100) as value)\ndata2 = table(take(\"B\", 100) as sym, 1..100 as id, double(20+1..100) as value)\ndata3 = table(take(\"C\", 100) as sym, 1..100 as id, double(30+1..100) as value)\ndata = data1.unionAll(data2).unionAll(data3).sortBy!(`id)\n\n// 写入数据\nde.append!(data)\nselect top 10 * from result   \n```\n\n<table id=\"table_ijs_vkf_xbc\"><thead><tr><th>\n\nsym\n\n</th><th>\n\nid\n\n</th><th>\n\nflag\n\n</th><th>\n\nvalue\n\n</th><th>\n\nfactor\n\n</th></tr></thead><tbody><tr><td>\n\nA\n\n</td><td>\n\n1\n\n</td><td>\n\nflag\\_A\n\n</td><td>\n\n11\n\n</td><td>\n\n</td></tr><tr><td>\n\nA\n\n</td><td>\n\n2\n\n</td><td>\n\nflag\\_A\n\n</td><td>\n\n12\n\n</td><td>\n\n</td></tr><tr><td>\n\nA\n\n</td><td>\n\n3\n\n</td><td>\n\nflag\\_A\n\n</td><td>\n\n13\n\n</td><td>\n\n</td></tr><tr><td>\n\nA\n\n</td><td>\n\n4\n\n</td><td>\n\nflag\\_A\n\n</td><td>\n\n14\n\n</td><td>\n\n</td></tr><tr><td>\n\nA\n\n</td><td>\n\n5\n\n</td><td>\n\nflag\\_A\n\n</td><td>\n\n15\n\n</td><td>\n\n13\n\n</td></tr><tr><td>\n\nA\n\n</td><td>\n\n6\n\n</td><td>\n\nflag\\_A\n\n</td><td>\n\n16\n\n</td><td>\n\n14\n\n</td></tr><tr><td>\n\nA\n\n</td><td>\n\n7\n\n</td><td>\n\nflag\\_A\n\n</td><td>\n\n17\n\n</td><td>\n\n15\n\n</td></tr><tr><td>\n\nA\n\n</td><td>\n\n8\n\n</td><td>\n\nflag\\_A\n\n</td><td>\n\n18\n\n</td><td>\n\n16\n\n</td></tr><tr><td>\n\nA\n\n</td><td>\n\n9\n\n</td><td>\n\nflag\\_A\n\n</td><td>\n\n19\n\n</td><td>\n\n17\n\n</td></tr><tr><td>\n\nA\n\n</td><td>\n\n10\n\n</td><td>\n\nflag\\_A\n\n</td><td>\n\n20\n\n</td><td>\n\n18\n\n</td></tr></tbody>\n</table>**Parent topic:**[函数参考](../../funcs/funcs_intro.md)\n"
    },
    "createDimensionTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createdimensiontable.html",
        "signatures": [
            {
                "full": "createDimensionTable(dbHandle, table, tableName, [compressMethods], [sortColumns\\|primaryKey], [keepDuplicates=ALL], [softDelete=false], [indexes])",
                "name": "createDimensionTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[compressMethods]",
                        "name": "compressMethods",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns\\|primaryKey]",
                        "name": "[sortColumns\\|primaryKey]"
                    },
                    {
                        "full": "[keepDuplicates=ALL]",
                        "name": "keepDuplicates",
                        "optional": true,
                        "default": "ALL"
                    },
                    {
                        "full": "[softDelete=false]",
                        "name": "softDelete",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[indexes]",
                        "name": "indexes",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createDimensionTable](https://docs.dolphindb.cn/zh/funcs/c/createdimensiontable.html)\n\n\n\n#### 语法\n\ncreateDimensionTable(dbHandle, table, tableName, \\[compressMethods], \\[sortColumns\\\\|primaryKey], \\[keepDuplicates=ALL], \\[softDelete=false], \\[indexes])\n\n别名：createTable\n\n#### 详情\n\n在分布式数据库中创建一个维度表。维度表是分布式数据库中没有进行分区的表，查询时会将表中所有数据加载到内存，适用于存储不频繁更新的小数据集。\n\n系统会定期检查内存的使用情况，当内存使用超过系统配置参数 *warningMemSize* 设定的阈值时，系统会尝试释放部分缓存。维度表如果长时间未被使用，其占用的内存根据 LRU（Least Recently Used）策略将被释放。用户也可以调用 *clearCachedDatabase* 手动释放维度表的缓存。\n\n维度表与分区表都是根据设置参数 *dfsReplicationFactor* 决定副本的数量。维度表的读写操作也支持事务。\n\n通过在配置项配置 *enableConcurrentDimensionalTableWrite* = true，可以支持对维度表进行并发的写入、修改或删除操作。\n\n#### 参数\n\n**dbHandle** 是 [database](https://docs.dolphindb.cn/zh/funcs/d/database.html) 函数返回的分布式数据库句柄。\n\n**table** 是一个表，系统将根据该表的结构在数据库中创建一个空的维度表。\n\n**tableName** 是一个字符串，表示维度表的名称。\n\n**compressMethods** 一个字典，指定某些列使用 lz4, delta, zstd 或 chimp 压缩算法存储。key 为字段名，value 为压缩算法（\"lz4\", \"delta\", \"zstd\" 或 \"chimp\"）。若未指定，默认采用 lz4 压缩算法。有关 Delta 压缩算法，亦称为 delta-of-delta encoding，参考：[Delta Compression Techniques](http://engineering.nyu.edu/~suel/papers/delta-chap.pdf)。\n\n* 对于 DECIMAL,SHORT, INT, LONG 与时间或日期类型数据，建议采用 Delta 算法压缩。\n* 将字符串存储为 SYMBOL 类型数据，实现对字符串类型的压缩。\n* 对于小数部分长度在三位以内的 DOUBLE 类型的数据，可以考虑使用 chimp 算法压缩。\n\n**sortColumns** 字符串标量或向量，用于指定每一分区内的排序列，每次写入磁盘的数据在每一分区内将按 *sortColumns* 进行排序。系统默认 *sortColumns* （指定多列时） 最后一列为时间列，其余列字段作为排序的索引列，称作 sort key。每一分区内，同一个 sort key 组合值对应的数据将按时间列顺序连续存放在一起。查询时，若查询条件包含索引列，可以快速定位数据所在的数据块位置，提高查询性能。\n\n* 仅当 dbHandle 指示的数据库采用 “TSDB” 引擎（engine=”TSDB”）时，本参数才生效。\n* *sortColumns* 只能是 INTEGER, TEMPORAL, LITERAL 类别（除 BLOB） 或 DECIMAL 类型。\n  * 若 *sortColumns* 指定为多列，则 *sortColumns* 的最后一列必须为时间列，其余列为索引列，且索引列不能为为 TIME, TIMESTAMP, NANOTIME, NANOTIMESTAMP 类型。\n  * 若 *sortColumns* 仅指定一列，则该列作为 sort key，其类型不能为TIME, TIMESTAMP, NANOTIME, NANOTIMESTAMP。若 *sortColumns* 指定为一列时间列 （非分区列），且同时指定了 *sortKeyMappingFunction*，则查询的过滤条件中 *sortColumns* 只能与相同时间类型的值进行比较。\n* 频繁查询的字段适合设置为 *sortColumns*，且建议优先把查询频率高的字段作为 *sortColumns* 中位置靠前的列。\n* 为保证性能最优，建议每个分区内索引列的组合数（sort key）不超过1000个。\n* *sortColumns* 是每个分区内部 level file 内数据的排序依据，与其是否为分区字段无关。\n\n**primaryKey**字符串标量或向量，用于指定主键列。在数据写入操作中，如果主键相同，新的数据覆盖现有数据。\n\n* 仅当*dbHandlei* 指示的数据库采用 “PKEY” 引擎（engine=”PKEY”）时，本参数才生效。\n\n* 主键列必须包含所有的分区列。\n\n* 主键列支持的类型包括：BOOL, CHAR, SHORT, INT, LONG, INT128, STRING, TIME, SECOND, MINUTE, DATE, MONTH, DATEHOUR, DATETIME, SYMBOL, TIMESTAMP, NANOTIME, NANOTIMESTAMP, UUID, COMPLEX, POINT, IPADDR, DECIMAL32, DECIMAL64, DECIMAL128。\n\n**keepDuplicates** 指定在每个分区内如何处理所有 *sortColumns* 之值皆相同的数据。提供以下选项：\n\n* ALL：保留所有数据，为默认值。\n* LAST：仅保留最新数据\n* FIRST：仅保留第一条数据\n\n**softDelete** 用于启用或禁用软删除功能。默认为 false，即禁用。该参数适于在行数多但删除量小的场景下使用。使用该参数需要同时满足以下条件：\n\n* 由TSDB 存储引擎创建的数据库内的表\n\n* *keepDuplicates* 已设置为 LAST\n\n**Note:** 参数 *sortColumns*, *keepDuplicates* 仅在 `database` 的 *engine* 参数指定为 TSDB 时才有效。\n\n**indexes** 为一个字典。当引擎为 PKEY 时，用于为表中的列指定索引。字典的键是 STRING 类型标量，表示列名；值是 STRING 类型标量，表示为该列指定的索引类型。目前支持设置 “bloomfilter” 索引类型：适用于对大基数列进行点查，且基数越大，索引效果越好，如身份证 ID、订单号、从业务上游同步的外键等数据列。目前支持的类型包括 BOOL, CHAR, SHORT, INT, LONG, BLOB, STRING, DECIMAL32, DECIMAL64, DECIMAL128。\n\n**Note:** 引擎会将所有主键列合并为组合主键，并为组合主键设置 bloomfilter 类型索引。\n\n#### 例子\n\n例1\n\n```\ndb=database(\"dfs://db1\",VALUE,1 2 3)\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nt = table(timestamp, sym, qty, price);\n\ndt=db.createDimensionTable(t,`dt).append!(t);\nselect * from dt;\n```\n\n| timestamp | sym | qty  | price  |\n| --------- | --- | ---- | ------ |\n| 09:34:07  | C   | 2200 | 49.6   |\n| 09:36:42  | MS  | 1900 | 29.46  |\n| 09:36:51  | MS  | 2100 | 29.52  |\n| 09:36:59  | MS  | 3200 | 30.02  |\n| 09:32:47  | IBM | 6800 | 174.97 |\n| 09:35:26  | IBM | 5400 | 175.23 |\n| 09:34:16  | C   | 1300 | 50.76  |\n| 09:34:26  | C   | 2500 | 50.32  |\n| 09:38:12  | C   | 8800 | 51.29  |\n\n例2\n\n```\ndb = database(\"dfs://demodb\", VALUE, 1..10)\nt=table(take(1, 86400) as id, 2020.01.01T00:00:00 + 0..86399 as timestamp, rand(1..100, 86400) as val)\ndt = db.createDimensionTable(t, \"dt\", {timestamp:\"delta\", val:\"delta\"})\ndt.append!(t)\n```\n\n例3. TSDB 存储引擎下创建维度表\n\n```\nif(existsDatabase(\"dfs://dbctable_createDimensionTable\")){\n  dropDatabase(\"dfs://dbctable_createDimensionTable\")\n}\ndb = database(\"dfs://dbctable_createDimensionTable\", VALUE, 1..100, , \"TSDB\")\nt1 = table(1 100 100 300 300 400 500 as id, 1..7 as v)\ndb.createDimensionTable(t1, \"dt\", , \"id\").append!(t1)\ndt=loadTable(\"dfs://dbctable_createDimensionTable\",\"dt\")\n```\n\n例4. PKEY 存储引擎下创建维度表\n\n```\ndb = database(directory=\"dfs://PKDB\", partitionType=VALUE, partitionScheme=1..10, engine=\"PKEY\")\nschematb = table(1:0,`id1`id2`val1`val2`date1`time1,[INT,INT,INT,DECIMAL32(2),DATE,TIME])\npkt = createDimensionTable(dbHandle=db, table=schematb, tableName=\"pkt\", primaryKey=`id1`id2, indexes={\"val1\": \"bloomfilter\", \"val2\": \"bloomfilter\"})\n```\n\n**Related information**\n\n[createPartitionedTable](https://docs.dolphindb.cn/zh/funcs/c/createPartitionedTable.html)\n"
    },
    "createDistributedInMemoryTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createDistributedInMemoryTable.html",
        "signatures": [
            {
                "full": "createDistributedInMemoryTable(tableName, colNames, colTypes, globalPartitionType, globalPartitionScheme, globalPartitionColumn, [localPartitionType], [localPartitionScheme], [localPartitionColumn])",
                "name": "createDistributedInMemoryTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    },
                    {
                        "full": "globalPartitionType",
                        "name": "globalPartitionType"
                    },
                    {
                        "full": "globalPartitionScheme",
                        "name": "globalPartitionScheme"
                    },
                    {
                        "full": "globalPartitionColumn",
                        "name": "globalPartitionColumn"
                    },
                    {
                        "full": "[localPartitionType]",
                        "name": "localPartitionType",
                        "optional": true
                    },
                    {
                        "full": "[localPartitionScheme]",
                        "name": "localPartitionScheme",
                        "optional": true
                    },
                    {
                        "full": "[localPartitionColumn]",
                        "name": "localPartitionColumn",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createDistributedInMemoryTable](https://docs.dolphindb.cn/zh/funcs/c/createDistributedInMemoryTable.html)\n\n\n\n#### 语法\n\ncreateDistributedInMemoryTable(tableName, colNames, colTypes, globalPartitionType, globalPartitionScheme, globalPartitionColumn, \\[localPartitionType], \\[localPartitionScheme], \\[localPartitionColumn])\n\n#### 详情\n\n创建一个分布式共享内存表，按指定分区方案，将数据存储在不同在节点上。该函数只能在数据节点/计算节点执行。\n\n按全局分区方案将分布式共享内存表的数据分散地存储在不同节点（数据节点/计算节点）的内存中。每个节点最多只能存放一个分区的数据。分布式共享内存表支持并行读写，因此，它适用于需要对内存表进行分布式计算的场景。\n\n分布式共享内存表的分区分为两级：\n\n* 第一级为全局分区。全局分区可以将内存表的数据按照分区存放在不同的节点上。\n* 第二级为局部分区（可选配置）。局部分区对存储在单个节点内的分区数据进行再分区。\n\n若同时配置了全局分区和局部分区，等同于对分布式共享内存表进行了组合分区。\n\n**Note:**\n\n* 仅支持在集群模式下创建分布式共享内存表。\n* 全局分区的数量必须不小于2，且不能超过数据节点和计算节点总数。\n* 其它节点访问分布式共享内存表前，需要执行 [loadDistributedInMemoryTable](https://docs.dolphindb.cn/zh/funcs/l/loadDistributedInMemoryTable.html) 函数加载表。\n* 通过命令 [dropDistributedInMemoryTable](https://docs.dolphindb.cn/zh/funcs/d/dropDistributedInMemoryTable.html) 删除分布式共享内存表。\n* 分布式共享内存表的操作暂不支持事务。\n\n#### 参数\n\n**tableName** 字符串标量，表示分布式共享内存表的名称。\n\n**colNames** 字符串向量，用于指定表的列名。\n\n**colTypes** 由数据类型组成的向量，用于指定 *colNames* 各列的类型。\n\n**globalPartitionType** 必选参数，表示集群全局的分区类型，仅支持范围分区（RANGE），哈希分区（HASH），数值分区（VALUE），列表分区（LIST）。\n\n**globalPartitionScheme** 必选参数，表示集群全局的分区方案。\n\n分区类型及对应的分区方案见下表：\n\n| 分区类型 | 分区符号  | 分区方案                           |\n| ---- | ----- | ------------------------------ |\n| 范围分区 | RANGE | 向量。向量的任意两个相邻元素定义分区的范围。         |\n| 哈希分区 | HASH  | 元组。第一个元素是分区列的数据类型，第二个元素是分区的数量。 |\n| 值分区  | VALUE | 向量。向量的每个元素定义了一个分区。             |\n| 列表分区 | LIST  | 向量。向量的每个元素定义了一个分区。             |\n\n**globalPartitionColumn** 必选参数，字符串标量，表示集群全局的分区列。\n\n以上参数对应整个集群的分区配置，分布式共享内存表将按照上述分区方案将数据分区后存储到各个节点。各个节点的数据可以通过以下参数，进行节点内部的二次分区。\n\n**localPartitionType** 可选参数，表示节点内部的分区类型，仅支持范围分区（RANGE），哈希分区（HASH），数值分区（VALUE），列表分区（LIST）。\n\n**localPartitionScheme** 可选参数，表示节点内部的分区方案。\n\n**localPartitionColumn** 可选参数，字符串标量，表示节点内部的分区列。\n\n#### 例子\n\n* 创建分布式共享内存表\n\n  本例的集群拥有两个数据节点 node1 和 node2，在 node1 上创建一个分布式共享内存表。因为分区的数量不能超过数据节点和计算节点数总和，建议进行 HASH 分区。\n\n  ```\n  pt = createDistributedInMemoryTable(`dt, `time`id`value, `DATETIME`INT`LONG, HASH, [INT, 2],`id)\n  ```\n\n* 加载分布式共享内存表\n\n  在 node2 上加载分布式共享内存表，并插入数据。\n\n  ```\n  time = take(2021.08.20 00:00:00..2021.08.30 00:00:00, 40);\n  id = 0..39;\n  value = rand(100, 40);\n  tmp = table(time, id, value);\n\n  pt = loadDistributedInMemoryTable(`dt)\n  pt.append!(tmp);\n\n  select * from pt;\n  ```\n\n* 查看分布式共享内存表是否存在。\n\n  ```\n  objs(true)\n  ```\n\n* 删除分布式共享内存表\n\n  ```\n  dropDistributedInMemoryTable(`dt)\n  ```\n"
    },
    "createDualOwnershipReactiveStateEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createDualOwnershipReactiveStateEngine.html",
        "signatures": [
            {
                "full": "createDualOwnershipReactiveStateEngine(name, metrics1, metrics2, dummyTable, outputTable, keyColumn1, keyColumn2, [snapshotDir], [snapshotIntervalInMsgCount], [keyPurgeFilter1], [keyPurgeFilter2], [keyPurgeFreqInSecond=0], [raftGroup], [outputHandler=NULL], [msgAsTable=false])",
                "name": "createDualOwnershipReactiveStateEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics1",
                        "name": "metrics1"
                    },
                    {
                        "full": "metrics2",
                        "name": "metrics2"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "keyColumn1",
                        "name": "keyColumn1"
                    },
                    {
                        "full": "keyColumn2",
                        "name": "keyColumn2"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFilter1]",
                        "name": "keyPurgeFilter1",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFilter2]",
                        "name": "keyPurgeFilter2",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSecond=0]",
                        "name": "keyPurgeFreqInSecond",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createDualOwnershipReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createDualOwnershipReactiveStateEngine.html)\n\n\n\n#### 语法\n\ncreateDualOwnershipReactiveStateEngine(name, metrics1, metrics2, dummyTable, outputTable, keyColumn1, keyColumn2, \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[keyPurgeFilter1], \\[keyPurgeFilter2], \\[keyPurgeFreqInSecond=0], \\[raftGroup], \\[outputHandler=NULL], \\[msgAsTable=false])\n\n#### 详情\n\nDual Ownership Reactive State Engine 是对响应式状态引擎的扩展，支持对同一张流数据表指定两种不同的分组方式分别应用不同的指标进行并行计算。与响应式状态级联实现相比，该函数能极大地提升计算性能。\n\n**Note:** 该引擎输出和输入顺序保持一致，即内部强制使 *keepOrder* = True。\n\n#### 参数\n\n`createDualOwnershipReactiveStateEngine` 与 [createReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createReactiveStateEngine.html) 参数基本一致，这里仅介绍有区别的参数：\n\n对 *keyColumn1* 分组后的数据按照 *metrics1* 进行计算，分组数据的清条件则由参数 *keyPurgeFilter1* 设置。\n\n对 *keyColumn2* 分组后的数据按照 *metrics2* 进行计算，分组数据的清条件则由参数 *keyPurgeFilter2* 设置。\n\n**outputTable** 结果的输出表，可以是内存表或者分布式表。使用 `createDualOwnershipReactiveStateEngine` 函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。\n\n输出表各列的顺序如下：\n\n1. 分组列。输出表的前几列为 *keyColumn1* 和 *keyColumn2* 的公共列，然后依次为 *keyColumn1* 的非公共列和 *keyColumn2* 的非公共列。\n2. 计算结果列。包含 *metrics1* 的计算结果列，*metrics2*的计算结果列。\n\n**outputHandler** 一元函数。设置此参数时，引擎计算结束后，不再将计算结果写到输出表，而是会调用此函数处理计算结果。默认值为 NULL，表示仍将结果写到输出表。\n\n**msgAsTable** 布尔标量，表示在设置了参数 outputHandler 时，将引擎的计算结果以表的结构调用函数。默认值为 false，此时将计算结果的每一列作为元素组成元组。\n\n#### 例子\n\n```\nshare streamTable(1:0, `date`time`sym`market`price`qty, [DATE, TIME, SYMBOL, CHAR, DOUBLE, INT]) as trades\nshare table(100:0, `date`sym`market`factor1`factor2, [DATE, SYMBOL, CHAR, DOUBLE, DOUBLE]) as outputTable\ndors = createDualOwnershipReactiveStateEngine(name=\"test\", metrics1=<mfirst(price, 3)>, metrics2=<mmax(price, 3)>, dummyTable=trades, outputTable=outputTable, keyColumn1=`date`sym, keyColumn2=`date`market)\ntmp = table(1:0, `date`time`sym`market`price`qty, [DATE, TIME, SYMBOL, CHAR, DOUBLE, INT])\nsubscribeTable(tableName=`trades, actionName=\"test\",msgAsTable=true, handler=tableInsert{dors})\ninsert into tmp values(2012.01.01, 09:00:00.030, `a, 'B', 10.65, 1500)\ninsert into tmp values(2012.01.01, 09:00:00.030, `a, 'B', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.031, `b, 'A', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.031, `a, 'B', 10.65, 1500)\ninsert into tmp values(2012.01.01, 09:00:00.031, `a, 'A', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.033, `b, 'B', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.033, `a, 'A', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.034, `b, 'A', 10.59, 2500)\ninsert into tmp values(2012.01.01, 09:00:00.034, `b, 'A', 10.22, 1200)\ninsert into tmp values(2012.01.01, 09:00:00.035, `a, 'A', 11.0, 2500)\ninsert into tmp values(2012.01.02, 09:00:00.031, `b, 'A', 10.22, 1200)\ninsert into tmp values(2012.01.02, 09:00:00.032, `a, 'B', 11.0, 2500)\ninsert into tmp values(2012.01.02, 09:00:00.032, `b, 'B', 15.6, 1300)\ninsert into tmp values(2012.01.02, 09:00:00.040, `c, 'B', 13.2, 2000)\ntrades.append!(tmp)\nselect * from outputTable\n```\n\n| date       | sym | market | factor1 | factor2 |\n| ---------- | --- | ------ | ------- | ------- |\n| 2012.01.01 | a   | 'B'    |         |         |\n| 2012.01.01 | a   | 'B'    |         |         |\n| 2012.01.01 | b   | 'A'    |         |         |\n| 2012.01.01 | a   | 'B'    | 10.65   | 10.65   |\n| 2012.01.01 | a   | 'A'    | 10.59   |         |\n| 2012.01.01 | b   | 'B'    |         | 10.65   |\n| 2012.01.01 | a   | 'A'    | 10.65   | 10.59   |\n| 2012.01.01 | b   | 'A'    | 10.59   | 10.59   |\n| 2012.01.01 | b   | 'A'    | 10.59   | 10.59   |\n| 2012.01.01 | a   | 'A'    | 10.59   | 11      |\n| 2012.01.02 | b   | 'A'    |         |         |\n| 2012.01.02 | a   | 'B'    |         |         |\n| 2012.01.02 | b   | 'B'    |         |         |\n| 2012.01.02 | c   | 'B'    |         | 15.6    |\n\n```\nunsubscribeTable(tableName=`trades, actionName=\"test\")\nundef(`trades,SHARED)\ndropStreamEngine(\"test\")\n```\n"
    },
    "createEqualJoinEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createEqualJoinEngine.html",
        "signatures": [
            {
                "full": "createEquiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, timeColumn, [garbageSize=5000], [maxDelayedTime])",
                "name": "createEquiJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[garbageSize=5000]",
                        "name": "garbageSize",
                        "optional": true,
                        "default": "5000"
                    },
                    {
                        "full": "[maxDelayedTime]",
                        "name": "maxDelayedTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createEqualJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createEqualJoinEngine.html)\n\n是 [createEquiJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createEquiJoinEngine.html) 的别名。\n\n\n以下是 `createEquiJoinEngine` 函数的文档：\n### [createEquiJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createEquiJoinEngine.html)\n\n\n\n#### 语法\n\ncreateEquiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, timeColumn, \\[garbageSize=5000], \\[maxDelayedTime])\n\n别名：createEqualJoinEngine\n\n#### 详情\n\n创建流数据等值连接引擎。返回一个左、右两表 equi join 后的表对象。注入等值连接引擎的左、右两表将以 *matchingColumn* + *timeColumn* 作为连接列，返回两表中连接字段相等的行。\n\n更多流数据引擎的应用场景说明可以参考 [内置多数据源流式关联引擎](https://docs.dolphindb.cn/zh/stream/str_join_engine.html)。\n\n#### 计算规则\n\n* 每次数据注入引擎左表时，会在右表中查找与连接列字段相匹配的记录，若找到，则将两表匹配的记录 join 后，根据 *metrics* 给出的因子进行计算并输出。\n* 每次数据注入引擎右表时，亦会做同样操作。\n\n#### 参数\n\nequi join 引擎的部分参数和 asof join 引擎相同，请参照 [createAsofJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createAsofJoinEngine.html) 中参数介绍。下面介绍不同的参数：\n\n**name** 字符串标量，表示 equi join 引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**timeColumn** 字符串标量或向量。用于指定 *leftTable* 和 *rightTable* 中时间列的名称。两表的时间列名称可以不同，但数据类型需保持一致。当 *leftTable* 和 *rightTable* 时间列名称相同时，*timeColumn* 是字符串标量，否则，*timeColumn* 是长度为2的字符串向量。\n\n**garbageSize** 可选参数，正整数，默认值是 5,000（单位为行）。当内存中历史数据行数超过 *garbageSize* 时，会清理本次计算不需要的历史数据。\n\n满足以下条件的数据才会被清理：\n\n1. 历史数据中已经 join 并输出的数据；\n2. 历史数据未发生 join 的数据，但其时间戳与 *leftTable* 或 *rightTable* 收到的最新数据的时间戳的差值大于 *maxDelayedTime*。\n\n**maxDelayedTime** 可选参数，正整数，单位同 *timeColumn* 精度一致，默认值为 3 秒。该参数仅在达到 *garbageSize* 清理条件时才会起效，表示引擎内能够保留最新多长时间的数据。详情参考上述清理条件 2。不建议设置 *maxDelayedTime* 值设置过小，否则可能导致一些需关联却没及时关联的数据被清理。\n\n#### 例子\n\n```\nshare streamTable(1:0, `time`sym`price, [SECOND, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [SECOND, SYMBOL, DOUBLE]) as rightTable\nshare table(100:0, `time`sym`price`val`total, [SECOND, SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\nejEngine=createEquiJoinEngine(\"test1\", leftTable, rightTable, output, [<price>, <val>, <price*val>], `sym, `time)\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{ejEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{ejEngine, false}, msgAsTable=true)\n\ntmp1=table(13:30:10+1..20 as time, take(`AAPL, 10) join take(`IBM, 10) as sym, double(1..20) as price)\nleftTable.append!(tmp1)\ntmp2=table(13:30:10+1..20 as time, take(`AAPL, 10) join take(`IBM, 10) as sym, double(50..31) as val)\nrightTable.append!(tmp2)\n```\n\n下例中时间列类型为 TIMESTAMP，若不设置 *maxDelayedTime*，取默认值3000ms(3s)。\n\n```\nshare streamTable(5000000:0, `timestamp`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(5000000:0, `timestamp`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\nshare table(5000000:0, `timestamp`sym`price`val`total`diff`ratio, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as output\nejEngine=createEquiJoinEngine(\"test1\", leftTable, rightTable, output, <[price, val, price+val, price-val, price/val]>, `sym, `timestamp, 5000)\ntopic1=subscribeTable(tableName=\"leftTable\", actionName=\"writeLeft\", offset=0, handler=appendForJoin{ejEngine, true}, batchSize=10000, throttle=1)\ntopic2=subscribeTable(tableName=\"rightTable\", actionName=\"writeRight\", offset=0, handler=appendForJoin{ejEngine, false}, batchSize=10000, throttle=1)\ndef writeLeftTable(mutable tb){\n   batch = 1000\n   for(i in 1..300){\n           tmp = table(batch:batch, `timestamp`sym`price, [TIMESTAMP, SYMBOL, DOUBLE])\n           tmp[`timestamp]=take(2012.01.01T00:00:00.000+i, batch)\n           tmp[`sym]=shuffle(\"A\"+string(1..batch))\n           tmp[`price]=rand(100.0, batch)\n           tb.append!(tmp)\n   }\n}\n\ndef writeRightTable(mutable tb){\n   batch = 500\n   for(i in 1..200){\n           tmp = table(batch:batch, `timestamp`sym`val, [TIMESTAMP, SYMBOL, DOUBLE])\n           tmp[`timestamp]=take(2012.01.01T00:00:00.000+i, batch)\n           tmp[`sym]=shuffle(\"A\"+string(1..batch))\n           tmp[`val]=rand(100.0, batch)\n           tb.append!(tmp)\n   }\n}\n\njob1 = submitJob(\"writeLeft\", \"\", writeLeftTable, leftTable)\njob2 = submitJob(\"writeRight\", \"\", writeRightTable, rightTable)\n\nselect count(*) from output order by sym, timestamp\n// output: 100000\n```\n"
    },
    "createEquiJoinEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createEquiJoinEngine.html",
        "signatures": [
            {
                "full": "createEquiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, timeColumn, [garbageSize=5000], [maxDelayedTime])",
                "name": "createEquiJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[garbageSize=5000]",
                        "name": "garbageSize",
                        "optional": true,
                        "default": "5000"
                    },
                    {
                        "full": "[maxDelayedTime]",
                        "name": "maxDelayedTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createEquiJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createEquiJoinEngine.html)\n\n\n\n#### 语法\n\ncreateEquiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, timeColumn, \\[garbageSize=5000], \\[maxDelayedTime])\n\n别名：createEqualJoinEngine\n\n#### 详情\n\n创建流数据等值连接引擎。返回一个左、右两表 equi join 后的表对象。注入等值连接引擎的左、右两表将以 *matchingColumn* + *timeColumn* 作为连接列，返回两表中连接字段相等的行。\n\n更多流数据引擎的应用场景说明可以参考 [内置多数据源流式关联引擎](https://docs.dolphindb.cn/zh/stream/str_join_engine.html)。\n\n#### 计算规则\n\n* 每次数据注入引擎左表时，会在右表中查找与连接列字段相匹配的记录，若找到，则将两表匹配的记录 join 后，根据 *metrics* 给出的因子进行计算并输出。\n* 每次数据注入引擎右表时，亦会做同样操作。\n\n#### 参数\n\nequi join 引擎的部分参数和 asof join 引擎相同，请参照 [createAsofJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createAsofJoinEngine.html) 中参数介绍。下面介绍不同的参数：\n\n**name** 字符串标量，表示 equi join 引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**timeColumn** 字符串标量或向量。用于指定 *leftTable* 和 *rightTable* 中时间列的名称。两表的时间列名称可以不同，但数据类型需保持一致。当 *leftTable* 和 *rightTable* 时间列名称相同时，*timeColumn* 是字符串标量，否则，*timeColumn* 是长度为2的字符串向量。\n\n**garbageSize** 可选参数，正整数，默认值是 5,000（单位为行）。当内存中历史数据行数超过 *garbageSize* 时，会清理本次计算不需要的历史数据。\n\n满足以下条件的数据才会被清理：\n\n1. 历史数据中已经 join 并输出的数据；\n2. 历史数据未发生 join 的数据，但其时间戳与 *leftTable* 或 *rightTable* 收到的最新数据的时间戳的差值大于 *maxDelayedTime*。\n\n**maxDelayedTime** 可选参数，正整数，单位同 *timeColumn* 精度一致，默认值为 3 秒。该参数仅在达到 *garbageSize* 清理条件时才会起效，表示引擎内能够保留最新多长时间的数据。详情参考上述清理条件 2。不建议设置 *maxDelayedTime* 值设置过小，否则可能导致一些需关联却没及时关联的数据被清理。\n\n#### 例子\n\n```\nshare streamTable(1:0, `time`sym`price, [SECOND, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [SECOND, SYMBOL, DOUBLE]) as rightTable\nshare table(100:0, `time`sym`price`val`total, [SECOND, SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\nejEngine=createEquiJoinEngine(\"test1\", leftTable, rightTable, output, [<price>, <val>, <price*val>], `sym, `time)\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{ejEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{ejEngine, false}, msgAsTable=true)\n\ntmp1=table(13:30:10+1..20 as time, take(`AAPL, 10) join take(`IBM, 10) as sym, double(1..20) as price)\nleftTable.append!(tmp1)\ntmp2=table(13:30:10+1..20 as time, take(`AAPL, 10) join take(`IBM, 10) as sym, double(50..31) as val)\nrightTable.append!(tmp2)\n```\n\n下例中时间列类型为 TIMESTAMP，若不设置 *maxDelayedTime*，取默认值3000ms(3s)。\n\n```\nshare streamTable(5000000:0, `timestamp`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(5000000:0, `timestamp`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\nshare table(5000000:0, `timestamp`sym`price`val`total`diff`ratio, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as output\nejEngine=createEquiJoinEngine(\"test1\", leftTable, rightTable, output, <[price, val, price+val, price-val, price/val]>, `sym, `timestamp, 5000)\ntopic1=subscribeTable(tableName=\"leftTable\", actionName=\"writeLeft\", offset=0, handler=appendForJoin{ejEngine, true}, batchSize=10000, throttle=1)\ntopic2=subscribeTable(tableName=\"rightTable\", actionName=\"writeRight\", offset=0, handler=appendForJoin{ejEngine, false}, batchSize=10000, throttle=1)\ndef writeLeftTable(mutable tb){\n   batch = 1000\n   for(i in 1..300){\n           tmp = table(batch:batch, `timestamp`sym`price, [TIMESTAMP, SYMBOL, DOUBLE])\n           tmp[`timestamp]=take(2012.01.01T00:00:00.000+i, batch)\n           tmp[`sym]=shuffle(\"A\"+string(1..batch))\n           tmp[`price]=rand(100.0, batch)\n           tb.append!(tmp)\n   }\n}\n\ndef writeRightTable(mutable tb){\n   batch = 500\n   for(i in 1..200){\n           tmp = table(batch:batch, `timestamp`sym`val, [TIMESTAMP, SYMBOL, DOUBLE])\n           tmp[`timestamp]=take(2012.01.01T00:00:00.000+i, batch)\n           tmp[`sym]=shuffle(\"A\"+string(1..batch))\n           tmp[`val]=rand(100.0, batch)\n           tb.append!(tmp)\n   }\n}\n\njob1 = submitJob(\"writeLeft\", \"\", writeLeftTable, leftTable)\njob2 = submitJob(\"writeRight\", \"\", writeRightTable, rightTable)\n\nselect count(*) from output order by sym, timestamp\n// output: 100000\n```\n"
    },
    "createGPLearnEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/creategplearnengine.html",
        "signatures": [
            {
                "full": "createGPLearnEngine(trainData, targetData,[groupCol=''], [populationSize=1000], [generations=20], [tournamentSize=20], [stoppingCriteria=0.0], [constRange], [windowRange], [initDepth], [initMethod='half'], [initProgram=''], [functionSet], [maxSamples=1.0], [fitnessFunc='mse'], [parsimonyCoefficient=0.001], [crossoverMutationProb=0.9], [subtreeMutationProb=0.01], [hoistMutationProb=0.01], [pointMutationProb=0.01], [eliteCount =0], [restrictDepth=false], [deviceId=0], [seed], [verbose=true], [minimize=true], [useAbsFit=true])",
                "name": "createGPLearnEngine",
                "parameters": [
                    {
                        "full": "trainData",
                        "name": "trainData"
                    },
                    {
                        "full": "targetData",
                        "name": "targetData"
                    },
                    {
                        "full": "[groupCol='']",
                        "name": "groupCol",
                        "optional": true,
                        "default": "''"
                    },
                    {
                        "full": "[populationSize=1000]",
                        "name": "populationSize",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[generations=20]",
                        "name": "generations",
                        "optional": true,
                        "default": "20"
                    },
                    {
                        "full": "[tournamentSize=20]",
                        "name": "tournamentSize",
                        "optional": true,
                        "default": "20"
                    },
                    {
                        "full": "[stoppingCriteria=0.0]",
                        "name": "stoppingCriteria",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[constRange]",
                        "name": "constRange",
                        "optional": true
                    },
                    {
                        "full": "[windowRange]",
                        "name": "windowRange",
                        "optional": true
                    },
                    {
                        "full": "[initDepth]",
                        "name": "initDepth",
                        "optional": true
                    },
                    {
                        "full": "[initMethod='half']",
                        "name": "initMethod",
                        "optional": true,
                        "default": "'half'"
                    },
                    {
                        "full": "[initProgram='']",
                        "name": "initProgram",
                        "optional": true,
                        "default": "''"
                    },
                    {
                        "full": "[functionSet]",
                        "name": "functionSet",
                        "optional": true
                    },
                    {
                        "full": "[maxSamples=1.0]",
                        "name": "maxSamples",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[fitnessFunc='mse']",
                        "name": "fitnessFunc",
                        "optional": true,
                        "default": "'mse'"
                    },
                    {
                        "full": "[parsimonyCoefficient=0.001]",
                        "name": "parsimonyCoefficient",
                        "optional": true,
                        "default": "0.001"
                    },
                    {
                        "full": "[crossoverMutationProb=0.9]",
                        "name": "crossoverMutationProb",
                        "optional": true,
                        "default": "0.9"
                    },
                    {
                        "full": "[subtreeMutationProb=0.01]",
                        "name": "subtreeMutationProb",
                        "optional": true,
                        "default": "0.01"
                    },
                    {
                        "full": "[hoistMutationProb=0.01]",
                        "name": "hoistMutationProb",
                        "optional": true,
                        "default": "0.01"
                    },
                    {
                        "full": "[pointMutationProb=0.01]",
                        "name": "pointMutationProb",
                        "optional": true,
                        "default": "0.01"
                    },
                    {
                        "full": "[eliteCount =0]",
                        "name": "[eliteCount =0]"
                    },
                    {
                        "full": "[restrictDepth=false]",
                        "name": "restrictDepth",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[deviceId=0]",
                        "name": "deviceId",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[seed]",
                        "name": "seed",
                        "optional": true
                    },
                    {
                        "full": "[verbose=true]",
                        "name": "verbose",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[minimize=true]",
                        "name": "minimize",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[useAbsFit=true]",
                        "name": "useAbsFit",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [createGPLearnEngine](https://docs.dolphindb.cn/zh/funcs/c/creategplearnengine.html)\n\n#### 语法\n\ncreateGPLearnEngine(trainData, targetData,\\[groupCol=''], \\[populationSize=1000], \\[generations=20], \\[tournamentSize=20], \\[stoppingCriteria=0.0], \\[constRange], \\[windowRange], \\[initDepth], \\[initMethod='half'], \\[initProgram=''], \\[functionSet], \\[maxSamples=1.0], \\[fitnessFunc='mse'], \\[parsimonyCoefficient=0.001], \\[crossoverMutationProb=0.9], \\[subtreeMutationProb=0.01], \\[hoistMutationProb=0.01], \\[pointMutationProb=0.01], \\[eliteCount =0], \\[restrictDepth=false], \\[deviceId=0], \\[seed], \\[verbose=true], \\[minimize=true], \\[useAbsFit=true])\n\n**Note:**\n\n社区版 License 暂不支持该引擎，如需使用此功能，请联系技术支持。\n\n#### 详情\n\n创建一个 GPLearn 引擎用于训练和预测。\n\n#### 参数\n\n* **trainData** 是 FLOAT 或 DOUBLE 类型的表，表示用于训练的数据。\n\n* **targetData**是 FLOAT 或 DOUBLE 类型的向量，需要预测的数据。targetData 与 trainData 的数据类型必须一致。\n\n* **groupCol** 字符串标量或向量，表示分组列名，可将数据按照此参数指定的列进行分组后计算。默认为空，表示无分组列。\n\n  **Note:** 分组列本身不会参与计算。\n\n* **populationSize** 整型标量，表示每代公式的数量， 默认值为 1000。\n\n* **generations** 整型标量，表示进化的代数，默认为 20。\n\n* **tournamentSize** 整型标量，表示生成下一代公式时，参与竞争的公式数量，默认为 20。\n\n* **stoppingCriteria** 浮点型标量，表示终止迭代的适应度阈值。当适应度小于等于此阈值时，会提前结束进化。默认为 0，表示达到进化的代数之前不会停止。\n\n* **constRange** 可以是 0 或长度为 2 的浮点型向量，表示公式中包含的常量的范围，默认为 \\[-1.0, 1.0]。\n  * 为 0 时，公式中将不会包含常量。\n  * 为向量时，向量的两个元素代表闭区间边界。\n\n* **windowRange** 整型向量，表示滑动窗口函数的窗口大小取值范围，滑动窗口的大小是此向量中的随机值，默认为 \\[2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 30, 7, 14, 21, 48, 35, 42]。\n\n* **initDepth** 长度为 2 的整型向量，表示初始化公式树的深度范围，默认是 \\[2, 6]。\n\n* **initMethod** 字符串类型标量，用于指定初始化公式树的方法，默认为 half 。\n  * grow 公式树中的每一个节点，都是从函数、常量和变量中随机选取\n  * full 只有公式树的叶子节点可以是常量或变量\n  * half 公式树的子树，将会有50%/50%的概率通过 grow/full 生成\n\n* **initProgram**元代码或元代码的元组，默认为空。指定此参数，将会用指定的元代码初始化种群。例如 `<mavg(price, 10)>` ，其中 mavg 是 GPLearn 已经支持的函数， price 是 *trainData* 中的列。\n\n* **functionSet** 初始化公式树和进化时选择的算子，为字符串类型的向量。默认值为空，表示可以使用所有支持的算子。支持的算子列表详见附录。\n\n* **maxSamples** 浮点型标量，表示参与 fitnessFunc 计算的输入数据的比例，取值范围是 \\[0,1]，默认是 1.0 。\n\n* **fitnessFunc** 用户自定义的 FUNCTIONDEF 类型标量，或字符串标量，代表适应度函数。默认是 'mse'，字符串可选值为：\n  * 'mse'，均方误差。\n  * 'rmse'，均方根误差。\n  * 'pearson'，皮尔逊矩阵相关系数。\n  * 'spearmanr'，Spearmanr 排序相关系数。\n  * 'mae'，平均绝对误差。\n\n* **parsimonyCoefficient** 浮点型标量，表示节俭系数。随着进化次数的增加，公式会越来越膨胀，失去可解释性，节俭系数会惩罚过长的公式。默认为 0.0 。\n\n* **crossoverMutationProb** 浮点型标量，表示 crossover 的概率，默认是 0.9 。\n\n* **subtreeMutationProb** 浮点型标量，表示 subtree 变异的概率，默认是 0.01 。\n\n* **hoistMutationProb**浮点型标量，表示 hoist 变异的概率，默认是 0.01 。\n\n* **pointMutationProb**浮点型标量，表示 point 变异的概率，默认是 0.01 。\n\n**Note:** 所有变异概率之和必须小于等于 1\n\n* **eliteCount** INT 类型标量，代表精英数量，默认为 0。适应度最优的 eliteCount 个公式，会作为精英直接传递给下一代。\n* **restrictDepth**布尔类型标量，代表是否严格限制公式的长度，默认为 false。设置为 true 时，公式的深度不会超过 initDepth 的上限。\n* **deviceId** INT类型的标量或向量。当前机器拥有多卡时，可以指定使用的设备 ID，默认为 0 。\n* **seed** 整型标量，表示训练时使用的种子。\n* **verbose** BOOL 类型标量，设置是否输出训练时的信息，默认是 true。\n* **minimize** BOOL 类型标量，设置是否向适应度最小化的方向进化。默认是 true，则认为适应度越小，公式越优秀；反之则认为适应度越大，公式越优秀。\n* **useAbsFit**在计算适应度时是否取绝对值。可选参数，默认为 true，表示取绝对值。设置为 false 时，当 *fitnessFunc* 设置为 'pearson'，'spearmanr' 或 `corr`时，不取绝对值。\n\n#### 例子\n\n参考：[Shark GPLearn 快速上手](https://docs.dolphindb.cn/zh/tutorials/gplearn.html)\n\n\n\n**Related information**\n\n[Shark GPLearn 快速上手](https://docs.dolphindb.cn/zh/tutorials/gplearn.html)\n"
    },
    "createGroup": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createGroup.html",
        "signatures": [
            {
                "full": "createGroup(groupId, [userIds])",
                "name": "createGroup",
                "parameters": [
                    {
                        "full": "groupId",
                        "name": "groupId"
                    },
                    {
                        "full": "[userIds]",
                        "name": "userIds",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createGroup](https://docs.dolphindb.cn/zh/funcs/c/createGroup.html)\n\n\n\n#### 语法\n\ncreateGroup(groupId, \\[userIds])\n\n#### 参数\n\n**groupId** 是表示组名的字符串。\n\n**userId** 是表示组成员的字符串标量或向量。\n\n#### 详情\n\n创建组。\n\n组中的用户必须是已经创建了的用户。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n创建组 \"production\"，并且把用户 \"JohnSmith\" 添加到该组。\n\n```\ncreateGroup(`production, `JohnSmith);\n```\n"
    },
    "createIMOLTPTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createIMOLTPTable.html",
        "signatures": [
            {
                "full": "createIMOLTPTable(dbHandle, table, tableName, primaryKey, [secondaryKey], [uniqueFlag])",
                "name": "createIMOLTPTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "primaryKey",
                        "name": "primaryKey"
                    },
                    {
                        "full": "[secondaryKey]",
                        "name": "secondaryKey",
                        "optional": true
                    },
                    {
                        "full": "[uniqueFlag]",
                        "name": "uniqueFlag",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createIMOLTPTable](https://docs.dolphindb.cn/zh/funcs/c/createIMOLTPTable.html)\n\n\n\n#### 语法\n\ncreateIMOLTPTable(dbHandle, table, tableName, primaryKey, \\[secondaryKey], \\[uniqueFlag])\n\n#### 参数\n\n**dbHandle**函数 [database](https://docs.dolphindb.cn/zh/funcs/d/database.html) 返回的 IMOLTP 数据库句柄。\n\n**table**一个表，系统将根据该表的结构在数据库中创建一个空的 IMOLTP 表。\n\n**tableName**字符串标量，表示 IMOLTP 表的名字。\n\n**primaryKey**字符串标量或向量，表示主键索引的键包含的字段（字段即为列名）。为标量时，表示只包含一个字段；为向量时，表示包含多个字段。\n\n**secondaryKey**可选参数，字符串标量或向量，表示每一个二级索引的键包含的字段。\n\n**uniqueFlag**可选参数，布尔类型标量或向量，表示每一个二级索引是否是唯一的：\n\n* uniqueFlag 为标量或 size 为 1 的向量，表示只有一个二级索引。此时 secondaryKey 可以为字符串标量（表示一个字段）或向量（表示多个字段）。\n* uniqueFlag 为长度大于 1 的向量，表示有多个二级索引。此时 secondaryKey 的长度必须与 uniqueFlag 相同，secondaryKey 的每一个元素表示一个键。\n\n#### 详情\n\n在 IMOLTP 数据库中创建 IMOLTP 表。\n\n#### 例子\n\n创建 IMOLTP 数据库\n\n```\ndbName = \"oltp://test_imoltp\"\ndb = database(directory=dbName, partitionType=VALUE, partitionScheme=1..100, engine=\"IMOLTP\")\n```\n\n创建表 test\\_table\\_1，以 id 为主键，没有二级索引\n\n```\npt1 = createIMOLTPTable(\n    dbHandle=db,\n    table=table(1:0, [\"id\", \"val1\", \"val2\", \"sym\"], [LONG, INT, LONG, STRING]),\n    tableName=\"test_table_1\",\n    primaryKey=`id\n)\n```\n\n创建表 test\\_table\\_2，以 id,sym 为主键，没有二级索引\n\n```\npt2 = createIMOLTPTable(\n    dbHandle=db,\n    table=table(1:0, [\"id\", \"val1\", \"val2\", \"sym\"], [LONG, INT, LONG, STRING]),\n    tableName=\"test_table_2\",\n    primaryKey=`id`sym,\n    secondaryKey=`val2`sym,\n    uniqueFlag=true\n)\n```\n\n创建表 test\\_table\\_3，以 id 为主键，有一个非 unique 二级索引：以 val1 为键；一个 unique 二级索引：以 sym 为键\n\n```\npt3 = createIMOLTPTable(\n    dbHandle=db,\n    table=table(1:0, [\"id\", \"val1\", \"val2\", \"sym\"], [LONG, INT, LONG, STRING]),\n    tableName=\"test_table_3\",\n    primaryKey=`id,\n    secondaryKey=[`val1, `sym],\n    uniqueFlag=[false, true]\n)\n```\n"
    },
    "createIPCInMemoryTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createIPCInMemoryTable.html",
        "signatures": [
            {
                "full": "createIPCInMemoryTable(size, tableName, columnNames, columnTypes)",
                "name": "createIPCInMemoryTable",
                "parameters": [
                    {
                        "full": "size",
                        "name": "size"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "columnNames",
                        "name": "columnNames"
                    },
                    {
                        "full": "columnTypes",
                        "name": "columnTypes"
                    }
                ]
            }
        ],
        "markdown": "### [createIPCInMemoryTable](https://docs.dolphindb.cn/zh/funcs/c/createIPCInMemoryTable.html)\n\n\n\n#### 语法\n\ncreateIPCInMemoryTable(size, tableName, columnNames, columnTypes)\n\n#### 参数\n\n**size** 整数，表示 table 能缓存的记录数。该值必须大于 1,000,000，否则系统自动取 1,000,000。\n\n**tableName** 字符串，表示跨进程共享内存表的名称。\n\n**columnNames** 字符串向量，用于指定表的列名。\n\n**columnTypes** 向量，表示每列的数据类型。可使用表示数据类型的系统保留字或相应的字符串。\n\n#### 详情\n\n创建一个跨进程共享内存表的句柄。跨进程共享内存表通常作为流计算的输出表。在对时延要求极高的场景下，用户进程通过插件直接访问共享内存获取数据，极大减小了 TCP 等网络传输的时延。\n\n跨进程共享内存表通过共享内存（由操作系统管理）进行跨进程通信。共享内存表仅支持在同一物理机内共享，不支持在集群不同物理节点间进行共享。\n\n跨进程共享内存表支持读写，但不支持对跨进程共享内存表的表结构进行修改。向跨进程共享内存表写数据的方法，与普通内存表一致。若一次性插入的数据量大于共享内存，系统会抛出异常。\n\n* 读写机制：将写入共享内存的进程作为生产者，从共享内存中读取数据的进程作为消费者。一次写入的数据将作为一个整体，供一次读取消费，且读进程依次按顺序对写入的数据进行消费。例如：第一写入 100 条数据，第二次写入 200 条数据，则第一次会读到 100 条数据，第二次会读到第二批写入的 200 条数据，以此类推。读取数据时，共享内存表中的所有数据均已被消费，则读进程会被阻塞，直到有新写入的可消费数据时，才能将数据读出。\n\nDolphinDB 支持多进程并发写入共享内存表，以及在写入的同时进行读操作。但注意，只能同时存在一个读进程。参考上述读写机制，读取是一次性的，若不同进程并发读取，将会得到不同阶段写入的数据。\n\n**Note:** 此函数仅适用于 Linux 系统。\n\n#### 例子\n\n创建一个跨进程共享内存表，并作为流数据订阅的输出表。\n\n```\nshare streamTable(10000:0,`timestamp`temperature, [TIMESTAMP,DOUBLE]) as pubTable\nipc_t = createIPCInMemoryTable(1000000, \"ipc_table\", `timestamp`temperature, [TIMESTAMP, DOUBLE])\ndef shm_append(mutable table, msg) {\n   table.append!(msg)\n}\nsubscribeTable(tableName=\"pubTable\", actionName=\"act3\", offset=0, handler=shm_append{ipc_t}, msgAsTable=true)\n// 写入数据\n\nn = 200\ntimestamp = 2022.01.01T09:00:00.000 + 1..n\ntemp = 30 + rand(5.0,n)\n\ntableInsert(pubTable,timestamp,temp)\n```\n\n**Related information**\n\n[dropIPCInMemoryTable](https://docs.dolphindb.cn/zh/funcs/d/dropIPCInMemoryTable.html)\n\n[loadIPCInMemoryTable](https://docs.dolphindb.cn/zh/funcs/l/loadIPCInMemoryTable.html)\n"
    },
    "createLeftSemiJoinEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createLeftSemiJoinEngine.html",
        "signatures": [
            {
                "full": "createLeftSemiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, [garbageSize=5000], [updateRightTable=false])",
                "name": "createLeftSemiJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "[garbageSize=5000]",
                        "name": "garbageSize",
                        "optional": true,
                        "default": "5000"
                    },
                    {
                        "full": "[updateRightTable=false]",
                        "name": "updateRightTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createLeftSemiJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createLeftSemiJoinEngine.html)\n\n\n\n#### 语法\n\ncreateLeftSemiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, \\[garbageSize=5000], \\[updateRightTable=false])\n\n#### 详情\n\n创建流数据左半等值连接引擎，返回一个左、右表关联后的表对象。对于左表每一条数据，都去匹配右表相同 *matchingColumn* 的数据，若无匹配的右表记录，则不输出。若匹配多条右表记录，则由 *updateRightTable* 参数决定连接右表的第一条记录还是最新一条记录。\n\n**Note:** 右表根据 *updateRightTable* 指定的策略，同一 *matchingColumn* 只保留第一条或者最新一条数据，历史数据不再进行垃圾回收，因此用户需要控制 *matchingColumn* 的唯一值数量，否则可能会导致内存溢出。\n\n#### 参数\n\n**name** 表示流数据 left semi join 引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**leftTable** 表对象。可以不包含数据，但结构必须与订阅的流数据表相同。自 2.00.11 版本开始，该参数支持 array vector。\n\n**rightTable** 表对象。可以不包含数据，但结构必须与订阅的流数据表相同。自 2.00.11 版本开始，该参数支持 array vector。\n\n**outputTable** 为计算结果的输出表。在使用 `createLeftSemiJoinEngine` 函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。自 2.00.11 版本开始，引擎支持通过自定义聚合函数，将多个计算结果以 array vector 的形式输出，此时必须在该参数中指定对应列类型为 array vector。\n\n输出表的各列的顺序如下：\n\n1. 连接列。与 *matchingColumn* 中的列以及其顺序一致，可为多列。\n2. 计算结果列。可为多列。\n\n**metrics** 以元代码的格式表示计算指标，支持输入元组。有关元代码的更多信息可参考 [Metaprogramming](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n* 计算指标可以是一个或多个表达式、系统内置或用户自定义函数、一个常量标量/向量。当指定为常量向量时，对应的输出列必须设置为数组向量类型，例子参见 [createReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createReactiveStateEngine.html) 中的例4。\n* **metrics** 内支持调用具有多个返回值的函数，且必须指定列名，例如 \\<func(price) as \\`col1\\`col2>。\n\n  若在 *metrics* 指定了 *leftTable* 和 *rightTable* 中具有相同名称的列，默认取左表的列，可以通过 \"tableName.colName\" 指定该列来自哪个表。\n\n  **Note:** *metrics* 中使用的列名大小写不敏感，不需要与输入表的列名大小写保持一致。\n\n**matchingColumn** 表示连接列的字符串标量/向量或字符串向量组成的 tuple，支持 Integral, Temporal 或 Literal(UUID 除外)类型。\n\n*matchingColumn* 指定规则：\n\n1. 只有一个连接列。当左表和右表的连接列名相同时，*matchingColumn* 是一个字符串标量，否则是一个长度为 2 的 tuple。例如：左表连接列名为 sym，右表连接列名为 sym1，则 *matchingColumn* = \\[\\[\\`sym],\\[\\`sym1]]。\n2. 有多个连接列。当左表和右表的连接列名相同时，*matchingColumn* 是一个字符串向量，否则是一个长度为 2 的 tuple。例如：左表连接列名为 timestamp, sym，右表连接列名为 timestamp, sym1，则 *matchingColumn* = \\[\\[\\`timestamp, \\`sym], \\[\\`timestamp,\\`sym1]]。\n\n**garbageSize** 可选参数，正整数，默认值是 5,000（单位为行）。和其他连接引擎不同，该函数的 *garbageSize* 参数只用于清理左表的历史数据。当左表发生过 join 的记录数超过 *garbageSize* 时，系统会触发清理。\n\n**updateRightTable** 可选参数，布尔值，默认为 false，表示右表存在多条相同 *matchingColumn* 的记录时，是保留第一条（false）还是最新一条记录（true）。\n\n#### 例子\n\n```\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym1`vol, [TIMESTAMP, SYMBOL, INT]) as rightTable\n\nshare table(100:0, `time`sym`price`vol`total, [TIMESTAMP, SYMBOL, DOUBLE, INT, DOUBLE]) as output\nlsjEngine=createLeftSemiJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output,  metrics=<[price, vol,price*vol]>, matchingColumn=[[`time,`sym], [`time,`sym1]], updateRightTable=true)\n\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{lsjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{lsjEngine, false}, msgAsTable=true)\n\nv = [1, 5, 10, 15]\ntp1=table(2012.01.01T00:00:00.000+v as time, take(`AAPL, 4) as sym, rand(100,4) as price)\nleftTable.append!(tp1)\n\nv = [1, 1, 3, 4, 5, 5, 5, 15]\ntp2=table(2012.01.01T00:00:00.000+v as time, take(`AAPL, 8) as sym, rand(100,8) as vol)\nrightTable.append!(tp2)\n\nselect * from output\n```\n\n| time                    | sym  | price | vol | total |\n| ----------------------- | ---- | ----- | --- | ----- |\n| 2012.01.01T00:00:00.001 | AAPL | 44    | 76  | 3344  |\n| 2012.01.01T00:00:00.005 | AAPL | 15    | 64  | 960   |\n| 2012.01.01T00:00:00.015 | AAPL | 24    | 75  | 1800  |\n\n若要再次执行以上脚本，需要先删除引擎并取消订阅：\n\n```\ndropStreamEngine(\"test1\")\nlsjEngine=NULL\nunsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\")\nunsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\")\n```\n\n**Related information**\n\n[内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)\n"
    },
    "createLookupJoinEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createLookupJoinEngine.html",
        "signatures": [
            {
                "full": "createLookupJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, [rightTimeColumn], [checkTimes], [outputElapsedMicroseconds=false], [keepDuplicates=false])",
                "name": "createLookupJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "[rightTimeColumn]",
                        "name": "rightTimeColumn",
                        "optional": true
                    },
                    {
                        "full": "[checkTimes]",
                        "name": "checkTimes",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keepDuplicates=false]",
                        "name": "keepDuplicates",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createLookupJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createLookupJoinEngine.html)\n\n\n\n#### 语法\n\ncreateLookupJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, \\[rightTimeColumn], \\[checkTimes], \\[outputElapsedMicroseconds=false], \\[keepDuplicates=false])\n\n#### 详情\n\n创建流数据表的 lookup join 引擎，该引擎以 *matchingColumn* 作为连接列将两个流数据表进行实时 [leftjoin](https://docs.dolphindb.cn/zh/progr/sql/leftjoin.html)， 或者将流数据表和非流数据表进行 left join（此时需要定时刷新非流数据表）。lookup join 引擎常用于右表更新不频繁的场景（如保存了日频指标的维度表）。\n\n##### 工作机制\n\n1. 仅当左表有新数据流入时才会触发左、右表的 left join 输出。\n2. 当 *keepDuplicates*=false 时，引擎仅保留右表根据 *matchingColumn* 分组后各分组内的最新一条数据。当 *keepDuplicates*=true 时，引擎保留右表根据 *matchingColumn* 分组后各分组内的所有数据。当右表是订阅的流数据表时，数据流入右表的同时会更新数据； 若右表为内存表、维度表或元代码，系统会根据 *checkTimes* 定时刷新右表数据。\n\nlookup join 引擎与 asof join 引擎很相似，它们之间的区别如下：\n\n* lookup join 引擎输出表的第一列可以不是时间列，而 asof join 引擎输出表第一列必须是时间列。\n* lookup join 引擎当左表有新数据流入便会触发 join 输出，因此无需考虑数据延迟，也无需缓存左表数据。而 asof join 引擎，当指定 *timeColumn* 时，需要考虑左右表的数据延时。\n\n更多流数据引擎的应用场景说明可以参考 [内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)。\n\n#### 参数\n\n**name** 必选参数，表示流数据 lookup join 引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**leftTable** 表对象。可以不包含数据，但结构必须与订阅的流数据表相同。\n\n**rightTable** 表对象，可以是内存表、流数据表、维度表或 SQL 查询元代码（查询语句必须返回表 ）。请注意，如果 *rightTable* 没有被订阅，但 *rightTable* 会定期更新，则必须设置 *checkTimes* 来定时刷新右表数据。\n\n**outputTable** 必选参数，为计算结果的输出表。在使用 `createLookupJoinEngine` 函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。\n\n输出表的各列的顺序如下：\n\n1. 连接列。与 *matchingColumn* 中的列以及其顺序一致，可为多列。\n2. 计算结果列。可为多列。\n3. 耗时列。如果指定 *outputElapsedMicroseconds* = true，则指定一个 LONG 类型的列用于记录单次响应计算耗时（单位：微秒）。\n4. batchSize 列。如果指定 *outputElapsedMicroseconds* = true, 则指定一个INT类型的列，记录单次响应的数据条数。\n\n**metrics** 以元代码的格式表示计算指标，支持输入元组。有关元代码的更多信息可参考 [Metaprogramming](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n* 计算指标可以是一个或多个表达式、系统内置或用户自定义函数、一个常量标量/向量，但不能是聚合函数。当指定为常量向量时，对应的输出列必须设置为数组向量类型，例子参见 [createReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createReactiveStateEngine.html) 中的例4。\n* *metrics* 内支持调用具有多个返回值的函数，且必须指定列名，例如 \\<func(price) as \\`col1\\`col2>。\n* 若在 *metrics* 指定了 *leftTable* 和 *rightTable* 中具有相同名称的列，默认取左表的列，可以通过 \"tableName.colName\" 指定该列来自哪个表。\n\n  **Note:** *metrics* 中使用的列名大小写不敏感，不需要与输入表的列名大小写保持一致。\n\n**matchingColumn** 表示连接列的字符串标量/向量或字符串向量组成的 tuple，支持 Integral, Temporal 或 Literal(UUID 除外)类型。*matchingColumn* 指定规则：\n\n1. 只有一个连接列。当左表和右表的连接列名相同时，*matchingColumn* 是一个字符串标量，否则是一个长度为 2 的 tuple。例如：左表连接列名为 sym，右表连接列名为 sym1，则 *matchingColumn* = \\[\\[\\`sym],\\[\\`sym1]]。\n2. 有多个连接列。当左表和右表的连接列名相同时，*matchingColumn* 是一个字符串向量，否则是一个长度为 2 的 tuple。例如：左表连接列名为 timestamp, sym，右表连接列名为 timestamp, sym1，则 *matchingColumn* = \\[\\[\\`timestamp, \\`sym], \\[\\`timestamp,\\`sym1]]。\n\n**rightTimeColumn** 是字符串标量，表示右表的时间列名称。若设置该参数，右表会根据指定的时间列的时间戳保留最新的数据（若有多行，则取其中最后一行）。若不指定该参数，则根据数据注入系统的时间保留最新数据。\n\n**checkTimes** 是一个时间类型向量或 DURATION 的标量。设置后，系统会定时更新 *rightTable* 的数据（只保留 *rightTable* 的最新数据），并将更新后的数据追加到引擎中。当无需更新 *rightTable* 时，则不用设置该参数，但需要在引擎创建后，手动将 *rightTable* 注入到引擎中。\n\n* *checkTimes* 是时间类型向量时，只能为SECOND、TIME 或 NANOTIME 类型。 lookup join 引擎每天根据向量内各元素指定的时间定时更新右表。\n* *checkTimes* 是 DURATION 标量时，表示更新右表的时间间隔。\n\n**outputElapsedMicroseconds** 布尔值，表示是否输出单次响应计算的耗时（从触发计算的数据注入引擎到计算完成的耗时），默认为 false。指定参数 *outputElapsedMicroseconds* 后，在定义 outputTable 时需要在计算结果列后增加一个 LONG 类型的列和 INT 类型的列，详见 *outputTable* 参数说明。\n\n**keepDuplicates** 布尔值，表示是否保留右表各分组内的所有数据。默认值为 false，即在关联时只取右表各分组内的最新一条数据。当设置为 true 时，在关联时则使用右表各分组内的所有数据。\n\n#### 例子\n\n例1.\n\n```\nlogin(`admin, `123456)\nshare streamTable(1000:0, `timestamps`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\nshare streamTable(1000:0, `timestamps`sym`val`id, [TIMESTAMP, SYMBOL, DOUBLE, INT]) as prices\nshare table(100:0, `sym`factor1`factor2`factor3, [SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\n\nLjEngine = createLookupJoinEngine(name=\"test1\", leftTable=trades, rightTable=prices, outputTable=output, metrics=<[price,val,price*val]>, matchingColumn=`sym)\nsubscribeTable(tableName=\"trades\", actionName=\"append_leftTable\", offset=0, handler=appendForJoin{LjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"prices\", actionName=\"append_rightTable\", offset=0, handler=appendForJoin{LjEngine, false}, msgAsTable=true)\n\nn = 15\ntem1 = table( (2018.10.08T01:01:01.001 + 1..12) join (2018.10.08T01:01:01.001 + 1..3)as timestamps,take(`A`B`C, n) as sym,take(1..15,n) as val,1..15 as id)\nprices.append!(tem1)\nsleep(2000)\nn  = 10\ntem2 = table( 2019.10.08T01:01:01.001 + 1..n as timestamps,take(`A`B`C, n) as sym,take(0.1+10..20,n) as price)\ntrades.append!(tem2)\nsleep(100)\nselect * from output\n```\n\n| sym | factor1 | factor2 | factor3 |\n| --- | ------- | ------- | ------- |\n| A   | 10.1    | 13      | 131.3   |\n| B   | 11.1    | 14      | 155.4   |\n| C   | 12.1    | 15      | 181.5   |\n| A   | 13.1    | 13      | 170.3   |\n| B   | 14.1    | 14      | 197.4   |\n| C   | 15.1    | 15      | 226.5   |\n| A   | 16.1    | 13      | 209.3   |\n| B   | 17.1    | 14      | 239.4   |\n| C   | 8.1     | 15      | 271.5   |\n| A   | 19.1    | 13      | 248.3   |\n\n例2.\n\n```\nshare streamTable(1000:0, `timestamps`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\nshare streamTable(1000:0, `timestamps`sym`val`id, [TIMESTAMP, SYMBOL, DOUBLE, INT]) as prices\nshare table(100:0, `sym`factor1`factor2`factor3, [SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\nLjEngine = createLookupJoinEngine(name=\"test1\", leftTable=trades, rightTable=prices, outputTable=output, metrics=<[price,val,price*val]>, matchingColumn=`sym, rightTimeColumn=`timestamps)\nsubscribeTable(tableName=\"trades\", actionName=\"append_leftTable\", offset=0, handler=appendForJoin{LjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"prices\", actionName=\"append_rightTable\", offset=0, handler=appendForJoin{LjEngine, false}, msgAsTable=true)\n\nn = 15\ntem1 = table( (2018.10.08T01:01:01.001 + 1..12) join (2018.10.08T01:01:01.001 + 1..3)as timestamps,take(`A`B`C, n) as sym,take(1..15,n) as val,1..15 as id)\nprices.append!(tem1)\nsleep(2000)\nn  = 10\ntem2 = table( 2019.10.08T01:01:01.001 + 1..n as timestamps,take(`A`B`C, n) as sym,take(0.1+10..20,n) as price)\ntrades.append!(tem2)\nsleep(100)\nselect * from output\n```\n\n| sym | factor1 | factor2 | factor3 |\n| --- | ------- | ------- | ------- |\n| A   | 10.1    | 10      | 101     |\n| B   | 11.1    | 11      | 122.1   |\n| C   | 12.1    | 12      | 145.2   |\n| A   | 13.1    | 10      | 131     |\n| B   | 14.1    | 11      | 155.1   |\n| C   | 15.1    | 12      | 181.2   |\n| A   | 16.1    | 10      | 161     |\n| B   | 17.1    | 11      | 188.1   |\n| C   | 18.1    | 12      | 217.2   |\n| A   | 19.1    | 10      | 191     |\n\n例3. 右表是内存表，需设置 *checkTimes*\n\n```\nshare streamTable(1000:0, `timestamps`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\nshare table(100:0, `sym`factor1`factor2`factor3, [SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\nshare table(1000:0, `timestamps`sym`val`id, [TIMESTAMP, SYMBOL, DOUBLE, INT]) as prices\nLjEngine = createLookupJoinEngine(name=\"test1\", leftTable=trades, rightTable=prices, outputTable=output, metrics=<[price,val,price*val]>, matchingColumn=`sym, rightTimeColumn=`timestamps, checkTimes=1s)\nsubscribeTable(tableName=\"trades\", actionName=\"append_leftTable\", offset=0, handler=appendForJoin{LjEngine, true}, msgAsTable=true)\n\nn = 15\ntem1 = table( (2018.10.08T01:01:01.001 + 1..12) join (2018.10.08T01:01:01.001 + 1..3)as timestamps,take(`A`B`C, n) as sym,take(1..15,n) as val,1..15 as id)\nprices.append!(tem1)\nsleep(2000)\nn  = 10\ntem2 = table( 2019.10.08T01:01:01.001 + 1..n as timestamps,take(`A`B`C, n) as sym,take(0.1+10..20,n) as price)\ntrades.append!(tem2)\nsleep(100)\nselect * from output\n```\n\n| sym | factor1 | factor2 | factor3 |\n| --- | ------- | ------- | ------- |\n| A   | 10.1    | 10      | 101     |\n| B   | 11.1    | 11      | 122.1   |\n| C   | 12.1    | 12      | 145.2   |\n| A   | 13.1    | 10      | 131     |\n| B   | 14.1    | 11      | 155.1   |\n| C   | 15.1    | 12      | 181.2   |\n| A   | 16.1    | 10      | 161     |\n| B   | 17.1    | 11      | 188.1   |\n| C   | 18.1    | 12      | 217.2   |\n| A   | 19.1    | 10      | 191     |\n\n例4. 左表为一个实时的交易表与右表（相对稳定的维度表）做连接。\n\n```\nshare streamTable(1000:0, `time`volume`id, [TIMESTAMP, INT,INT]) as trades\ndbPath=\"dfs://testlj\"\nif(existsDatabase(dbPath)){\n   dropDatabase(dbPath)\n}\nrt=table(1000:0, `time`price`id, [TIMESTAMP, DOUBLE, INT])\ndb=database(dbPath, VALUE, `A`B`C)\nprices=db.createTable(rt,`rightTable)\nshare table(10000:0, `id`volume`price`prod, [INT,INT,DOUBLE,DOUBLE]) as outputTable\n\ntradesLookupJoin = createLookupJoinEngine(name=\"streamLookup1\", leftTable=trades, rightTable=prices, outputTable=outputTable, metrics=<[volume,price,volume*price]>, matchingColumn=`id, rightTimeColumn=`time,checkTimes=1s)\nsubscribeTable(tableName=\"trades\", actionName=\"append_trades\", offset=0, handler=appendForJoin{tradesLookupJoin, true}, msgAsTable=true)\n\ndef writeData(t,n){\n    timev = 2021.10.08T01:01:01.001 + timestamp(1..n)\n    volumev = take(1..n, n)\n    id = take(1 2 3, n)\n    insert into t values(timev, volumev, id)\n}\nwriteData(rt, 10)\nprices.append!(rt)\nsleep(2000)\nwriteData(trades, 6)\nsleep(2)\n\nselect * from outputTable\n```\n\n| id | volume | price | prod |\n| -- | ------ | ----- | ---- |\n| 1  | 1      | 10    | 10   |\n| 2  | 2      | 8     | 16   |\n| 3  | 3      | 9     | 27   |\n| 1  | 4      | 10    | 40   |\n| 2  | 5      | 8     | 40   |\n| 3  | 6      | 9     | 54   |\n\n例5. 通过 *rightTable* 可以对分布式分区表中的字段进行关联，此时 *rightTable* 是一个 SQL 查询元代码：\n\n```\nshare streamTable(1000:0, `time`volume`id, [TIMESTAMP, INT,INT]) as trades\ndbPath=\"dfs://lookupjoinDB\"\nif(existsDatabase(dbPath)){\n   dropDatabase(dbPath)\n}\nrt=table(1000:0, `time`price`id, [TIMESTAMP, DOUBLE, INT])\ndb=database(dbPath, HASH, [INT,5])\nprices=db.createPartitionedTable(rt,`rightTable, `id)\nshare table(10000:0, `id`volume`price`prod, [INT,INT,DOUBLE,DOUBLE]) as outputTable\n\ntradesLookupJoin = createLookupJoinEngine(name=\"streamLookup1\", leftTable=trades, rightTable=<select * from loadTable(dbPath, `rightTable)>, outputTable=outputTable, metrics=<[volume,price,volume*price]>, matchingColumn=`id, rightTimeColumn=`time,checkTimes=1s)\nsubscribeTable(tableName=\"trades\", actionName=\"append_trades\", offset=0, handler=appendForJoin{tradesLookupJoin, true}, msgAsTable=true)\n\ndef writeData(t,n){\n    timev = 2021.10.08T01:01:01.001 + timestamp(1..n)\n    volumev = take(1..n, n)\n    id = take(1 2 3, n)\n    insert into t values(timev, volumev, id)\n}\nwriteData(rt, 10)\nprices.append!(rt)\nsleep(2000)\nwriteData(trades, 6)\nsleep(2)\n\nselect * from outputTable\n```\n\n| id | volume | price | prod |\n| -- | ------ | ----- | ---- |\n| 1  | 1      | 10    | 10   |\n| 2  | 2      | 8     | 16   |\n| 3  | 3      | 9     | 27   |\n| 1  | 4      | 10    | 40   |\n| 2  | 5      | 8     | 40   |\n| 3  | 6      | 9     | 54   |\n"
    },
    "createNarrowReactiveStateEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createnarrowreactivestateengine.html",
        "signatures": [
            {
                "full": "createNarrowReactiveStateEngine(name, metrics, metricNames, dummyTable, outputTable, keyColumn, [filter], [snapshotDir], [snapshotIntervalInMsgCount], [keepOrder], [keyPurgeFilter], [keyPurgeFreqInSecond=0], [raftGroup], [outputElapsedMicroseconds=false], [keyCapacity=1024], [parallelism=1], [outputHandler=NULL], [msgAsTable=false])",
                "name": "createNarrowReactiveStateEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "metricNames",
                        "name": "metricNames"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "[filter]",
                        "name": "filter",
                        "optional": true
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[keepOrder]",
                        "name": "keepOrder",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFilter]",
                        "name": "keyPurgeFilter",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSecond=0]",
                        "name": "keyPurgeFreqInSecond",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyCapacity=1024]",
                        "name": "keyCapacity",
                        "optional": true,
                        "default": "1024"
                    },
                    {
                        "full": "[parallelism=1]",
                        "name": "parallelism",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createNarrowReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createnarrowreactivestateengine.html)\n\n\n\n#### 语法\n\ncreateNarrowReactiveStateEngine(name, metrics, metricNames, dummyTable, outputTable, keyColumn, \\[filter], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[keepOrder], \\[keyPurgeFilter], \\[keyPurgeFreqInSecond=0], \\[raftGroup], \\[outputElapsedMicroseconds=false], \\[keyCapacity=1024], \\[parallelism=1], \\[outputHandler=NULL], \\[msgAsTable=false])\n\n#### 详情\n\n创建生成窄表的响应式状态引擎。其计算规则和计算方式与 createReactiveStateEngine 一致，输出形式不同。createReactiveStateEngine 将每次计算的指标输出为一行的不同列，而该引擎则把通过 metricNames 指定指标的计算以窄表的形式输出，即计算结果输出到不同行的相同列。\n\n#### 参数\n\n该引擎的的大部分参数和 createReactiveStateEngine 的参数相同，可以参考 createReactiveStateEngine 中的参数说明。这里仅对有区别的参数进行说明。\n\n**metrics** 以元代码的格式表示计算指标，支持输入元组，表示需要输出到 outputTable 中的除 keyColumn 外的输入表中的列或计算指标。注意：这里不要求必须指定除 keyColumn 外的列，但必须指定计算指标，且计算指标必须与 *metricNames* 指定的名称一一对应。\n\n**metricNames** 字符串标量或向量，表示输出到 *outputTable*中的指标的名称。\n\n**outputTable** 计算结果的输出表，可以是内存表或分布式表。使用 `createNarrowReactiveStateEngine` 函数之前，需要预先设立一个输出表，引擎会将计算结果注入该表。\n\n输出表的各列的顺序如下：\n\n(1) 分组列。根据 *keyColumn* 的设置，输出表的前几列必须和 *keyColumn* 设置的列及其顺序保持一致。\n\n(2) 耗时列。指定 *outputElapsedMicroseconds* = true 时才有。此时需要增加一个 LONG 类型和一个 INT 类型的列，分别用于存储引擎内部每个 batch 的数据耗时（单位：微秒）和记录数。\n\n(3) *metrics*中指定的除 *metricNames*指定的计算指标外的列。\n\n(4) *metricNames*列，仅1列。\n\n(5) 计算结果列，仅1列。\n\n**Note:**\n\n暂不支持指定以下三个参数：*snapshotDir*,*snapshotIntervalInMsgCount* 和 *raftGroup。*\n\n**outputHandler** 一元函数。设置此参数时，引擎计算结束后，不再将计算结果写到输出表，而是会调用此函数处理计算结果。默认值为 NULL，表示仍将结果写到输出表。\n\n**msgAsTable** 布尔标量，表示在设置了参数 outputHandler 时，将引擎的计算结果以表的结构调用函数。默认值为 false，此时将计算结果的每一列作为元素组成元组。\n\n#### 例子\n\n下例通过 `createNarrowReactiveStateEngine` 计算累计成交量和移动平均最新价，并将计算结果输出到窄表中，即两个指标的结果输出到同一列。\n\n```\ndummy = streamTable(1:0, [\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"upToDatePrice\",\"qty\",\"value\"], [STRING,STRING,STRING,TIMESTAMP,TIMESTAMP,DOUBLE,DOUBLE,INT]) \noutputTable = streamTable(1:0,[\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"metricNames\",\"factorValue\"], [STRING,STRING,STRING, TIMESTAMP,TIMESTAMP,STRING,DOUBLE])\n//这里定义计算指标，本例中定义了累计成交量和移动平均最新价两个指标。用户可根据实际需要修改指标。\nfactor = [<createTime>, <updateTime>,<cumsum(qty)>,<cumavg(upToDatePrice)>]\nNarrowtest = createNarrowReactiveStateEngine(name=\"narrowtest1\",metrics=factor,metricNames=[\"factor1\",\"factor2\"],dummyTable=dummy,outputTable=outputTable,keyColumn=[\"securityID1\",\"securityID2\",\"securityID3\"])\n\nnum = 5\ntmp = table(take(\"A\" + lpad(string(1..4),4,\"0\"),num) as securityID1,take(\"CC.HH\" + lpad(string(21..34),4,\"0\"),num) as securityID2,take(\"FFICE\" + lpad(string(13..34),4,\"0\"),num) as securityID3, 2023.09.01 00:00:00+(1..num) as createTime, 2023.09.01 00:00:00+take(1..num, num).sort() as updateTime,take(rand(100.0,num) join take(int(),30),num) as upToDatePrice,take(take(100.0,num) join take(int(),30),num)+30 as qty,take(1..20 join take(int(),5),num) as value)\nNarrowtest.append!(tmp)\n\nselect * from outputTable\n```\n\n| securityID1 | securityID2 | securityID3 | createTime              | updateTime              | metricNames | factorValue |\n| ----------- | ----------- | ----------- | ----------------------- | ----------------------- | ----------- | ----------- |\n| A0001       | CC.HH0021   | FFICE0013   | 2023.09.01T00:00:01.000 | 2023.09.01T00:00:01.000 | factor1     | 131         |\n| A0001       | CC.HH0021   | FFICE0013   | 2023.09.01T00:00:01.000 | 2023.09.01T00:00:01.000 | factor2     | 101         |\n| A0002       | CC.HH0022   | FFICE0014   | 2023.09.01T00:00:02000  | 2023.09.01T00:00:02.000 | factor1     | 132         |\n| A0002       | CC.HH0022   | FFICE0014   | 2023.09.01T00:00:02.000 | 2023.09.01T00:00:02.000 | factor2     | 102         |\n| A0003       | CC.HH0023   | FFICE0015   | 2023.09.01T00:00:03.000 | 2023.09.01T00:00:03.000 | factor1     | 133         |\n| A0003       | CC.HH0023   | FFICE0015   | 2023.09.01T00:00:03.000 | 2023.09.01T00:00:03.000 | factor2     | 103         |\n| A0004       | CC.HH0024   | FFICE0016   | 2023.09.01T00:00:04.000 | 2023.09.01T00:00:04.000 | factor1     | 134         |\n| A0004       | CC.HH0024   | FFICE0016   | 2023.09.01T00:00:04.000 | 2023.09.01T00:00:04.000 | factor2     | 105         |\n| A0001       | CC.HH0025   | FFICE0017   | 2023.09.01T00:00:05.000 | 2023.09.01T00:00:05.000 | factor1     | 135         |\n| A0001       | CC.HH0025   | FFICE0017   | 2023.09.01T00:00:05.000 | 2023.09.01T00:00:05.000 | factor2     | 105         |\n\n**Related information**\n\n[addReactiveMetrics](https://docs.dolphindb.cn/zh/funcs/a/addreactivemetrics.html)\n\n[getReactiveMetrics](https://docs.dolphindb.cn/zh/funcs/g/getreactivemetrics.html)\n"
    },
    "createOrderBookSnapshotEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createorderbooksnapshotengine.html",
        "signatures": [
            {
                "full": "createOrderBookSnapshotEngine(name, exchange, orderbookDepth, intervalInMilli, date, startTime, prevClose, dummyTable, outputTable, inputColMap, [outputColMap], [outputCodeMap], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup], [outputIntervalOffsetMap], [checkRestrict], [maxPrice], [minPrice], [userDefinedMetrics], [priceNullFill], [triggerType], [forceTriggerTime], [precision], [orderBySeq], [skipCrossedMarket=true], [orderBookDetailDepth=0], [orderBookAsArray=false], [useSystemTime=false])",
                "name": "createOrderBookSnapshotEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "exchange",
                        "name": "exchange"
                    },
                    {
                        "full": "orderbookDepth",
                        "name": "orderbookDepth"
                    },
                    {
                        "full": "intervalInMilli",
                        "name": "intervalInMilli"
                    },
                    {
                        "full": "date",
                        "name": "date"
                    },
                    {
                        "full": "startTime",
                        "name": "startTime"
                    },
                    {
                        "full": "prevClose",
                        "name": "prevClose"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "inputColMap",
                        "name": "inputColMap"
                    },
                    {
                        "full": "[outputColMap]",
                        "name": "outputColMap",
                        "optional": true
                    },
                    {
                        "full": "[outputCodeMap]",
                        "name": "outputCodeMap",
                        "optional": true
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[outputIntervalOffsetMap]",
                        "name": "outputIntervalOffsetMap",
                        "optional": true
                    },
                    {
                        "full": "[checkRestrict]",
                        "name": "checkRestrict",
                        "optional": true
                    },
                    {
                        "full": "[maxPrice]",
                        "name": "maxPrice",
                        "optional": true
                    },
                    {
                        "full": "[minPrice]",
                        "name": "minPrice",
                        "optional": true
                    },
                    {
                        "full": "[userDefinedMetrics]",
                        "name": "userDefinedMetrics",
                        "optional": true
                    },
                    {
                        "full": "[priceNullFill]",
                        "name": "priceNullFill",
                        "optional": true
                    },
                    {
                        "full": "[triggerType]",
                        "name": "triggerType",
                        "optional": true
                    },
                    {
                        "full": "[forceTriggerTime]",
                        "name": "forceTriggerTime",
                        "optional": true
                    },
                    {
                        "full": "[precision]",
                        "name": "precision",
                        "optional": true
                    },
                    {
                        "full": "[orderBySeq]",
                        "name": "orderBySeq",
                        "optional": true
                    },
                    {
                        "full": "[skipCrossedMarket=true]",
                        "name": "skipCrossedMarket",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[orderBookDetailDepth=0]",
                        "name": "orderBookDetailDepth",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[orderBookAsArray=false]",
                        "name": "orderBookAsArray",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createOrderBookSnapshotEngine](https://docs.dolphindb.cn/zh/funcs/c/createorderbooksnapshotengine.html)\n\n\n\n#### 语法\n\ncreateOrderBookSnapshotEngine(name, exchange, orderbookDepth, intervalInMilli, date, startTime, prevClose, dummyTable, outputTable, inputColMap, \\[outputColMap], \\[outputCodeMap], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[raftGroup], \\[outputIntervalOffsetMap], \\[checkRestrict], \\[maxPrice], \\[minPrice], \\[userDefinedMetrics], \\[priceNullFill], \\[triggerType], \\[forceTriggerTime], \\[precision], \\[orderBySeq], \\[skipCrossedMarket=true], \\[orderBookDetailDepth=0], \\[orderBookAsArray=false], \\[useSystemTime=false])\n\n**Note:**\n\n社区版 License 暂不支持该引擎，如需使用此功能，请联系技术支持。\n\n#### 详情\n\n该函数基于一个包含了逐笔委托和逐笔交易数据表，实时合成指定频率（1秒，100ms，30ms 等）的全档位盘口信息、窗口内统计信息、全天累计统计信息等订单薄（或者叫快照）数据。也可通过历史逐笔数据来合成需要的订单薄数据。\n\n目前支持合成深交所股票、深交所可转债、深交所基金、上交所股票、上交所可转债、上交所基金的订单薄数据。请注意，可转债的规则遵循自2022年8月之后发布的新规定。\n\n##### 窗口规则\n\n由参数 *intervalInMilli*指定窗口的长度（以时间衡量），输出表中显示的时间为窗口的右边界。最后一个窗口区间为左开右开，且输出窗口显示为右边界的时间戳，其余窗口区间全部左开右闭。其中，最后一个窗口的右边界最大值由 *exchange* 决定：\n\n* *exchange* = “XSHGBOND” 时，最后一个窗口的右边界最大值为 15:00:00.000。\n* *exchange* 是其它值时，最后一个窗口的右边界最大值为 14:57:00.000。\n\n##### 触发规则\n\n第一条输出记录由输入表中第一条时间戳大于 startTime + intervalInMilli 的记录触发，此时输出表的时间戳为 startTime + intervalInMili。之后根据参数 *triggerType*的配置值，决定新收到任意一条逐笔数据，当其时间戳大于窗口右边界时，触发输出单个或所有证券代码的快照。\n\n**Note:**\n\n* 一个引擎至多只能输入某一天一个通道的全部股票数据。\n* 必须保证注入引擎的数据表内的数据按照交易所的逐笔序号排序。\n\n#### 参数\n\n**Note:** 传参时必须指定参数名。\n\n**name** 字符串标量，表示 orderbook 快照引擎的名称，可包含字母，数字和下划线，但必须以字母开头。\n\n**exchange** 字符串标量，表示证券的类型。可选参数：\n\n* “XSHE” 或 “XSHESTOCK”：深交所股票\n* “XSHEBOND”：深交所可转债\n* “XSHEFUND”：深交所基金\n* “XSHG” 或 “XSHGSTOCK”：上交所股票\n* “XSHGBOND”：上交所可转债\n* “XSHGFUND”：上交所基金\n\n**orderbookDepth** 正整数，表示 orderbook 中最多能够显示的买卖报价的档位。\n\n**intervalInMilli** 正整数，表示触发输出数据的时间间隔，即合成快照的时间频率，单位为毫秒。\n\n**date** DATE 类型标量，表示交易日期。该参数和窗口右边界组合成输出表的 TIMESTAMP 列。\n\n**startTime** TIME 类型标量，表示触发输出数据的起始时刻。引擎只会输出该参数指定时刻（规整后）之后的数据。\n\n**prevClose** 字典，其 key 为字符串标量或向量，表示股票代码；其 value 为数值类型，表示对应于股票代码的上一个交易日的收盘价格。\n\n**dummyTable** 一个表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。。\n\n**outputTable** 一个表对象。若指定 *userDefinedMetrics*，*outputTable* 根据 `genOutputColumnsForOBSnapshotEngine` 函数指定的 *basic*、*depth* 以及用户自定义的指标来确定表结构。否则，*outputTable* 根据 *outputColMap*的设置来确定表结构。\n\n**inputColMap** 字典，将输入表中列字段的名称映射为引擎计算所需要的列。其中：\n\n* key 为字符串类型，表示引擎所需要的固定的输入字段。具体字段名和含义见下表。注意，这些 key 区分大小写，必须全部指定，但顺序可以不固定。\n* value 为字符串类型，表示输入表中对应的列名称。\n\n<table id=\"table_s52_ghv_x1c\"><thead><tr><th>\n\nkey\n\n</th><th>\n\nvalue 对应的字段类型\n\n</th><th>\n\n含义\n\n</th></tr></thead><tbody><tr><td>\n\n\"codeColumn\"\n\n</td><td>\n\nSYMBOL\n\n</td><td>\n\n证券代码（如300010.SZ）\n\n</td></tr><tr><td>\n\n\"timeColumn\"\n\n</td><td>\n\nTIME\n\n</td><td>\n\n交易时间\n\n</td></tr><tr><td>\n\n\"typeColumn\"\n\n</td><td>\n\nINT\n\n</td><td>\n\n交易类型：-   如果是逐笔委托单，则：1 表示市价；2 表示限价；3 表示本方最优；10 表示撤单（仅上交所）；11 市场状态（仅上交所）\n\n* 如果是逐笔成交单，则：0 表示成交；1 表示撤单（仅深交所）\n\n</td></tr><tr><td>\n\n\"priceColumn\"\n\n</td><td>\n\nLONG\n\n</td><td>\n\n价格，真实价格\\*10000\n\n</td></tr><tr><td>\n\n\"qtyColumn\"\n\n</td><td>\n\nLONG\n\n</td><td>\n\n数量（股数）\n\n</td></tr><tr><td>\n\n\"buyOrderColumn\"\n\n</td><td>\n\nLONG\n\n</td><td>\n\n* 逐笔成交：对应其原始成交中的买方委托序号。\n* 逐笔委托：\n  * 上交所：填充原始委托中的原始订单号，即上交所在新增、删除订单时用以标识订单的唯一编号（OrderNo 字段）\n  * 深交所：填充 0。此字段为深交所为了补全上交所数据格式而增加的冗余列\n\n</td></tr><tr><td>\n\n\"sellOrderColumn\"\n\n</td><td>\n\nLONG\n\n</td><td>\n\n* 逐笔成交：对应其原始成交中的卖方委托序号。\n* 逐笔委托：\n  * 上交所：填充原始委托中的原始订单号，即上交所在新增、删除订单时用以标识订单的唯一编号（OrderNo 字段）\n  * 深交所：填充 0。此字段深交所为了补全上交所数据格式而增加的冗余列\n\n</td></tr><tr><td>\n\n\"sideColumn\"\n\n</td><td>\n\nINT\n\n</td><td>\n\n买卖方向：1 表示买单；2 表示卖单说明：\n\n* 委托单的 BSFlag，必填\n* 撤单的 BSFlag 由原始委托单决定买卖方向，必填\n* 成交单的 BSFlag，不影响结果，非必填\n\n</td></tr><tr><td>\n\n\"msgTypeColumn\"\n\n</td><td>\n\nINT\n\n</td><td>\n\n数据类型：-   0 表示逐笔委托；\n\n* 1 表示逐笔成交；\n* -1 表示产品状态。\n\n</td></tr><tr><td>\n\n\"seqColumn\"\n\n</td><td>\n\nLONG\n\n</td><td>\n\n一个通道内从 1 开始递增的逐笔数据序号。深交所为 appseqlnum 字段，若深交所数据中包含 index 字段，也可以使用 index；上交所为 bizIndex 字段。\n\n</td></tr><tr><td>\n\n\"receiveTime\"\n\n</td><td>\n\nNANOTIMESTAMP\n\n</td><td>\n\n逐笔数据的接收时间\n\n</td></tr></tbody>\n</table>**Note:** 引擎规范了枚举类型中各枚举值的具体含义。输入表对应的枚举值必须遵守这个规范。比如枚举类型字段 sideColumn 所对应的输入表中的字段必须使用 1 代表买方向，2 代表卖方向。\n\n**outputColMap** 可选参数，字符串向量，用于指定需要输出的字段名称，不区分大小写。为方便指定 *outputColMap*，用户可通过 `genOutputColumnsForOBSnapshotEngine` 函数生成需要输出的字段名称，将返回值的第一个元素赋值给 *outputColMap* 即可。\n\n**outputCodeMap** 可选参数，字符串向量，表示股票代码，例如：“000803.SZ”。指定该参数后，将只输出指定股票对应的数据。\n\n**outputIntervalOffsetMap** 可选参数，向量或字典，用于指定输出表中股票被触发计算的时间偏移量。\n\n* 当为向量时，向量中的元素表示不同的时间偏移量，单位为毫秒。引擎将根据输入的股票数量自动将这些股票均匀分配到这些偏移量上。例如，outputIntervalOffsetMap = \\[400, 500]，表示引擎将自动将输入的股票均匀分成两部分，经过intervalInMilli + 400(ms) 后触发其中一部分股票的数据输出；经过 intervalInMilli + 500(ms) 后触发另一部分股票的数据输出。\n* 当为字典时，其 key 为字符串类型，表示股票代码；其 value 为整型，表示时间偏移量，单位为毫秒。例如：outputIntervalOffsetMap =dict(\\[\"127053.sz\",\"123082.SZ\"],\\[400, 500])，表示经过 intervalInMilli + 400(ms) 后触发 127053.sz 股票的数据输出；经过 intervalInMilli + 500(ms) 后触发 123082.SZ 股票的数据输出。\n\n**checkRestrict** 可选参数，布尔值，默认值为 true，表示开启价格笼子机制；若设置为 false，则关闭笼子机制，此时会取消对股票交易的限制，创业板合成出的快照可能不正确。\n\n**Note:** 深交所对创业板证券（证券代码以 3 开头）设定了价格笼子。在 *checkRestrict*=true 时，引擎只会将证券代码的首字符是否为 3 作为是否执行价格笼子的判断标准。因此，在向引擎输入创业板数据时，证券代码必须以 3 开头。\n\n**maxPrice** 可选参数，字典。其 key 为字符串类型，表示证券代码；其 value 为 DOUBLE 类型，表示涨停价格。\n\n**minPrice** 可选参数，字典。其 key 为字符串类型，表示证券代码；其 value 为 DOUBLE 类型，表示跌停价格。\n\n**userDefinedMetrics** 可选参数，一元函数。\n\n* 函数的入参是一个表，表的每一行是一个标的，每一列是标的对应的快照。若指定 *outputColMap*，则表中数据为 *outputColMap*设置的字段；否则表中数据为基础字段和报价/询价的价格和数量。\n\n* 函数的返回值是一个元组，元组的每一个元素是一个常规向量，代表每个标的经对应指标计算后的结果。\n\n**priceNullFill** 一个数字。该参数值用于填充输出表中多档买/卖价格中缺失档位的价格。例如涨停后卖单的价格都为 NULL，此时如有指定卖单价格为 0 的需求，可以设置 priceNullFill=0。\n\n**triggerType** 可选参数，字符串标量，表示触发方式。可选值为：\n\n* “mutual”：新收到任意一条逐笔数据，当其时间戳大于窗口右边界时，就会触发所有股票未计算的快照合成输出。触发计算的数据并不会参与该次计算。\n* “independent”：新收到任意一条逐笔数据，当其时间戳大于窗口右边界时，只触发该条数据对应股票未计算的快照合成输出。触发计算的数据并不会参与该次计算。\n* “perRow”：每收到一行逐笔数据都会触发该条数据对应股票计算并输出，触发计算的数据并参与该次计算。\n\n**forceTriggerTime** 可选参数，是非负整数，单位为毫秒。除了正常触发合成快照外，有时会出现一些数据因乱序不能触发合成快照，而是被缓存在引擎中。在这种情况下，可通过该参数设置强制触发引擎中长时间未处理的逐笔数据合成快照。触发规则为：\n\n1. 最新收到的逐笔数据的时间戳（t ）减去最后一条已经处理的交易数据的时间戳（t0 ）大于或等于 *forceTriggerTime*，则触发未处理的数据中序号最小的那条数据合成快照，并更新已经处理的交易数据的时间戳（t1）。\n2. 重复上述操作，若判断 t-t1 >= *forceTriggerTime*，则触发未处理的数据中序号最小的那条数据合成快照，并更新已经处理的交易数据的时间戳（t2）；直到两个时间戳的差值小于 *forceTriggerTime*时，停止触发快照合成。\n\n**precision** 可选参数，非负整数，表示小数位数，取值范围为\\[0,4]。若指定该参数，则输出表中所有的价格将按照指定的位数进行四舍五入。否则，按照原始结果输出。\n\n**orderBySeq** 可选参数，布尔值或元组\n\n* 指定该参数值为布尔值时，表示是否按照逐笔数据中的 seqColumn 列中值的大小顺序处理数据。\n  * 当 *orderBySeq*=true（默认值） 时，会根据逐笔数据的序号有序处理数据，并计算输出。例如引擎先后收到序号为1，3的数据，因为缺少序号为2的数据，引擎先将1和3的数据缓存，待收到序号2的数据时，再进行计算输出。此时也可以指定 *forceTriggerTime*强制触发计算输出。\n  * 当 *orderBySeq*=false 时，每接收到一条数据都会立即进行计算并输出，此时不可设置 *forceTriggerTime*。\n* 指定该参数值为元组时，以（BOOL, INTEGER, \\[STRING]）的形式表示，其中：\n  * 第一个元素为布尔值，表示是否按照逐笔数据的序号有序输出结果的布尔值，作用同上。\n  * 第二个元素为正整数，表示记录缓存输入数据量的时间间隔，单位为毫秒（ms）。\n  * 第三个元素为指定输出日志级别的字符串标量，可选参数，其可用值为 DEBUG （默认值）和 INFO，分别对应 Debug 和 Info 级别的日志输出。\n\n**skipCrossedMarket**可选参数， 布尔值，表示是否输出买一卖一价交叉的计算结果。\n\n* 当 *skipCrossedMarket*=true（默认值）时，若设置 *useSystemTime* = false，若出现买一卖一价交叉，即卖一价<=买一价，则不输出该条结果；若设置 *useSystemTime* = true，则出现买一卖一交叉时，暂时不输出该条快照，若接下来收到的数据不再有交叉，则立即触发该条快照输出。\n* 当 *skipCrossedMarket*=false 时，若出现买一卖一价交叉，仍然输出该条结果。\n\n**orderBookDetailDepth** 可选参数，整型标量，表示 orderbook 明细的深度。默认值为0，表示不输出。该参数必须和 *outputColMap* 中 orderBookDetailDepth 字段的值保持一致。\n\n**orderBookAsArray** 可选参数，布尔值，表示是否以数组向量形式输出报价/询价的价格和数量。默认值为 false，价格和数量将以多列形式输出。\n\n注意，若指定 *userDefinedMetrics*，价格和数量的输出形式由 *orderBookAsArray* 确定。否则，价格和数量的输出形式由 *outputColMap* 确定，该参数失效。\n\n**useSystemTime** 可选参数，布尔值，表示是否使用系统时间来触发快照输出。\n\n* 当 *useSystemTime* = true 时，交易时段内，引擎将基于当前的系统时间，按照 *intervalInMilli* 设置的时间间隔触发快照输出。此时，休盘时段（(11:30:00.000，13:00:00.000]）不输出数据，下午盘第一个输出窗口时间戳为 13:00:00.000+*intervalInMilli*。注意，若设置 *useSystemTime* = true，则不能指定 *forceTriggerTime*；可以不指定 *triggerType*，或者指定为 *triggerType*=“mutual”\n* 当 *useSystemTime* = false（缺省值）时，引擎根据事件时间来触发快照输出。\n\n#### 例子\n\n运行代码前，先下载 [../data/orderbookDemoInput.zip](https://docs.dolphindb.cn/zh/funcs/data/orderbookDemoInput.zip) 文件。\n\n```\n// 登录\nlogin(\"admin\", \"123456\")\n\n// 释放已有的引擎\ntry { dropStreamEngine(\"demo\") } catch(ex) { print(ex) }\n\n// 创建引擎参数 outputTable，即指定输出表\nsuffix = string(1..10)\ncolNames = `SecurityID`timestamp`lastAppSeqNum`tradingPhaseCode`modified`turnover`volume`tradeNum`totalTurnover`totalVolume`totalTradeNum`lastPx`highPx`lowPx`ask`bid`askVol`bidVol`preClosePx`invalid  join (\"bids\" + suffix) join (\"bidVolumes\" + suffix) join (\"bidOrderNums\" + suffix) join (\"asks\" + suffix)  join (\"askVolumes\" + suffix) join (\"askOrderNums\" + suffix) \ncolTypes = [SYMBOL,TIMESTAMP,LONG,INT,BOOL,DOUBLE,LONG,INT,DOUBLE,LONG,INT,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,LONG,DOUBLE,BOOL] join take(DOUBLE, 10) join take(LONG, 10) join take(INT, 10) join take(DOUBLE, 10) join take(LONG, 10) join take(INT, 10) \nshare table(10000000:0, colNames, colTypes) as outTable\n\n// 创建引擎参数 dummyTable，即指定输入表的表结构\ncolNames = `SecurityID`Date`Time`SecurityIDSource`SecurityType`Index`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo\ncolTypes = [SYMBOL, DATE, TIME, SYMBOL, SYMBOL, LONG, INT, INT, LONG, LONG, INT, LONG, LONG, LONG, INT]\ndummyOrderStream = table(1:0, colNames, colTypes)\n\n// 创建引擎参数 inputColMap，即指定输入表各字段的含义\ninputColMap = dict(`codeColumn`timeColumn`typeColumn`priceColumn`qtyColumn`buyOrderColumn`sellOrderColumn`sideColumn`msgTypeColumn`seqColumn, `SecurityID`Time`Type`Price`Qty`BuyNo`SellNo`BSFlag`SourceType`ApplSeqNum)\n\n// 创建引擎参数 prevClose，即昨日收盘价，prevClose 不影响最终的输出结果中除昨日收盘价以外的其他字段\nprevClose = dict(`000587.SZ`002694.SZ`002822.SZ`000683.SZ`301063.SZ`300459.SZ`300057.SZ`300593.SZ`301035.SZ`300765.SZ, [1.66, 6.56, 6.10, 8.47, 38.10, 5.34, 9.14, 48.81, 60.04, 16.52])\n\n// 定义引擎，每1s计算输出深交所股票10档买卖盘口\nengine = createOrderBookSnapshotEngine(name=\"demo\", exchange=\"XSHE\", orderbookDepth=10, intervalInMilli = 1000, date=2022.01.10, startTime=09:15:00.000, prevClose=prevClose, dummyTable=dummyOrderStream, outputTable=outTable, inputColMap=inputColMap)\n\nfilePath = \"./orderbookDemoInput.csv\"\ncolNames = `SecurityID`Date`Time`SecurityIDSource`SecurityType`Index`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo\ncolTypes = [SYMBOL, DATE, TIME, SYMBOL, SYMBOL, LONG, INT, INT, LONG, LONG, INT, LONG, LONG, LONG, INT]\norderTrade = table(1:0, colNames, colTypes)\norderTrade.append!(select * from loadText(filePath) order by Time)\n\n// 10支股票的逐笔数据批量注入快照合成引擎\nengine.append!(orderTrade)\nselect count(*) from outTable where SecurityID=\"300593.SZ\", timestamp between 2022.01.10T13:15:01.000 and 2022.01.10T13:15:10.000\n\n//output: 10\n```\n\n通过 *outputColMap*指定需要输出的字段。`genOutputColumnsForOBSnapshotEngine` 函数返回值的第一个元素即为 *outputColMap*，返回值的第二个元素可以确定 *outputTable* 的 schema。\n\n```\ntry { dropStreamEngine(\"demo\") } catch(ex) { print(ex) }\n\nfilePath = \"./orderbookDemoInput.csv\"\n\n// 创建引擎参数 dummyTable，即指定输入表的表结构\ncolNames = `SecurityID`Date`Time`SecurityIDSource`SecurityType`Index`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo\ncolTypes = [SYMBOL, DATE, TIME, SYMBOL, SYMBOL, LONG, INT, INT, LONG, LONG, INT, LONG, LONG, LONG, INT]\nshare table(1:0, colNames, colTypes) as dummyOrderStream\n\n// 创建引擎参数 inputColMap，即指定输入表各字段的含义\ninputColMap = dict(`codeColumn`timeColumn`typeColumn`priceColumn`qtyColumn`buyOrderColumn`sellOrderColumn`sideColumn`msgTypeColumn`seqColumn, `SecurityID`Time`Type`Price`Qty`BuyNo`SellNo`BSFlag`SourceType`ApplSeqNum)\n\n// 创建引擎参数 prevClose，即昨日收盘价，prevClose 不影响最终的输出结果中除昨日收盘价以外的其他字段\nprevClose = dict(`000587.SZ`002694.SZ`002822.SZ`000683.SZ`301063.SZ`300459.SZ`300057.SZ`300593.SZ`301035.SZ`300765.SZ, [1.66, 6.56, 6.10, 8.47, 38.10, 5.34, 9.14, 48.81, 60.04, 16.52])\n\n//创建使用 outputColMap 和 outputTableSch 接收 genOutputColumnsForOBSnapshotEngine 的返回值。它们分别用于确定 outputColMap 和 outputTable\noutputColMap, outputTableSch = genOutputColumnsForOBSnapshotEngine(basic=true, time=false, depth=(10, true), tradeDetail=true, orderDetail=false, withdrawDetail=false, orderBookDetailDepth=0, prevDetail=false)\n\nengine = createOrderBookSnapshotEngine(name=\"demo\", exchange=\"XSHE\", orderbookDepth=10, intervalInMilli = 1000, date=2022.01.10, startTime=09:15:00.000, prevClose=prevClose, dummyTable=dummyOrderStream, outputTable=outputTableSch, inputColMap=inputColMap, outputColMap=outputColMap, orderBookAsArray=true)\n\n// 10支股票的逐笔数据批量注入快照合成引擎\nengine.append!(select * from loadText(filePath) order by Time)\nselect top 10 * from outputTableSch where code=\"300593.SZ\", timestamp between 2022.01.10T13:15:01.000 and 2022.01.10T13:15:10.000\n```\n\n部分结果展示如下：\n\n![](https://docs.dolphindb.cn/zh/images/orderBook1.png)\n\n```\ntry { dropStreamEngine(\"demo\") } catch(ex) { print(ex) }\n\nfilePath = \"./orderbookDemoInput.csv\"\n\n// 创建引擎参数 dummyTable，即指定输入表的表结构\ncolNames = `SecurityID`Date`Time`SecurityIDSource`SecurityType`Index`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo`ReceiveTime\ncolTypes = [SYMBOL, DATE, TIME, SYMBOL, SYMBOL, LONG, INT, INT, LONG, LONG, INT, LONG, LONG, LONG, INT, NANOTIMESTAMP]\nshare table(1:0, colNames, colTypes) as dummyOrderStream\n\n// 创建引擎参数 inputColMap，即指定输入表各字段的含义\ninputColMap = dict(`codeColumn`timeColumn`typeColumn`priceColumn`qtyColumn`buyOrderColumn`sellOrderColumn`sideColumn`msgTypeColumn`seqColumn`receiveTime, `SecurityID`Time`Type`Price`Qty`BuyNo`SellNo`BSFlag`SourceType`ApplSeqNum`ReceiveTime)\n\n// 创建引擎参数 prevClose，即昨日收盘价，prevClose 不影响最终的输出结果中除昨日收盘价以外的其他字段\nprevClose = dict(`000587.SZ`002694.SZ`002822.SZ`000683.SZ`301063.SZ`300459.SZ`300057.SZ`300593.SZ`301035.SZ`300765.SZ, [1.66, 6.56, 6.10, 8.47, 38.10, 5.34, 9.14, 48.81, 60.04, 16.52])\n\n//此处只定义 outputColMap 接收 genOutputColumnsForOBSnapshotEngine 的第一个返回值。因 userDefinedMetrics 定义的指标中需要使用委托明细和回撤明细，因此 genOutputColumnsForOBSnapshotEngine  需要指定 orderDetail=false, withdrawDetail=true\noutputColMap = genOutputColumnsForOBSnapshotEngine(basic=true, time=false, depth=(10, true), tradeDetail=true, orderDetail=false, withdrawDetail=true, orderBookDetailDepth=0, prevDetail=false)[0]\n\n\n//// 定义用户自定义因子\ndef userDefinedFunc(t){\n        AvgBuyDuration = rowAvg(t.TradeMDTimeList-t.TradeOrderBuyNoTimeList).int()\n        AvgSellDuration = rowAvg(t.TradeMDTimeList-t.TradeOrderSellNoTimeList).int()        \n        BuyWithdrawQty = rowSum(t.WithdrawBuyQtyList)\n        SellWithdrawQty = rowSum(t.WithdrawSellQtyList)\n        return (AvgBuyDuration, AvgSellDuration, BuyWithdrawQty, SellWithdrawQty)\n}\n\n// 定义 orderbook 引擎的输出表，需要包含基础字段（basic），报价/询价的多档价格和数量（depth），userDefinedMetrics 自定义指标的输出结果\noutputTableSch = genOutputColumnsForOBSnapshotEngine(basic=true, time=false, depth=(10, true), tradeDetail=false, orderDetail=false, withdrawDetail=false, orderBookDetailDepth=0, prevDetail=false)[1]\ncolNames = outputTableSch.schema().colDefs.name join (`AvgBuyDuration`AvgSellDuration`BuyWithdrawQty`SellWithdrawQty)\ncolTypes = outputTableSch.schema().colDefs.typeString join (`INT`INT`INT`INT) \noutputTable = table(1:0, colNames, colTypes)\n\n// 创建引擎，每1s计算输出深交所股票10档 orderbook \n\nengine = createOrderBookSnapshotEngine(name=\"demo\", exchange=\"XSHE\", orderbookDepth=10, intervalInMilli = 1000, date=2022.01.10, startTime=09:30:00.000, prevClose=prevClose, dummyTable=dummyOrderStream, outputTable=outputTable, inputColMap=inputColMap, outputColMap=outputColMap, orderBookAsArray=true, userDefinedMetrics=userDefinedFunc)\n\nt = select * from loadText(filePath) order by Time\nupdate t set ReceiveTime = now(true) // 构造接收时间列\n\ngetStreamEngine(\"demo\").append!(t)\n\nselect top 10 * from outputTable where code=\"300593.SZ\", timestamp between 2022.01.10T13:15:01.000 and 2022.01.10T13:15:10.000\n```\n\n部分结果展示如下：\n\n![](https://docs.dolphindb.cn/zh/images/orderBook2.png)\n\n相关函数：[genOutputColumnsForOBSnapshotEngine](https://docs.dolphindb.cn/zh/funcs/g/genoutputcolumnsforobsnapshotengine.html)\n\n相关教程：[基于逐笔数据合成高频 Orderbook：DolphinDB Orderbook 引擎](https://docs.dolphindb.cn/zh/tutorials/orderBookSnapshotEngine.html)\n\n#### 附录\n\n**basic（基础字段）**\n\n不指定 *outputColMap* 和 *userDefinedMetrics* 时，输出除 openPrice，maxPrice，minPrice 外的字段。\n\n<table id=\"table_e13_h2b_bbc\"><thead><tr><th>\n\n字段名\n\n</th><th>\n\n类型\n\n</th><th>\n\n说明\n\n</th></tr></thead><tbody><tr><td>\n\ncode\n\n</td><td>\n\nSYMBOL\n\n</td><td>\n\n证券代码\n\n</td></tr><tr><td>\n\ntimestamp\n\n</td><td>\n\nTIMESTAMP\n\n</td><td>\n\n快照时间戳，如以1s间隔合成快照：2022.08.01T09:20:00.000，2022.08.01T09:20:01.000\n\n</td></tr><tr><td>\n\nlastSeq\n\n</td><td>\n\nLONG\n\n</td><td>\n\n最后一条逐笔数据的序号（lastAppSeqNum）\n\n</td></tr><tr><td>\n\ntradingPhaseCode\n\n</td><td>\n\nINT\n\n</td><td>\n\n交易阶段代码（tradingPhaseCode）。枚举值：0（开盘前，启动）、1（开盘集合竞价）、2（开盘集合竞价阶段结束至连续竞价阶段开始之前）、3（连续竞价）、4（中午午休）、5（收盘集合竞价）\n\n</td></tr><tr><td>\n\nmodified\n\n</td><td>\n\nBOOL\n\n</td><td>\n\n各证券代码当前周期无输入数据，则对应输出表中的该字段显示为 false，否则显示为 true。\n\n</td></tr><tr><td>\n\nturnover\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n当前周期内的成交金额\n\n</td></tr><tr><td>\n\nvolume\n\n</td><td>\n\nLONG\n\n</td><td>\n\n当前周期内的成交量\n\n</td></tr><tr><td>\n\ntradeNum\n\n</td><td>\n\nINT\n\n</td><td>\n\n当前周期内的成交笔数\n\n</td></tr><tr><td>\n\nttlTurnover\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n（totalTurnover）开盘到现在的成交金额\n\n</td></tr><tr><td>\n\nttlVolume\n\n</td><td>\n\nLONG\n\n</td><td>\n\n（totalVolume）开盘到现在的成交量\n\n</td></tr><tr><td>\n\nttlTradeNum\n\n</td><td>\n\nINT\n\n</td><td>\n\n（totalTradeNum）开盘到现在的成交笔数\n\n</td></tr><tr><td>\n\nlastPrice\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n（lastPx）最近成交价\n\n</td></tr><tr><td>\n\nhighPrice\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n（highPx）开盘到现在的最高价\n\n</td></tr><tr><td>\n\nlowPrice\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n（lowPx）开盘到现在的最低价\n\n</td></tr><tr><td>\n\nopenPrice\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n（openPx）开盘价\n\n</td></tr><tr><td>\n\navgAskPrice\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n（ask）卖出加权平均价 = 卖单的每一档价格\\*量 / 卖单的总量\n\n</td></tr><tr><td>\n\navgBidPrice\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n（bid）买入加权平均价 = 买单的每一档价格\\*量 / 买单的总量\n\n</td></tr><tr><td>\n\naskQty\n\n</td><td>\n\nLONG\n\n</td><td>\n\n（askVol）当前卖盘加权挂单量\n\n</td></tr><tr><td>\n\nbidQty\n\n</td><td>\n\nLONG\n\n</td><td>\n\n（bidVol）当前买盘加权挂单量\n\n</td></tr><tr><td>\n\npreClosePrice\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n（preClosePx）昨收价。\n\n引擎外部定义昨收价，并以字典的方式传入引擎。\n\n</td></tr><tr><td>\n\nabnormal\n\n</td><td>\n\nBOOL\n\n</td><td>\n\n（invalid）输入数据是否异常：true 表示输入数据异常；false 表示输入数据正常。\n\n数据异常是指收到了逐笔成交或者撤单，却找不到对应的委托单。\n\n</td></tr><tr><td>\n\nmaxPrice\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n涨停价。\n\n引擎外部定义涨停价，并以字典的方式传入引擎。\n\n</td></tr><tr><td>\n\nminPrice\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n跌停价。\n\n引擎外部定义跌停价，并以字典的方式传入引擎。\n\n</td></tr></tbody>\n</table>**time（时间字段）**\n\n<table id=\"table_f13_h2b_bbc\"><thead><tr><th>\n\n字段名\n\n</th><th>\n\n类型\n\n</th><th>\n\n说明\n\n</th></tr></thead><tbody><tr><td>\n\nmdTime\n\n</td><td>\n\nTIME\n\n</td><td>\n\n快照时间戳，如以1s间隔合成快照：09:20:00.000，09:20:01.000\n\n</td></tr><tr><td>\n\nmdDate\n\n</td><td>\n\nDATE\n\n</td><td>\n\n快照日期。\n\n引擎外部定义快照日期，通过 date 参数传入引擎。\n\n</td></tr><tr><td>\n\nUpdateTime1\n\n</td><td>\n\nNANOTIMESTAMP\n\n</td><td>\n\n触发窗口关闭的那条输入数据的 receiveTime\n\n</td></tr><tr><td>\n\nUpdateTime2\n\n</td><td>\n\nNANOTIMESTAMP\n\n</td><td>\n\n触发窗口关闭后计算完成的系统时刻，即输出计算结果时的系统时间。\n\n</td></tr></tbody>\n</table>**depth（报价/询价档位）**\n\n不指定 *outputColMap* 和 *userDefinedMetrics* 时，会输出 depth 中的所有字段。提供两种方式存储 depth 数据。两种方式只能选其一：\n\n* 每个档位输出一列。比如 bidsPrice 有10个档位，则会输出10个 bidsPrice 字段：bidsPrice1、bidsPrice2、…、bidsPrice10。\n\n| 字段名       | 类型          | 说明                                             |\n| --------- | ----------- | ---------------------------------------------- |\n| bidsPrice | DOUBLE (多个) | （bids）多个字段，分别存放多档买入价格，档位由 *depth*确定            |\n| bidsQty   | LONG (多个)   | （bidVolumes）多个字段，分别存放多档买入数量，档位由 *depth* 确定     |\n| bidsCount | INT (多个)    | （bidOrderNums）多个字段，分别存放多档买入委托笔数，档位由 *depth* 确定 |\n| asksPrice | DOUBLE (多个) | （asks）多个字段，分别存放多档卖出价格，档位由 *depth* 确定           |\n| asksQty   | LONG (多个)   | （askVolumes）多个字段，分别存放多档卖出数量，档位由 *depth* 确定     |\n| asksCount | INT (多个)    | （askOrderNums）多个字段，分别存放多档卖出委托笔数，档位由 *depth* 确定 |\n\n* 多个档位输出到一个列字段，该列的类型为数组向量。比如 bidsPrice 有10个档位，则会将这10个档位以数组向量的形式输出到一个字段：bidsPriceList。\n\n| 字段名           | 类型        | 说明                             |\n| ------------- | --------- | ------------------------------ |\n| bidsPriceList | DOUBLE\\[] | 数组向量，存放多档买入价格，档位由 *depth* 确定   |\n| bidsQtyList   | LONG\\[]   | 数组向量，存放多档买入数量，档位由 *depth* 确定   |\n| bidsCountList | INT\\[]    | 数组向量，存放多档买入委托笔数，档位由 *depth* 确定 |\n| asksPriceList | DOUBLE\\[] | 数组向量，存放多档卖出价格，档位由 *depth* 确定   |\n| asksQtyList   | LONG\\[]   | 数组向量，存放多档卖出数量，档位由 *depth* 确定   |\n| asksCountList | INT\\[]    | 数组向量，存放多档卖出委托笔数，档位由 *depth* 确定 |\n\n**tradeDetail（成交明细）**\n\n| 基础衍生字段                   | 类型        | 含义                                    |\n| ------------------------ | --------- | ------------------------------------- |\n| buyQty                   | LONG      | 当前周期内的买入总量 = sum( BSFlag=1 的成交的量）     |\n| sellQty                  | LONG      | 当前周期内的卖出总量 = sum( BSFlag=2的成交的量）      |\n| buyMoney                 | DOUBLE    | 当前周期内的买入总金额 = sum( BSFlag=1的成交的量\\*价格） |\n| sellMoney                | DOUBLE    | 当前周期内的卖出总金额 = sum( BSFlag=2的成交的量\\*价格） |\n| tradePriceList           | DOUBLE\\[] | 当前周期内成交价格列表                           |\n| tradeQtyList             | LONG\\[]   | 当前周期内成交量列表                            |\n| tradeTypeList            | INT\\[]    | 当前周期内成交类型列表                           |\n| tradeBSFlagList          | INT\\[]    | 当前周期内成交方向列表                           |\n| tradeMDTimeList          | TIME\\[]   | 当前周期内成交时间列表                           |\n| tradeBuyNoList           | LONG\\[]   | 当前周期内买方委托序号列表                         |\n| tradeSellNoList          | LONG\\[]   | 当前周期内卖方委托序号列表                         |\n| tradeOrderBuyNoTimeList  | TIME\\[]   | 当前周期内的有效成交对应的委托的买单下单时间                |\n| tradeOrderSellNoTimeList | TIME\\[]   | 当前周期内的有效成交对应的委托的卖单下单时间                |\n\n**orderDetail （委托明细）**\n\n| 基础衍生字段          | 类型        | 含义          |\n| --------------- | --------- | ----------- |\n| orderPriceList  | DOUBLE\\[] | 当前周期内委托价格列表 |\n| orderQtyList    | LONG\\[]   | 当前周期内成交量列表  |\n| orderTypeList   | INT\\[]    | 当前周期内委托类型列表 |\n| orderBSFlagList | INT\\[]    | 当前周期内委托方向列表 |\n| orderMDTimeList | TIME\\[]   | 当前周期内委托时间列表 |\n| orderNoList     | LONG\\[]   | 当前周期内委托序号列表 |\n\n**withdrawDetail（撤单明细）**\n\n| 基础衍生字段                      | 类型        | 含义                      |\n| --------------------------- | --------- | ----------------------- |\n| withdrawBuyPriceList        | DOUBLE\\[] | 当前周期内买方撤单的委托价格          |\n| withdrawBuyQtyList          | LONG\\[]   | 当前周期内买方撤单的委托量           |\n| withdrawBuyOrderTypeList    | INT\\[]    | 当前周期内买方撤单的委托的订单类型       |\n| withdrawBuyMDTimeList       | TIME\\[]   | 当前周期内买方撤单的订单时间          |\n| withdrawBuyOrderMDTimeList  | TIME\\[]   | 当前周期内买方撤单对应的委托下单时间      |\n| WithdrawBuyOrderQtyList     | LONG\\[]   | 当前周期内买方撤单对应的原始委托数据中的委托量 |\n| withdrawSellPriceList       | DOUBLE\\[] | 当前周期内卖方撤单的委托价格          |\n| withdrawSellQtyList         | LONG\\[]   | 当前周期内卖方撤单的委托量           |\n| withdrawSellOrderTypeList   | INT\\[]    | 当前周期内卖方撤单的委托的订单类型       |\n| withdrawSellMDTimeList      | TIME\\[]   | 当前周期内卖方撤单的订单时间          |\n| withdrawSellOrderMDTimeList | TIME\\[]   | 当前周期内卖方撤单对应的委托下单时间      |\n| WithdrawSellOrderQtyList    | LONG\\[]   | 当前周期内卖方撤单对应的原始委托数据中的委托量 |\n\n**prevDetail（上一笔交易明细）**\n\n| 基础衍生字段                   | 类型      | 含义                               |\n| ------------------------ | ------- | -------------------------------- |\n| prevBuyPrice1            | DOUBLE  | 上一笔快照的 BuyPrice1 价格              |\n| prevSellPrice1           | DOUBLE  | 上一笔快照的 SellPrice1 价格             |\n| prevBuyAddQtyList1       | LONG\\[] | 价格为上一笔快照的 BuyPrice1，在当前周期内的申购明细  |\n| prevSellAddQtyList1      | LONG\\[] | 价格为上一笔快照的 SellPrice1，在当前周期内的申购明细 |\n| prevBuyWithdrawQtyList1  | LONG\\[] | 价格为上一笔快照的 BuyPrice1，在当前周期内的撤单明细  |\n| prevSellWithdrawQtyList1 | LONG\\[] | 价格为上一笔快照的 SellPrice1，在当前周期内的撤单明细 |\n\n**orderBookDetailDepth（ orderbook 明细档位）**\n\n每个档位输出一列，该列的类型是数组向量。比如 buyQtyList 有20个档位，则会输出20个 buyQtyList 字段：buyQtyList1、buyQtyList2、…、buyQtyList20。buyValueList，sellQtyList 和 sellValueList 同理。\n\n<table id=\"table_a2y_q2t_2bc\"><thead><tr><th>\n\n基础衍生字段\n\n</th><th>\n\n类型\n\n</th><th>\n\n含义\n\n</th></tr></thead><tbody><tr><td>\n\nbuyQtyList\n\n</td><td>\n\nLONG\\[]（多个）\n\n</td><td>\n\n当前最新盘口各档位买入的每一笔委托的数量\n\n</td></tr><tr><td>\n\nbuyValueList\n\n</td><td>\n\nDOUBLE\\[]（多个）\n\n</td><td>\n\n当前最新盘口各档位买入的每一笔委托的金额\n\n</td></tr><tr><td>\n\nsellQtyList\n\n</td><td>\n\nLONG\\[]（多个）\n\n</td><td>\n\n当前最新盘口各档位卖出的每一笔委托的数量\n\n</td></tr><tr><td>\n\nsellValueList\n\n</td><td>\n\nDOUBLE\\[]（多个）\n\n</td><td>\n\n当前最新盘口各档位卖出的每一笔委托的金额\n\n</td></tr></tbody>\n</table>**seqDetail（sequence 明细）**\n\n<table id=\"table_jyr_xmf_fcc\"><thead><tr><th>\n\n基础衍生字段\n\n</th><th>\n\n类型\n\n</th><th>\n\n含义\n\n</th></tr></thead><tbody><tr><td>\n\ntradeSeqList\n\n</td><td>\n\nLONG\\[]\n\n</td><td>\n\n当前周期内的成交序号列表\n\n</td></tr><tr><td>\n\norderSeqList\n\n</td><td>\n\nLONG\\[]\n\n</td><td>\n\n当前周期内的委托序号列表\n\n</td></tr><tr><td>\n\nwithdrawBuySeqList\n\n</td><td>\n\nLONG\\[]\n\n</td><td>\n\n当前周期内的买方撤单序号列表\n\n</td></tr><tr><td>\n\nwithdrawSellSeqList\n\n</td><td>\n\nLONG\\[]\n\n</td><td>\n\n当前周期内的卖方撤单序号列表\n\n</td></tr></tbody>\n</table>**residualDetail（剩余委托明细）**\n\n注意：\n\n* 卖方字段（ResidualAskPriceList, ResidualAskQtyList, ResidualAskTimeList, ResidualAskApplSeqNumList）中每个档位的信息按照价格和交易时间升序排序。若价格和交易时间相同，则按数据进入引擎的时间升序排序。\n\n* 买方字段（ResidualBidPriceList, ResidualBidQtyList, ResidualBidTimeList, ResidualBidApplSeqNumList）中每个档位的信息按价格降序和交易时间升序排序，若价格和交易时间相同，则按数据进入引擎的时间升序排序。\n\n| 字段名                       | 类型        | 说明                    |\n| ------------------------- | --------- | --------------------- |\n| ResidualAskPriceList      | DOUBLE\\[] | 卖方剩余委托价格列表            |\n| ResidualAskQtyList        | LONG\\[]   | 卖方剩余委托量列表             |\n| ResidualAskTimeList       | TIME\\[]   | 卖方剩余委托时间列表            |\n| ResidualAskApplSeqNumList | LONG\\[]   | 卖方剩余委托单 ApplSeqNum 列表 |\n| ResidualBidPriceList      | DOUBLE\\[] | 买方剩余委托价格列表            |\n| ResidualBidQtyList        | LONG\\[]   | 买方剩余委托量列表             |\n| ResidualBidTimeList       | TIME\\[]   | 买方剩余委托时间列表            |\n| ResidualBidApplSeqNumList | LONG\\[]   | 买方剩余委托单 ApplSeqNum 列表 |\n"
    },
    "createPartitionedTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createPartitionedTable.html",
        "signatures": [
            {
                "full": "createPartitionedTable(dbHandle, table, tableName, partitionColumns, [compressMethods], [sortColumns|primaryKey], [keepDuplicates=ALL], [sortKeyMappingFunction], [softDelete=false], [indexes], [latestKeyCache=false])",
                "name": "createPartitionedTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "partitionColumns",
                        "name": "partitionColumns"
                    },
                    {
                        "full": "[compressMethods]",
                        "name": "compressMethods",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns|primaryKey]",
                        "name": "[sortColumns|primaryKey]"
                    },
                    {
                        "full": "[keepDuplicates=ALL]",
                        "name": "keepDuplicates",
                        "optional": true,
                        "default": "ALL"
                    },
                    {
                        "full": "[sortKeyMappingFunction]",
                        "name": "sortKeyMappingFunction",
                        "optional": true
                    },
                    {
                        "full": "[softDelete=false]",
                        "name": "softDelete",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[indexes]",
                        "name": "indexes",
                        "optional": true
                    },
                    {
                        "full": "[latestKeyCache=false]",
                        "name": "latestKeyCache",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createPartitionedTable](https://docs.dolphindb.cn/zh/funcs/c/createPartitionedTable.html)\n\n\n\n#### 语法\n\ncreatePartitionedTable(dbHandle, table, tableName, partitionColumns, \\[compressMethods], \\[sortColumns|primaryKey], \\[keepDuplicates=ALL], \\[sortKeyMappingFunction], \\[softDelete=false], \\[indexes], \\[latestKeyCache=false])\n\n#### 详情\n\n根据 *table* 的结构创建一个空的分区表。\n\n* 对于分布式数据库和本地磁盘数据库，*table* 参数只能是一个表。\n* 对于内存数据库，*table* 参数可以是一个表或包含多个表的元组。如果 *table* 是一个元组，每个 *table* 表示一个分区。\n\n如果参数 *table* 是一个表，则根据该表的结构创建一个分区表。通过 `append!`或 `tableInsert`给新创建的分区表插入数据。它不能用于创建顺序分区的分区表。\n\n如果参数 *table* 是一系列表，则创建一个分区的内存表。参数 *table* 中表的数量与数据库中分区的数量相同。\n\n**Note:**\n\n* 创建分区表时只会使用参数 *table* 的结构，并不会把 *table* 中的数据插入到新的分区表中。\n* OLAP 引擎允许集群每个节点创建的不同的分布式分区表句柄（包含临时句柄）上限为 8192；TSDB 引擎没有上限。临时句柄的说明请参考注释。\n* 调用函数 createPartitionedTable 创建分布式分区表时，若用户没有创建一个句柄变量来接收函数的返回值，则每个数据库会创建一个临时句柄。若在同一数据库下多次创表，则该数据库的临时句柄会被覆盖。\n\n#### 参数\n\n**Note:** 参数 *sortColumns*, *keepDuplicates* 及 *sortKeyMappingFunction* 仅在 `database` 的 *engine* 参数指定为 TSDB 时才有效。\n\n**dbHandle** [database](https://docs.dolphindb.cn/zh/funcs/d/database.html) 函数返回的数据库句柄。它可以是本地磁盘数据库，也可以是分布式数据库。*dbHandle* 为空字符串或没有指定时，表示内存数据库的句柄。\n\n**table** 一个表或包含多个表的元组。系统将会根据该表的结构创建新的分区表。\n\n**tableName** 一个字符串，表示的分区表的名称。\n\n**partitionColumns** 一个字符串或字符串向量，表示分区列或者应用于分区列的函数调用（例如：”partitionFunc(id)”）。对于组合分区，*partitionColumns* 是一个字符串向量。对非顺序分区，此参数为必选参数。若指定该参数为函数调用，则必须有且仅有一个参数是分区列，且其它参数是常量标量。此时，系统在创建分布式表时，会根据函数调用返回的数据进行分区。然而，在 SQL 查询中，对于基于分区列（例如partitionFunc(id) 中的 id 列）的查询优化行为受到一些限制：\n\n* 当 WHERE 条件中对分区列进行非等值比较（例如 >，<）时，不会进行分区剪枝。\n* 无法根据分区列或分区路径进行其它查询优化。\n\n**compressMethods** 一个字典，指定某些列使用 lz4, delta, zstd 或 chimp 压缩算法存储。key 为字段名，value 为压缩算法（\"lz4\", \"delta\", \"zstd\" 或 \"chimp\"）。若未指定，默认采用 lz4 压缩算法。有关 Delta 压缩算法，亦称为 delta-of-delta encoding，参考：[Delta Compression Techniques](http://engineering.nyu.edu/~suel/papers/delta-chap.pdf)。\n\n* 对于 DECIMAL,SHORT, INT, LONG 与时间或日期类型数据，建议采用 Delta 算法压缩。\n* 将字符串存储为 SYMBOL 类型数据，实现对字符串类型的压缩。\n* 对于小数部分长度在三位以内的 DOUBLE 类型的数据，可以考虑使用 chimp 算法压缩。\n\n**sortColumns** 字符串标量或向量，用于指定每一分区内的排序列，每次写入磁盘的数据在每一分区内将按 *sortColumns* 进行排序。系统默认 *sortColumns* （指定多列时） 最后一列为时间列，其余列字段作为排序的索引列，称作 sort key。每一分区内，同一个 sort key 组合值对应的数据将按时间列顺序连续存放在一起。查询时，若查询条件包含索引列，可以快速定位数据所在的数据块位置，提高查询性能。\n\n* 仅当 dbHandle 指示的数据库采用 “TSDB” 引擎（engine=”TSDB”）时，本参数才生效。\n* *sortColumns* 只能是 INTEGER, TEMPORAL, LITERAL 类别（除 BLOB） 或 DECIMAL 类型。\n  * 若 *sortColumns* 指定为多列，则 *sortColumns* 的最后一列必须为时间列，其余列为索引列，且索引列不能为为 TIME, TIMESTAMP, NANOTIME, NANOTIMESTAMP 类型。\n  * 若 *sortColumns* 仅指定一列，则该列作为 sort key，其类型不能为TIME, TIMESTAMP, NANOTIME, NANOTIMESTAMP。若 *sortColumns* 指定为一列时间列 （非分区列），且同时指定了 *sortKeyMappingFunction*，则查询的过滤条件中 *sortColumns* 只能与相同时间类型的值进行比较。\n* 频繁查询的字段适合设置为 *sortColumns*，且建议优先把查询频率高的字段作为 *sortColumns* 中位置靠前的列。\n* 为保证性能最优，建议每个分区内索引列的组合数（sort key）不超过1000个。\n* *sortColumns* 是每个分区内部 level file 内数据的排序依据，与其是否为分区字段无关。\n\n**primaryKey**字符串标量或向量，用于指定主键列。在数据写入操作中，如果主键相同，新的数据覆盖现有数据。\n\n* 仅当*dbHandlei* 指示的数据库采用 “PKEY” 引擎（engine=”PKEY”）时，本参数才生效。\n* 主键列必须包含所有的分区列。\n* 主键列支持的类型包括：BOOL, CHAR, SHORT, INT, LONG, INT128, STRING, TIME, SECOND, MINUTE, DATE, MONTH, DATEHOUR, DATETIME, SYMBOL, TIMESTAMP, NANOTIME, NANOTIMESTAMP, UUID, COMPLEX, POINT, IPADDR, DECIMAL32, DECIMAL64, DECIMAL128。\n\n**keepDuplicates** 指定在每个分区内如何处理所有 *sortColumns* 之值皆相同的数据。提供以下选项：\n\n* ALL：保留所有数据，为默认值。\n* LAST：仅保留最新数据\n* FIRST：仅保留第一条数据\n\n在 TSDB 引擎单个分区 sort key 组合数过多，但每个 sort key 组合值对应的记录数较少的场景下，建议配置 *sortKeyMappingFunction* 参数以对 sort key 组合数进行降维。降维后单个 TSDB level File 内的数据块可以存储更多的数据，查询时既减少了读数据块的次数（降低了 I/O 开销），又提升了数据的压缩率。\n\n**sortKeyMappingFunction** 由一元函数对象组成的向量，其长度与索引列一致，即 *sortColumns* 的长度 - 1，若只指定一个映射函数 mapfunc，必须写为 *sortKeyMappingFunction*=\\[mapfunc]。用于指定应用在索引列中各列的映射函数，以减少 sort key 的组合数，该过程称为 sort key 降维。\n\n索引列中的各列被对应的映射函数降维后，原本的多个 sort key 组合值会被重新映射到一个新的 sort key 组合值上。而每个新 sort key 组合值对应的数据仍将根据 *sortColumns* 的最后一列（时间列）进行排序。降维在写入磁盘时进行，因此指定该参数一定程度上将影响写入性能。\n\n**Note:**\n\n* *sortKeyMappingFunction* 指定的函数对象与索引列中的各列一一对应，若其中某列无需降维，则函数对象置为空。\n* 当 *sortKeyMappingFunction* 中的函数对象为 `hashBucket`，且需要对采用 Hash 分区的分区字段进行降维时，应确保 Hash 分区的数量和 `hashBucket` 中的 *buckets* 之间不存在整除关系（*buckets*=1 除外），否则会导致同一分区内的所有 Hash 值得到的 key 都相同。\n\n**softDelete** 用于启用或禁用软删除功能。默认为 false，即禁用。该参数适于在行数多但删除量小的场景下使用。使用该参数需要同时满足以下条件：\n\n* 由TSDB 存储引擎创建的数据库内的表\n* *keepDuplicates* 已设置为 LAST\n\n**indexes** 为一个字典，用于为表中的列指定索引。仅当 *dbHandle* 指示的数据库采用 “TSDB” （engine=”TSDB” 且 keepDuplicates=ALL）或 “PKEY” 引擎（engine=”PKEY”）时，本参数才生效。\n\n* 设置布隆过滤器，适用于 PKEY 数据库。\n\n  为 PKEY 数据库表中的列指定索引。字典的键是 STRING 类型标量，表示列名；值是 STRING 类型标量，表示为该列指定的索引类型。目前支持设置 “bloomfilter” 索引类型：适用于对大基数列进行点查，且基数越大，索引效果越好，如身份证 ID、订单号、从业务上游同步的外键等数据列。目前支持的类型包括 BOOL, CHAR, SHORT, INT, LONG, BLOB, STRING, DECIMAL32, DECIMAL64, DECIMAL128。\n\n  **Note:** 引擎会将所有主键列合并为组合主键，并为组合主键设置 bloomfilter 类型索引。\n\n* 设置文本索引，适用于 PKEY 数据库。\n\n  为某一列设置文本索引，以便在查询时对该列进行高效的文本查询。每个表支持为STRING 类型的非主键列设置文本索引。字典的 key 为 STRING 类型，表示列名，且该列类型必须是 STRING；字典的 value 为 STRING 类型，其形式为 `textindex(parser=english,full=false,lowercase=true,stem=true)`，其中：\n\n  * parser：指定分词器。没有默认值，必须显式指定。可选值为 none, english, chinese, mixed：\n\n    * none：不分词。\n\n    * english：英文分词器，按照空格和标点进行分词，适合于英文为主要内容的场景。\n\n    * chinese：中文分词器。按照中文词库、空格和标点进行分词。适合于中文较多，仅有少量英文或对英文要求不高的场景。\n\n    * mixed：混合分词器。英文按单词分词，中文按 Bigram 分词（以两个连续字符为单位进行分词，且会重叠。如 '武汉市长江大桥' 会被分词为 '武汉' '汉市' '市长' '长江' '江大' '大桥'）。适合于中英文交替，且对英文要求较高的场景。\n\n  * full：设置中文分词时的分词模式。该属性仅在 parser=chinese 时有效。默认值为 false。\n\n    * false：默认模式。词语之间不会重叠和包含。比如 '武汉市长江大桥' 会分成 '武汉市' 和 '长江大桥'。\n\n    * true：全分词模式。该模式会尽可能多的分析句子中包含的词语。比如 '武汉市长江大桥' 会分成 '武汉', '武汉市', '市长', '长江', '长江大桥', '大桥'。\n\n  * lowercase：是否忽略大小写。该属性在 *parser* 为 english, chinese, mixed 时有效。默认值为true。\n\n    * true：适用于需要忽略英文大小写的场景。\n\n    * false：适用于需要大小写敏感的场景。\n\n  * stem：是否将英文单词作为词干匹配。该属性仅在 parser=english 且 lowercase=true 时生效。默认值为 false。\n\n    * true：将英文单词作为词干。此时可能会匹配到相应的派生词，例如查询单词'dark'，可能会搜到含 'darkness' 的结果。\n\n    * false：只能精确查询结果。\n\n* 设置向量索引，适用于 TSDB 和 PKEY 数据库。\n\n  为某一列设置向量索引，以便在查询时对该列进行高效的欧氏距离计算。目前，每个表仅支持为单个列设置向量索引。字典的键为 STRING 类型，表示列名，且该列的类型必须为 FLOAT\\[] 或 DOUBLE\\[]；字典的 value 为 STRING 类型，其形式为 `\"vectorindex(type=flat, dim=128)\"`，其中：\n\n  type 可选值为 flat, pq, ivf, ivfpq, hnsw：\n\n  * flat 适用于数据规模在数百至数万级别的向量数据，或需要最高精度的场景。\n  * pq 适用于数据规模在数十万至数千万级别的向量数据，且对搜索精度要求不高的场景。常见应用场景如大型数据库、视频库等。\n  * ivf 适用于数据规模在数万至数百万级别的向量数据，常见应用场景如图片检索、文本检索等。\n  * ivfpq 适用于数据规模在数百万至数千万级别的向量数据，需要在检索速度和精度之间找到最佳平衡的场景。常见应用场景如大型推荐系统、社交网络中的用户匹配。\n  * hnsw 适用于数据规模在数亿至数十亿级别的向量数据，并对检索速度，精度和动态更新有高要求的场景，常见应用场景如实时推荐系统、在线搜索、RAG 等。\n    dim 为正整数，表示向量的维度。若 *type* 指定为 pq 或 ivfpq，则要求 *dim* 为 4 的倍数。 后续插入的向量维度必须为 *dim*，否则会插入失败。\n\n  如果已为某一列设置了向量索引，在查询语句中，若同时满足以下条件，则会应用向量索引提升查询性能：\n\n  * 不包含 join 语句\n\n  * 包含 order by 子句且其中只包含对该列应用 rowEuclidean 函数并按升序排序\n\n  * 包含 limit 子句\n\n  * 若引擎为 TSDB，where 子句中不包含 sort key\n\n  **Note:** 当引擎为 PKEY，在满足上述查询条件时，查询会先根据 order by 子句和 limit 子句对索引列进行过滤，再将所得结果根据 where 条件进行过滤，由此得到的结果可能会比 limit 的结果少。\n\n**latestKeyCache** 可选参数，布尔标量，用于设置是否开启最新值缓存功能。默认值为 false，即关闭。注意：该参数为 true 时，参数 *sortColumns* 至少需要包含两列。一般为 ID 列、各种 tag 列和时间列。\n\n注意：建立点位管理表时，\n\n* 须保证当前数据库使用 IOTDB 引擎。\n\n* 暂不支持建立 IOTANY 列。\n\n* 暂不支持 softDelete 等利用 cid 特性的功能。故建立时须设置 softDelete=false。\n\n* 不支持 sortColumns 中包含 DECIMAL 类型。\n\n#### 例子\n\n例1. 在分布式数据库中创建一个分区表\n\n例1.1 创建一张 OLAP 引擎下的分区表。\n\n```\nn=1000000;\nt=table(2020.01.01T00:00:00 + 0..(n-1) as timestamp, rand(`IBM`MS`APPL`AMZN,n) as symbol, rand(10.0, n) as value)\ndb = database(\"dfs://rangedb_tradedata\", RANGE, `A`F`M`S`ZZZZ)\nTrades = db.createPartitionedTable(table=t, tableName=\"Trades\", partitionColumns=\"symbol\", compressMethods={timestamp:\"delta\"});\n```\n\n`createPartitionedTable` 只是建立一张空的表格 Trades，该表复制了表 t 的字段。接着用 `append!` 函数将数据追加到 Trades 表里。\n\n```\nTrades.append!(t);\n```\n\n查询分区表：\n\n```\nTrades=loadTable(db,`Trades);\nselect min(value) from Trades;\n\n0\n```\n\n在分布式数据库中，初次创建表后，可以跳过 [loadTable](https://docs.dolphindb.cn/zh/funcs/l/loadTable.html) 把表载入内存的步骤，因为分布式文件系统会动态刷新表的内容。系统重启后，需要再次执行 `loadTable` 函数加载表。\n\n例1.2 创建一张 TSDB 引擎下的分区表。\n\n```\nn = 10000\nSecurityID = rand(`st0001`st0002`st0003`st0004`st0005, n)\nsym = rand(`A`B, n)\nTradeDate = 2022.01.01 + rand(100,n)\nTotalVolumeTrade = rand(1000..3000, n)\nTotalValueTrade = rand(100.0, n)\nschemaTable_snap = table(SecurityID, TradeDate, TotalVolumeTrade, TotalValueTrade).sortBy!(`SecurityID`TradeDate)\n\ndbPath = \"dfs://TSDB_STOCK\"\nif(existsDatabase(dbPath)){dropDatabase(dbPath)}\ndb_snap = database(dbPath, VALUE, 2022.01.01..2022.01.05, engine='TSDB')\nsnap=createPartitionedTable(dbHandle=db_snap, table=schemaTable_snap, tableName=\"snap\", \n    partitionColumns=`TradeDate, sortColumns=`SecurityID`TradeDate, keepDuplicates=ALL, \n    sortKeyMappingFunction=[hashBucket{,5}])\nsnap.append!(schemaTable_snap)\nflushTSDBCache()\nsnap = loadTable(dbPath, `snap)\nselect * from snap\n```\n\n例2. 在内存数据库中创建一个分区表\n\n例2.1 创建分区常规内存表\n\n```\nn = 200000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt = table(n:0, colNames, colTypes)\ndb = database(, RANGE, `A`D`F)\npt = db.createPartitionedTable(table=t, tableName=`pt, partitionColumns=`sym)\n\ninsert into pt values(09:30:00.001,`AAPL,100,56.5)\ninsert into pt values(09:30:01.001,`DELL,100,15.5)\n```\n\n例2.2 创建分区键值内存表\n\n```\nn = 200000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt = keyedTable(`time`sym, n:0, colNames, colTypes)\ndb = database(, RANGE, `A`D`F)\npt = db.createPartitionedTable(table=t, tableName=`pt, partitionColumns=`sym)\n\ninsert into pt values(09:30:00.001,`AAPL,100,56.5)\ninsert into pt values(09:30:01.001,`DELL,100,15.5)\n```\n\n例2.3 创建分区流数据表\n\n注意，创建分区流数据表时 `createPartitionedTable` 的第二个参数必须是元组，并且其长度必须与分区数量相等，每个表对应一个分区。下例中，trades\\_stream1 和 trades\\_stream2 组成一个分区流数据表 trades。写入数据时，只能分别往 trades\\_stream1 和 trades\\_stream2 写入，不能直接写入到 trades。查询 trades 可以获取到两个表的数据。\n\n```\nn=200000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\ntrades_stream1 = streamTable(n:0, colNames, colTypes)\ntrades_stream2 = streamTable(n:0, colNames, colTypes)\ndb=database(, RANGE, `A`D`F)\ntrades = createPartitionedTable(db,table=[trades_stream1, trades_stream2], tableName=\"\", partitionColumns=`sym)\n\ninsert into trades_stream1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into trades_stream2 values(09:30:01.001,`DELL,100,15.5)\n\nselect * from trades;\n```\n\n| time         | sym  | qty | price |\n| ------------ | ---- | --- | ----- |\n| 09:30:00.001 | AAPL | 100 | 56.5  |\n| 09:30:01.001 | DELL | 100 | 15.5  |\n\n例2.4 创建分区 MVCC 内存表\n\n创建分区 MVCC 内存表的方式与创建分区流数据表的方式相同。\n\n```\nn=200000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\ntrades_mvcc1 = mvccTable(n:0, colNames, colTypes)\ntrades_mvcc2 = mvccTable(n:0, colNames, colTypes)\ndb=database(, RANGE, `A`D`F)\ntrades = createPartitionedTable(db,table=[trades_mvcc1, trades_mvcc2], tableName=\"\", partitionColumns=`sym)\n\ninsert into trades_mvcc1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into trades_mvcc2 values(09:30:01.001,`DELL,100,15.5)\n\nselect * from trades;\n```\n\n| time         | sym  | qty | price |\n| ------------ | ---- | --- | ----- |\n| 09:30:00.001 | AAPL | 100 | 56.5  |\n| 09:30:01.001 | DELL | 100 | 15.5  |\n\n例3. 创建 TSDB 分区表时设置向量索引，提高查询性能。\n\n```\ndb = database(directory=\"dfs://indexesTest\", partitionType=VALUE, partitionScheme=1..10, engine=\"TSDB\")\nschematb = table(1:0,`col0`col1`col2`col3,[INT,INT,TIMESTAMP,FLOAT[]])\npt = createPartitionedTable(dbHandle=db, table=schematb, tableName=`pt, partitionColumns=`col0, sortColumns=`col1`col2, indexes={\"col3\":\"vectorindex(type=flat, dim=5)\"})\n\ntmp = cj(table(1..10 as col0),cj(table(1..10 as col1),table(now()+1..10 as col2))) join table(arrayVector(1..1000*5,1..5000) as col3)\n\npt.tableInsert(tmp)\n\nselect * from pt where col2<now() order by rowEuclidean(col3,[1339,252,105,105,829]) limit 10\n```\n\n| col0 | col1 | col2                    | col3                       |\n| ---- | ---- | ----------------------- | -------------------------- |\n| 2    | 1    | 2024.06.27 16:56:38.950 | \\[526, 527, 528, 529, 530] |\n| 2    | 1    | 2024.06.27 16:56:38.949 | \\[521, 522, 523, 524, 525] |\n| 2    | 1    | 2024.06.27 16:56:38.951 | \\[531, 532, 533, 534, 535] |\n| 2    | 1    | 2024.06.27 16:56:38.948 | \\[516, 517, 518, 519, 520] |\n| 2    | 1    | 2024.06.27 16:56:38.952 | \\[536, 537, 538, 539, 540] |\n| 2    | 1    | 2024.06.27 16:56:38.947 | \\[511, 512, 513, 514, 515] |\n| 2    | 1    | 2024.06.27 16:56:38.953 | \\[541, 542, 543, 544, 545] |\n| 2    | 1    | 2024.06.27 16:56:38.946 | \\[506, 507, 508, 509, 510] |\n| 2    | 1    | 2024.06.27 16:56:38.954 | \\[546, 547, 548, 549, 550] |\n| 2    | 1    | 2024.06.27 16:56:38.945 | \\[501, 502, 503, 504, 505] |\n\n例4. 创建主键引擎的分区表\n\n```\ndb = database(directory=\"dfs://PKDB\", partitionType=VALUE, partitionScheme=1..10, engine=\"PKEY\")\nschematb = table(1:0,`id1`id2`val1`val2`date1`time1,[INT,INT,INT,DECIMAL32(2),DATE,TIME])\npkt = createPartitionedTable(dbHandle=db, table=schematb, tableName=\"pkt\", partitionColumns=\"id1\", primaryKey=`id1`id2, indexes={\"val1\": \"bloomfilter\", \"val2\": \"bloomfilter\"})\n```\n\n例5. 创建点位管理表\n\n本例中，我们通过复合分区方案按 id 和 ts 分区，创建了一个名为 pt 的点位管理表。该表使用 ticket 和 id2 作为唯一识别一个点位的两列；启用最新值缓存和 hashSortKey 压缩。\n\n```\ndb1 = database(, partitionType=HASH, partitionScheme=[INT, 10])\ndb2 = database(, partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\ndb = database(dbName, COMPO, [db1, db2], engine='IOTDB')\nschematb = table(1:0,`id`ticket`id2`ts,[INT,SYMBOL,LONG,TIMESTAMP])\npt = createPartitionedTable(dbHandle=db, table=schematb, tableName=\"pt\", partitionColumns=`id`ts, primaryKey=`ticket`id2`ts, sortKeyMappingFunction = [hashBucket{, 50}, hashBucket{, 50}], latestKeyCache = true )\n```\n"
    },
    "createPricingEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createpricingengine.html",
        "signatures": [
            {
                "full": "createPricingEngine(name, dummyTable, timeColumn, typeColumn, securityType, method, outputTable, [securityReference], [keyColumn], [extraMetrics])",
                "name": "createPricingEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "typeColumn",
                        "name": "typeColumn"
                    },
                    {
                        "full": "securityType",
                        "name": "securityType"
                    },
                    {
                        "full": "method",
                        "name": "method"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[securityReference]",
                        "name": "securityReference",
                        "optional": true
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[extraMetrics]",
                        "name": "extraMetrics",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createPricingEngine](https://docs.dolphindb.cn/zh/funcs/c/createpricingengine.html)\n\n\n\n#### 语法\n\ncreatePricingEngine(name, dummyTable, timeColumn, typeColumn, securityType, method, outputTable, \\[securityReference], \\[keyColumn], \\[extraMetrics])\n\n#### 详情\n\n本函数用于计算估值定价。\n\n该引擎既可调用 DolphinDB 诸多用于估值定价的函数，也支持用户传入可以传入自定义函数或表达式，以此为用户提供方便的、可适用于多种业务场景、交易品种、数据频率的现代金融工具，进而帮助用户准确判断市场动态、优化投资决策、并有效管理市场风险。\n\n#### 参数\n\n**name** 字符串标量，表示引擎的名称。该参数是引擎在一个数据节点上的唯一标识，可包含字母，数字和下划线，但必须以字母开头。\n\n**dummyTable** 表，用于指定输入数据的表结构。\n\n**timeColumn** 字符串向量，表示指定输入表中的时间列。\n\n**typeColumn** 字符串向量，用于指定表中的债券列。\n\n**securityType**整型数组，用于指定需要定价的债券类型。\n\n**method** 元代码元组，用于指定债券定价算法和参数。注意：\n\n* 该参数的大小须和参数 *typeList* 保持一致。\n\n* 引擎本身不限制算法，可以传入自定义函数，也可以传入表达式。\n\n* 算法中的参数可以是输入表中的列或者是参数 *securityReference* 中的列或者常量，优先查找参数 *dummyTable* 中的列；如果有重名，可以用列引用的方式，如 `dummyTable.X`。\n\n* 对于 [vanillaOption](https://docs.dolphindb.cn/zh/funcs/v/vanillaoption.html) 的 kwargs, 支持以下几种写法：\n\n  * 单独指定kwargs\n\n    * ```\n      ```\n\nkwargs = dict(STRING, ANY)\nkwargs\\['theta'] = <theta>\nkwargs\\['kappa'] = <kappa>\nkwargs\\['rho'] = <rho>\nkwargs\\['sigma'] = <sigma>\nmethod=\\[\\<vanillaOption(settlement, maturity, valDay, spot, strike, riskFree, dividend, volatility, isCall, style, basis, calendar,\"heston\",kwargs)>]\n\n````\n\n    -   直接在method中构造kwargs\n\n        -   ```\nmethod=[<vanillaOption(settlement, maturity, valDay, spot, strike, riskFree, dividend, volatility, isCall, style, basis, calendar,\"heston\",dict(`theta`kappa`rho`sigma, [theta, kappa, rho, sigma]))>]\n````\n\n**outputTable** 表，用于指定输出数据的表结构。输出表的列顺序应遵守下述顺序：\n\n1. 时间列，与参数 *timeColumn* 保持一致。\n\n2. 债券类型，INT 数据类型。（可参考 [DolphinDB 数据类型说明](https://docs.dolphindb.cn/zh/progr/data_types.html)）\n\n3. 合约代码列，与参数 *keyColumn* 保持一致。\n\n4. 定价结果，DOUBLE 型数组向量，输出值的数量与参数 *methodList* 中指定算法的数量保持一致。\n\n5. 额外指定输出的算子，与 *extraMetrics* 保持一致。\n\n**securityReference** 可选参数，内存表，用于指定每个合约基础信息。注意：不同品种的合约基础信息略有不同，如有需要请先整合到一张表里再输入；若没有信息则为空值。如下为表说明：\n\n<table id=\"table_d3b_25w_bdc\"><thead><tr><th align=\"left\">\n\n字段\n\n</th><th align=\"left\">\n\n类型\n\n</th><th align=\"left\">\n\n说明\n\n</th></tr></thead><tbody><tr><td>\n\ntype\n\n</td><td>\n\nINT\n\n</td><td>\n\n整型标量或向量，表示标的类型，\n\n</td></tr><tr><td>\n\nassetType\n\n</td><td>\n\nINT\n\n</td><td>\n\n资产类型\n\n</td></tr><tr><td>\n\nsymbol\n\n</td><td>\n\nSYMBOL\n\n</td><td>\n\n合约名\n\n</td></tr><tr><td>\n\nmaturity\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n到期日\n\n</td></tr><tr><td>\n\ncoupon\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n票面利率\n\n</td></tr><tr><td>\n\nfrequency\n\n</td><td>\n\nINT\n\n</td><td>\n\n付息频率\n\n</td></tr><tr><td>\n\nunderlying\n\n</td><td>\n\nSYMBOL\n\n</td><td>\n\n表示标的利率，可选值为：”FR007”, “Shibor3M“，“FDR001”，“FDR007”，“ShiborO/N”，“LPR1Y”，“LPR5Y”\n\n</td></tr><tr><td>\n\nstartDate\n\n</td><td>\n\nDATE\n\n</td><td>\n\n第一次利率互换的日期\n\n</td></tr><tr><td>\n\nendDate\n\n</td><td>\n\nDATE\n\n</td><td>\n\n最后一次利率互换的日期。注意：须晚于 *startDay。*\n\n</td></tr><tr><td>\n\nfixRate\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n百分数值，表示利率互换中固定利率支付方所支付的利率，在整个利率互换期间该利率不变\n\n</td></tr><tr><td>\n\ninterval\n\n</td><td>\n\nINT\n\n</td><td>\n\n利率互换的间隔时间\n\n</td></tr><tr><td>\n\nbasis\n\n</td><td>\n\nINT\n\n</td><td>\n\n表示要使用的日计数基准类型\n\n</td></tr><tr><td>\n\nPrice\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n标的资产的当前价格。\n\n</td></tr><tr><td>\n\nstrike\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n标的资产的行权价格\n\n</td></tr><tr><td>\n\ndividendYield\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n表示分红利率\n\n</td></tr></tbody>\n</table>**keyColumn** 可选参数，字符串标量或元组（大小为2），用于指定 *dummyTable* 和 *sucurityReference* 中的合约代码列。如果是 size 为 2 的元组，则分别表示 *dummyTable* 和 *sucurityReference* 中的合约代码列。\n\n注意：参数 *sucurityReference* 和 *keyColumn* 需要搭配使用，即只支持同时指定这两个参数或者同时不指定的情况。\n\n**extraMetrics** 可选参数，元代码元组，用于指定除定价结果外需要额外输出的信息。该参数可以传入输入列中的部分列、*securityReference* 中的部分列等。注意：不可包含常量。\n\n#### 例子\n\n首先指定参数，创建一个估值定价引擎。\n\n```\n//指定传入表结构、合约基础信息、输出表结构\ndummyTable = table(1:0, `tradeTime`Symbol`realTimeX`predictY`price,[TIMESTAMP,SYMBOL, DOUBLE, DOUBLE, DOUBLE])\nsecurityReference= table(take(0 1 2, 100) as type, take(1 2 3 4, 100) as assetType,\"s\"+string(1..100) as symbol, 2025.07.25+1..100 as maturity, rand(10.0, 100) as coupon, rand(10,100) as frequency,take([1],100) as basis )\noutputTable = table(1:0, `tradeTime`type`symbol`result`factor1`factor2,[TIMESTAMP, INT, SYMBOL, DOUBLE, DOUBLE, DOUBLE])\n\n//指定需要定价的债券类型、有价证券的购买日期、证券票面值、债券定价算法和参数\ntypeList=[0,1,2]\ndate=2024.07.25\npar=100\nmethodList=[<bondDirtyPrice(date, maturity, coupon, predictY, frequency,basis)>,\n             <bondAccrInt(date, maturity, coupon, frequency,par,basis)>,\n             <bondDuration(date, maturity, coupon, predictY, frequency, basis)>]\n\n//基于上述参数创建估值定价引擎\ncreatePricingEngine(name=\"engine1\", dummyTable=dummyTable, timeColumn=`tradeTime, typeColumn=`type, securityType=typeList, method=methodList, outputTable=outputTable, securityReference=securityReference, keyColumn=`Symbol, extraMetrics=[<price * predictY>, <coupon+price>])\n```\n\n成功创建引擎后，传入符合期望格式的数据并使用 `getStreamEngine` 函数调用引擎句柄，从而计算估值定价。\n\n```\ndata = table(take(now(), 100)as tradeTime,\"s\"+string(1..100) as symbol, rand(10.0, 100) as realTimeX,  rand(10.0, 100) as predictY, rand(10.0, 100) as price)\ngetStreamEngine(`engine1).append!(data)\n```\n\n**相关函数**\n\n* [bondDirtyPrice](https://docs.dolphindb.cn/zh/funcs/b/bondDirtyPrice.html)\n\n* [bondAccrInt](https://docs.dolphindb.cn/zh/funcs/b/bondaccrint.html)\n\n* [bondDuration](https://docs.dolphindb.cn/zh/funcs/b/bondDuration.html)\n\n* [bondConvexity](https://docs.dolphindb.cn/zh/funcs/b/bondconvexity.html)\n\n* [bondYield](https://docs.dolphindb.cn/zh/funcs/b/bondyield.html)\n\n* [irs](https://docs.dolphindb.cn/zh/funcs/i/irs.html)\n"
    },
    "createReactiveStateEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createReactiveStateEngine.html",
        "signatures": [
            {
                "full": "createReactiveStateEngine(name, metrics, dummyTable, outputTable, [keyColumn], [filter],\n        [snapshotDir], [snapshotIntervalInMsgCount], [keepOrder], [keyPurgeFilter],\n        [keyPurgeFreqInSecond=0], [raftGroup], [outputElapsedMicroseconds=false],\n        [keyCapacity=1024], [parallelism=1], [outputHandler=NULL], [msgAsTable=false])",
                "name": "createReactiveStateEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[filter]",
                        "name": "filter",
                        "optional": true
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[keepOrder]",
                        "name": "keepOrder",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFilter]",
                        "name": "keyPurgeFilter",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSecond=0]",
                        "name": "keyPurgeFreqInSecond",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyCapacity=1024]",
                        "name": "keyCapacity",
                        "optional": true,
                        "default": "1024"
                    },
                    {
                        "full": "[parallelism=1]",
                        "name": "parallelism",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createReactiveStateEngine.html)\n\n\n\n#### 语法\n\n```\ncreateReactiveStateEngine(name, metrics, dummyTable, outputTable, [keyColumn], [filter],\n        [snapshotDir], [snapshotIntervalInMsgCount], [keepOrder], [keyPurgeFilter],\n        [keyPurgeFreqInSecond=0], [raftGroup], [outputElapsedMicroseconds=false],\n        [keyCapacity=1024], [parallelism=1], \\[outputHandler=NULL\\], \\[msgAsTable=false\\])\n```\n\n#### 详情\n\n创建响应式状态引擎。返回一个表对象，向该表写入数据意味着这些数据进入响应式状态引擎进行计算。\n\n下列状态函数在 DolphinDB 的响应式状态引擎中的实现均得到了优化。需要注意的是，状态引擎不允许使用未经优化的内置状态函数，且需避免使用聚合函数。\n\n* 累计窗口函数：[cumavg](https://docs.dolphindb.cn/zh/funcs/c/cumavg.html), [cumsum](https://docs.dolphindb.cn/zh/funcs/c/cumsum.html), [cumprod](https://docs.dolphindb.cn/zh/funcs/c/cumprod.html), [cumcount](https://docs.dolphindb.cn/zh/funcs/c/cumcount.html), [cummin](https://docs.dolphindb.cn/zh/funcs/c/cummin.html), [cummax](https://docs.dolphindb.cn/zh/funcs/c/cummax.html), [cumvar](https://docs.dolphindb.cn/zh/funcs/c/cumvar.html), [cumvarp](https://docs.dolphindb.cn/zh/funcs/c/cumvarp.html), [cumstd](https://docs.dolphindb.cn/zh/funcs/c/cumstd.html), [cumstdp](https://docs.dolphindb.cn/zh/funcs/c/cumstdp.html), [cumcorr](https://docs.dolphindb.cn/zh/funcs/c/cumcorr.html), [cumcovar](https://docs.dolphindb.cn/zh/funcs/c/cumcovar.html), [cumbeta](https://docs.dolphindb.cn/zh/funcs/c/cumbeta.html), [cumwsum](https://docs.dolphindb.cn/zh/funcs/c/cumwsum.html), [cumwavg](https://docs.dolphindb.cn/zh/funcs/c/cumwavg.html), [cumfirstNot](https://docs.dolphindb.cn/zh/funcs/c/cumfirstNot.html), [cumlastNot](https://docs.dolphindb.cn/zh/funcs/c/cumlastNot.html), [cummed](https://docs.dolphindb.cn/zh/funcs/c/cummed.html), [cumpercentile](https://docs.dolphindb.cn/zh/funcs/c/cumpercentile.html), [cumnunique](https://docs.dolphindb.cn/zh/funcs/c/cumnunique.html), [cumPositiveStreak](https://docs.dolphindb.cn/zh/funcs/c/cumPositiveStreak.html), [cummdd](https://docs.dolphindb.cn/zh/funcs/c/cummdd.html)\n* 滑动窗口函数：[ema](https://docs.dolphindb.cn/zh/funcs/e/ema.html), [mavg](https://docs.dolphindb.cn/zh/funcs/m/mavg.html), [msum](https://docs.dolphindb.cn/zh/funcs/m/msum.html), [mcount](https://docs.dolphindb.cn/zh/funcs/m/mcount.html), [mprod](https://docs.dolphindb.cn/zh/funcs/m/mprod.html), [mvar](https://docs.dolphindb.cn/zh/funcs/m/mvar.html), [mvarp](https://docs.dolphindb.cn/zh/funcs/m/mvarp.html), [mstd](https://docs.dolphindb.cn/zh/funcs/m/mstd.html), [mstdp](https://docs.dolphindb.cn/zh/funcs/m/mstdp.html), [mskew](https://docs.dolphindb.cn/zh/funcs/m/mskew.html), [mkurtosis](https://docs.dolphindb.cn/zh/funcs/m/mkurtosis.html), [mmin](https://docs.dolphindb.cn/zh/funcs/m/mmin.html), [mmax](https://docs.dolphindb.cn/zh/funcs/m/mmax.html), [mimin](https://docs.dolphindb.cn/zh/funcs/m/mimin.html), [mimax](https://docs.dolphindb.cn/zh/funcs/m/mimax.html), [mmed](https://docs.dolphindb.cn/zh/funcs/m/mmed.html), [mpercentile](https://docs.dolphindb.cn/zh/funcs/m/mpercentile.html), [mrank](https://docs.dolphindb.cn/zh/funcs/m/mrank.html), [mcorr](https://docs.dolphindb.cn/zh/funcs/m/mcorr.html), [mcovar](https://docs.dolphindb.cn/zh/funcs/m/mcovar.html), [mbeta](https://docs.dolphindb.cn/zh/funcs/m/mbeta.html), [mwsum](https://docs.dolphindb.cn/zh/funcs/m/mwsum.html), [mwavg](https://docs.dolphindb.cn/zh/funcs/m/mwavg.html), [mmad](https://docs.dolphindb.cn/zh/funcs/m/mmad.html), [mfirst](https://docs.dolphindb.cn/zh/funcs/m/mfirst.html), [mlast](https://docs.dolphindb.cn/zh/funcs/m/mlast.html), [mslr](https://docs.dolphindb.cn/zh/funcs/m/mslr.html), [tmove](https://docs.dolphindb.cn/zh/funcs/t/tmove.html), [tmfirst](https://docs.dolphindb.cn/zh/funcs/t/tmfirst.html), [tmlast](https://docs.dolphindb.cn/zh/funcs/t/tmlast.html), [tmsum](https://docs.dolphindb.cn/zh/funcs/t/tmsum.html), [tmsum2](https://docs.dolphindb.cn/zh/funcs/t/tmsum2.html), [tmavg](https://docs.dolphindb.cn/zh/funcs/t/tmavg.html), [tmcount](https://docs.dolphindb.cn/zh/funcs/t/tmcount.html), [tmvar](https://docs.dolphindb.cn/zh/funcs/t/tmvar.html), [tmvarp](https://docs.dolphindb.cn/zh/funcs/t/tmvarp.html), [tmstd](https://docs.dolphindb.cn/zh/funcs/t/tmstd.html), [tmstdp](https://docs.dolphindb.cn/zh/funcs/t/tmstdp.html), [tmprod](https://docs.dolphindb.cn/zh/funcs/t/tmprod.html), [tmskew](https://docs.dolphindb.cn/zh/funcs/t/tmskew.html), [tmkurtosis](https://docs.dolphindb.cn/zh/funcs/t/tmkurtosis.html), [tmmin](https://docs.dolphindb.cn/zh/funcs/t/tmmin.html), [tmmax](https://docs.dolphindb.cn/zh/funcs/t/tmmax.html), [tmmed](https://docs.dolphindb.cn/zh/funcs/t/tmmed.html), [tmpercentile](https://docs.dolphindb.cn/zh/funcs/t/tmpercentile.html), [tmrank](https://docs.dolphindb.cn/zh/funcs/t/tmrank.html), [tmcovar](https://docs.dolphindb.cn/zh/funcs/t/tmcovar.html), [tmbeta](https://docs.dolphindb.cn/zh/funcs/t/tmbeta.html), [tmcorr](https://docs.dolphindb.cn/zh/funcs/t/tmcorr.html), [tmwavg](https://docs.dolphindb.cn/zh/funcs/t/tmwavg.html), [tmwsum](https://docs.dolphindb.cn/zh/funcs/t/tmwsum.html), [tmoving](https://docs.dolphindb.cn/zh/funcs/ho_funcs/tmoving.html), [moving](https://docs.dolphindb.cn/zh/funcs/ho_funcs/moving.html), [sma](https://docs.dolphindb.cn/zh/funcs/s/sma.html), [wma](https://docs.dolphindb.cn/zh/funcs/w/wma.html), [dema](https://docs.dolphindb.cn/zh/funcs/d/dema.html), [tema](https://docs.dolphindb.cn/zh/funcs/t/tema.html), [trima](https://docs.dolphindb.cn/zh/funcs/t/trima.html), [linearTimeTrend](https://docs.dolphindb.cn/zh/funcs/l/linearTimeTrend.html), [talib](https://docs.dolphindb.cn/zh/funcs/ho_funcs/talib.html), [t3](https://docs.dolphindb.cn/zh/funcs/t/t3.html), [ma](https://docs.dolphindb.cn/zh/funcs/m/ma.html), [gema](https://docs.dolphindb.cn/zh/funcs/g/gema.html), [wilder](https://docs.dolphindb.cn/zh/funcs/w/wilder.html), [mmaxPositiveStreak](https://docs.dolphindb.cn/zh/funcs/m/mmaxPositiveStreak.html), [movingWindowData](https://docs.dolphindb.cn/zh/funcs/m/movingWindowData.html), [tmovingWindowData](https://docs.dolphindb.cn/zh/funcs/t/tmovingWindowData.html)\n* 行计算函数： [rowMin](https://docs.dolphindb.cn/zh/funcs/r/rowMin.html), [rowMax](https://docs.dolphindb.cn/zh/funcs/r/rowMax.html), [rowAnd](https://docs.dolphindb.cn/zh/funcs/r/rowAnd.html), [rowOr](https://docs.dolphindb.cn/zh/funcs/r/rowOr.html), [rowXor](https://docs.dolphindb.cn/zh/funcs/r/rowXor.html), [rowProd](https://docs.dolphindb.cn/zh/funcs/r/rowProd.html), [rowSum](https://docs.dolphindb.cn/zh/funcs/r/rowSum.html), [rowSum2](https://docs.dolphindb.cn/zh/funcs/r/rowSum2.html), [rowSize](https://docs.dolphindb.cn/zh/funcs/r/rowSize.html), [rowCount](https://docs.dolphindb.cn/zh/funcs/r/rowCount.html), [rowAvg](https://docs.dolphindb.cn/zh/funcs/r/rowAvg.html), [rowKurtosis](https://docs.dolphindb.cn/zh/funcs/r/rowKurtosis.html), [rowSkew](https://docs.dolphindb.cn/zh/funcs/r/rowSkew.html), [rowVar](https://docs.dolphindb.cn/zh/funcs/r/rowVar.html), [rowVarp](https://docs.dolphindb.cn/zh/funcs/r/rowVarp.html), [rowStd](https://docs.dolphindb.cn/zh/funcs/r/rowStd.html), [rowStdp](https://docs.dolphindb.cn/zh/funcs/r/rowStdp.html)\n* 序列相关函数：[deltas](https://docs.dolphindb.cn/zh/funcs/d/deltas.html), [ratios](https://docs.dolphindb.cn/zh/funcs/r/ratios.html), [ffill](https://docs.dolphindb.cn/zh/funcs/f/ffill.html), [move](https://docs.dolphindb.cn/zh/funcs/m/move.html), [prev](https://docs.dolphindb.cn/zh/funcs/p/prev.html), [iterate](https://docs.dolphindb.cn/zh/funcs/i/iterate.html), [ewmMean](https://docs.dolphindb.cn/zh/funcs/e/ewmMean.html), [ewmVar](https://docs.dolphindb.cn/zh/funcs/e/ewmVar.html), [ewmStd](https://docs.dolphindb.cn/zh/funcs/e/ewmStd.html), [ewmCov](https://docs.dolphindb.cn/zh/funcs/e/ewmCov.html), [ewmCorr](https://docs.dolphindb.cn/zh/funcs/e/ewmCorr.html), [prevState](https://docs.dolphindb.cn/zh/funcs/p/prevState.html), [percentChange](https://docs.dolphindb.cn/zh/funcs/p/percentChange.html)\n* topN相关函数：[msumTopN](https://docs.dolphindb.cn/zh/funcs/m/msumTopN.html), [mavgTopN](https://docs.dolphindb.cn/zh/funcs/m/mavgTopN.html), [mstdpTopN](https://docs.dolphindb.cn/zh/funcs/m/mstdpTopN.html), [mstdTopN](https://docs.dolphindb.cn/zh/funcs/m/mstdTopN.html), [mvarpTopN](https://docs.dolphindb.cn/zh/funcs/m/mvarpTopN.html), [mvarTopN](https://docs.dolphindb.cn/zh/funcs/m/mvarTopN.html), [mcorrTopN](https://docs.dolphindb.cn/zh/funcs/m/mcorrTopN.html), [mbetaTopN](https://docs.dolphindb.cn/zh/funcs/m/mbetaTopN.html), [mcovarTopN](https://docs.dolphindb.cn/zh/funcs/m/mcovarTopN.html), [mwsumTopN](https://docs.dolphindb.cn/zh/funcs/m/mwsumTopN.html), [cumsumTopN](https://docs.dolphindb.cn/zh/funcs/c/cumsumTopN.html),[cumwsumTopN](https://docs.dolphindb.cn/zh/funcs/c/cumwsumTopN.html), [cumvarTopN](https://docs.dolphindb.cn/zh/funcs/c/cumvarTopN.html), [cumvarpTopN](https://docs.dolphindb.cn/zh/funcs/c/cumvarpTopN.html), [cumstdTopN](https://docs.dolphindb.cn/zh/funcs/c/cumstdTopN.html), [cumstdpTopN](https://docs.dolphindb.cn/zh/funcs/c/cumstdpTopN.html), [cumcorrTopN](https://docs.dolphindb.cn/zh/funcs/c/cumcorrTopN.html), [cumbetaTopN](https://docs.dolphindb.cn/zh/funcs/c/cumbetaTopN.html), [cumavgTopN](https://docs.dolphindb.cn/zh/funcs/c/cumavgTopN.html), [msumTopN](https://docs.dolphindb.cn/zh/funcs/m/msumTopN.html), [mavgTopN](https://docs.dolphindb.cn/zh/funcs/m/mavgTopN.html), [mstdpTopN](https://docs.dolphindb.cn/zh/funcs/m/mstdpTopN.html), [mstdTopN](https://docs.dolphindb.cn/zh/funcs/m/mstdTopN.html), [mvarpTopN](https://docs.dolphindb.cn/zh/funcs/m/mvarpTopN.html), [mvarTopN](https://docs.dolphindb.cn/zh/funcs/m/mvarTopN.html), [mcorrTopN](https://docs.dolphindb.cn/zh/funcs/m/mcorrTopN.html), [mbetaTopN](https://docs.dolphindb.cn/zh/funcs/m/mbetaTopN.html), [mcovarTopN](https://docs.dolphindb.cn/zh/funcs/m/mcovarTopN.html), [mwsumTopN](https://docs.dolphindb.cn/zh/funcs/m/mwsumTopN.html), [cumsumTopN](https://docs.dolphindb.cn/zh/funcs/c/cumsumTopN.html),[cumwsumTopN](https://docs.dolphindb.cn/zh/funcs/c/cumwsumTopN.html), [cumvarTopN](https://docs.dolphindb.cn/zh/funcs/c/cumvarTopN.html), [cumvarpTopN](https://docs.dolphindb.cn/zh/funcs/c/cumvarpTopN.html), [cumstdTopN](https://docs.dolphindb.cn/zh/funcs/c/cumstdTopN.html), [cumstdpTopN](https://docs.dolphindb.cn/zh/funcs/c/cumstdpTopN.html), [cumcorrTopN](https://docs.dolphindb.cn/zh/funcs/c/cumcorrTopN.html), [cumbetaTopN](https://docs.dolphindb.cn/zh/funcs/c/cumbetaTopN.html), [cumavgTopN](https://docs.dolphindb.cn/zh/funcs/c/cumavgTopN.html), [cumskewTopN](https://docs.dolphindb.cn/zh/funcs/c/cumskewTopN.html)、[cumkurtosisTopN](https://docs.dolphindb.cn/zh/funcs/c/cumkurtosisTopN.html), [mskewTopN](https://docs.dolphindb.cn/zh/funcs/m/mskewTopN.html), [mkurtosisTopN](https://docs.dolphindb.cn/zh/funcs/m/mkurtosisTopN.html),[tmsumTopN](https://docs.dolphindb.cn/zh/funcs/t/tmsumTopN.html), [tmavgTopN](https://docs.dolphindb.cn/zh/funcs/t/tmavgTopN.html), [tmstdTopN](https://docs.dolphindb.cn/zh/funcs/t/tmstdTopN.html), [tmstdpTopN](https://docs.dolphindb.cn/zh/funcs/t/tmstdpTopN.html), [tmvarTopN](https://docs.dolphindb.cn/zh/funcs/t/tmvarTopN.html), [tmvarpTopN](https://docs.dolphindb.cn/zh/funcs/t/tmvarpTopN.html), [tmskewTopN](https://docs.dolphindb.cn/zh/funcs/t/tmskewTopN.html), [tmkurtosisTopN](https://docs.dolphindb.cn/zh/funcs/t/tmkurtosisTopN.html), [tmbetaTopN](https://docs.dolphindb.cn/zh/funcs/t/tmbetaTopN.html), [tmcorrTopN](https://docs.dolphindb.cn/zh/funcs/t/tmcorrTopN.html), [tmcovarTopN](https://docs.dolphindb.cn/zh/funcs/t/tmcovarTopN.html), [tmwsumTopN](https://docs.dolphindb.cn/zh/funcs/t/tmwsumTopN.html)\n* 高阶函数：[segmentby](https://docs.dolphindb.cn/zh/funcs/ho_funcs/segmentby.html) (参数 *func* 暂支持 cumsum, cummax, cummin, cumcount, cumavg, cumstd, cumvar, cumstdp, cumvarp), [moving](https://docs.dolphindb.cn/zh/funcs/ho_funcs/moving.html), [byColumn](https://docs.dolphindb.cn/zh/funcs/ho_funcs/byColumn.html), [accumulate](https://docs.dolphindb.cn/zh/funcs/ho_funcs/accumulate.html), [window](https://docs.dolphindb.cn/zh/funcs/ho_funcs/window.html)\n* 其他函数：[talibNull](https://docs.dolphindb.cn/zh/funcs/t/talibNull.html), [dynamicGroupCumsum](https://docs.dolphindb.cn/zh/funcs/d/dynamicGroupCumsum.html), [dynamicGroupCumcount](https://docs.dolphindb.cn/zh/funcs/d/dynamicGroupCumcount.html), [topRange](https://docs.dolphindb.cn/zh/funcs/t/topRange.html), [lowRange](https://docs.dolphindb.cn/zh/funcs/l/lowRange.html), [trueRange](https://docs.dolphindb.cn/zh/funcs/t/trueRange.html), [sumbars](https://docs.dolphindb.cn/zh/funcs/s/sumbars.html)\n* 特殊函数（仅支持在引擎内使用）：[stateIterate](https://docs.dolphindb.cn/zh/funcs/s/stateIterate.html), [conditionalIterate](https://docs.dolphindb.cn/zh/funcs/c/conditionalIterate.html), [genericStateIterate](https://docs.dolphindb.cn/zh/funcs/g/genericStateIterate.html), [genericTStateIterate](https://docs.dolphindb.cn/zh/funcs/g/genericTStateIterate.html)\n\n**Note:** [talib](https://docs.dolphindb.cn/zh/funcs/ho_funcs/talib.html) 作为状态函数时，第一个参数 *func* 只能是响应式状态引擎支持的状态函数。\n\n有关更多流数据引擎的应用场景说明，参考：[内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)。\n\n#### 计算规则\n\n每注入一条数据都会计算并产生一条结果。用户可以通过设置参数 *filter* 过滤计算结果后输出。 若指定了 *keyColumn* 进行分组，则计算将在组内进行。\n\n**Note:** 状态引擎的输出结果可能和输入顺序不一致，建议配置参数 *keepOrder* = true，保持输出结果的有序性。\n\n#### 引擎的其它功能\n\n* 支持数据/状态清理：状态引擎内部的状态数据是按分组保存的，为避免分组过多，导致引擎内部内存开销过大，可以将历史分组数据进行清理。用户可以通过配置参数 *keyPurgeFilter* 设置清理条件，配置 *keyPurgeFreqInSecond* 设置清理时间间隔。\n* 快照机制：启用快照机制之后，系统若出现异常，可及时将流数据引擎恢复到最新的快照状态。（详情请参考 *snapshotDir* 和 *snapshotIntervalInMsgCount* 的参数说明）\n* 流数据引擎高可用：若要启用引擎高可用，需在订阅端 raft 组的 leader 节点创建引擎并通过 *raftGroup* 参数开启高可用。开启高可用后，当 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。\n\n#### 参数\n\n**name** 字符串标量，表示响应式状态引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**metrics** 以元代码的形式表示计算公式，可以是一个或多个表达式、系统内置或用户自定义函数、一个常量标量/向量。当指定为常量向量时，对应的输出列应该设置为数组向量类型。有关元代码的详情可参考 [Metaprogramming](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。若需使用用户自定义函数，请注意以下两点：\n\n1. 需在定义前添加声明 \"@state\"。状态函数只能包含赋值语句和 return 语句。\n\n   自 2.00.9 版本起，支持使用 if-else 条件语句，且条件只能是标量。\n\n   自2.00.11 版本起，支持使用 for 循环（包含 break, continue 语句），请注意不支持嵌套 for 循环，且循环次数须小于 100 次。\n\n2. 状态引擎中可以使用无状态函数或者状态函数。但不允许在无状态函数中嵌套使用状态函数。\n\n3. 若赋值语句的右值是一个多返回值的函数（内置函数或自定义函数），则需要将多个返回值同时赋予多个变量。例如：两个返回值的函数 linearTimeTrend 应用于自定义状态函数中，正确写法为：\n\n```\n@state\ndef forcast2(S, N){\n      linearregIntercept, linearregSlope = linearTimeTrend(S, N)\n      return (N - 1) * linearregSlope + linearregIntercept\n}\n```\n\n**dummyTable** 一个表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。\n\n**outputTable** 计算结果的输出表，可以是内存表或分布式表。使用 `createReactiveStateEngine` 函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。响应式状态引擎会将计算结果注入该表。输出表的各列的顺序如下：\n\n1. 分组列。若指定 *keyColumn*，则根据 *keyColumn* 的设置，输出表的前几列必须和 *keyColumn* 设置的列及其顺序保持一致。\n2. 耗时列和记录数。若指定 *outputElapsedMicroseconds* = true，则需要指定一个 LONG 类型和一个 INT 类型的列，分别用于存储引擎内部每个 batch 的数据耗时（单位：微秒）和记录数。\n3. 计算结果列。可为多列。\n\n**keyColumn** 可选参数，字符串标量或向量表示分组列名。若指定该参数，计算将在各分组进行。\n\n**filter** 可选参数，以元代码的形式表示过滤条件。过滤条件只能是一个表达式，并且只能包含 *dummyTable*中的列。设置多个条件时，用逻辑运算符（and, or）连接。引擎会先计算指标，然后根据 *filter*指定的过滤条件，输出满足条件的输入数据对应的计算结果。\n\n若要开启快照机制（snapshot），必须指定 *snapshotDir* 与 *snapshotIntervalInMsgCount*。\n\n**snapshotDir** 可选参数，字符串，表示保存引擎快照的文件目录。\n\n* 指定的目录必须存在，否则系统会提示异常。\n* 创建流数据引擎时，如果指定了 *snapshotDir*，会检查该目录下是否存在快照。如果存在，会加载该快照，恢复引擎的状态。\n* 多个引擎可以指定同一个目录存储快照，用引擎的名称来区分快照文件。\n* 一个引擎的快照可能会使用三个文件名：\n  * 临时存储快照信息：文件名为 *\\<engineName>.tmp*；\n  * 快照生成并刷到磁盘：文件保存为 *\\<engineName>.snapshot*；\n  * 存在同名快照：旧快照自动重命名为 *\\<engineName>.old*。\n\n**snapshotIntervalInMsgCount** 可选参数，为整数类型，表示每隔多少条数据保存一次流数据引擎快照。\n\n**keepOrder** 可选参数，表示输出表数据是否按照输入时的顺序排序。设置 *keepOrder* = true，表示输出表按照输入时的顺序排序。当 *keyColumn* 包含有时间列时，*keyOrder* 默认值为 true，否则默认值为 false。\n\n**keyPurgeFilter** 可选参数，是一个由布尔表达式组成的元代码，表示清理条件。各表达式只能引用 *outputTable* 中的字段。必须指定 *keyColumn* 才能使用该参数。\n\n**keyPurgeFreqInSecond** 正整数，表示触发数据清理需要满足的时间间隔（以秒为单位）。必须指定 *keyColumn* 才能使用该参数。\n\n响应式状态引擎提供了 *keyPurgeFilter*, *keyPurgeFreqInSecond* 两个参数，用来清理不再需要的分组数据。每次数据注入时，系统会依次根据以下条件决定是否触发数据清理：\n\n1. 检测本次数据注入与上一次数据注入的时间间隔是否大于等于 *keyPurgeFreqInSecond* （第一次数据注入时，检测注入时间和引擎创建时间的间隔）；\n2. 若满足上述条件，系统将根据 *keyPurgeFilter* 指定的条件，过滤出待清理的数据；\n3. 若待清理的数据所属的分组数大于等于所有分组数的 10%，则触发清理。\n\n若需要查看清理前后的状态，可以通过调用 [getStreamEngineStat](https://docs.dolphindb.cn/zh/funcs/g/getStreamEngineStat.html) 函数查看 ReactiveStreamEngine 引擎状态的 numGroups 列，来对比响应式状态引擎清理前后分组数的变化。\n\n**raftGroup** 是流数据高可用订阅端 raft 组的 ID (大于1的整数，由流数据高可用相关的配置项 *streamingRaftGroups*\\*指定)。设置该参数表示开启计算引擎高可用。在 leader 节点创建流数据引擎后，会同步在 follower 节点创建该引擎。每次保存的 snapshot 也会同步到 follower。当 raft 组的 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。请注意，若要指定 *raftGroup*，必须同时指定 *snapshotDir*。 若同时有一批数据注入响应式状态引擎，则引擎内部数据是分批进行计算的，每个批次的数据称为一个 batch，每个 batch 包含记录数由系统决定。\n\n**outputElapsedMicroseconds** 布尔值，可选参数，表示是否输出每个 batch 中数据从注入引擎到计算输出的总耗时，以及每个 batch 包含的总记录数，默认为 false。指定参数 *outputElapsedMicroseconds* 后，在定义 *outputTable* 时需要指定耗时列和记录数两列，详见 *outputTable* 参数说明。\n\n**keyCapacity** 正整数，可选参数，表示建表时系统为该表预分配的 key 分组数量，用于调整状态表中 key 的函数。通过该参数的合理设置，能够降低在 key 分组较多时可能出现的延迟。\n\n**parallelism** 不超过63的正整数，可选参数，表示并行计算的工作线程数，默认值为 1。在计算量较大时，合理地调整该参数能够有效利用计算资源，降低计算耗时。\n\n**Note:** *parallelism* 不能超过 min(许可核数, 逻辑核数)-1。\n\n**outputHandler** 一元函数。设置此参数时，引擎计算结束后，不再将计算结果写到输出表，而是会调用此函数处理计算结果。默认值为 NULL，表示仍将结果写到输出表。\n\n**msgAsTable** 布尔标量，表示在设置了参数 outputHandler 时，将引擎的计算结果以表的结构调用函数。默认值为 false，此时将计算结果的每一列作为元素组成元组。\n\n#### 例子\n\n例1.\n\n```\ndef sum_diff(x, y){\n return (x-y)/(x+y)\n}\nfactor1 = <ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) -  ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)>\nshare streamTable(1:0, `sym`time`price, [STRING,DATETIME,DOUBLE]) as tickStream\nshare table(1000:0, `sym`time`factor1, [STRING,DATETIME,DOUBLE]) as result\nrse = createReactiveStateEngine(name=\"reactiveDemo\", metrics =[<time>, factor1], dummyTable=tickStream, outputTable=result, keyColumn=\"sym\", filter=<sym in [\"000001.SH\", \"000002.SH\"]>)\nsubscribeTable(tableName=`tickStream, actionName=\"factors\", handler=tableInsert{rse})\n\ndata1 = table(take(\"000001.SH\", 100) as sym, 2021.02.08T09:30:00 + 1..100 *3 as time, 10+cumsum(rand(0.1, 100)-0.05) as price)\ndata2 = table(take(\"000002.SH\", 100) as sym, 2021.02.08T09:30:00 + 1..100 *3 as time, 20+cumsum(rand(0.2, 100)-0.1) as price)\ndata3 = table(take(\"000003.SH\", 100) as sym, 2021.02.08T09:30:00 + 1..100 *3 as time, 30+cumsum(rand(0.3, 100)-0.15) as price)\ndata = data1.unionAll(data2).unionAll(data3).sortBy!(`time)\n\nreplay(inputTables=data, outputTables=tickStream, timeColumn=`time)\n```\n\n查看结果表 *result*，可见只有过滤条件中的 \"000001.SH\" 与 \"000002.SH\" 这两只股票的计算结果被输出。\n\n若要重复调试以上代码，需要先执行以下代码。\n\n```\nunsubscribeTable(tableName=`tickStream, actionName=\"factors\")\ndropStreamEngine(`reactiveDemo)\nundef(`tickStream, SHARED)\n```\n\n例2. *keyColumn* 设置以股票和日期进行分组计算，并设置输出时间在 \"2012.01.01\" 和\"2012.01.03\" 之间的计算结果。\n\n```\nshare streamTable(1:0, `date`time`sym`market`price`qty, [DATE, TIME, SYMBOL, CHAR, DOUBLE, INT]) as trades\nshare table(100:0, `date`sym`factor1, [DATE, STRING, DOUBLE]) as outputTable\nengine = createReactiveStateEngine(name=\"test\", metrics=<mavg(price, 3)>, dummyTable=trades, outputTable=outputTable, keyColumn=[\"date\",\"sym\"], filter=<date between 2012.01.01 : 2012.01.03>, keepOrder=true)\nsubscribeTable(tableName=`trades, actionName=\"test\", msgAsTable=true, handler=tableInsert{engine})\n\nn=100\ntmp = table(rand(2012.01.01..2012.01.10, n) as date, rand(09:00:00.000..15:59:59.999, n) as time, rand(\"A\"+string(1..10), n) as sym, rand(['B', 'S'], n) as market, rand(100.0, n) as price, rand(1000..2000, n) as qty)\ntrades.append!(tmp)\nselect * from outputTable\n\n//若要重复调试以上代码，需要先执行以下代码\nunsubscribeTable(tableName=`trades, actionName=\"test\")\ndropStreamEngine(`test)\nundef(`trades, SHARED)\n```\n\n例3. 2.00.9 版本后，支持在响应式状态引擎中调用 `moving` 高阶函数计算 array vector。\n\n```\ndefg myFactor(x){\n   return avg(var(x));\n}\nshare streamTable(1:0, `DateTime`SecurityID`Trade, [TIMESTAMP, SYMBOL, DOUBLE[]]) as tickStream\nshare table(1000:0, `SecurityID`DateTime`result, [SYMBOL, DATETIME, DOUBLE]) as result\nrse = createReactiveStateEngine(name=\"reactiveDemo\", metrics =<[DateTime, moving(myFactor, Trade, 3, 1)]>, dummyTable=tickStream, outputTable=result, keyColumn=\"SecurityID\")\nDateTime = 2022.09.15T09:00:00.000+1..12\nSecurityID = take(`600021, 12)\nTrade = [[10.06, 10.06], [10.04], [10.05, 10.06, 10.05, 10.08],[10.02,10.01], [10.06, 10.06, 10.05, 10.05], [10.04], [10.05,10.08, 10.09],[10.02,10.01],[10.06, 10.06, 10.05], [10.04, 10.03], [10.05, 10.06, 10.05, 10.08, 10.09],[10.02]]\nt = table(1:0, `DateTime`SecurityID`Trade, [TIMESTAMP, SYMBOL, DOUBLE[]])\ntableInsert(t, DateTime, SecurityID, Trade)\nrse.append!(t)\nselect * from result\ndropStreamEngine(\"reactiveDemo\")\n```\n\n例4. 本例对例3进行改造，在指标中指定一个常数，表示因子名称。此时，输出表中会包含一个因子名称列。\n\n```\ndefg myFactor(x){\n   return avg(var(x));\n}\nshare streamTable(1:0, `DateTime`SecurityID`Trade, [TIMESTAMP, SYMBOL, DOUBLE[]]) as tickStream\nshare table(1000:0, `SecurityID`DateTime`factorName`result, [SYMBOL, DATETIME, STRING, DOUBLE]) as result\nrse = createReactiveStateEngine(name=\"reactiveDemo\", metrics =<[DateTime,\"factor1\", moving(myFactor, Trade, 3, 1)]>, dummyTable=tickStream, outputTable=result, keyColumn=\"SecurityID\")\nDateTime = 2022.09.15T09:00:00.000+1..12\nSecurityID = take(`600021, 12)\nTrade = [[10.06, 10.06], [10.04], [10.05, 10.06, 10.05, 10.08],[10.02,10.01], [10.06, 10.06, 10.05, 10.05], [10.04], [10.05,10.08, 10.09],[10.02,10.01],[10.06, 10.06, 10.05], [10.04, 10.03], [10.05, 10.06, 10.05, 10.08, 10.09],[10.02]]\nt = table(1:0, `DateTime`SecurityID`Trade, [TIMESTAMP, SYMBOL, DOUBLE[]])\ntableInsert(t, DateTime, SecurityID, Trade)\nrse.append!(t)\nselect * from result\n```\n\n<table id=\"table_ukv_yb2_xbc\"><thead><tr><th>\n\nSecurityID\n\n</th><th>\n\nDateTime\n\n</th><th>\n\nfactorName\n\n</th><th>\n\nresult\n\n</th></tr></thead><tbody><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0001\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0002\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0006\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0004\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0004\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0003\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.001\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0007\n\n</td></tr><tr><td>\n\n600021\n\n</td><td>\n\n2022.09.15 09:00:00\n\n</td><td>\n\nfactor1\n\n</td><td>\n\n0.0004\n\n</td></tr></tbody>\n</table>\n"
    },
    "createReactiveStatelessEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createReactiveStatelessEngine.html",
        "signatures": [
            {
                "full": "createReactiveStatelessEngine(name, metrics, outputTable)",
                "name": "createReactiveStatelessEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    }
                ]
            }
        ],
        "markdown": "### [createReactiveStatelessEngine](https://docs.dolphindb.cn/zh/funcs/c/createReactiveStatelessEngine.html)\n\n\n\n#### 语法\n\ncreateReactiveStatelessEngine(name, metrics, outputTable)\n\n#### 详情\n\n很多时候，数据之间具有很强的依赖关系，某些数据可能依赖于其他数据的最新值。每当所依赖的数据有更新时，希望这些数据可以同步更新。应对此场景，可以使用响应式无状态引擎。\n\n创建一个响应式无状态引擎。该引擎可以定义依赖关系，每当所依赖的数据注入，便会根据最新的所依赖的数据计算出最新结果，将其输出到输出表。\n\n返回一个表对象，向该表写入数据意味着将数据注入引擎。\n\n该表的结构如下\n\n| name        | typeString |\n| ----------- | ---------- |\n| productName | STRING     |\n| metricName  | STRING     |\n| value       | DOUBLE     |\n\n#### 计算规则\n\n引擎每有一批数据注入，会根据参数 metrics 中定义的依赖关系，将任何直接依赖或间接依赖这批数据的数据输出，每次输出的条数等于直接或间接依赖这批数据的变量个数。即使这个变量的值没有改变，也会输出。\n\n#### 参数\n\n**name**字符串标量，表示引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**metrics**字典向量，其中的每一个元素都是一个字典，代表数据间的一个依赖关系，每个字典的结构如下：\n\n* “outputName”->productName:metricName\n* “formula“->\\<A\\*B>\n* “A“->productName:metricName\n* “B“->productName:metricName\n\n其中，键值 outputName 对应的 productName 和 metricName 将分别作为输出表的第一列和第二列；键值 A 和 B 对应的 productName 和 metricName 唯一确定了依赖的数据所在位置，既可以是输入表的数据，也可以是输出表中的数据；键值 formula 对应的元代码，用于表示数据间的依赖关系，上例中 outputName = A \\* B。\n\n**outputTable**输出表，必须为以下结构：\n\n* productName，可以为 STRING 或 SYMBOL 类型。\n* metricName，可以为 STRING 或 SYMBOL 类型。\n* 计算所得指标的值，即 metrics 中 formula 计算得到的结果，可以为 DOUBLE 或 FLOAT 类型。\n\n#### 例子\n\n现有一个窄表，表中信息如下\n\n| productName | metricName | value |\n| ----------- | ---------- | ----- |\n| product\\_A  | factor1    | 1     |\n| product\\_A  | factor2    | 2     |\n| product\\_B  | factor1    | 1     |\n| product\\_B  | value      | 4     |\n| product\\_C  | factor1    | 2     |\n| product\\_C  | value      | 8     |\n\n上表中，product\\_A:factor1, product\\_A:factor2, product\\_B:factor1, product\\_C:factor1 完全由外部输入决定；一些数据依赖其他数据的值 product\\_B:value=product\\_A:factor1+product\\_A:factor2+product\\_B:factor1，product\\_C:value=product\\_B:value\\*product\\_C:factor1\n\n根据以上信息，通过以下脚本创建引擎\n\n```\n// 创建输出表\nnames = `product`metric`value\ntypes = [STRING, STRING, DOUBLE]\noutputTable = table(1:0, names, types)\n\n// 创建 metrics 描述数据间的依赖关系\nmetrics = array(ANY, 0, 0)\nmetric1 = dict(STRING,ANY)\n// 依赖关系 product_B:factor2=product_A:factor1+product_A:factor2+product_B:factor1\nmetric1[\"outputName\"] = `product_B:`value\nmetric1[\"formula\"] = <A+B+C>\nmetric1[\"A\"] = `product_A:`factor1\nmetric1[\"B\"] = `product_A:`factor2\nmetric1[\"C\"] = `product_B:`factor1\nmetrics.append!(metric1)\n// 依赖关系 product_C:value=product_B:value*product_C:factor1\nmetric2 = dict(STRING, ANY)\nmetric2[\"outputName\"] =`product_C:`value\nmetric2[\"formula\"] = <A*B>\nmetric2[\"A\"] = `product_B:`value \nmetric2[\"B\"] = `product_C:`factor1\nmetrics.append!(metric2)\n\n// 创建引擎\nengine1 = createReactiveStatelessEngine(\"engine1\", metrics, outputTable)\n```\n\n每次插入数据，无论插入的数据量有多大，都只会返回一次。\n\n第一次插入2条数据，此时，两个依赖关系所需的数据尚不完整，无法计算得到需要的结果，所以输出表中对应值为空。\n\n```\ninsert into engine1 values([\"product_A\",\"product_A\"],[\"factor1\",\"factor2\"],[1,2])\noutputTable\n```\n\n| product    | metric | value |\n| ---------- | ------ | ----- |\n| product\\_B | value  |       |\n| product\\_C | value  |       |\n\n第二次插入1条数据，此时，第一个依赖关系所需数据已经完整，故得到结果，第二个依赖关系所需数据仍不完整，对应值为空。\n\n```\ninsert into engine1 values(\"product_B\",\"factor1\",1)\noutputTable\n```\n\n| product    | metric | value |\n| ---------- | ------ | ----- |\n| product\\_B | value  |       |\n| product\\_C | value  |       |\n| product\\_B | value  | 4     |\n| product\\_C | value  |       |\n\n第三次插入1条数据，此时，第二个依赖关系所需数据完整，输出对应结果。\n\n```\ninsert into engine1 values(\"product_C\",\"factor1\",2)\noutputTable\n```\n\n| product    | metric | value |\n| ---------- | ------ | ----- |\n| product\\_B | value  |       |\n| product\\_C | value  |       |\n| product\\_B | value  | 4     |\n| product\\_C | value  |       |\n| product\\_C | value  | 8     |\n\n第四次插入1条数据，此时，由于数据被修改，依赖此数据的相关数据均会受到影响，并将更新后的结果输出。\n\n```\ninsert into engine1 values(\"product_C\",\"factor1\",3)\noutputTable\n```\n\n| product    | metric | value |\n| ---------- | ------ | ----- |\n| product\\_B | value  |       |\n| product\\_C | value  |       |\n| product\\_B | value  | 4     |\n| product\\_C | value  |       |\n| product\\_C | value  | 8     |\n| product\\_C | value  | 12    |\n\n注意，数据更新后，即使依赖此数据的相关数据的值最终没有变化，也会将最新结果输出\n\n```\ninsert into engine1 values([\"product_A\",\"product_A\"],[\"factor1\",\"factor2\"],[2,1])\noutputTable\n```\n\n| product    | metric | value |\n| ---------- | ------ | ----- |\n| product\\_B | value  |       |\n| product\\_C | value  |       |\n| product\\_B | value  | 4     |\n| product\\_C | value  |       |\n| product\\_C | value  | 8     |\n| product\\_C | value  | 12    |\n| product\\_B | value  | 4     |\n| product\\_C | value  | 12    |\n\n如果只想获得变量的最新状态，可以创建键值表作为输出表\n\n```\nkt = keyedTable(`product`metric, 1:0, `product`metric`value, [STRING, STRING, DOUBLE])\n```\n"
    },
    "createRuleEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createRuleEngine.html",
        "signatures": [
            {
                "full": "createRuleEngine(name, ruleSets, dummyTable, outputColumns, outputTable, [policy], [ruleSetColumn], [callback])",
                "name": "createRuleEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "ruleSets",
                        "name": "ruleSets"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputColumns",
                        "name": "outputColumns"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[policy]",
                        "name": "policy",
                        "optional": true
                    },
                    {
                        "full": "[ruleSetColumn]",
                        "name": "ruleSetColumn",
                        "optional": true
                    },
                    {
                        "full": "[callback]",
                        "name": "callback",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createRuleEngine](https://docs.dolphindb.cn/zh/funcs/c/createRuleEngine.html)\n\n#### 语法\n\ncreateRuleEngine(name, ruleSets, dummyTable, outputColumns, outputTable, \\[policy], \\[ruleSetColumn], \\[callback])\n\n#### 详情\n\n创建一个规则引擎，支持设置一个包含多个规则的规则集。数据流入引擎时，会根据某一列的值，决定使用规则集中的哪一条规则对此数据进行检测。引擎的规则可以动态增加、删除、修改。例如可以按照维度设置不同的检测规则，实现风控规则的配置。\n\n与异常检测引擎（createAnomalyDetectionEngine）相比：\n\n* 规则引擎是无状态引擎；异常检测引擎是有状态的。\n* 规则引擎可以对不同数据，采用不同的检查规则；异常检测引擎会对所有数据以相同的规则进行检测。\n* 规则引擎可以动态调整检测规则，包括增加、删除和修改；异常检测引擎创建后无法修改。\n* 规则引擎支持设置回调函数，用户可根据检测结果进行相应处理；异常检测引擎不支持设置回调函数。\n\n#### 参数\n\n**name** 是一个字符串，表示引擎名。\n\n**ruleSets** 是一个字典，表示规则集。字典的 key 是 STRING 或 INT 类型，value 是一个包含元代码的元组。如果 key 为NULL，表示此条为默认规则。一个规则集必须包含默认规则。\n\n**dummyTable** 一个表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。\n\n**outputColumns** 一个 STRING 类型向量，表示输入表中需要保留到输出表的列。\n\n**outputTable** 是一个表对象，表示输出表，可以是内存表或者分布式表。其结构为 ***outputColumns*** 指示的列，以及一列规则检查的结果列。当参数 **policy** 设置为 \"shortcut\" 时，最后一列的数据类型为 INT；否则，数据类型为 BOOL 类型。\n\n**policy** 是一个字符串标量，表示规则检查策略。可取以下值：\n\n* \"shortcut\" 是默认值，代表短路逻辑。当检查到任一规则不符合（该规则的计算结果为 false）时，返回对应的 index ，index 从 0 开始；否则返回 NULL。\n\n* \"all\" 检查全部规则，返回一个 BOOL 类型的数组向量，其元素的布尔值是按照规则集 key 对应的规则执行的结果。\n\n**ruleSetColumn** 是一个 STRING 类型标量，为输入表的某一列名，如果没有定义或者输入数据中的该列数据没有命中任何一个规则集，则使用默认规则。\n\n**callback** 是一个函数，其参数为一个表，是引擎输出的一行。若设置此参数，引擎每处理一行，在将引擎处理结果输出到输出表的同时，会将该结果作为入参调用此函数。此参数未设置时，仅将引擎处理结果输出到输出表。\n\n#### 例子\n\n首先\n\n```\n// 设置规则集\nx = [1, 2, NULL]\ny = [ [ < value > 1 > ], [ < price < 2 >, < price > 6 > ], [ < value*price > 10 > ] ]\nruleSets = dict(x, y)\n\n// 创建分布式表，用于回调函数写入数据\ndb = database(\"dfs://temp\", VALUE, 1..3)\nt1 = table(1:0, `sym`value`price, [INT,DOUBLE,DOUBLE])\npt = db.createPartitionedTable(t1,`pt,`sym)\n\n// 创建回调函数，根据检测结果，将数据写入分布式表\ndef writeBack(result){\n    if(result.rule[0]==false){\n        temp = select sym,value,price from result\n        loadTable(\"dfs://temp\",`pt).append!(temp)\n    }\n}\n\n// 创建规则引擎\nnames = `sym`value`price`quantity\ntypes = [INT, DOUBLE, DOUBLE, DOUBLE]\ndummy = table(1:0, names, types)\noutputNames = `sym`value`price`rule\noutputTypes = [INT, DOUBLE, DOUBLE, BOOL[]]\noutputTable = table(10:0, outputNames, outputTypes)\ntest = createRuleEngine(name=\"ruleEngineTest\", ruleSets=ruleSets, dummyTable=dummy, outputColumns=[\"sym\",\"value\",\"price\"], outputTable=outputTable, policy=\"all\", ruleSetColumn=\"sym\", callback=writeBack)\n\n// 分别插入两条 sym=1 的数据，此时会根据规则集 ruleSets 中 key=1 对应的规则，即 value >1 来检测这两条数据\ntest.append!(table(1 as sym, 0 as value, 2 as price, 3 as quantity))\ntest.append!(table(1 as sym, 2 as value, 2 as price, 3 as quantity))\n\n// 分别插入三条 sym=2 的数据，此时会根据规则集 ruleSets 中 key=2 对应的规则，即 price < 2 和 price > 6 来检测这三条数据\ntest.append!(table(2 as sym, 2 as value, 0 as price, 3 as quantity))\ntest.append!(table(2 as sym, 2 as value, 4 as price, 3 as quantity))\ntest.append!(table(2 as sym, 2 as value, 8 as price, 3 as quantity))\n\n// 插入两条 sym=3 的数据，由于规则集 ruleSets 只设置了键值为 1 和 2 的规则，此时会根据规则集中 key=NULL 对应的规则，即 value*price > 10 来检测这两条数据\ntest.append!(table(3 as sym, 2 as value, 3 as price, 3 as quantity))\ntest.append!(table(3 as sym, 2 as value, 6 as price, 3 as quantity))\n\n```\n\n此时的输出表 outputTable 内容如下\n\n| sym | value | price |      rule      |\n| :-: | :---: | :---: | :------------: |\n|  1  |   0   |   2   |    \\[false]    |\n|  1  |   2   |   2   |     \\[true]    |\n|  2  |   2   |   0   |  \\[true,false] |\n|  2  |   2   |   4   | \\[false,false] |\n|  2  |   2   |   8   |  \\[false,true] |\n|  3  |   2   |   3   |    \\[false]    |\n|  3  |   2   |   6   |     \\[true]    |\n\n此时，由回调函数向分布式表 dfs\\://temp/pt 中写入的数据可通过以下语句查看\n\n```\nselect * from loadTable(\"dfs://temp\",\"pt\")\n```\n\n| sym | value | price |\n| :-: | :---: | :---: |\n|  1  |   0   |   2   |\n|  2  |   2   |   4   |\n|  2  |   2   |   8   |\n|  3  |   2   |   3   |\n\n\n\n**Related information**\n\n[updateRule](https://docs.dolphindb.cn/zh/funcs/u/updateRule.html)\n\n[deleteRule](https://docs.dolphindb.cn/zh/funcs/d/deleteRule.html)\n"
    },
    "createSchema": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createSchema.html",
        "signatures": [
            {
                "full": "createSchema(catalog, dbUrl, schema)",
                "name": "createSchema",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    },
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    },
                    {
                        "full": "schema",
                        "name": "schema"
                    }
                ]
            }
        ],
        "markdown": "### [createSchema](https://docs.dolphindb.cn/zh/funcs/c/createSchema.html)\n\n\n\n#### 语法\n\ncreateSchema(catalog, dbUrl, schema)\n\n#### 参数\n\n**catalog** 字符串标量，表示 catalog 的名称。\n\n**dbUrl** 字符串标量，表示数据库的路径。\n\n**schema** 字符串标量，表示数据库对应的 schema 名称。\n\n#### 详情\n\n把指定数据库添加到指定的 catalog 中。\n\n由于数据库的 dbUrl 是全局唯一的，但不同 catalog 中的 schema 可以重名。因此需要先将数据库和 dbUrl 进行解耦。然后在将指定数据库添加到指定 catalog 时，需要为该数据库指定一个 schema 名称（类似该数据库的别名）。在后续 catalog 的相关操作中，都将使用该数据库的 schema 名称而非 dbUrl。\n\n注意：不支持将数据库同时加到两个 catalog 中。\n\n#### 例子\n\n```\ncreateSchema(\"catalog1\", \"dfs://db1\", \"schema1\")\n```\n"
    },
    "createSessionWindowEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createSessionWindowEngine.html",
        "signatures": [
            {
                "full": "createSessionWindowEngine(name, sessionGap, metrics, dummyTable, outputTable, [timeColumn], [useSystemTime=false], [keyColumn], [updateTime], [useSessionStartTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup], [forceTriggerTime])",
                "name": "createSessionWindowEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "sessionGap",
                        "name": "sessionGap"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[updateTime]",
                        "name": "updateTime",
                        "optional": true
                    },
                    {
                        "full": "[useSessionStartTime=true]",
                        "name": "useSessionStartTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[forceTriggerTime]",
                        "name": "forceTriggerTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createSessionWindowEngine](https://docs.dolphindb.cn/zh/funcs/c/createSessionWindowEngine.html)\n\n\n\n#### 语法\n\ncreateSessionWindowEngine(name, sessionGap, metrics, dummyTable, outputTable, \\[timeColumn], \\[useSystemTime=false], \\[keyColumn], \\[updateTime], \\[useSessionStartTime=true], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[raftGroup], \\[forceTriggerTime])\n\n#### 详情\n\n创建流数据会话窗口引擎。\n\n`createSessionWindowEngine` 的参数绝大多数与 `createTimeSeriesEngine` 一样，只有 *sessionGap* 和 *useSessionStartTime* 是它独有的参数。*sessionGap* 决定了一个会话窗口何时结束，*useSessionStartTime* 决定了输出表时间列的时间为各个窗口的起始时刻还是结束时刻。\n\n更多流数据引擎的应用场景说明可以参考 [内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)。\n\n自 2.00.11 版本开始，*dummyTable* 和 *outputTable*支持 array vector，但不支持在计算中使用 array vector，即 *metrics* 中不能包含 array vector 列。\n\n#### 计算规则\n\n若某条数据之后，经过 *sessionGap* 指定的时间长度内，没有新数据到来，就进行一次窗口截断（以截断前最后一条数据的时间戳 + *sessionGap* 作为窗口的结束时刻）。窗口结束后新到来的一条数据将触发该窗口的计算。\n\n**Note:** 若指定了 *keyColumn*，则按照分组分别进行窗口计算。\n\n#### 参数\n\n由于会话窗口引擎的绝大多数参数与时间序列引擎重合，请参照 [createTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesEngine.html) 中参数介绍。这里仅介绍与时间序列引擎不同的参数：\n\n**sessionGap** 必选参数，正整数标量，是判断窗口结束的时间指标，表示某条数据到来后若等待该时间仍无更新的数据到来，就终止当前窗口。此参数的时间精度取决于 *useSystemTime* 参数。\n\n**useSessionStartTime**: 可选参数，布尔值，默认值为 true，表示输出表中的时刻是否为数据窗口起始时刻，即每个窗口中第一条数据的时间戳。若设置为 false，则表示输出表中的时刻为数据窗口结束时刻，即每个窗口中最后一条数据的时刻+ *sessionGap*。如果指定 *updateTime* ，*useSessionStartTime* 必须为 true。\n\n**forceTriggerTime** 可选参数，非负整数，单位与 *timeColumn* 的时间精度一致。该参数仅在设置 *useSystemTime* = false 时起效。当系统收到最后一条数据后，经过 *forceTriggerTime* 时间，将强制触发未计算的窗口进行计算。\n\n**Note:** 若设置了 *keyColumn*，则各分组内进行上述操作。\n\n#### 例子\n\n```\nshare streamTable(1000:0, `time`sym`volume, [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(10000:0, `time`sym`sumVolume, [TIMESTAMP, SYMBOL, INT]) as output1\nengine_sw = createSessionWindowEngine(name = \"engine_sw\", sessionGap = 5, metrics = <sum(volume)>, dummyTable = trades, outputTable = output1, timeColumn = `time, keyColumn=`sym)\nsubscribeTable(tableName=\"trades\", actionName=\"append_engine_sw\", offset=0, handler=append!{engine_sw}, msgAsTable=true)\n\nn = 5\ntimev = 2018.10.12T10:01:00.000 + (1..n)\nsymv=take(`A`B`C,n)\nvolumev = (1..n)%1000\ninsert into trades values(timev, symv, volumev)\n\nn = 5\ntimev = 2018.10.12T10:01:00.010 + (1..n)\nvolumev = (1..n)%1000\nsymv=take(`A`B`C,n)\ninsert into trades values(timev, symv, volumev)\n\nn = 6\ntimev = 2018.10.12T10:01:00.020 + 1 2 3 8 14 20\nvolumev = (1..n)%1000\nsymv=take(`A`B`C,n)\ninsert into trades values(timev, symv, volumev)\n\nselect * from output1;\n```\n\n输出返回：\n\n| time                    | sym | volume |\n| ----------------------- | --- | ------ |\n| 2018.10.12T10:01:00.001 | A   | 5      |\n| 2018.10.12T10:01:00.002 | B   | 7      |\n| 2018.10.12T10:01:00.003 | C   | 3      |\n| 2018.10.12T10:01:00.011 | A   | 5      |\n| 2018.10.12T10:01:00.012 | B   | 7      |\n| 2018.10.12T10:01:00.013 | C   | 3      |\n| 2018.10.12T10:01:00.021 | A   | 1      |\n| 2018.10.12T10:01:00.022 | B   | 2      |\n| 2018.10.12T10:01:00.023 | C   | 3      |\n\n指定 *forceTriggerTime* 为 1000 ms，收到最后一条消息后，经过 1000 ms，触发所有分组数据计算输出。用以下代码替换上述引擎创建部分的代码。\n\n```\nengine_sw = createSessionWindowEngine(name = \"engine_sw\", sessionGap = 5, metrics = <sum(volume)>, dummyTable = trades, outputTable = output1, timeColumn = `time, keyColumn=`sym, forceTriggerTime=1000)\n```\n\n再次查询输出表，可以得到以下结果：\n\n| time                    | sym | volume |\n| ----------------------- | --- | ------ |\n| 2018.10.12T10:01:00.001 | A   | 5      |\n| 2018.10.12T10:01:00.002 | B   | 7      |\n| 2018.10.12T10:01:00.003 | C   | 3      |\n| 2018.10.12T10:01:00.011 | A   | 5      |\n| 2018.10.12T10:01:00.012 | B   | 7      |\n| 2018.10.12T10:01:00.013 | C   | 3      |\n| 2018.10.12T10:01:00.021 | A   | 1      |\n| 2018.10.12T10:01:00.022 | B   | 2      |\n| 2018.10.12T10:01:00.023 | C   | 3      |\n| 2018.10.12T10:01:00.028 | A   | 4      |\n| 2018.10.12T10:01:00.034 | B   | 5      |\n| 2018.10.12T10:01:00.040 | C   | 6      |\n"
    },
    "createSnapshotJoinEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createsnapshotjoinengine.html",
        "signatures": [
            {
                "full": "createSnapshotJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, [timeColumn], [outputElapsedMicroseconds=false], [keepLeftDuplicates=false], [keepRightDuplicates=false], [isInnerJoin=true])",
                "name": "createSnapshotJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keepLeftDuplicates=false]",
                        "name": "keepLeftDuplicates",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keepRightDuplicates=false]",
                        "name": "keepRightDuplicates",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[isInnerJoin=true]",
                        "name": "isInnerJoin",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [createSnapshotJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createsnapshotjoinengine.html)\n\n\n\n#### 语法\n\ncreateSnapshotJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, \\[timeColumn], \\[outputElapsedMicroseconds=false], \\[keepLeftDuplicates=false], \\[keepRightDuplicates=false], \\[isInnerJoin=true])\n\n#### 详情\n\n创建流数据表的快照连接引擎。该引擎以*matchingColumn*作为连接列，将两个流数据表进行实时的内连接（等值连接）或外连接（左/右连接）。\n\n\\*\\*返回值：\\*\\*返回一个左、右两表连接后的表对象。\n\n**连接行为**\n\n由 *isInnerJoin* 参数决定连接方式：\n\n* 当 *isInnerJoin*=true 时，进行内连接，即每次数据注入引擎左表时，会在右表中查找与连接列字段相匹配的记录，匹配成功才会将两表匹配的记录进行连接，并计算 *metrics* 后输出。每次数据注入引擎右表时，亦会做同样操作。\n\n* 当 *isInnerJoin*=false 时，进行外连接，即每次数据注入引擎左表时，与右表进行左连接。无论在右表中是否找到匹配的记录，都会计算 *metrics* 并输出（右表未匹配的记录输出空值）。每次数据注入引擎右表时，亦会做同样操作。\n\n* 当 keepLeftDuplicates=false 时，仅与左表中根据 *matchingColumn* 分组后的最新一条数据进行匹配连接。当 keepLeftDuplicates=true 时，与左表所有数据进行匹配连接。\n\n* 当 keepRightDuplicates=false 时，仅与右表中根据 *matchingColumn* 分组后的最新一条数据进行匹配连接。当 keepRightDuplicates=true 时，与右表所有数据进行匹配连接。\n\nSnapshot Join 引擎与 Lookup Join、Equi Join 引擎很相似，主要区别如下：\n\n* Lookup join 引擎由左表的新记录触发连接；而 Snapshot Join 引擎可以由左表/右表的新记录触发连接。\n\n* Equi Join 引擎仅匹配最新记录，且没有缓存；而 Snapshot Join 引擎可以选择与右表/左表所有记录或最新记录进行匹配，且有缓存。\n\n#### 参数\n\n**name**：字符串标量，表示 Snapshot join 引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**leftTable**：表对象，表示左表，其结构必须与订阅的流数据表相同。\n\n**rightTable**：表对象，表示右表，其结构必须与订阅的流数据表相同。\n\n**outputTable**：计算结果的输出表。在使用 `createSnapshotJoinEngine` 函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。\n\n输出表的各列的顺序如下：\n\n1. 连接列。与 *matchingColumn* 中的列以及其顺序一致，可为多列。\n\n2. 时间列。两列，分别为左表和右表的时间列。如果指定了 *timeColumn*，则数据类型与 *timeColumn* 列一致；否则，数据类型为 TIMESTAMP。\n\n3. 计算结果列。可为多列。\n\n4. 耗时列。如果指定 *outputElapsedMicroseconds* = true，则指定一个 LONG 类型的列用于记录单次响应计算耗时（单位：微秒）。\n\n5. batchSize 列。如果指定 *outputElapsedMicroseconds* = true, 则指定一个INT类型的列，记录单次响应的数据条数。\n\n**metrics**：以元代码的格式表示计算指标，支持输入元组。有关元代码的更多信息可参考 [Metaprogramming](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n* 计算指标可以是一个或多个表达式、系统内置或用户自定义函数，但不能是聚合函数。\n\n* *metrics* 内支持调用具有多个返回值的函数，且必须指定列名，例如 \\<func(price) as \\`col1\\`col2>。\n\n* 若在 *metrics* 指定了 *leftTable* 和 *rightTable* 中具有相同名称的列，默认取左表的列，可以通过 \"tableName.colName\" 指定该列来自哪个表。\n\n  **注：** *metrics* 中使用的列名大小写不敏感，不需要与输入表的列名大小写保持一致。\n\n\\*\\*matchingColumn：\\*\\*表示连接列的字符串标量/向量或字符串向量组成的 tuple，支持 Integral, Temporal 或 Literal(UUID 除外)类型。*matchingColumn* 指定规则：\n\n1. 只有一个连接列。当左表和右表的连接列名相同时，*matchingColumn* 是一个字符串标量，否则是一个长度为 2 的 tuple。例如：左表连接列名为 sym，右表连接列名为 sym1，则 *matchingColumn* = \\[\\[\\`sym],\\[\\`sym1]]。\n\n2. 有多个连接列。当左表和右表的连接列名相同时，*matchingColumn* 是一个字符串向量，否则是一个长度为 2 的 tuple。例如：左表连接列名为 timestamp, sym，右表连接列名为 timestamp, sym1，则 *matchingColumn* = \\[\\[\\`timestamp, \\`sym], \\[\\`timestamp,\\`sym1]]。\n\n\\*\\*timeColumn:\\*\\*字符串标量或向量，可选参数。用于指定 leftTable 和 rightTable 中时间列的名称。两表的时间列名称可以不同，但数据类型需保持一致。当 leftTable 和 rightTable 时间列名称相同时，timeColumn 是字符串标量，否则，timeColumn 是长度为2的字符串向量。\n\n**outputElapsedMicroseconds**：布尔值，可选参数，表示是否输出单次响应计算的耗时（从触发计算的数据注入引擎到计算完成的耗时），默认为 false。指定参数 *outputElapsedMicroseconds* 后，在定义 outputTable 时需要在计算结果列后增加一个 LONG 类型的列和 INT 类型的列，详见 *outputTable* 参数说明。\n\n**keepLeftDuplicates**：布尔值，可选参数，表示在进行右连接时，是否匹配左表各分组内的所有数据。\n\n* 若设置为 false（默认值）：仅匹配左表各分组内的最新一条数据。\n\n* 若设置为 true：匹配左表各分组内的所有数据。\n\n**keepRightDuplicates**：布尔值，可选参数，表示在进行左连接时，是否保留右表各分组内的所有数据。\n\n* 若设置为 false（默认值）：仅匹配右表各分组内的最新一条数据。\n\n* 若设置为 true：匹配右表各分组内的所有数据。\n\n\\*\\*isInnerJoin：\\*\\*布尔值，可选参数，表示是否进行内连接。\n\n* 若设置为 true（默认值）：进行内连接，只有左右两表匹配的记录被计算输出。\n\n* 若设置为 false：进行左连接或右连接，保留两个表中的所有记录。对于左右两表中匹配的记录进行计算，而未匹配的记录输出空值。\n\n#### 例子\n\n例1. 不指定 \\*outputElapsedMicroseconds，\\*指定 *isInnerJoin*=true，同时指定 *keepLeftDuplicates*=true，*keepRightDuplicates*=true。此时，引擎进行内连接，且匹配左/右表各分组内的所有数据。\n\n```\n//定义输入、输出表\nshare streamTable(1:0, `timestamp`sym1`id`price`val, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE]) as leftTable\nshare streamTable(1:0, `timestamp`sym2`id`price`qty, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE]) as rightTable\noutput=table(100:0, [\"id\",\"sym\", \"timestamp1\", \"timestamp2\", \"factor1\", \"factor2\"], \n[INT, SYMBOL, TIMESTAMP, TIMESTAMP, DOUBLE, DOUBLE])\n\ntest_metrics = [<val*10>, <qty>]\n// 创建引擎\ntest_engine = createSnapshotJoinEngine(name = \"test_SJE\", leftTable=leftTable, rightTable=rightTable, \noutputTable=output, metrics=test_metrics, matchingColumn = [[\"id\",\"sym1\"],[\"id\",\"sym2\"]], \ntimeColumn = `timestamp, isInnerJoin=true, keepLeftDuplicates=true,keepRightDuplicates=true)\n\n//将左表数据注入引擎\ntimestamp = 2024.10.10T15:12:01.507+1..10\nsym = take([\"a\",\"b\",\"c\",\"d\"],10)\nid = [1,1,2,1,5,2,4,4,1,4]\nprice = [2.53,7.61,8.07,7.87,7.29,9.39,5.98,9.49,9.20,9.17]\nval = [101,108,101,109,104,100,108,100,107,104]\nleft_data = table(timestamp as timestamp,sym as sym1,id as id,price as price,val as val)\nappendForJoin(test_engine,true, left_data)\n\n//将右表数据注入引擎，此时会触发两表进行右连接\ntimestamp = 2024.10.10T15:12:01.507+1..10\nsym = take([\"a\",\"b\",\"c\",\"d\"],10)\nid = [1,2,4,3,5,5,4,2,5,5]\nprice =  [1.08,9.08,9.97,7.60,1.91,6.77,7.81,8.81,0.61,5.92]\nqty =  [208,200,203,202,204,201,206,207,205,205]\nright_data = table(timestamp as timestamp,sym as sym2,id as id,price as price,qty as qty)\nappendForJoin(test_engine,false, right_data)\n\nselect * from output\n```\n\n结果表中将保留左表所有匹配记录。\n\n<table id=\"table_r2l_lbw_bdc\"><thead><tr><th>\n\nid\n\n</th><th>\n\nsym\n\n</th><th>\n\ntimestamp1\n\n</th><th>\n\ntimestamp2\n\n</th><th>\n\nfactor1\n\n</th><th>\n\nfactor2\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.508\n\n</td><td>\n\n2024.10.10T15:12:01.508\n\n</td><td>\n\n1,010\n\n</td><td>\n\n208\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.516\n\n</td><td>\n\n2024.10.10T15:12:01.508\n\n</td><td>\n\n1,070\n\n</td><td>\n\n208\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\nb\n\n</td><td>\n\n2024.10.10T15:12:01.513\n\n</td><td>\n\n2024.10.10T15:12:01.509\n\n</td><td>\n\n1,000\n\n</td><td>\n\n200\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nc\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n2024.10.10T15:12:01.510\n\n</td><td>\n\n1,080\n\n</td><td>\n\n203\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n1,040\n\n</td><td>\n\n204\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nc\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n1,080\n\n</td><td>\n\n206\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n2024.10.10T15:12:01.516\n\n</td><td>\n\n1,040\n\n</td><td>\n\n205\n\n</td></tr></tbody>\n</table>例2. 不指定 *outputElapsedMicroseconds*，指定 *isInnerJoin*=true，*keepLeftDuplicate*s=false，*keepRightDuplicates*=true。此时，引擎进行内连接，且匹配左表各分组内的最新一条数据。\n\n```\n//首先取消上例中定义的引擎\ndropStreamEngine(\"test_SJE\")\n\n//定义输入、输出表\nshare streamTable(1:0, `timestamp`sym1`id`price`val, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE]) as leftTable\nshare streamTable(1:0, `timestamp`sym2`id`price`qty, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE]) as rightTable\noutput=table(100:0, [\"id\",\"sym\", \"timestamp1\", \"timestamp2\", \"factor1\", \"factor2\"], \n[INT, SYMBOL, TIMESTAMP, TIMESTAMP, DOUBLE, DOUBLE])\n\ntest_metrics = [<val*10>, <qty>]\n// 创建引擎\ntest_engine = createSnapshotJoinEngine(name = \"test_SJE\", leftTable=leftTable, rightTable=rightTable, \noutputTable=output, metrics=test_metrics, matchingColumn = [[\"id\",\"sym1\"],[\"id\",\"sym2\"]], \ntimeColumn = `timestamp, isInnerJoin=true, keepLeftDuplicates=false,keepRightDuplicates=true)\n\n//将左表数据注入引擎\ntimestamp = 2024.10.10T15:12:01.507+1..10\nsym = take([\"a\",\"b\",\"c\",\"d\"],10)\nid = [1,1,2,1,5,2,4,4,1,4]\nprice = [2.53,7.61,8.07,7.87,7.29,9.39,5.98,9.49,9.20,9.17]\nval = [101,108,101,109,104,100,108,100,107,104]\nleft_data = table(timestamp as timestamp,sym as sym1,id as id,price as price,val as val)\nappendForJoin(test_engine,true, left_data)\n\n//将右表数据注入引擎，此时会触发两表进行右连接\ntimestamp = 2024.10.10T15:12:01.507+1..10\nsym = take([\"a\",\"b\",\"c\",\"d\"],10)\nid = [1,2,4,3,5,5,4,2,5,5]\nprice =  [1.08,9.08,9.97,7.60,1.91,6.77,7.81,8.81,0.61,5.92]\nqty =  [208,200,203,202,204,201,206,207,205,205]\nright_data = table(timestamp as timestamp,sym as sym2,id as id,price as price,qty as qty)\nappendForJoin(test_engine,false, right_data)\n\nselect * from output\n```\n\n结果表中仅保留左表每个分组中的最新记录，因此比例1中的结果少了一行记录。\n\n<table id=\"table_l3p_pbw_bdc\"><thead><tr><th>\n\nid\n\n</th><th>\n\nsym\n\n</th><th>\n\ntimestamp1\n\n</th><th>\n\ntimestamp2\n\n</th><th>\n\nfactor1\n\n</th><th>\n\nfactor2\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.516\n\n</td><td>\n\n2024.10.10T15:12:01.508\n\n</td><td>\n\n1,070\n\n</td><td>\n\n208\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\nb\n\n</td><td>\n\n2024.10.10T15:12:01.513\n\n</td><td>\n\n2024.10.10T15:12:01.509\n\n</td><td>\n\n1,000\n\n</td><td>\n\n200\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nc\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n2024.10.10T15:12:01.510\n\n</td><td>\n\n1,080\n\n</td><td>\n\n203\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n1,040\n\n</td><td>\n\n204\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nc\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n1,080\n\n</td><td>\n\n206\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n2024.10.10T15:12:01.516\n\n</td><td>\n\n1,040\n\n</td><td>\n\n205\n\n</td></tr></tbody>\n</table>例3. 不指定 *outputElapsedMicroseconds*，指定 *isInnerJoin*=false，*keepLeftDuplicates*=false，*keepRightDuplicates*=true。此时，引擎进行左连接或右连接。在左连接时，匹配右表各分组内的所有数据；在进行右连接时，仅匹配左表各分组内的最新一条数据。\n\n```\n//首先取消上例中定义的引擎\ndropStreamEngine(\"test_SJE\")\n\n//定义输入、输出表\nshare streamTable(1:0, `timestamp`sym1`id`price`val, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE]) as leftTable\nshare streamTable(1:0, `timestamp`sym2`id`price`qty, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE]) as rightTable\noutput=table(100:0, [\"id\",\"sym\", \"timestamp1\", \"timestamp2\", \"factor1\", \"factor2\"], \n[INT, SYMBOL, TIMESTAMP, TIMESTAMP, DOUBLE, DOUBLE])\n\ntest_metrics = [<val*10>, <qty>]\n// 创建引擎\ntest_engine = createSnapshotJoinEngine(name = \"test_SJE\", leftTable=leftTable, rightTable=rightTable, \noutputTable=output, metrics=test_metrics, matchingColumn = [[\"id\",\"sym1\"],[\"id\",\"sym2\"]], \ntimeColumn = `timestamp, isInnerJoin=false, keepLeftDuplicates=false,keepRightDuplicates=true)\n\n//将左表数据注入引擎\ntimestamp = 2024.10.10T15:12:01.507+1..10\nsym = take([\"a\",\"b\",\"c\",\"d\"],10)\nid = [1,1,2,1,5,2,4,4,1,4]\nprice = [2.53,7.61,8.07,7.87,7.29,9.39,5.98,9.49,9.20,9.17]\nval = [101,108,101,109,104,100,108,100,107,104]\nleft_data = table(timestamp as timestamp,sym as sym1,id as id,price as price,val as val)\nappendForJoin(test_engine,true, left_data)\n\n//将右表数据注入引擎，此时会触发两表进行右连接\ntimestamp = 2024.10.10T15:12:01.507+1..10\nsym = take([\"a\",\"b\",\"c\",\"d\"],10)\nid = [1,2,4,3,5,5,4,2,5,5]\nprice =  [1.08,9.08,9.97,7.60,1.91,6.77,7.81,8.81,0.61,5.92]\nqty =  [208,200,203,202,204,201,206,207,205,205]\nright_data = table(timestamp as timestamp,sym as sym2,id as id,price as price,qty as qty)\nappendForJoin(test_engine,false, right_data)\n\nselect * from output\n```\n\n由于引擎进行了右连接，仅保留左表每个分组中的最新记录。\n\n<table id=\"table_ok4_vbw_bdc\"><thead><tr><th>\n\nid\n\n</th><th>\n\nsym\n\n</th><th>\n\ntimestamp1\n\n</th><th>\n\ntimestamp2\n\n</th><th>\n\nfactor1\n\n</th><th>\n\nfactor2\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.508\n\n</td><td>\n\n1,010\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\nb\n\n</td><td>\n\n2024.10.10T15:12:01.509\n\n</td><td>\n\n1,080\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\nc\n\n</td><td>\n\n2024.10.10T15:12:01.510\n\n</td><td>\n\n1,010\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\nd\n\n</td><td>\n\n2024.10.10T15:12:01.511\n\n</td><td>\n\n1,090\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n1,040\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\nb\n\n</td><td>\n\n2024.10.10T15:12:01.513\n\n</td><td>\n\n1,000\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nc\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n1,080\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nd\n\n</td><td>\n\n2024.10.10T15:12:01.515\n\n</td><td>\n\n1,000\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.516\n\n</td><td>\n\n1,070\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nb\n\n</td><td>\n\n2024.10.10T15:12:01.517\n\n</td><td>\n\n1,040\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.516\n\n</td><td>\n\n2024.10.10T15:12:01.508\n\n</td><td>\n\n1,070\n\n</td><td>\n\n208\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\nb\n\n</td><td>\n\n2024.10.10T15:12:01.513\n\n</td><td>\n\n2024.10.10T15:12:01.509\n\n</td><td>\n\n1,000\n\n</td><td>\n\n200\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nc\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n2024.10.10T15:12:01.510\n\n</td><td>\n\n1,080\n\n</td><td>\n\n203\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\nd\n\n</td><td>\n\n2024.10.10T15:12:01.511\n\n</td><td>\n\n202\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n1,040\n\n</td><td>\n\n204\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\nb\n\n</td><td>\n\n2024.10.10T15:12:01.513\n\n</td><td>\n\n201\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nc\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n1,080\n\n</td><td>\n\n206\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\nd\n\n</td><td>\n\n2024.10.10T15:12:01.515\n\n</td><td>\n\n207\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n2024.10.10T15:12:01.516\n\n</td><td>\n\n1,040\n\n</td><td>\n\n205\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\nb\n\n</td><td>\n\n2024.10.10T15:12:01.517\n\n</td><td>\n\n205\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr></tbody>\n</table>例4. 指定 *outputElapsedMicroseconds* = true，输出耗时列和 batchSize 列。\n\n```\n//首先取消上例中定义的引擎\ndropStreamEngine(\"test_SJE\")\n\n//定义输入、输出表\nshare streamTable(1:0, `timestamp`sym1`id`price`val, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE]) as leftTable\nshare streamTable(1:0, `timestamp`sym2`id`price`qty, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE]) as rightTable\noutput=table(100:0, [\"id\",\"sym\", \"timestamp1\", \"timestamp2\", \"factor1\", \"factor2\", \"timecost\",\"batchsize\"],\n[INT, SYMBOL, TIMESTAMP, TIMESTAMP, DOUBLE, DOUBLE, LONG, INT])\n\ntest_metrics = [<val*10>, <qty>]\n// 创建引擎\ntest_engine = createSnapshotJoinEngine(name = \"test_SJE\", leftTable=leftTable, rightTable=rightTable, \noutputTable=output, metrics=test_metrics, matchingColumn = [[\"id\",\"sym1\"],[\"id\",\"sym2\"]],\ntimeColumn = `timestamp, outputElapsedMicroseconds=true, isInnerJoin=true,\nkeepLeftDuplicates=false,keepRightDuplicates=true)\n\n//将左表数据注入引擎\ntimestamp = 2024.10.10T15:12:01.507+1..10\nsym = take([\"a\",\"b\",\"c\",\"d\"],10)\nid = [1,1,2,1,5,2,4,4,1,4]\nprice = [2.53,7.61,8.07,7.87,7.29,9.39,5.98,9.49,9.20,9.17]\nval = [101,108,101,109,104,100,108,100,107,104]\nleft_data = table(timestamp as timestamp,sym as sym1,id as id,price as price,val as val)\nappendForJoin(test_engine,true, left_data)\n\n//将右表数据注入引擎，此时会触发两表进行右连接\ntimestamp = 2024.10.10T15:12:01.507+1..10\nsym = take([\"a\",\"b\",\"c\",\"d\"],10)\nid = [1,2,4,3,5,5,4,2,5,5]\nprice =  [1.08,9.08,9.97,7.60,1.91,6.77,7.81,8.81,0.61,5.92]\nqty =  [208,200,203,202,204,201,206,207,205,205]\nright_data = table(timestamp as timestamp,sym as sym2,id as id,price as price,qty as qty)\nappendForJoin(test_engine,false, right_data)\n\nselect * from output\n```\n\n<table id=\"table_gcx_zbw_bdc\"><thead><tr><th>\n\nid\n\n</th><th>\n\nsym\n\n</th><th>\n\ntimestamp1\n\n</th><th>\n\ntimestamp2\n\n</th><th>\n\nfactor1\n\n</th><th>\n\nfactor2\n\n</th><th>\n\ntimecost\n\n</th><th>\n\nbatchsize\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.516\n\n</td><td>\n\n2024.10.10T15:12:01.508\n\n</td><td>\n\n1,070\n\n</td><td>\n\n208\n\n</td><td>\n\n109\n\n</td><td>\n\n10\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\nb\n\n</td><td>\n\n2024.10.10T15:12:01.513\n\n</td><td>\n\n2024.10.10T15:12:01.509\n\n</td><td>\n\n1,000\n\n</td><td>\n\n200\n\n</td><td>\n\n109\n\n</td><td>\n\n10\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nc\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n2024.10.10T15:12:01.510\n\n</td><td>\n\n1,080\n\n</td><td>\n\n203\n\n</td><td>\n\n109\n\n</td><td>\n\n10\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n1,040\n\n</td><td>\n\n204\n\n</td><td>\n\n109\n\n</td><td>\n\n10\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\nc\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n2024.10.10T15:12:01.514\n\n</td><td>\n\n1,080\n\n</td><td>\n\n206\n\n</td><td>\n\n109\n\n</td><td>\n\n10\n\n</td></tr><tr><td>\n\n5\n\n</td><td>\n\na\n\n</td><td>\n\n2024.10.10T15:12:01.512\n\n</td><td>\n\n2024.10.10T15:12:01.516\n\n</td><td>\n\n1,040\n\n</td><td>\n\n205\n\n</td><td>\n\n109\n\n</td><td>\n\n10\n\n</td></tr></tbody>\n</table>\n"
    },
    "createStreamBroadcastEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createstreambroadcastengine.html",
        "signatures": [
            {
                "full": "createStreamBroadcastEngine(name, dummyTable, outputTables)",
                "name": "createStreamBroadcastEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTables",
                        "name": "outputTables"
                    }
                ]
            }
        ],
        "markdown": "### [createStreamBroadcastEngine](https://docs.dolphindb.cn/zh/funcs/c/createstreambroadcastengine.html)\n\n\n\n#### 语法\n\ncreateStreamBroadcastEngine(name, dummyTable, outputTables)\n\n#### 详情\n\n创建流数据广播引擎，将同一份流数据复制后分发至不同的目标表对象。该函数返回一个表对象，通过向该表对象注入数据，实现流数据的多路广播。\n\n该引擎的应用场景是对同一份流数据同时进行不同的处理，例如将拷贝后的一份数据存入磁盘，另一份数据则输入引擎进行后续计算等。\n\n#### 参数\n\n**name** 字符串标量，表示流数据广播引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**dummyTable** 一个表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。\n\n**outputTables** 由2个及以上表对象组成的元组，每个表对象的结构和 dummyTable 相同。表对象可以是内存表、分布式表或流计算引擎。\n\n#### 例子\n\n```\nshare streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream\nshare streamTable(1000:0, `sym`factor1, [STRING,DOUBLE]) as resultStream\n\nt=table(100:0, `sym`price, [STRING, DOUBLE])\n\n//定义将要使用的输出表。这里定义1个状态引擎，1个分布式表用于存储数据\nrse = createReactiveStateEngine(name=\"reactiveDemo\", metrics =<cumavg(price)>, dummyTable=tickStream, outputTable=resultStream, keyColumn=\"sym\")\nif(existsDatabase(\"dfs://database1\")){\n\tdropDatabase(\"dfs://database1\")\n}\ndb=database(\"dfs://database1\", VALUE, \"A\"+string(1..10))\npt=db.createPartitionedTable(t,`pt,`sym)\n\n//定义广播引擎\nbroadcastEngine=createStreamBroadcastEngine(name=\"broadcastEngine\", dummyTable=tickStream, outputTables=[loadTable(\"dfs://database1\", `pt),getStreamEngine(\"reactiveDemo\")])\n\n//订阅流数据表tickStream\nsubscribeTable(tableName=`tickStream, actionName=\"sub\", handler=tableInsert{broadcastEngine}, msgAsTable = true)\n\n//订阅的数据注入引擎\nn=100000\nsymbols=take((\"A\" + string(1..10)),n)\nprices=100+rand(1.0,n)\nt1=table(symbols as sym, prices as price)\ntickStream.append!(t1)\n\n// 查看分布式表中数据有100,000 条\nselect count(*) from loadTable(\"dfs://database1\", `pt)\n// output: 100,000\n\n//查看状态引擎状态\ngetStreamEngineStat().ReactiveStreamEngine\n```\n\n<table id=\"table_xgz_qpr_5bc\"><thead><tr><th>\n\nname\n\n</th><th>\n\nuser\n\n</th><th>\n\nstatus\n\n</th><th>\n\nlastErrMsg\n\n</th><th>\n\nnumGroups\n\n</th><th>\n\nnumRows\n\n</th><th>\n\nnumMetrics\n\n</th><th>\n\nmemoryInUsed\n\n</th><th>\n\nsnapshotDir\n\n</th><th>\n\nsnapshotInterval\n\n</th><th>\n\nsnapshotMsgId\n\n</th><th>\n\nsnapshotTimestamp\n\n</th></tr></thead><tbody><tr><td>\n\nreactiveDemo\n\n</td><td>\n\nadmin\n\n</td><td>\n\nOK\n\n</td><td>\n\n10\n\n</td><td>\n\n100,000\n\n</td><td>\n\n1\n\n</td><td>\n\n2,600\n\n</td><td>\n\n-1\n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td><td>\n\n \n\n</td></tr></tbody>\n</table>\n"
    },
    "createStreamDispatchEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createStreamDispatchEngine.html",
        "signatures": [
            {
                "full": "createStreamDispatchEngine(name, dummyTable, keyColumn, outputTable, [dispatchType='hash'], [hashByBatch=false], [outputLock=true], [queueDepth=4096], [outputElapsedTime=false], [mode='buffer'])",
                "name": "createStreamDispatchEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[dispatchType='hash']",
                        "name": "dispatchType",
                        "optional": true,
                        "default": "'hash'"
                    },
                    {
                        "full": "[hashByBatch=false]",
                        "name": "hashByBatch",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[outputLock=true]",
                        "name": "outputLock",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[queueDepth=4096]",
                        "name": "queueDepth",
                        "optional": true,
                        "default": "4096"
                    },
                    {
                        "full": "[outputElapsedTime=false]",
                        "name": "outputElapsedTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[mode='buffer']",
                        "name": "mode",
                        "optional": true,
                        "default": "'buffer'"
                    }
                ]
            }
        ],
        "markdown": "### [createStreamDispatchEngine](https://docs.dolphindb.cn/zh/funcs/c/createStreamDispatchEngine.html)\n\n\n\n#### 语法\n\ncreateStreamDispatchEngine(name, dummyTable, keyColumn, outputTable, \\[dispatchType='hash'], \\[hashByBatch=false], \\[outputLock=true], \\[queueDepth=4096], \\[outputElapsedTime=false], \\[mode='buffer'])\n\n#### 详情\n\n创建流数据分发引擎，返回一个表对象。该引擎将输入的数据分发到不同的输出表，以实现负载均衡。其中输出表可以是内存表，分布式表或流数据引擎。\n\n引擎特性：\n\n* 支持多线程输入和多线程输出。\n\n* 只提供数据分发功能，不提供指标计算功能。\n\n场景应用：\n\n将快照数据分发给一个或多个计算引擎进行因子计算，以提高计算性能。\n\n#### 参数\n\n**name** 字符串，表示流数据分发引擎的名称，可包含字母，数字和下划线，但必须以字母开头。\n\n**dummyTable** 表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。\n\n**keyColumn** 字符串。若设置，则会以 *dispatchType* 指定的方式，基于该列分发数据。*keyColumn* 列中的每个唯一值被视为一个 key。\n\n**outputTable** 表对象，若 *outputElapsedTime*= false，则 *outputTable* 的表结构和 *dummyTable* 相同；否则 *outputTable* 比 *dummyTable* 在最后多了一个 LONG 类型和一个 INT 类型的列，分别表示每一个 batch 的输出耗时（单位是微秒）及其输出时的时间戳（精度为纳秒）。\n\n可以指定1\\~100个输出表。引擎会为每个表创建一个线程来接收分发到该表的数据。以 tuple 或嵌套 tuple 的方式指定多张表，例如：outputTable=\\[table1, table2, table3, table4]，表示将注入的数据平均分发到4张表中，每张表的数据不同；outputTable=\\[\\[table1\\_1, table1\\_2], \\[table2\\_1, table2\\_2]]，则会将数据拆分并复制。两份副本分别分发到各个子元素中对应的表中。具体来说，副本1的数据分发到 table1\\_1 table1\\_2，副本2的数据分发到 table2\\_1 和 table2\\_2。此时 table1\\_1 和 table2\\_1 除耗时和时间列外，其它列的数据相同；table1\\_2 和 table2\\_2 除耗时和时间列外，其它列的数据相同。\n\n**dispatchType** 可选参数，字符串，可选值为：\n\n* \"hash\"（默认值）：对 *keyColumn* 列进行哈希计算，并根据计算结果，将数据分发到各个输出表。由于哈希计算得到的分布不一定均匀，因此可能会出现数据分配不均的情况。\n\n* \"uniform\"：按照 *keyColumn* 列，将数据均匀分发到各个输出表。\n\n* \"saltedHash\"：对 *keyColumn* 列进行加盐处理，然后进行哈希计算。通过[加盐处理](https://en.wikipedia.org/wiki/Salt_\\(cryptography\\))，可以确保即使输入相同，也能产生独特的哈希值，从而避免碰撞。该选项在需要进行多层哈希分发的场景（例如分发引擎嵌套分发引擎，且都采用哈希计算进行数据分发）中更为适用。\n\n**Tip:** 建议使用默认的分发方式，即 \"hash\"。如果因为哈希分配不均匀而影响性能，则可以尝试使用 \"uniform\" 方式。\n\n**hashByBatch** 可选参数, 布尔类型。该参数决定了是否将一个 batch 中的所有数据输出到同一个表中。默认为 false，表示对一个 batch 中的所有 key 分组后，按照 *dispatchType* 指定的方式分发数据。 仅当 *dispatchType*='hash' 时，才可设置 *hashByBatch*=true，此时，引擎随机取 batch 中一个 key 进行哈希计算，根据计算结果，将该 batch 中的所有数据输出到某一个表。\n\n**Note:** 当 *hashByBatch*=false 时，可以保证相同 key 的数据被输出到同一张表，但是这种分组操作会增加一些开销。\n\n**outputLock** 可选参数，布尔类型，默认值为 true，表示是否对输出表进行加锁以避免并发访问的冲突。若设置为 false，则不对输出表进行加锁，此时需要保证其他线程不会对输出表进行并发操作。一般情况下，建议使用默认值（true）。\n\n当除了分发引擎以外，还有其他线程（比如其他引擎、流订阅等等）写入到输出表时，输出表需要加锁（因为内存表不允许并发写入），但加锁会增加开销。但在某些场景下，例如在输出线程数量大于等于输入线程数量，且能保证多个输入线程不会同时向一个输出线程写入数据的场景下，如果用户能保证只有一个线程写入输出表，则可以设置该参数为 false，即不对输出表加锁，以提高数据分发的性能。\n\n**queueDepth** 可选参数，正整数，默认为4096（单位为行）。\n\n* *mode* = “buffer” 时，表示每个输出线程的缓存表大小。\n\n* *mode* = “queue” 时，表示每个输出线程的队列深度。\n\n建议根据输入数据的记录数大小，适当调节该参数。如果输入数据量较小但该参数设置过大，则会导致内存空间的浪费；相反，如果输入数据量较大但该参数设置过小，可能会导致数据输出阻塞。\n\n**outputElapsedTime** 可选参数，布尔类型，表示是否输出每个 batch 从注入引擎到分发输出的总耗时。默认为 false，不输出总耗时。若设置为 true，则会在输出表最后两列中输出耗时（单位为微秒）和数据输出的时间戳（单位为纳秒）。\n\n**mode** 可选参数，字符串，可选值为：\n\n* \"buffer\"（默认值）：引擎会为每个输出线程创建一个内存缓存表，并将待分发的数据复制到缓存表中。对于数据写入引擎过程中，可能会并发读写输入表，或频繁 append 数据到引擎且每次 append 的数据量较小的场景，建议使用该配置。\n\n* \"queue\"：引擎为每一个输出线程维护一个数据队列，只将输入表的引用加入到分发队列，不复制数据。此配置要求写入数据的过程中不能对输入表进行并发读写，适合不频繁 append 数据到引擎且每次 append 的数据量较大的场景。\n\n#### 例子\n\n通过分发引擎，将流数据表中的数据分发到3个状态引擎，以进行因子计算，最终将结果输出到同一个输出表中。\n\n```\n//定义状态引擎的输入和输出表\nshare streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream\nshare streamTable(1000:0, `sym`factor1, [STRING,DOUBLE]) as resultStream\n//定义将要使用的输出表。这里定义3个状态引擎。\nfor(i in 0..2){\nrse = createReactiveStateEngine(name=\"reactiveDemo\"+string(i), metrics =<cumavg(price)>, dummyTable=tickStream, outputTable=resultStream, keyColumn=\"sym\")\n}\n//定义分发引擎\ndispatchEngine=createStreamDispatchEngine(name=\"dispatchDemo\", dummyTable=tickStream, keyColumn=`sym, outputTable=[getStreamEngine(\"reactiveDemo0\"),getStreamEngine(\"reactiveDemo1\"),getStreamEngine(\"reactiveDemo2\")])\n\n//订阅流数据表tickStream\nsubscribeTable(tableName=`tickStream, actionName=\"sub\", handler=tableInsert{dispatchEngine}, msgAsTable = true)\n\n//订阅的数据注入引擎\nn=100000\nsymbols=take((\"A\" + string(1..10)),n)\nprices=100+rand(1.0,n)\nt=table(symbols as sym, prices as price)\ntickStream.append!(t)\n\n\nselect count(*) from resultStream\n100,000\n\n//查看状态引擎状态\ngetStreamEngineStat().ReactiveStreamEngine\n```\n\n| name         | user  | status | lastErrMsg | numGroups | numRows | numMetrics | metrics | snapshotDir | snapshotInterval | snapshotMsgId | snapshotTimestamp | garbageSize | memoryUsed |\n| ------------ | ----- | ------ | ---------- | --------- | ------- | ---------- | ------- | ----------- | ---------------- | ------------- | ----------------- | ----------- | ---------- |\n| dispatchDemo | admin | OK     | 0          | 100,000   | 0       | 0          | -1      | 0           | 0                |               |                   |             |            |\n"
    },
    "createTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createTable.html",
        "signatures": [
            {
                "full": "createDimensionTable(dbHandle, table, tableName, [compressMethods], [sortColumns\\|primaryKey], [keepDuplicates=ALL], [softDelete=false], [indexes])",
                "name": "createDimensionTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[compressMethods]",
                        "name": "compressMethods",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns\\|primaryKey]",
                        "name": "[sortColumns\\|primaryKey]"
                    },
                    {
                        "full": "[keepDuplicates=ALL]",
                        "name": "keepDuplicates",
                        "optional": true,
                        "default": "ALL"
                    },
                    {
                        "full": "[softDelete=false]",
                        "name": "softDelete",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[indexes]",
                        "name": "indexes",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createTable](https://docs.dolphindb.cn/zh/funcs/c/createTable.html)\n\n是 [createDimensionTable](https://docs.dolphindb.cn/zh/funcs/c/createdimensiontable.html) 的别名。\n\n\n以下是 `createDimensionTable` 函数的文档：\n### [createDimensionTable](https://docs.dolphindb.cn/zh/funcs/c/createdimensiontable.html)\n\n\n\n#### 语法\n\ncreateDimensionTable(dbHandle, table, tableName, \\[compressMethods], \\[sortColumns\\\\|primaryKey], \\[keepDuplicates=ALL], \\[softDelete=false], \\[indexes])\n\n别名：createTable\n\n#### 详情\n\n在分布式数据库中创建一个维度表。维度表是分布式数据库中没有进行分区的表，查询时会将表中所有数据加载到内存，适用于存储不频繁更新的小数据集。\n\n系统会定期检查内存的使用情况，当内存使用超过系统配置参数 *warningMemSize* 设定的阈值时，系统会尝试释放部分缓存。维度表如果长时间未被使用，其占用的内存根据 LRU（Least Recently Used）策略将被释放。用户也可以调用 *clearCachedDatabase* 手动释放维度表的缓存。\n\n维度表与分区表都是根据设置参数 *dfsReplicationFactor* 决定副本的数量。维度表的读写操作也支持事务。\n\n通过在配置项配置 *enableConcurrentDimensionalTableWrite* = true，可以支持对维度表进行并发的写入、修改或删除操作。\n\n#### 参数\n\n**dbHandle** 是 [database](https://docs.dolphindb.cn/zh/funcs/d/database.html) 函数返回的分布式数据库句柄。\n\n**table** 是一个表，系统将根据该表的结构在数据库中创建一个空的维度表。\n\n**tableName** 是一个字符串，表示维度表的名称。\n\n**compressMethods** 一个字典，指定某些列使用 lz4, delta, zstd 或 chimp 压缩算法存储。key 为字段名，value 为压缩算法（\"lz4\", \"delta\", \"zstd\" 或 \"chimp\"）。若未指定，默认采用 lz4 压缩算法。有关 Delta 压缩算法，亦称为 delta-of-delta encoding，参考：[Delta Compression Techniques](http://engineering.nyu.edu/~suel/papers/delta-chap.pdf)。\n\n* 对于 DECIMAL,SHORT, INT, LONG 与时间或日期类型数据，建议采用 Delta 算法压缩。\n* 将字符串存储为 SYMBOL 类型数据，实现对字符串类型的压缩。\n* 对于小数部分长度在三位以内的 DOUBLE 类型的数据，可以考虑使用 chimp 算法压缩。\n\n**sortColumns** 字符串标量或向量，用于指定每一分区内的排序列，每次写入磁盘的数据在每一分区内将按 *sortColumns* 进行排序。系统默认 *sortColumns* （指定多列时） 最后一列为时间列，其余列字段作为排序的索引列，称作 sort key。每一分区内，同一个 sort key 组合值对应的数据将按时间列顺序连续存放在一起。查询时，若查询条件包含索引列，可以快速定位数据所在的数据块位置，提高查询性能。\n\n* 仅当 dbHandle 指示的数据库采用 “TSDB” 引擎（engine=”TSDB”）时，本参数才生效。\n* *sortColumns* 只能是 INTEGER, TEMPORAL, LITERAL 类别（除 BLOB） 或 DECIMAL 类型。\n  * 若 *sortColumns* 指定为多列，则 *sortColumns* 的最后一列必须为时间列，其余列为索引列，且索引列不能为为 TIME, TIMESTAMP, NANOTIME, NANOTIMESTAMP 类型。\n  * 若 *sortColumns* 仅指定一列，则该列作为 sort key，其类型不能为TIME, TIMESTAMP, NANOTIME, NANOTIMESTAMP。若 *sortColumns* 指定为一列时间列 （非分区列），且同时指定了 *sortKeyMappingFunction*，则查询的过滤条件中 *sortColumns* 只能与相同时间类型的值进行比较。\n* 频繁查询的字段适合设置为 *sortColumns*，且建议优先把查询频率高的字段作为 *sortColumns* 中位置靠前的列。\n* 为保证性能最优，建议每个分区内索引列的组合数（sort key）不超过1000个。\n* *sortColumns* 是每个分区内部 level file 内数据的排序依据，与其是否为分区字段无关。\n\n**primaryKey**字符串标量或向量，用于指定主键列。在数据写入操作中，如果主键相同，新的数据覆盖现有数据。\n\n* 仅当*dbHandlei* 指示的数据库采用 “PKEY” 引擎（engine=”PKEY”）时，本参数才生效。\n\n* 主键列必须包含所有的分区列。\n\n* 主键列支持的类型包括：BOOL, CHAR, SHORT, INT, LONG, INT128, STRING, TIME, SECOND, MINUTE, DATE, MONTH, DATEHOUR, DATETIME, SYMBOL, TIMESTAMP, NANOTIME, NANOTIMESTAMP, UUID, COMPLEX, POINT, IPADDR, DECIMAL32, DECIMAL64, DECIMAL128。\n\n**keepDuplicates** 指定在每个分区内如何处理所有 *sortColumns* 之值皆相同的数据。提供以下选项：\n\n* ALL：保留所有数据，为默认值。\n* LAST：仅保留最新数据\n* FIRST：仅保留第一条数据\n\n**softDelete** 用于启用或禁用软删除功能。默认为 false，即禁用。该参数适于在行数多但删除量小的场景下使用。使用该参数需要同时满足以下条件：\n\n* 由TSDB 存储引擎创建的数据库内的表\n\n* *keepDuplicates* 已设置为 LAST\n\n**Note:** 参数 *sortColumns*, *keepDuplicates* 仅在 `database` 的 *engine* 参数指定为 TSDB 时才有效。\n\n**indexes** 为一个字典。当引擎为 PKEY 时，用于为表中的列指定索引。字典的键是 STRING 类型标量，表示列名；值是 STRING 类型标量，表示为该列指定的索引类型。目前支持设置 “bloomfilter” 索引类型：适用于对大基数列进行点查，且基数越大，索引效果越好，如身份证 ID、订单号、从业务上游同步的外键等数据列。目前支持的类型包括 BOOL, CHAR, SHORT, INT, LONG, BLOB, STRING, DECIMAL32, DECIMAL64, DECIMAL128。\n\n**Note:** 引擎会将所有主键列合并为组合主键，并为组合主键设置 bloomfilter 类型索引。\n\n#### 例子\n\n例1\n\n```\ndb=database(\"dfs://db1\",VALUE,1 2 3)\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nt = table(timestamp, sym, qty, price);\n\ndt=db.createDimensionTable(t,`dt).append!(t);\nselect * from dt;\n```\n\n| timestamp | sym | qty  | price  |\n| --------- | --- | ---- | ------ |\n| 09:34:07  | C   | 2200 | 49.6   |\n| 09:36:42  | MS  | 1900 | 29.46  |\n| 09:36:51  | MS  | 2100 | 29.52  |\n| 09:36:59  | MS  | 3200 | 30.02  |\n| 09:32:47  | IBM | 6800 | 174.97 |\n| 09:35:26  | IBM | 5400 | 175.23 |\n| 09:34:16  | C   | 1300 | 50.76  |\n| 09:34:26  | C   | 2500 | 50.32  |\n| 09:38:12  | C   | 8800 | 51.29  |\n\n例2\n\n```\ndb = database(\"dfs://demodb\", VALUE, 1..10)\nt=table(take(1, 86400) as id, 2020.01.01T00:00:00 + 0..86399 as timestamp, rand(1..100, 86400) as val)\ndt = db.createDimensionTable(t, \"dt\", {timestamp:\"delta\", val:\"delta\"})\ndt.append!(t)\n```\n\n例3. TSDB 存储引擎下创建维度表\n\n```\nif(existsDatabase(\"dfs://dbctable_createDimensionTable\")){\n  dropDatabase(\"dfs://dbctable_createDimensionTable\")\n}\ndb = database(\"dfs://dbctable_createDimensionTable\", VALUE, 1..100, , \"TSDB\")\nt1 = table(1 100 100 300 300 400 500 as id, 1..7 as v)\ndb.createDimensionTable(t1, \"dt\", , \"id\").append!(t1)\ndt=loadTable(\"dfs://dbctable_createDimensionTable\",\"dt\")\n```\n\n例4. PKEY 存储引擎下创建维度表\n\n```\ndb = database(directory=\"dfs://PKDB\", partitionType=VALUE, partitionScheme=1..10, engine=\"PKEY\")\nschematb = table(1:0,`id1`id2`val1`val2`date1`time1,[INT,INT,INT,DECIMAL32(2),DATE,TIME])\npkt = createDimensionTable(dbHandle=db, table=schematb, tableName=\"pkt\", primaryKey=`id1`id2, indexes={\"val1\": \"bloomfilter\", \"val2\": \"bloomfilter\"})\n```\n\n**Related information**\n\n[createPartitionedTable](https://docs.dolphindb.cn/zh/funcs/c/createPartitionedTable.html)\n"
    },
    "createTimeBucketEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createtimebucketengine.html",
        "signatures": [
            {
                "full": "createTimeBucketEngine(name,timeCutPoints,metrics,dummyTable,outputTable,timeColumn,[keyColumn],[useWindowStartTime],[closed='left'],[fill='none'],[keyPurgeFreqInSec=-1],[outputElapsedMicroseconds=false],[parallelism=1],[outputHandler=NULL],[msgAsTable=false])",
                "name": "createTimeBucketEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "timeCutPoints",
                        "name": "timeCutPoints"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[useWindowStartTime]",
                        "name": "useWindowStartTime",
                        "optional": true
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[fill='none']",
                        "name": "fill",
                        "optional": true,
                        "default": "'none'"
                    },
                    {
                        "full": "[keyPurgeFreqInSec=-1]",
                        "name": "keyPurgeFreqInSec",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[parallelism=1]",
                        "name": "parallelism",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createTimeBucketEngine](https://docs.dolphindb.cn/zh/funcs/c/createtimebucketengine.html)\n\n\n\n#### 语法\n\ncreateTimeBucketEngine(name,timeCutPoints,metrics,dummyTable,outputTable,timeColumn,\\[keyColumn],\\[useWindowStartTime],\\[closed='left'],\\[fill='none'],\\[keyPurgeFreqInSec=-1],\\[outputElapsedMicroseconds=false],\\[parallelism=1],\\[outputHandler=NULL],\\[msgAsTable=false])\n\n#### 详情\n\n创建一个自定义窗口长度（长度相同或不同）的时间序列聚合引擎。该引擎基于数据时间，按照指定的长度对输入数据进行窗口划分，并在窗口内执行增量聚合计算。通常和时序聚合引擎（createTimeSeriesEngine ）级联使用，接收其输出秒级或分钟级聚合结果（例如 K 线）进行进一步处理。\n\n\\*\\*返回值：\\*\\*返回一个表对象，通过向该表对象写入，将数据注入引擎进行计算。\n\n**窗口**\n\n* 窗口边界：窗口的左、右边界由*timeCutPoints* 向量的任意两个相邻元素确定。\n\n* 边界开闭：由 *closed* 确定边界是左闭右开或者左开右闭。\n\n* 窗口关闭时机：窗口左开右闭时，收到的第一条时间戳大于等于右边界的数据触发窗口关闭；窗口左闭右开时，收到的第一条时间戳大于等于右边界时间戳减1的数据触发窗口关闭。例如，对于窗口 \\[09:00, 09:05)，当第一条数据的时间戳大于等于 09:04 时，窗口关闭。\n\n* 窗口输出时间戳：窗口输出时间戳的精度同 *timeColumn*。若 *useWindowStartTime* = true，显示为窗口起始时间；反之，显示时间为数据窗口终止时间。\n\n**计算**\n\n* 参与计算的数据时间范围：*timeCutPoints* 向量中第一个元素和最后一个元素确定的时间范围内的数据会参与计算。该向量的时间精度决定了计算窗口的时间精度。例如，当 *timeCutPoints =*\\[09:00m, 09:05m]，且窗口左开右闭时，窗口的时间精度为分钟。此时，只有在大于等于 09:00m 且小于等于 09:04m 的数据会参与计算，而大于 09:04m 的数据（如 09:04:00.100）则不参与计算。\n\n* 分组计算或全局计算：若指定了 *keyColumn*，则按照分组分别进行窗口计算，否则进行全局计算。\n\n* 计算结果填充：未指定 *fill* 或指定 *fill* = \"none\" 时，只输出计算结果不为空的窗口；若指定了 *fill*，则输出所有窗口，且根据 *fill* 规则对结果为空的窗口进行填充。\n\n#### 参数\n\n**name** 字符串标量，表示时间序列分组引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**timeCutPoints** MINUTE 或 SECOND 类型向量，且不能包含空值。由 *timeCutPoints* 向量的任意两个相邻元素确定窗口的左、右边界。\n\n注意：\n\n* *timeCutPoints* 指定的时间精度必须高于 *timeColumn* 列的精度。\n\n* *timeCutPoints* 指定的时间精度决定关闭窗口右边界的时间精度。如果 *timeCutPoints* 是 MINUTE 类型，则窗口右边界的时间精度是分；如果 *timeCutPoints* 是 SECOND 类型，则窗口右边界的时间精度是秒。\n\n**metrics** 以元代码的格式表示计算指标，支持输入元组。有关元代码的更多信息可参考 [元编程](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n* 计算指标可以是一个或多个系统内置或用户自定义的聚合函数（使用 defg 关键字定义），如 <\\[sum(volume), avg(price)]>；可以对聚合结果使用表达式，如 <\\[avg(price1)-avg(price2)]>；也可对列与列的计算结果进行聚合计算，如 <\\[std(price1-price2)]>。\n\n* *metrics* 内支持调用具有多个返回值的函数，例如 \\<func(price) as \\`col1\\`col2>（可不指定列名）。\n\n* 若 *windowSize* 为向量， *windowSize* 每个值可对应 *metrics* 中多个计算指标。例如，*windowSize* 为\\[10,20]时，metrics可为 (<\\[min(volume), max(volume)]>, \\<sum(volume)>)。 *metrics* 也可以嵌套输入元组向量。例如：\\[\\[<\\[min(volume), max(volume)]>, \\<sum(volume)>], \\[\\<avg(volume)>]]\n\n  **Note:**\n\n  * *metrics* 中使用的列名大小写不敏感，不需要与输入表的列名大小写保持一致。\n  * *metrics* 中不可使用嵌套聚合函数。\n\n**dummyTable** 一个表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。\n\n**outputTable**计算结果的输出表，可以是内存表或者分布式表。在使用 createTimeBucketEngine 函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。引擎会将计算结果插入该表。\n\n输出表的列顺序如下：\n\n1. 时间列。当 *timeColumn* 为标量时，输出表中时间列的数据类型与 *timeColumn* 列 一致。否则输出表中时间列的数据类型与 *timeColumn* 中日期和时间列应用 concatDateTime 的结果一致。\n\n2. 分组列。如果 *keyColumn* 不为空，则其后几列和 *keyColumn* 设置的列及其顺序保持一致。\n\n3. 耗时列。如果指定 *outputElapsedMicroseconds* = true，则指定一个 LONG 类型的列用于存储耗时（单位：微秒）。\n\n4. 计算结果列，数量和 *metrics* 中指定的算子个数相同。若 *metrics* 指定的某个算子返回多个计算结果，则它们将以数组向量的形式输出，因此，该算子对应的计算结果列必须的类型必须是数组向量。\n\n**timeColumn** 字符串标量或长度为2的向量，用于输入表中时间列的名称。\n\n注：若 *timeColumn* 指定为向量，则第一个元素（date）的类型为 DATE，第二个元素（time）的类型为 TIME, SECOND 或 NANOTIME。此时，输出表第一列的时间类型必须与 concatDateTime(date, time) 的类型一致。\n\n**keyColumn** 可选参数，字符串标量或向量，表示分组列名。若设置，则分组进行聚合计算，例如以每支股票为一组进行聚合计算。\n\n**useWindowStartTime** 可选参数。布尔值，表示输出表中的时间是否为数据窗口起始时间。默认值为 false，表示输出表中的时间为窗口结束时间。\n\n**closed** 字符串，用于确定滑动窗口边界的开闭情况。可选值为 'left' 或 'right'，默认值为 'left'。\n\n* closed = 'left'： 窗口左闭右开。\n\n* closed = 'right'： 窗口左开右闭。\n\n**fill** 可选参数，一个标量或向量，指定某个分组的某个窗口无数据时的处理方法。可取以下值：\n\n* 'none': 不输出结果。\n* 'null': 输出结果为 NULL。\n* 'ffill': 输出上一个有数据的窗口的结果。\n* '具体数值'：该值的数据类型需要和对应的 *metrics* 计算结果的类型保持一致。\n\n*fill* 可以输入向量，长度与 *metrics* 元素个数保持一致，表示为每个 *metrics* 指定不同的 *fill* 方式。若为向量，向量中各项只能是 'null', 'ffill' 或一个数值，不能是 'none'。\n\n**keyPurgeFreqInSec** 正整数，表示清理窗口数据为空的分组的时间间隔，单位为秒。指定该参数后，若当前数据注入时间与上一次清理时间的间隔大于等于 *keyPurgeFreqInSec*，则触发对当前窗口数据为空的分组信息的清理。若指定该参数，则必须指定 *keyColumn*，且不能指定 *fill。*\n\n**outputElapsedMicroseconds** 布尔值，表示是否输出每个窗口从触发计算到计算完成输出结果的耗时（若指定了 *keyColumn* 则包含数据分组的耗时），默认为 false。指定参数 *outputElapsedMicroseconds* 后，在定义 *outputTable* 时需要在时间列和分组列后增加一个 LONG 类型的列，详见 *outputTable* 参数说明。\n\n**parallelism** 为不超过 63 的正整数，可选参数，表示并行计算的工作线程数，默认值为 1。在计算量较大时，合理地调整该参数能够有效利用计算资源，降低计算耗时。建议小于机器核数，推荐值为 4 到 8 。\n\n**outputHandler** 一元函数。设置此参数时，引擎计算结束后，不再将计算结果写到输出表，而是会调用此函数处理计算结果。默认值为 NULL，表示仍将结果写到输出表。\n\n**msgAsTable** 布尔标量，表示在设置了参数 outputHandler 时，将引擎的计算结果以表的结构调用函数。默认值为 false，此时将计算结果的每一列作为元素组成元组。\n\n#### 例子\n\n通过时序聚合引擎计算1分钟 K 线，然后通过 createTimeBucketEngine 将 1 分钟 K 线聚合为 5 分钟。在窗口左闭右开的情况下，可以提前一分钟结束窗口并计算输出，从而比使用 createTimeSeriesEngine 减少延时。\n\n```\nshare streamTable(1000:0, `time`sym`price`volume, [TIMESTAMP, SYMBOL, DOUBLE, INT]) as trades\nshare streamTable(10000:0, `time`sym`firstPrice`maxPrice`minPrice`lastPrice`sumVolume, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE, INT]) as output1\ntimeSeries1 = createTimeSeriesEngine(name=\"timeSeries1\", windowSize=60000, step=60000, metrics=<[first(price), max(price), min(price), last(price), sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`time, useSystemTime=false, keyColumn=`sym, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"timeSeries1\", offset=0, handler=append!{timeSeries1}, msgAsTable=true);\n\n// 定义 createTimeBucketEngine 的输出表和窗口区间\nshare streamTable(10000:0, `time`sym`firstPrice`maxPrice`minPrice`lastPrice`sumVolume, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE, INT]) as output2\ntimeCutPoints=[10:00m, 10:05m, 10:10m, 10:15m]\n\ntimeBucket1 = createTimeBucketEngine(name=\"timeBucket1\", timeCutPoints=timeCutPoints, metrics=<[first(firstPrice), max(maxPrice), min(minPrice), last(lastPrice), sum(sumVolume)]>, dummyTable=output1, outputTable=output2, timeColumn=`time,  keyColumn=`sym)\nsubscribeTable(tableName=\"output1\", actionName=\"timeBucket1\", offset=0, handler=append!{timeBucket1}, msgAsTable=true);\n\n\ninsert into trades values(2024.10.08T10:01:01.785,`A, 10.83, 2110)\ninsert into trades values(2024.10.08T10:01:02.125,`B,21.73, 1600)\ninsert into trades values(2024.10.08T10:01:12.457,`A,10.79, 2850)\ninsert into trades values(2024.10.08T10:03:10.789,`A,11.81, 2250)\ninsert into trades values(2024.10.08T10:03:12.005,`B, 22.96, 1980)\ninsert into trades values(2024.10.08T10:08:02.236,`A, 11.25, 2400)\ninsert into trades values(2024.10.08T10:08:04.412,`B, 23.03, 2130)\ninsert into trades values(2024.10.08T10:08:05.152,`B, 23.18, 1900)\ninsert into trades values(2024.10.08T10:08:30.021,`A, 11.04, 2300)\ninsert into trades values(2024.10.08T10:10:20.123,`A, 11.85, 2200)\ninsert into trades values(2024.10.08T10:11:02.236,`A, 11.06, 2200)\ninsert into trades values(2024.10.08T10:13:04.412,`B, 23.15, 1880)\ninsert into trades values(2024.10.08T10:15:12.005,`B, 22.06, 2100)\n\nsleep(10)\n\n// 查看时序引擎输出的 1 分钟 K 线结果\nselect * from output1;\n\n```\n\n| time                    | sym | firstPrice | maxPrice | minPrice | lastPrice | sumVolume |\n| ----------------------- | --- | ---------- | -------- | -------- | --------- | --------- |\n| 2024.10.08T10:02:00.000 | A   | 10.83      | 10.83    | 10.79    | 10.79     | 4,960     |\n| 2024.10.08T10:02:00.000 | B   | 21.73      | 21.73    | 21.73    | 21.73     | 1,600     |\n| 2024.10.08T10:04:00.000 | A   | 11.81      | 11.81    | 11.81    | 11.81     | 2,250     |\n| 2024.10.08T10:04:00.000 | B   | 22.96      | 22.96    | 22.96    | 22.96     | 1,980     |\n| 2024.10.08T10:09:00.000 | A   | 11.25      | 11.25    | 11.04    | 11.04     | 4,700     |\n| 2024.10.08T10:09:00.000 | B   | 23.03      | 23.18    | 23.03    | 23.18     | 4,030     |\n| 2024.10.08T10:11:00.000 | A   | 11.85      | 11.85    | 11.85    | 11.85     | 2,200     |\n| 2024.10.08T10:14:00.000 | B   | 23.15      | 23.15    | 23.15    | 23.15     | 1,880     |\n\n查看 5 分钟 K 线结果：\n\n```\n`select * from output2;`\n```\n\n| time                    | sym | firstPrice | maxPrice | minPrice | lastPrice | sumVolume |\n| ----------------------- | --- | ---------- | -------- | -------- | --------- | --------- |\n| 2024.10.08T10:05:00.000 | A   | 10.83      | 11.81    | 10.79    | 11.81     | 7,210     |\n| 2024.10.08T10:05:00.000 | B   | 21.73      | 22.96    | 21.73    | 22.96     | 3,580     |\n| 2024.10.08T10:10:00.000 | A   | 11.25      | 11.25    | 11.04    | 11.04     | 4,700     |\n| 2024.10.08T10:10:00.000 | B   | 23.03      | 23.18    | 23.03    | 23.18     | 4,030     |\n| 2024.10.08T10:15:00.000 | B   | 23.15      | 23.15    | 23.15    | 23.15     | 1,880     |\n"
    },
    "createTimeSeriesAggregator": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesAggregator.html",
        "signatures": [
            {
                "full": "createTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, [timeColumn], [useSystemTime=false], [keyColumn], [garbageSize], [updateTime], [useWindowStartTime], [roundTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [fill='none'], [forceTriggerTime], [raftGroup], [keyPurgeFreqInSec=-1], [closed='left'], [outputElapsedMicroseconds=false], [subWindow], [parallelism=1],[acceptedDelay=0], [outputHandler=NULL], [msgAsTable=false])",
                "name": "createTimeSeriesEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "windowSize",
                        "name": "windowSize"
                    },
                    {
                        "full": "step",
                        "name": "step"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[updateTime]",
                        "name": "updateTime",
                        "optional": true
                    },
                    {
                        "full": "[useWindowStartTime]",
                        "name": "useWindowStartTime",
                        "optional": true
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[fill='none']",
                        "name": "fill",
                        "optional": true,
                        "default": "'none'"
                    },
                    {
                        "full": "[forceTriggerTime]",
                        "name": "forceTriggerTime",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSec=-1]",
                        "name": "keyPurgeFreqInSec",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[subWindow]",
                        "name": "subWindow",
                        "optional": true
                    },
                    {
                        "full": "[parallelism=1]",
                        "name": "parallelism",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[acceptedDelay=0]",
                        "name": "acceptedDelay",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createTimeSeriesAggregator](https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesAggregator.html)\n\n是 [createTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesEngine.html) 的别名。\n\n\n以下是 `createTimeSeriesEngine` 函数的文档：\n### [createTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesEngine.html)\n\n\n\n#### 语法\n\ncreateTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, \\[timeColumn], \\[useSystemTime=false], \\[keyColumn], \\[garbageSize], \\[updateTime], \\[useWindowStartTime], \\[roundTime=true], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[fill='none'], \\[forceTriggerTime], \\[raftGroup], \\[keyPurgeFreqInSec=-1], \\[closed='left'], \\[outputElapsedMicroseconds=false], \\[subWindow], \\[parallelism=1],\\[acceptedDelay=0], \\[outputHandler=NULL], \\[msgAsTable=false])\n\n别名：createTimeSeriesAggregator\n\n#### 详情\n\n创建流数据时间序列引擎，以实现基于时间的滑动窗口或滚动窗口进行实时计算。\n\n时序引擎的聚合计算的算子分为增量计算和全量计算两种。增量计算算子不会保留历史数据，每次有数据进来就会进行增量计算；而全量计算算子（例如自定义的聚合函数，或未经优化的内置聚合函数，亦或是嵌套了状态函数的函数）会保留窗口内完整的数据，待触发输出时进行全量计算。\n\n时序引擎对以下聚合计算算子进行了优化，实现了增量计算，显著提升了性能：corr, covar, first, last, max, med, min, percentile, quantile, std, var, sum, sum2, sum3, sum4, wavg, wsum, count, firstNot, ifirstNot, lastNot, ilastNot, imax, imin, nunique, prod, sem, mode, searchK, beta, avg。\n\n更多流数据引擎的应用场景说明可以参考 [内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)。\n\n\\*\\*返回值：\\*\\*一个表对象，通过向该表对象写入，将数据注入时间序列引擎进行计算。\n\n##### 窗口\n\n* 窗口边界规整：对起始窗口左边界进行规整。（详情请参考 *step* 和 *roundTime* 的参数说明以及 `规整规则表`）\n\n* 窗口确定：\n\n  * *windowSize* 确定窗口长度。\n\n  * *closed* 确定窗口左闭右开或左开右闭。\n\n  * *step* 确定滑动的步长。\n\n  其中，*windowSize* 与 *step* 的单位取决于 *useSystemTime* 参数。若 *useSystemTime* = true， *windowSize* 与 *step* 的单位是毫秒。若 *useSystemTime* = false，*windowSize* 与 *step* 的单位同 *timeColumn* 列的精度一致。\n\n* 窗口截取：*useSystemTime* 参数决定了如何截取窗口，可以基于数据的时间列，亦可以基于数据注入系统的时间进行截取。\n\n##### 计算\n\n* 计算前提：若指定了 *timeColumn*，则 *timeColumn* 的时间必须递增；若同时指定了 *keyColumn*，则按照分组分别进行滑动窗口计算，*timeColumn* 在每组内的时间必须递增。否则，时间乱序的数据在计算中会被直接丢弃。\n\n* 触发规则：若指定了 *timeColumn*，当前窗口的计算将由该窗口结束后收到的第一条数据触发；若设置 *useSystemTime* = true，窗口结束后会自动触发计算。\n\n* 强制触发规则：对长时间未触发计算的窗口数据，可以通过设置 *updateTime* 或 *forceTriggerTime* 强制触发计算。具体规则请参考参数说明。\n\n* 窗口填充规则：未指定 *fill* 或指定 *fill* = \"none\" 时，只会输出计算结果不为空的窗口；若指定了 *fill*，则会输出所有窗口，且根据 *fill* 规则对结果为空的窗口进行填充。\n\n##### 其它功能\n\n* 支持数据/状态清理：清理引擎中堆积的数据和不再需要的状态信息。（详情请参考 *garbageSize* 和 *keyPurgeFreqInSec* 的参数说明）\n\n* 快照机制：启用快照机制之后，系统若出现异常，可及时将流数据引擎恢复到最新的快照状态。（详情请参考 *snapshotDir* 和 *snapshotIntervalInMsgCount* 的参数说明）\n\n* 流数据引擎高可用：若要启用引擎高可用，需在订阅端 raft 组的 leader 节点创建引擎并通过 *raftGroup* 参数开启高可用。开启高可用后，当 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。（详情请参考 *raftGroup* 的参数说明）\n\n#### 参数\n\n**name** 字符串标量，表示时间序列引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**windowSize** 正整数标量或向量，表示滑动窗口的长度。\n\n**step** 正整数标量，表示滑动窗口移动的步长。 *windowSize* 必须是 *step* 的整数倍，否则会抛出异常。*windowSize* 和 *step* 的单位与 *useSystemTime* 有关：\n\n* 若 *useSystemTime* 为 true，则 *windowSize* 和 *step* 的单位为毫秒。\n\n* 若 *useSystemTime* 为 false，则 *windowSize* 和 *step* 的单位与 *timeColumn* 的时间精度一致。\n\n**metrics** 以元代码的格式表示计算指标，支持输入元组。有关元代码的更多信息可参考 [元编程](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n* 计算指标可以是一个或多个系统内置或用户自定义的聚合函数（使用 defg 关键字定义），如 <\\[sum(volume), avg(price)]>；可以对聚合结果使用表达式，如 <\\[avg(price1)-avg(price2)]>；也可对列与列的计算结果进行聚合计算，如 <\\[std(price1-price2)]>。\n\n* *metrics* 内支持调用具有多个返回值的函数，例如 \\<func(price) as \\`col1\\`col2>（可不指定列名）。\n\n* 若 *windowSize* 为向量， *windowSize* 每个值可对应 *metrics* 中多个计算指标。例如，*windowSize* 为\\[10,20]时，metrics可为 (<\\[min(volume), max(volume)]>, \\<sum(volume)>)。 *metrics* 也可以嵌套输入元组向量。例如：\\[\\[<\\[min(volume), max(volume)]>, \\<sum(volume)>], \\[\\<avg(volume)>]]\n\n  **Note:**\n\n  * *metrics* 中使用的列名大小写不敏感，不需要与输入表的列名大小写保持一致。\n  * *metrics* 中不可使用嵌套聚合函数。\n\n**dummyTable** 一个表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。\n\n**outputTable** 计算结果的输出表，可以是内存表或者分布式表。在使用 `createTimeSeriesEngine` 函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。时间序列引擎会将计算结果插入该表。\n\n* 输出表的列顺序如下：\n\n  1. 时间列。其中：\n\n     * 若 *useSystemTime* = true，为 TIMESTAMP 类型；反之，该列数据类型与 *timeColumn* 列一致。\n\n     * 若 *useWindowStartTime* = true，显示时间为数据窗口起始时间；反之，显示时间为数据窗口终止时间。\n\n  2. 分组列。如果 *keyColumn* 不为空，则其后几列和 *keyColumn* 设置的列及其顺序保持一致。\n\n  3. 耗时列。如果指定 *outputElapsedMicroseconds* = true，则指定一个 LONG 类型的列用于存储耗时（单位：微秒）。\n\n  4. 计算结果列。可为多列。\n\n  **Note:** 自 2.00.10 版本开始，引擎支持通过自定义聚合函数，将多个计算结果以 array vector 的形式输出，此时必须在 *outputTable* 中指定对应列类型为 array vector，详见例2。\n\n**timeColumn** 可选参数，字符串标量或向量。当 *useSystemTime* = false 时，必须指定该参数。 该参数用于指定订阅的流数据表中时间列的名称。\n\n**Note:** 字符串向量必须是 date 和 time 组成的向量，date 类型为 DATE，time 类型为 TIME, SECOND 或 NANOTIME。此时，输出表第一列的时间类型必须与 [concatDateTime(date, time)](https://docs.dolphindb.cn/zh/funcs/c/concatDateTime.html) 的类型一致。\n\n**useSystemTime** 可选参数，布尔值，表示是否使用数据注入引擎时的系统时间作为时间列进行计算。\n\n* 当 *useSystemTime* = true时，时间序列引擎会按照数据注入时间序列引擎的时刻（毫秒精度的本地系统时间，与数据中的时间列无关），每隔固定时间截取固定长度窗口的流数据进行计算。只要一个数据窗口中含有数据，数据窗口结束后就会自动进行计算。结果中的第一列为计算发生的时间戳，与数据中的时间无关。\n\n* 当 *useSystemTime* = false（缺省值）时，时间序列引擎根据流数据中的 *timeColumn* 列来截取数据窗口。一个数据窗口结束后的第一条新数据才会触发该数据窗口的计算。请注意，触发计算的数据并不会参与该次计算。\n\n  例如，一个数据窗口从 10:10:10 到 10:10:19。若 *useSystemTime* = true，则只要该窗口中至少有一条数据，该窗口的计算会在窗口结束后的 10:10:20 触发。若 *useSystemTime* = false，且 10:10:19 后的第一条数据为 10:10:25，则该窗口的计算会在 10:10:25 触发。\n\n**keyColumn** 可选参数，字符串标量或向量，表示分组列名。若设置，则分组进行聚合计算，例如以每支股票为一组进行聚合计算。\n\n**garbageSize** 可选参数，正整数，默认值是 50,000（单位为行）。随着订阅的流数据不断积累，注入时间序列引擎，存放在内存中的数据会越来越多，这时需要清理不再需要的历史数据。当内存中历史数据行数超过 *garbageSize* 值时，系统会清理本次计算不需要的历史数据。如果指定了 *keyColumn*，内存清理是各组内独立进行的。当一个组在内存中的历史数据记录数超出 *garbageSize* 时，会清理该组中本次计算中不需要的历史数据。\n\n**Note:** 对于增量计算算子，系统会自动清理不再需要的历史数据。而对于全量计算算子，需要指定该参数来触发清理历史数据。\n\n**updateTime** 可选参数，非负整数，单位与 timeColumn 的时间精度一致。用于指定比 *step* 更短的计算时间间隔。*step* 必须是 *updateTime* 的整数倍。要设置 *updateTime*， *useSystemTime* 必须设为 false。\n\n如果没有指定 *updateTime*，一个数据窗口结束前，不会发生对该数据窗口数据的计算。若一个窗口长时间未触发计算，可以指定 updateTime，分多次触发当前窗口数据的计算。计算触发的规则为：\n\n* updateTime 指定为正整数值时：\n\n  * 从当前窗口的左边界开始，每隔 *updateTime* 时间，若有新的数据到来，则对当前窗口内该数据之前的所有数据进行计算。\n\n  * 如果系统经过 2 \\* *updateTime* （至少2秒）后仍有未被处理的数据，则触发对当前窗口内所有数据的计算。\n\n  * 若分组计算，则每组内进行上述操作。\n\n* updateTime 指定为 0 时：在新的数据到来后，立即对当前窗口的最新数据计算并输出。\n\n指定 *updateTime* 后，建议使用键值内存表作为输出表。因为每次计算均会增加一条记录，输出表若使用普通内存表或流数据表，则会产生大量带有相同时间戳的结果。因为键值流数据表不可更新记录，输出表亦不推荐使用键值流数据表。\n\n**useWindowStartTime** 可选参数，布尔值，表示输出表中的时间是否为数据窗口起始时间。默认值为 false，表示输出表中的时间为数据窗口起始时间 + *windowSize* 。若 *windowSize* 是向量， *useWindowStartTime* 必须为 false。\n\n**roundTime** 可选参数，布尔值，表示若数据时间精度为毫秒或者秒且 *step* > 一分钟，如何对窗口边界值进行规整处理。默认值为 true，表示按照既定的多分钟规则进行规整。若为 false，则按一分钟规则进行窗口规整。\n\n若要开启快照机制（snapshot），必须指定 *snapshotDir* 与 *snapshotIntervalInMsgCount*。\n\n**snapshotDir** 可选参数，字符串，表示保存引擎快照的文件目录。\n\n* 指定的目录必须存在，否则系统会提示异常。\n\n* 创建流数据引擎时，如果指定了 *snapshotDir*，会检查该目录下是否存在快照。如果存在，会加载该快照，恢复引擎的状态。\n\n* 多个引擎可以指定同一个目录存储快照，用引擎的名称来区分快照文件。\n\n* 一个引擎的快照可能会使用三个文件名：\n\n  * 临时存储快照信息：文件名为 \\<engineName>.tmp；\n\n  * 快照生成并刷到磁盘：文件保存为 \\<engineName>.snapshot；\n\n  * 存在同名快照：旧快照自动重命名为 \\<engineName>.old。\n\n**snapshotIntervalInMsgCount** 可选参数，为整数类型，表示每隔多少条数据保存一次流数据引擎快照。\n\n**fill** 可选参数，一个标量或向量，指定某个分组的某个窗口无数据时的处理方法。可取以下值：\n\n* 'none': 不输出结果。\n* 'null': 输出结果为 NULL。\n* 'ffill': 输出上一个有数据的窗口的结果。\n* '具体数值'：该值的数据类型需要和对应的 *metrics* 计算结果的类型保持一致。\n\n*fill* 可以输入向量，长度与 *metrics* 元素个数保持一致，表示为每个 *metrics* 指定不同的 *fill* 方式。若为向量，向量中各项只能是 'null', 'ffill' 或一个数值，不能是 'none'。\n\n**forceTriggerTime** 可选参数，是非负整数，单位与 *timeColumn* 的时间精度一致。用于强制触发各个分组未计算的窗口进行计算。要设置 *forceTriggerTime*， *useSystemTime* 必须设置为 false，且不能指定 *updateTime*。强制触发计算及输出规则如下：\n\n1. 未被触发计算的窗口结束后（窗口结束时刻为 t），若收到了其他分组的数据（时间戳为 t1），且满足 t1-t ≥ *forceTriggerTime*，则该窗口将被触发计算。\n\n2. 如果某个分组在最后一个窗口被强制触发计算后，没有再收到新的数据，但其他分组仍然收到了新的数据，那么通过 *fill* 来填充该分组的所有缺失窗口，可以确保在最新时间截面上仍然输出该分组的窗口。如果不指定 *fill*，则最后一个窗口被触发计算后，该分组不会产生新的窗口。\n\n设置 *forceTriggerTime* 或 *updateTime* 时需注意以下几点：\n\n* 设置 *updateTime*，计算发生后仍有属于当前窗口的数据到达时，当前窗口计算结果会再次更新；\n\n* 设置 *forceTriggerTime*，则触发计算之后收到的数据会被丢弃，建议不要设置太小的 *forceTriggerTime*。\n\n**raftGroup** 可选参数，表示流数据高可用订阅端 raft 组的 ID (大于1的整数，由流数据高可用相关的配置项 *streamingRaftGroups* 指定)。设置该参数表示开启计算引擎高可用。在 leader 节点创建流数据引擎后，会同步在 follower 节点创建该引擎。每次保存的 snapshot 也会同步到 follower。当 raft 组的 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。请注意，若要指定 *raftGroup*，必须同时指定 *snapshotDir*。\n\n**keyPurgeFreqInSec** 正整数，表示清理窗口数据为空的分组的时间间隔，单位为秒。指定该参数后，若当前数据注入时间与上一次清理时间的间隔大于等于 *keyPurgeFreqInSec*，则触发对当前窗口数据为空的分组信息的清理。\n\n**Note:**\n\n* 若需指定该参数，必须指定 *forceTriggerTime*，且不能指定 *fill*。\n\n* 可以通过调用 [getStreamEngineStat](https://docs.dolphindb.cn/zh/funcs/g/getStreamEngineStat.html) 函数查看 TimeSeriesEngine 引擎状态的 numGroups 列，来对比响应式状态引擎清理前后分组数的变化。\n\n**closed** 字符串，用于确定滑动窗口边界的开闭情况。可选值为 'left' 或 'right'，默认值为 'left'。\n\n* closed = 'left'： 窗口左闭右开。\n\n* closed = 'right'： 窗口左开右闭。\n\n**outputElapsedMicroseconds** 布尔值，表示是否输出每个窗口从触发计算到计算完成输出结果的耗时（若指定了 *keyColumn* 则包含数据分组的耗时），默认为 false。指定参数 *outputElapsedMicroseconds* 后，在定义 *outputTable* 时需要在时间列和分组列后增加一个 LONG 类型的列，详见 *outputTable* 参数说明。\n\n**subWindow**整型或者 DURATION 数据对。在滑动窗口内指定子窗口，仅计算子窗口内的数据。子窗口边界的开闭情况由参数 *closed* 决定。子窗口结束后收到第一条数据触发对子窗口内数据的计算（参考例4）。当 *subWindow*为整型数据对时，其单位与 *timeColumn* 的时间精度一致。若指定 *subWindow*，则：\n\n* *windowSize*和 *step*必须相等。\n\n* 不可设置 *updateTime*>0和 *useSystemTime*=true。\n\n**parallelism** 为不超过 63 的正整数，可选参数，表示并行计算的工作线程数，默认值为 1。在计算量较大时，合理地调整该参数能够有效利用计算资源，降低计算耗时。建议小于机器核数，推荐值为 4 到 8 。\n\n**acceptedDelay** 为小于等于 *windowSize* 的正整数，可选参数。指定每个窗口接收数据的最大延迟，默认值为 0。若设置该参数，则不能设置 *forceTriggerTime* 或 *updateTime*。\n\n* 当 useSystemTime= true 时，窗口结束后 *acceptedDelay* 时间内接收到的数据，仍然属于此窗口并参与计算，而不会参与下一个窗口的计算。\n\n* 当 useSystemTime= false 时，该参数用于处理乱序数据。假设当前窗口结束的时间戳为 t ，若收到一条时间戳大于等于 t+*acceptedDelay*的数据，则触发在此之前收到的所有属于当前窗口的数据进行计算输出，并关闭该窗口。\n\n**outputHandler** 一元函数。设置此参数时，引擎计算结束后，不再将计算结果写到输出表，而是会调用此函数处理计算结果。默认值为 NULL，表示仍将结果写到输出表。\n\n**msgAsTable** 布尔标量，表示在设置了参数 outputHandler 时，将引擎的计算结果以表的结构调用函数。默认值为 false，此时将计算结果的每一列作为元素组成元组。\n\n##### 规整规则\n\n为了便于观察和对比计算结果，系统会对第一个数据窗口的起始时间进行规整，根据 *step* 参数、数据的时间精度，以及 *roundTime* 参数来确定整数类型的规整尺度 alignmentSize。当时间序列引擎使用分组计算时，所有分组的窗口均进行统一的规整。相同时刻的数据窗口在各组均有相同的边界。\n\n* 若数据的时间精度为分钟，如 MINUTE(HH:mm) 类型，alignmentSize 取值如下：\n\n*若 roundTime = false*：\n\n| step   | alignmentSize |\n| ------ | ------------- |\n| 0\\~2   | 2             |\n| 3      | 3             |\n| 4\\~5   | 5             |\n| 6\\~10  | 10            |\n| 11\\~15 | 15            |\n| 16\\~20 | 20            |\n| 21\\~30 | 30            |\n| >30    | 60 (1小时)      |\n\n*若 roundTime = true*:\n\n当 step <= 30 时，alignmentSize 取值同上表。当 step > 30 时，alignmentSize 取值见下表：\n\n| step       | alignmentSize |\n| ---------- | ------------- |\n| 31\\~60     | 60 (1小时)      |\n| 61\\~120    | 120 (2小时)     |\n| 121\\~180   | 180 (3小时)     |\n| 181\\~300   | 300 (5小时)     |\n| 301\\~600   | 600 (10小时)    |\n| 601\\~900   | 900 (15小时)    |\n| 901\\~1200  | 1200 (20小时)   |\n| 1201\\~1800 | 1800 (30小时)   |\n| >1800      | 3600 (60小时)   |\n\n* 若数据的时间精度为秒，如 DATETIME(yyyy-MM-dd HH:mm:ss) 与 SECOND(HH:mm:ss) 类型，alignmentSize 的 取值如下：\n\n*若 roundTime = false*：\n\n| step   | alignmentSize |\n| ------ | ------------- |\n| 0\\~2   | 2             |\n| 3      | 3             |\n| 4\\~5   | 5             |\n| 6\\~10  | 10            |\n| 11\\~15 | 15            |\n| 16\\~20 | 20            |\n| 21\\~30 | 30            |\n| >30    | 60 (1分钟)      |\n\n*若 roundTime = true*:\n\n当 step <= 30 时，alignmentSize 取值同上表。当 step > 30 时，alignmentSize 取值见下表：\n\n| step       | alignmentSize |\n| ---------- | ------------- |\n| 31\\~60     | 60 (1分钟)      |\n| 61\\~120    | 120 (2分钟)     |\n| 121\\~180   | 180 (3分钟)     |\n| 181\\~300   | 300 (5分钟)     |\n| 301\\~600   | 600 (10分钟)    |\n| 601\\~900   | 900 (15分钟)    |\n| 901\\~1200  | 1200 (20分钟)   |\n| 1201\\~1800 | 1800 (30分钟)   |\n| >1800      | 3600 (1小时)    |\n\n* 若数据的时间精度为毫秒，如 TIMESTAMP(yyyy-MM-dd HH:mm:ss.mmm) 与 TIME(HH:mm:ss.mmm) 类型，alignmentSize 的取值如下：\n\n*若 roundTime = false*:\n\n| step         | alignmentSize |\n| ------------ | ------------- |\n| 0\\~2         | 2             |\n| 3\\~5         | 5             |\n| 6\\~10        | 10            |\n| 11\\~20       | 20            |\n| 21\\~25       | 25            |\n| 26\\~50       | 50            |\n| 51\\~100      | 100           |\n| 101\\~200     | 200           |\n| 201\\~250     | 250           |\n| 251\\~500     | 500           |\n| 501\\~1000    | 1000（1秒）      |\n| 1001\\~2000   | 2000（2秒）      |\n| 2001\\~5000   | 5000（5秒）      |\n| 5001\\~10000  | 10000（10秒）    |\n| 10001\\~15000 | 15000（15秒）    |\n| 15001\\~20000 | 20000（20秒）    |\n| 20001\\~30000 | 30000（30秒）    |\n| >30000       | 60000（1分钟）    |\n\n*若 roundTime = true*:\n\n若 *step* <= 30000，alignmentSize 取值同上表；若 *step* > 30000，alignmentSize 取值见下表：\n\n| step             | alignmentSize |\n| ---------------- | ------------- |\n| 30001\\~60000     | 60000（1分钟）    |\n| 60001\\~120000    | 120000（2分钟）   |\n| 120001\\~300000   | 300000（5分钟）   |\n| 300001\\~600000   | 600000（10分钟）  |\n| 600001\\~900000   | 900000（15分钟）  |\n| 900001\\~1200000  | 1200000（20分钟） |\n| 1200001\\~1800000 | 1800000（30分钟） |\n| >1800000         | 3600000（1小时）  |\n\n* 若数据的时间精度为纳秒，如 NANOTIMESTAMP(yyyy-MM-dd HH:mm:ss.nnnnnnnnn) 与 NANOTIME(HH:mm:ss.nnnnnnnnn) 类型，alignmentSize 的取值如下：\n\n*若 roundTime = false*:\n\n| step         | alignmentSize |\n| ------------ | ------------- |\n| 0\\~2ns       | 2ns           |\n| 3ns\\~5ns     | 5ns           |\n| 6ns\\~10ns    | 10ns          |\n| 11ns\\~20ns   | 20ns          |\n| 21ns\\~25ns   | 25ns          |\n| 26ns\\~50ns   | 50ns          |\n| 51ns\\~100ns  | 100ns         |\n| 101ns\\~200ns | 200ns         |\n| 201ns\\~250ns | 250ns         |\n| 251ns\\~500ns | 500ns         |\n| >500ns       | 1000ns        |\n\n*若 roundTime = true*:\n\n| step        | alignmentSize |\n| ----------- | ------------- |\n| 1000ns\\~1ms | 1ms           |\n| 1ms\\~10ms   | 10ms          |\n| 10ms\\~100ms | 100ms         |\n| 100ms\\~1s   | 1s            |\n| 1s\\~2s      | 2s            |\n| 2s\\~3s      | 3s            |\n| 3s\\~5s      | 5s            |\n| 5s\\~10s     | 10s           |\n| 10s\\~15s    | 15s           |\n| 15s\\~20s    | 20s           |\n| 20s\\~30s    | 30s           |\n| >30s        | 1min          |\n\n假设第一条数据的时间为 x, 那么根据其类型，第一个数据窗口的左边界的计算规则为：`timeType_cast(x/alignmentSize*alignmentSize+step-windowSize)`。其中，timeType\\_cast 表示依据时间精度，需要强制转换的时间类型；'/' 表示整除。例如，第一条数据的时间为 2018.10.08T01:01:01.365，windowSize 为 120000，step 为 60000，那么 alignmentSize 为 60000，第一个数据窗口的左边界为 `timestamp(2018.10.08T01:01:01.365/60000*60000+60000-120000)`，即 2018.10.08T01:00:00.000。\n\n#### 例子\n\n**Note:** 以下例子使用了相同的变量和表名便于比较。每个例子执行结束后，请使用以下命令清除环境中的临时数据：\n\n* [getStreamingStat](https://docs.dolphindb.cn/zh/funcs/g/getStreamingStat.html)：用于查看当前的流数据表订阅者。例如：\n\n  ```\n  getStreamingStat().pubTables\n  ```\n\n* [unsubscribeTable](https://docs.dolphindb.cn/zh/funcs/u/unsubscribeTable.html)：用于取消订阅流数据表。例如，在例子 1 代码运行后取消对 trades 的订阅：\n\n  ```\n  unsubscribeTable(tableName=\"trades\", actionName=\"engine1\")\n  ```\n\n* [dropStreamTable](https://docs.dolphindb.cn/zh/funcs/d/dropStreamTable.html)：用于删除流数据表。例如，删除例子 1 中的流数据表 trades：\n\n  ```\n  dropStreamTable(tableName=\"trades\")\n  ```\n\n* [dropStreamEngine](https://docs.dolphindb.cn/zh/funcs/d/dropStreamEngine.html)：用于流数据引擎。例如，删除例子 1 中的流数据引擎 engine1：\n\n  ```\n  dropStreamEngine(\"engine1\")\n  ```\n\n例1. 时间序列引擎 engine1 订阅流数据表 trades，实时计算表 trades 中过去1分钟内每只股票交易量之和。\n\n```\nshare streamTable(1000:0, [\"time\",\"sym\",\"volume\"], [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(10000:0, [\"time\",\"sym\",\"sumVolume\"], [TIMESTAMP, SYMBOL, INT]) as output1\nengine1 = createTimeSeriesEngine(name=\"engine1\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=\"time\", useSystemTime=false, keyColumn=\"sym\", garbageSize=50, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=append!{engine1}, msgAsTable=true);\n\ninsert into trades values(2018.10.08T01:01:01.785,`A,10)\ninsert into trades values(2018.10.08T01:01:02.125,`B,26)\ninsert into trades values(2018.10.08T01:01:10.263,`B,14)\ninsert into trades values(2018.10.08T01:01:12.457,`A,28)\ninsert into trades values(2018.10.08T01:02:10.789,`A,15)\ninsert into trades values(2018.10.08T01:02:12.005,`B,9)\ninsert into trades values(2018.10.08T01:02:30.021,`A,10)\ninsert into trades values(2018.10.08T01:04:02.236,`A,29)\ninsert into trades values(2018.10.08T01:04:04.412,`B,32)\ninsert into trades values(2018.10.08T01:04:05.152,`B,23)\n\nsleep(10)\n\nselect * from output1;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:02:00.000 | A   | 38        |\n| 2018.10.08T01:02:00.000 | B   | 40        |\n| 2018.10.08T01:03:00.000 | A   | 25        |\n| 2018.10.08T01:03:00.000 | B   | 9         |\n\n下面详细解释时间序列引擎的计算过程。为简便起见，以下提到时间时，省略相同的日期部分，只列出（小时:分钟:秒.毫秒）部分。\n\n首先，时间序列引擎对第一个数据窗口的起始时间进行规整。第一个数据窗口的时间范围是 01:01:00.000 到 01:02:00.000，只包含左边界，不包含右边界。当(01:02:10.789,`A,15)到达时，触发第一个窗口 A 组计算；当(01:02:12.005,`B,9)到达时，触发第一个窗口 B 组计算。\n\n第二个数据窗口的时间范围是 01:02:00.000 到 01:03:00.000。当(01:04:02.236,`A,29)到达时，触发第二个窗口 A 组计算；当(01:04:04.412,`B,32)到达时，触发第二个窗口 B 组计算。\n\n由于 01:05:00.000 及之后没有数据，因此没有对 01:04:00.000 到 01:05:00.000 之间的数据进行计算。\n\n输出表 output1 保存了时间序列引擎的计算结果。由于 *useWindowStartTime* 为 false，因此输出表 output1 中的时间为窗口的结束时间。若将 *useWindowStartTime* 设为 true，则输出表中的时间为窗口的起始时间。例如：\n\n```\noutput2 = table(10000:0, [\"time\",\"sym\",\"sumVolume\"], [TIMESTAMP, SYMBOL, INT])\nengine2 = createTimeSeriesEngine(name=\"engine2\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output2, timeColumn=\"time\", useSystemTime=false, keyColumn=\"sym\", garbageSize=50, useWindowStartTime=true)\nsubscribeTable(tableName=\"trades\", actionName=\"engine2\", offset=0, handler=append!{engine2}, msgAsTable=true)\n\nsleep(10)\nselect * from output2;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:01:00.000 | A   | 38        |\n| 2018.10.08T01:01:00.000 | B   | 40        |\n| 2018.10.08T01:02:00.000 | A   | 25        |\n| 2018.10.08T01:02:00.000 | B   | 9         |\n\n下例中指定 *updateTime* 为 1000（毫秒）：\n\n```\n\nshare keyedTable([\"time\",\"sym\"],10000:0, [\"time\",\"sym\",\"sumVolume\"], [TIMESTAMP, SYMBOL, INT]) as output3\nengine3 = createTimeSeriesEngine(name=\"engine3\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output3, timeColumn=\"time\", useSystemTime=false, keyColumn=\"sym\", garbageSize=50, updateTime=1000, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"engine3\", offset=0, handler=append!{engine3}, msgAsTable=true)\n\nsleep(2001)\nselect * from output3;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:02:00.000 | A   | 38        |\n| 2018.10.08T01:02:00.000 | B   | 40        |\n| 2018.10.08T01:03:00.000 | A   | 25        |\n| 2018.10.08T01:03:00.000 | B   | 9         |\n| 2018.10.08T01:05:00.000 | B   | 55        |\n| 2018.10.08T01:05:00.000 | A   | 29        |\n\n例2. 下例中指定 *updateTime* 为 0（毫秒）：\n\n```\nshare streamTable(1000:0, [\"time\",\"sym\",\"volume\"], [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(1000:0, [\"time\",\"sym\",\"sumVolume\"], [TIMESTAMP, SYMBOL, INT]) as output4\nengine4 = createTimeSeriesEngine(name=\"engine4\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output4, timeColumn=\"time\", useSystemTime=false, keyColumn=\"sym\", garbageSize=50, updateTime=0, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"engine4\", offset=0, handler=append!{engine4}, msgAsTable=true);\n\ninsert into trades values(2018.10.08T01:01:01.785,`A,10)\ninsert into trades values(2018.10.08T01:01:02.125,`B,26)\ninsert into trades values(2018.10.08T01:01:10.263,`B,14)\ninsert into trades values(2018.10.08T01:01:12.457,`A,28)\n\nsleep(100)\n\ninsert into trades values(2018.10.08T01:01:12.557,`B,21)\ninsert into trades values(2018.10.08T01:01:12.557,`A,28)\n\n\nselect * from output4;\n\n```\n\n*updateTime*=0 时，每收到一批数据就触发一次计算输出：\n\n* 01:01:12.457 时，触发了第一批数据中 A、B 两组数据的计算输出。\n\n* 01:01:12.557 时，再次触发第二批数据中 A、B 两组数据的计算输出。\n\n最终得到：\n\n|       | time                    | sym | sumVolume |\n| ----- | ----------------------- | --- | --------- |\n| **0** | 2018.10.08 01:02:00.000 | A   | 38        |\n| **1** | 2018.10.08 01:02:00.000 | B   | 40        |\n| **2** | 2018.10.08 01:02:00.000 | B   | 61        |\n| **3** | 2018.10.08 01:02:00.000 | A   | 66        |\n\n下面以最后一个数据窗口为例，介绍时间序列引擎指定 *updateTime* 时如何进行计算。假设 time 列时间亦为数据进入时间序列引擎的时刻。\n\n1. 在 01:04:04.236 时，A 分组的第一条记录到达后已经过 2000 毫秒，触发一次 A 组计算，输出表增加一条记录(01:05:00.000, \\`A, 29)。\n\n2. 在 01:04:05.152 时的 B 组记录为 01:04:04.412 所在小窗口\\[01:04:04.000, 01:04:05.000)之后第一条记录，触发一次 B 组计算，输出表增加一条记录(01:05:00,\"B\",32)。\n\n3. 2 秒（2\\*updateTime个时间单位）后，在 01:04:07.152 时，由于 01:04:05.152 时的 B 组记录仍未参与计算，触发一次B组计算，输出一条记录(01:05:00,\"B\",55)。由于输出表的主键为 time 和 sym，并且输出表中已有(01:05:00,\"B\",32)这条记录，因此将该记录更新为(01:05:00,\"B\",55)。\n\n下例中，共享流数据表 \"pubT\" 包含两个时间列，类型分别时 DATE 和 SECOND，创建时间序列引擎时，通过设置 *timeColumn* 来将原来流数据表的两个时间列整合为输出表 streamMinuteBar\\_1min 中的一个类型为 DATETIME 的时间列。\n\n```\ncolNames=[\"symbol\",\"date\",\"minute\",\"price\",\"type\",\"volume\"]\ncolTypes=[SYMBOL, DATE, SECOND, DOUBLE, STRING, INT]\npubTable = streamTable(10000:0,colNames,colTypes)\nshare pubTable as pubT\n\ncolNames = [\"time\",\"symbol\",\"open\",\"max\",\"min\",\"close\",\"volume\",\"amount\",\"ret\",\"vwap\"]\ncolTypes = [DATETIME, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE, INT, DOUBLE, DOUBLE, DOUBLE]\nshare streamTable(10000:0,colNames, colTypes) as streamMinuteBar_1min\n\ntsAggrOHLC = createTimeSeriesEngine(name=\"subT\", windowSize=60, step=60, metrics=<[first(price) as open ,max(price) as max,min(price) as min ,last(price) as close ,sum(volume) as volume ,wsum(volume, price) as amount ,(last(price)-first(price))/first(price)) as ret, (wsum(volume, price)/sum(volume)) as vwap]>, dummyTable=pubTable, outputTable=streamMinuteBar_1min, timeColumn=[\"date\",\"minute\"], useSystemTime=false, keyColumn=\"symbol\", fill=\"none\")\nsubscribeTable(tableName=\"pubT\", actionName=\"subT\", offset=-1, handler=append!{tsAggrOHLC}, msgAsTable=true)\n\ninsert into pubT values(\"000001\", 2021.04.05, 09:25:01, 1, 'B', 1)\ninsert into pubT values(\"000001\", 2021.04.05, 09:30:05, 2, 'B', 1)\ninsert into pubT values(\"000001\", 2021.04.05, 09:31:06, 3, 'B', 1)\ninsert into pubT values(\"000001\", 2021.04.05, 09:35:05, 4, 'S', 4)\ninsert into pubT values(\"000001\", 2021.04.05, 09:40:05, 5, 'S', 5)\ninsert into pubT values(\"000001\", 2021.04.06, 09:25:05, 6, 'S', 6)\n\npubT\n```\n\n| symbol | date       | minute   | price | type | volume |\n| ------ | ---------- | -------- | ----- | ---- | ------ |\n| 000001 | 2021.04.05 | 09:25:01 | 1     | B    | 1      |\n| 000001 | 2021.04.05 | 09:30:05 | 2     | B    | 1      |\n| 000001 | 2021.04.05 | 09:31:06 | 3     | B    | 1      |\n| 000001 | 2021.04.05 | 09:35:05 | 4     | S    | 4      |\n| 000001 | 2021.04.05 | 09:40:05 | 5     | S    | 5      |\n| 000001 | 2021.04.06 | 09:25:05 | 6     | S    | 6      |\n\n```\nselect * from streamMinuteBar_1min\n```\n\n| time                | symbol | open | max | min | close | volume | amount | ret | vwap |\n| ------------------- | ------ | ---- | --- | --- | ----- | ------ | ------ | --- | ---- |\n| 2021.04.05T09:26:00 | 000001 | 1    | 1   | 1   | 1     | 1      | 1      | 0   | 1    |\n| 2021.04.05T09:31:00 | 000001 | 2    | 2   | 2   | 2     | 1      | 2      | 1   | 2    |\n| 2021.04.05T09:32:00 | 000001 | 3    | 3   | 3   | 3     | 1      | 3      | 2   | 3    |\n| 2021.04.05T09:36:00 | 000001 | 4    | 4   | 4   | 4     | 4      | 16     | 3   | 4    |\n| 2021.04.05T09:41:00 | 000001 | 5    | 5   | 5   | 5     | 5      | 25     | 4   | 5    |\n\n```\nshare streamTable(1000:0, [\"time\",\"sym\",\"qty\"], [DATETIME, SYMBOL, INT]) as trades\nshare table(10000:0, [\"time\",\"sym\",\"sumQty\"], [DATETIME, SYMBOL, INT]) as output5\n\nengine = createTimeSeriesEngine(name=\"engine\", windowSize=6, step=6, metrics=<sum(qty)>, dummyTable=trades, outputTable=output5, timeColumn=\"time\",keyColumn=\"sym\", forceTriggerTime=7,fill=1000)\nsubscribeTable(tableName=\"trades\", actionName=\"engine\", offset=0, handler=append!{engine}, msgAsTable=true)\nsleep(1000)\ninsert into engine values(2018.08.01T14:05:43,`A,1)\ninsert into engine values(2018.08.01T14:05:43,`C,3)\nsleep(10)\ninsert into engine values(2018.08.01T14:05:44,`B,1)\nsleep(80)\ninsert into engine values(2018.08.01T14:05:52,`B,3)\nsleep(20)\ninsert into engine values(2018.08.01T14:05:54,`A,3)\nsleep(10)\ninsert into engine values(2018.08.01T14:05:55,`A,5)\nsleep(20)\ninsert into engine values(2018.08.01T14:05:57,`B,5)\nsleep(50)\ninsert into engine values(2018.08.01T14:06:12,`A,1)\nsleep(50)\nselect * from output5 order by sym\n```\n\n| time                | sum | Qty   |\n| ------------------- | --- | ----- |\n| 2018.08.01T14:05:46 | A   | 1     |\n| 2018.08.01T14:05:52 | A   | 1,000 |\n| 2018.08.01T14:05:58 | A   | 8     |\n| 2018.08.01T14:06:04 | A   | 1,000 |\n| 2018.08.01T14:06:10 | A   | 1,000 |\n| 2018.08.01T14:05:46 | B   | 1     |\n| 2018.08.01T14:05:52 | B   | 1,000 |\n| 2018.08.01T14:05:58 | B   | 8     |\n| 2018.08.01T14:05:46 | C   | 3     |\n| 2018.08.01T14:05:52 | C   | 1,000 |\n\n例3. 下例计算每个分组窗口的第一个和最后一个 volume，组合后输出为一个数组向量。\n\n```\n//通过 defg 自定义一个函数，引擎在调用该函数时会将返回值转换为数组向量\ndefg toVector(x){\n\treturn x\t\n}\nshare streamTable(1000:0, [\"time\",\"sym\",\"volume\",\"price\"], [TIMESTAMP, SYMBOL, DOUBLE,DOUBLE]) as trades\n//定义输出表，对应 toVector 指标输出的列需要定义为数组向量类型，此例中将其定义为 DOUBLE[]\nshare table(10000:0, [\"time\",\"sym\",\"sumVolume\",\"avg\"], [TIMESTAMP,STRING,DOUBLE[],DOUBLE]) as output6\n//metrics 中调用了 toVector 函数，将1分钟窗口内的第一个 volume 和最后一个 volume 组合到一个向量中。\nengine1 = createTimeSeriesEngine(name=\"engine1\", windowSize=60000, step=60000, metrics=<[toVector([first(volume),last(volume)]),avg(volume+price)]>, dummyTable=trades, outputTable=output6, timeColumn=\"time\", keyColumn=\"sym\" , useSystemTime=false, garbageSize=50, useWindowStartTime=false)\n\ntimes = sort(2023.10.08T00:00:00.000 + rand(1..(1+3000*200), 30))\nsyms = rand(\"A\"+string(1..10), 30)\nvolumes = rand(rand(100.0, 10) join 2.3 NULL NULL NULL NULL, 30)\nprices = rand(rand(100.0, 10) join 2.3 NULL NULL NULL NULL, 30)\nt=table(times as time, syms as sym, volumes as volume,prices as price)\n\nengine1.append!(t)\n\nselect * from output6 where time between 2023.10.08T00:01:00.000 and 2023.10.08T00:05:00.000 order by time,sym \n```\n\n| time                    | sym | sumVolume      | avg      |\n| ----------------------- | --- | -------------- | -------- |\n| 2023.10.08T00:01:00.000 | A1  | \\[57.66,]      | 80.428   |\n| 2023.10.08T00:01:00.000 | A2  | \\[,]           |          |\n| 2023.10.08T00:02:00.000 | A7  | \\[,]           |          |\n| 2023.10.08T00:02:00.000 | A8  | \\[,]           |          |\n| 2023.10.08T00:03:00.000 | A2  | \\[,41.25]      | 101.7832 |\n| 2023.10.08T00:03:00.000 | A3  | \\[41.25,41.25] | 68.4897  |\n| 2023.10.08T00:03:00.000 | A6  | \\[,]           |          |\n| 2023.10.08T00:03:00.000 | A8  | \\[19.17,19.17] | 93.9934  |\n| 2023.10.08T00:04:00.000 | A7  | \\[,]           |          |\n| 2023.10.08T00:05:00.000 | A3  | \\[2.05,2.05]   | 95.433   |\n| 2023.10.08T00:05:00.000 | A5  | \\[55.93,55.93] | 116.4669 |\n| 2023.10.08T00:05:00.000 | A9  | \\[42.66,42.66] |          |\n\n例4.本例将说明 *subWindow* 参数的作用。\n\n```\nshare streamTable(1000:0, [\"time\",\"sym\",\"volume\"], [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(10000:0, [\"time\",\"sym\",\"sumVolume\"], [TIMESTAMP, SYMBOL, INT]) as output7\n//在长度为 1 分钟的窗口内指定一个子窗口，未指定 closed 时，子窗口左闭右开。这里子窗口为每分钟的[0s, 10s)\nengine4 = createTimeSeriesEngine(name=\"engine4\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output7, timeColumn=\"time\", useSystemTime=false, keyColumn=\"sym\", garbageSize=50, useWindowStartTime=true, subWindow=0s:10s)\n\nsubscribeTable(tableName=\"trades\", actionName=\"engine4\", offset=0, handler=append!{engine4}, msgAsTable=true);\n\ninsert into trades values(2018.10.08T01:01:01.785,`A,10)\ninsert into trades values(2018.10.08T01:01:02.125,`B,26)\ninsert into trades values(2018.10.08T01:01:10.000,`A,14)\ninsert into trades values(2018.10.08T01:01:12.457,`A,28)\n\nsleep(10)\n\nselect * from output7;\n```\n\n2018.10.08T01:01:10.000 时刻的数据触发 \\[2018.10.08T01:01:00.000, 2018.10.08T01:01:10.000) 区间内 A 组数据对应的 volume 的总和。在子窗口结束后没有再收到 B 组的数据，因此 B 组子窗口内数据\n\n<table id=\"table_mzg_pwy_21c\"><thead><tr><th>\n\ntime\n\n</th><th>\n\nsym\n\n</th><th>\n\nsumVolume\n\n</th></tr></thead><tbody><tr><td>\n\n2018.10.08T01:01:10.000\n\n</td><td>\n\nA\n\n</td><td>\n\n10\n\n</td></tr></tbody>\n</table>**Related information**  \n\n[createDailyTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createDailyTimeSeriesEngine.html)\n"
    },
    "createTimeSeriesEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesEngine.html",
        "signatures": [
            {
                "full": "createTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, [timeColumn], [useSystemTime=false], [keyColumn], [garbageSize], [updateTime], [useWindowStartTime], [roundTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [fill='none'], [forceTriggerTime], [raftGroup], [keyPurgeFreqInSec=-1], [closed='left'], [outputElapsedMicroseconds=false], [subWindow], [parallelism=1],[acceptedDelay=0], [outputHandler=NULL], [msgAsTable=false])",
                "name": "createTimeSeriesEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "windowSize",
                        "name": "windowSize"
                    },
                    {
                        "full": "step",
                        "name": "step"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[updateTime]",
                        "name": "updateTime",
                        "optional": true
                    },
                    {
                        "full": "[useWindowStartTime]",
                        "name": "useWindowStartTime",
                        "optional": true
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[fill='none']",
                        "name": "fill",
                        "optional": true,
                        "default": "'none'"
                    },
                    {
                        "full": "[forceTriggerTime]",
                        "name": "forceTriggerTime",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSec=-1]",
                        "name": "keyPurgeFreqInSec",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[subWindow]",
                        "name": "subWindow",
                        "optional": true
                    },
                    {
                        "full": "[parallelism=1]",
                        "name": "parallelism",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[acceptedDelay=0]",
                        "name": "acceptedDelay",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[outputHandler=NULL]",
                        "name": "outputHandler",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesEngine.html)\n\n\n\n#### 语法\n\ncreateTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, \\[timeColumn], \\[useSystemTime=false], \\[keyColumn], \\[garbageSize], \\[updateTime], \\[useWindowStartTime], \\[roundTime=true], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[fill='none'], \\[forceTriggerTime], \\[raftGroup], \\[keyPurgeFreqInSec=-1], \\[closed='left'], \\[outputElapsedMicroseconds=false], \\[subWindow], \\[parallelism=1],\\[acceptedDelay=0], \\[outputHandler=NULL], \\[msgAsTable=false])\n\n别名：createTimeSeriesAggregator\n\n#### 详情\n\n创建流数据时间序列引擎，以实现基于时间的滑动窗口或滚动窗口进行实时计算。\n\n时序引擎的聚合计算的算子分为增量计算和全量计算两种。增量计算算子不会保留历史数据，每次有数据进来就会进行增量计算；而全量计算算子（例如自定义的聚合函数，或未经优化的内置聚合函数，亦或是嵌套了状态函数的函数）会保留窗口内完整的数据，待触发输出时进行全量计算。\n\n时序引擎对以下聚合计算算子进行了优化，实现了增量计算，显著提升了性能：corr, covar, first, last, max, med, min, percentile, quantile, std, var, sum, sum2, sum3, sum4, wavg, wsum, count, firstNot, ifirstNot, lastNot, ilastNot, imax, imin, nunique, prod, sem, mode, searchK, beta, avg。\n\n更多流数据引擎的应用场景说明可以参考 [内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)。\n\n\\*\\*返回值：\\*\\*一个表对象，通过向该表对象写入，将数据注入时间序列引擎进行计算。\n\n##### 窗口\n\n* 窗口边界规整：对起始窗口左边界进行规整。（详情请参考 *step* 和 *roundTime* 的参数说明以及 `规整规则表`）\n\n* 窗口确定：\n\n  * *windowSize* 确定窗口长度。\n\n  * *closed* 确定窗口左闭右开或左开右闭。\n\n  * *step* 确定滑动的步长。\n\n  其中，*windowSize* 与 *step* 的单位取决于 *useSystemTime* 参数。若 *useSystemTime* = true， *windowSize* 与 *step* 的单位是毫秒。若 *useSystemTime* = false，*windowSize* 与 *step* 的单位同 *timeColumn* 列的精度一致。\n\n* 窗口截取：*useSystemTime* 参数决定了如何截取窗口，可以基于数据的时间列，亦可以基于数据注入系统的时间进行截取。\n\n##### 计算\n\n* 计算前提：若指定了 *timeColumn*，则 *timeColumn* 的时间必须递增；若同时指定了 *keyColumn*，则按照分组分别进行滑动窗口计算，*timeColumn* 在每组内的时间必须递增。否则，时间乱序的数据在计算中会被直接丢弃。\n\n* 触发规则：若指定了 *timeColumn*，当前窗口的计算将由该窗口结束后收到的第一条数据触发；若设置 *useSystemTime* = true，窗口结束后会自动触发计算。\n\n* 强制触发规则：对长时间未触发计算的窗口数据，可以通过设置 *updateTime* 或 *forceTriggerTime* 强制触发计算。具体规则请参考参数说明。\n\n* 窗口填充规则：未指定 *fill* 或指定 *fill* = \"none\" 时，只会输出计算结果不为空的窗口；若指定了 *fill*，则会输出所有窗口，且根据 *fill* 规则对结果为空的窗口进行填充。\n\n##### 其它功能\n\n* 支持数据/状态清理：清理引擎中堆积的数据和不再需要的状态信息。（详情请参考 *garbageSize* 和 *keyPurgeFreqInSec* 的参数说明）\n\n* 快照机制：启用快照机制之后，系统若出现异常，可及时将流数据引擎恢复到最新的快照状态。（详情请参考 *snapshotDir* 和 *snapshotIntervalInMsgCount* 的参数说明）\n\n* 流数据引擎高可用：若要启用引擎高可用，需在订阅端 raft 组的 leader 节点创建引擎并通过 *raftGroup* 参数开启高可用。开启高可用后，当 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。（详情请参考 *raftGroup* 的参数说明）\n\n#### 参数\n\n**name** 字符串标量，表示时间序列引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**windowSize** 正整数标量或向量，表示滑动窗口的长度。\n\n**step** 正整数标量，表示滑动窗口移动的步长。 *windowSize* 必须是 *step* 的整数倍，否则会抛出异常。*windowSize* 和 *step* 的单位与 *useSystemTime* 有关：\n\n* 若 *useSystemTime* 为 true，则 *windowSize* 和 *step* 的单位为毫秒。\n\n* 若 *useSystemTime* 为 false，则 *windowSize* 和 *step* 的单位与 *timeColumn* 的时间精度一致。\n\n**metrics** 以元代码的格式表示计算指标，支持输入元组。有关元代码的更多信息可参考 [元编程](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n* 计算指标可以是一个或多个系统内置或用户自定义的聚合函数（使用 defg 关键字定义），如 <\\[sum(volume), avg(price)]>；可以对聚合结果使用表达式，如 <\\[avg(price1)-avg(price2)]>；也可对列与列的计算结果进行聚合计算，如 <\\[std(price1-price2)]>。\n\n* *metrics* 内支持调用具有多个返回值的函数，例如 \\<func(price) as \\`col1\\`col2>（可不指定列名）。\n\n* 若 *windowSize* 为向量， *windowSize* 每个值可对应 *metrics* 中多个计算指标。例如，*windowSize* 为\\[10,20]时，metrics可为 (<\\[min(volume), max(volume)]>, \\<sum(volume)>)。 *metrics* 也可以嵌套输入元组向量。例如：\\[\\[<\\[min(volume), max(volume)]>, \\<sum(volume)>], \\[\\<avg(volume)>]]\n\n  **Note:**\n\n  * *metrics* 中使用的列名大小写不敏感，不需要与输入表的列名大小写保持一致。\n  * *metrics* 中不可使用嵌套聚合函数。\n\n**dummyTable** 一个表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。\n\n**outputTable** 计算结果的输出表，可以是内存表或者分布式表。在使用 `createTimeSeriesEngine` 函数之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。时间序列引擎会将计算结果插入该表。\n\n* 输出表的列顺序如下：\n\n  1. 时间列。其中：\n\n     * 若 *useSystemTime* = true，为 TIMESTAMP 类型；反之，该列数据类型与 *timeColumn* 列一致。\n\n     * 若 *useWindowStartTime* = true，显示时间为数据窗口起始时间；反之，显示时间为数据窗口终止时间。\n\n  2. 分组列。如果 *keyColumn* 不为空，则其后几列和 *keyColumn* 设置的列及其顺序保持一致。\n\n  3. 耗时列。如果指定 *outputElapsedMicroseconds* = true，则指定一个 LONG 类型的列用于存储耗时（单位：微秒）。\n\n  4. 计算结果列。可为多列。\n\n  **Note:** 自 2.00.10 版本开始，引擎支持通过自定义聚合函数，将多个计算结果以 array vector 的形式输出，此时必须在 *outputTable* 中指定对应列类型为 array vector，详见例2。\n\n**timeColumn** 可选参数，字符串标量或向量。当 *useSystemTime* = false 时，必须指定该参数。 该参数用于指定订阅的流数据表中时间列的名称。\n\n**Note:** 字符串向量必须是 date 和 time 组成的向量，date 类型为 DATE，time 类型为 TIME, SECOND 或 NANOTIME。此时，输出表第一列的时间类型必须与 [concatDateTime(date, time)](https://docs.dolphindb.cn/zh/funcs/c/concatDateTime.html) 的类型一致。\n\n**useSystemTime** 可选参数，布尔值，表示是否使用数据注入引擎时的系统时间作为时间列进行计算。\n\n* 当 *useSystemTime* = true时，时间序列引擎会按照数据注入时间序列引擎的时刻（毫秒精度的本地系统时间，与数据中的时间列无关），每隔固定时间截取固定长度窗口的流数据进行计算。只要一个数据窗口中含有数据，数据窗口结束后就会自动进行计算。结果中的第一列为计算发生的时间戳，与数据中的时间无关。\n\n* 当 *useSystemTime* = false（缺省值）时，时间序列引擎根据流数据中的 *timeColumn* 列来截取数据窗口。一个数据窗口结束后的第一条新数据才会触发该数据窗口的计算。请注意，触发计算的数据并不会参与该次计算。\n\n  例如，一个数据窗口从 10:10:10 到 10:10:19。若 *useSystemTime* = true，则只要该窗口中至少有一条数据，该窗口的计算会在窗口结束后的 10:10:20 触发。若 *useSystemTime* = false，且 10:10:19 后的第一条数据为 10:10:25，则该窗口的计算会在 10:10:25 触发。\n\n**keyColumn** 可选参数，字符串标量或向量，表示分组列名。若设置，则分组进行聚合计算，例如以每支股票为一组进行聚合计算。\n\n**garbageSize** 可选参数，正整数，默认值是 50,000（单位为行）。随着订阅的流数据不断积累，注入时间序列引擎，存放在内存中的数据会越来越多，这时需要清理不再需要的历史数据。当内存中历史数据行数超过 *garbageSize* 值时，系统会清理本次计算不需要的历史数据。如果指定了 *keyColumn*，内存清理是各组内独立进行的。当一个组在内存中的历史数据记录数超出 *garbageSize* 时，会清理该组中本次计算中不需要的历史数据。\n\n**Note:** 对于增量计算算子，系统会自动清理不再需要的历史数据。而对于全量计算算子，需要指定该参数来触发清理历史数据。\n\n**updateTime** 可选参数，非负整数，单位与 timeColumn 的时间精度一致。用于指定比 *step* 更短的计算时间间隔。*step* 必须是 *updateTime* 的整数倍。要设置 *updateTime*， *useSystemTime* 必须设为 false。\n\n如果没有指定 *updateTime*，一个数据窗口结束前，不会发生对该数据窗口数据的计算。若一个窗口长时间未触发计算，可以指定 updateTime，分多次触发当前窗口数据的计算。计算触发的规则为：\n\n* updateTime 指定为正整数值时：\n\n  * 从当前窗口的左边界开始，每隔 *updateTime* 时间，若有新的数据到来，则对当前窗口内该数据之前的所有数据进行计算。\n\n  * 如果系统经过 2 \\* *updateTime* （至少2秒）后仍有未被处理的数据，则触发对当前窗口内所有数据的计算。\n\n  * 若分组计算，则每组内进行上述操作。\n\n* updateTime 指定为 0 时：在新的数据到来后，立即对当前窗口的最新数据计算并输出。\n\n指定 *updateTime* 后，建议使用键值内存表作为输出表。因为每次计算均会增加一条记录，输出表若使用普通内存表或流数据表，则会产生大量带有相同时间戳的结果。因为键值流数据表不可更新记录，输出表亦不推荐使用键值流数据表。\n\n**useWindowStartTime** 可选参数，布尔值，表示输出表中的时间是否为数据窗口起始时间。默认值为 false，表示输出表中的时间为数据窗口起始时间 + *windowSize* 。若 *windowSize* 是向量， *useWindowStartTime* 必须为 false。\n\n**roundTime** 可选参数，布尔值，表示若数据时间精度为毫秒或者秒且 *step* > 一分钟，如何对窗口边界值进行规整处理。默认值为 true，表示按照既定的多分钟规则进行规整。若为 false，则按一分钟规则进行窗口规整。\n\n若要开启快照机制（snapshot），必须指定 *snapshotDir* 与 *snapshotIntervalInMsgCount*。\n\n**snapshotDir** 可选参数，字符串，表示保存引擎快照的文件目录。\n\n* 指定的目录必须存在，否则系统会提示异常。\n\n* 创建流数据引擎时，如果指定了 *snapshotDir*，会检查该目录下是否存在快照。如果存在，会加载该快照，恢复引擎的状态。\n\n* 多个引擎可以指定同一个目录存储快照，用引擎的名称来区分快照文件。\n\n* 一个引擎的快照可能会使用三个文件名：\n\n  * 临时存储快照信息：文件名为 \\<engineName>.tmp；\n\n  * 快照生成并刷到磁盘：文件保存为 \\<engineName>.snapshot；\n\n  * 存在同名快照：旧快照自动重命名为 \\<engineName>.old。\n\n**snapshotIntervalInMsgCount** 可选参数，为整数类型，表示每隔多少条数据保存一次流数据引擎快照。\n\n**fill** 可选参数，一个标量或向量，指定某个分组的某个窗口无数据时的处理方法。可取以下值：\n\n* 'none': 不输出结果。\n* 'null': 输出结果为 NULL。\n* 'ffill': 输出上一个有数据的窗口的结果。\n* '具体数值'：该值的数据类型需要和对应的 *metrics* 计算结果的类型保持一致。\n\n*fill* 可以输入向量，长度与 *metrics* 元素个数保持一致，表示为每个 *metrics* 指定不同的 *fill* 方式。若为向量，向量中各项只能是 'null', 'ffill' 或一个数值，不能是 'none'。\n\n**forceTriggerTime** 可选参数，是非负整数，单位与 *timeColumn* 的时间精度一致。用于强制触发各个分组未计算的窗口进行计算。要设置 *forceTriggerTime*， *useSystemTime* 必须设置为 false，且不能指定 *updateTime*。强制触发计算及输出规则如下：\n\n1. 未被触发计算的窗口结束后（窗口结束时刻为 t），若收到了其他分组的数据（时间戳为 t1），且满足 t1-t ≥ *forceTriggerTime*，则该窗口将被触发计算。\n\n2. 如果某个分组在最后一个窗口被强制触发计算后，没有再收到新的数据，但其他分组仍然收到了新的数据，那么通过 *fill* 来填充该分组的所有缺失窗口，可以确保在最新时间截面上仍然输出该分组的窗口。如果不指定 *fill*，则最后一个窗口被触发计算后，该分组不会产生新的窗口。\n\n设置 *forceTriggerTime* 或 *updateTime* 时需注意以下几点：\n\n* 设置 *updateTime*，计算发生后仍有属于当前窗口的数据到达时，当前窗口计算结果会再次更新；\n\n* 设置 *forceTriggerTime*，则触发计算之后收到的数据会被丢弃，建议不要设置太小的 *forceTriggerTime*。\n\n**raftGroup** 可选参数，表示流数据高可用订阅端 raft 组的 ID (大于1的整数，由流数据高可用相关的配置项 *streamingRaftGroups* 指定)。设置该参数表示开启计算引擎高可用。在 leader 节点创建流数据引擎后，会同步在 follower 节点创建该引擎。每次保存的 snapshot 也会同步到 follower。当 raft 组的 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。请注意，若要指定 *raftGroup*，必须同时指定 *snapshotDir*。\n\n**keyPurgeFreqInSec** 正整数，表示清理窗口数据为空的分组的时间间隔，单位为秒。指定该参数后，若当前数据注入时间与上一次清理时间的间隔大于等于 *keyPurgeFreqInSec*，则触发对当前窗口数据为空的分组信息的清理。\n\n**Note:**\n\n* 若需指定该参数，必须指定 *forceTriggerTime*，且不能指定 *fill*。\n\n* 可以通过调用 [getStreamEngineStat](https://docs.dolphindb.cn/zh/funcs/g/getStreamEngineStat.html) 函数查看 TimeSeriesEngine 引擎状态的 numGroups 列，来对比响应式状态引擎清理前后分组数的变化。\n\n**closed** 字符串，用于确定滑动窗口边界的开闭情况。可选值为 'left' 或 'right'，默认值为 'left'。\n\n* closed = 'left'： 窗口左闭右开。\n\n* closed = 'right'： 窗口左开右闭。\n\n**outputElapsedMicroseconds** 布尔值，表示是否输出每个窗口从触发计算到计算完成输出结果的耗时（若指定了 *keyColumn* 则包含数据分组的耗时），默认为 false。指定参数 *outputElapsedMicroseconds* 后，在定义 *outputTable* 时需要在时间列和分组列后增加一个 LONG 类型的列，详见 *outputTable* 参数说明。\n\n**subWindow**整型或者 DURATION 数据对。在滑动窗口内指定子窗口，仅计算子窗口内的数据。子窗口边界的开闭情况由参数 *closed* 决定。子窗口结束后收到第一条数据触发对子窗口内数据的计算（参考例4）。当 *subWindow*为整型数据对时，其单位与 *timeColumn* 的时间精度一致。若指定 *subWindow*，则：\n\n* *windowSize*和 *step*必须相等。\n\n* 不可设置 *updateTime*>0和 *useSystemTime*=true。\n\n**parallelism** 为不超过 63 的正整数，可选参数，表示并行计算的工作线程数，默认值为 1。在计算量较大时，合理地调整该参数能够有效利用计算资源，降低计算耗时。建议小于机器核数，推荐值为 4 到 8 。\n\n**acceptedDelay** 为小于等于 *windowSize* 的正整数，可选参数。指定每个窗口接收数据的最大延迟，默认值为 0。若设置该参数，则不能设置 *forceTriggerTime* 或 *updateTime*。\n\n* 当 useSystemTime= true 时，窗口结束后 *acceptedDelay* 时间内接收到的数据，仍然属于此窗口并参与计算，而不会参与下一个窗口的计算。\n\n* 当 useSystemTime= false 时，该参数用于处理乱序数据。假设当前窗口结束的时间戳为 t ，若收到一条时间戳大于等于 t+*acceptedDelay*的数据，则触发在此之前收到的所有属于当前窗口的数据进行计算输出，并关闭该窗口。\n\n**outputHandler** 一元函数。设置此参数时，引擎计算结束后，不再将计算结果写到输出表，而是会调用此函数处理计算结果。默认值为 NULL，表示仍将结果写到输出表。\n\n**msgAsTable** 布尔标量，表示在设置了参数 outputHandler 时，将引擎的计算结果以表的结构调用函数。默认值为 false，此时将计算结果的每一列作为元素组成元组。\n\n##### 规整规则\n\n为了便于观察和对比计算结果，系统会对第一个数据窗口的起始时间进行规整，根据 *step* 参数、数据的时间精度，以及 *roundTime* 参数来确定整数类型的规整尺度 alignmentSize。当时间序列引擎使用分组计算时，所有分组的窗口均进行统一的规整。相同时刻的数据窗口在各组均有相同的边界。\n\n* 若数据的时间精度为分钟，如 MINUTE(HH:mm) 类型，alignmentSize 取值如下：\n\n*若 roundTime = false*：\n\n| step   | alignmentSize |\n| ------ | ------------- |\n| 0\\~2   | 2             |\n| 3      | 3             |\n| 4\\~5   | 5             |\n| 6\\~10  | 10            |\n| 11\\~15 | 15            |\n| 16\\~20 | 20            |\n| 21\\~30 | 30            |\n| >30    | 60 (1小时)      |\n\n*若 roundTime = true*:\n\n当 step <= 30 时，alignmentSize 取值同上表。当 step > 30 时，alignmentSize 取值见下表：\n\n| step       | alignmentSize |\n| ---------- | ------------- |\n| 31\\~60     | 60 (1小时)      |\n| 61\\~120    | 120 (2小时)     |\n| 121\\~180   | 180 (3小时)     |\n| 181\\~300   | 300 (5小时)     |\n| 301\\~600   | 600 (10小时)    |\n| 601\\~900   | 900 (15小时)    |\n| 901\\~1200  | 1200 (20小时)   |\n| 1201\\~1800 | 1800 (30小时)   |\n| >1800      | 3600 (60小时)   |\n\n* 若数据的时间精度为秒，如 DATETIME(yyyy-MM-dd HH:mm:ss) 与 SECOND(HH:mm:ss) 类型，alignmentSize 的 取值如下：\n\n*若 roundTime = false*：\n\n| step   | alignmentSize |\n| ------ | ------------- |\n| 0\\~2   | 2             |\n| 3      | 3             |\n| 4\\~5   | 5             |\n| 6\\~10  | 10            |\n| 11\\~15 | 15            |\n| 16\\~20 | 20            |\n| 21\\~30 | 30            |\n| >30    | 60 (1分钟)      |\n\n*若 roundTime = true*:\n\n当 step <= 30 时，alignmentSize 取值同上表。当 step > 30 时，alignmentSize 取值见下表：\n\n| step       | alignmentSize |\n| ---------- | ------------- |\n| 31\\~60     | 60 (1分钟)      |\n| 61\\~120    | 120 (2分钟)     |\n| 121\\~180   | 180 (3分钟)     |\n| 181\\~300   | 300 (5分钟)     |\n| 301\\~600   | 600 (10分钟)    |\n| 601\\~900   | 900 (15分钟)    |\n| 901\\~1200  | 1200 (20分钟)   |\n| 1201\\~1800 | 1800 (30分钟)   |\n| >1800      | 3600 (1小时)    |\n\n* 若数据的时间精度为毫秒，如 TIMESTAMP(yyyy-MM-dd HH:mm:ss.mmm) 与 TIME(HH:mm:ss.mmm) 类型，alignmentSize 的取值如下：\n\n*若 roundTime = false*:\n\n| step         | alignmentSize |\n| ------------ | ------------- |\n| 0\\~2         | 2             |\n| 3\\~5         | 5             |\n| 6\\~10        | 10            |\n| 11\\~20       | 20            |\n| 21\\~25       | 25            |\n| 26\\~50       | 50            |\n| 51\\~100      | 100           |\n| 101\\~200     | 200           |\n| 201\\~250     | 250           |\n| 251\\~500     | 500           |\n| 501\\~1000    | 1000（1秒）      |\n| 1001\\~2000   | 2000（2秒）      |\n| 2001\\~5000   | 5000（5秒）      |\n| 5001\\~10000  | 10000（10秒）    |\n| 10001\\~15000 | 15000（15秒）    |\n| 15001\\~20000 | 20000（20秒）    |\n| 20001\\~30000 | 30000（30秒）    |\n| >30000       | 60000（1分钟）    |\n\n*若 roundTime = true*:\n\n若 *step* <= 30000，alignmentSize 取值同上表；若 *step* > 30000，alignmentSize 取值见下表：\n\n| step             | alignmentSize |\n| ---------------- | ------------- |\n| 30001\\~60000     | 60000（1分钟）    |\n| 60001\\~120000    | 120000（2分钟）   |\n| 120001\\~300000   | 300000（5分钟）   |\n| 300001\\~600000   | 600000（10分钟）  |\n| 600001\\~900000   | 900000（15分钟）  |\n| 900001\\~1200000  | 1200000（20分钟） |\n| 1200001\\~1800000 | 1800000（30分钟） |\n| >1800000         | 3600000（1小时）  |\n\n* 若数据的时间精度为纳秒，如 NANOTIMESTAMP(yyyy-MM-dd HH:mm:ss.nnnnnnnnn) 与 NANOTIME(HH:mm:ss.nnnnnnnnn) 类型，alignmentSize 的取值如下：\n\n*若 roundTime = false*:\n\n| step         | alignmentSize |\n| ------------ | ------------- |\n| 0\\~2ns       | 2ns           |\n| 3ns\\~5ns     | 5ns           |\n| 6ns\\~10ns    | 10ns          |\n| 11ns\\~20ns   | 20ns          |\n| 21ns\\~25ns   | 25ns          |\n| 26ns\\~50ns   | 50ns          |\n| 51ns\\~100ns  | 100ns         |\n| 101ns\\~200ns | 200ns         |\n| 201ns\\~250ns | 250ns         |\n| 251ns\\~500ns | 500ns         |\n| >500ns       | 1000ns        |\n\n*若 roundTime = true*:\n\n| step        | alignmentSize |\n| ----------- | ------------- |\n| 1000ns\\~1ms | 1ms           |\n| 1ms\\~10ms   | 10ms          |\n| 10ms\\~100ms | 100ms         |\n| 100ms\\~1s   | 1s            |\n| 1s\\~2s      | 2s            |\n| 2s\\~3s      | 3s            |\n| 3s\\~5s      | 5s            |\n| 5s\\~10s     | 10s           |\n| 10s\\~15s    | 15s           |\n| 15s\\~20s    | 20s           |\n| 20s\\~30s    | 30s           |\n| >30s        | 1min          |\n\n假设第一条数据的时间为 x, 那么根据其类型，第一个数据窗口的左边界的计算规则为：`timeType_cast(x/alignmentSize*alignmentSize+step-windowSize)`。其中，timeType\\_cast 表示依据时间精度，需要强制转换的时间类型；'/' 表示整除。例如，第一条数据的时间为 2018.10.08T01:01:01.365，windowSize 为 120000，step 为 60000，那么 alignmentSize 为 60000，第一个数据窗口的左边界为 `timestamp(2018.10.08T01:01:01.365/60000*60000+60000-120000)`，即 2018.10.08T01:00:00.000。\n\n#### 例子\n\n**Note:** 以下例子使用了相同的变量和表名便于比较。每个例子执行结束后，请使用以下命令清除环境中的临时数据：\n\n* [getStreamingStat](https://docs.dolphindb.cn/zh/funcs/g/getStreamingStat.html)：用于查看当前的流数据表订阅者。例如：\n\n  ```\n  getStreamingStat().pubTables\n  ```\n\n* [unsubscribeTable](https://docs.dolphindb.cn/zh/funcs/u/unsubscribeTable.html)：用于取消订阅流数据表。例如，在例子 1 代码运行后取消对 trades 的订阅：\n\n  ```\n  unsubscribeTable(tableName=\"trades\", actionName=\"engine1\")\n  ```\n\n* [dropStreamTable](https://docs.dolphindb.cn/zh/funcs/d/dropStreamTable.html)：用于删除流数据表。例如，删除例子 1 中的流数据表 trades：\n\n  ```\n  dropStreamTable(tableName=\"trades\")\n  ```\n\n* [dropStreamEngine](https://docs.dolphindb.cn/zh/funcs/d/dropStreamEngine.html)：用于流数据引擎。例如，删除例子 1 中的流数据引擎 engine1：\n\n  ```\n  dropStreamEngine(\"engine1\")\n  ```\n\n例1. 时间序列引擎 engine1 订阅流数据表 trades，实时计算表 trades 中过去1分钟内每只股票交易量之和。\n\n```\nshare streamTable(1000:0, [\"time\",\"sym\",\"volume\"], [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(10000:0, [\"time\",\"sym\",\"sumVolume\"], [TIMESTAMP, SYMBOL, INT]) as output1\nengine1 = createTimeSeriesEngine(name=\"engine1\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=\"time\", useSystemTime=false, keyColumn=\"sym\", garbageSize=50, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=append!{engine1}, msgAsTable=true);\n\ninsert into trades values(2018.10.08T01:01:01.785,`A,10)\ninsert into trades values(2018.10.08T01:01:02.125,`B,26)\ninsert into trades values(2018.10.08T01:01:10.263,`B,14)\ninsert into trades values(2018.10.08T01:01:12.457,`A,28)\ninsert into trades values(2018.10.08T01:02:10.789,`A,15)\ninsert into trades values(2018.10.08T01:02:12.005,`B,9)\ninsert into trades values(2018.10.08T01:02:30.021,`A,10)\ninsert into trades values(2018.10.08T01:04:02.236,`A,29)\ninsert into trades values(2018.10.08T01:04:04.412,`B,32)\ninsert into trades values(2018.10.08T01:04:05.152,`B,23)\n\nsleep(10)\n\nselect * from output1;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:02:00.000 | A   | 38        |\n| 2018.10.08T01:02:00.000 | B   | 40        |\n| 2018.10.08T01:03:00.000 | A   | 25        |\n| 2018.10.08T01:03:00.000 | B   | 9         |\n\n下面详细解释时间序列引擎的计算过程。为简便起见，以下提到时间时，省略相同的日期部分，只列出（小时:分钟:秒.毫秒）部分。\n\n首先，时间序列引擎对第一个数据窗口的起始时间进行规整。第一个数据窗口的时间范围是 01:01:00.000 到 01:02:00.000，只包含左边界，不包含右边界。当(01:02:10.789,`A,15)到达时，触发第一个窗口 A 组计算；当(01:02:12.005,`B,9)到达时，触发第一个窗口 B 组计算。\n\n第二个数据窗口的时间范围是 01:02:00.000 到 01:03:00.000。当(01:04:02.236,`A,29)到达时，触发第二个窗口 A 组计算；当(01:04:04.412,`B,32)到达时，触发第二个窗口 B 组计算。\n\n由于 01:05:00.000 及之后没有数据，因此没有对 01:04:00.000 到 01:05:00.000 之间的数据进行计算。\n\n输出表 output1 保存了时间序列引擎的计算结果。由于 *useWindowStartTime* 为 false，因此输出表 output1 中的时间为窗口的结束时间。若将 *useWindowStartTime* 设为 true，则输出表中的时间为窗口的起始时间。例如：\n\n```\noutput2 = table(10000:0, [\"time\",\"sym\",\"sumVolume\"], [TIMESTAMP, SYMBOL, INT])\nengine2 = createTimeSeriesEngine(name=\"engine2\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output2, timeColumn=\"time\", useSystemTime=false, keyColumn=\"sym\", garbageSize=50, useWindowStartTime=true)\nsubscribeTable(tableName=\"trades\", actionName=\"engine2\", offset=0, handler=append!{engine2}, msgAsTable=true)\n\nsleep(10)\nselect * from output2;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:01:00.000 | A   | 38        |\n| 2018.10.08T01:01:00.000 | B   | 40        |\n| 2018.10.08T01:02:00.000 | A   | 25        |\n| 2018.10.08T01:02:00.000 | B   | 9         |\n\n下例中指定 *updateTime* 为 1000（毫秒）：\n\n```\n\nshare keyedTable([\"time\",\"sym\"],10000:0, [\"time\",\"sym\",\"sumVolume\"], [TIMESTAMP, SYMBOL, INT]) as output3\nengine3 = createTimeSeriesEngine(name=\"engine3\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output3, timeColumn=\"time\", useSystemTime=false, keyColumn=\"sym\", garbageSize=50, updateTime=1000, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"engine3\", offset=0, handler=append!{engine3}, msgAsTable=true)\n\nsleep(2001)\nselect * from output3;\n```\n\n| time                    | sym | sumVolume |\n| ----------------------- | --- | --------- |\n| 2018.10.08T01:02:00.000 | A   | 38        |\n| 2018.10.08T01:02:00.000 | B   | 40        |\n| 2018.10.08T01:03:00.000 | A   | 25        |\n| 2018.10.08T01:03:00.000 | B   | 9         |\n| 2018.10.08T01:05:00.000 | B   | 55        |\n| 2018.10.08T01:05:00.000 | A   | 29        |\n\n例2. 下例中指定 *updateTime* 为 0（毫秒）：\n\n```\nshare streamTable(1000:0, [\"time\",\"sym\",\"volume\"], [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(1000:0, [\"time\",\"sym\",\"sumVolume\"], [TIMESTAMP, SYMBOL, INT]) as output4\nengine4 = createTimeSeriesEngine(name=\"engine4\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output4, timeColumn=\"time\", useSystemTime=false, keyColumn=\"sym\", garbageSize=50, updateTime=0, useWindowStartTime=false)\nsubscribeTable(tableName=\"trades\", actionName=\"engine4\", offset=0, handler=append!{engine4}, msgAsTable=true);\n\ninsert into trades values(2018.10.08T01:01:01.785,`A,10)\ninsert into trades values(2018.10.08T01:01:02.125,`B,26)\ninsert into trades values(2018.10.08T01:01:10.263,`B,14)\ninsert into trades values(2018.10.08T01:01:12.457,`A,28)\n\nsleep(100)\n\ninsert into trades values(2018.10.08T01:01:12.557,`B,21)\ninsert into trades values(2018.10.08T01:01:12.557,`A,28)\n\n\nselect * from output4;\n\n```\n\n*updateTime*=0 时，每收到一批数据就触发一次计算输出：\n\n* 01:01:12.457 时，触发了第一批数据中 A、B 两组数据的计算输出。\n\n* 01:01:12.557 时，再次触发第二批数据中 A、B 两组数据的计算输出。\n\n最终得到：\n\n|       | time                    | sym | sumVolume |\n| ----- | ----------------------- | --- | --------- |\n| **0** | 2018.10.08 01:02:00.000 | A   | 38        |\n| **1** | 2018.10.08 01:02:00.000 | B   | 40        |\n| **2** | 2018.10.08 01:02:00.000 | B   | 61        |\n| **3** | 2018.10.08 01:02:00.000 | A   | 66        |\n\n下面以最后一个数据窗口为例，介绍时间序列引擎指定 *updateTime* 时如何进行计算。假设 time 列时间亦为数据进入时间序列引擎的时刻。\n\n1. 在 01:04:04.236 时，A 分组的第一条记录到达后已经过 2000 毫秒，触发一次 A 组计算，输出表增加一条记录(01:05:00.000, \\`A, 29)。\n\n2. 在 01:04:05.152 时的 B 组记录为 01:04:04.412 所在小窗口\\[01:04:04.000, 01:04:05.000)之后第一条记录，触发一次 B 组计算，输出表增加一条记录(01:05:00,\"B\",32)。\n\n3. 2 秒（2\\*updateTime个时间单位）后，在 01:04:07.152 时，由于 01:04:05.152 时的 B 组记录仍未参与计算，触发一次B组计算，输出一条记录(01:05:00,\"B\",55)。由于输出表的主键为 time 和 sym，并且输出表中已有(01:05:00,\"B\",32)这条记录，因此将该记录更新为(01:05:00,\"B\",55)。\n\n下例中，共享流数据表 \"pubT\" 包含两个时间列，类型分别时 DATE 和 SECOND，创建时间序列引擎时，通过设置 *timeColumn* 来将原来流数据表的两个时间列整合为输出表 streamMinuteBar\\_1min 中的一个类型为 DATETIME 的时间列。\n\n```\ncolNames=[\"symbol\",\"date\",\"minute\",\"price\",\"type\",\"volume\"]\ncolTypes=[SYMBOL, DATE, SECOND, DOUBLE, STRING, INT]\npubTable = streamTable(10000:0,colNames,colTypes)\nshare pubTable as pubT\n\ncolNames = [\"time\",\"symbol\",\"open\",\"max\",\"min\",\"close\",\"volume\",\"amount\",\"ret\",\"vwap\"]\ncolTypes = [DATETIME, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE, INT, DOUBLE, DOUBLE, DOUBLE]\nshare streamTable(10000:0,colNames, colTypes) as streamMinuteBar_1min\n\ntsAggrOHLC = createTimeSeriesEngine(name=\"subT\", windowSize=60, step=60, metrics=<[first(price) as open ,max(price) as max,min(price) as min ,last(price) as close ,sum(volume) as volume ,wsum(volume, price) as amount ,(last(price)-first(price))/first(price)) as ret, (wsum(volume, price)/sum(volume)) as vwap]>, dummyTable=pubTable, outputTable=streamMinuteBar_1min, timeColumn=[\"date\",\"minute\"], useSystemTime=false, keyColumn=\"symbol\", fill=\"none\")\nsubscribeTable(tableName=\"pubT\", actionName=\"subT\", offset=-1, handler=append!{tsAggrOHLC}, msgAsTable=true)\n\ninsert into pubT values(\"000001\", 2021.04.05, 09:25:01, 1, 'B', 1)\ninsert into pubT values(\"000001\", 2021.04.05, 09:30:05, 2, 'B', 1)\ninsert into pubT values(\"000001\", 2021.04.05, 09:31:06, 3, 'B', 1)\ninsert into pubT values(\"000001\", 2021.04.05, 09:35:05, 4, 'S', 4)\ninsert into pubT values(\"000001\", 2021.04.05, 09:40:05, 5, 'S', 5)\ninsert into pubT values(\"000001\", 2021.04.06, 09:25:05, 6, 'S', 6)\n\npubT\n```\n\n| symbol | date       | minute   | price | type | volume |\n| ------ | ---------- | -------- | ----- | ---- | ------ |\n| 000001 | 2021.04.05 | 09:25:01 | 1     | B    | 1      |\n| 000001 | 2021.04.05 | 09:30:05 | 2     | B    | 1      |\n| 000001 | 2021.04.05 | 09:31:06 | 3     | B    | 1      |\n| 000001 | 2021.04.05 | 09:35:05 | 4     | S    | 4      |\n| 000001 | 2021.04.05 | 09:40:05 | 5     | S    | 5      |\n| 000001 | 2021.04.06 | 09:25:05 | 6     | S    | 6      |\n\n```\nselect * from streamMinuteBar_1min\n```\n\n| time                | symbol | open | max | min | close | volume | amount | ret | vwap |\n| ------------------- | ------ | ---- | --- | --- | ----- | ------ | ------ | --- | ---- |\n| 2021.04.05T09:26:00 | 000001 | 1    | 1   | 1   | 1     | 1      | 1      | 0   | 1    |\n| 2021.04.05T09:31:00 | 000001 | 2    | 2   | 2   | 2     | 1      | 2      | 1   | 2    |\n| 2021.04.05T09:32:00 | 000001 | 3    | 3   | 3   | 3     | 1      | 3      | 2   | 3    |\n| 2021.04.05T09:36:00 | 000001 | 4    | 4   | 4   | 4     | 4      | 16     | 3   | 4    |\n| 2021.04.05T09:41:00 | 000001 | 5    | 5   | 5   | 5     | 5      | 25     | 4   | 5    |\n\n```\nshare streamTable(1000:0, [\"time\",\"sym\",\"qty\"], [DATETIME, SYMBOL, INT]) as trades\nshare table(10000:0, [\"time\",\"sym\",\"sumQty\"], [DATETIME, SYMBOL, INT]) as output5\n\nengine = createTimeSeriesEngine(name=\"engine\", windowSize=6, step=6, metrics=<sum(qty)>, dummyTable=trades, outputTable=output5, timeColumn=\"time\",keyColumn=\"sym\", forceTriggerTime=7,fill=1000)\nsubscribeTable(tableName=\"trades\", actionName=\"engine\", offset=0, handler=append!{engine}, msgAsTable=true)\nsleep(1000)\ninsert into engine values(2018.08.01T14:05:43,`A,1)\ninsert into engine values(2018.08.01T14:05:43,`C,3)\nsleep(10)\ninsert into engine values(2018.08.01T14:05:44,`B,1)\nsleep(80)\ninsert into engine values(2018.08.01T14:05:52,`B,3)\nsleep(20)\ninsert into engine values(2018.08.01T14:05:54,`A,3)\nsleep(10)\ninsert into engine values(2018.08.01T14:05:55,`A,5)\nsleep(20)\ninsert into engine values(2018.08.01T14:05:57,`B,5)\nsleep(50)\ninsert into engine values(2018.08.01T14:06:12,`A,1)\nsleep(50)\nselect * from output5 order by sym\n```\n\n| time                | sum | Qty   |\n| ------------------- | --- | ----- |\n| 2018.08.01T14:05:46 | A   | 1     |\n| 2018.08.01T14:05:52 | A   | 1,000 |\n| 2018.08.01T14:05:58 | A   | 8     |\n| 2018.08.01T14:06:04 | A   | 1,000 |\n| 2018.08.01T14:06:10 | A   | 1,000 |\n| 2018.08.01T14:05:46 | B   | 1     |\n| 2018.08.01T14:05:52 | B   | 1,000 |\n| 2018.08.01T14:05:58 | B   | 8     |\n| 2018.08.01T14:05:46 | C   | 3     |\n| 2018.08.01T14:05:52 | C   | 1,000 |\n\n例3. 下例计算每个分组窗口的第一个和最后一个 volume，组合后输出为一个数组向量。\n\n```\n//通过 defg 自定义一个函数，引擎在调用该函数时会将返回值转换为数组向量\ndefg toVector(x){\n\treturn x\t\n}\nshare streamTable(1000:0, [\"time\",\"sym\",\"volume\",\"price\"], [TIMESTAMP, SYMBOL, DOUBLE,DOUBLE]) as trades\n//定义输出表，对应 toVector 指标输出的列需要定义为数组向量类型，此例中将其定义为 DOUBLE[]\nshare table(10000:0, [\"time\",\"sym\",\"sumVolume\",\"avg\"], [TIMESTAMP,STRING,DOUBLE[],DOUBLE]) as output6\n//metrics 中调用了 toVector 函数，将1分钟窗口内的第一个 volume 和最后一个 volume 组合到一个向量中。\nengine1 = createTimeSeriesEngine(name=\"engine1\", windowSize=60000, step=60000, metrics=<[toVector([first(volume),last(volume)]),avg(volume+price)]>, dummyTable=trades, outputTable=output6, timeColumn=\"time\", keyColumn=\"sym\" , useSystemTime=false, garbageSize=50, useWindowStartTime=false)\n\ntimes = sort(2023.10.08T00:00:00.000 + rand(1..(1+3000*200), 30))\nsyms = rand(\"A\"+string(1..10), 30)\nvolumes = rand(rand(100.0, 10) join 2.3 NULL NULL NULL NULL, 30)\nprices = rand(rand(100.0, 10) join 2.3 NULL NULL NULL NULL, 30)\nt=table(times as time, syms as sym, volumes as volume,prices as price)\n\nengine1.append!(t)\n\nselect * from output6 where time between 2023.10.08T00:01:00.000 and 2023.10.08T00:05:00.000 order by time,sym \n```\n\n| time                    | sym | sumVolume      | avg      |\n| ----------------------- | --- | -------------- | -------- |\n| 2023.10.08T00:01:00.000 | A1  | \\[57.66,]      | 80.428   |\n| 2023.10.08T00:01:00.000 | A2  | \\[,]           |          |\n| 2023.10.08T00:02:00.000 | A7  | \\[,]           |          |\n| 2023.10.08T00:02:00.000 | A8  | \\[,]           |          |\n| 2023.10.08T00:03:00.000 | A2  | \\[,41.25]      | 101.7832 |\n| 2023.10.08T00:03:00.000 | A3  | \\[41.25,41.25] | 68.4897  |\n| 2023.10.08T00:03:00.000 | A6  | \\[,]           |          |\n| 2023.10.08T00:03:00.000 | A8  | \\[19.17,19.17] | 93.9934  |\n| 2023.10.08T00:04:00.000 | A7  | \\[,]           |          |\n| 2023.10.08T00:05:00.000 | A3  | \\[2.05,2.05]   | 95.433   |\n| 2023.10.08T00:05:00.000 | A5  | \\[55.93,55.93] | 116.4669 |\n| 2023.10.08T00:05:00.000 | A9  | \\[42.66,42.66] |          |\n\n例4.本例将说明 *subWindow* 参数的作用。\n\n```\nshare streamTable(1000:0, [\"time\",\"sym\",\"volume\"], [TIMESTAMP, SYMBOL, INT]) as trades\nshare table(10000:0, [\"time\",\"sym\",\"sumVolume\"], [TIMESTAMP, SYMBOL, INT]) as output7\n//在长度为 1 分钟的窗口内指定一个子窗口，未指定 closed 时，子窗口左闭右开。这里子窗口为每分钟的[0s, 10s)\nengine4 = createTimeSeriesEngine(name=\"engine4\", windowSize=60000, step=60000, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output7, timeColumn=\"time\", useSystemTime=false, keyColumn=\"sym\", garbageSize=50, useWindowStartTime=true, subWindow=0s:10s)\n\nsubscribeTable(tableName=\"trades\", actionName=\"engine4\", offset=0, handler=append!{engine4}, msgAsTable=true);\n\ninsert into trades values(2018.10.08T01:01:01.785,`A,10)\ninsert into trades values(2018.10.08T01:01:02.125,`B,26)\ninsert into trades values(2018.10.08T01:01:10.000,`A,14)\ninsert into trades values(2018.10.08T01:01:12.457,`A,28)\n\nsleep(10)\n\nselect * from output7;\n```\n\n2018.10.08T01:01:10.000 时刻的数据触发 \\[2018.10.08T01:01:00.000, 2018.10.08T01:01:10.000) 区间内 A 组数据对应的 volume 的总和。在子窗口结束后没有再收到 B 组的数据，因此 B 组子窗口内数据\n\n<table id=\"table_mzg_pwy_21c\"><thead><tr><th>\n\ntime\n\n</th><th>\n\nsym\n\n</th><th>\n\nsumVolume\n\n</th></tr></thead><tbody><tr><td>\n\n2018.10.08T01:01:10.000\n\n</td><td>\n\nA\n\n</td><td>\n\n10\n\n</td></tr></tbody>\n</table>**Related information**  \n\n[createDailyTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createDailyTimeSeriesEngine.html)\n"
    },
    "createUser": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createUser.html",
        "signatures": [
            {
                "full": "createUser(userId, password, [groupIds], [isAdmin=false])",
                "name": "createUser",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    },
                    {
                        "full": "password",
                        "name": "password"
                    },
                    {
                        "full": "[groupIds]",
                        "name": "groupIds",
                        "optional": true
                    },
                    {
                        "full": "[isAdmin=false]",
                        "name": "isAdmin",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createUser](https://docs.dolphindb.cn/zh/funcs/c/createUser.html)\n\n\n\n#### 语法\n\ncreateUser(userId, password, \\[groupIds], \\[isAdmin=false])\n\n#### 详情\n\n创建用户。\n\n*groupIds* 表示的组必须是已经创建了的组。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n#### 参数\n\n**userId** 是表示用户名的字符串。它只能包含字母、下划线或数字，并且它不能 以数字开头。长度不能超过30个字符。\n\n**password** 是表示用户密码的字符串。它不能包含空格或控制字符。\n\n从 2.00.10.10 开始，用户可以通过配置项 *enhancedSecurityVerification* 控制是否对 password 进行复杂性校验。若不设置 *enhancedSecurityVerification*，则不校验；若设置 *enhancedSecurityVerification*=true，则要求密码必须满足以下条件：\n\n* 字符个数为8\\~20\n\n* 至少包含一个大写字母\n\n* 至少包含以下字符之一：!\"#$%&'()\\*+,-./:;<=>?@\\[]^\\_\\`{|}\\~。\n\n**groupIds** 是表示用户所属组的字符串标量或向量。\n\n**isAdmin** 是表示用户是否为管理员的布尔值。\n\n#### 例子\n\n创建一个名称为 \"JohnSmith\"，密码为 'Qb0507#$' 的非管理员用户。该用户属于组 \"research\" 和组 \"production\"。\n\n```\ncreateUser(`JohnSmith, \"Qb0507#$\", `research`production);\n```\n"
    },
    "createWindowJoinEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createWindowJoinEngine.html",
        "signatures": [
            {
                "full": "createWindowJoinEngine(name, leftTable, rightTable, outputTable, window, metrics, matchingColumn, [timeColumn], [useSystemTime=false], [garbageSize = 5000], [maxDelayedTime], [nullFill], [outputElapsedMicroseconds=false], [sortByTime=false],[closed])",
                "name": "createWindowJoinEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "leftTable",
                        "name": "leftTable"
                    },
                    {
                        "full": "rightTable",
                        "name": "rightTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "matchingColumn",
                        "name": "matchingColumn"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[garbageSize = 5000]",
                        "name": "[garbageSize = 5000]"
                    },
                    {
                        "full": "[maxDelayedTime]",
                        "name": "maxDelayedTime",
                        "optional": true
                    },
                    {
                        "full": "[nullFill]",
                        "name": "nullFill",
                        "optional": true
                    },
                    {
                        "full": "[outputElapsedMicroseconds=false]",
                        "name": "outputElapsedMicroseconds",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[sortByTime=false]",
                        "name": "sortByTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [createWindowJoinEngine](https://docs.dolphindb.cn/zh/funcs/c/createWindowJoinEngine.html)\n\n\n\n#### 语法\n\ncreateWindowJoinEngine(name, leftTable, rightTable, outputTable, window, metrics, matchingColumn, \\[timeColumn], \\[useSystemTime=false], \\[garbageSize = 5000], \\[maxDelayedTime], \\[nullFill], \\[outputElapsedMicroseconds=false], \\[sortByTime=false],\\[closed])\n\n#### 详情\n\n创建流数据 window join 引擎。返回一个左、右两表实时 [window join](https://docs.dolphindb.cn/zh/progr/sql/windowjoin.html) 后的表对象。\n\n该引擎与 window join 存在以下区别：\n\n* window join 仅支持聚合计算，window join 引擎支持聚合计算，也支持非聚合计算。\n* 计算指标中的列未指定表名时，window join 默认取右表列，而 window join 引擎默认取左表列。\n\n注入 window join 引擎左、右两表的数据，根据 *matchingColumn* 分组。在各分组内，左表的每条记录，都会同右表中一个时间区间（即窗口）内的数据进行连接，并根据指定的 *metrics* 计算窗口内的数据并输出。\n\n* 普通窗口（*window* 不为 0:0）：\n\n  右表的计算窗口将由左表当前数据的时间戳和 *window* 确定。假设左表当前记录的时间戳为 t，*window* 为 a:b，则右表时间戳属于 \\[t+a, t+b] 的数据将与左表当前记录连接并计算输出。\n\n  触发计算的规则：\n\n  * *useSystemTime*=false：\n    * \\*\\*同组数据触发：\\*\\*各分组当前窗口数据的计算将由该窗口结束后的第一条属于该分组的数据触发。触发计算的数据不参与该窗口的计算。\n    * \\*\\*其它分组数据触发：\\*\\*对于某个分组中未发生计算的窗口，若其窗口右边界 + *maxDelayedTime* < 右表最新收到的任意一个分组数据的时间戳，则该窗口的计算将被新收到的这条数据触发。\n  * *useSystemTime*=true：当系统时间到达各分组未发生计算的窗口的右边界时，触发该窗口的计算。\n* 特殊窗口（*window* 为 0:0）：\n\n  右表的计算窗口将由左表当前数据和其上一条数据的时间戳决定。默认情况下，该窗口左闭右开，假设左表当前记录的时间戳为 t，上一条记录的时间戳为 t0，则右表计算窗口为 \\[t0, t)。可以通过指定参数 *closed* = “right”，设置窗口为左开右闭。 触发计算的规则：\n\n  * *useSystemTime*=false：各分组当前窗口数据的计算将由窗口结束后的第一条属于该分组的右表数据触发。\n  * *useSystemTime*=true：各个分组收到的左表数据将触发对应分组窗口的数据计算输出。\n\n**Note:**\n\n*window*=0:0 时，若 *metrics* 中指定了非聚合的指标，其输出列必须为对应类型的 array vector。\n\n更多流数据引擎的应用场景说明可以参考 [内置流式计算引擎](https://docs.dolphindb.cn/zh/funcs/themes/streamingEngine.html)。\n\n#### 参数\n\n**name** 必选参数，表示 window join 引擎的名称，作为其在一个数据节点/计算节点上的唯一标识。可包含字母，数字和下划线，但必须以字母开头。\n\n**leftTable** 表对象。可以不包含数据，但结构必须与订阅的流数据表相同。2.00.9.3 版本开始支持 array vector 类型。\n\n**rightTable** 表对象。可以不包含数据，但结构必须与订阅的流数据表相同。\n\n**outputTable** 必选参数，为计算结果的输出表。window join 引擎会将计算结果插入该表。\n\n* 输出表各列的顺序如下：\n\n  1. 时间列。其中：\n\n     * 若 *useSystemTime* = true，为 TIMESTAMP 类型；\n\n     * 若 *useSystemTime* = false，数据类型与 *timeColumn* 列一致。\n\n  2. 连接列。与 *matchingColumn* 中的列以及其顺序一致，可为多列。\n\n  3. 计算结果列。可为多列。\n\n  4. 耗时列。若指定 *outputElapsedMicroseconds* = true，则需要增加一个 LONG 类型和一个 INT 类型的列，分别用于存储引擎内部每个 batch 的数据耗时（单位：微秒）和记录数。\n\n**window** 必选参数，表示滑动窗口区间的整型或 DURATION 数据对，其中左右边界都包含在内。\n\n**metrics** 以元代码的格式表示计算指标，支持输入元组。有关元代码的更多信息可参考 [元编程](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n* 计算指标可以是一个或多个表达式、系统内置或用户自定义函数。\n* *metrics* 内支持调用具有多个返回值的函数，且必须指定列名，例如 \\<func(price) as \\`col1\\`col2>。\n\n  若在 *metrics* 指定了 *leftTable* 和 *rightTable* 中具有相同名称的列，默认取左表的列，可以通过 \"tableName.colName\" 指定该列来自哪个表。\n\n  **Note:**\n\n  * *metrics* 中使用的列名大小写不敏感，不要求与输入表的列名大小写保持一致。\n  * 当以下函数只计算 *rightTable* 中的数据列时，window join 引擎对它们进行了优化：sum, sum2, avg, std, var, corr, covar, wavg, wsum, beta, max, min, last, first, med, percentile。\n\n**matchingColumn** 表示连接列的字符串标量/向量/tuple，支持 Integral, Temporal 或 Literal（UUID 除外）类型。*matchingColumn* 指定规则为：\n\n1. 只有一个连接列：当左表和右表的连接列名相同时，*matchingColumn* 是一个字符串标量，否则是一个长度为 2 的 tuple，例如：左表连接列名为 sym，右表连接列名为 sym1，则 *matchingColumn* = \\[\\[\\`sym],\\[\\`sym1]]。\n\n2. 有多个连接列：当左表和右表的连接列名相同时，*matchingColumn* 是一个字符串向量，否则是一个长度为 2 的 tuple，例如：左表连接列名为 timestamp, sym，右表连接列名为 timestamp, sym1，则 *matchingColumn* = \\[\\[\\`timestamp, \\`sym], \\[\\`timestamp,\\`sym1]]。\n\n**timeColumn** 可选参数，当 *useSystemTime* = false时，指定要连接的两个表中时间列的名称。*leftTable* 和 *rightTable* 时间列名称可以不同，但数据类型需保持一致。当 *leftTable* 和 *rightTable* 时间列名称不同时，*timeColumn* 为一个长度为2的字符串向量。\n\n**useSystemTime** 可选参数，表示 *outputTable* 中第一列（时间列）为系统当前时间（*useSystemTime* = true）或左表的时间列（*useSystemTime* = false）。\n\n**garbageSize** 可选参数，是正整数，默认值是5,000（单位为行）。随着订阅的流数据不断积累进入 window join 引擎，存放在内存中的数据会越来越多，这时需要清理不再需要的历史数据。当左/右两表各个分组内的数据行数超过 *garbageSize* 值时，系统会清理本次计算不需要的历史数据。\n\n**maxDelayedTime** 可选参数，是正整数，默认值为3，单位为秒。通过设置该参数，帮助触发引擎中长时间未输出的分组数据进行计算。 即若`(某个分组中未发生计算的窗口右边界) + (maxDelayedTime) < (右表最新收到的任意一个分组数据的时间戳)`，则这条数据会触发该窗口计算输出。\n\n**Note:** 指定该参数时，必须同时指定 timeColumn，且单位需和 timeColumn 精度一致。\n\n**nullFill** 和输出表列字段等长且类型一一对应的元组，用于填充以下列中的空值：输出表中包含的左表列、右表列、右表列被聚合计算后的计算结果列。\n\n若同时有一批数据注入引擎，则引擎内部数据是分批进行计算的，每个批次的数据称为一个 batch，每个 batch 包含记录数由系统决定。\n\n**outputElapsedMicroseconds** 布尔值，表示是否输出每个 batch 中数据从注入引擎到计算输出的总耗时，以及每个 batch 包含的总记录数，默认为 false。指定参数 *outputElapsedMicroseconds* = true 后，在定义 *outputTables* 时需要在最后增加两列，详见 *outputTable* 参数说明。\n\n**sortByTime** 布尔值，表示是否按全局时间顺序输出数据。默认值为 false，表示不按全局时间输出数据，仅在组内按时间顺序输出数据。注意：当设置 sortByTime=true 时，必须保证输入的左表和右表的数据必须全局有序，且不可设置 *maxDelayedTime*。\n\n**closed** 字符串，用于确定窗口边界的开闭情况，仅当 *window*为 0:0 时有效 。可选值为 ‘left’ 或 ‘right’，默认值为 ‘left’。\n\n* closed = ‘left’： 窗口左闭右开。\n\n* closed = ‘right’： 窗口左开右闭。此时必须设置 useSystemTime=false 。\n\n#### 例子\n\n```\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\nshare table(100:0, `time`sym`factor1`factor2`factor3, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\n\nnullFill= [2012.01.01T00:00:00.000, `NONE, 0.0, 0.0, 0.0]\nwjEngine=createWindowJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output,  window=-2:2, metrics=<[price,val,sum(val)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false,nullFill=nullFill)\n\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{wjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{wjEngine, false}, msgAsTable=true)\n\nn=10\ntp1=table(take(2012.01.01T00:00:00.000+0..10, 2*n) as time, take(`A, n) join take(`B, n) as sym, take(NULL join rand(10.0, n-1),2*n) as price)\ntp1.sortBy!(`time)\nleftTable.append!(tp1)\n\ntp2=table(take(2012.01.01T00:00:00.000+0..10, 2*n) as time, take(`A, n) join take(`B, n) as sym, take(double(1..n),2*n) as val)\ntp2.sortBy!(`time)\nrightTable.append!(tp2)\n\nselect * from output where time between 2012.01.01T00:00:00.000:2012.01.01T00:00:00.001\n```\n\n| time                    | sym | factor1 | factor2 | factor3 |\n| ----------------------- | --- | ------- | ------- | ------- |\n| 2012.01.01T00:00:00.000 | A   | 0       | 1       | 6       |\n| 2012.01.01T00:00:00.000 | A   | 0       | 2       | 6       |\n| 2012.01.01T00:00:00.000 | A   | 0       | 3       | 6       |\n| 2012.01.01T00:00:00.001 | A   | 5.2705  | 1       | 10      |\n| 2012.01.01T00:00:00.001 | A   | 5.2705  | 2       | 10      |\n| 2012.01.01T00:00:00.001 | A   | 5.2705  | 3       | 10      |\n| 2012.01.01T00:00:00.001 | A   | 5.2705  | 4       | 10      |\n| 2012.01.01T00:00:00.000 | B   | 5.2705  | 2       | 9       |\n| 2012.01.01T00:00:00.000 | B   | 5.2705  | 3       | 9       |\n| 2012.01.01T00:00:00.000 | B   | 5.2705  | 4       | 9       |\n| 2012.01.01T00:00:00.001 | B   | 1.0179  | 2       | 14      |\n| 2012.01.01T00:00:00.001 | B   | 1.0179  | 3       | 14      |\n| 2012.01.01T00:00:00.001 | B   | 1.0179  | 4       | 14      |\n| 2012.01.01T00:00:00.001 | B   | 1.0179  | 5       | 14      |\n\n下例展示特殊窗口的计算：\n\n```\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\n\nv = [1, 5, 10, 15]\ntp1=table(2012.01.01T00:00:00.000+v as time, take(`A   , 4) as sym, rand(10.0,4) as price)\n\nv = [1, 2, 3, 4, 5, 6, 9, 15]\ntp2=table(2012.01.01T00:00:00.000+v as time, take(`A   , 8) as sym, rand(10.0,8) as val)\n\nshare table(100:0, `time`sym`price`val`sum_val, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE[], DOUBLE]) as output\nwjEngine=createWindowJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output,  window=0:0, metrics=<[price, val, sum(val)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false)\n\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{wjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{wjEngine, false}, msgAsTable=true)\n\nleftTable.append!(tp1)\nrightTable.append!(tp2)\n```\n\n| time                    | sym | price  | val                               | sum\\_val |\n| ----------------------- | --- | ------ | --------------------------------- | -------- |\n| 2012.01.01T00:00:00.001 | A   | 8.8252 | \\[]                               |          |\n| 2012.01.01T00:00:00.005 | A   | 7.1195 | \\[7.495792,9.417891,1.419681,...] | 21.3741  |\n| 2012.01.01T00:00:00.010 | A   | 5.2217 | \\[4.840462,8.086567,3.495306]     | 16.4223  |\n| 2012.01.01T00:00:00.015 | A   | 9.2517 | \\[]                               |          |\n\n当 window=0:0 时，默认情况下，该窗口左闭右开。下例中指定参数 *closed* = \"right\"，将窗口设置为左开右闭。\n\n```\nunsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\")\nunsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\")\nundef(`leftTable,SHARED)\nundef(`rightTable,SHARED)\ndropAggregator(name=\"test1\")\n\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\n\nv1 = [1, 5, 10, 15]\ntp1=table(2012.01.01T00:00:00.000+v1 as time, take(`A, 4) as sym, rand(10.0,4) as price)\n\nv2 = [1, 2, 3, 4, 5, 6, 9, 15]\ntp2=table(2012.01.01T00:00:00.000+v2 as time, take(`A, 8) as sym, rand(10.0,8) as val)\n\nshare table(100:0, `time`sym`price`val`sum_val, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE[], DOUBLE]) as output\nwjEngine=createWindowJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output,  window=0:0, metrics=<[price, val, sum(val)]>, matchingColumn=\"sym\", timeColumn=\"time\", useSystemTime=false, closed=\"right\")\n\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{wjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{wjEngine, false}, msgAsTable=true)\n\nleftTable.append!(tp1)\nrightTable.append!(tp2)\nsleep(100)\nselect * from output\n```\n\n返回：\n\n```\ntime\t                  sym\tprice\tval\t                      sum_val\n2012.01.01T00:00:00.001\tA\t9.7366\t[7.8310]\t                  7.831\n2012.01.01T00:00:00.005\tA\t2.6537\t[1.8564,4.6238,8.2536,3.1028]     17.8368\n2012.01.01T00:00:00.010\tA\t3.9586\t[0.8413,8.0684]\t           8.9098\n```\n\n下例展示指定 *sortByTime* = true 时，引擎将按时间顺序输出数据。\n\n```\n//清理引擎及变量\nunsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\")\nunsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\")\nundef(`leftTable,SHARED)\nundef(`rightTable,SHARED)\ndropAggregator(name=\"test1\")\n\n//定义引擎\nshare streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable\nshare streamTable(1:0, `time`sym`val, [TIMESTAMP, SYMBOL, DOUBLE]) as rightTable\nshare table(100:0, `time`sym`factor1`factor2`factor3, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE]) as output\nnullFill= [2012.01.01T00:00:00.000, `NONE, 0.0, 0.0, 0.0]\nwjEngine=createWindowJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output,  window=-2:2, metrics=<[price,val,sum(val)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false,nullFill=nullFill, sortByTime=true)\n\n//定义数据\nsubscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{wjEngine, true}, msgAsTable=true)\nsubscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{wjEngine, false}, msgAsTable=true)\n\nn=10\ntp1=table(take(2012.01.01T00:00:00.000+0..10, 2*n) as time, take(`A, n) join take(`B, n) as sym, take(NULL join rand(10.0, n-1),2*n) as price)\ntp1.sortBy!(`time)\nleftTable.append!(tp1)\n\ntp2=table(take(2012.01.01T00:00:00.000+0..10, 2*n) as time, take(`A, n) join take(`B, n) as sym, take(double(1..n),2*n) as val)\ntp2.sortBy!(`time)\nrightTable.append!(tp2)\n\nsleep(100)\nselect * from output where time between 2012.01.01T00:00:00.000:2012.01.01T00:00:00.001\n```\n\n| time                    | sym | factor1 | factor2 | factor3 |\n| ----------------------- | --- | ------- | ------- | ------- |\n| 2012.01.01T00:00:00.000 | A   | 0       | 1       | 6       |\n| 2012.01.01T00:00:00.000 | A   | 0       | 2       | 6       |\n| 2012.01.01T00:00:00.000 | A   | 0       | 3       | 6       |\n| 2012.01.01T00:00:00.000 | B   | 3.9389  | 2       | 9       |\n| 2012.01.01T00:00:00.000 | B   | 3.9389  | 3       | 9       |\n| 2012.01.01T00:00:00.000 | B   | 3.9389  | 4       | 9       |\n| 2012.01.01T00:00:00.001 | A   | 3.9389  | 1       | 10      |\n| 2012.01.01T00:00:00.001 | A   | 3.9389  | 2       | 10      |\n| 2012.01.01T00:00:00.001 | A   | 3.9389  | 3       | 10      |\n| 2012.01.01T00:00:00.001 | A   | 3.9389  | 4       | 10      |\n| 2012.01.01T00:00:00.001 | B   | 4.9875  | 2       | 14      |\n| 2012.01.01T00:00:00.001 | B   | 4.9875  | 3       | 14      |\n| 2012.01.01T00:00:00.001 | B   | 4.9875  | 4       | 14      |\n| 2012.01.01T00:00:00.001 | B   | 4.9875  | 5       | 14      |\n"
    },
    "createYieldCurveEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/createyieldcurveengine.html",
        "signatures": [
            {
                "full": "createYieldCurveEngine(name, dummyTable, assetType, fitMethod, keyColumn, modelOutput, frequency, [timeColumn], [predictDummyTable],[predictInputColumn], [predictKeyColumn],[predictTimeColumn], [predictOutput], [extraMetrics],[fitAfterPredict=false])",
                "name": "createYieldCurveEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "assetType",
                        "name": "assetType"
                    },
                    {
                        "full": "fitMethod",
                        "name": "fitMethod"
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "modelOutput",
                        "name": "modelOutput"
                    },
                    {
                        "full": "frequency",
                        "name": "frequency"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[predictDummyTable]",
                        "name": "predictDummyTable",
                        "optional": true
                    },
                    {
                        "full": "[predictInputColumn]",
                        "name": "predictInputColumn",
                        "optional": true
                    },
                    {
                        "full": "[predictKeyColumn]",
                        "name": "predictKeyColumn",
                        "optional": true
                    },
                    {
                        "full": "[predictTimeColumn]",
                        "name": "predictTimeColumn",
                        "optional": true
                    },
                    {
                        "full": "[predictOutput]",
                        "name": "predictOutput",
                        "optional": true
                    },
                    {
                        "full": "[extraMetrics]",
                        "name": "extraMetrics",
                        "optional": true
                    },
                    {
                        "full": "[fitAfterPredict=false]",
                        "name": "fitAfterPredict",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [createYieldCurveEngine](https://docs.dolphindb.cn/zh/funcs/c/createyieldcurveengine.html)\n\n\n\n#### 语法\n\ncreateYieldCurveEngine(name, dummyTable, assetType, fitMethod, keyColumn, modelOutput, frequency, \\[timeColumn], \\[predictDummyTable],\\[predictInputColumn], \\[predictKeyColumn],\\[predictTimeColumn], \\[predictOutput], \\[extraMetrics],\\[fitAfterPredict=false])\n\n#### 详情\n\n本函数用于计算债券的预测曲线和预测值。\n\n其内部综合了 DolphinDB 中用于曲线拟合和优化求解的诸多函数，以此为用户提供方便的、可适用于多种业务场景、交易品种、数据频率的现代金融工具，进而帮助用户预期市场未来利率走势、进行更有效的投资和风险管理。\n\n注意：\n\n* 可在该引擎中直接进行预测，也可结合函数 `appendForPrediction` 配套使用。\n\n* 目前仅支持拟合债券收益率曲线，后续将逐步支持其它类型的收益率曲线和衍生品曲线。\n\n#### 参数\n\n**name** 字符串标量，表示引擎的名称。该参数是引擎在一个数据节点上的唯一标识，可包含字母，数字和下划线，但必须以字母开头。\n\n**dummyTable** 表，用于指定输入数据的表结构。如：\n\n<table id=\"table_wq5_pmr_bdc\"><thead><tr><th align=\"left\">\n\n字段\n\n</th><th align=\"left\">\n\n类型\n\n</th><th align=\"left\">\n\n说明\n\n</th></tr></thead><tbody><tr><td>\n\nsymbol\n\n</td><td>\n\nSYMBOL\n\n</td><td>\n\n合约名\n\n</td></tr><tr><td>\n\nsendingTime\n\n</td><td>\n\nTIMESTAMP\n\n</td><td>\n\n行情时间\n\n</td></tr><tr><td>\n\naskDirtyprice1\n\n</td><td>\n\nDECIMAL\n\n</td><td>\n\n卖一全价\n\n</td></tr><tr><td>\n\nbidDirtyprice1\n\n</td><td>\n\nDECIMAL\n\n</td><td>\n\n买一全价\n\n</td></tr><tr><td>\n\nmidDirtyprice1\n\n</td><td>\n\nDECIMAL\n\n</td><td>\n\n中间价全价\n\n</td></tr><tr><td>\n\naskyield1\n\n</td><td>\n\nDECIMAL\n\n</td><td>\n\n卖一收益率\n\n</td></tr><tr><td>\n\nbidyield1\n\n</td><td>\n\nDECIMAL\n\n</td><td>\n\n买一收益率\n\n</td></tr><tr><td>\n\nmidyield1\n\n</td><td>\n\nDECIMAL\n\n</td><td>\n\n中间价收益率\n\n</td></tr><tr><td>\n\ntimetoMaturity\n\n</td><td>\n\nDOUBLE\n\n</td><td>\n\n剩余到期期限\n\n</td></tr><tr><td>\n\nassetType\n\n</td><td>\n\nINT\n\n</td><td>\n\n资产类型，主要用于和曲线类型进行匹配：\n\n0：国债\n\n1：国开\n\n2：农发\n\n</td></tr><tr><td>\n\ndataSource\n\n</td><td>\n\nINT\n\n</td><td>\n\n数据源：\n\n0：X-Bond\n\n1：ESP\n\n2：QB\n\n3：SH\n\n4：SZ\n\n</td></tr><tr><td>\n\nclearRate\n\n</td><td>\n\nSTR\n\n</td><td>\n\n清算速度：\n\n\"T0”\n\n“T1”\n\n“T2”\n\n</td></tr></tbody>\n</table>**assetType** 整型向量，表示资产类型。输入示例：\\[0,1,2\\]。注意：不可包含重复值。\n\n**fitMethod** 元代码元组，用于指定不同资产对应的拟合算法和对应参数。该参数的大小须和参数 *assetType* 保持一致。如：\n\n```\n[<piecewiseLinFit(timetoMaturity, midyield1, 10)>,<nss(timetoMaturity,bidyield1,\"ns\")>,<cubicSpline(timetoMaturity,askyield1,\"not-a-knot\")>]\n```\n\n**keyColumn** 字符串向量，表示引擎拟合模型的分组标准。注意：至少传入一列。其中，第一列为整型的类型列，用于映射算法；其他列为分组列。\n\n**modelOutput** 模型输出表，输出列顺序应遵守下述顺序：\n\n1. 时间列，表示模型更新时间。\n\n2. 指定输出列，与 keyColumn 保持一致。\n\n3. model，BLOB 类型。引擎会通过 `toStdJson` 函数将模型转成 JSON 格式的字符串进行输出。\n\n**frequency** 表示模型的更新频率，其使用分三种情况：\n\n* 按照数据条数，传入 INT 类型，即每组未参与模型拟合的数据条数累计到设定值后更新模型。\n\n* 按照数据时间，传入 DURATION 类型，根据每组未参与模型拟合的数据时间更新模型。注意：需要设置参数 *timeColumn*。即每组分开判断，起始时间按每组第一条数据规整，每隔 *frequency* 时间输出一次拟合模型；如果窗口内没收到数据则不输出。示例：假设收到的数据时间如下：09:30:00.100, 09:32:00.100, 09:35:00.100, 09:45:00.100, 09:50:00.100，同时 *frequency* = 5 min, 则 model 输出的时间为 09:35:00.000, 09:40:00.000, 09:50:00.000。右边界为开，即 09:35:00.000 输出的 model 的拟合数据不包括 09:35:00.000。\n\n* 按照系统时间，传入 DURATION 类型。注意：此时不能设置参数 *timeColumn*，将按照固定时间更新每组的模型。起始时间按第一条数据进到引擎的时间规整；如果窗口内没收到数据则不输出。\n\n**timeColumn** 可选参数，时间类型向量，用于指定输入表中的时间列，进而更新频率。须与参数 *frequency* 搭配使用。\n\n**predictDummyTable**可选参数，表示预测的输入数据表结构。默认和 *dummyTable* 一致。\n\n**predictInputColumn**可选参数，字符串标量，表示预测数据的输入列名。\n\n**predictKeyColumn**可选参数，表示用于查找模型的分组列，默认和 *keyColumn* 一致。\n\n**predictTimeColumn**可选参数，表示预测数据的时间列，默认和 *timeColumn* 一致。\n\n**predictOutput** 可选参数，表示预测结果输出表。输出列遵循如下顺序：\n\n1. predictTimeColumn 表示时间列，如果没有时间列则输出系统时间。\n\n2. predictKeyColumn 表示查找模型的分组列。\n\n3. predictXColumn 表示预测数据的输入列名。\n\n4. predict result 表示预测结果。\n\n5. extraMetrics 表示额外指定输出的算子。\n\n注意： 如果不设置参数 *predictOutput*，则引擎只用于拟合模型。\n\n**extraMetrics**可选参数，除预测结果外额外输出的算子。可以是 *predictDummyTable* 中的列，也可以是在此基础上的一些简单计算。\n\n**predictWithFitting**可选参数，布尔标量。\n\n* 如果为 true，表示 *predictDummyTable* 和 *dummyTable* 一样，引擎收到数据后先用之前的模型预测输出，再用收到的数据继续拟合模型。\n\n* 如果为 false，表示只进行拟合运算，不进行预测操作。该种为默认情况。\n\n#### 例子\n\n指定参数，创建一个曲线拟合引擎，最后进行拟合。\n\n```\n//指定传入表结构、资产类型、拟合算法\ndummyTable = table(1:0, `symbol`sendingtime`askDirtyPrice1`bidDirtyPrice1`midDirtyPirce1`askyield1`bidyield1`midyield1`timetoMaturity`assetType`datasource`clearRate, \n                        [SYMBOL, TIMESTAMP,DECIMAL32(3),DECIMAL32(3),DECIMAL32(3),DECIMAL32(3),DECIMAL32(3),DECIMAL32(3),DOUBLE,INT,INT,STRING])\nassetType=[0,1,2]\nfitMethod=[<piecewiseLinFit(timetoMaturity, midyield1, 10)>,\n            <nss(timetoMaturity,bidyield1,\"ns\")>,\n            <piecewiseLinFit(timetoMaturity, askyield1, 5)>]\n\n//指定模型输出表和预测结果输出表\nmodelOutput=table(1:0, `time`assetType`dataSource`clearRate`model,\n                        [TIMESTAMP,INT,INT,SYMBOL,BLOB])\npredictOutput=table(1:0, `time`assetType`dataSource`clearRate`x`y,[TIMESTAMP,INT,INT,SYMBOL,DOUBLE,DOUBLE])\n\n//基于上述参数创建曲线拟合引擎\nengine = createYieldCurveEngine(name=\"test\", dummyTable=dummyTable,assetType=assetType,fitMethod=fitMethod,\n                                keyColumn=`assetType`dataSource`clearRate, modelOutput=modelOutput,\n                                frequency=10,predictInputColumn=`timetoMaturity,predictTimeColumn=`sendingtime, \n                                predictOutput=predictOutput,fitAfterPredict=true)\n                                \n//创建数据，进行拟合\ndata = table(take(`a`b`c, 30) as  symbol, take(now(), 30) as time, decimal32(rand(10.0, 30),3) as p1,  decimal32(rand(10.0, 30),3) as p2,  decimal32(rand(10.0, 30),3) as p3, decimal32(rand(10.0, 30),3) as p4,  decimal32(rand(10.0, 30),3) as p5,  decimal32(rand(10.0, 30),3) as p6, (rand(10.0, 30)+10).sort() as timetoMaturity, take(0 1 2, 30) as assetType, take([1], 30) as datasource, take(\"1\", 30) as clearRate)\nengine.append!(data)\n```\n\n**相关函数** [appendForPrediction](https://docs.dolphindb.cn/zh/funcs/a/appendforprediction.html)\n"
    },
    "crmwCBond": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/crmwcbond.html",
        "signatures": [
            {
                "full": "crmwCBond(settlement, maturity, fv, ys, yd)",
                "name": "crmwCBond",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "fv",
                        "name": "fv"
                    },
                    {
                        "full": "ys",
                        "name": "ys"
                    },
                    {
                        "full": "yd",
                        "name": "yd"
                    }
                ]
            }
        ],
        "markdown": "### [crmwCBond](https://docs.dolphindb.cn/zh/funcs/c/crmwcbond.html)\n\n\n\n#### 语法\n\ncrmwCBond(settlement, maturity, fv, ys, yd)\n\n#### 详情\n\n本函数使用中债估值方法，对标的债务为到期一次还本付息的短期债券的信用风险缓释凭证（Credit Risk Mitigation Warrant, CRMW）进行估值。成功执行后将返回 CRMW 的估值价格，是一个 DOUBLE 类型的标量或向量。\n\n#### 语法\n\n**settlement** DATE 类型标量或向量，表示 CRMW 的估值日。\n\n**maturity** DATE 类型标量或向量，表示标的债券的到期日。\n\n注意：*settlement* 应早于对应的 *maturity*。\n\n**fv** 数值型标量或向量，非负数，表示标的债券到期时还本付息总金额。\n\n**ys** 数值型标量或向量，非负数，表示 CRMW 创设机构估价收益率。\n\n**yd** 数值型标量或向量，非负数，表示标的债券的估价收益率。\n\n注意：如果输入参数中，部分为标量，其余为向量时，则会将标量当作与向量长度相同、所有元素值等于该标量的向量；且所有向量的长度必须一致。\n\n#### 例子\n\n假设 CRMW 的标的债券到期日为 2024 年 9 月 1 日，到期时还本付息总金额为 105，CRMW 创设机构估价收益率为 5.3%，标的债券的估价收益率 5.8%。估值日为 2024 年 3 月 1 日。\n\n```\ncrmwCBond(settlement=2024.03.01, maturity=2024.09.01, fv=105, ys=0.053, yd=0.058)\n// Output: 0.249800655\n```\n"
    },
    "crossStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/crossStat.html",
        "signatures": [
            {
                "full": "crossStat(X, Y)",
                "name": "crossStat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [crossStat](https://docs.dolphindb.cn/zh/funcs/c/crossStat.html)\n\n\n\n#### 语法\n\ncrossStat(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是长度相同的数值型向量。\n\n#### 详情\n\n返回的结果是一个元组，结果中的每个元素依次为 count(X), sum(X), sum(Y), sum2(X), sum2(Y), sum(X\\*Y) 的计算结果。\n\n#### 例子\n\n```\nx=1 NULL 2 3\ny=4 3 NULL 2\ncrossStat(x,y);\n// output\n(2,4,6,10,20,10)\n```\n"
    },
    "cubicSpline": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cubicspline.html",
        "signatures": [
            {
                "full": "cubicSpline(x, y, bc_type=\"not-a-knot\")",
                "name": "cubicSpline",
                "parameters": [
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "y",
                        "name": "y"
                    },
                    {
                        "full": "bc_type=\"not-a-knot\"",
                        "name": "bc_type=\"not-a-knot\""
                    }
                ]
            }
        ],
        "markdown": "### [cubicSpline](https://docs.dolphindb.cn/zh/funcs/c/cubicspline.html)\n\n#### 语法\n\ncubicSpline(x, y, bc\\_type=\"not-a-knot\")\n\n#### 详情\n\n生成三次样条插值曲线。\n\n* 当 *bc\\_type* 是一个字符串标量或长度为 1 的向量时，以此作为曲线两端的限制条件。\n* 当 *bc\\_type* 是一个数据对或长度为 2 的向量时，两个元素分别作为曲线左端和右端的限制。\n\n返回一个字典，包含 2 个key：c, x：\n\n* c：三次样条函数的分段多项式的系数\n* x：输入的 x 向量\n\n#### 参数\n\n**x** 是一个数值向量，代表自变量的值。x 的长度不小于 3，必须严格递增，且不包含空值。\n\n**y** 是一个数值向量，代表因变量的值。y 必须与 x 长度相等。\n\n**bc\\_type** 是一个字符串标量、字符串数据对、或长度小于等于 2 的向量，用于限定边界条件。字符串支持”not-a-knot“、”clampe“、”nature“，默认值为”not-a-knot“。\n\n* not-a-knot：曲线的前两段和最后两段的三阶导数相等。\n* clamped：曲线两端点处的一阶导数为零。\n* natural：曲线两端点处的二阶导数为零。\n\n#### 例子\n\n```\nn = 10\nx = 0..(n-1)\ny = sin(x)\nmodel = cubicSpline(x, y, bc_type=\"not-a-knot\")\nprint(model)\n```\n\n返回：\n\n```\nc->[-0.041850075616506,-0.261272044545537,1.144593104969939,0,-0.041850075616507,-0.386822271395055,0.496498789029347,0.841470984807897,0.146891060089045,-0.512372498244576,-0.402695980610284,0.909297426825682,0.160544611441946,-0.071699317977441,-0.986767796832301,0.141120008059867,0.036476302757735,0.409934516348399,-0.648532598461344,-0.756802495307928,-0.120619990666048,0.519363424621603,0.280765342508658,-0.958924274663138,-0.178733575459463,0.157503452623459,0.957632219753719,-0.279415498198926,-0.025369476962727,-0.378697273754929,0.736438398622249,0.656986598718789,-0.025369476962726,-0.454805704643109,-0.09706457977579,0.989358246623382]\nx->[0,1,2,3,4,5,6,7,8,9]\n\n```\n\n\n\n**Related information**\n\n[cubicSplinePredict](https://docs.dolphindb.cn/zh/funcs/c/cubicsplinepredic.html)\n"
    },
    "cubicSplinePredict": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cubicsplinepredic.html",
        "signatures": [
            {
                "full": "cubicSplinePredict(model, x)",
                "name": "cubicSplinePredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "x",
                        "name": "x"
                    }
                ]
            }
        ],
        "markdown": "### [cubicSplinePredict](https://docs.dolphindb.cn/zh/funcs/c/cubicsplinepredic.html)\n\n#### 语法\n\ncubicSplinePredict(model, x)\n\n#### 详情\n\n根据 *model* 给出的三次样条曲线，预测 x 对应的 y。\n\n#### 参数\n\n**model** 是一个字典，包含两个 key：c 和 x，其中 c 的值是三次样条函数的分段多项式的系数，x 的值是分段多项式的分段点，c 的长度=（x 的长度-1）\\*4。c 和 x 的值均不可包含空值。*model* 可由 `cubicSpline` 函数生成。\n\n**x** 是一个数值型标量或向量要预测的自变量。\n\n#### 例子\n\n```\nn = 10\nx = 0..(n-1)\ny = sin(x)\nmodel = cubicSpline(x, y, bc_type=\"not-a-knot\")\n\nnewx = [-0.5, 0.5, 0.7, 1.2, 4.5, 8.9, 9.3]\nret = cubicSplinePredict(model, newx)\n```\n\n返回：\n\n```\n[-0.632383304169291,0.501747281896522,0.658837295715183,0.924963051153032,-0.974025627606784,0.515113155358425,0.03881591118089]\n```\n\n\n\n**Related information**\n\n[cubicSpline](https://docs.dolphindb.cn/zh/funcs/c/cubicspline.html)\n"
    },
    "cumavg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumavg.html",
        "signatures": [
            {
                "full": "cumavg(X)",
                "name": "cumavg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumavg](https://docs.dolphindb.cn/zh/funcs/c/cumavg.html)\n\n\n\n#### 语法\n\ncumavg(X)\n\n参数说明和窗口计算规则请参考: [累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累积平均值。\n\n#### 例子\n\n```\nx=[2,3,NULL,4];\n\ncumavg(x);\n[2,2.5,2.5,3]\n\nm=matrix(1 2 3 NULL 4, 5 6 NULL 7 8);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 2  | 6  |\n| 3  |    |\n|    | 7  |\n| 4  | 8  |\n\n```\ncumavg(m);\n```\n\n| #0  | #1  |\n| --- | --- |\n| 1   | 5   |\n| 1.5 | 5.5 |\n| 2   | 5.5 |\n| 2   | 6   |\n| 2.5 | 6.5 |\n\n相关函数：[avg](https://docs.dolphindb.cn/zh/funcs/a/avg.html)\n"
    },
    "cumavgTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumavgTopN.html",
        "signatures": [
            {
                "full": "cumavgTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumavgTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumavgTopN](https://docs.dolphindb.cn/zh/funcs/c/cumavgTopN.html)\n\n\n\n#### 语法\n\ncumavgTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[cumTopN 系列](https://docs.dolphindb.cn/zh/funcs/themes/cumTopN.html)\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素并计算平均值。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumavgTopN(X, S, 6)\n// output\n[1,1.5,2,4,23.199,20,20.167]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumavgTopN(X, S, 6)\n```\n\n| #0   | #1      |\n| ---- | ------- |\n| 1    |         |\n| 1.5  | 12      |\n| 2    | 12.5    |\n| 2    | 13      |\n| 2.75 | 13      |\n| 3.4  | 13.75   |\n| 4    | 14.4    |\n| 5    | 15      |\n| 5    | 15.8333 |\n| 5    | 16      |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumavgTopN(price, id, 6) as result from t\n```\n\n| result  |\n| ------- |\n| 94      |\n| 69.5    |\n| 46.3333 |\n| 55.75   |\n| 57.8    |\n| 49.6667 |\n| 50.5    |\n| 50.5    |\n| 51.5    |\n| 51.5    |\n"
    },
    "cumbeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumbeta.html",
        "signatures": [
            {
                "full": "cumbeta(Y, X)",
                "name": "cumbeta",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumbeta](https://docs.dolphindb.cn/zh/funcs/c/cumbeta.html)\n\n\n\n#### 语法\n\ncumbeta(Y, X)\n\n参数说明和窗口计算规则请参考: [累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n累积计算 *Y* 在 *X* 上的回归系数的最小二乘估计。\n\n#### 例子\n\n```\nx=1 3 5 7 11 16 23\ny=1 6 9 8 15 23 34;\n\ncumbeta(y,x);\n// output\n[,2.5,2,1.2,1.256757,1.365322,1.440948]\n```\n\n相关函数：[beta](https://docs.dolphindb.cn/zh/funcs/b/beta.html)\n"
    },
    "cumbetaTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumbetaTopN.html",
        "signatures": [
            {
                "full": "cumbetaTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumbetaTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumbetaTopN](https://docs.dolphindb.cn/zh/funcs/c/cumbetaTopN.html)\n\n\n\n#### 语法\n\ncumbetaTopN(X, Y, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，然后计算 *Y* 在 *X* 上的回归系数的最小二乘估计。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 100 4 3\nY=1 7 8 9 0 5 8\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumbetaTopN(X, Y, S, 6)\n// output\n[,0.1666,0.2441,0.7483,-6.4428,-6.4428,-6.2293]\n```\n"
    },
    "cumcorr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumcorr.html",
        "signatures": [
            {
                "full": "cumcorr(X,Y)",
                "name": "cumcorr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cumcorr](https://docs.dolphindb.cn/zh/funcs/c/cumcorr.html)\n\n\n\n#### 语法\n\ncumcorr(X,Y)\n\n参数说明和窗口计算规则请参考: [累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 参数\n\n**X** 和 **Y** 是向量、矩阵或表。\n\n#### 详情\n\n累计计算 *X* 和 *Y* 之间的相关性（correlation）。\n\n#### 例子\n\n```\nx = 7 4 5 8 9\ny = 1 7 8 9 0\ncumcorr(x, y);\n\n// output\n[,-1,-0.893405,-0.1524,-0.518751]\n```\n\n相关函数：[corr](https://docs.dolphindb.cn/zh/funcs/c/corr.html)\n"
    },
    "cumcorrTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumcorrTopN.html",
        "signatures": [
            {
                "full": "cumcorrTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumcorrTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumcorrTopN](https://docs.dolphindb.cn/zh/funcs/c/cumcorrTopN.html)\n\n\n\n#### 语法\n\ncumcorrTopN(X, Y, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[cumTopN 系列](https://docs.dolphindb.cn/zh/funcs/themes/cumTopN.html)\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，然后计算 *X* 和 *Y* 之间的相关性。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 13 4 3\nY = 1 7 8 9 0 5 8\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumcorrTopN(X, Y, S, 6)\n// output\n[,1,0.9244,0.6588,-0.1784,-0.1764,-0.1825]\n```\n"
    },
    "cumcount": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumcount.html",
        "signatures": [
            {
                "full": "cumcount(X)",
                "name": "cumcount",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumcount](https://docs.dolphindb.cn/zh/funcs/c/cumcount.html)\n\n\n\n#### 语法\n\ncumcount(X)\n\n参数说明和窗口计算规则请参考: [累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 中累积非 NULL 的元素数量。\n\n#### 例子\n\n```\nx=[1,2,NULL,3,4,NULL,5,6]\ncumcount(x);\n// output\n[1,2,2,3,4,4,5,6]\n\nm=matrix(1 2 3 NULL 4, 5 6 NULL NULL 8);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 2  | 6  |\n| 3  |    |\n|    |    |\n| 4  | 8  |\n\n```\ncumcount(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 2  | 2  |\n| 3  | 2  |\n| 3  | 2  |\n| 4  | 3  |\n\n相关函数：[count](https://docs.dolphindb.cn/zh/funcs/c/count.html)\n"
    },
    "cumcovar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumcovar.html",
        "signatures": [
            {
                "full": "cumcovar(X,Y)",
                "name": "cumcovar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cumcovar](https://docs.dolphindb.cn/zh/funcs/c/cumcovar.html)\n\n\n\n#### 语法\n\ncumcovar(X,Y)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n累积计算 *X* 和 *Y* 的协方（covariance）。\n\n#### 例子\n\n```\nx = 7 4 5 8 9\ny = 1 7 8 9 0\ncumcovar(x, y);\n// output\n[,-9,-5.166667,-1,-4.5]\n```\n\n相关函数：[covar](https://docs.dolphindb.cn/zh/funcs/c/covar.html)\n"
    },
    "cumcovarTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumcovarTopN.html",
        "signatures": [
            {
                "full": "cumcovarTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumcovarTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumcovarTopN](https://docs.dolphindb.cn/zh/funcs/c/cumcovarTopN.html)\n\n\n\n#### 语法\n\ncumcovarTopN(X, Y, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[cumTopN 系列](https://docs.dolphindb.cn/zh/funcs/themes/cumTopN.html)\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，然后计算 *X* 和 *Y* 的协方差。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 13 4 3\nY = 1 7 8 9 0 5 8\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumcovarTopN(X, Y, S, 6)\n// output\n[,3,3.5,9.6666,-4,-3.2,-3.3333]\n```\n"
    },
    "cumdenseRank": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumdenseRank.html",
        "signatures": [
            {
                "full": "cumdenseRank(X, [ascending=true], [ignoreNA=true], [percent=false], [norm='max'])",
                "name": "cumdenseRank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[norm='max']",
                        "name": "norm",
                        "optional": true,
                        "default": "'max'"
                    }
                ]
            }
        ],
        "markdown": "### [cumdenseRank](https://docs.dolphindb.cn/zh/funcs/c/cumdenseRank.html)\n\n#### 语法\n\ncumdenseRank(X, \\[ascending=true], \\[ignoreNA=true], \\[percent=false], \\[norm='max'])\n\n#### 参数\n\n**X** 可以是向量、矩阵或内存表。\n\n**ascending** 是一个布尔值，表示是否按升序排序。默认值是 true。\n\n**ignoreNA** 是一个布尔值，表示是否忽略 NULL 值，true 表示忽略 NULL 值，false 表示 NULL 作为最小值参与排名。默认值为 true。\n\n**percent** 是一个布尔值，表示是否以百分比形式显示返回的排名，默认值为 false。\n\n**norm** 是一个字符串，可为 'max' 或 'minmax' ，在计算百分比时，不同设置值决定了排名的起始值，进而可决定了百分比的计算结果。当 *norm*='max' 时，排名从1开始；当 *norm*='minmax' 时，排名从0开始。以返回 \\[3, 1, 2] 的密集排名百分比为例进行说明：\n\n* 当 *norm*='max' 时，最后一个累计窗口中2的排名为2，窗口中的最大排名数为3，因此结果为2\\3。\n\n* 当 *norm*='minmax' 时，最后一个累计窗口中2的排名为1，窗口中的最大排名数为2，因此结果为1\\2。\n\n#### 详情\n\n**Note:**\n\n* 该函数首发于1.30.22.3版本。\n* 若要使用参数 *norm*，*percent* 应为 true\n\n若 *X* 是向量，对 *X* 中的每一个元素，返回其在累计窗口内的密集排名。\n\n* 基于 *ascending* 指定的方式排序。\n\n* 如果 *ignoreNA* = true，则 NULL 值不参与排序，结果中 NULL 值的排名为空。\n\n若 X 是矩阵或内存表，在每列内进行上述计算，返回一个与 *X* 维度相同的矩阵或内存表。\n\n#### 例子\n\n```\na = 1 3 2 3 4\ncumdenseRank(X=a, ascending=true, ignoreNA=true, percent=false)\n// output\n[0,1,1,2,3]\n\ncumdenseRank(X=a, ascending=true, ignoreNA=true, percent=true, norm=\"max\")\n// output\n[1,1,0.6667,1,1]\n\ncumdenseRank(X=a, ascending=true, ignoreNA=true, percent=true, norm=\"minmax\")\n// output\n[1,1,0.5,1,1]\n\nm = matrix(1 6 2 NULL, 3 0 1 6, 7 3 NULL 2)\ncumdenseRank(X=m, ascending=true, ignoreNA=true, percent=false)\n#0 #1 #2\n-- -- --\n0  0  0 \n1  0  0 \n1  1    \n   3  0\n       \nt = table([4,10,3,4,8,1] as val1, [10,8,1,8,5,2]  as val2)\ncumdenseRank(X=t, ascending=true, ignoreNA=true, percent=false)\n    \tval1\tval2\n    0\t0\t0\n    1\t1\t0\n    2\t0\t0\n    3\t1\t1\n    4\t2\t1\n    5\t0\t1\n```\n\n"
    },
    "cumfirstNot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumfirstNot.html",
        "signatures": [
            {
                "full": "cumfirstNot(X, [k])",
                "name": "cumfirstNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k]",
                        "name": "k",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [cumfirstNot](https://docs.dolphindb.cn/zh/funcs/c/cumfirstNot.html)\n\n\n\n#### 语法\n\ncumfirstNot(X, \\[k])\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 参数\n\n**k** 一个标量。\n\n#### 详情\n\n* 若 *X* 是向量：\n\n  * 如果没有指定 *k*，对 *X* 内的每个元素，返回其之前所有元素中第一个不为 NULL 的元素。\n\n  * 如果指定 *k*，对 *X* 内的每个元素，返回其之前所有元素中第一个不为 *k* 的元素。\n\n* 若 *X* 是矩阵，在每列内进行上述计算，返回一个与 *X* 维度相同的矩阵。\n\n#### 例子\n\n```\nx=[NULL,1,2,6,NULL,3,4,NULL]\ncumfirstNot(x);\n// output\n[,1,1,1,1,1,1,1]\n\ncumfirstNot(x, 1)\n// output\n[,,2,2,2,2,2,2]\n\nm=matrix(1 2 3 NULL 4, NULL NULL 8 8 9);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 2  |    |\n| 3  | 8  |\n|    | 8  |\n| 4  | 9  |\n\n```\ncumfirstNot(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 1  |    |\n| 1  | 8  |\n| 1  | 8  |\n| 1  | 8  |\n\n相关函数： [firstNot](https://docs.dolphindb.cn/zh/funcs/f/firstNot.html)\n"
    },
    "cumkurtosisTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumkurtosisTopN.html",
        "signatures": [
            {
                "full": "cumkurtosisTopN(X, S, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "cumkurtosisTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumkurtosisTopN](https://docs.dolphindb.cn/zh/funcs/c/cumkurtosisTopN.html)\n\n\n\n#### 语法\n\ncumkurtosisTopN(X, S, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[cumTopN 系列](https://docs.dolphindb.cn/zh/funcs/themes/cumTopN.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否是有偏估计。默认值为 true，表示有偏估计。\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素并计算峰度。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumkurtosisTopN(X, S, 6)\n// output\n[,,1.5,2.2304,3.2152,4.1525,4.1554]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumkurtosisTopN(X, S, 6)\n```\n\n| #0     | #1     |\n| ------ | ------ |\n|        |        |\n|        |        |\n| 1.5    |        |\n| 1.5    | 1.5    |\n| 1.8457 | 1.5    |\n| 1.5092 | 1.8457 |\n| 1.5    | 1.5092 |\n| 1.9204 | 1.5    |\n| 1.9204 | 1.6107 |\n| 1.9204 | 1.7297 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumkurtosisTopN(price, id, 6) as result from t\n```\n\n| result |\n| ------ |\n|        |\n|        |\n| 1.5    |\n| 1.4036 |\n| 1.537  |\n| 1.8185 |\n| 1.8838 |\n| 2.0968 |\n| 2.6695 |\n| 2.6695 |\n"
    },
    "cumlastNot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumlastNot.html",
        "signatures": [
            {
                "full": "cumlastNot(X, [k])",
                "name": "cumlastNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k]",
                        "name": "k",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [cumlastNot](https://docs.dolphindb.cn/zh/funcs/c/cumlastNot.html)\n\n\n\n#### 语法\n\ncumlastNot(X, \\[k])\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 参数\n\n**k** 一个标量。\n\n#### 详情\n\n* 若 *X* 是向量：\n\n  * 如果没有指定 *k*，对 *X* 内的每个元素，返回其之前所有元素中最后一个不为 NULL 的元素。\n\n  * 如果指定 *k*，对 *X* 内的每个元素，返回其之前所有元素中最后一个不为 *k* 的元素。\n\n* 若 *X* 是矩阵，在每列内进行上述计算，返回一个与 *X* 维度相同的矩阵。\n\n#### 例子\n\n```\nx=[NULL,1,2,6,NULL,3,4,NULL]\ncumlastNot(x);\n// output\n[,1,2,6,6,3,4,4]\n\ncumlastNot(x, 4)\n// output\n[,1,2,6,6,3,3,3]\n\nm=matrix(1 2 3 NULL 4, NULL NULL 8 8 9);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 2  |    |\n| 3  | 8  |\n|    | 8  |\n| 4  | 9  |\n\n```\ncumlastNot(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 2  |    |\n| 3  | 8  |\n| 3  | 8  |\n| 4  | 9  |\n\n相关函数： [lastNot](https://docs.dolphindb.cn/zh/funcs/l/lastNot.html)\n"
    },
    "cummax": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cummax.html",
        "signatures": [
            {
                "full": "cummax(X)",
                "name": "cummax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cummax](https://docs.dolphindb.cn/zh/funcs/c/cummax.html)\n\n\n\n#### 语法\n\ncummax(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计最大值。\n\n#### 例子\n\n```\nx = [7,4,5,8,9]\ncummax(x);\n// output\n[7,7,7,8,9]\n\nm = matrix(6 5 7 8 1, 3 9 4 2 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 5  | 9  |\n| 7  | 4  |\n| 8  | 2  |\n| 1  | 10 |\n\n```\ncummax(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 6  | 9  |\n| 7  | 9  |\n| 8  | 9  |\n| 8  | 10 |\n\n相关函数：[cummin](https://docs.dolphindb.cn/zh/funcs/c/cummin.html), [max](https://docs.dolphindb.cn/zh/funcs/m/max.html)\n"
    },
    "cummdd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cummdd.html",
        "signatures": [
            {
                "full": "cummdd(X, [ratio=true])",
                "name": "cummdd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ratio=true]",
                        "name": "ratio",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [cummdd](https://docs.dolphindb.cn/zh/funcs/c/cummdd.html)\n\n\n\n#### 语法\n\ncummdd(X, \\[ratio=true])\n\n#### 详情\n\n累计计算传入向量数据的最大回撤。\n\n#### 参数\n\n**X** 数值向量，表示用于计算最大回撤的输入数据，一般指累积的收益或收益率。注意：不可为空。\n\n**ratio**布尔标量，表示是否返回最大回撤率。默认值为 true。\n\n* 若为 true，表示返回最大回撤率，即相对于峰值的最大下降百分比，计算公式为：\n\n  ![](https://docs.dolphindb.cn/zh/funcs/images/mdd1.png)\n\n* 若为 false，表示返回基于下降金额绝对值的最大回撤，计算公式为：\n\n  ![](https://docs.dolphindb.cn/zh/funcs/images/mdd2.png)\n\n注意：计算时将忽略空值。\n\n窗口计算规则请参考: [累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 例子\n\n假设有一个投资组合在一段时间内的累积收益变化如下（以天为单位）：\n\n<table id=\"table_hfv_wzx_bdc\"><thead><tr><th align=\"left\">\n\n日期\n\n</th><th align=\"left\">\n\n累积收益\n\n</th></tr></thead><tbody><tr><td>\n\n2024-10-01\n\n</td><td>\n\n36\n\n</td></tr><tr><td>\n\n2024-10-02\n\n</td><td>\n\n96\n\n</td></tr><tr><td>\n\n2024-10-03\n\n</td><td>\n\n42\n\n</td></tr><tr><td>\n\n2024-10-04\n\n</td><td>\n\n100\n\n</td></tr><tr><td>\n\n2024-10-05\n\n</td><td>\n\n59\n\n</td></tr><tr><td>\n\n2024-10-06\n\n</td><td>\n\n86\n\n</td></tr><tr><td>\n\n2024-10-07\n\n</td><td>\n\n25\n\n</td></tr><tr><td>\n\n2024-10-08\n\n</td><td>\n\n72\n\n</td></tr></tbody>\n</table>使用 `cummdd` 计算该数据的累计最大回撤。\n\n```\nx = [36,96,42,100,59,86,25,64,72]\ncummdd(x)\n// Output: [0,0,0.5625,0.5625,0.5625,0.5625,0.75,0.75,0.75]\ncummdd(x, false)\n// Output: [0,0,54,54,54,54,75,75,75]\n```\n\n相关函数：[maxDrawdown](https://docs.dolphindb.cn/zh/funcs/m/maxdrawdown.html)\n"
    },
    "cummed": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cummed.html",
        "signatures": [
            {
                "full": "cummed(X)",
                "name": "cummed",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cummed](https://docs.dolphindb.cn/zh/funcs/c/cummed.html)\n\n\n\n#### 语法\n\ncummed(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计中位数。\n\n#### 例子\n\n```\nx = [7,9,5,NULL,9]\ncummed(x);\n// output\n[7,8,7,7,8]\n\nm = matrix(6 5 7 8 1, 3 9 4 2 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 5  | 9  |\n| 7  | 4  |\n| 8  | 2  |\n| 1  | 10 |\n\n```\ncummed(m);\n```\n\n| #0  | #1  |\n| --- | --- |\n| 6   | 3   |\n| 5.5 | 6   |\n| 6   | 4   |\n| 6.5 | 3.5 |\n| 6   | 4   |\n\n相关函数：[cummax](https://docs.dolphindb.cn/zh/funcs/c/cummax.html), [cummin](https://docs.dolphindb.cn/zh/funcs/c/cummin.html), [med](https://docs.dolphindb.cn/zh/funcs/m/med.html)\n"
    },
    "cummin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cummin.html",
        "signatures": [
            {
                "full": "cummin(X)",
                "name": "cummin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cummin](https://docs.dolphindb.cn/zh/funcs/c/cummin.html)\n\n\n\n#### 语法\n\ncummin(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计最小值。\n\n#### 例子\n\n```\nx = [7,4,5,NULL,9]\ncummin(x);\n// output\n[7,4,4,4,4]\n\nm = matrix(6 5 7 8 1, 3 9 4 2 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 5  | 9  |\n| 7  | 4  |\n| 8  | 2  |\n| 1  | 10 |\n\n```\ncummin(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 5  | 3  |\n| 5  | 3  |\n| 5  | 2  |\n| 1  | 2  |\n\n相关函数：[cummax](https://docs.dolphindb.cn/zh/funcs/c/cummax.html), [min](https://docs.dolphindb.cn/zh/funcs/m/min.html)\n"
    },
    "cumnunique": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumnunique.html",
        "signatures": [
            {
                "full": "cumnunique(X, [ignoreNull=false])",
                "name": "cumnunique",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ignoreNull=false]",
                        "name": "ignoreNull",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [cumnunique](https://docs.dolphindb.cn/zh/funcs/c/cumnunique.html)\n\n\n\n#### 语法\n\ncumnunique(X, \\[ignoreNull=false])\n\n参数说明和窗口计算规则请参考：[cumFunctions](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 参数\n\n**ignoreNull** 是一个布尔值，表示是否忽略 *X*中 NULL 值。若指定 *ignoreNull*=true，则统计唯一值时将不考虑 NULL 值；否则将会统计 NULL 值。默认值为 false。\n\n#### 详情\n\n统计 *X* 元素的累计唯一值数量。若指定 *ignoreNull*=true，则统计唯一值时将不考虑 NULL 值；否则将会统计 NULL 值。\n\n#### 例子\n\n```\nv = [NULL, 1, 2, -6, 0, 1, 2]\ncumnunique(v)\n// output: [1,2,3,4,5,5,5]\n\ncumnunique(v,true)\n// output: [0,1,2,3,4,4,4]\n\nt = table(`a`a`b`c`a`b as id, 20 20 10 40 30 20 as val)\nselect cumnunique(id) as cumVal from t\n```\n\n| cumVal |\n| ------ |\n| 1      |\n| 1      |\n| 2      |\n| 3      |\n| 3      |\n| 3      |\n"
    },
    "cumpercentile": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumpercentile.html",
        "signatures": [
            {
                "full": "cumpercentile(X, percent, [interpolation='linear'])",
                "name": "cumpercentile",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "percent",
                        "name": "percent"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    }
                ]
            }
        ],
        "markdown": "### [cumpercentile](https://docs.dolphindb.cn/zh/funcs/c/cumpercentile.html)\n\n\n\n#### 语法\n\ncumpercentile(X, percent, \\[interpolation='linear'])\n\n部分通用参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 参数\n\n**percent** 是 0 到 100 之间的整数或小数。\n\n**interpolation** 是一个字符串，表示当选中的分位点位于在 *X* 的第 i 和第 i+1 个元素之间时，采用的插值方法。它具有以下取值：\n\n* 'linear': ![linear](https://docs.dolphindb.cn/zh/images/linear.png), 其中 ![fraction](https://docs.dolphindb.cn/zh/images/fraction_cumpercentile.png)\n\n* 'lower': ![lower](https://docs.dolphindb.cn/zh/images/lower.png)\n\n* 'higher': ![higher](https://docs.dolphindb.cn/zh/images/higher.png)\n\n* 'nearest': ![lower](https://docs.dolphindb.cn/zh/images/lower.png)和![higher](https://docs.dolphindb.cn/zh/images/higher.png)之中最接近分位点的数据\n\n* 'midpoint': ![midpoint](https://docs.dolphindb.cn/zh/images/midpoint.png)\n\n如果没有指定 *interpolation*，默认采用 'linear'。\n\n如果没有指定 *interpolation*，默认采用 'linear'。\n\n#### 详情\n\n计算 *X* 元素的累计百分位。\n\n#### 例子\n\n```\na=1..10;\n\ncumpercentile(a,25);\n\n[1,1.25,1.5,1.75,2,2.25,2.5,2.75,3,3.25]\n\ncumpercentile(a,25,'lower');\n\n[1,1,1,1,2,2,2,2,3,3]\n\ncumpercentile(a,25,'higher');\n\n[1,2,2,2,2,3,3,3,3,4]\n\ncumpercentile(a,25,'midpoint');\n\n[1,1.5,1.5,1.5,2,2.5,2.5,2.5,3,3.5]\n\ncumpercentile(a,25,'nearest');\n\n[1,1,1,2,2,2,2,3,3,3]\n\ncumpercentile(a,50.5);\n\n[1,1.505,2.01,2.515,3.02,3.525,4.03,4.535,5.04,5.545]\n\nm=matrix(1..10, 11..20);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n| 6  | 16 |\n| 7  | 17 |\n| 8  | 18 |\n| 9  | 19 |\n| 10 | 20 |\n\n```\ncumpercentile(m,25);\n```\n\n| #0   | #1    |\n| ---- | ----- |\n| 1    | 11    |\n| 1.25 | 11.25 |\n| 1.5  | 11.5  |\n| 1.75 | 11.75 |\n| 2    | 12    |\n| 2.25 | 12.25 |\n| 2.5  | 12.5  |\n| 2.75 | 12.75 |\n| 3    | 13    |\n| 3.25 | 13.25 |\n\n相关函数：[percentile](https://docs.dolphindb.cn/zh/funcs/p/percentile.html)\n"
    },
    "cumPositiveStreak": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumPositiveStreak.html",
        "signatures": [
            {
                "full": "cumPositiveStreak(X)",
                "name": "cumPositiveStreak",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumPositiveStreak](https://docs.dolphindb.cn/zh/funcs/c/cumPositiveStreak.html)\n\n\n\n#### 语法\n\ncumPositiveStreak(X)\n\n参数说明和窗口计算规则请参考：[cumFunctions](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n累计计算 *X* 中连续的正数之和的。\n\n#### 例子\n\n```\nx=1 0 -1 1 2 2 2 1 0 -1 0 2;\n\ncumPositiveStreak x;\n// output\n[1,0,0,1,3,5,7,8,0,0,0,2]\n\nm=matrix(1 0 -1 1 2 2 2 1 0 -1 0 2, -1 -2 -1 0 1 3 6 7 0 -1 -2 0);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | -1 |\n| 0  | -2 |\n| -1 | -1 |\n| 1  | 0  |\n| 2  | 1  |\n| 2  | 3  |\n| 2  | 6  |\n| 1  | 7  |\n| 0  | 0  |\n| -1 | -1 |\n| 0  | -2 |\n| 2  | 0  |\n\n```\ncumPositiveStreak(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 0  |\n| 0  | 0  |\n| 0  | 0  |\n| 1  | 0  |\n| 3  | 1  |\n| 5  | 4  |\n| 7  | 10 |\n| 8  | 17 |\n| 0  | 0  |\n| 0  | 0  |\n| 0  | 0  |\n| 2  | 0  |\n"
    },
    "cumprod": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumprod.html",
        "signatures": [
            {
                "full": "cumprod(X)",
                "name": "cumprod",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumprod](https://docs.dolphindb.cn/zh/funcs/c/cumprod.html)\n\n\n\n#### 语法\n\ncumprod(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计乘积。\n\n#### 例子\n\n```\ncumprod(2 3 4);\n// output\n[2,6,24]\n# 等价于 [2, 2*3, 2*3*4]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ncumprod(m);\n```\n\n| #0 | #1  |\n| -- | --- |\n| 1  | 4   |\n| 2  | 20  |\n| 6  | 120 |\n\n相关函数：[prod](https://docs.dolphindb.cn/zh/funcs/p/prod.html)\n"
    },
    "cumrank": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumrank.html",
        "signatures": [
            {
                "full": "cumrank(X, [ascending=true], [ignoreNA=true], [tiesMethod='min'], [percent=false)",
                "name": "cumrank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='min']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'min'"
                    },
                    {
                        "full": "[percent=false",
                        "name": "[percent=false"
                    }
                ]
            }
        ],
        "markdown": "### [cumrank](https://docs.dolphindb.cn/zh/funcs/c/cumrank.html)\n\n\n\n#### 语法\n\ncumrank(X, \\[ascending=true], \\[ignoreNA=true], \\[tiesMethod='min'], \\[percent=false)\n\n部分通用参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 参数\n\n**ascending** 是一个布尔值，表示是否按升序排序。默认值是 true。\n\n**ignoreNA** 是一个布尔值，表示是否忽略 NULL 值。true 表示忽略 NULL 值（默认值），false 表示 NULL 值参与排名，此时 NULL 值为最小值。\n\n**tiesMethod** 是一个字符串，表示窗口内若存在重复值时，排名如何选取。\n\n* 'min'表示取最小排名。\n* 'max'表示取最大排名。\n* 'average'表示取排名的均值。\n\n**percent** 是一个布尔值，表示是否以百分比形式显示返回的排名，默认值为 false。\n\n#### 详情\n\n对 *X* 中的每一个元素，返回其在累计窗口内的排名。\n\n**Note:** 如果 *ignoreNA* = true，则 NULL 值不参与排序，结果中 NULL 值的排名为空。\n\n#### 例子\n\n```\ncumrank(1 3 2 3 4);\n// output\n[0,1,1,2,4]\n\ncumrank(1 3 2 2 4 NULL, , true);\n// output\n[0,1,1,1,4,]\n\ncumrank(1 3 2 2 4 NULL, , false);\n// output\n[0,1,1,1,4,0]\n\ncumrank(1 3 2 2 4 NULL, , false, 'max');\n// output\n[0,1,1,2,4,0]\n\nm=matrix(1 4 2 3 4, 4 NULL 6 1 2);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 4  |    |\n| 2  | 6  |\n| 3  | 1  |\n| 4  | 2  |\n\n```\ncumrank(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 0  | 0  |\n| 1  |    |\n| 1  | 1  |\n| 2  | 0  |\n| 3  | 1  |\n\n相关函数：[rank](https://docs.dolphindb.cn/zh/funcs/r/rank.html)\n"
    },
    "cumskewTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumskewTopN.html",
        "signatures": [
            {
                "full": "cumskewTopN(X, S, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "cumskewTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumskewTopN](https://docs.dolphindb.cn/zh/funcs/c/cumskewTopN.html)\n\n\n\n#### 语法\n\ncumskewTopN(X, S, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[cumTopN 系列](https://docs.dolphindb.cn/zh/funcs/themes/cumTopN.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否是有偏估计。默认值为 true，表示有偏估计。\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素并计算斜度。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumskewTopN(X, S, 6)\n// output\n[,0,0,1.0182,1.4754,1.7635,1.7650]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumskewTopN(X, S, 6)\n```\n\n| #0      | #1      |\n| ------- | ------- |\n|         |         |\n| 0       |         |\n| 0       | 0       |\n| 0       | 0       |\n| 0.4373  | 0       |\n| 0.158   | 0.4347  |\n| 0       | 0.158   |\n| -0.4448 | 0       |\n| -0.4448 | -0.3599 |\n| -0.4448 | -0.1413 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumskewTopN(price, id, 6) as result from t\n```\n\n| result  |\n| ------- |\n|         |\n| 0       |\n| -0.6435 |\n| -0.7353 |\n| -0.209  |\n| -0.2864 |\n| -0.0042 |\n| 0.0955  |\n| 0.0955  |\n| -0.5659 |\n"
    },
    "cumstd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumstd.html",
        "signatures": [
            {
                "full": "cumstd(X)",
                "name": "cumstd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumstd](https://docs.dolphindb.cn/zh/funcs/c/cumstd.html)\n\n\n\n#### 语法\n\ncumstd(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计标准差。\n\n#### 例子\n\n```\nx = [1,2,4,NULL,8];\ncumstd(x);\n// output\n[,0.707107,1.527525,1.527525,3.095696]\n\nm=matrix(0.15 0.08 0.03 -0.14 -0.09, 0.2 -0.12 -0.16 0.08 0.16);\nm;\n```\n\n| #0    | #1    |\n| ----- | ----- |\n| 0.15  | 0.2   |\n| 0.08  | -0.12 |\n| 0.03  | -0.16 |\n| -0.14 | 0.08  |\n| -0.09 | 0.16  |\n\n```\ncumstd(m);\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n| 0.049497474683058 | 0.226274169979695 |\n| 0.060277137733417 | 0.19731531449265  |\n| 0.123558353285671 | 0.169705627484771 |\n| 0.119707978013163 | 0.16346253393362  |\n\n相关函数：[std](https://docs.dolphindb.cn/zh/funcs/s/std.html)\n"
    },
    "cumstdp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumstdp.html",
        "signatures": [
            {
                "full": "cumstdp(X)",
                "name": "cumstdp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumstdp](https://docs.dolphindb.cn/zh/funcs/c/cumstdp.html)\n\n\n\n#### 语法\n\ncumstdp(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计总体标准差。\n\n#### 例子\n\n```\nx = [1,2,4,NULL,8];\n// output\n[ , 0.5, 1.247219128924647, 1.247219128924647, 2.680951323690902]\n```\n\n```\nm=matrix(0.15 0.08 0.03 -0.14 -0.09, 0.2 -0.12 -0.16 0.08 0.16);\nm;\n```\n\n| #0    | #1    |\n| ----- | ----- |\n| 0.15  | 0.2   |\n| 0.08  | -0.12 |\n| 0.03  | -0.16 |\n| -0.14 | 0.08  |\n| -0.09 | 0.16  |\n\n```\ncumstdp(m);\n```\n\n| col1   | col2   |\n| ------ | ------ |\n| 0      | 0      |\n| 0.035  | 0.16   |\n| 0.0492 | 0.1611 |\n| 0.107  | 0.147  |\n| 0.1071 | 0.1462 |\n"
    },
    "cumstdpTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumstdpTopN.html",
        "signatures": [
            {
                "full": "cumstdpTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumstdpTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumstdpTopN](https://docs.dolphindb.cn/zh/funcs/c/cumstdpTopN.html)\n\n\n\n#### 语法\n\ncumstdpTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[cumTopN 系列](https://docs.dolphindb.cn/zh/funcs/themes/cumTopN.html)\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素并计算总体标准差。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumstdpTopN(X, S, 6)\n// output\n[0,0.5,0.8164,3.5355,38.5299,35.8933,35.8116]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumstdpTopN(X, S, 6)\n```\n\n| #1     | #2     |\n| ------ | ------ |\n| 0      |        |\n| 0.5    | 0      |\n| 0.8165 | 0.5    |\n| 0.8165 | 0.8165 |\n| 1.479  | 0.8165 |\n| 1.8547 | 1.479  |\n| 2.1602 | 1.8547 |\n| 2.3805 | 2.1602 |\n| 2.3805 | 2.5441 |\n| 2.3805 | 2.7689 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumstdpTopN(price, id, 6) as result from t\n```\n\n| result  |\n| ------- |\n| 0       |\n| 28.5    |\n| 26.8701 |\n| 24.8294 |\n| 22.2657 |\n| 29.4543 |\n| 29.4543 |\n| 30.8081 |\n| 25.5435 |\n| 25.5435 |\n"
    },
    "cumstdTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumstdTopN.html",
        "signatures": [
            {
                "full": "cumstdTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumstdTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumstdTopN](https://docs.dolphindb.cn/zh/funcs/c/cumstdTopN.html)\n\n\n\n#### 语法\n\ncumstdTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[cumTopN 系列](https://docs.dolphindb.cn/zh/funcs/themes/cumTopN.html)\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素并计算标准差。\n\n返回值：DOUBLE 类型向量或矩阵。\n\n#### 例子\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumstdTopN(X, S, 6)\n// output\n[,0.70,1,4.08,43.07,39.31,39.22]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumstdTopN(X, S, 6)\n```\n\n| #0     | #1     |\n| ------ | ------ |\n|        |        |\n| 0.7071 |        |\n| 1      | 0.7071 |\n| 1      | 1      |\n| 1.7078 | 1      |\n| 2.0736 | 1.7078 |\n| 2.3664 | 2.0736 |\n| 2.6077 | 2.3664 |\n| 2.6077 | 2.7869 |\n| 2.6077 | 3.0332 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumavgTopN(price, id, 6) as result from t\n```\n\n| result  |\n| ------- |\n| 94      |\n| 69.5    |\n| 46.3333 |\n| 55.75   |\n| 57.8    |\n| 49.6667 |\n| 50.5    |\n| 50.5    |\n| 51.5    |\n| 51.5    |\n"
    },
    "cumsum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumsum.html",
        "signatures": [
            {
                "full": "cumsum(X)",
                "name": "cumsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumsum](https://docs.dolphindb.cn/zh/funcs/c/cumsum.html)\n\n\n\n#### 语法\n\ncumsum(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计和。\n\n#### 例子\n\n```\nx=[2,3,4];\ncumsum(x);\n// output\n[2,5,9]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ncumsum(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 3  | 9  |\n| 6  | 15 |\n\n相关函数：[sum](https://docs.dolphindb.cn/zh/funcs/s/sum.html)\n"
    },
    "cumsum2": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumsum2.html",
        "signatures": [
            {
                "full": "cumsum2(X)",
                "name": "cumsum2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumsum2](https://docs.dolphindb.cn/zh/funcs/c/cumsum2.html)\n\n\n\n#### 语法\n\ncumsum2(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计平方和。\n\n#### 例子\n\n```\nx=[2,3,4];\ncumsum2 x;\n// output\n[4,13,29]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 16 |\n| 5  | 41 |\n| 14 | 77 |\n\n相关函数：[sum2](https://docs.dolphindb.cn/zh/funcs/s/sum2.html)\n"
    },
    "cumsum3": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumsum3.html",
        "signatures": [
            {
                "full": "cumsum3(X)",
                "name": "cumsum3",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumsum3](https://docs.dolphindb.cn/zh/funcs/c/cumsum3.html)\n\n\n\n#### 语法\n\ncumsum3(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计立方和。\n\n#### 例子\n\n```\nx=[2,3,4];\ncumsum3 x;\n// output\n[8,35,99]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ncumsum3(m);\n```\n\n| #0 | #1  |\n| -- | --- |\n| 1  | 64  |\n| 9  | 189 |\n| 36 | 405 |\n\n相关函数：[sum](https://docs.dolphindb.cn/zh/funcs/s/sum.html)\n"
    },
    "cumsum4": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumsum4.html",
        "signatures": [
            {
                "full": "cumsum4(X)",
                "name": "cumsum4",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumsum4](https://docs.dolphindb.cn/zh/funcs/c/cumsum4.html)\n\n\n\n#### 语法\n\ncumsum4(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计四次方和。\n\n#### 例子\n\n```\nx=[2,3,4];\ncumsum4 x;\n// output\n[16,97,353]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ncumsum4(m);\n```\n\n| #0 | #1   |\n| -- | ---- |\n| 1  | 256  |\n| 17 | 881  |\n| 98 | 2177 |\n\n相关函数：[sum4](https://docs.dolphindb.cn/zh/funcs/s/sum4.html)\n"
    },
    "cumsumTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumsumTopN.html",
        "signatures": [
            {
                "full": "cumsumTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumsumTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumsumTopN](https://docs.dolphindb.cn/zh/funcs/c/cumsumTopN.html)\n\n\n\n#### 语法\n\ncumsumTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[cumTopN 系列](https://docs.dolphindb.cn/zh/funcs/themes/cumTopN.html)\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素并计算和。\n\n返回值：LONG 或 DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumsumTopN(X, S, 6, 4)\n// output\n[1,3,6,16,116,120,121]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumsumTopN(X, S, 6, 4)\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 3  | 12 |\n| 6  | 25 |\n| 6  | 39 |\n| 11 | 39 |\n| 17 | 55 |\n| 24 | 72 |\n| 30 | 90 |\n| 30 | 95 |\n| 30 | 96 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumsumTopN(price, id, 6, 4) as result from t\n```\n\n| result |\n| ------ |\n| 32     |\n| 130    |\n| 145    |\n| 223    |\n| 283    |\n| 292    |\n| 344    |\n| 364    |\n| 406    |\n| 333    |\n"
    },
    "cumvar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumvar.html",
        "signatures": [
            {
                "full": "cumvar(X)",
                "name": "cumvar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumvar](https://docs.dolphindb.cn/zh/funcs/c/cumvar.html)\n\n\n\n#### 语法\n\ncumvar(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计方差。\n\n#### 例子\n\n```\nx=[2,3,4];\ncumvar(x);\n// output\n[,0.5,1]\n\nm=matrix(0.15 0.08 0.03 -0.14 -0.09, 0.2 -0.12 -0.16 0.08 0.16);\nm;\n```\n\n| #0    | #1    |\n| ----- | ----- |\n| 0.15  | 0.2   |\n| 0.08  | -0.12 |\n| 0.03  | -0.16 |\n| -0.14 | 0.08  |\n| -0.09 | 0.16  |\n\n```\ncumvar(m);\n```\n\n| #0     | #1     |\n| ------ | ------ |\n|        |        |\n| 0.0024 | 0.0512 |\n| 0.0036 | 0.0389 |\n| 0.0152 | 0.0288 |\n| 0.0143 | 0.0267 |\n\n相关函数：[cummax](https://docs.dolphindb.cn/zh/funcs/c/cummax.html), [cummin](https://docs.dolphindb.cn/zh/funcs/c/cummin.html), [cumprod](https://docs.dolphindb.cn/zh/funcs/c/cumprod.html), [cumPositiveStreak](https://docs.dolphindb.cn/zh/funcs/c/cumPositiveStreak.html), [cumsum](https://docs.dolphindb.cn/zh/funcs/c/cumsum.html), [cumavg](https://docs.dolphindb.cn/zh/funcs/c/cumavg.html), [cumstd](https://docs.dolphindb.cn/zh/funcs/c/cumstd.html)\n"
    },
    "cumvarp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumvarp.html",
        "signatures": [
            {
                "full": "cumvarp(X)",
                "name": "cumvarp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [cumvarp](https://docs.dolphindb.cn/zh/funcs/c/cumvarp.html)\n\n\n\n#### 语法\n\ncumvarp(X)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 元素的累计总体方差。\n\n#### 例子\n\n```\ncumvarp(1 2 3 NULL 4);\n// output\n[ , 0.25, 0.666666666666667, 0.666666666666667, 1.25]\n\nm=matrix(1.1 3 5.0 7.5 9.2, 1 4.3 7.1 10.6 13.5);\nm;\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1.1  | 1    |\n| 3    | 4.3  |\n| 5    | 7.1  |\n| 7.5  | 10.6 |\n| 9.2  | 13.5 |\n\n```\ncumvarp(m);\n```\n\n| col1   | col2    |\n| ------ | ------- |\n| 0      | 0       |\n| 0.9025 | 2.7225  |\n| 2.5356 | 6.2156  |\n| 5.6425 | 12.5025 |\n| 8.5944 | 19.612  |\n\n相关函数： [var](https://docs.dolphindb.cn/zh/funcs/v/varp.html)\n"
    },
    "cumvarpTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumvarpTopN.html",
        "signatures": [
            {
                "full": "cumvarpTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumvarpTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumvarpTopN](https://docs.dolphindb.cn/zh/funcs/c/cumvarpTopN.html)\n\n\n\n#### 语法\n\ncumvarpTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[cumTopN 系列](https://docs.dolphindb.cn/zh/funcs/themes/cumTopN.html)\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素并计算总体方差。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumvarpTopN(X, S, 6)\n// output\n[0,0.25,0.6666,12.5,1484.5599,1288.3333,1282.4722]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumvarpTopN(X, S, 6)\n```\n\n| #1     | #2     |\n| ------ | ------ |\n| 0      |        |\n| 0.25   | 0      |\n| 0.6667 | 0.25   |\n| 0.6667 | 0.6667 |\n| 2.1875 | 0.6667 |\n| 3.44   | 2.1875 |\n| 4.6667 | 3.44   |\n| 5.6667 | 4.6667 |\n| 5.6667 | 6.4722 |\n| 5.6667 | 7.6667 |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumvarpTopN(price, id, 6) as result from t\n```\n\n| result   |\n| -------- |\n| 0        |\n| 182.25   |\n| 124.2222 |\n| 114.5    |\n| 255.44   |\n| 428.4722 |\n| 428.4722 |\n| 416.9167 |\n| 722.9167 |\n| 722.9167 |\n"
    },
    "cumvarTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumvarTopN.html",
        "signatures": [
            {
                "full": "cumvarTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumvarTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumvarTopN](https://docs.dolphindb.cn/zh/funcs/c/cumvarTopN.html)\n\n\n\n#### 语法\n\ncumvarTopN(X, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[cumTopN 系列](https://docs.dolphindb.cn/zh/funcs/themes/cumTopN.html)\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素并计算方差。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumvarTopN(X, S, 6)\n// output\n[,0.5,1,16.6666,1855.7,1546,1538.9666]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\ncumvarTopN(X, S, 6)\n```\n\n| #0     | #1     |\n| ------ | ------ |\n|        |        |\n| 0.5    |        |\n| 1      | 0.5    |\n| 1      | 1      |\n| 2.9167 | 1      |\n| 4.3    | 2.9167 |\n| 5.6    | 4.3    |\n| 6.8    | 5.6    |\n| 6.8    | 7.7667 |\n| 6.8    | 9.2    |\n\n```\nid=rand(10,10)\nprice=rand(100,10)\nt=table(id, price)\nselect cumvarTopN(price, id, 6) as result from t\n```\n\n| result   |\n| -------- |\n|          |\n| 800      |\n| 808.3333 |\n| 730.25   |\n| 825.2    |\n| 903.3667 |\n| 747.3667 |\n| 856.7    |\n| 887.4667 |\n| 994.9667 |\n"
    },
    "cumwavg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumwavg.html",
        "signatures": [
            {
                "full": "cumwavg(X, Y)",
                "name": "cumwavg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cumwavg](https://docs.dolphindb.cn/zh/funcs/c/cumwavg.html)\n\n\n\n#### 语法\n\ncumwavg(X, Y)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n以 *Y* 为权重，计算 *X* 的累计加权平均。\n\n#### 例子\n\n```\ncumwavg(2.2 1.1 3.3, 4 5 6);\n// output\n[2.2,1.588889,2.273333]\n\ncumwavg(1 NULL 1, 1 1 1);\n// output\n[1,1,1]\n```\n\n相关函数：[wavg](https://docs.dolphindb.cn/zh/funcs/w/wavg.html)\n"
    },
    "cumwsum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumwsum.html",
        "signatures": [
            {
                "full": "cumwsum(X, Y)",
                "name": "cumwsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [cumwsum](https://docs.dolphindb.cn/zh/funcs/c/cumwsum.html)\n\n\n\n#### 语法\n\ncumwsum(X, Y)\n\n参数说明和窗口计算规则请参考：[累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n计算 *X* 和 *Y* 的累计内积。\n\n#### 例子\n\n```\ncumwsum(2.2 1.1 3.3, 4 5 6);\n// output\n[8.8,14.3,34.1]\n\ncumwsum(1 NULL 1, 1 1 1);\n// output\n[1,1,2]\n```\n\n相关函数：[wsum](https://docs.dolphindb.cn/zh/funcs/w/wsum.html)\n"
    },
    "cumwsumTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cumwsumTopN.html",
        "signatures": [
            {
                "full": "cumwsumTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
                "name": "cumwsumTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [cumwsumTopN](https://docs.dolphindb.cn/zh/funcs/c/cumwsumTopN.html)\n\n\n\n#### 语法\n\ncumwsumTopN(X, Y, S, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n部分通用参数说明和窗口计算规则请参考：[cumTopN 系列](https://docs.dolphindb.cn/zh/funcs/themes/cumTopN.html)\n\n#### 详情\n\n在累计窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，然后计算 *X* 和 *Y* 的内积。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 13 4 3\nY = 1 7 8 9 0 5 8\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\ncumwsumTopN(X, Y, S, 6)\n```\n\n返回值为：\\[1,15,39,129,129,149,159]\n"
    },
    "cut": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cut.html",
        "signatures": [
            {
                "full": "cut(X, size|cutPositions)",
                "name": "cut",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "size|cutPositions",
                        "name": "size|cutPositions"
                    }
                ]
            }
        ],
        "markdown": "### [cut](https://docs.dolphindb.cn/zh/funcs/c/cut.html)\n\n\n\n#### 语法\n\ncut(X, size|cutPositions)\n\n#### 参数\n\n**X** 是标量/向量。\n\n**size** 是整型标量，必须满足 0<*size*<=*size*(*X*) 条件。\n\n**cutPositions** 是单增的整型向量，用于指定切分段开始的索引。\n\n#### 详情\n\n将 *X* 分为一系列标量、向量、矩阵（按列）或表（按行）。\n\n* 当 *X* 是标量时：第二个参数只能是 *size*，且 *size* 值只能为1，cut 函数返回由 *X* 组成的元组。\n\n* 当 *X* 是向量时：\n\n  * 若第二个参数为 *size*：cut 函数把 *X* 分成一系列长度为 *size* 的标量（*size* =1时）或向量（*size* >1时）。\n\n  * 若第二个参数为 *cutPositions*，cut 函数先根据 *cutPositions* 将 *X* 分段，然后返回每段子向量组成的元组。\n\n* 当 *X* 是矩阵（表）时：\n\n  * 若第二个参数为 *size*：cut 函数把 *X* 分成一系列列数（行数）为 *size* 的矩阵（表）。\n\n  * 若第二个参数为 *cutPositions*，cut 函数先根据 *cutPositions* 将 *X* 分段，然后返回每个子矩阵（子表）组成的元组。\n\n关于该函数的逆操作，参见 [flatten](https://docs.dolphindb.cn/zh/funcs/f/flatten.html) 函数。\n\n#### 例子\n\n```\na=1..10;\ncut(a,2);\n// output\n([1,2],[3,4],[5,6],[7,8],[9,10])\n\ncut(a,3);\n// output\n([1,2,3],[4,5,6],[7,8,9],[10])\n\ncut(a,9);\n// output\n([1,2,3,4,5,6,7,8,9],[10])\n\nb = cut(a,2);\nb;\n// output\n([1,2],[3,4],[5,6],[7,8],[9,10])\n\nflatten b;\n// output\n(1,2,3,4,5,6,7,8,9,10)\n\ncut(a, 0 2 7);\n// output\n([1,2],[3,4,5,6,7],[8,9,10])\n\ncut(a, 2 7);\n// output\n([3,4,5,6,7],[8,9,10])\n\nm=matrix(1 5 9, 12 20 23, 25 29 32)\ncut(m,2)\n// output\n\n(#0 #1\n-- --\n1  12\n5  20\n9  23\n,#0\n--\n25\n29\n32\n)\n\ncut(m, 1 2)\n// output\n(#0\n--\n12\n20\n23\n,#0\n--\n25\n29\n32\n)\n```\n\n`cut` 函数在时间数据分析中是一个方便的工具。在下面的例子中，我们用 `cut` 函数计算两个事件发生期间的收入和。\n\n```\nincomes=table(2016.07.31 - 10..1 as date, rand(100,10) as income);\nincomes;\n```\n\n| date       | income |\n| ---------- | ------ |\n| 2016.07.21 | 78     |\n| 2016.07.22 | 61     |\n| 2016.07.23 | 79     |\n| 2016.07.24 | 15     |\n| 2016.07.25 | 78     |\n| 2016.07.26 | 22     |\n| 2016.07.27 | 30     |\n| 2016.07.28 | 81     |\n| 2016.07.29 | 17     |\n| 2016.07.30 | 52     |\n\n```\neventdates = [2016.07.22, 2016.07.25, 2016.07.29];\n\nx = incomes.date.binsrch(eventdates);\nx;\n// output\n[1,4,8]\n\nincomes.date.cut(x);\n// output\n([2016.07.22,2016.07.23,2016.07.24],[2016.07.25,2016.07.26,2016.07.27,2016.07.28],[2016.07.29,2016.07.30])\n\ntable(eventdates as startDate, each(last,incomes.date.cut(x)) as endDate, each(sum,incomes.income.cut(x)) as incomeSum);\n```\n\n| startDate  | endDate    | incomeSum |\n| ---------- | ---------- | --------- |\n| 2016.07.22 | 2016.07.24 | 155       |\n| 2016.07.25 | 2016.07.28 | 211       |\n| 2016.07.29 | 2016.07.30 | 69        |\n"
    },
    "cutPoints": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cutPoints.html",
        "signatures": [
            {
                "full": "cutPoints(X, binNum, [freq])",
                "name": "cutPoints",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "binNum",
                        "name": "binNum"
                    },
                    {
                        "full": "[freq]",
                        "name": "freq",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [cutPoints](https://docs.dolphindb.cn/zh/funcs/c/cutPoints.html)\n\n\n\n#### 语法\n\ncutPoints(X, binNum, \\[freq])\n\n#### 参数\n\n**X** 是一个向量。\n\n**binNum** 是产生桶的数量。\n\n**freq** 是与 *X* 等长的向量。它是 *X* 中每个元素的频率。它是一个可选参数，如果指定了 *freq*，*X* 中的所有元素必须是唯一的，并且按升序存储。\n\n#### 详情\n\n返回具有（*binNum*+1）个元素的向量，这样 *X* 中的数据均匀地分布 *binNum* 个桶中。每个桶由向量中相邻的两个元素决定，只包含下边界不包含上边界。\n\n`cutPoints` 可以用于获取 RANGE 分区数据库的分区方案。\n\n#### 例子\n\n```\ncutPoints(2 3 1 4, 2);\n// output\n[1,3,5]\n\ncutPoints(1 2 3 4, 2, 1 1 1 3);\n// output\n[1,4,5]\n```\n"
    },
    "condValueAtRisk": {
        "url": "https://docs.dolphindb.cn/zh/funcs/c/cvar.html",
        "signatures": [
            {
                "full": "condValueAtRisk(returns, method, [confidenceLevel=0.95])",
                "name": "condValueAtRisk",
                "parameters": [
                    {
                        "full": "returns",
                        "name": "returns"
                    },
                    {
                        "full": "method",
                        "name": "method"
                    },
                    {
                        "full": "[confidenceLevel=0.95]",
                        "name": "confidenceLevel",
                        "optional": true,
                        "default": "0.95"
                    }
                ]
            }
        ],
        "markdown": "### [condValueAtRisk](https://docs.dolphindb.cn/zh/funcs/c/cvar.html)\n\n\n\n#### 语法\n\ncondValueAtRisk(returns, method, \\[confidenceLevel=0.95])\n\n#### 详情\n\n条件风险指标（Conditional Value at Risk；也可称 Expected Shortfall），用于计算超过风控指标的损失的平均值。该函数将返回其绝对值，为 DOUBLE 类型。如果没有收益率低于 VaR 的值，则返回 VaR 的值。\n\n#### 参数\n\n**returns** 数值型向量，表示收益率序列。注意，表示收益率的每个元素都应大于 -1 且不能为空。\n\n**method** 字符串类型，表示计算 VaR 的方法，可选值为：\n\n* 'normal' 正态参数法。\n\n* 'logNormal' 对数正态参数法。\n\n* 'historical' 历史模拟法。\n\n* 'monteCarlo' 蒙特卡洛模拟法，使用正态分布进行模拟。\n\n**confidenceLevel** 数值型标量，表示置信水平，合法值域为(0,1)，默认值为 0.95。\n\n#### 例子\n\n本例中给定一个假设的收益率序列，通过历史模拟法，计算置信水平为 0.9 的条件风险指标。\n\n```\nreturns = [0.0, -0.0023816107391389394, -0.0028351258634076834, 0.00789570628538656, 0.0022056267475062397, -0.004515475812603498, 0.0031189325339843646, 0.010774648811452205, 0.0030816164453268957, 0.02172541561228001, 0.011106185767699728, -0.005369098699244845, -0.0096490689793588, 0.0025152212699484314, 0.017822140037111668, -0.02837536728283525, 0.018373545076599204, -0.0026401111537113003, 0.019524374522517898, -0.010800546314337627, 0.014073362622486131, -0.00398277532382243, 0.008398647051501285, 0.0024056749358184904, 0.007093080335863512, -0.005332549248384733, -0.008471915938733665, -0.0038788486165083342, -0.01308504169086584, 0.00350496242864784, 0.009036118926745962, 0.0013358223875250545, 0.0036426642608267563, 0.003974568474545581, -0.003944066366522669, -0.011969668605022311, 0.015116930499066374, 0.006931427295653037, -0.0032650627551519267, 0.003407880132851648]\ncondValueAtRisk(returns, 'historical', 0.9);\n//output:0.016057655973\n```\n\n**相关函数**：[valueAtRisk](https://docs.dolphindb.cn/zh/funcs/v/var_0.html)\n"
    },
    "dailyAlignedBar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dailyAlignedBar.html",
        "signatures": [
            {
                "full": "dailyAlignedBar(X, timeOffset, n, [timeEnd], [mergeSessionEnd=false])",
                "name": "dailyAlignedBar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "timeOffset",
                        "name": "timeOffset"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    },
                    {
                        "full": "[timeEnd]",
                        "name": "timeEnd",
                        "optional": true
                    },
                    {
                        "full": "[mergeSessionEnd=false]",
                        "name": "mergeSessionEnd",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [dailyAlignedBar](https://docs.dolphindb.cn/zh/funcs/d/dailyAlignedBar.html)\n\n\n\n#### 语法\n\ndailyAlignedBar(X, timeOffset, n, \\[timeEnd], \\[mergeSessionEnd=false])\n\n相关函数：[bar](https://docs.dolphindb.cn/zh/funcs/b/bar.html)\n\n#### 参数\n\n**X** 时间类型向量，支持以下的类型：SECOND, TIME, NANOTIME, DATETIME, TIMESTAMP 或 NANOTIMESTAMP。\n\n**timeOffset** 标量或向量，表示每个时段的起始时刻。与 *X* 精度一致，可以是 SECOND、TIME 或 NANOTIME 类型的标量或向量。如果 *timeOffset* 是一个向量，它必须是递增的。\n\n**n** 是一个正整数或 DURATION 类型数据，表示时间区间长度。 *n* 取正整数时，其单位为 *timeOffset* 的最小精度。 *n* 取 DURATION 类型数据时，其单位不能是 y, M, w, d, B。\n\n**timeEnd** 可选参数，表示每个时段的结束时刻。和 timeOffset 的类型和长度必须一致。\n\n**mergeSessionEnd** 为可选参数，是一个布尔值，表示若某个时段的最后时刻为某个区间的起始时刻，是否将其并入之前的区间。默认值为 false。\n\n#### 详情\n\n按照给定的起始时刻 *timeOffset* （与结束时刻 *timeEnd* ）以及时间区间长度（由 *n* 指定），划分时间区间，返回 *X* 中每个元素所属的时间区间起始时刻，结果为与 *X* 长度相同的向量。具体而言，对于 *X* 中的每个元素，计算 X-((X-timeOffset)%n)。\n\n时间区间一般包括左边界，不包括右边界。但若指定 *mergeSessionEnd* = true，且某个时段的最后时刻为某个区间的起始时刻，则将其并入之前的区间。\n\n该函数支持隔夜时段。\n\n#### 例子\n\n以下例子中均使用了随机模拟数据。结果中的 price 列之值每次执行均会有所不同。\n\n例1. 中国股票市场每天有两个交易时段：上午9:30-11:30和下午1:00-3:00。计算每个交易时段中的60分钟均价。\n\n```\nsessionsBegin = 09:30:00 13:00:00\nts = 2019.11.01T09:30:00..2019.11.01T11:30:00 join 2019.11.01T13:00:00..2019.11.01T15:00:00\nt = table(ts, rand(10.0, size(ts)) as price);\n\nselect avg(price) as price, count(*) as count from t group by dailyAlignedBar(ts, sessionsBegin, 60*60) as k60;\n```\n\n| k60                 | price             | count |\n| ------------------- | ----------------- | ----- |\n| 2019.11.01T09:30:00 | 5.031685383252463 | 3600  |\n| 2019.11.01T10:30:00 | 5.022667285786399 | 3600  |\n| 2019.11.01T11:30:00 | 4.930270051117987 | 1     |\n| 2019.11.01T13:00:00 | 4.931854071494632 | 3600  |\n| 2019.11.01T14:00:00 | 4.979529541734115 | 3600  |\n| 2019.11.01T15:00:00 | 0.961996954865754 | 1     |\n\n由于每个区间包括左边界，不包括右边界，若每个交易时段的结束时刻（上午11:30与下午3:00）恰好是区间边界，若不指定 *timeEnd* 与 *mergeSessionEnd*，则时段的结束时刻会单独作为一区间，如上例所示。多数情况下，会希望此类结束时刻归入前一区间。可参照以下脚本。\n\n```\nsessionsEnd = 11:30:00 15:00:00;\nselect avg(price) as price, count(*) as count from t group by dailyAlignedBar(ts, sessionsBegin, 60*60, sessionsEnd, true) as k60;\n```\n\n| k60                 | price             | count |\n| ------------------- | ----------------- | ----- |\n| 2019.11.01T09:30:00 | 5.031685383252463 | 3600  |\n| 2019.11.01T10:30:00 | 5.022641627015316 | 3601  |\n| 2019.11.01T13:00:00 | 4.931854071494632 | 3600  |\n| 2019.11.01T14:00:00 | 4.978413870368697 | 3601  |\n\n例2. 隔夜时段。期货市场每天有两个交易时段：下午1:30-4:30和晚上10:30-凌晨2:30。使用 `dailyAlignedBar` 函数计算每个交易时段中的7分钟均价。\n\n```\nsessions = 13:30:00 22:30:00\nts = 2019.11.01T13:30:00..2019.11.01T16:30:00 join 2019.11.01T22:30:00..2019.11.02T02:30:00\nts = ts join (ts+60*60*24)\nt = table(ts, rand(10.0, size(ts)) as price)\nselect avg(price) as price, count(*) as count from t group by dailyAlignedBar(ts, sessions, 7m) as k7;\n```\n\n例3. 计算分钟 k 线时，*n* 需要转换为 NANOTIMESTAMP，此时若使用整型计算可能造成类型溢出，需要将数据类型转换成 LONG。\n\n```\nn = 1000000\nnano=(09:30:00.000000000 + rand(long(6.5*60*60*1000000000), n)).sort!()\nsessionStartNano=09:30:00.000000000\nprice = 100+cumsum(rand(0.02, n)-0.01)\nvolume = rand(1000, n)\nsymbol = rand(`600519`000001`600000`601766, n)\ntradeNano=table(symbol, nano, price, volume).sortBy!(`symbol`nano)\nundef(`nano`price`volume`symbol)\nbarMinutes=7\nitv = barMinutes*60*long(1000000000)\n\nOHLC_nano=select first(price) as open, max(price) as high, min(price) as low, last(price) as close, sum(volume) as volume from tradeNano group by symbol, dailyAlignedBar(nano, sessionStartNano, itv) as barStart\n\n```\n"
    },
    "database": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/database.html",
        "signatures": [
            {
                "full": "database(directory, [partitionType], [partitionScheme], [locations], [engine='OLAP'], [atomic='TRANS'])",
                "name": "database",
                "parameters": [
                    {
                        "full": "directory",
                        "name": "directory"
                    },
                    {
                        "full": "[partitionType]",
                        "name": "partitionType",
                        "optional": true
                    },
                    {
                        "full": "[partitionScheme]",
                        "name": "partitionScheme",
                        "optional": true
                    },
                    {
                        "full": "[locations]",
                        "name": "locations",
                        "optional": true
                    },
                    {
                        "full": "[engine='OLAP']",
                        "name": "engine",
                        "optional": true,
                        "default": "'OLAP'"
                    },
                    {
                        "full": "[atomic='TRANS']",
                        "name": "atomic",
                        "optional": true,
                        "default": "'TRANS'"
                    }
                ]
            },
            {
                "full": "database(directory, [partitionType], [partitionScheme], [locations], [engine='OLAP'], [atomic='TRANS'], [chunkGranularity='TABLE'])",
                "name": "database",
                "parameters": [
                    {
                        "full": "directory",
                        "name": "directory"
                    },
                    {
                        "full": "[partitionType]",
                        "name": "partitionType",
                        "optional": true
                    },
                    {
                        "full": "[partitionScheme]",
                        "name": "partitionScheme",
                        "optional": true
                    },
                    {
                        "full": "[locations]",
                        "name": "locations",
                        "optional": true
                    },
                    {
                        "full": "[engine='OLAP']",
                        "name": "engine",
                        "optional": true,
                        "default": "'OLAP'"
                    },
                    {
                        "full": "[atomic='TRANS']",
                        "name": "atomic",
                        "optional": true,
                        "default": "'TRANS'"
                    },
                    {
                        "full": "[chunkGranularity='TABLE']",
                        "name": "chunkGranularity",
                        "optional": true,
                        "default": "'TABLE'"
                    }
                ]
            }
        ],
        "markdown": "### [database](https://docs.dolphindb.cn/zh/funcs/d/database.html)\n\n\n\n#### 语法\n\ndatabase(directory, \\[partitionType], \\[partitionScheme], \\[locations], \\[engine='OLAP'], \\[atomic='TRANS'])\n\n2.00.4 版本以后，若配置项 *enableChunkGranularityConfig* = true:\n\ndatabase(directory, \\[partitionType], \\[partitionScheme], \\[locations], \\[engine='OLAP'], \\[atomic='TRANS'], \\[chunkGranularity='TABLE'])\n\n#### 参数\n\n**directory** 是保存数据库的目录的路径。如果需要创建分布式文件系统中的数据库，*directory* 应该以 \"dfs\\://\" 开头，如果需要创建内存在线事务处理数据库，应该以 \"oltp\\://\" 开头。\n\n**partitionType** 有六种类型：顺序分区（SEQ），范围分区（RANGE），哈希分区（HASH），数值分区（VALUE），列表分区（LIST）和组合分区（COMPO）。\n\n**partitionScheme** 描述了分区是如何创建的。它通常是一个向量，在序列域是一个整型标量。分区方案的说明决定了分区类型。*partitionScheme* 支持以下数据类型：CHAR, SHORT, INT, DATE, MONTH, TIME, MINUTE, SECOND, DATETIME 和 SYMBOL。\n\n| 分区类型 | 分区符号  | 分区方案                                      |\n| ---- | ----- | ----------------------------------------- |\n| 顺序分区 | SEQ   | 整型标量。表示分区的数量。                             |\n| 范围分区 | RANGE | 向量。向量的任意两个相邻元素定义分区的范围。                    |\n| 哈希分区 | HASH  | 元组。第一个元素是分区列的数据类型，第二个元素是分区的数量。            |\n| 值分区  | VALUE | 向量。向量的每个元素定义了一个分区。                        |\n| 列表分区 | LIST  | 向量。向量的每个元素定义了一个分区。                        |\n| 组合分区 | COMPO | 向量。向量的每个元素是一个数据库句柄。向量长度表示分区的层级，最小是2，最大是3。 |\n\n**locations** 是元组，指定分区的位置。元组中元素的数量应该与 *partitionType* 和 *partitionScheme* 共同决定的分区数量相同。若要在多个节点上保存分区时， 可以使用分布式文件系统或使用 *locations* 参数指定每个分区在哪些节点。如果没有指定 *locations* 参数，所有分区属于当前节点。我们不能指定分层域的分区。\n\n**engine = 'OLAP'** 设置数据库存储引擎。取值为：'OLAP' , 'TSDB', 'IMOLTP'或'PKEY'，默认值为 'OLAP'。关于存储引擎的介绍，请参见[数据库](https://docs.dolphindb.cn/zh/db_distr_comp/cfg/db_intro.html)。\n\n**Note:** TSDB和 PKEY引擎只支持创建分布式数据库。\n\n**atomic** 表示写入事务的原子性层级，决定了是否允许并发写入同一分区。可选值为 'TRANS' 和 'CHUNK'，默认值为 'TRANS'。\n\n* 设置为 'TRANS'，写入事务的原子性层级为事务，即一个事务写入多个分区时，若某个分区被其他写入事务锁定而出现写入冲突，则该事务的写入全部失败。因此，该设置下，不允许并发写入同一个分区。\n\n* 设置为 'CHUNK'，写入事务的原子性层级为分区。若一个事务写入多个分区时，某分区被其它写入事务锁定而出现冲突，系统会完成其他分区的写入，同时对之前发生冲突的分区不断尝试写入，尝试数分钟后仍冲突才放弃。此设置下，允许并发写入同一个分区，但由于不能完全保证事务的原子性，可能出现部分分区写入成功而部分分区写入失败的情况。同时由于采用了重试机制，写入速度可能较慢。\n\n**chunkGranularity** 是一个字符串，用于指定分区的粒度。可选值为：\n\n* 'TABLE'：表级分区，设置后支持同时写入同一分区的不同表。\n\n* 'DATABASE'：数据库级分区，设置后只支持同时写入不同分区。\n\n该参数只有在配置 *enableChunkGranularityConfig* = true 时启用。\n\n#### 详情\n\n创建一个数据库句柄。\n\n我们需要指定 *partitionType* 和 *partitionScheme* 创建新的分布式数据库。当我们重新打开已有的分布式数据库，只需要指定 *directory*。我们不能用不同的 *partitionType* 或 *partitionScheme* 覆盖已有的分布式数据库。\n\n当 *directory* 为本地磁盘路径时，将创建本地磁盘数据库。磁盘数据库仅应用于备份数据和本地计算的场景，其相较于分布式表，在使用上具有一定局限，例如不能进行权限控制等。\n\n#### 例子\n\n1.创建没有分区的磁盘数据库。\n\n```\ndb=database(directory=\"C:/DolphinDB/Data/db1/\");\nt=table(take(1..10,10000000) as id, rand(10,10000000) as x, rand(10.0,10000000) as y);\nsaveTable(db, t, `t1);\n```\n\n2.对于分布式数据库，每种类型的分区都有一个例子。\n\n* 顺序分区（SEQ）：分区是基于输入数据文件中行的顺序。它只能在本地文件系统中使用，不能在分布式文件系统中使用。\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x);\nsaveText(t, \"C:/DolphinDB/Data/t.txt\");\n\ndb = database(directory=\"C:/DolphinDB/Data/seqdb\", partitionType=SEQ, partitionScheme=8)\npt = loadTextEx(db, `pt, ,\"C:/DolphinDB/Data/t.txt\");\n```\n\n在 `\"C:/DolphinDB/data/seqdb\"` 文件夹中，有8个新建的子文件夹。每个对应输入数据文件中的分区。如果输入数据文件比计算机的可用内存大，我们可以把数据载入分区。\n\n![](https://docs.dolphindb.cn/zh/images/database01.png)\n\n* 范围分区（RANGE）：分区是由分区方案中的两个元素决定的。范围包含下限不包含上限。\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x);\ndb=database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 5 10)\npt = db.createPartitionedTable(t, `pt, `ID);\npt.append!(t);\n\npt=loadTable(db,`pt)\nx=select * from pt\nselect count(x) from pt;\n```\n\n| count\\_x |\n| -------- |\n| 1000000  |\n\n在上述例子中，数据库 db 有两个分区：\\[0,5)和\\[5,10)。表 t 在数据库 db 中保存为以 ID 为分区列的分区表 pt。\n\n![](https://docs.dolphindb.cn/zh/images/database02.png)\n\n把数据文件输入为范围域的分布式数据库：\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x);\nsaveText(t, \"C:/DolphinDB/Data/t.txt\");\n\ndb=database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 5 10)\npt = loadTextEx(db, `pt, `ID, \"C:/DolphinDB/Data/t.txt\");\n```\n\n* 哈希分区（HASH）：我们需要指定分区列的数据类型和分区数量。\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x)\ndb=database(directory=\"dfs://hashdb\", partitionType=HASH, partitionScheme=[INT, 2])\n\npt = db.createPartitionedTable(t, `pt, `ID)\npt.append!(t);\n\nselect count(x) from pt;\n```\n\n| count\\_x |\n| -------- |\n| 1000000  |\n\n上面的例子中，数据库 db 有两个分区。表 t 被保存为以 ID 为分区列的分区表 pt。\n\n注意：如果导入哈希分区数据库的数据的分区列包含空值，则该条数据会被丢弃。\n\n```\nID = NULL 3 6 NULL 9\nx = rand(1.0, 5)\nt1 = table(ID, x)\npt.append!(t1)\nselect count(x) from pt;\n```\n\n| count\\_x |\n| -------- |\n| 1000003  |\n\n* 数值分区（VALUE）：分区方案中的每个元素决定一个分区。\n\n```\nn=1000000\nmonth=take(2000.01M..2016.12M, n);\nx=rand(1.0, n);\nt=table(month, x);\n\ndb=database(directory=\"dfs://valuedb\", partitionType=VALUE, partitionScheme=2000.01M..2016.12M)\npt = db.createPartitionedTable(t, `pt, `month);\npt.append!(t);\n\npt=loadTable(db,`pt)\nselect count(x) from pt;\n```\n\n| count\\_x |\n| -------- |\n| 1000000  |\n\n上述例子定义了一个具有204个分区的数据库。每个分区表示从2000年1月到2016年12月的月份。使用 `createPartitionedTable` 和 `append!` 函数，把表 t 保存为数据库 db 中以 month 作为分区列的分区表 pt。\n\n![](https://docs.dolphindb.cn/zh/images/database03.png)\n\n* 列表分区（LIST）：分区方案的每个元素决定分区。\n\n```\nn=1000000\nticker = rand(`MSFT`GOOG`FB`ORCL`IBM,n);\nx=rand(1.0, n);\nt=table(ticker, x);\n\ndb=database(directory=\"dfs://listdb\", partitionType=LIST, partitionScheme=[`IBM`ORCL`MSFT, `GOOG`FB])\npt = db.createPartitionedTable(t, `pt, `ticker)\npt.append!(t);\n\npt=loadTable(db,`pt)\nselect count(x) from pt;\n```\n\n| count\\_x |\n| -------- |\n| 1000000  |\n\n上述例子中的数据库有两个分区。第一个分区有3支股票，第二个分区有2支股票。\n\n![](https://docs.dolphindb.cn/zh/images/database04.png)\n\n* 组合分区（COMPO）：可以有2个或3个分区列。每个分区列可以是按范围分区、值分区、哈希分区或列表分区。分区列的顺序是无关的。\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndbDate = database(, partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\ndbID = database(, partitionType=RANGE, partitionScheme=0 50 100)\ndb = database(directory=\"dfs://compoDB\", partitionType=COMPO, partitionScheme=[dbDate, dbID])\n\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t)\n\npt=loadTable(db,`pt)\nselect count(x) from pt;\n```\n\n| count\\_x |\n| -------- |\n| 1000000  |\n\n数值域根据天数分成5个分区：\n\n![](https://docs.dolphindb.cn/zh/images/database05.png)\n\n范围域有2个分区：\n\n![](https://docs.dolphindb.cn/zh/images/database06.png)\n\n请注意，虽然这里的数据库文件有两级文件夹，但是分层域只有一个层次的分区。与之对比，双重分区具有两个层次分区。\n\n3.创建分布式数据库\n\n我们可以根据上述例子的语法，在分布式文件系统中建立分布式数据库。唯一区别是，在 `database` 函数中，*directory* 参数要以 \"dfs\\://\" 开头。\n\n在执行下面例子之前，我们需要在 web 界面上启动 DFS 集群，并且提交数据节点的脚本。\n\n在分布式文件系统中保存分层域的分区表：\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x);\n\ndbDate = database(, partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\ndbID=database(, partitionType=RANGE, partitionScheme=0 50 100);\ndb = database(directory=\"dfs://compoDB\", partitionType=COMPO, partitionScheme=[dbDate, dbID]);\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n```\n\n我们可以在以下目录查看数据库文件：\n\n![](https://docs.dolphindb.cn/zh/images/database07.png)\n\nDFS\\_NODE1 只有4个关于日期的文件夹；在 \"20170807\" 文件夹中只有一个 ID 文件夹。这是因为有4个数据节点和基于日期和 ID 的2\\*5=10个分区。默认情况下，每个分区在分布式文件系统中有3个备份。因此，总共有5\\*2\\*3=30个分区来保存4个数据节点。不是所有数据节点都有10个分区。\n\n在分布式文件系统中把数据文件输入到范围域的分布式数据库中：\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x);\nsaveText(t, \"C:/DolphinDB/Data/t.txt\");\n\ndb=database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 5 10)\npt = loadTextEx(db, `pt, `ID, \"C:/DolphinDB/Data/t.txt\");\n```\n\n4.关于 *locations* 参数的例子：\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x);\n\ndb=database(directory=\"dfs://rangedb5\", partitionType=RANGE, partitionScheme=0 5 10, locations=[`node1`node2, `node3])\npt = db.createPartitionedTable(t, `pt, `ID);\npt.append!(t);\n```\n\n上述例子定义了具有两个分区的数值域。第一个分区在 node1 和 node2 上，第二个分区在 node3 上。所有的位置必须在这些节点所在的计算机中的 dolphindb.cfg 文件的 sites 参数定义：\n\n```\nsites=111.222.3.4:8080:node1, 111.222.3.5:8080:node2, 111.222.3.6:8080:node3\n```\n\nsites 中的参数是用逗号分隔的。每个 site 包含3部分：主机名，端口号和别名。分区可以复制多个 sites。在这个例子中，每个节点位于不同的计算机。\n\n我们也可以直接使用主机名和端口号表示位置。函数将会变成：\n\n```\ndb=database(directory=\"dfs://rangedb6\", partitionType=RANGE, partitionScheme=0 5 10, locations=[[\"111.222.3.4:8080\", \"111.222.3.5:8080\"], \"111.222.3.6:8080\"])\n```\n\n5. 关于 *atomic* 参数的例子：\n\n```\nif(existsDatabase(\"dfs://test\"))\ndropDB(\"dfs://test\")\ndb = database(directory=\"dfs://test\", partitionType=VALUE, partitionScheme=1..20, atomic='CHUNK')\ndummy = table(take(1..20, 100000) as id, rand(1.0, 100000) as value)\npt = db.createPartitionedTable(dummy, \"pt\", `id)\n\ndummy1 = table(take(1..15, 1000000) as id, rand(1.0, 1000000) as value)\ndummy2 = table(take(11..20, 1000000) as id, rand(1.0, 1000000) as value)\nsubmitJob(\"write1\", \"writer1\", append!{pt, dummy1})\nsubmitJob(\"write2\", \"writer2\", append!{pt, dummy2})\nsubmitJob(\"write3\", \"writer3\", append!{pt, dummy1})\nsubmitJob(\"write4\", \"writer4\", append!{pt, dummy2})\nselect count(*) from pt\n// output\n4,000,000\n```\n\n创建 IMOLTP 数据库\n\n```\ndbName = \"oltp://test_imoltp\"\ndb = database(directory=dbName, partitionType=VALUE, partitionScheme=1..100, engine=\"IMOLTP\")\n```\n"
    },
    "date": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/date.html",
        "signatures": [
            {
                "full": "date(X)",
                "name": "date",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [date](https://docs.dolphindb.cn/zh/funcs/d/date.html)\n\n\n\n#### 语法\n\ndate(X)\n\n#### 详情\n\n返回对应的日期。返回值的类型是 DATE，一个时间值。如果参数 *X* 不是日期，则返回值是 1970.01.01 + *X* 天的日期。\n\n#### 参数\n\n**X** 可以是时间标量、向量或整数。\n\n#### 例子\n\n```\ndate();\n```\n\n返回：null\n\n```\ndate(1)\n```\n\n返回：1970.01.02\n\n```\ndate(`2011.10.12);\n```\n\n返回：2011.10.12\n\n```\ndate(now());\n```\n\n返回：2024.02.22\n\n```\ndate 2012.12.03 01:22:01;\n```\n\n返回：2012.12.03\n\n```\ndate(2016.03M);\n```\n\n返回：2016.03.01\n\n**Related information**\n\n[second](https://docs.dolphindb.cn/zh/funcs/s/second.html)\n\n[minute](https://docs.dolphindb.cn/zh/funcs/m/minute.html)\n\n[month](https://docs.dolphindb.cn/zh/funcs/m/month.html)\n\n[hour](https://docs.dolphindb.cn/zh/funcs/h/hour.html)\n\n[year](https://docs.dolphindb.cn/zh/funcs/y/year.html)\n"
    },
    "datehour": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/datehour.html",
        "signatures": [
            {
                "full": "datehour(X)",
                "name": "datehour",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [datehour](https://docs.dolphindb.cn/zh/funcs/d/datehour.html)\n\n\n\n#### 语法\n\ndatehour(X)\n\n#### 详情\n\n把时间类型的标量或向量转换为 DATEHOUR 类型。返回日期和精确到小时的时间值。\n\n**Note:**\n\n自 2.00.12 版本起，支持转换 MONTH 类型的数据。\n\n#### 参数\n\n**X** 是一个包含日期和小时信息的时间类型标量或向量。如果参数 *X* 中未包含前述时间类型标量或向量，则返回值是 1970.01.01 + *X* 小时的日期与小时的时间表达。\n\n#### 例子\n\n```\ndatehour(1)\n```\n\n返回：1970.01.01T01\n\n```\ndatehour(2012.06.13 13:30:10);\n```\n\n返回：2012.06.13T13\n\n```\ndatehour([2012.06.15 15:32:10.158,2012.06.15 17:30:10.008]);\n```\n\n返回：\\[2012.06.15T15,2012.06.15T17]\n\n```\ndatehour(2012.01M)\n```\n\n返回：2012.01.01T00\n"
    },
    "datetime": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/datetime.html",
        "signatures": [
            {
                "full": "datetime(X)",
                "name": "datetime",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [datetime](https://docs.dolphindb.cn/zh/funcs/d/datetime.html)\n\n\n\n#### 语法\n\ndatetime(X)\n\n#### 详情\n\n返回日期和精确到秒的时间值。返回值的类型是 DATETIME，一个时间值。如果参数 *X* 中未包含前述时间类型标量或向量，则返回值是 1970.01.01 + *X* 秒的日期与时间。\n\n**Note:**\n\nDATETIME 类型的可用时间范围是 \\[1901.12.13T20:45:53, 2038.01.19T03:14:07]。\n\n自 2.00.12 版本起，支持转换 MONTH 类型的数据。\n\n#### 参数\n\n**X** 可以是时间标量或向量，或整数。\n\n#### 例子\n\n```\ndatetime(1)\n```\n\n返回：1970.01.01 00:00:01\n\n```\ndatetime(2009.11.10);\n```\n\n返回：2009.11.10 00:00:00\n\n```\ntypestr datetime(2009.11.10);\n```\n\n返回：DATETIME\n\n```\ndatetime(now());\n```\n\n返回：2024.02.22 15:55:39\n\n```\ndatetime(2012.01M)\n```\n\n返回：2012.01.01T00:00:00\n\n**Related information**\n\n[date](https://docs.dolphindb.cn/zh/funcs/d/date.html)\n\n[second](https://docs.dolphindb.cn/zh/funcs/s/second.html)\n\n[minute](https://docs.dolphindb.cn/zh/funcs/m/minute.html)\n\n[month](https://docs.dolphindb.cn/zh/funcs/m/month.html)\n\n[hour](https://docs.dolphindb.cn/zh/funcs/h/hour.html)\n\n[year](https://docs.dolphindb.cn/zh/funcs/y/year.html)\n"
    },
    "datetimeParse": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/datetimeParse.html",
        "signatures": [
            {
                "full": "temporalParse(X, format)",
                "name": "temporalParse",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "format",
                        "name": "format"
                    }
                ]
            }
        ],
        "markdown": "### [datetimeParse](https://docs.dolphindb.cn/zh/funcs/d/datetimeParse.html)\n\n是 [temporalParse](https://docs.dolphindb.cn/zh/funcs/t/temporalParse.html) 的别名。\n\n\n以下是 `temporalParse` 函数的文档：\n### [temporalParse](https://docs.dolphindb.cn/zh/funcs/t/temporalParse.html)\n\n\n\n#### 语法\n\ntemporalParse(X, format)\n\n别名：datetimeParse\n\n#### 参数\n\n**X** 是一个字符串。\n\n**format** 是表示时间序列对象格式的字符串。\n\n#### 详情\n\n把字符串转换成 DolphinDB 中的时序类型数据。如果系统不能识别时序格式，将返回 NULL。\n\nDolphinDB 具有以下时序格式：\n\n| 格式        | 含义       | 范围                                          |\n| --------- | -------- | ------------------------------------------- |\n| yyyy      | 年份（4个数字） | 1000-9999                                   |\n| yy        | 年份（2个数字） | 00-99. (00-39: 2000-2039; 40-99: 1940-1999) |\n| MM        | 月份       | 1月12日                                       |\n| MMM       | 月份       | JAN, FEB, ... DEC （不区分大小写）                  |\n| dd        | 日期       | 1月31日                                       |\n| HH        | 时（24小时制） | 0-23                                        |\n| hh        | 时（12小时制） | 0-11                                        |\n| mm        | 分钟       | 0-59                                        |\n| ss        | 秒        | 0-59                                        |\n| aa        | 上午/下午    | AM, PM. （不区分大小写）                            |\n| SSS       | 毫秒       | 0-999                                       |\n| nnnnnn    | 微秒       | 0-999999                                    |\n| nnnnnnnnn | 纳秒       | 0-999999999                                 |\n\n`temporalParse` 函数中的 *format* 参数有以下两种表示方式：\n\n* 使用分隔符\n\n  对于 *format* 参数 ，除了 y, M, d, H, h, m, s, a, S, n 以外的符号的字符都可以作为分隔符。*format* 参数中的分隔符需要与输入字符串中的分隔符一致。\n\n  ```\n  temporalParse(\"14-02-2018\",\"dd-MM-yyyy\");\n  // output\n  2018.02.14\n\n  temporalParse(\"14-02-2018\",\"dd/MM/yyyy\");\n  // output\n  00d\n\n  temporalParse(\"14//02//2018\",\"dd//MM//yyyy\");\n  // output\n  2018.02.14\n\n  temporalParse(\"14//02//2018\",\"dd/MM/yyyy\");\n  // output\n  00d\n\n  temporalParse(\"14//02//2018\",\"dd..MM..yyyy\");\n  // output\n  00d\n  ```\n\n  我们可以使用单个字母来简化格式。例如，使用 \"y/M/d\" 代替 \"yyyy/MM/dd\"。因为 \"y\" 可以表示 \"yyyy\" 和 \"yy\", 系统会根据数字的个数采用 \"yyyy\" 或 \"yy\"。\n\n  ```\n  temporalParse(\"14-02-18\",\"d-M-y\");\n  // output\n  2018.02.14\n\n  temporalParse(\"2018/2/6 02:33:01 PM\",\"y/M/d h:m:s a\");\n  // output\n  2018.02.06T14:33:01\n  ```\n\n  \"MMM\",\"SSS\", \"nnnnnn\" , \"nnnnnnnnn\" 不能使用单个字母。\n\n  ```\n  temporalParse(\"02-FEB-2018\",\"d-MMM-y\");\n  // output\n  2018.02.02\n\n  temporalParse(\"02-FEB-2018\",\"d-M-y\");\n  // output\n  00d\n\n  temporalParse(\"13:30:10.001\",\"H:m:s.SSS\");\n  // output\n  13:30:10.001\n\n  temporalParse(\"13:30:10.001\",\"H:m:s.S\");\n  // output\n  Invalid temporal format: 'H:m:s.S'. Millisecond (S) must have three digits.\n\n  temporalParse(\"13:30:10.008001\",\"H:m:s.nnnnnn\");\n  // output\n  13:30:10.008001000\n\n  temporalParse(\"13:30:10.008001\",\"H:m:s.n\");\n  // output\n  Invalid temporal format: 'H:m:s.n'. Nanosecond (n) must have six or nine digits.\n  ```\n\n  `temporalParse` 函数解释输入字符串中数字个数的方式是非常灵活的。\n\n  ```\n  temporalParse(\"2-4-18\",\"d-M-y\");\n  // output\n  2018.04.02\n\n  temporalParse(\"2-19-6\",\"H-m-s\");\n  // output\n  02:19:06\n\n  temporalParse(\"002-019-006\",\"H-m-s\");\n  // output\n  02:19:06\n  ```\n\n  对于毫秒，微秒和纳秒，对应的数字位个数必须是3, 6, 9。\n\n  ```\n  temporalParse(\"2018/2/6 13:30:10.001\",\"y/M/d H:m:s.SSS\");\n  // output\n  2018.02.06T13:30:10.001\n\n  temporalParse(\"2018/2/6 13:30:10.01\",\"y/M/d H:m:s.SSS\");\n  // output\n  00T\n\n  temporalParse(\"2018/2/6 13:30:10.000001\",\"y/M/d H:m:s.nnnnnn\");\n  // output\n  2018.02.06T13:30:10.000001000\n\n  temporalParse(\"2018/2/6 13:30:10.0000010\",\"y/M/d H:m:s.nnnnnn\");\n  // output\n  00N\n  ```\n\n* 不使用分隔符\n\n  对于这种表示方式，*format* 参数必须与上述表格中的格式对应，不能使用单个字母来表示格式。\n\n  ```\n  temporalParse(\"20180214\",\"yyyyMMdd\");\n  // output\n  2018.02.14\n\n  temporalParse(\"122506\",\"MMddyy\");\n  // output\n  2006.12.25\n\n  temporalParse(\"155950\",\"HHmmss\");\n  // output\n  15:59:50\n\n  temporalParse(\"035901PM\",\"hhmmssaa\");\n  // output\n  15:59:01\n\n  temporalParse(\"02062018155956001000001\",\"MMddyyyyHHmmssnnnnnnnnn\");\n  // output\n  2018.02.06T15:59:56.001000001\n  ```\n"
    },
    "dayOfMonth": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html",
        "signatures": [
            {
                "full": "dayOfMonth(X)",
                "name": "dayOfMonth",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [dayOfMonth](https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html)\n\n\n\n#### 语法\n\ndayOfMonth(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n计算 *X* 在当月的第几天。\n\n#### 例子\n\n```\ndayOfMonth(2011.01.01);\n// output\n1\n\ndayOfMonth([2012.06.12T12:30:00,2012.07.28T12:35:00]);\n// output\n[12,28]\n```\n\n相关函数：[dayOfYear](https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html), [quarterOfYear](https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.cn/zh/funcs/m/millisecond.html), [microsecond](https://docs.dolphindb.cn/zh/funcs/m/microsecond.html), [nanosecond](https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html)\n"
    },
    "dayOfWeek": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dayOfWeek.html",
        "signatures": [
            {
                "full": "dayOfWeek(X)",
                "name": "dayOfWeek",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [dayOfWeek](https://docs.dolphindb.cn/zh/funcs/d/dayOfWeek.html)\n\n\n\n#### 语法\n\ndayOfWeek(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n计算 *X* 是一个星期中的第几天。返回的结果是0到6之间的整数，0表示星期一，1表示星期二，...，6表示星期日。\n\n#### 例子\n\n```\ndayOfWeek(2012.12.05);\n// output\n2\n\ndayOfWeek 2013.05.23T12:00:00;\n// output\n3\n\ndayOfWeek(2014.01.11T23:04:28.113);\n// output\n5\n\ndayOfWeek(2012.12.05 2012.12.06 2013.01.05);\n// output\n[2,3,4]\n```\n"
    },
    "dayOfYear": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html",
        "signatures": [
            {
                "full": "dayOfYear(X)",
                "name": "dayOfYear",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [dayOfYear](https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html)\n\n\n\n#### 语法\n\ndayOfYear(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n计算 *X* 是当年中的第几天。返回的结果是整型。\n\n#### 例子\n\n```\ndayOfYear(2011.01.01);\n// output\n1\n\ndayOfYear([2011.12.31,2012.12.31]);\n// output\n[365,366]\n\ndayOfYear([2012.06.12T12:30:00,2012.07.12T12:35:00]);\n// output\n[164,194]\n```\n\n相关函数：[dayOfMonth](https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.cn/zh/funcs/m/millisecond.html), [microsecond](https://docs.dolphindb.cn/zh/funcs/m/microsecond.html), [nanosecond](https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html)\n"
    },
    "daysInMonth": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/daysInMonth.html",
        "signatures": [
            {
                "full": "daysInMonth(X)",
                "name": "daysInMonth",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [daysInMonth](https://docs.dolphindb.cn/zh/funcs/d/daysInMonth.html)\n\n\n\n#### 语法\n\ndaysInMonth(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n返回 *X* 所在月份的天数。\n\n#### 例子\n\n```\ndaysInMonth(2012.06.12T12:30:00);\n// output\n30\n\ndaysInMonth([2012.02.01,2013.12.05]);\n// output\n[29,31]\n```\n"
    },
    "decimal128": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/decimal128.html",
        "signatures": [
            {
                "full": "decimal128(X, scale)",
                "name": "decimal128",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    }
                ]
            }
        ],
        "markdown": "### [decimal128](https://docs.dolphindb.cn/zh/funcs/d/decimal128.html)\n\n\n\n#### 语法\n\ndecimal128(X, scale)\n\n#### 详情\n\n将输入的数据类型转换为 DECIMAL128 类型。\n\n#### 参数\n\n**X** 整型/浮点型/字符串类型标量或向量。\n\n**scale** 整型标量，表示保留的小数位数。\n\n#### 例子\n\n```\na=decimal128(142, 2)\na\n```\n\n返回：142.00\n\n```\nb=decimal128(1\\7, 6)\nb\n```\n\n返回：0.142857\n\n```\na+b\n```\n\n返回：142.142857\n\n```\na*b\n```\n\n返回：20.28569400\n\n```\ndecimal128(\"3.1415926535\", 4)\n```\n\n返回：3.1416\n\n一个 DECIMAL 类型向量里的所有元素的类型和 scale 必须相同，例如：\n\n```\nd1=[1.23$DECIMAL128(4), 3$DECIMAL128(4), 3.14$DECIMAL128(4)]; \n```\n\n返回：\\[1.2300,3.0000,3.1400]\n\n```\ntypestr(d1);\n```\n\n返回：FAST DECIMAL128 VECTOR\n\n如果元素的 scale 不同，则会创建并输出元组：\n\n```\nd2=[1.23$DECIMAL128(4), 3$DECIMAL128(4), 3.14$DECIMAL128(3)];\n```\n\n返回：(1.2300,3.0000,3.140)\n\n```\ntypestr(d2);\n```\n\n返回：ANY VECTOR\n"
    },
    "decimal32": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/decimal32.html",
        "signatures": [
            {
                "full": "decimal32(X, scale)",
                "name": "decimal32",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    }
                ]
            }
        ],
        "markdown": "### [decimal32](https://docs.dolphindb.cn/zh/funcs/d/decimal32.html)\n\n\n\n#### 语法\n\ndecimal32(X, scale)\n\n#### 详情\n\n将输入的数据类型转换为 DECIMAL32 类型。\n\n#### 参数\n\n**X** 整型/浮点型/字符串类型标量或向量。\n\n**scale** 整型标量，表示保留的小数位数。\n\n#### 例子\n\n```\na=decimal32(142, 2)\na\n```\n\n返回：142.00\n\n```\nb=decimal32(1\\7, 6)\nb\n```\n\n返回：0.142857\n\n```\na+b\n```\n\n返回：142.142857\n\n```\na*b\n```\n\n返回：20.28569400\n\n```\ndecimal32(\"3.1415926535\", 4)\n```\n\n返回：3.1415\n\n一个 DECIMAL 类型向量里的所有元素的类型和 scale 必须相同，例如：\n\n```\nd1=[1.23$DECIMAL32(4), 3$DECIMAL32(4), 3.14$DECIMAL32(4)];\n```\n\n返回：\\[1.2300,3.0000,3.1400]\n\n```\ntypestr(d1);\n```\n\n返回：FAST DECIMAL32 VECTOR\n\n```\nd2=[1.23$DECIMAL32(4), 3$DECIMAL32(4), 3.14$DECIMAL32(3)];\n```\n\n返回：(1.2300,3.0000,3.140)\n\n```\ntypestr(d2);\n```\n\n返回：ANY VECTOR\n\n将 STRING 或 SYMBOL 类型转换为 DECIMAL 类型时，不同版本服务器的处理方式存在差别。2.00.10 之前版本会将超出 *scale* 的小数部分直接舍去。而 2.00.10 及之后的版本，会将超出 *scale* 的小数部分进行四舍五入。例如，对于以下的转换：\n\n```\nsymbol([\"1.341\", \"4.5677\"])$DECIMAL32(2)\n```\n\n2.00.10 之前的版本，结果为：\\[1.34,4.56]\n\n2.00.10 及之后的版本，结果为：\\[1.34,4.57]\n"
    },
    "decimal64": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/decimal64.html",
        "signatures": [
            {
                "full": "decimal64(X, scale)",
                "name": "decimal64",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    }
                ]
            }
        ],
        "markdown": "### [decimal64](https://docs.dolphindb.cn/zh/funcs/d/decimal64.html)\n\n\n\n#### 语法\n\ndecimal64(X, scale)\n\n#### 详情\n\n将输入的数据类型转换为 DECIMAL64 类型。\n\n#### 参数\n\n**X** 整型/浮点型/字符串类型标量或向量。\n\n**scale** 整型标量，表示保留的小数位数。\n\n#### 例子\n\n```\na=decimal64(142, 2)\na\n```\n\n返回：142.00\n\n```\nb=decimal64(1\\7, 6)\nb\n```\n\n返回：0.142857\n\n```\na+b\n```\n\n返回：142.142857\n\n```\na*b\n```\n\n返回：20.28569400\n\n```\ndecimal64(\"3.1415926535\", 4)\n```\n\n返回：3.1415\n\n一个 DECIMAL 类型向量里的所有元素的类型和 scale 必须相同，例如：\n\n```\nd1=[1.23$DECIMAL64(4), 3$DECIMAL64(4), 3.14$DECIMAL64(4)];\n```\n\n返回：\\[1.2300,3.0000,3.1400]\n\n```\ntypestr(d1);\n```\n\n返回：FAST DECIMAL64 VECTOR\n\n如果元素的 scale 不同，则会创建并输出元组：\n\n```\nd2=[1.23$DECIMAL64(4), 3$DECIMAL64(4), 3.14$DECIMAL64(3)];\n```\n\n返回：(1.2300,3.0000,3.140)\n\n```\ntypestr(d2);\n```\n\n返回：ANY VECTOR\n\n将 STRING 或 SYMBOL 类型转换为 DECIMAL 类型时，不同版本服务器的处理方式存在差别。2.00.10 之前版本会将超出 *scale* 的小数部分直接舍去。而 2.00.10 及之后的版本，会将超出 *scale* 的小数部分进行四舍五入。例如，对于以下的转换：\n\n```\nsymbol([\"1.341\", \"4.5677\"])$DECIMAL64(2)\n```\n\n2.00.10 之前的版本，结果为：\\[1.34,4.56]\n\n2.00.10 及之后的版本，结果为：\\[1.34,4.57]\n"
    },
    "decimalFormat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/decimalFormat.html",
        "signatures": [
            {
                "full": "decimalFormat(X, format)",
                "name": "decimalFormat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "format",
                        "name": "format"
                    }
                ]
            }
        ],
        "markdown": "### [decimalFormat](https://docs.dolphindb.cn/zh/funcs/d/decimalFormat.html)\n\n\n\n#### 语法\n\ndecimalFormat(X, format)\n\n#### 参数\n\n**X** 可以是整型或浮点型的标量或向量。\n\n**format** 是表示格式的字符串。\n\n#### 详情\n\n把数字转换成指定格式的字符串。\n\n| 标志 | 含义         | 备注  |\n| -- | ---------- | --- |\n| 0  | 强制数字位数     | 备注1 |\n| #  | 可选数字位数     | 备注2 |\n| .  | 小数点        |     |\n| %  | 百分号        | 备注3 |\n| E  | 科学计数法的符号   | 备注4 |\n| ,  | 分隔符        | 备注5 |\n| ;  | 表示正数和负数的符号 | 备注6 |\n\n* 备注1：小数点之前0的个数表示整数部分的位数。与之对比，小数点之后0的个数表示小数部分的位数。\n\n  ```\n  decimalFormat(123,\"0\");\n  // output: 123\n\n  decimalFormat(123,\"00000\");\n  // output: 00123\n\n  decimalFormat(123.45,\"0\");\n  // output: 123\n\n  decimalFormat(123.45,\"0.0\");\n  // output: 123.5\n\n  decimalFormat(123.45,\"0.000\");\n  // output: 123.450\n\n  decimalFormat(123.45, \".0\");\n  // output: 123.5\n\n  decimalFormat(0.45, \".0\");\n  // output: .5\n  ```\n\n* 备注2：如果0与#同时在小数点后使用，0必须在#前面。\n\n  ```\n  decimalFormat(123.45,\"0.#\");\n  // output: 123.5\n\n  decimalFormat(123.45,\"0.###\");\n  // output: 123.45\n\n  decimalFormat(123.456,\"0.000###\");\n  // output: 123.456\n\n  decimalFormat(123.456789110,\"0.000###\");\n  // output: 123.456789\n\n  decimalFormat(0.345, \".##\");\n  // output: .35\n  ```\n\n* 备注3：%用于格式字符串的结尾。%和 E 在一个格式字符串中不能同时出现。\n\n  ```\n  decimalFormat(0.125,\"0.00%\");\n  // output: 12.50%\n\n  decimalFormat(0.125, \"#.##%\");\n  // output: 12.5%\n\n  decimalFormat(0.12567,\"#.##%\");\n  // output: 12.57%\n  ```\n\n* 备注4：E 后面只能紧跟0，并且至少紧跟一个0。\n\n  ```\n  decimalFormat(1234567.89,\"0.##E00\");\n  // output: 1.23E06\n\n  decimalFormat(0.0000000000123456789,\"0.000E0\");\n  // output: 1.235E-11\n  ```\n\n* 备注5：分隔符在一个格式字符串中只能出现一次。分隔符与小数点之间的位数或分隔符到结尾的位数即为分隔的间距。\n\n  ```\n  decimalFormat(123456789,\"#,###\");\n  // output: 123,456,789\n\n  decimalFormat(123456789.166,\"#,###.##\");\n  // output: 123,456,789.17\n\n  decimalFormat(123456789.166,\"0,000.00\");\n  // output: 123,456,789.17\n  ```\n\n* 备注6：我们可以使用\";\"来选择数字对象的正负。\n\n  ```\n  decimalFormat(123.456,\"0.00#E00;(0.00#E00)\");\n  // output: 1.235E02\n\n  decimalFormat(-123.456,\"0.00#E00;(0.00#E00)\");\n  // output: (1.235E02)\n  ```\n"
    },
    "decimalMultiply": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/decimalMultiply.html",
        "signatures": [
            {
                "full": "decimalMultiply(X, Y, scale)",
                "name": "decimalMultiply",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    }
                ]
            }
        ],
        "markdown": "### [decimalMultiply](https://docs.dolphindb.cn/zh/funcs/d/decimalMultiply.html)\n\n\n\n#### 语法\n\ndecimalMultiply(X, Y, scale)\n\n#### 参数\n\n**X / Y** 标量或向量，其中至少有一个必须为 DECIMAL 类型。\n\n**scale** 非负整型标量，表示计算结果保留的小数位数。\n\n#### 详情\n\nDECIMAL 类型的乘法运算，相较于 `mul` 函数或运算符 \\*，该函数可以指定计算结果保留的小数位数。\n\n**Note:**\n\n* 在以下情况下，*scale* 参数将会失效，返回值类型为 DECIMAL：\n\n  * 只有一个参数是 DECIMAL 类型（小数位数是 S），且指定的 *scale* 值不等于 S。\n\n  * X 和 Y 都是 DECIMAL 类型（小数位数分别是 S1 和 S2），且指定的 *scale* 值小于 min(S1, S2) 或大于 S1+S2。\n\n* 当其中一个参数是浮点数时，scale 参数将会失效，并且返回值类型为 DOUBLE。\n\n当 *scale* 参数失效时，该函数的计算结果等同于 X \\* Y。\n\n#### 返回值\n\nDECIMAL 或 DOUBLE 类型。\n\n#### 例子\n\n```\na = decimal32(`1.235, 3);\nb = decimal32(`7.5689, 4);\nc=decimalMultiply(a, b, 5)\n// output\n9.34759\n\ntypestr(c)\n// output\nDECIMAL32\n\ndecimalMultiply(a, b, 2)   // scale 小于min(3,4)，函数结果等于 a*b\n// output\n9.3475915\n\nb=float(`7.5689)\nc=decimalMultiply(a, b, 5)   // b 是浮点数， 函数结果等于 a*b，且数据类型是 DOUBLE。\n// output\n9.3475916337\n\ntypestr(c)\n// output\nDOUBLE\n```\n\n乘法运算（\\*）和 decimalMultiply 的计算结果如果溢出，会自动转换为更高精度的类型。如果无法进行转换，则会抛出异常。\n\n```\nx = decimal32(1\\7, 8)\ny = decimal32(1\\6, 8)\nz = x * y\nz\n// output\n0.0238095223809524\ntypestr z\n// output\nDECIMAL64\n\nz = decimalMultiply(x, y, 8)\nz\n// output\n0.02380952\ntypestr z\n// output\nDECIMAL64\n\nx = decimal128(1\\7, 35)\ny = decimal128(1\\6, 35)\nx*y\n// output\nx * y => Scale out of bound (valid range: [0, 38], but get: 70)\n\ndecimalMultiply(x, y, 35)\n// output\ndecimalMultiply(x, y, 35) => Decimal math overflow\n```\n\n*X* 和 *Y* 中至少有一个是向量。\n\n```\n\nx = [decimal32(3.213312, 3), decimal32(3.1435332, 3), decimal32(3.54321, 3)]\ny = 2.1\ndecimalMultiply(x, y, 5)\n// output\n[6.7473,6.6003,7.440300000000001]\n\nx = [decimal32(3.213312, 3), decimal32(3.1435332, 3), decimal32(3.54321, 3)]\ny = [decimal64(4.312412, 3), decimal64(4.53231, 3), decimal64(4.31258, 3)]\ndecimalMultiply(x, y, 5)\n// output\n[13.85445,14.24407,15.27741]\n```\n"
    },
    "decodeShortGenomeSeq": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/decodeShortGenomeSeq.html",
        "signatures": [
            {
                "full": "decodeShortGenomeSeq(X)",
                "name": "decodeShortGenomeSeq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [decodeShortGenomeSeq](https://docs.dolphindb.cn/zh/funcs/d/decodeShortGenomeSeq.html)\n\n\n\n#### 语法\n\ndecodeShortGenomeSeq(X)\n\n别名：decodeSGS\n\n#### 参数\n\n**X** 整型标量或向量。\n\n#### 详情\n\n将经过 `encodeShortGenomeSeq` 编码的整型数字解码为一个 DNA 序列。\n\n#### 返回值\n\n字符串（STRING）或字符串向量（STRING VECTOR）\n\n#### 例子\n\n```\na=encodeShortGenomeSeq(\"TCGATCG\")\ndecodeShortGenomeSeq(a)\n// output\n\"TCGATCG\"\n    \nb=encodeShortGenomeSeq(\"TCGATCG\" \"TCGATCGCCC\")\ndecodeShortGenomeSeq(b)\n// output\n[\"TCGATCG\",\"TCGATCGCCC\"]\n    \n// 当输入为空时，返回空字符串。\ndecodeShortGenomeSeq(int(NULL))\n// output\n\"\"\n    \n// 因\"TCGATCG\"重复5次后，长度超过了28，所以返回了空的整型向量，再通过 decodeSGS 解码时，会返回为空字符。\nc=encodeShortGenomeSeq(repeat(\"TCGATCG\" \"TCGAT\", 5))\ndecodeShortGenomeSeq(c)\n// output\n[,\"TCGATTCGATTCGATTCGATTCGAT\"]     \n```\n\n相关函数：[encodeShortGenomeSeq](https://docs.dolphindb.cn/zh/funcs/e/encodeShortGenomeSeq.html), [genShortGenomeSeq](https://docs.dolphindb.cn/zh/funcs/g/genShortGenomeSeq.html)\n"
    },
    "decompress": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/decompress.html",
        "signatures": [
            {
                "full": "decompress(X)",
                "name": "decompress",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [decompress](https://docs.dolphindb.cn/zh/funcs/d/decompress.html)\n\n\n\n#### 语法\n\ndecompress(X)\n\n#### 参数\n\n**X** 是一个压缩后的向量。\n\n#### 详情\n\n对一个压缩后的向量进行解压缩。\n\n#### 例子\n\n```\nx=1..100000000\ny=compress(x, \"delta\");\n\ny.typestr();\n// output: HUGE COMPRESSED VECTOR\n\nz=decompress(y);\nz.size();\n// output: 100000000\n```\n\n相关函数：[compress](https://docs.dolphindb.cn/zh/funcs/c/compress.html)\n"
    },
    "defined": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/defined.html",
        "signatures": [
            {
                "full": "defined(names, [type=VAR])",
                "name": "defined",
                "parameters": [
                    {
                        "full": "names",
                        "name": "names"
                    },
                    {
                        "full": "[type=VAR]",
                        "name": "type",
                        "optional": true,
                        "default": "VAR"
                    }
                ]
            }
        ],
        "markdown": "### [defined](https://docs.dolphindb.cn/zh/funcs/d/defined.html)\n\n\n\n#### 语法\n\ndefined(names, \\[type=VAR])\n\n#### 参数\n\n**names** 可以是字符串标量或向量，表示对象名。\n\n**type** 可为 VAR（本地变量），SHARED（共享变量）或 DEF（函数定义）。默认值为 VAR。\n\n#### 详情\n\n返回一个标量/向量，表示 *names* 中的每个元素是否已被定义。\n\n#### 例子\n\n```\nx=10\ny=20\ndef f(a){return a+1}\nshare table(1..3 as x, 4..6 as y) as t1;\n\ndefined([\"x\",\"y\",\"f\",`t1]);\n// output\n[1,1,0,0]\n\ndefined([\"x\",\"y\",\"f\",`t1], DEF);\n// output\n[0,0,1,0]\n\ndefined([\"x\",\"y\",\"f\",`t1], SHARED);\n// output\n[0,0,0,1]\n```\n"
    },
    "defs": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/defs.html",
        "signatures": [
            {
                "full": "defs([X])",
                "name": "defs",
                "parameters": [
                    {
                        "full": "[X]",
                        "name": "X",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [defs](https://docs.dolphindb.cn/zh/funcs/d/defs.html)\n\n\n\n#### 语法\n\ndefs(\\[X])\n\n#### 参数\n\n**X** 是字符串。它支持通配符\"%\"和\"?\"。\"%\"表示0，1或多个字符，“?”表示1个字符。\n\n#### 详情\n\n如果没有指定参数，将以表格的形式返回系统的所有函数。\n\n如果指定了 *X*，将以 *X* 的格式返回所有函数的名称。\n\n#### 例子\n\n```\ndefs();\n```\n\n| name    | isCommand | userDefined | minParamCount | maxParamCount | syntax      |\n| ------- | --------- | ----------- | ------------- | ------------- | ----------- |\n| !=\\_2   | 0         | 0           | 2             | 2             | (X, Y)      |\n| !\\_1    | 0         | 0           | 1             | 1             | (X)         |\n| $\\_2    | 0         | 0           | 2             | 2             | (obj, type) |\n| %\\_2    | 0         | 0           | 2             | 2             | (X, Y)      |\n| &&\\_2   | 0         | 0           | 2             | 2             | (X, Y)      |\n| &\\_2    | 0         | 0           | 2             | 2             | (X, Y)      |\n| \\*\\*\\_2 | 0         | 0           | 2             | 2             | (X, Y)      |\n| \\*\\_2   | 0         | 0           | 2             | 2             | (X, Y)      |\n| +\\_2    | 0         | 0           | 2             | 2             | (X, Y)      |\n| -\\_1    | 0         | 0           | 1             | 1             | (X)         |\n| ...     |           |             |               |               |             |\n\n```\ntypestr defs();\n// output\nIN-MEMORY TABLE;\n\nselect * from defs() where name like \"bit%\";\n```\n\n| name   | isCommand | userDefined | minParamCount | maxParamCount | syntax |\n| ------ | --------- | ----------- | ------------- | ------------- | ------ |\n| bitAnd | 0         | 0           | 2             | 2             | (X, Y) |\n| bitNot | 0         | 0           | 1             | 1             | (X)    |\n| bitOr  | 0         | 0           | 2             | 2             | (X, Y) |\n| bitXor | 0         | 0           | 2             | 2             | (X, Y) |\n\n```\ndefs(\"bit%\");\n```\n\n| name   | isCommand | userDefined | minParamCount | maxParamCount | syntax |\n| ------ | --------- | ----------- | ------------- | ------------- | ------ |\n| bitAnd | 0         | 0           | 2             | 2             | (X, Y) |\n| bitNot | 0         | 0           | 1             | 1             | (X)    |\n| bitOr  | 0         | 0           | 2             | 2             | (X, Y) |\n| bitXor | 0         | 0           | 2             | 2             | (X, Y) |\n\n```\ndefs(\"%sin\");\n```\n\n| name | isCommand | userDefined | minParamCount | maxParamCount | syntax |\n| ---- | --------- | ----------- | ------------- | ------------- | ------ |\n| asin | 0         | 0           | 1             | 1             | (X)    |\n| sin  | 0         | 0           | 1             | 1             | (X)    |\n\n```\ndefs(\"?sin\");\n```\n\n| name | isCommand | userDefined | minParamCount | maxParamCount | syntax |\n| ---- | --------- | ----------- | ------------- | ------------- | ------ |\n| asin | 0         | 0           | 1             | 1             | (X)    |\n"
    },
    "deg2rad": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/deg2rad.html",
        "signatures": [
            {
                "full": "deg2rad(X)",
                "name": "deg2rad",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [deg2rad](https://docs.dolphindb.cn/zh/funcs/d/deg2rad.html)\n\n\n\n#### 语法\n\ndeg2rad(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n将角的单位从度转换成弧度。\n\n#### 例子\n\n```\ndeg2rad 45 90 180 360;\n// output\n[0.785398,1.570796,3.141593,6.283185]\n```\n\n相关函数：[rad2deg](https://docs.dolphindb.cn/zh/funcs/r/rad2deg.html)\n"
    },
    "deleteChunkMetaOnMasterById": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/deletechunkmetaonmasterbyid.html",
        "signatures": [
            {
                "full": "deleteChunkMetaOnMasterById(chunkPath, chunkId)",
                "name": "deleteChunkMetaOnMasterById",
                "parameters": [
                    {
                        "full": "chunkPath",
                        "name": "chunkPath"
                    },
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    }
                ]
            }
        ],
        "markdown": "### [deleteChunkMetaOnMasterById](https://docs.dolphindb.cn/zh/funcs/d/deletechunkmetaonmasterbyid.html)\n\n\n\n#### 语法\n\ndeleteChunkMetaOnMasterById(chunkPath, chunkId)\n\n#### 参数\n\n**chunkPath** 一个字符串，表示需要删除的 chunk 的路径。\n\n**chunkId** 一个字符串，表示需要删除的 chunk 的 ID。\n\n#### 详情\n\n根据 chunk 的路径和 ID，删除控制节点上该 chunk 的元数据。\n\n该函数只能由 admin 在控制节点执行。\n\n#### 例子\n\n```\ndeleteChunkMetaOnMasterById(chunkPath=\"/olap_value/8/40o\", chunkId=\"11d45d2d-a995-7c97-c041-32362f3400d7\")\n```\n"
    },
    "deleteGroup": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/deleteGroup.html",
        "signatures": [
            {
                "full": "deleteGroup(groupName)",
                "name": "deleteGroup",
                "parameters": [
                    {
                        "full": "groupName",
                        "name": "groupName"
                    }
                ]
            }
        ],
        "markdown": "### [deleteGroup](https://docs.dolphindb.cn/zh/funcs/d/deleteGroup.html)\n\n\n\n#### 语法\n\ndeleteGroup(groupName)\n\n#### 参数\n\n**groupName** 是表示群组名称的字符串。\n\n#### 详情\n\n删除一个群组。这可能会影响群组内所有成员的权限。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n```\ndeleteGroup(`Production);\n```\n\n**Related information**\n\n[deleteGroupMember](https://docs.dolphindb.cn/zh/funcs/d/deleteGroupMember.html)\n\n[deleteUser](https://docs.dolphindb.cn/zh/funcs/d/deleteUser.html)\n"
    },
    "deleteGroupMember": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/deleteGroupMember.html",
        "signatures": [
            {
                "full": "deleteGroupMember(userIds, groupIds)",
                "name": "deleteGroupMember",
                "parameters": [
                    {
                        "full": "userIds",
                        "name": "userIds"
                    },
                    {
                        "full": "groupIds",
                        "name": "groupIds"
                    }
                ]
            }
        ],
        "markdown": "### [deleteGroupMember](https://docs.dolphindb.cn/zh/funcs/d/deleteGroupMember.html)\n\n\n\n#### 语法\n\ndeleteGroupMember(userIds, groupIds)\n\n#### 参数\n\n**userIds** 是表示用户名称的字符串标量或向量。\n\n**groupIds** 是表示群组名称的字符串标量或向量。\n\n*userIds* 和 *groupIds* 不能同时为向量。\n\n#### 详情\n\n删除多个组中的同一个成员，或删除同一个组中的多个成员。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n```\ndeleteGroupMember(`AlexEdwards`ElizabethRoberts, `production);\n```\n\n**Related information**\n\n[deleteGroup](https://docs.dolphindb.cn/zh/funcs/d/deleteGroup.html)\n\n[deleteUser](https://docs.dolphindb.cn/zh/funcs/d/deleteUser.html)\n"
    },
    "deleteReplicas": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/deleteReplicas.html",
        "signatures": [
            {
                "full": "deleteReplicas(chunkId, nodeAlias)",
                "name": "deleteReplicas",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    },
                    {
                        "full": "nodeAlias",
                        "name": "nodeAlias"
                    }
                ]
            }
        ],
        "markdown": "### [deleteReplicas](https://docs.dolphindb.cn/zh/funcs/d/deleteReplicas.html)\n\n\n\n#### 语法\n\ndeleteReplicas(chunkId, nodeAlias)\n\n#### 参数\n\n**chunkId** 是字符串标量或向量，表示 chunk 的 ID。\n\n**nodeAlias** 是一个字符串，表示节点的别名。\n\n#### 详情\n\n把节点上的一个或多个 chunk 的副本删除。该命令只能由管理员在控制节点上执行。\n\n#### 例子\n\n删除 “node1” 上所有 chunk 的副本。\n\n```\nchunkIds=exec chunkId from pnodeRun(getChunksMeta) where node=\"node1\"\ndeleteReplicas(chunkIds,\"node1\");\n```\n"
    },
    "deleteRule": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/deleteRule.html",
        "signatures": [
            {
                "full": "deleteRule(engineName, key)",
                "name": "deleteRule",
                "parameters": [
                    {
                        "full": "engineName",
                        "name": "engineName"
                    },
                    {
                        "full": "key",
                        "name": "key"
                    }
                ]
            }
        ],
        "markdown": "### [deleteRule](https://docs.dolphindb.cn/zh/funcs/d/deleteRule.html)\n\n#### 语法\n\ndeleteRule(engineName, key)\n\n#### 详情\n\n如果该引擎规则中存在指定的规则 *key* 则删除，删除成功返回 true；否则，返回 false。\n\n**Note:** 默认规则不可删除。\n\n#### 参数\n\n**engineName** 是一个字符串，表示引擎名。\n\n**key** 是 STRING 或 INT 类型的标量，表示要删除的规则对应的 key 。\n\n#### 例子\n\n```\nx = [1, 2, NULL]\ny = [ [ < value>1 > ], [ < price<2 >, < price>6 > ], [ < value*price>10 > ] ]\nruleSets = dict(x, y)\nnames = `sym`value`price`quantity\ntypes = [INT, DOUBLE, DOUBLE, DOUBLE]\ndummy = table(10:0, names, types)\noutputNames = `sym`value`price`rule\noutputTypes = [INT, DOUBLE, DOUBLE, BOOL[]]\noutputTable = table(10:0, outputNames, outputTypes)\ntest = createRuleEngine(name=\"ruleEngineTest\", ruleSets=ruleSets, dummyTable=dummy, outputColumns=[\"sym\",\"value\",\"price\"], outputTable=outputTable, policy=\"all\", ruleSetColumn=\"sym\")\n\n// 删除规则前\ntest.append!(table(1 as sym, 6 as value, 1 as price, 8 as quantity))\n\n// 删除 sym=1 的规则，sym=1会使用默认规则\ndeleteRule(\"ruleEngineTest\",1)\ntest.append!(table(1 as sym, 6 as value, 1 as price, 8 as quantity))\n```\n\n此时的输出表 outputTable 内容如下\n\n| sym | value | price |   rule   |\n| :-: | :---: | :---: | :------: |\n|  1  |   6   |   1   |  \\[true] |\n|  1  |   6   |   1   | \\[false] |\n\n\n\n**Related information**\n\n[updateRule](https://docs.dolphindb.cn/zh/funcs/u/updateRule.html)\n\n[createRuleEngine](https://docs.dolphindb.cn/zh/funcs/c/createRuleEngine.html)\n"
    },
    "deleteScheduledJob": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/deleteScheduledJob.html",
        "signatures": [
            {
                "full": "deleteScheduledJob(jobId)",
                "name": "deleteScheduledJob",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    }
                ]
            }
        ],
        "markdown": "### [deleteScheduledJob](https://docs.dolphindb.cn/zh/funcs/d/deleteScheduledJob.html)\n\n\n\n#### 语法\n\ndeleteScheduledJob(jobId)\n\n#### 参数\n\n**jobId** 是一个表示定时任务 ID 的字符串。\n\n#### 详情\n\n删除一个定时任务。如果指定的任务 ID 不存在，则抛出异常。\n\n#### 例子\n\n```\ndeleteScheduledJob(`dailyJob1);\n```\n"
    },
    "deleteUser": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/deleteUser.html",
        "signatures": [
            {
                "full": "deleteUser(userId)",
                "name": "deleteUser",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    }
                ]
            }
        ],
        "markdown": "### [deleteUser](https://docs.dolphindb.cn/zh/funcs/d/deleteUser.html)\n\n\n\n#### 语法\n\ndeleteUser(userId)\n\n#### 参数\n\n**userId** 是表示用户名的字符串。\n\n#### 详情\n\n删除一个用户。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n```\ndeleteUser(`JohnSmith);\n```\n\n**Related information**\n\n[deleteGroup](https://docs.dolphindb.cn/zh/funcs/d/deleteGroup.html)\n\n[deleteGroupMember](https://docs.dolphindb.cn/zh/funcs/d/deleteGroupMember.html)\n"
    },
    "deltas": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/deltas.html",
        "signatures": [
            {
                "full": "deltas(X,[n])",
                "name": "deltas",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[n]",
                        "name": "n",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [deltas](https://docs.dolphindb.cn/zh/funcs/d/deltas.html)\n\n\n\n#### 语法\n\ndeltas(X,\\[n])\n\n#### 参数\n\n**X** 是一个向量、矩阵或表。\n\n**n** 可选参数，一个整数，用于减数相较于被减数的索引偏移。默认是1。\n\n#### 详情\n\n对于 *X* 中的每一个元素，计算 *X*i-*X*i-n，NULL 值不参与计算。\n\n* 若 *X* 是向量，返回一个包含 *X* 中两个元素之差的向量。\n\n* 若 *X* 是矩阵，在每列内进行上述计算，返回一个与 *X* 维度相同的矩阵。\n\n* 若 *X* 是表，在每列内进行上述计算，返回一个与 *X* 行数与列数都相同的表。\n\n#### 例子\n\n```\nx=7 4 5 8 9;\ndeltas(x);\n//output: [,-3,1,3,1]\n//等价于 [, 4-7, 5-4, 8-5, 9-8]\n\nx=NULL 1 2 NULL 3;\ndeltas(x);\n//output： [,,1,,]\n\nm=matrix(1 3 2 5 6, 0 8 NULL 7 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 0  |\n| 3  | 8  |\n| 2  |    |\n| 5  | 7  |\n| 6  | 6  |\n\n```\ndeltas(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n| 2  | 8  |\n| -1 |    |\n| 3  |    |\n| 1  | -1 |\n\n*n* 是正整数时：\n\n```\ndeltas(m,2)\n```\n\n| 0 | 1  |\n| - | -- |\n|   |    |\n|   |    |\n| 1 |    |\n| 2 | -1 |\n| 4 |    |\n\n*n* 为负整数时：\n\n```\ndeltas(m,-2)\n```\n\n| 0  | 1 |\n| -- | - |\n| -1 |   |\n| -2 | 1 |\n| -4 |   |\n|    |   |\n|    |   |\n"
    },
    "dema": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dema.html",
        "signatures": [
            {
                "full": "dema(X, window)",
                "name": "dema",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [dema](https://docs.dolphindb.cn/zh/funcs/d/dema.html)\n\n\n\n#### 语法\n\ndema(X, window)\n\nTA-lib 系列函数参数说明和窗口计算规则请参考：[TA-lib 系列](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的双重指数移动平均（Double Exponential Moving Average）。\n\n其计算公式为：\n\n![](https://docs.dolphindb.cn/zh/images/ema1.png)\n\n![](https://docs.dolphindb.cn/zh/images/dema.png)\n\n#### 例子\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\ndema(x,3);\n// output\n[,,,,12.091666666666668,11.689583333333335,11.266666666666665]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\ndema(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n| 12.0917 | 20.9444 |\n| 11.6896 | 14.6806 |\n| 11.2667 | 10.9444 |\n\n相关函数：[ema](https://docs.dolphindb.cn/zh/funcs/e/ema.html), [tema](https://docs.dolphindb.cn/zh/funcs/t/tema.html)\n"
    },
    "demean": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/demean.html",
        "signatures": [
            {
                "full": "demean(X)",
                "name": "demean",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [demean](https://docs.dolphindb.cn/zh/funcs/d/demean.html)\n\n\n\n#### 语法\n\ndemean(X)\n\n#### 参数\n\n**X** 数值型标量、向量、矩阵或表。\n\n#### 详情\n\n对一组数据进行去均值化（零均值化）操作，空值不参与计算，返回一个和 *X* 维度相同的 DOUBLE 类型对象。\n\n* 若 *X* 为向量，计算 X - avg(X)；\n\n* 若 *X* 为矩阵，则在矩阵每一列进行计算；\n\n* 若 *X* 为表，则只对数值列进行计算。\n\n#### 例子\n\n```\nx = 1 NULL 2 3\ndemean(x)\n```\n\n输出返回：\\[-1,,0,1]\n\n```\nv = 1 0 1 1 8 2 -4 0\ndemean(v)\n```\n\n输出返回：\\[-0.125,-1.125,-0.125,-0.125,6.875,0.875,-5.125,-1.125]\n"
    },
    "denseRank": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/denseRank.html",
        "signatures": [
            {
                "full": "denseRank(X, [ascending=true],[ignoreNA=true], [percent=false])",
                "name": "denseRank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [denseRank](https://docs.dolphindb.cn/zh/funcs/d/denseRank.html)\n\n\n\n#### 语法\n\ndenseRank(X, \\[ascending=true],\\[ignoreNA=true], \\[percent=false])\n\n#### 参数\n\n**X** 是一个向量或矩阵。\n\n**ascending** 是一个布尔值，表示是否按升序排序。默认值是 true。\n\n**ignoreNA** 是一个布尔值，表示是否忽略 NULL 值，默认值为 true。true 表示忽略 NULL 值，false 表示 NULL 作为最小值参与排名。\n\n**percent** 是一个布尔值，表示是否以百分比形式显示返回的排名，默认值为 false。\n\n#### 详情\n\n若 *X* 是向量：\n\n* 基于 *ascending* 指定的排序顺序，返回 *X* 中每个元素连续的排名。\n\n* 如果 *ignoreNA* = true，则 NULL 值不参与排序，结果中 NULL 值的排名为空。\n\n若 *X* 是矩阵，在每列内进行上述计算，返回一个与 *X* 维度相同的矩阵。\n\n**Note:** `denseRanke` 和 [rank](https://docs.dolphindb.cn/zh/funcs/r/rank.html) 的区别在于，多个元素相等时，前者采用密集排名方式，而后者采用跳跃排名方式。\n\n#### 例子\n\n```\nx=1 5 5 6 8 8 9\nprint denseRank(x)\n// output\n[0,1,1,2,3,3,4]\n\ny=time(4 1 1 2)\nprint denseRank(y, ascending=false)\n// output\n[0,2,2,1]\nm = matrix(1 2 2 NULL, 0 0 0 1, 0 0 NULL 2)\ndenseRank(m, ignoreNA=false)\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 0  | 1  |\n| 2  | 0  | 1  |\n| 2  | 0  | 0  |\n| 0  | 1  | 2  |\n\n```\nt=table(`A`A`B`C`B`B`A`C`C as id,[4,1,NULL,1,2,4,5,0,-1] as val)\nselect id,val, denseRank(val) from t context by id\n```\n\n| id | val | denseRank\\_val |\n| -- | --- | -------------- |\n| A  | 4   | 1              |\n| A  | 1   | 0              |\n| A  | 5   | 2              |\n| B  |     |                |\n| B  | 2   | 0              |\n| B  | 4   | 1              |\n| C  | 1   | 2              |\n| C  | 0   | 1              |\n| C  | -1  | 0              |\n\n相关函数：[rowDenseRank](https://docs.dolphindb.cn/zh/funcs/r/rowDenseRank.html)\n"
    },
    "deny": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/deny.html",
        "signatures": [
            {
                "full": "deny(userId|groupId, accessType, [objs])",
                "name": "deny",
                "parameters": [
                    {
                        "full": "userId|groupId",
                        "name": "userId|groupId"
                    },
                    {
                        "full": "accessType",
                        "name": "accessType"
                    },
                    {
                        "full": "[objs]",
                        "name": "objs",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [deny](https://docs.dolphindb.cn/zh/funcs/d/deny.html)\n\n\n\n#### 语法\n\ndeny(userId|groupId, accessType, \\[objs])\n\n#### 参数\n\n**userId** | **groupId** 是表示用户名或组名的字符串。\n\n**accessType** 是权限类型。\n\n**objs** 标量或向量，表示权限类型的应用对象。\n\n**Note:** 注：当 *accessType* 指定为 COMPUTE\\_GROUP\\_EXEC 时，*objs* 必须为对应的计算组名，或 \\*（表示所有计算组）。\n\n*accessType* 和 *objs* 的取值请参照 [用户权限管理](https://docs.dolphindb.cn/zh/tutorials/ACL_and_Security.html) 权限类型表。\n\n#### 详情\n\n拒绝某个用户或某个组的权限。管理员可以通过该命令拒绝用户所有权限（*accessType*），但普通用户在拥有相关的 OWNER 权限后，只能通过该命令拒绝以下权限：TABLE\\_READ, TABLE\\_WRITE, TABLE\\_INSERT, TABLE\\_UPDATE, TABLE\\_DELETE, DB\\_READ, DB\\_WRITE, DB\\_INSERT, DB\\_UPDATE, DB\\_DELETE, DBOBJ\\_DELETE, DBOBJ\\_CREATE 和 VIEW\\_EXEC。\n\n**Note:** 该函数可在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n组 \"research\" 中的所有成员都不能向表 dfs\\://db1/t1 中写入数据：\n\n```\ndeny(`research, TABLE_WRITE, \"dfs://db1/t1\")\n```\n\n组 \"research\" 中的所有成员都不能在数据库 dfs\\://db1 和 dfs\\://db2 中创建表：\n\n```\ndeny(\"research\", DBOBJ_CREATE, [\"dfs://db1\",\"dfs://db2\"])\n```\n\n用户 \"AlexSmith\" 不能删除数据库：\n\n```\ndeny(\"AlexSmith\", DB_MANAGE)\n```\n\n用户 \"AlexSmith\" 不能执行脚本：\n\n```\ndeny(\"AlexSmith\", SCRIPT_EXEC)\n```\n\n用户 \"AlexSmith\" 不能测试脚本：\n\n```\ndeny(\"AlexSmith\", TEST_EXEC)\n```\n"
    },
    "derivative": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/derivative.html",
        "signatures": [
            {
                "full": "derivative(func, X, [dx =1.0], [n=1], [order=3])",
                "name": "derivative",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[dx =1.0]",
                        "name": "[dx =1.0]"
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[order=3]",
                        "name": "order",
                        "optional": true,
                        "default": "3"
                    }
                ]
            }
        ],
        "markdown": "### [derivative](https://docs.dolphindb.cn/zh/funcs/d/derivative.html)\n\n\n\n#### 语法\n\nderivative(func, X, \\[dx =1.0], \\[n=1], \\[order=3])\n\n#### 参数\n\n**func** 是一元函数。\n\n**X** 是数值型标量或向量，表示求导位置。\n\n**dx** 是数值型的标量，表示求导间隔。*dx* 默认值是1.0，取值范围为大于0的浮点数。\n\n**n** 是整型的标量，表示导数的阶数。*n* 的默认是1。当前函数仅支持计算1阶导数。\n\n**order** 是整型的标量，表示选取点的数量。*order* 必须是奇数，默认值是3，取值范围为\\[3, 1023]。\n\n#### 详情\n\n返回函数 *func* 在 *X* 位置的 *n* 阶导数值。\n\n#### 例子\n\n```\nderivative(acos, 0.458, 1e-3);\n// output\n-1.12492\n\na=[0.25, -4.53, 1.85, 12.45, 2.0];\nderivative(cbrt, a, 1e-3, 1, 5);\n// output\n[0.83995,0.121753,0.221189,0.062053,0.209987]\n\nderivative(pow{3,}, 5);\n// output\n324\n```\n"
    },
    "det": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/det.html",
        "signatures": [
            {
                "full": "det(X)",
                "name": "det",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [det](https://docs.dolphindb.cn/zh/funcs/d/det.html)\n\n\n\n#### 语法\n\ndet(X)\n\n#### 参数\n\n**X** 是一个矩阵。\n\n#### 详情\n\n返回矩阵 *X* 的行列式（determinant）。在计算中，NULL 值用 0 代替。\n\n#### 例子\n\n```\nx=1..4$2:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\nx.det();\n// output\n-2\n\nx=1 2 3 6 5 4 8 7 0$3:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 6  | 8  |\n| 2  | 5  | 7  |\n| 3  | 4  | 0  |\n\n```\ndet(x);\n// output\n42\n\nx=1 2 3 6 5 4 8 7 NULL $3:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 6  | 8  |\n| 2  | 5  | 7  |\n| 3  | 4  |    |\n\n```\ndet(x);\n// output\n42\n```\n"
    },
    "diag": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/diag.html",
        "signatures": [
            {
                "full": "diag(X)",
                "name": "diag",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [diag](https://docs.dolphindb.cn/zh/funcs/d/diag.html)\n\n\n\n#### 语法\n\ndiag(X)\n\n#### 参数\n\n**X** 是一个向量或方阵。\n\n#### 详情\n\n* 如果 *X* 是一个向量，`diag` 返回一个对角矩阵，*X* 为主对角线上的元素。\n\n* 如果 *X* 是一个方阵，`diag` 返回一个由主对角线元素组成的向量。\n\n#### 例子\n\n```\ndiag(1..5);\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 0  | 0  | 0  | 0  |\n| 0  | 2  | 0  | 0  | 0  |\n| 0  | 0  | 3  | 0  | 0  |\n| 0  | 0  | 0  | 4  | 0  |\n| 0  | 0  | 0  | 0  | 5  |\n\n```\nm=1..4$2:2;\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\ndiag(m);\n\n// output\n[1,4]\n```\n"
    },
    "dict": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dict.html",
        "signatures": [
            {
                "full": "dict(keyObj, valueObj, [ordered=false])",
                "name": "dict",
                "parameters": [
                    {
                        "full": "keyObj",
                        "name": "keyObj"
                    },
                    {
                        "full": "valueObj",
                        "name": "valueObj"
                    },
                    {
                        "full": "[ordered=false]",
                        "name": "ordered",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "dict(keyType, valueType, [ordered=false])",
                "name": "dict",
                "parameters": [
                    {
                        "full": "keyType",
                        "name": "keyType"
                    },
                    {
                        "full": "valueType",
                        "name": "valueType"
                    },
                    {
                        "full": "[ordered=false]",
                        "name": "ordered",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [dict](https://docs.dolphindb.cn/zh/funcs/d/dict.html)\n\n\n\n#### 语法\n\ndict(keyObj, valueObj, \\[ordered=false])\n\n或\n\ndict(keyType, valueType, \\[ordered=false])\n\n#### 参数\n\n对于第一种情形，**keyObj** 是表示键的向量，**valueObj** 是表示值的向量。\n\n对于第二种情形，**keyType** 是字典键的数据类型，**valueType** 是字典值的数据类型。系统支持以下键的数据类型：Literal、Integral（COMPRESS 除外）、Floating 和 Temporal。字典中的值不支持 COMPLEX，POINT 类别。\n\n**ordered** 一个布尔值，默认为 false，表示创建一个无序字典。当 *ordered* = true 时，创建一个有序字典。无序字典在输出或进行遍历时，其键值对不保留输入时的顺序；有序字典在输出或进行遍历时，键值对的顺序与输入顺序保持一致。\n\n#### 详情\n\n返回一个无序字典或有序字典对象。\n\n#### 例子\n\n```\nx=1 6 3\ny=4.5 7.8 4.3\nz=dict(x,y);\nz;\n// output\n3->4.3\n1->4.5\n6->7.8\n\nz=dict(INT,DOUBLE);\nz[5]=7.9;\nz;\n// output\n5->7.9\n\nz[3]=6;\nz;\n// output\n3->6\n5->7.9\n\ndt=dict([`test], [1]);\ndt;\n// output\ntest->1\n\n// 创建有序字典\nz=dict(x,y,true)\nz;\n// output\n1->4.5\n6->7.8\n3->4.3\n\n\n// y 为 DECIMAL32 类型的向量，将 y 作为 value 值创建有序字典 z\nx=1 3 2\ny = decimal32\\(1.23 3 3.14, 3\\)\nz=dict\\(x,y,true\\);\nz;\n// output\n1-&gt;1.230\n3-&gt;3.000\n2-&gt;3.140\n```\n\n获取键和值:\n\n```\nx=1 6 3\ny=4.5 7.8 4.3\nz=dict(x,y);\nz.keys();\n// output\n[3,1,6]\n\nz.values();\n// output\n[4.3,4.5,7.8]\n```\n\n相关函数：[array](https://docs.dolphindb.cn/zh/funcs/a/array.html), [matrix](https://docs.dolphindb.cn/zh/funcs/m/matrix.html)， [dictUpdate!](https://docs.dolphindb.cn/zh/funcs/d/dictUpdate_.html), [syncDict](https://docs.dolphindb.cn/zh/funcs/s/syncDict.html)\n"
    },
    "dictUpdate!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dictUpdate_.html",
        "signatures": [
            {
                "full": "dictUpdate!(dictionary, function, keys, parameters, [initFunc=copy])",
                "name": "dictUpdate!",
                "parameters": [
                    {
                        "full": "dictionary",
                        "name": "dictionary"
                    },
                    {
                        "full": "function",
                        "name": "function"
                    },
                    {
                        "full": "keys",
                        "name": "keys"
                    },
                    {
                        "full": "parameters",
                        "name": "parameters"
                    },
                    {
                        "full": "[initFunc=copy]",
                        "name": "initFunc",
                        "optional": true,
                        "default": "copy"
                    }
                ]
            }
        ],
        "markdown": "### [dictUpdate!](https://docs.dolphindb.cn/zh/funcs/d/dictUpdate_.html)\n\n\n\n#### 语法\n\ndictUpdate!(dictionary, function, keys, parameters, \\[initFunc=copy])\n\n#### 参数\n\n**dictionary** 是一个字典。\n\n**function** 是一个函数。\n\n**keys** 可以是标量或向量，表示对哪些键应用函数。\n\n**parameters** 和 **keys** 具有相同长度。应用函数的参数是 *parameters* 和字典的初始值。\n\n**initFunc** 是一个一元函数。当更新的键不存在时，执行该函数。只有当字典的值是 ANY 类型时，才能指定该参数。\n\n#### 详情\n\n更新字典中的特定的键的值。\n\n#### 例子\n\n```\nx=dict(1 2 3, 1 1 1);\nx;\n// output\n3->1\n1->1\n2->1\n\ndictUpdate!(x, add, 2 3, 1 2);\n// output\n3->3\n1->1\n2->2\n\nx.dictUpdate!(mul, 3 4, 2 4);\n// output\n4->4\n3->6\n1->1\n2->2\n\nd = dict(`IBM`MSFT, [1 2, 3 4])\nmsg = table(`IBM`MSFT`GOOG as symbol, 2 3 2 as ap)\nd.dictUpdate!(append!, msg.symbol, msg.ap, x->array(x.type(), 0, 512).append!(x))\nd;\n// output\nMSFT->[3,4,3]\nGOOG->[2]\nIBM->[1,2,2]\n```\n"
    },
    "difference": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/difference.html",
        "signatures": [
            {
                "full": "difference(X)",
                "name": "difference",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [difference](https://docs.dolphindb.cn/zh/funcs/d/difference.html)\n\n\n\n#### 语法\n\ndifference(X)\n\n#### 参数\n\n**X** 可以是标量或向量。\n\n#### 详情\n\n返回向量的最后一个元素减第一个元素的值。如果 *X* 是一个标量，则返回 0。\n\n#### 例子\n\n```\ndifference(2 4 2);\n// output\n0\n\ndifference(12.3 15.6 17.8);\n// output\n5.5\n\ndifference(278);\n// output\n0\n```\n"
    },
    "differentialEvolution": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/differentialevolution.html",
        "signatures": [
            {
                "full": "differentialEvolution(func, bounds, [X0], [maxIter=1000], [popSize=15], [mutation], [recombination=0.7], [tol=0.01], [atol=0], [polish=true], [seed])",
                "name": "differentialEvolution",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "bounds",
                        "name": "bounds"
                    },
                    {
                        "full": "[X0]",
                        "name": "X0",
                        "optional": true
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[popSize=15]",
                        "name": "popSize",
                        "optional": true,
                        "default": "15"
                    },
                    {
                        "full": "[mutation]",
                        "name": "mutation",
                        "optional": true
                    },
                    {
                        "full": "[recombination=0.7]",
                        "name": "recombination",
                        "optional": true,
                        "default": "0.7"
                    },
                    {
                        "full": "[tol=0.01]",
                        "name": "tol",
                        "optional": true,
                        "default": "0.01"
                    },
                    {
                        "full": "[atol=0]",
                        "name": "atol",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[polish=true]",
                        "name": "polish",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[seed]",
                        "name": "seed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [differentialEvolution](https://docs.dolphindb.cn/zh/funcs/d/differentialevolution.html)\n\n\n\n#### 语法\n\ndifferentialEvolution(func, bounds, \\[X0], \\[maxIter=1000], \\[popSize=15], \\[mutation], \\[recombination=0.7], \\[tol=0.01], \\[atol=0], \\[polish=true], \\[seed])\n\n#### 详情\n\n使用差分进化算法（Differential Evolution）求解多元函数的全局最小值。返回一个字典，表示求解结果，详细说明请参见“返回值”小节。\n\n#### 参数\n\n**func** 函数名，表示需要最小化的目标函数。注意：其返回值应为标量数值。\n\n**bounds** 数值类型矩阵，形状为(N,2)，其中 N 为需要优化的参数数量。\n\n**X0** 可选参数，数值向量，表示使目标函数最小化的参数的初始猜测。\n\n注意：\n\n* 参数 *bounds* 中每一行的两个值（min, max），分别定义了 *X0* 中对应参数的下、上边界。即参数 *X0* 的每个元素值均在 *bounds* 的范围内。\n\n* 参数 *X0* 应与 *bounds* 保持相同长度，即 N=size(*X0*)。\n\n**maxIter** 可选参数，非负整数标量，表示执行的最大迭代次数，默认值为 1000。\n\n**popSize** 可选参数，正整数标量，用于设置种群大小的乘数。种群包含 popSize\\*(N - N\\_equal) 个个体，其中，N\\_equal 表示 *bounds* 中上下限相等的参数个数。默认值为 15。\n\n**mutation** 可选参数，输入形式为数值数据对 pair(min, max)，表示变异常数的范围。应满足 0<= min <=max <2。默认值为(0.5, 1)。\n\n**recombination** 可选参数，数值标量，表示重组常数，又称为交叉概率。取值范围为\\[0, 1]。\n\n**tol** 可选参数，非负浮点数标量，表示收敛的相对容忍度。默认值为 0.01。\n\n**atol** 可选参数，非负浮点数标量，表示收敛的绝对容忍度。默认值为 0。当满足条件 stdev(population\\_energies) <= *atol* + *tol* \\* abs(mean(population\\_energies)) 时，停止算法迭代，其中 population\\_energies 表示种群中每个个体求得的目标函数值构成的向量。\n\n**polish** 可选参数，布尔标量，表示是否在差分进化算法结束后进一步使用 L-BFGS-B 算法优化参数。默认值为 true，表示使用。\n\n**seed** 可选参数，整数标量，表示差分进化算法中使用的随机数种子。如果不设置，则使用非确定性的随机数生成器。该参数的作用在于让用户可以复现运行结果。默认不设置。\n\n#### 返回值\n\n返回一个字典，包含以下成员：\n\n* xopt：浮点数向量，使目标函数最小化的参数值。\n\n* fopt：浮点数标量，目标函数最小值，fopt=f(xopt)。\n\n* iterations：整数标量，优化过程中执行的总迭代数。\n\n* fcalls：整数标量，优化过程中的目标函数调用次数。\n\n* converged：布尔值标量，表示优化过程的收敛状态。\n\n  * true：表示优化结果已收敛至满足预定条件，算法停止执行。\n\n  * false：表示已达最大迭代次数，算法未收敛而停止执行。\n\n#### 例子\n\n自定义函数 `rosen`，在上下界 *bounds* 约束下使用 `differentialEvolution` 求解 `rosen` 函数的全局最小值。\n\n```\ndef rosen(x) { \n\tN = size(x);\n\treturn sum(100.0*power(x[1:]-power(x[:N-1], 2.0), 2.0)+power(1-x[:N-1], 2.0));\n}\nbounds = matrix([0 0 0 0 0, 2 2 2 2 2])\ndifferentialEvolution(rosen, bounds)\n\n/* Ouput:\nfcalls->43656\nxopt->[1.000000000000,1.000000000000,1.000000000000,1.000000000000,1.000000000000]\nfopt->0.0\niterations->581\nconverged->true\n*/\n```\n"
    },
    "digitize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/digitize.html",
        "signatures": [
            {
                "full": "digitize(x, bins, [right=false])",
                "name": "digitize",
                "parameters": [
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "bins",
                        "name": "bins"
                    },
                    {
                        "full": "[right=false]",
                        "name": "right",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [digitize](https://docs.dolphindb.cn/zh/funcs/d/digitize.html)\n\n#### 语法\n\ndigitize(x, bins, \\[right=false])\n\n#### 参数\n\n**x** 一个浮点型、整型或 DECIMAL 类型的标量或向量。\n\n**bins** 一个单调递增或递减的浮点型、整型或 DECIMAL 类型向量。\n\n**right** 一个布尔值，为可选参数，设置区间包含右边界还是左边界，默认为 false（包含左边界）。\n\n#### 详情\n\n返回 *x*所属的*bins*的索引，返回值的数据形式与*x* 一致。\n\n<table id=\"table_svs_qst_x1c\"><thead><tr><th>\n\n*right*\n\n</th><th>\n\n*bins* 顺序\n\n</th><th>\n\n返回的索引满足\n\n</th></tr></thead><tbody><tr><td>\n\nfalse\n\n</td><td>\n\n升序\n\n</td><td>\n\n*bins* 里第一个大于 *x* 的元素的索引\n\n</td></tr><tr><td>\n\ntrue\n\n</td><td>\n\n升序\n\n</td><td>\n\n*bins*里第一个大于等于 *x*的元素的索引\n\n</td></tr><tr><td>\n\nfalse\n\n</td><td>\n\n降序\n\n</td><td>\n\n*bins*里第一个小于等于 *x*的元素的索引\n\n</td></tr><tr><td>\n\ntrue\n\n</td><td>\n\n降序\n\n</td><td>\n\n*bins*里第一个小于 *x*的元素的索引\n\n</td></tr></tbody>\n</table>如果 *x*中的值超出 *bins* 的左或右边界，则返回 0 或 *bins* 的长度。\n\n该函数的功能和使用方法同 numpy.digitize。\n\n#### 例子\n\n```\nbins = [1,3,3,5,5]\n// 返回 bins 里第一个大于 x 的元素的索引\ndigitize(3, bins=bins, right=false)\n// output: 3\n//返回 bins 里第一个大于 x 的元素的索引，由于 bins 里不存在这样的元素，返回 size(bins)\ndigitize(5, bins=bins, right=false)\n//output: 5\n// 返回 bins 里第一个大于等于 x 的元素的索引\ndigitize(5, bins=bins, right=true)\n//output: 3\nbins = reverse(bins)\ndigitize(5, bins=bins, right=false)\n//output: 0\ndigitize(5, bins=bins, right=true)\n//output: 2\n\nx = [-1,0,1,2,3,4,5,6]\nbins = [1,3,5]\ndigitize(x=x, bins=bins, right=false)\n//output: [0,0,1,1,2,2,3,3]\ndigitize(x=x, bins=bins, right=true)\n//output: [0,0,0,1,1,2,2,3]\nbins = reverse(bins)\ndigitize(x=x, bins=bins, right=false)\n//output: [3,3,2,2,1,1,0,0]\ndigitize(x=x, bins=bins, right=true)\n//output: [3,3,3,2,2,1,1,0]\n```\n\n`digitize` 函数相较于 `bucket` 函数更灵活，可以自定义 *bins* 。以下为示例：\n\n```\nbucket(9 23 54 36 46 12, 12:53, 2) //报错：dataRange must be the mutltiplier of bucketNum.\n```\n\n因为 \\[12, 53) 中元素个数不能被2整除，所以不能使用 `bucket` 来分桶。\n\n```\ndigitize(9 23 54 36 46 12 , 12 40 53)\n// output: [0,1,3,1,2,1]\n```\n\n`digitize` 函数中，函数按照自定义的 *bins*给数据分桶。\n\n"
    },
    "disableActivePartition": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/disableActivePartition.html",
        "signatures": [
            {
                "full": "disableActivePartition(dbHandle)",
                "name": "disableActivePartition",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    }
                ]
            }
        ],
        "markdown": "### [disableActivePartition](https://docs.dolphindb.cn/zh/funcs/d/disableActivePartition.html)\n\n\n\n#### 语法\n\ndisableActivePartition(dbHandle)\n\n#### 参数\n\n**dbHandle** 是历史数据库的句柄。\n\n#### 详情\n\n断开与历史数据库的连接。\n\n#### 例子\n\n```\nhistdb = database(\"C:\\DolphinDBDemo\\example\\data\\dbspace\\historical-A\\Trades2ndDomain\")\nactiveNodeAlias = getNodeAlias()\nactiveDate = today()\nenableActivePartition(histdb, activeDate, activeNodeAlias);\n\ndisableActivePartition(histdb);\n```\n"
    },
    "disableQueryMonitor": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/disableQueryMonitor.html",
        "signatures": [
            {
                "full": "disableQueryMonitor()",
                "name": "disableQueryMonitor",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [disableQueryMonitor](https://docs.dolphindb.cn/zh/funcs/d/disableQueryMonitor.html)\n\n\n\n#### 语法\n\ndisableQueryMonitor()\n\n#### 参数\n\n无\n\n#### 详情\n\n关闭监控查询任务状态的功能。\n\n由于监控查询任务状态具有一定的内存开销，内存资源紧张时，可以关闭该功能。注意：调用该命令后，用户将无法调用 [getQueryStatus](https://docs.dolphindb.cn/zh/funcs/g/getQueryStatus.html) 函数获取查询任务的状态。\n\n相关函数： [enableQueryMonitor](https://docs.dolphindb.cn/zh/funcs/e/enableQueryMonitor.html)\n"
    },
    "disableResourceTracking": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/disableresourcetracking.html",
        "signatures": [
            {
                "full": "disableResourceTracking()",
                "name": "disableResourceTracking",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [disableResourceTracking](https://docs.dolphindb.cn/zh/funcs/d/disableresourcetracking.html)\n\n\n\n#### 语法\n\ndisableResourceTracking()\n\n#### 参数\n\n无\n\n#### 详情\n\n在线关闭资源跟踪。仅当 resourceSamplingInterval 设置为正整数时才能调用该函数。该函数仅限管理员在数据节点上调用。\n\n**Note:** 资源跟踪开启和关闭不会影响日志回收。\n\n**Related information**\n\n[enableResourceTracking](https://docs.dolphindb.cn/zh/funcs/e/enableresourcetracking.html)\n"
    },
    "disableTablePersistence": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/disableTablePersistence.html",
        "signatures": [
            {
                "full": "disableTablePersistence(table)",
                "name": "disableTablePersistence",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [disableTablePersistence](https://docs.dolphindb.cn/zh/funcs/d/disableTablePersistence.html)\n\n\n\n#### 语法\n\ndisableTablePersistence(table)\n\n#### 参数\n\n**table** 是一个表对象。\n\n#### 详情\n\n停止把表持久化到磁盘，后续表更新的内容将不会持久化到磁盘上。\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt = streamTable(100:0, colName, colType);\nshare t as st\nenableTablePersistence(table=st, cacheSize=1200000)\n\nfor(s in 0:200){\n   n=10000\n   time=2019.01.01T00:00:00.000+s*n+1..n\n   x=rand(10.0, n)\n   insert into st values(time, x)\n}\ndisableTablePersistence(st);\n```\n\n相关命令：[enableTablePersistence](https://docs.dolphindb.cn/zh/funcs/e/enableTablePersistence.html), [clearTablePersistence](https://docs.dolphindb.cn/zh/funcs/c/clearTablePersistence.html)\n"
    },
    "disableTSDBAsyncSorting": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/disableTSDBAsyncSorting.html",
        "signatures": [
            {
                "full": "disableTSDBAsyncSorting()",
                "name": "disableTSDBAsyncSorting",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [disableTSDBAsyncSorting](https://docs.dolphindb.cn/zh/funcs/d/disableTSDBAsyncSorting.html)\n\n\n\n#### 语法\n\ndisableTSDBAsyncSorting()\n\n#### 参数\n\n无\n\n#### 详情\n\nTSDB 写入 Cache Engine 中的数据会根据 *sortColumns* 排序。写入任务和排序任务可以同步或异步进行，该命令用于关闭异步进行数据排序的功能。只能由管理员在数据节点上执行。\n\n**Related information**\n\n[enableTSDBAsyncSorting](https://docs.dolphindb.cn/zh/funcs/e/enableTSDBAsyncSorting.html)\n"
    },
    "distance": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/distance.html",
        "signatures": [
            {
                "full": "distance(X, Y)",
                "name": "distance",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [distance](https://docs.dolphindb.cn/zh/funcs/d/distance.html)\n\n\n\n#### 语法\n\ndistance(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是 POINT 类型的标量、数据对或者向量。\n\n#### 详情\n\n计算 *X* 和 *Y* 之间的距离（单位为米）。\n\n#### 例子\n\n```\np1 = point(180, 24.118418)\np2 = point(180, 24.11931)\ndistance(p1,p2)\n// output\n99.185916\n\np1 = point(117.60972, 24.118418)\np2 = point(117.50972, 24.118418)\np3 = point(117.70972, 24.118418)\np4 = point(117.75972, 24.118418)\ndistance([p1,p2], [p3,p4])\n```\n\n| 0          | 1           |\n| ---------- | ----------- |\n| 10,148.799 | 25,371.9947 |\n\n计算地图上两点之间的距离，假设 p1 的经纬度为 (Lon1, Lat1)，p2 的经纬度为 (Lon2, Lat2)。按照0度经线的基准，东经取正值（Longitude），西经取负值（-Longitude），北纬取90-纬度值（90- Latitude），南纬取90+纬度值（90+Latitude）。经过上述处理后进行计算：\n\n```\np1 = point(-117.60972,24.118418)  // 表示西经117.60972和北纬65.881582\np2 = point(117.61113,114.11931)  // 表示东经117.60972和南纬24.118418\ndistance(p1,p2)\n// output\n6.02098E6\n```\n"
    },
    "distinct": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/distinct.html",
        "signatures": [
            {
                "full": "distinct(X)",
                "name": "distinct",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [distinct](https://docs.dolphindb.cn/zh/funcs/d/distinct.html)\n\n\n\n#### 语法\n\ndistinct(X)\n\n#### 参数\n\n**X** 是一个向量或数组向量类型。\n\n#### 详情\n\n只返回向量 *X* 中不相同的元素，如果有两个或以上的相同元素，将只返回一个。结果中返回的顺序不保证和原来的向量相同。\n\n#### 例子\n\n```\ndistinct 4 5 5 2 3;\n// output\n[3,2,5,4]\n\na = array(INT[], 0, 10).append!([1 2 3,  4 5, 6 7 8, 9 10])\ndistinct(a)\n// output\n[10,9,8,7,6,5,4,3,2,1]\n\nt=table(3 1 2 2 3 as x);\nselect distinct x from t;\n```\n\n| distinct\\_x |\n| ----------- |\n| 2           |\n| 1           |\n| 3           |\n\n```\nselect sort(distinct(x)) as x from t;\n```\n\n| x |\n| - |\n| 1 |\n| 2 |\n| 3 |\n\n函数 `distinct` 返回一个向量，而函数 [`set`](https://docs.dolphindb.cn/zh/funcs/s/set.html) 返回一个集合。\n\n```\nx=set(4 5 5 2 3);\nx;\n// output\nset(3,2,5,4)\nx.intersection(set(2 5));\n// output\nset(2,5)\n```\n\n在内存表或分布式表中，`distinct` 函数可以和 `group by` 配合使用，每个分组的结果为一个数组向量。\n\n```\ndbName = \"dfs://testdb\"\nif(existsDatabase(dbName)){\n   dropDatabase(dbName)\n}\n\ndb=database(\"dfs://testdb\", VALUE, 2012.01.11..2012.01.29)\n\nn=100\nt=table(take(2012.01.11..2012.01.29, n) as date, symbol(take(\"A\"+string(21..60), n)) as sym, take(100, n) as val)\n\npt=db.createPartitionedTable(t, `pt, `date).append!(t)\nresult=select distinct(date) from pt group by sym\nselect sym, distinct_date from result where sym=`A21\n```\n\n| sym | distinct\\_date                      |\n| --- | ----------------------------------- |\n| A21 | \\[2012.01.15,2012.01.13,2012.01.11] |\n"
    },
    "div": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/div.html",
        "signatures": [
            {
                "full": "div(X, Y)",
                "name": "div",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [div](https://docs.dolphindb.cn/zh/funcs/d/div.html)\n\n\n\n#### 语法\n\ndiv(X, Y) 或 X/Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量或矩阵。如果 *X* 或 *Y* 的其中一个是数据对、向量、矩阵，另一个必须是具有相同长度或维度的数据对、向量、矩阵。\n\n#### 详情\n\n返回 *X* 和 *Y* 中元素依次相除的结果。当 *X* 或 *Y* 是浮点数时，返回一个浮点数。当 *X* 和 *Y* 都是整数时，`div` 表示整数除法，相当于在除法操作后应用 [floor](https://docs.dolphindb.cn/zh/funcs/f/floor.html) 函数。比如，5/2 返回 2. 如果想要为整数执行“真正”的除法，可以使用 [ratio](https://docs.dolphindb.cn/zh/funcs/r/ratio.html) 运算符 \"\\\\\" 代替。整数常和 [mod](https://docs.dolphindb.cn/zh/funcs/m/mod.html) 运算符一同使用，用来为数据分组。`div` 和 `mod` 的结果应该满足关系式：X=div(X,Y)\\*Y+mod(X,Y)。\n\n#### 例子\n\n```\n9/2:5;\n// output\n4 : 1\n\n11:25/3:4;\n// output\n3 : 6\n\nx=1 2 3;\nx/2;\n// output\n[0,1,1]\n\n2/x;\n// output\n[2,1,0]\n\ny=4 5 6;\nx/y;\n// output\n[0,0,0]\ny/x;\n// output\n[4,2,2]\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1/2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 1  | 2  |\n| 1  | 2  | 3  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1/m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 0  | 2  |\n| 0  | 1  | 6  |\n\n```\n-7/5;\n// output\n-2\n\nx=-1 2 6;\nx/-5;\n// output\n[0,-1,-2]\n```\n"
    },
    "dividedDifference": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dividedDifference.html",
        "signatures": [
            {
                "full": "dividedDifference(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false])",
                "name": "dividedDifference",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "resampleRule",
                        "name": "resampleRule"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    },
                    {
                        "full": "[outputX=false]",
                        "name": "outputX",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [dividedDifference](https://docs.dolphindb.cn/zh/funcs/d/dividedDifference.html)\n\n\n\n#### 语法\n\ndividedDifference(X, Y, resampleRule, \\[closed='left'], \\[origin='start\\_day'], \\[outputX=false])\n\n#### 详情\n\n该函数根据 *resampleRule*, *closed*, *origin* 确定的采样规则，对 *X* 进行重采样操作。并根据重采样后的 *X*，对 *Y* 进行均差插值（DividedDifference Interpolation）。\n\n若不指定 *outputX*，仅返回一个对 *Y* 插值后的向量。若指定 *outputX* = true，则返回一个 tuple，其第一个元素为 *X* 重采样后的向量，第二个元素为对 *Y* 插值后的向量。\n\n#### 参数\n\n**X** 严格递增的时间类型向量。\n\n**Y** 同 *X* 等长的数值型向量。\n\n**resampleRule** 一个字符串，可选值请参考 [resample](https://docs.dolphindb.cn/zh/funcs/r/resample.html) 的 *rule* 参数。\n\n**closed** 和 **origin** 同 [resample](https://docs.dolphindb.cn/zh/funcs/r/resample.html) 的 *closed* 和 *origin* 参数。\n\n**outputX** 布尔类型，表示是否输出 *X* 按照 *resampleRule*, *closed*, *origin* 重采样后的向量。默认值为 false。\n\n#### 例子\n\n```\ndividedDifference([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min);\n\n// output\n[1,1.0217,1.0451,1.0703,1.0972,1.1259,1.1562,1.1884,1.2222,1.2578,\n1.2951,1.3342,1.375,1.4175,1.4618,1.5078,1.5556,1.605,1.6562,1.7092,\n1.7639,1.8203,1.8785,1.9384,2,2.0634,2.1285,2.1953,2.2639,2.3342,\n2.4062,2.48,2.5556,2.6328,2.7118,2.7925,2.875,2.9592,3.0451,3.1328,\n3.2222,3.3134,3.4062,3.5009,3.5972,3.6953,3.7951,3.8967,4]\n```\n"
    },
    "dot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dot.html",
        "signatures": [
            {
                "full": "dot(X, Y)",
                "name": "dot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [dot](https://docs.dolphindb.cn/zh/funcs/d/dot.html)\n\n\n\n#### 语法\n\ndot(X, Y) 或 X\\*\\*Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、向量或矩阵。如果 *X* 和 *Y* 都是向量，他们必须具有相同的长度。如果 *X* 或 *Y* 的其中一个是矩阵，另一个必须是维度满足矩阵乘法规则的向量或矩阵。\n\n#### 详情\n\n返回 *X* 和 *Y* 的矩阵乘法。如果 *X* 和 *Y* 是具有相同长度的向量，返回它们的内积。\n\n#### 例子\n\n```\nx=1..6$2:3;\ny=1 2 3;\nx dot y;\n```\n\n| #0 |\n| -- |\n| 22 |\n| 28 |\n\n```\nx=1..6$2:3;\ny=6..1$3:2;\nx**y;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 41 | 14 |\n| 56 | 20 |\n\n```\ny**x;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 12 | 30 | 48 |\n| 9  | 23 | 37 |\n| 6  | 16 | 26 |\n\n```\na=1 2 3;\nshape a;\n// output\n3:1\nx**a;\n```\n\n| #0 |\n| -- |\n| 22 |\n| 28 |\n\n```\nb=1 2;\nshape b;\n// output\n2:1\nb**x;\n// 对于矩阵和向量之间的矩阵乘法，系统会自动转换向量的维度以便完成乘法。\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 5  | 11 | 17 |\n\n```\nx=1 2 3;\ny=4 5 6;\nx ** y;\n// output\n32\n// 两个向量之间的内积。等价于 1*4 + 2*5 + 3*6\n\nx ** 2;\n// output\n[2,4,6]\n\nx=1..6$2:3\nx ** 2;\n// output\nUse * rather than ** for scalar and matrix multiplication.\n```\n\n相关函数：[rowDot](https://docs.dolphindb.cn/zh/funcs/r/rowDot.html)\n"
    },
    "double": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/double.html",
        "signatures": [
            {
                "full": "double(X)",
                "name": "double",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [double](https://docs.dolphindb.cn/zh/funcs/d/double.html)\n\n\n\n#### 语法\n\ndouble(X)\n\n#### 详情\n\n将输入的数据类型转换为 DOUBLE。\n\n#### 参数\n\n**X** 可以是任意数据类型。\n\n#### 例子\n\n```\nx=double();  // 创建一个 DOUBLE 类型的变量，默认值为0。\nx;\n```\n\n返回：null\n\n```\ntypestr x;\n```\n\n返回：DOUBLE\n\n```\ntypestr double(`10);\n```\n\n返回：DOUBLE\n\n```\ndouble(`10.9);\n```\n\n返回：10.9\n\n```\ndouble(now());\n```\n\n返回：1,708,616,927,949\n\n**Note:** 该例子首先使用 `now` 函数获得当前系统时间 2024.02.22 15:50:15.528，`double` 函数将该时间转换为 1,708,616,927,949。\n"
    },
    "drop": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/drop.html",
        "signatures": [
            {
                "full": "drop(X, n)",
                "name": "drop",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [drop](https://docs.dolphindb.cn/zh/funcs/d/drop.html)\n\n\n\n#### 语法\n\ndrop(X, n)\n\n#### 参数\n\n**X** 可以是向量、矩阵或表。\n\n**n** 是一个整数。\n\n#### 详情\n\n从向量中删除前 *n* 个或后 *n* 个（如果 *n* 为负数）个元素，或从矩阵中删除前/后 *n* 列，或从表中删除前/后 *n* 行。\n\n#### 例子\n\n```\nx=1..10;\nx.drop(2);\n// output\n[3,4,5,6,7,8,9,10]\nx.drop(-2);\n// output\n[1,2,3,4,5,6,7,8]\n\nx=1..10$2:5;\nx;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  |\n| 2  | 4  | 6  | 8  | 10 |\n\n```\ndrop(x,2);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 5  | 7  | 9  |\n| 6  | 8  | 10 |\n\n```\nx drop -2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nt=table(1 2 3 4 as x, 11..14 as y);\nt;\n```\n\n| x | y  |\n| - | -- |\n| 1 | 11 |\n| 2 | 12 |\n| 3 | 13 |\n| 4 | 14 |\n\n```\nt.drop(2);\n```\n\n| x | y  |\n| - | -- |\n| 3 | 13 |\n| 4 | 14 |\n"
    },
    "dropAggregator": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropAggregator.html",
        "signatures": [
            {
                "full": "dropStreamEngine(name)",
                "name": "dropStreamEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [dropAggregator](https://docs.dolphindb.cn/zh/funcs/d/dropAggregator.html)\n\n是 [dropStreamEngine](https://docs.dolphindb.cn/zh/funcs/d/dropStreamEngine.html) 的别名。\n\n\n以下是 `dropStreamEngine` 函数的文档：\n### [dropStreamEngine](https://docs.dolphindb.cn/zh/funcs/d/dropStreamEngine.html)\n\n#### 语法\n\ndropStreamEngine(name)\n\n别名： [dropAggregator](https://docs.dolphindb.cn/zh/funcs/d/dropAggregator.html)\n\n#### 详情\n\n释放指定的流数据引擎的定义。\n\n#### 参数\n\n**name**：字符串，表示一个流数据引擎的名称。需指定为已创建的引擎名称，否则会抛出异常。通过 [getStreamEngineStat](https://docs.dolphindb.cn/zh/funcs/g/getStreamEngineStat.html) 可查看已创建的引擎名称。\n\n#### 例子\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\noutputTable = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\ntradesAggregator = createTimeSeriesAggregator(name=\"StreamAggregatorDemo\", windowSize=3, step=3, metrics=<[sum(qty)]>, dummyTable=trades, outputTable=outputTable, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesAggregator\", offset=0, handler=append!{tradesAggregator}, msgAsTable=true)\n\ndef writeData(n){\n    timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n    symv =take(`A`B, n)\n    qtyv = take(1, n)\n    insert into trades values(timev, symv, qtyv)\n}\n\nwriteData(6);\n\nselect * from outputTable;\n```\n\n| time                    | sym | sumQty |\n| ----------------------- | --- | ------ |\n| 2018.10.08T01:01:01.003 | A   | 1      |\n| 2018.10.08T01:01:01.006 | A   | 1      |\n| 2018.10.08T01:01:01.006 | B   | 2      |\n\n```\ndropStreamEngine(\"StreamAggregatorDemo\");\n```\n\n"
    },
    "dropCatalog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropCatalog.html",
        "signatures": [
            {
                "full": "dropCatalog(catalog)",
                "name": "dropCatalog",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    }
                ]
            }
        ],
        "markdown": "### [dropCatalog](https://docs.dolphindb.cn/zh/funcs/d/dropCatalog.html)\n\n\n\n#### 语法\n\ndropCatalog(catalog)\n\n#### 参数\n\n**catalog** 字符串标量，表示 catalog 的名称。\n\n#### 详情\n\n删除指定的 catalog。\n\n#### 例子\n\n```\ndropCatalog(\"catalog1\")\n```\n"
    },
    "dropColumns!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropColumns_.html",
        "signatures": [
            {
                "full": "dropColumns!(table, colNames)",
                "name": "dropColumns!",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    }
                ]
            }
        ],
        "markdown": "### [dropColumns!](https://docs.dolphindb.cn/zh/funcs/d/dropColumns_.html)\n\n#### 语法\n\ndropColumns!(table, colNames)\n\n别名：drop!\n\n#### 参数\n\n**table** 一个内存表或分布式表（仅支持 OLAP 引擎）。\n\n**colNames** 表示列名的标量或向量。若 *table* 是分布式表，则 *colNames* 只能是标量。\n\n#### 详情\n\n从表中删除指定的列。请注意，对于分布式表，不支持分区列和 SYMBOL 类型列的删除。\n\n#### 例子\n\n```\nt=table(1 2 3 as x, 4 5 6 as y, 7..9 as z, 10..12 as a, 13..15 as b, 16..18 as c);\nt;\n```\n\n| x | y | z | a  | b  | c  |\n| - | - | - | -- | -- | -- |\n| 1 | 4 | 7 | 10 | 13 | 16 |\n| 2 | 5 | 8 | 11 | 14 | 17 |\n| 3 | 6 | 9 | 12 | 15 | 18 |\n\n```\nt.dropColumns!(`x);\n```\n\n| y | z | a  | b  | c  |\n| - | - | -- | -- | -- |\n| 4 | 7 | 10 | 13 | 16 |\n| 5 | 8 | 11 | 14 | 17 |\n| 6 | 9 | 12 | 15 | 18 |\n\n```\ndropColumns!(t, `a`b);\n```\n\n| y | z | c  |\n| - | - | -- |\n| 4 | 7 | 16 |\n| 5 | 8 | 17 |\n| 6 | 9 | 18 |\n\n"
    },
    "dropDatabase": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropDatabase.html",
        "signatures": [
            {
                "full": "dropDatabase(dbDir)",
                "name": "dropDatabase",
                "parameters": [
                    {
                        "full": "dbDir",
                        "name": "dbDir"
                    }
                ]
            }
        ],
        "markdown": "### [dropDatabase](https://docs.dolphindb.cn/zh/funcs/d/dropDatabase.html)\n\n\n\n#### 语法\n\ndropDatabase(dbDir)\n\n#### 参数\n\n**dbDir** 是数据库所在的目录。对于分布式文件系统中的数据库，目录要以 `\"dfs://\"` 开始。\n\n#### 详情\n\n删除指定数据库的所有物理文件。\n\n自 3.00.0 版本起，支持删除 catalog 中的数据库，其引用关系也会同时被删掉。\n\n#### 例子\n\n删除分布式数据库：\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x);\nsaveText(t, \"C:/DolphinDB/Data/t.txt\");\n\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt = loadTextEx(db, `pt1, `date, \"C:/DolphinDB/Data/t.txt\");\n\ndropDatabase(\"dfs://valueDB\")\n```\n\n删除本地磁盘数据库：\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\nsaveText(t, \"C:/DolphinDB/Data/t.txt\");\n\ndb = database(\"C:/DolphinDB/Data/rangedb\", RANGE, 0 5 10)\npt = loadTextEx(db, `pt, `ID, \"C:/DolphinDB/Data/t.txt\");\n\ndropDatabase(\"C:/DolphinDB/Data/rangedb\");\n```\n"
    },
    "dropDistributedInMemoryTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropDistributedInMemoryTable.html",
        "signatures": [
            {
                "full": "dropDistributedInMemoryTable(tableName)",
                "name": "dropDistributedInMemoryTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [dropDistributedInMemoryTable](https://docs.dolphindb.cn/zh/funcs/d/dropDistributedInMemoryTable.html)\n\n\n\n#### 语法\n\ndropDistributedInMemoryTable(tableName)\n\n#### 参数\n\n**tableName** 字符串标量，表示分布式共享内存表的名称。\n\n#### 详情\n\n删除指定的表。该命令只能在数据节点/计算节点上执行。\n\n#### 例子\n\n```\npt = createDistributedInMemoryTable(`dt, `time`id`value, `DATETIME`INT`LONG, HASH, [INT, 2],`id)\ntime = take(2021.08.20 00:00:00..2021.08.30 00:00:00, 40);\nid = 0..39;\nvalue = rand(100, 40);\ntmp = table(time, id, value);\n\npt = loadDistributedInMemoryTable(`dt)\npt.append!(tmp);\ndropDistributedInMemoryTable(`dt)\n```\n\n相关函数：[loadDistributedInMemoryTable](https://docs.dolphindb.cn/zh/funcs/l/loadDistributedInMemoryTable.html), [createDistributedInMemoryTable](https://docs.dolphindb.cn/zh/funcs/c/createDistributedInMemoryTable.html)\n"
    },
    "dropFunctionView": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropFunctionView.html",
        "signatures": [
            {
                "full": "dropFunctionView(name, [isNamespace=false])",
                "name": "dropFunctionView",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[isNamespace=false]",
                        "name": "isNamespace",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [dropFunctionView](https://docs.dolphindb.cn/zh/funcs/d/dropFunctionView.html)\n\n\n\n#### 语法\n\ndropFunctionView(name, \\[isNamespace=false])\n\n#### 参数\n\n**name** 是一个字符串标量，表示用户自定义函数名称或一个命名空间。\n\n**isNamespace** 是一个布尔标量，指示 name 是否是一个命名空间。\n\n#### 详情\n\n删除一个视图或一个命名空间下的所有函数。\n\n`dropFunctionView`只能由管理员或拥有 VIEW\\_OWNER 权限的普通用户执行。\n\n```\ngetFunctionViews()\nname      body                           \n--------- ------------------\nf1        def f1(){return 1}\ntest::f1 def f1(){return 2}\ntest::f2 def f2(){return 3}\n\n// 删除 f1\ndropFunctionView(`f1)\n// 删除 test::f1\ndropFunctionView(\"test::f1\")\n// 删除命名空间 test 下所有函数\ndropFunctionView(\"test\",true)\n```\n"
    },
    "dropIPCInMemoryTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropIPCInMemoryTable.html",
        "signatures": [
            {
                "full": "dropIPCInMemoryTable(tableName)",
                "name": "dropIPCInMemoryTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [dropIPCInMemoryTable](https://docs.dolphindb.cn/zh/funcs/d/dropIPCInMemoryTable.html)\n\n\n\n#### 语法\n\ndropIPCInMemoryTable(tableName)\n\n#### 参数\n\n**tableName** 字符串，表示跨进程共享内存表的名称。\n\n#### 详情\n\n删除跨进程共享内存表。\n\n**Note:**\n\n* 此函数仅适用于 Linux 系统。\n\n* server 关机并不能删除跨进程共享内存表，仍然需要通过 `dropIPCInMemoryTable` 进行删除。\n\n#### 例子\n\n删除函数 `createIPCInMemoryTable` 例子中创建的表 ipc\\_table。\n\n```\ndropIPCInMemoryTable(`ipc_table)\n// output\nipc_table\n```\n"
    },
    "dropna": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropna.html",
        "signatures": [
            {
                "full": "dropna(X, [byRow=true], [thresh])",
                "name": "dropna",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[byRow=true]",
                        "name": "byRow",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[thresh]",
                        "name": "thresh",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [dropna](https://docs.dolphindb.cn/zh/funcs/d/dropna.html)\n\n\n\n#### 语法\n\ndropna(X, \\[byRow=true], \\[thresh])\n\n#### 参数\n\n**X** 是一个向量或矩阵。\n\n**byRow** 是一个布尔值。默认值为 true。\n\n**thresh** 是一个正整数。\n\n#### 详情\n\n若 *X* 是向量，将其中 NULL 值删除。\n\n若 *X* 是矩阵，删除其中含有空值的行或列。若参数 *byRow* 为 true，删除含有 NULL 值的行；若参数 *byRow* 为 false，删除含有 NULL 值的列。\n\n若指定 *thresh*，要求结果中每行或每列含有至少 *thresh* 个非 NULL 元素，否则删除。\n\n#### 例子\n\n```\nx=1 NULL 2 3 NULL NULL 4;\nx.dropna();\n// output\n[1,2,3,4]\n\nm=matrix(1 1 1 1, 1 1 1 NULL, 1 NULL 1 NULL);\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 1  | 1  |    |\n| 1  | 1  | 1  |\n| 1  |    |    |\n\n```\ndropna(m);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 1  | 1  | 1  |\n\n```\ndropna(m,,2);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 1  | 1  |    |\n| 1  | 1  | 1  |\n\n```\ndropna(m,false);\n```\n\n| #0 |\n| -- |\n| 1  |\n| 1  |\n| 1  |\n| 1  |\n\n```\ndropna(m,false,3);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 1  | 1  |\n| 1  | 1  |\n| 1  |    |\n"
    },
    "dropPartition": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropPartition.html",
        "signatures": [
            {
                "full": "dropPartition(dbHandle, partitionPaths, tableName, [forceDelete=false], [deleteSchema=false])",
                "name": "dropPartition",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "partitionPaths",
                        "name": "partitionPaths"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[forceDelete=false]",
                        "name": "forceDelete",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[deleteSchema=false]",
                        "name": "deleteSchema",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [dropPartition](https://docs.dolphindb.cn/zh/funcs/d/dropPartition.html)\n\n\n\n#### 语法\n\ndropPartition(dbHandle, partitionPaths, tableName, \\[forceDelete=false], \\[deleteSchema=false])\n\n#### 详情\n\n删除数据库中指定分区的数据。\n\n如果指定了 *tableName* ：删除指定表中符合指定条件的分区数据。\n\n如果没有指定 *tableName*：删除指定数据库所有表中符合指定条件的分区数据。\n\n#### 参数\n\n**dbHandle** 分布式数据库的句柄。\n\n**partitionPaths** 有两种指定模式：\n\n* 指定路径：以 \"/\" 开头的字符串或字符串向量，表示数据库目录下单个或多个分区的路径。请注意对组合分区，路径必须包括所有层次分区。\n\n* 指定条件：以分区列的一个或多个值组成的标量或向量作为过滤条件，系统会找到并删除这些值所在的分区。对于组合分区，partitionPaths 是由每层分区的过滤条件组成的元组，如果某层分区不需要过滤，那么相应的过滤条件需置为空。\n\n**tableName** 字符串，表示表名。若分区粒度为数据库级（[database](https://docs.dolphindb.cn/zh/funcs/d/database.html): *chunkGranularity* = 'DATABASE'），可以不指定 *tableName*，否则必须指定该参数。\n\n**forceDelete** 布尔值，默认值为 false，表示不开启强制删除。如果 *forceDelete* =true，即使指定的分区正在恢复，系统也会将其强制删除。\n\n**deleteSchema** 布尔值，默认值为 false，表示仅删除分区数据，分区方案（partitionSchema）中仍保留其对应的分区方案信息。\n\n如果 *deleteSchema*=true，在满足以下条件时，删除分区数据及其对应的分区方案信息（可通过 [schema](https://docs.dolphindb.cn/zh/funcs/s/schema.html).partitionSchema 函数查看）：\n\n1. 数据库只包含一个表；\n\n2. 单级分区时采用 VALUE 分区，或多级分区的第一级为 VALUE 分区；\n\n3. `dropPartition` 仅删除第一级分区的数据。\n\n#### 例子\n\n下面例子中的脚本需要在集群中的数据节点/计算节点执行。\n\n```\nn=1000000\nID=rand(150, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID = database(, RANGE, 0 50 100 150)\ndb = database(\"dfs://compoDB\", COMPO, [dbDate, dbID])\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n```\n\n上面的代码创建了组合分区的数据库，第一层分区为基于日期的值分区，第二层分区为基于值的范围分区。\n\n例 1. 删除某个分区的数据\n\n例如，删除表 pt \"/20170807/0\\_50\" 分区，有以下两种方法：\n\n(1) 指定路径：\n\n```\ndropPartition(db, \"/20170807/0_50\", tableName=`pt);\n```\n\n(2) 指定条件：\n\n```\ndropPartition(db, [2017.08.07, 0], tableName=`pt);\n```\n\n注意：\"/20170807/0\\_50\" 分区中的 ID 的可取值范围是从 0 到 49，不包括 50。以上脚本中，可以使用 0 到 49 的任一数字来代表此分区。\n\n例 2. 删除一级分区的数据\n\n例如，删除表 pt 的一级分区 2017.08.08，有以下两种方法：\n\n(1) 使用向量指定该一级分区之下所有分区的路径：\n\n```\npartitions=[\"/20170808/0_50\",\"/20170808/50_100\",\"/20170808/100_150\"]\ndropPartition(db, partitions, tableName=`pt);\n```\n\n(2) 指定条件：\n\n```\ndropPartition(db, 2017.08.08, tableName=`pt);\n```\n\n删除分区数据后，我们使用 [schema](https://docs.dolphindb.cn/zh/funcs/s/schema.html) 函数查看数据库的分区方案：\n\n```\nschema(db);\npartitionSchema->([2017.08.11,2017.08.10,2017.08.09,2017.08.08,2017.08.07],[0,50,100,150])\ndatabaseDir->dfs://compoDB\npartitionSites->\n```\n\n可以发现，2017.08.08 仍然在分区方案中，这是因为 `dropPartition` 只删除了 2017.08.08 这个分区中的数据，并不会将 2017.08.08 从数据库的分区方案中移除。由于该例删除的是一级 VALUE 分区，通过指定 *deleteSchema* = true，来同步删除分区方案中的对应分区信息。\n\n```\ndropPartition(db, 2017.08.08, tableName=`pt, deleteSchema = true);\n```\n\n使用 `schema` 函数查看数据库的分区方案：\n\n```\nschema(db);\n// output\npartitionSchema->([2017.08.11,2017.08.10,2017.08.09,2017.08.07],[0,50,100,150])\n...\n```\n\n例 3. 删除二级分区的数据\n\n例如，删除表 pt 的二级分区 \\[0,50)，有以下两种方法：\n\n(1) 使用向量指定含有该二级分区的所有分区的路径：\n\n```\npartitions=[\"/20170807/0_50\",\"/20170808/0_50\",\"/20170809/0_50\",\"/20170810/0_50\",\"/20170811/0_50\"]\ndropPartition(db, partitions, tableName=`pt);\n```\n\n(2) 指定条件：\n\n```\ndropPartition(db, [,[0]], tableName=`pt);\n```\n\n例 4. 删除多个二级分区的数据\n\n例如，删除表 pt 的二级分区 \\[0,50) 和 \\[100,150)：\n\n```\ndropPartition(db, [,[0,100]], tableName=`pt);\n```\n\n例 5. 修改分布式数据库中的数据\n\n在 DolphinDB 中，如果要修改分布式数据库中的数据，需要先把相关分区的数据加载到内存中进行修改，然后使用 `dropPartition` 将数据库中的相关分区删除，最后将内存中修改好的分区数据重新追加到数据库中。\n\n例如，将分布式表 pt 中 date=2017.08.10, ID=88 的记录 x+10。\n\n首先，将包含 date=2017.08.10, ID=88 的所有相关分区数据加载到内存中，这些数据位于 \"20170810/50\\_100\" 分区中：\n\n```\ntmp=select * from loadTable(\"dfs://compoDB\",\"pt\") where date=2017.08.10 and 50<=ID<100 ;\n```\n\n接着，将内存表 tmp 中 date=2017.08.10, ID=88 的记录 x+10。：\n\n```\nupdate tmp set x=x+10 where date=2017.08.10 and ID=88;\n```\n\n然后，删除表 pt 中 \"20170810/50\\_100\" 分区中的数据：\n\n```\ndropPartition(db,\"/20170810/50_100\", tableName=`pt);\n```\n\n最后，将内存中修改好的记录追加到表 pt 中：\n\n```\npt.append!(tmp);\n```\n"
    },
    "dropSchema": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropSchema.html",
        "signatures": [
            {
                "full": "dropSchema(catalog, schema)",
                "name": "dropSchema",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    },
                    {
                        "full": "schema",
                        "name": "schema"
                    }
                ]
            }
        ],
        "markdown": "### [dropSchema](https://docs.dolphindb.cn/zh/funcs/d/dropSchema.html)\n\n\n\n#### 语法\n\ndropSchema(catalog, schema)\n\n#### 参数\n\n**catalog** 字符串标量，表示 catalog 的名称。\n\n**schema** 字符串标量，表示要删除的 schema 的名称。\n\n#### 详情\n\n删掉指定 catalog 中的指定 schema。\n\n#### 例子\n\n```\ndropSchema(\"catalog1\", \"Schema\")\n```\n"
    },
    "dropStreamEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropStreamEngine.html",
        "signatures": [
            {
                "full": "dropStreamEngine(name)",
                "name": "dropStreamEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [dropStreamEngine](https://docs.dolphindb.cn/zh/funcs/d/dropStreamEngine.html)\n\n#### 语法\n\ndropStreamEngine(name)\n\n别名： [dropAggregator](https://docs.dolphindb.cn/zh/funcs/d/dropAggregator.html)\n\n#### 详情\n\n释放指定的流数据引擎的定义。\n\n#### 参数\n\n**name**：字符串，表示一个流数据引擎的名称。需指定为已创建的引擎名称，否则会抛出异常。通过 [getStreamEngineStat](https://docs.dolphindb.cn/zh/funcs/g/getStreamEngineStat.html) 可查看已创建的引擎名称。\n\n#### 例子\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\noutputTable = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\ntradesAggregator = createTimeSeriesAggregator(name=\"StreamAggregatorDemo\", windowSize=3, step=3, metrics=<[sum(qty)]>, dummyTable=trades, outputTable=outputTable, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesAggregator\", offset=0, handler=append!{tradesAggregator}, msgAsTable=true)\n\ndef writeData(n){\n    timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n    symv =take(`A`B, n)\n    qtyv = take(1, n)\n    insert into trades values(timev, symv, qtyv)\n}\n\nwriteData(6);\n\nselect * from outputTable;\n```\n\n| time                    | sym | sumQty |\n| ----------------------- | --- | ------ |\n| 2018.10.08T01:01:01.003 | A   | 1      |\n| 2018.10.08T01:01:01.006 | A   | 1      |\n| 2018.10.08T01:01:01.006 | B   | 2      |\n\n```\ndropStreamEngine(\"StreamAggregatorDemo\");\n```\n\n"
    },
    "dropStreamTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropStreamTable.html",
        "signatures": [
            {
                "full": "dropStreamTable(tableName,[force=false])",
                "name": "dropStreamTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[force=false]",
                        "name": "force",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [dropStreamTable](https://docs.dolphindb.cn/zh/funcs/d/dropStreamTable.html)\n\n\n\n#### 语法\n\ndropStreamTable(tableName,\\[force=false])\n\n#### 详情\n\n删除流数据表。如果流数据表启用了持久化，该函数也会将磁盘上持久化的数据删除。\n\n如果流数据表已经持久化到磁盘但是尚未加载到内存，管理员用户可以通过设置参数 *force* 为 true，直接删除磁盘上的持久化数据。\n\n如果要删除高可用流数据表，只需在 Raft 组中的任意一个数据节点/计算节点上执行该函数即可，其他数据节点/计算节点上名称相同的高可用流数据表也会被删除。\n\n#### 参数\n\n**tableName** 是一个字符串，表示流数据表的名称。\n\n**force** 是一个布尔标量，表示是否在内存没有该流数据表时强制删除同名持久化文件。默认值为 false。\n\n#### 例子\n\n删除普通流数据表：\n\n```\ncolNames = `timestamp`sym`qty`price\ncolTypes = [TIMESTAMP,SYMBOL,INT,DOUBLE]\nt=streamTable(1:0,colNames,colTypes)\nenableTableShareAndPersistence(t,`trades);\n\ndropStreamTable(`trades);\n```\n\n删除未加载到内存的持久化流数据表：\n\n```\ncolNames = `timestamp`sym`qty`price\ncolTypes = [TIMESTAMP,SYMBOL,INT,DOUBLE]\nt=streamTable(1:0,colNames,colTypes)\nenableTableShareAndPersistence(t,`trades);\n\n//删除内存中的流数据表\nundef(`trades,SHARED)\n\n//删除持久化流表失败\ndropStreamTable(`trades)\n//dropStreamTable(\"trades\") => Can't find stream table trades\n\n// admin 设置force为true,成功删除\ndropStreamTable(tableName=`trades,force=true)\n```\n\n删除高可用流数据表：\n\n```\ncolNames = `timestamp`sym`qty`price\ncolTypes = [TIMESTAMP,SYMBOL,INT,DOUBLE]\nt=table(1:0,colNames,colTypes)\nhaStreamTable(11,t,`trades,100000);\n\ndropStreamTable(`trades);\n```\n"
    },
    "dropTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dropTable.html",
        "signatures": [
            {
                "full": "dropTable(dbHandle, tableName)",
                "name": "dropTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [dropTable](https://docs.dolphindb.cn/zh/funcs/d/dropTable.html)\n\n\n\n#### 语法\n\ndropTable(dbHandle, tableName)\n\n#### 详情\n\n删除指定的表。该命令只能在数据节点/计算节点上执行，不能在控制节点和代理节点上执行。\n\n#### 参数\n\n**dbHandle** 是数据库句柄。\n\n**tableName** 是一个字符串，表示表名。\n\n#### 例子\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x)\ndb=database(\"dfs://rangedb\", RANGE,  0 5 10)\npt = db.createPartitionedTable(t, `pt, `ID)\npt.append!(t)\n\ndropTable(db,`pt);\n```\n\n**Related information**\n\n[truncate](https://docs.dolphindb.cn/zh/funcs/t/truncate.html)\n"
    },
    "dumpHeapSample": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dumpheapsample.html",
        "signatures": [
            {
                "full": "dumpHeapSample(filename)",
                "name": "dumpHeapSample",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    }
                ]
            }
        ],
        "markdown": "### [dumpHeapSample](https://docs.dolphindb.cn/zh/funcs/d/dumpheapsample.html)\n\n\n\n#### 语法\n\ndumpHeapSample(filename)\n\n#### 参数\n\n**filename** 字符串标量，表示堆内存快照的路径。\n\n#### 详情\n\n生成当前堆内存的快照。调用此函数后，系统会记录当前的内存使用情况，包括已分配的内存块、它们的大小和状态等信息。仅管理员可执行该函数。\n\n#### 例子\n\n对内存使用情况进行分析的流程如下：\n\n1. 启用堆内存采样：可在启动 DolphinDB 前，设置环境变量 TCMALLOC\\_SAMPLE\\_PARAMETER 为1-524288之间的值（建议值 524288）；或通过函数 `startHeapSample` 动态开启。\n\n2. 在可能发生内存泄漏的操作前、后分别执行 `dumpHeapSample`，保存两个不同的文件。通过对比两个文件，确认操作涉及到的内存分配和使用情况。\n\n3. 关闭堆内存采样。\n\n```\nstartHeapSample(524288)\n\ndumpHeapSample(\"/DolphinDB/Data/heap1\")\ndumpHeapSample(\"/DolphinDB/Data/heap2\")\n\nstopHeapSample()\n```\n\n相关函数：[startHeapSample](https://docs.dolphindb.cn/zh/funcs/s/startheapsample.html), [stopHeapSample](https://docs.dolphindb.cn/zh/funcs/s/stopheapsample.html)\n"
    },
    "duration": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/duration.html",
        "signatures": [
            {
                "full": "duration(X)",
                "name": "duration",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [duration](https://docs.dolphindb.cn/zh/funcs/d/duration.html)\n\n\n\n#### 语法\n\nduration(X)\n\n#### 详情\n\n将一个字符串标量转换为 DURATION 类型。表示一个时间区间。\n\n**Note:**\n\n* 用于分组的时间区间单位应需不小于时间列的单位。\n\n* 时间单位区分大小写，例如：M 表示月份，m 表示分钟；若分组的时间区间单位为 M，时间列需要通过函数 [month](https://docs.dolphindb.cn/zh/funcs/m/month.html) 转换为对应月份。\n\n* DURATION 类型数据之间不能进行任何运算。例如，不能进行比较运算：`duration('20ms') >= duration('10ms')`。\n\n#### 参数\n\n**X** 是一个字符串，为一个数字与时间单位所组成。支持以下时间单位：y, M, w, d, B, H, m, s, ms, us, ns和由四个大写英文字母构成的交易日历标识（`duration` 函数不会校验交易日历文件是否存在于 *marketHolidayDir* 中）。例如：\"2y\", \"3M\", \"30m\", \"100ms\", \"3XNYS\"等。\n\n#### 例子\n\n```\ny=duration(\"20H\")\ny\n```\n\n返回：20H\n\n```\ntypestr(y)\n```\n\n返回：DURATION\n\n```\nduration(\"3XNYS\")\n```\n\n返回：3XNYS\n\n不指定时间单位，取时间列 time 的单位 s：\n\n```\nt=table(take(2018.01.01T01:00:00+1..10,10) join take(2018.01.01T02:00:00+1..10,10) join take(2018.01.01T08:00:00+1..10,10) as time, rand(1.0, 30) as x);\nselect max(x) from t group by bar(time, 5);\n```\n\n| bar\\_time           | max\\_x |\n| ------------------- | ------ |\n| 2018.01.01T01:00:00 | 0.8824 |\n| 2018.01.01T01:00:05 | 0.8027 |\n| 2018.01.01T01:00:10 | 0.572  |\n| 2018.01.01T02:00:00 | 0.8875 |\n| 2018.01.01T02:00:05 | 0.8542 |\n| 2018.01.01T02:00:10 | 0.4287 |\n| 2018.01.01T08:00:00 | 0.9294 |\n| 2018.01.01T08:00:05 | 0.9804 |\n| 2018.01.01T08:00:10 | 0.2147 |\n\n指定单位为 m，对时间列按照1分钟进行分组：\n\n```\nselect max(x) from t group by bar(time, 1m);\n```\n\n| bar\\_time           | max\\_x |\n| ------------------- | ------ |\n| 2018.01.01T01:00:00 | 0.8824 |\n| 2018.01.01T02:00:00 | 0.8875 |\n| 2018.01.01T08:00:00 | 0.9804 |\n\n**Related information**\n\n[交易日历](https://docs.dolphindb.cn/zh/modules/MarketHoliday/mkt_calendar.html)\n"
    },
    "dynamicGroupCumcount": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dynamicGroupCumcount.html",
        "signatures": [
            {
                "full": "dynamicGroupCumcount(membership, prevMembership, groupCount)",
                "name": "dynamicGroupCumcount",
                "parameters": [
                    {
                        "full": "membership",
                        "name": "membership"
                    },
                    {
                        "full": "prevMembership",
                        "name": "prevMembership"
                    },
                    {
                        "full": "groupCount",
                        "name": "groupCount"
                    }
                ]
            }
        ],
        "markdown": "### [dynamicGroupCumcount](https://docs.dolphindb.cn/zh/funcs/d/dynamicGroupCumcount.html)\n\n\n\n#### 语法\n\ndynamicGroupCumcount(membership, prevMembership, groupCount)\n\n#### 参数\n\n**membership** 整型向量，其元素必须是 \\[0, groupCount) 范围内的整数。用于记录事件在每个时间戳上对应的标签。\n\n**prevMembership** 整型向量，其元素可以为空值（对应序列的第一条记录）。用于记录事件在前一个时间戳上对应的标签。\n\n**groupCount** \\[2, 8] 之间的一个整数。表示函数返回值（元组）的长度，即需要统计的标签数。\n\n#### 详情\n\n通常一个事件的类别和属性是固定的。但在某些场景下，事件的类别会动态发生变化。如：在实时处理逐笔数据时，进行大小单的统计以对资金流进行分析。用户期望根据某个订单（事件的属性）的累计交易量来判断该订单是大单还是小单（事件的类别）。随着实时数据不断流入，交易量的不断增加，该订单的类别可能从一个小单变成大单。\n\n`dynamicGroupCumcount` 即可应用在这类场景下，用于统计在一个时间序列下，不同类别的累计事件数。\n\n具体算法如下：\n\n* 若 *membership* = *prevMembership*，统计量不变。\n\n* 若 *membership* ≠ *prevMembership*，*membership* 对应组的统计量加1，*prevMembership* 对应的组统计量减1。\n\n* 若 *prevMembership* 为空值（对应序列的第一条记录），*membership* 对应组的统计量加1，*prevMembership* 无对应组，无需处理。\n\n该函数返回一个长度为 *groupCount* 的元组，其每个元素是一个与 *membership* 等长的向量，依次记录了各标签统计的累积记录数。\n\n**Note:** 元组的下标与标签号一一对应，即标签为 0 的统计结果将输出至元组下标为 0 的向量。\n\n#### 例子\n\n数据预处理：\n\n```\n# 打标签函数\ndef tag_func(v){\n\n  return iif(v <= 5, 0, iif(v <= 10 and v > 5, 1, 2))\n// output\n}\n# 原始数据表\ntime = take(2022.01.01T09:00:00.000 + 1..3, 6)\nsym=`st0`st0`st0`st1`st1`st1\norderNo = `10001`10002`10001`10002`10003`10002\nvolume = 2 4 6 3 2 9\nt = table(sym, time, orderNo, volume)\n\n# 计算累计和并根据阈值打标签\nt1 = select *, cumsum(volume) as sumVolume from t context by sym, orderNo\nt2 = lj(t, t1,`sym`time`orderNo)\nt3 = select sym, time, orderNo, volume, sumVolume, tag_func(sumVolume) as groupId from t2\n```\n\n对于历史数据，可以使用 SQL 语句计算不同组的累计记录数：\n\n```\nt4 = select sym, time, orderNo, prev(groupId) as prevGroupId from t3 context by sym,orderNo\nt5 = lj(t3, t4,`sym`time`orderNo)\nre = select sym, time, orderNo, dynamicGroupCumcount(groupId, prevGroupId, 3) as `groupId0`groupId1`groupId2 from t5 context by sym\nre\n```\n\n| sym | time                    | orderNo | groupId0 | groupId1 | groupId2 |\n| --- | ----------------------- | ------- | -------- | -------- | -------- |\n| st0 | 2022.01.01T09:00:00.001 | 10001   | 1        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.002 | 10002   | 2        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.003 | 10001   | 1        | 1        | 0        |\n| st1 | 2022.01.01T09:00:00.001 | 10002   | 1        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.002 | 10003   | 2        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.003 | 10002   | 1        | 0        | 1        |\n\n对于实时数据，可以使用流数据引擎计算不同组的累计记录数：\n\n```\nresult = table(1000:0, `sym`time`orderNo`groupId0`groupId1`groupId2, [SYMBOL, TIME, SYMBOL,INT,INT,INT])\nfactor0 = [<time>,  <prev(groupId) as prevGroupId>, <groupId>, <volume>]\nfactor1 = [<time>, <orderNo>, <dynamicGroupCumcount(groupId, prevGroupId, 3)>]\ndm1 = table(1000:0, `sym`time`orderNo`volume`sumVolume`groupId, [SYMBOL, TIME, SYMBOL,INT, INT,INT])\ndm2 = table(1000:0, `sym`orderNo`time`prevGroupId`groupId`volume, [SYMBOL, SYMBOL, TIME, INT,INT,INT])\nres1 = createReactiveStateEngine(name=\"reactive_ccnt\", metrics =factor1, dummyTable=dm2, outputTable=result, keyColumn=`sym, keepOrder=true)\nres0 = createReactiveStateEngine(name=\"reactive_prev\", metrics =factor0, dummyTable=dm1, outputTable=res1, keyColumn=`sym`orderNo, keepOrder=true)\nres0.append!(t3)\n\nselect * from result\n```\n\n| sym | time                    | orderNo | groupId0 | groupId1 | groupId2 |\n| --- | ----------------------- | ------- | -------- | -------- | -------- |\n| st0 | 2022.01.01T09:00:00.001 | 10001   | 1        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.002 | 10002   | 2        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.003 | 10001   | 1        | 1        | 0        |\n| st1 | 2022.01.01T09:00:00.001 | 10002   | 1        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.002 | 10003   | 2        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.003 | 10002   | 1        | 0        | 1        |\n\n```\ndropStreamEngine(\"reactive_ccnt\")\ndropStreamEngine(\"reactive_prev\")\n```\n\n相关函数：[dynamicGroupCumsum](https://docs.dolphindb.cn/zh/funcs/d/dynamicGroupCumsum.html)\n"
    },
    "dynamicGroupCumsum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/d/dynamicGroupCumsum.html",
        "signatures": [
            {
                "full": "dynamicGroupCumsum(cumValue, prevCumValue, membership, prevMembership, groupCount)",
                "name": "dynamicGroupCumsum",
                "parameters": [
                    {
                        "full": "cumValue",
                        "name": "cumValue"
                    },
                    {
                        "full": "prevCumValue",
                        "name": "prevCumValue"
                    },
                    {
                        "full": "membership",
                        "name": "membership"
                    },
                    {
                        "full": "prevMembership",
                        "name": "prevMembership"
                    },
                    {
                        "full": "groupCount",
                        "name": "groupCount"
                    }
                ]
            }
        ],
        "markdown": "### [dynamicGroupCumsum](https://docs.dolphindb.cn/zh/funcs/d/dynamicGroupCumsum.html)\n\n\n\n#### 语法\n\ndynamicGroupCumsum(cumValue, prevCumValue, membership, prevMembership, groupCount)\n\n#### 参数\n\n**cumValue** 数值型向量，用于记录事件在每个时间戳上对应的累计值。\n\n**prevCumValue** 数值型向量，其元素可以为空值（对应序列的第一条记录）。用于记录事件在前一个时间戳上对应的累计值。\n\n**membership** 整型向量，其元素必须是 \\[0, groupCount) 范围内的整数。用于记录事件在每个时间戳上对应的标签。\n\n**prevMembership** 整型向量，其元素可以为空值（对应序列的第一条记录）。用于记录事件在前一个时间戳上对应的标签。\n\n**groupCount** \\[2, 8] 之间的一个整数。表示函数返回值（元组）的长度，即需要统计的标签数。\n\n#### 详情\n\n通常一个事件的类别和属性是固定的。但在某些场景下，事件的类别会动态发生变化。如：在实时处理逐笔数据时，进行大小单的统计以对资金流进行分析。用户期望根据某个订单（事件的属性）的累计交易量来判断该订单是大单还是小单（事件的类别）。随着实时数据不断流入，交易量的不断增加，该订单的类别可能从一个小单变成大单。\n\n`dynamicGroupCumsum` 即可应用在这类场景下，用于统计在一个时间序列下，某个事件指标在不同类别下的累计值。\n\n具体算法如下：\n\n* 若 *membership* = *prevMembership*，统计量不变。\n\n* 若 *membership* ≠ *prevMembership*，*membership* 对应组的统计量加 *cumValue*，*prevMembership* 对应的组统计量减 prevCumValue。\n\n* 若 *prevMembership* 为空值（对应序列的第一条记录），*membership* 对应组的统计量加 *cumValue*，*prevMembership* 无对应组，无需处理。\n\n该函数返回一个长度为 *groupCount* 的元组，其每个元素是一个与 *membership* 等长的向量，依次记录了某指标（*cumValue* 对应的列）在各标签下的累积和。\n\n**Note:** 元组的下标与标签号一一对应，即标签为 0 的统计结果将输出至元组下标为 0 的向量。\n\n#### 例子\n\n数据预处理：\n\n```\n// 打标签函数\ndef tag_func(v){\n\n  return iif(v <= 5, 0, iif(v <= 10 and v > 5, 1, 2))\n// output\n}\n// 原始数据表\ntime = take(2022.01.01T09:00:00.000 + 1..3, 6)\nsym=`st0`st0`st0`st1`st1`st1\norderNo = `10001`10002`10001`10002`10003`10002\nvolume = 2 4 6 3 2 9\nt = table(sym, time, orderNo, volume)\n\n// 计算累计和并根据阈值打标签\nt1 = select *, cumsum(volume) as sumVolume from t context by sym, orderNo\nt2 = lj(t, t1,`sym`time`orderNo)\nt3 = select sym, time, orderNo, volume, sumVolume, tag_func(sumVolume) as groupId from t2\n```\n\n对于历史数据，可以使用 SQL 语句计算不同组的累计成交量：\n\n```\nt4 = select sym, time, orderNo, prev(groupId) as prevGroupId, groupId, prev(sumVolume) as prevSumVolume, sumVolume from t3 context by sym,orderNo\nt5 = lj(t3, t4,`sym`time`orderNo)\nre = select sym, time, orderNo, dynamicGroupCumsum(sumVolume, prevSumVolume, groupId, prevGroupId, 3) as `groupId0`groupId1`groupId2 from t5 context by sym\nre\n```\n\n| sym | time                    | orderNo | groupId0 | groupId1 | groupId2 |\n| --- | ----------------------- | ------- | -------- | -------- | -------- |\n| st0 | 2022.01.01T09:00:00.001 | 10001   | 2        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.002 | 10002   | 6        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.003 | 10001   | 4        | 8        | 0        |\n| st1 | 2022.01.01T09:00:00.001 | 10002   | 3        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.002 | 10003   | 5        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.003 | 10002   | 2        | 0        | 12       |\n\n对于实时数据，可以使用流数据引擎计算不同组的累计成交量：\n\n```\nresult = table(1000:0, `sym`time`orderNo`groupId0`groupId1`groupId2, [SYMBOL, TIME, SYMBOL,INT,INT,INT])\nfactor0 = [ <time>, <prev(groupId) as prevGroupId>, <groupId>, <prev(sumVolume) as prevSumVolume>, <sumVolume>]\nfactor1 = [<time>, <orderNo>, <dynamicGroupCumsum(sumVolume, prevSumVolume, groupId, prevGroupId, 3)>]\ndm1 = table(1000:0, `sym`time`orderNo`volume`sumVolume`groupId, [SYMBOL, TIME, SYMBOL,INT, INT,INT])\ndm2 = table(1000:0, `sym`orderNo`time`prevGroupId`groupId`prevSumVolume`sumVolume, [SYMBOL, SYMBOL, TIME, INT, INT, INT, INT])\nres1 = createReactiveStateEngine(name=\"reactive_csum\", metrics =factor1, dummyTable=dm2, outputTable=result, keyColumn=`sym, keepOrder=true)\nres0 = createReactiveStateEngine(name=\"reactive_prev\", metrics =factor0, dummyTable=dm1, outputTable=res1, keyColumn=`sym`orderNo, keepOrder=true)\nres0.append!(t3)\n\nselect * from result\n```\n\n| sym | time                    | orderNo | groupId0 | groupId1 | groupId2 |\n| --- | ----------------------- | ------- | -------- | -------- | -------- |\n| st0 | 2022.01.01T09:00:00.001 | 10001   | 2        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.002 | 10002   | 6        | 0        | 0        |\n| st0 | 2022.01.01T09:00:00.003 | 10001   | 4        | 8        | 0        |\n| st1 | 2022.01.01T09:00:00.001 | 10002   | 3        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.002 | 10003   | 5        | 0        | 0        |\n| st1 | 2022.01.01T09:00:00.003 | 10002   | 2        | 0        | 12       |\n\n```\ndropStreamEngine(\"reactive_csum\")\ndropStreamEngine(\"reactive_prev\")\n```\n\n相关函数：[dynamicGroupCumcount](https://docs.dolphindb.cn/zh/funcs/d/dynamicGroupCumcount.html)\n"
    },
    "eig": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/eig.html",
        "signatures": [
            {
                "full": "eig(A)",
                "name": "eig",
                "parameters": [
                    {
                        "full": "A",
                        "name": "A"
                    }
                ]
            }
        ],
        "markdown": "### [eig](https://docs.dolphindb.cn/zh/funcs/e/eig.html)\n\n\n\n#### 语法\n\neig(A)\n\n#### 参数\n\n**A** 是一个实对称矩阵或 Hermitian（共轭对称）矩阵。\n\n#### 详情\n\n返回一个字典，为矩阵 A 的特征值与特征向量。\n\n该函数的计算结果与 `numpy.linalg.eigh` 函数的结果保持一致。\n\n#### 例子\n\n```\nA = 1 1 2 7 9 3 5 7 0 $ 3:3;\neig(A);\n// output\nvectors->\n#0        #1       #2\n--------- -------- ---------\n0.839752  0.169451 -0.515852\n-0.301349 0.935753 -0.18318\n0.45167   0.309277 0.836864\n\nvalues->[1.716868,10.17262,-1.889488]\n```\n\n对应第一个特征值 1.716868 的特征向量为：\n\n```\neig(A).vectors[0];\n// output\n[0.839752,-0.301349,0.45167]\n```\n"
    },
    "elasticNet": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/elasticNet.html",
        "signatures": [
            {
                "full": "elasticNet(ds, yColName, xColNames, [alpha=1.0], [l1Ratio=0.5], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])",
                "name": "elasticNet",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alpha=1.0]",
                        "name": "alpha",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[l1Ratio=0.5]",
                        "name": "l1Ratio",
                        "optional": true,
                        "default": "0.5"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[positive=false]",
                        "name": "positive",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    },
                    {
                        "full": "[checkInput=true]",
                        "name": "checkInput",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [elasticNet](https://docs.dolphindb.cn/zh/funcs/e/elasticNet.html)\n\n\n\n#### 语法\n\nelasticNet(ds, yColName, xColNames, \\[alpha=1.0], \\[l1Ratio=0.5], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[positive=false], \\[swColName], \\[checkInput=true])\n\n#### 参数\n\n**ds** 是内存表或通常用 [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html) 函数生成的数据源。\n\n**yColName** 是字符串，表示数据源中因变量的列名。\n\n**xColNames** 是字符串标量或向量，表示数据源中自变量的列名。\n\n**alpha** 是浮点数，表示乘以 L1 范数惩罚项的系数。默认值是1.0。\n\n**l1Ratio** 是0与1之间的浮点数，表示 L1 范数惩罚项所占比例。若 *l1Ratio*=0，只有 L2 范数惩罚项。若 *l1Ratio*=1，只有 L1 范数惩罚项。默认值为0.5。\n\n**intercept** 是布尔值，表示是否回归模型包含截距。默认值为true。\n\n**normalize** 是布尔值。默认值为 false。若设为 true，则所有自变量均会进行如下标准化：减去平均值，然后除以 L2 范数。若 intercept 为 false，该参数会被忽略。\n\n**maxIter** 是正整数，表示最大迭代次数。默认值是1000。\n\n**tolerance** 是浮点数，表示迭代中止的边界差值。默认值是0.0001。\n\n**positive** 是布尔值，表示是否强制系数为正数。默认值是 false。\n\n**swColName** 字符串，表示列名，必须为 ds 中存在的列名。如果未指定该参数，则所有样本的权重都默认为1；如果指定该参数，则将指定的列作为样本的权重。\n\n**checkInput** 布尔值，表示是否检查输入参数（*yColName*, *xColNames* 和 *swColName*）的合法性。\n\n* 若 *checkInput*=true（默认值），则会检查这些参数中是否存在无效值（NULL），若存在，则会报错；\n\n* 若 *checkInput*=false，则不检查无效值。\n\n**Important:** 强烈建议开启 *checkInput*，以检查输入参数的有效性。如果不开启 *checkInput*，则必须确保输入参数中不存在无效值，并且中间计算过程中不会产生无效值，否则可能得到一个无用的模型。\n\n#### 详情\n\n进行弹性网络回归（ElasticNet 回归）计算。即最小化以下目标函数：\n\n![](https://docs.dolphindb.cn/zh/images/elasticnet.png)\n\n#### 例子\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288]\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599]\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219]\nt = table(y, x0, x1)\nelasticNet(t, `y, `x0`x1);\n```\n\n如果 t 是一个 DFS 表，则应使用数据源作为输入：\n\n```\nelasticNet(sqlDS(<select * from t>), `y, `x0`x1);\n```\n"
    },
    "elasticNetBasic": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/elasticNetBasic.html",
        "signatures": [
            {
                "full": "elasticNetBasic(Y, X, [mode=0], [alpha=1.0], [l1Ratio=0.5], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])",
                "name": "elasticNetBasic",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[alpha=1.0]",
                        "name": "alpha",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[l1Ratio=0.5]",
                        "name": "l1Ratio",
                        "optional": true,
                        "default": "0.5"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[positive=false]",
                        "name": "positive",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    },
                    {
                        "full": "[checkInput=true]",
                        "name": "checkInput",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [elasticNetBasic](https://docs.dolphindb.cn/zh/funcs/e/elasticNetBasic.html)\n\n\n\n#### 语法\n\nelasticNetBasic(Y, X, \\[mode=0], \\[alpha=1.0], \\[l1Ratio=0.5], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[positive=false], \\[swColName], \\[checkInput=true])\n\n#### 详情\n\n进行弹性网络回归（ElasticNet 回归）计算。即最小化以下目标函数：\n\n![](https://docs.dolphindb.cn/zh/images/elasticnet.png)\n\n#### 参数\n\n`Y` 数值类型的向量，表示因变量。\n\n`X` 数值类型的向量/元组/矩阵/表，表示自变量。\n\n* 当 *X* 是向量/元组时，其长度必须等于 Y 的长度。\n\n* 当 *X* 是矩阵/表时，其行数必须等于 Y 的长度。\n\n`mode` 一个整数，可取以下 3 个值\n\n* 0（默认值）: 输出一个系数估计向量\n\n* 1: 输出一个具有系数估计，标准差，t 统计量和 p 值的表\n\n* 2: 输出一个具有 ANOVA(方差分析)、RegressionStat(回归统计)、Cofficient(系数) 和 Residual(残差) 的字典，具体含义见下表：\n\n键 ANOVA 对应值：\n\n<table id=\"table_xvj_w4c_zzb\"><thead><tr><th>\n\nSource of Variance\n\n</th><th>\n\n自由度(Degree of freedom)\n\n</th><th>\n\n平方和(Sum of Square)\n\n</th><th>\n\n均方差(Mean of square)\n\n</th><th>\n\nF统计量\n\n</th><th>\n\nSignificance\n\n</th></tr></thead><tbody><tr><td>\n\nRegression(回归)\n\n</td><td>\n\n变量个数(p)\n\n</td><td>\n\n回归平方和(SSR)\n\n</td><td>\n\n回归均方差(MSR=SSR/R)\n\n</td><td>\n\nMSR对MSE的比值\n\n</td><td>\n\n显著性，即统计出的P值\n\n</td></tr><tr><td>\n\nResidual(残差)\n\n</td><td>\n\n残差自由度(n-p-1)\n\n</td><td>\n\n残差平方和(SSE)\n\n</td><td>\n\n残差均方差(MSE=MSE/E)\n\n</td><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\nTotal\n\n</td><td>\n\n样本自由度， 不包括常数项(n-1)\n\n</td><td>\n\n总离差平方和(SST)\n\n</td><td>\n\n</td><td>\n\n</td><td>\n\n</td></tr></tbody>\n</table>键 RegressionStat 对应值：\n\n<table id=\"table_cjq_y4c_zzb\"><thead><tr><th>\n\nitem\n\n</th><th>\n\n统计值\n\n</th></tr></thead><tbody><tr><td>\n\nR2\n\n</td><td>\n\nR决定系数，描述回归曲线对真实数据点拟合程度的统计量。范围在 \\[0,1]之间，越接近1 ，说明对y的解释能力越强，拟合越好。\n\n</td></tr><tr><td>\n\nAdjustedR2\n\n</td><td>\n\n经自由度修正后的决定系数，通过样本数量与模型数量对 R-squared 进行修正。\n\n</td></tr><tr><td>\n\nStdError\n\n</td><td>\n\n回归残差标准误差，残差经自由度修正后的标准差。\n\n</td></tr><tr><td>\n\nObservations\n\n</td><td>\n\n观察样本个数。\n\n</td></tr></tbody>\n</table>键 Coefficient 对应值：\n\n<table id=\"table_cjj_1pc_zzb\"><thead><tr><th>\n\n元素\n\n</th><th>\n\n说明\n\n</th></tr></thead><tbody><tr><td>\n\nfactor\n\n</td><td>\n\n自变量名称\n\n</td></tr><tr><td>\n\nbeta\n\n</td><td>\n\n回归系数估计值\n\n</td></tr><tr><td>\n\nstdError\n\n</td><td>\n\n回归系数标准误差。\n\n</td></tr><tr><td>\n\ntstat\n\n</td><td>\n\nT统计值，衡量系数的统计显著性。\n\n</td></tr></tbody>\n</table>键 Residual 对应每一个预测值和实际值之间的残差。\n\n`alpha` 一个浮点数，表示乘以L1范数惩罚项的系数。默认值是1.0。\n\n`l1Ratio` 0与1之间的浮点数，表示L1范数惩罚项所占比例。若 l1Ratio=0，只有L2范数惩罚项。若 l1Ratio=1，只有L1范数惩罚项。默认值为0.5。\n\n`intercept` 布尔值，表示是否包含回归中的截距。默认值为 true，此时系统自动给 *X* 添加一列 “1” 以生成截距。\n\n`normalize` 布尔值，默认值为 false。若设为 true，则所有自变量均会进行如下标准化：减去平均值，然后除以L2范数。若 intercept 为 false，该参数会被忽略。\n\n`maxIter` 一个正整数，表示最大迭代次数。默认值是1000。\n\n`tolerance` 一个浮点数，表示迭代中止的边界差值。默认值是0.0001。\n\n`positive` 布尔值，表示是否强制系数为正数。默认值是 false。\n\n`swColName` 字符串，表示列名，必须为 X 中存在的列名。如果未指定该参数，则所有样本的权重都默认为1；如果指定该参数，则将指定的列作为自变量的权重。\n\n`checkInput` 布尔值，表示是否检查输入参数（yColName, xColNames 和 swColName）的合法性。\n\n* 若 checkInput=true（默认值），则会检查这些参数中是否存在无效值（NULL），若存在，则会报错；\n\n* 若 checkInput=false，则不检查无效值。\n\n**Important:** 强烈建议开启 checkInput，以检查输入参数的有效性。如果不开启 checkInput，则必须确保输入参数中不存在无效值，并且中间计算过程中不会产生无效值，否则可能得到一个无用的模型。\n"
    },
    "elasticNetCV": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/elasticNetCV.html",
        "signatures": [
            {
                "full": "elasticNetCV(ds, yColName, xColNames, [alpha=[0.01,0.1,1.0]], [l1Ratio=0.5], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false])",
                "name": "elasticNetCV",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alpha=[0.01",
                        "name": "[alpha=[0.01"
                    },
                    {
                        "full": "0.1",
                        "name": "0.1"
                    },
                    {
                        "full": "1.0]]",
                        "name": "1.0]]"
                    },
                    {
                        "full": "[l1Ratio=0.5]",
                        "name": "l1Ratio",
                        "optional": true,
                        "default": "0.5"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[positive=false]",
                        "name": "positive",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [elasticNetCV](https://docs.dolphindb.cn/zh/funcs/e/elasticNetCV.html)\n\n#### 语法\n\nelasticNetCV(ds, yColName, xColNames, \\[alpha=\\[0.01,0.1,1.0]], \\[l1Ratio=0.5], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[positive=false])\n\n#### 详情\n\n使用五折交叉验证方法进行弹性网络回归（ElasticNet），输出最优参数对应的模型。结果为一个字典，包含以下 key：\n\n* modelName：模型名称。elasticNetCV 方法对应的模型名为 \"elasticNetCV\"。\n* coefficients：模型的回归系数。\n* intercept：截距。\n* dual\\_gap：表示优化结束时的对偶间隙。\n* tolerance：迭代中止的边界差值。\n* iterations：迭代次数\n* xColNames：数据源中自变量的列名。\n* predict：用于预测的函数。\n* alpha：交叉验证选择的惩罚量。\n\n#### 参数\n\n**alpha** 是浮点型标量或向量，表示乘以L1范数惩罚项的系数。默认值是 \\[0.01, 0.1, 1.0]。\n\n**Note:** 除 *alphas* 参数外，其它参数都和 [elasticNet](https://docs.dolphindb.cn/zh/funcs/e/elasticNet.html) 的参数相同，参数描述可参考 [elasticNet](https://docs.dolphindb.cn/zh/funcs/e/elasticNet.html)。这里仅说明 *alphas* 参数。\n\n#### 例子\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288]\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599]\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219]\nt = table(y, x0, x1);\n\nelasticNetCV(t, `y, `x0`x1);\n```\n\n返回如下：\n\n```\ndual_gap->0.0037\nmodelName->elasticNetCV\nintercept->0.5416\nalpha->0.0100\ncoefficients->[93.8331,13.9105]\npredict->coordinateDescentPredict\nxColNames->[x0,x1]\ntolerance->0.0001\niterations->5\n```\n\n"
    },
    "ema": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/ema.html",
        "signatures": [
            {
                "full": "ema(X, window, warmup=false)",
                "name": "ema",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "warmup=false",
                        "name": "warmup=false"
                    }
                ]
            }
        ],
        "markdown": "### [ema](https://docs.dolphindb.cn/zh/funcs/e/ema.html)\n\n\n\n#### 语法\n\nema(X, window, warmup=false)\n\nTA-lib 系列函数参数说明和窗口计算规则请参考: [TA-lib 系列](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 参数\n\n**warmup** 布尔值，默认为 false，即计算结果的前 *window*-1 个元素为空值。若为 true，则结果的前 *window*-1 元素将由详情给出的公式计算得出。\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的指数移动平均（Exponential Moving Average）。\n\n其计算公式为：\n\n* *warmup*=false：\n\n![EMA\\_k](https://docs.dolphindb.cn/zh/images/ema_k.png)\n\n* *warmup*=true:\n\n![EMA\\_ktrue](https://docs.dolphindb.cn/zh/images/ema_ktrue.png)\n\n其中：![EMA\\_k1](https://docs.dolphindb.cn/zh/images/EMA_k1.png)为第k个指数移动平均值，![n](https://docs.dolphindb.cn/zh/images/n.png)为移动窗口长度，![xk](https://docs.dolphindb.cn/zh/images/xk.png)为向量 ![x](https://docs.dolphindb.cn/zh/images/x.png)中第 k 个元素。\n\n#### 例子\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\nema(x,3);\n// output\n[,,12.3,12.55,12.225,11.9125,11.55625]\n\nema(x,3, warmup=true)\n// output\n[12.1,12.2,12.4667,12.6333,12.2667,11.9333,11.5667]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\nema(x,3);\n```\n\n| #0       | #1        |\n| -------- | --------- |\n|          |           |\n|          |           |\n| 12.30    | 15.666667 |\n| 12.55    | 17.333333 |\n| 12.225   | 19.166667 |\n| 11.9125  | 15.583333 |\n| 11.55625 | 12.791667 |\n\n相关函数：[gema](https://docs.dolphindb.cn/zh/funcs/g/gema.html), [wilder](https://docs.dolphindb.cn/zh/funcs/w/wilder.html), [dema](https://docs.dolphindb.cn/zh/funcs/d/dema.html), [tema](https://docs.dolphindb.cn/zh/funcs/t/tema.html)\n"
    },
    "enableActivePartition": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/enableActivePartition.html",
        "signatures": [
            {
                "full": "enableActivePartition(db, activeDate, siteAlias)",
                "name": "enableActivePartition",
                "parameters": [
                    {
                        "full": "db",
                        "name": "db"
                    },
                    {
                        "full": "activeDate",
                        "name": "activeDate"
                    },
                    {
                        "full": "siteAlias",
                        "name": "siteAlias"
                    }
                ]
            }
        ],
        "markdown": "### [enableActivePartition](https://docs.dolphindb.cn/zh/funcs/e/enableActivePartition.html)\n\n\n\n#### 语法\n\nenableActivePartition(db, activeDate, siteAlias)\n\n#### 参数\n\n**db** 是历史数据库的句柄。\n\n**activeDate** 是活动数据库的日期。\n\n**setAlias** 是活动数据库所在节点的别名。\n\n#### 详情\n\n创建活动数据库和历史数据库之间的连接。\n\n#### 例子\n\n```\nhistdb = database(\"C:\\DolphinDBDemo\\example\\data\\dbspace\\historical-A\\Trades2ndDomain\")\nactiveNodeAlias = getNodeAlias()\nactiveDate = today()\nenableActivePartition(histdb, activeDate, activeNodeAlias);\n```\n"
    },
    "enableQueryMonitor": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/enableQueryMonitor.html",
        "signatures": [
            {
                "full": "enableQueryMonitor()",
                "name": "enableQueryMonitor",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [enableQueryMonitor](https://docs.dolphindb.cn/zh/funcs/e/enableQueryMonitor.html)\n\n\n\n#### 语法\n\nenableQueryMonitor()\n\n#### 参数\n\n无\n\n#### 详情\n\n启用监控查询任务状态的功能。系统默认会开启该功能。\n\n相关函数： [disableQueryMonitor](https://docs.dolphindb.cn/zh/funcs/d/disableQueryMonitor.html)\n"
    },
    "enableResourceTracking": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/enableresourcetracking.html",
        "signatures": [
            {
                "full": "enableResourceTracking()",
                "name": "enableResourceTracking",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [enableResourceTracking](https://docs.dolphindb.cn/zh/funcs/e/enableresourcetracking.html)\n\n\n\n#### 语法\n\nenableResourceTracking()\n\n#### 参数\n\n无\n\n#### 详情\n\n在线开启资源跟踪。仅当 *resourceSamplingInterval* 设置为正整数时才能调用该函数。该函数仅限管理员在数据节点上调用。\n\n成功启动资源跟踪后，各个数据节点会根据 *resourceSamplingInterval* 设置的时间间隔获取以下资源：CPU 和内存使用量、查询分布式表的信息。\n\n* CPU 和内存使用量写入一个 CSV 日志文件，路径是 `<HomeDir>/resource/hardware.log`。日志记录了以下信息：\n\n  * timestamp：NANOTIMESTAMP 类型的时间戳。\n\n  * userId：登录用户名。\n\n  * cpu：当前用户占用的工作线程数量。\n\n  * memory：内存使用量，当前用户使用的所有变量的内存占用大小。单位是字节。\n\n* 查询分布式表的信息写入另一个 CSV 日志文件，路径是`<HomeDir>/resource/access.log`。目前仅支持 SQL SELECT 语句，并且在跟踪过程中不会记录非标准 SQL-92 嵌套表连接中的表信息，例如在 ej(ej(t1, t2, \\`id), t3, \\`id) 查询中，t1 和 t2 的信息将不会被记录。日志记录了以下内容：\n\n  * timestamp：NANOTIMESTAMP 类型的时间戳。如果 type 是 sql，则这里记录开始执行 SQL 的时间戳；如果 type 是 rowCount 或 memUsage，则这里记录的是读出数据的时间戳。\n\n  * rootQueryId：SQL 查询任务的 ID，是分布式 SQL 查询任务的唯一标识符。一个分布式查询会按分区拆分为多个 SQL 子查询。该 ID 为分布式查询及其拆分出的子查询的根 ID。\n\n  * userId：用户名。\n\n  * database：数据库名。\n\n  * table：表名。\n\n  * type：记录的信息类型，包括3类：sql, rowCount, memUsage。\n\n  * value：\n\n    * 当类型为 sql 时，为 SQL 查询任务的执行次数。该值总是为1。\n\n    * 当类型为 rowCount 时，为读出的行数。\n\n    * 当类型为 memUsage 时，为读出的表的数据量。单位是字节。\n\n注意：这里只记录每次访问表的行数和数据量。例如维度表读入内存后，会记录每次访问该表的行数和数据量，而非第一次读入内存的数据量。\n\n* script：当类型为 sql 时，记录 SQL 脚本，其他类型则为空字符串。\n\n为防止文件大小持续增长，DolphinDB 对这两个文件都采用日志滚动策略，一旦文件大小达到阈值就会生成滚动日志文件。文件名以时间戳作为前缀。例如20231101162302\\_access.log，表示 2023.11.01T16:23:02 拆分出来的滚动日志。\n\n系统会根据 *resourceSamplingLogRetentionTime* 的配置值自动清理资源跟踪日志。此自动清理机制不受资源跟踪功能的开启或关闭影响。\n\n相关函数：[disableResourceTracking](https://docs.dolphindb.cn/zh/funcs/d/disableresourcetracking.html)\n"
    },
    "enableTableCachePurge": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/enabletablecachepurge.html",
        "signatures": [
            {
                "full": "enableTableCachePurge(table, [cacheSize],[cachePurgeTimeColumn],[cachePurgeInterval],[cacheRetentionTime])",
                "name": "enableTableCachePurge",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "[cacheSize]",
                        "name": "cacheSize",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeTimeColumn]",
                        "name": "cachePurgeTimeColumn",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeInterval]",
                        "name": "cachePurgeInterval",
                        "optional": true
                    },
                    {
                        "full": "[cacheRetentionTime]",
                        "name": "cacheRetentionTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [enableTableCachePurge](https://docs.dolphindb.cn/zh/funcs/e/enabletablecachepurge.html)\n\n\n\n#### 语法\n\nenableTableCachePurge(table, \\[cacheSize],\\[cachePurgeTimeColumn],\\[cachePurgeInterval],\\[cacheRetentionTime])\n\n#### 参数\n\n**table** 是一个空的流数据表。\n\n**cacheSize** 是一个正整数，可选参数，表示流数据表在内存中最多保留的记录数。\n\n**cachePurgeTimeColumn** 字符串标量，需要指定为持久化流表中的时间列名称。\n\n**cachePurgeInterval** DURATION 类型标量，表示触发清理内存中数据的时间间隔。\n\n**cacheRetentionTime** DURATION 类型标量，表示内存中数据的最长保留期限。\n\n#### 详情\n\n为非持久化流表开启自动清理缓存。\n\n通过以下两种方式之一来清理内存中的数据：\n\n* 配置 *cacheSize* 参数时，如果插入的数据使内存中流数据表的行数达到阈值，系统将清理内存中较旧的已发布记录。阈值确定方法如下：\n\n  * 每次 append 的数据都不超过 *cacheSize* 时，阈值为 *cacheSize* 的 2.5 倍。\n\n  * 当 append 的数据超过 *cacheSize* 时，阈值为追加行数和 cacheSize 之和的 1.2 倍。\n\n* 同时配置*cachePurgeTimeColumn*, *cachePurgeInterval* 和 *cacheRetentionTime*，系统将根据时间列清理数据。每次插入新数据时，系统会计算新数据与内存中第一条数据的时间戳差值，当差值大于等于 *cachePurgeInterval*时，系统仅保留时间戳与新数据时间戳差值小于等于 *cacheRetentionTime*的数据，清理其它数据。\n\n#### 例子\n\n例1. 配置 cacheSize 参数，根据内存中的数据量进行清理。\n\n```\nt = streamTable(1000:0, `time`sym`volume, [DATETIME, SYMBOL, INT])\nenableTableCachePurge(table=t, cacheSize=1000)\ntime = datetime(2024.01.01T09:00:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\n\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n//0\n\ntime = datetime(2024.01.01T09:35:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n//500\n```\n\n例2. 配置*cachePurgeTimeColumn*, *cachePurgeInterval* 和 \\*cacheRetentionTime，\\*根据时间列清理数据。\n\n```\nt = streamTable(1000:0, `time`sym`volume, [DATETIME, SYMBOL, INT])\n\nenableTableCachePurge(table=t, cachePurgeTimeColumn=`time,\n cachePurgeInterval=30m, cacheRetentionTime=20m)\n\ntime = datetime(2024.01.01T09:00:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\n\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n//0\n\ntime = datetime(2024.01.01T09:35:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n//999\n```\n"
    },
    "enableTablePersistence": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/enableTablePersistence.html",
        "signatures": [
            {
                "full": "enableTablePersistence(table, [asynWrite=true], [compress=true], [cacheSize], [retentionMinutes=1440], [flushMode=0],[cachepurgeTimeColumn],[cachePurgeInterval],[cacheRetentionTime])",
                "name": "enableTablePersistence",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "[asynWrite=true]",
                        "name": "asynWrite",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[compress=true]",
                        "name": "compress",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[cacheSize]",
                        "name": "cacheSize",
                        "optional": true
                    },
                    {
                        "full": "[retentionMinutes=1440]",
                        "name": "retentionMinutes",
                        "optional": true,
                        "default": "1440"
                    },
                    {
                        "full": "[flushMode=0]",
                        "name": "flushMode",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[cachepurgeTimeColumn]",
                        "name": "cachepurgeTimeColumn",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeInterval]",
                        "name": "cachePurgeInterval",
                        "optional": true
                    },
                    {
                        "full": "[cacheRetentionTime]",
                        "name": "cacheRetentionTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [enableTablePersistence](https://docs.dolphindb.cn/zh/funcs/e/enableTablePersistence.html)\n\n\n\n#### 语法\n\nenableTablePersistence(table, \\[asynWrite=true], \\[compress=true], \\[cacheSize], \\[retentionMinutes=1440], \\[flushMode=0],\\[cachepurgeTimeColumn],\\[cachePurgeInterval],\\[cacheRetentionTime])\n\n#### 参数\n\n**table** 是一个空的流数据表。\n\n**asynWrite** 是一个布尔值，表示是否异步持久化数据到磁盘。默认值为 true，流数据写入内存即为写入成功，持久化到磁盘的操作将会由另一个线程执行。\n\n**Note:**\n\n持久化数据到磁盘包含两个步骤：\n\n* 写内存数据到操作系统缓存\n\n* 写缓存数据到磁盘（是否开启同步刷盘由参数 *flushMode* 决定）\n\n**compress** 是一个布尔值。可选参数，表示是否以压缩模式模式保存至磁盘。默认值为 true。\n\n**cacheSize** 整数，可选参数，表示流数据表在内存中最多保留多少行。如果它为0或者没有指定，所有记录行都会保存在内存中。如果 *cacheSize* 设置为小于 1000 的正整数，它会被自动调整为 1000。\n\n**retentionMinutes** 是一个整数，表示保留大小超过 1GB 的 log 文件的时间（从文件的最后修改时间开始计算），单位是分钟。默认值是 1440，即一天。\n\n**flushMode** 是一个整数，表示是否开启同步刷盘，取值只能为 0 或 1。默认值是 0，表示异步刷盘，内存中的流数据写入操作系统缓存即为写入成功，并进行下一批数据的写入。 若为 1，则表示同步刷盘，当前批次的流数据必须落盘完成，才会进行下一批数据的写入。\n\n**cachePurgeTimeColumn** 字符串标量，需要指定为持久化流表中的时间列名称。\n\n**cachePurgeInterval** DURATION 类型标量，表示触发清理内存中数据的时间间隔。\n\n**cacheRetentionTime** DURATION 类型标量，表示内存中数据的最长保留期限。\n\n**Note:** 自 3.00.2 版本起，该函数要求参数 *cacheRetentionTime* 必须小于 *cachePurgeInterval*。\n\n#### 详情\n\n该命令将共享的流计算表保存到磁盘上。\n\n为保证该命令能够正常执行，需要在配置文件中（单节点：`dolohindb.cfg`，集群：`cluster.cfg`）指定配置参数 *persistenceDir*，配置参考 [功能配置](https://docs.dolphindb.cn/zh/db_distr_comp/cfg/function_configuration.html)。流数据表在磁盘上的存储目录是 `<PERSISTENCE_DIR>/<TABLE_NAME>`。目录包含两种类型的文件：数据文件（名称类型 *data0.log, data1.log...*）和索引文件 *index.log* 。把这些数据保存到磁盘后，如果重启系统，该命令会把磁盘中的数据加载到内存中。\n\n参数 *asynWrite* 会告知系统是否以异步模式保存表。在异步模式中，追加的数据会被放进队列，之后用于保存的工作线程把数据写入磁盘。在同步模式中，表的追加数据操作直到追加数据被保存到磁盘中才完成。该参数的默认值是 true，即为异步模式。通常情况下，异步模式实现更高的吞吐量，但是如果服务器崩溃，可能会丢失最后追加的行。在异步模式中，保存表的工作是由单个工作线程完成，并且一个工作线程可能处理多个表。如果只保存一个表，增加工作线程的数量并不会提升性能。\n\n默认情况下，流数据表将所有数据保存在内存中。如果流数据表太大，系统可能会出现内存不足的情况。为了避免内存不足的问题，可以通过以下两种方式之一来清理内存中的数据：\n\n* 配置 *cacheSize* 参数时，如果插入的数据使内存中流数据表的行数达到 *cacheSize* 设置的阈值，系统将清理内存中较旧的已发布记录。阈值确定规则如下：\n\n  * 每次 append 的数据都不超过 *cacheSize* 时，内存中的记录数不会大于 *cacheSize* 的 2.5 倍。\n  * 否则，当 append 的数据超过 *cacheSize* 时，内存中的记录数不会超过追加行数和 *cacheSize* 之和的 1.2 倍。\n* 同时配置*cachePurgeTimeColumn*, *cachePurgeInterval* 和 *cacheRetentionTime*，系统将根据时间列清理数据。每次插入新数据时，系统会计算新数据与内存中第一条数据的时间戳差值，当差值大于等于 *cachePurgeInterval*时，系统仅保留时间戳与新数据时间戳差值小于等于 *cacheRetentionTime*的数据，清理其它数据。\n\n**Note:**\n\n* 如果手动重启 server，建议调用 [fflush](https://docs.dolphindb.cn/zh/funcs/f/fflush.html) 函数先把缓存区的数据写入磁盘再使用 `kill -15` 命令终止进程。\n\n* 如果设置 *flushMode*=0，则 server 发生 crash 时可能会丢失一部分数据。\n\n#### 例子\n\n例1.\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt = streamTable(100:0, colName, colType);\nshare t as st\n\nenableTablePersistence(table=st, cacheSize=1200000)\n\nfor(s in 0:200){\n  n=10000\n  time=2019.01.01T00:00:00.000+s*n+1..n\n  x=rand(10.0, n)\n  insert into st values(time, x)\n}\n\ngetPersistenceMeta(st);\n\n/* output: \npersistenceDir->/data/ssd/DolphinDBDemo/persistence3/st\nretentionMinutes->1440\nhashValue->0\nasynWrite->true\ndiskOffset->0\nsizeInMemory->800000\ncompress->1\nmemoryOffset->1200000\ntotalSize->2000000\nsizeOnDisk->2000000\n*/\n```\n\n**Note:**\n\n以上代码先使用 `share` 命令共享流数据表，再通过 `enableTablePersistence` 命令持久化流数据表。我们推荐使用 [enableTableShareAndPersistence](https://docs.dolphindb.cn/zh/funcs/e/enableTableShareAndPersistence.html) 函数将共享和持久化组织成原子性操作。\n\n例2. 本例将说明 *cachePurgeTimeColumn*, *cachePurgeInterval* 和 *cacheRetentionTime* 的使用方法。\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt1 = streamTable(100:0, colName, colType);\nshare t1 as st1\n\nenableTablePersistence(table=st,cachePurgeTimeColumn = `time, cachePurgeInterval = duration(\"7H\"),cacheRetentionTime = duration(\"2H\"))\n\ntime=2019.01.01T00:00:00.000\nfor(s in 0:6000){\n  time = temporalAdd(time,1,\"m\");\n  x=rand(10.0, 1)\n  insert into st values(time, x)\n}\n\ngetPersistenceMeta(st1);\n\n//通过查看流数据表的元数据，看到该表中的总记录数是 6000 行，系统根据时间列的自动清理内存后，在内存中仅保留了 300 行数据。\n\n/* output:\nlastLogSeqNum->-1\nsizeInMemory->300\ntotalSize->6000\nasynWrite->true\ncompress->true\nraftGroup->-1\nmemoryOffset->5700\nretentionMinutes->1440\nsizeOnDisk->6000\npersistenceDir->/data/ssd/DolphinDBDemo/persistence3/st1\nhashValue->0\ndiskOffset->0\n*/\n```\n\n**Related information**\n\n[disableTablePersistence](https://docs.dolphindb.cn/zh/funcs/d/disableTablePersistence.html)\n\n[clearTablePersistence](https://docs.dolphindb.cn/zh/funcs/c/clearTablePersistence.html)\n\n[getPersistenceMeta](https://docs.dolphindb.cn/zh/funcs/g/getPersistenceMeta.html)\n"
    },
    "enableTableShareAndCachePurge": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/enabletableshareandcachepurge.html",
        "signatures": [
            {
                "full": "enableTableShareAndCachePurge(table, tableName, [cacheSize],[cachePurgeTimeColumn],[cachePurgeInterval],[cacheRetentionTime])",
                "name": "enableTableShareAndCachePurge",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[cacheSize]",
                        "name": "cacheSize",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeTimeColumn]",
                        "name": "cachePurgeTimeColumn",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeInterval]",
                        "name": "cachePurgeInterval",
                        "optional": true
                    },
                    {
                        "full": "[cacheRetentionTime]",
                        "name": "cacheRetentionTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [enableTableShareAndCachePurge](https://docs.dolphindb.cn/zh/funcs/e/enabletableshareandcachepurge.html)\n\n\n\n#### 语法\n\nenableTableShareAndCachePurge(table, tableName, \\[cacheSize],\\[cachePurgeTimeColumn],\\[cachePurgeInterval],\\[cacheRetentionTime])\n\n##### 参数\n\n**table** 是一个空的流数据表。\n\n**tableName** 是一个字符串，表示 table 共享后的名称。\n\n**cacheSize** 是一个正整数，可选参数，表示流数据表在内存中最多保留的记录数。\n\n**cachePurgeTimeColumn** 字符串标量，可选参数。需要指定为持久化流表中的时间列名称。\n\n**cachePurgeInterval** DURATION 类型标量，表示触发清理内存中数据的时间间隔。\n\n**cacheRetentionTime** DURATION 类型标量，表示内存中数据的最长保留期限。\n\n#### 详情\n\n将非持久化的流数据表共享，并设置定时清理。\n\n通过以下两种方式之一来清理内存中的数据：\n\n* 配置 *cacheSize* 参数时，如果插入的数据使内存中流数据表的行数达到阈值，系统将清理内存中较旧的已发布记录。阈值确定方法如下：\n\n  * 每次 append 的数据都不超过 *cacheSize* 时，阈值为 *cacheSize* 的 2.5 倍。\n\n  * 当 append 的数据超过 *cacheSize* 时，阈值为追加行数和 cacheSize 之和的 1.2 倍。\n\n* 同时配置*cachePurgeTimeColumn*, *cachePurgeInterval* 和 *cacheRetentionTime*，系统将根据时间列清理数据。每次插入新数据时，系统会计算新数据与内存中第一条数据的时间戳差值，当差值大于等于 *cachePurgeInterval*时，系统仅保留时间戳与新数据时间戳差值小于等于 *cacheRetentionTime*的数据，清理其它数据。\n\n#### 例子\n\n例1. 配置 cacheSize 参数，根据内存中的数据量进行清理。\n\n```\nt = streamTable(1000:0, `time`sym`volume, [DATETIME, SYMBOL, INT])\nenableTableShareAndCachePurge(table=t, tableName=`st, cacheSize=1000)\ntime = datetime(2024.01.01T09:00:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\n\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n//0\n\ntime = datetime(2024.01.01T09:35:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n//500\n```\n\n例2. 配置*cachePurgeTimeColumn*, *cachePurgeInterval* 和 \\*cacheRetentionTime，\\*根据时间列清理数据。\n\n```\nt = streamTable(1000:0, `time`sym`volume, [DATETIME, SYMBOL, INT])\nenableTableShareAndCachePurge(table=t, tableName=`st, cachePurgeTimeColumn=`time,\n cachePurgeInterval=30m, cacheRetentionTime=20m)\n\ntime = datetime(2024.01.01T09:00:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\n\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n//0\n\ntime = datetime(2024.01.01T09:35:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n//999\n```\n"
    },
    "enableTableShareAndPersistence": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/enableTableShareAndPersistence.html",
        "signatures": [
            {
                "full": "enableTableShareAndPersistence(table, tableName, [asynWrite=true], [compress=true], [cacheSize], [retentionMinutes=1440], [flushMode=0], [preCache],[cachePurgeTimeColumn],[cachePurgeInterval],[cacheRetentionTime])",
                "name": "enableTableShareAndPersistence",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[asynWrite=true]",
                        "name": "asynWrite",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[compress=true]",
                        "name": "compress",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[cacheSize]",
                        "name": "cacheSize",
                        "optional": true
                    },
                    {
                        "full": "[retentionMinutes=1440]",
                        "name": "retentionMinutes",
                        "optional": true,
                        "default": "1440"
                    },
                    {
                        "full": "[flushMode=0]",
                        "name": "flushMode",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[preCache]",
                        "name": "preCache",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeTimeColumn]",
                        "name": "cachePurgeTimeColumn",
                        "optional": true
                    },
                    {
                        "full": "[cachePurgeInterval]",
                        "name": "cachePurgeInterval",
                        "optional": true
                    },
                    {
                        "full": "[cacheRetentionTime]",
                        "name": "cacheRetentionTime",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [enableTableShareAndPersistence](https://docs.dolphindb.cn/zh/funcs/e/enableTableShareAndPersistence.html)\n\n\n\n#### 语法\n\nenableTableShareAndPersistence(table, tableName, \\[asynWrite=true], \\[compress=true], \\[cacheSize], \\[retentionMinutes=1440], \\[flushMode=0], \\[preCache],\\[cachePurgeTimeColumn],\\[cachePurgeInterval],\\[cacheRetentionTime])\n\n#### 参数\n\n**table** 是一个空的流数据表。\n\n**tableName** 是一个字符串，表示 table 共享后的名称。\n\n**asynWrite** 是一个布尔值，表示是否异步持久化数据到磁盘。默认值为 true，流数据写入内存即为写入成功，持久化到磁盘的操作将会由另一个线程执行。\n\n**Note:**\n\n持久化数据到磁盘包含两个步骤：\n\n* 写内存数据到操作系统缓存\n\n* 写缓存数据到磁盘（是否开启同步刷盘由参数 *flushMode* 决定）\n\n**compress** 是一个布尔值。可选参数，表示是否以压缩模式模式保存至磁盘。默认值为 true。\n\n**cacheSize** 整数，可选参数，表示流数据表在内存中最多保留多少行。如果未指定该参数，则所有记录行都会保存在内存中。如果 *cacheSize* 小于 1000，它会被自动调整为 1000。\n\n**retentionMinutes** 是一个整数，表示文件大小超过 1GB的 log 文件的保留时间(从文件的最后修改时间开始计算)，单位是分钟。默认值是 1440，即一天。如果 log 文件未达 1GB，则会一直保留至大小达到 1GB。\n\n**flushMode** 是一个整数，表示是否开启同步刷盘，取值只能为 0 或 1。默认值是 0，表示异步刷盘，内存中的流数据写入操作系统缓存即为写入成功，并进行下一批数据的写入。 若为 1，则表示同步刷盘，当前批次的流数据必须落盘完成，才会进行下一批数据的写入。\n\n**preCache** 是一个整数，表示从磁盘加载到内存的记录条数。如果没有指定该参数，默认会把所有记录加载到内存中。\n\n**cachePurgeTimeColumn** 字符串标量，需要指定为持久化流表中的时间列名称。\n\n**cachePurgeInterval** DURATION 类型标量，表示触发清理内存中数据的时间间隔。\n\n**cacheRetentionTime** DURATION 类型标量，表示内存中数据的最长保留期限。\n\n**Note:** 自 3.00.2 版本起，该函数要求参数 *cacheRetentionTime* 必须小于 *cachePurgeInterval*。\n\n#### 详情\n\n该命令将流数据表共享，并把它持久化到磁盘上。\n\n为了保证该命令能够正常执行，需要在配置文件中（单节点：`dolohindb.cfg`，集群：`cluster.cfg`）指定配置参数 *persistenceDir*，配置参考：[功能配置](https://docs.dolphindb.cn/zh/db_distr_comp/cfg/function_configuration.html)。流数据表在磁盘上的存储目录是 `<PERSISTENCE_DIR>/<TABLE_NAME>`。目录包含两种类型的文件：数据文件（名称类型 *data0.log, data1.log...*）和索引文件 *index.log*。把这些数据保存到磁盘后，如果重启系统，再次执行该命令会把磁盘中的数据加载到内存中，加载的记录条数由参数 *preCache* 指定，但是实际加载的记录条数有可能会超过 *preCache*。\n\n参数 *asynWrite* 会告知系统是否以异步模式保存表。在异步模式中，追加的数据会被放进队列，之后用于保存的工作线程把数据写入磁盘。在同步模式中，表的追加数据操作直到追加数据被保存到磁盘中才完成。该参数的默认值是 true，即为异步模式。通常情况下，异步模式实现更高的吞吐量，但是如果服务器崩溃，可能会丢失最后追加的行。在异步模式中，保存表的工作是由单个工作线程完成，并且一个工作线程可能处理多个表。如果只保存一个表，增加工作线程的数量并不会提升性能。\n\n默认情况下，流数据表将所有数据保存在内存中。如果流数据表太大，系统可能会出现内存不足的情况。为了避免内存不足的问题，可以通过以下两种方式之一来清理内存中的数据：\n\n* 配置 *cacheSize* 参数时，如果插入的数据使内存中流数据表的行数达到阈值，系统将清理内存中较旧的已发布记录。阈值确定规则如下：\n\n  * 每次 append 的数据都不超过 *cacheSize* 时，内存中的记录数不会大于 *cacheSize* 的 2.5 倍。\n  * 否则，当 append 的数据超过 *cacheSize* 时，内存中的记录数不会超过追加行数和 *cacheSize* 之和的 1.2 倍。\n* 同时配置*cachePurgeTimeColumn*, *cachePurgeInterval* 和 *cacheRetentionTime*，系统将根据时间列清理数据。每次插入新数据时，系统会计算新数据与内存中第一条数据的时间戳差值，当差值大于等于 *cachePurgeInterval*时，系统仅保留时间戳与新数据时间戳差值小于等于 *cacheRetentionTime*的数据，清理其它数据。\n\n**Note:**\n\n* 如果手动重启 server，建议调用 [fflush](https://docs.dolphindb.cn/zh/funcs/f/fflush.html) 函数先把缓存区的数据写入磁盘使用 `kill -15` 命令 进程。\n\n* 如果设置 asynWrite=true，此时流数据写入速度最快，若 server 发生 crash 可能导致部分数据丢失。\n\n* 如果设置 asynWrite=false，flushmode=0，此时流数据写入速度中等，server 发生 crash 不会丢失数据，但操作系统崩溃可能导致部分数据丢失。\n\n* 如果设置 asynWrite=false，flushmode=1，此时流数据写入速度最慢，server 发生 crash 或操作系统崩溃都不会导致数据丢失。\n\n* 不可以将同一个流数据表通过修改共享变量名称的方式共享 2 次及以上。\n\n#### 例子\n\n例1.\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt = streamTable(100:0, colName, colType);\nenableTableShareAndPersistence(table=t, tableName=`st, cacheSize=1200000)\ngo;\n```\n\n```\nfor(s in 0:200){\n  n=10000\n  time=2019.01.01T00:00:00.000+s*n+1..n\n  x=rand(10.0, n)\n  insert into st values(time, x)\n}\n```\n\n```\ngetPersistenceMeta(st);\n\n/* output:\nsizeInMemory->800000\nasynWrite->true\ntotalSize->2000000\ncompress->true\nmemoryOffset->1200000\nretentionMinutes->1440\nsizeOnDisk->2000000\npersistenceDir->/home/llin/hzy/server1/pst/st\nhashValue->0\ndiskOffset->0\n*/\n```\n\n例2. 本例将说明 *cachePurgeTimeColumn*, *cachePurgeInterval* 和 *cacheRetentionTime* 的使用方法。\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt1 = streamTable(100:0, colName, colType);\n\nenableTableShareAndPersistence(table=t1,tableName=`st1, cachePurgeTimeColumn=`time, cachePurgeInterval=duration(\"7H\"),cacheRetentionTime=duration(\"2H\"))\n\ngo;\n\ntime=2019.01.01T00:00:00.000\nfor(s in 0:6000){\n  time = temporalAdd(time,1,\"m\");\n  x=rand(10.0, 1)\n  insert into st1 values(time, x)\n}\n\ngetPersistenceMeta(st1);\n\n/* output:\nlastLogSeqNum->-1\nsizeInMemory->300\ntotalSize->12000\nasynWrite->true\ncompress->true\nraftGroup->-1\nmemoryOffset->11700\nretentionMinutes->1440\nsizeOnDisk->11879\npersistenceDir->/home/ffliu/jjxu/DolphinDB_Linux64_V3.0/server/persistence/st1\nhashValue->0\ndiskOffset->0\n*/\n```\n\n**Related information**\n\n[disableTablePersistence](https://docs.dolphindb.cn/zh/funcs/d/disableTablePersistence.html)\n\n[clearTablePersistence](https://docs.dolphindb.cn/zh/funcs/c/clearTablePersistence.html)\n\n[getPersistenceMeta](https://docs.dolphindb.cn/zh/funcs/g/getPersistenceMeta.html)\n"
    },
    "enableTSDBAsyncSorting": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/enableTSDBAsyncSorting.html",
        "signatures": [
            {
                "full": "enableTSDBAsyncSorting()",
                "name": "enableTSDBAsyncSorting",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [enableTSDBAsyncSorting](https://docs.dolphindb.cn/zh/funcs/e/enableTSDBAsyncSorting.html)\n\n\n\n#### 语法\n\nenableTSDBAsyncSorting()\n\n#### 参数\n\n无\n\n#### 详情\n\nTSDB 写入 Cache Engine 中的数据会根据 *sortColumns* 排序。写入任务和排序任务可以同步或异步进行，该命令用于开启异步进行数据排序的功能。异步线程数量由配置参数 *TSDBAsyncSortingWorkerNum* 指定。 只能由管理员在数据节点上执行。请注意，执行该命令前请确认 *TSDBAsyncSortingWorkerNum* 配置值大于0。\n\n因异步数据排序能提高数据写入性能，若 TSDB 引擎所在服务器 CPU 核数较多，建议在进行数据写入前，执行该命令开启异步数据排序功能。\n\n相关函数：[disableTSDBAsyncSorting](https://docs.dolphindb.cn/zh/funcs/d/disableTSDBAsyncSorting.html)\n"
    },
    "encodeShortGenomeSeq": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/encodeShortGenomeSeq.html",
        "signatures": [
            {
                "full": "encodeShortGenomeSeq(X)",
                "name": "encodeShortGenomeSeq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [encodeShortGenomeSeq](https://docs.dolphindb.cn/zh/funcs/e/encodeShortGenomeSeq.html)\n\n\n\n#### 语法\n\nencodeShortGenomeSeq(X)\n\n别名：encodeSGS\n\n#### 参数\n\n**X** STRING 类型标量或向量、CHAR 类型向量。\n\n#### 详情\n\n对 DNA 序列（由 A, T, C, G 自由组合）进行编码。通过编码，可以减小 DNA 序列的存储空间，提高计算效率。\n\n注意：\n\n* 若 *X* 指定为空字符（\"\"），则函数返回0。\n\n* 若 *X* 中包含了除 A, T, C, G（大小写敏感）以外的字符，则返回空值。\n\n* 若 *X* 指定的字符串所包含的字符个数超过了28，则返回空值。\n\n#### 返回值\n\n长整型（LONG）或长整型向量（FAST LONG VECTOR）\n\n#### 例子\n\n```\na=encodeShortGenomeSeq(\"TCGATCG\")\na;\n// output\n465691\ntypestr(a)\n// output\nLONG\n    \nb=encodeShortGenomeSeq(\"TCGATCG\" \"TCGATCGCCC\") \n// output\n[465691,168216298]\ntypestr(b)\n// output\nFAST LONG VECTOR\n    \n// \"TCGATCG\"重复5次后，因长度超过了28，所以返回了空值。\nencodeShortGenomeSeq(repeat(\"TCGATCG\" \"TCGAT\", 5))\n// output\n[,1801916404867712433]\n    \ny=toCharArray(\"TCGATCGCCC\")\nencodeShortGenomeSeq(y)\n// output\n168216298\n    \nencodeShortGenomeSeq(\"TC G\") \n// output\n00l\nencodeShortGenomeSeq(\"TCtG\") \n// output\n00l\n// 基因序列中出现 N，编码返回空。\nencodeShortGenomeSeq(\"NNNNNNNNTCGGGGCAT\")\n// output\n00l\nencodeShortGenomeSeq(\"TCGGGGCATNGCCCG\")\n// output\n00l\nencodeShortGenomeSeq(\"GCCCGATNNNNN\")\n// output\n00l\n```\n\n相关函数：[decodeShortGenomeSeq](https://docs.dolphindb.cn/zh/funcs/d/decodeShortGenomeSeq.html), [genShortGenomeSeq](https://docs.dolphindb.cn/zh/funcs/g/genShortGenomeSeq.html)\n"
    },
    "endsWith": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/endsWith.html",
        "signatures": [
            {
                "full": "endsWith(X, str)",
                "name": "endsWith",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "str",
                        "name": "str"
                    }
                ]
            }
        ],
        "markdown": "### [endsWith](https://docs.dolphindb.cn/zh/funcs/e/endsWith.html)\n\n\n\n#### 语法\n\nendsWith(X, str)\n\n#### 参数\n\n**X** 是搜索的目标字符串。它可以是标量或向量。\n\n**str** 是被搜索的目标字符串。它必须是标量。\n\n#### 详情\n\n检查 *X* 是否以 *str* 结尾。如果是，返回 true； 否则返回 false。\n\n#### 例子\n\n```\nendsWith('ABCDEF!', \"F!\");\n// output\ntrue\n\nendsWith('ABCDEF!', \"E!\");\n// output\nfalse\n```\n"
    },
    "enlist": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/enlist.html",
        "signatures": [
            {
                "full": "enlist(X)",
                "name": "enlist",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [enlist](https://docs.dolphindb.cn/zh/funcs/e/enlist.html)\n\n\n\n#### 语法\n\nenlist(X)\n\n#### 参数\n\n**X** 任意数据形式。\n\n#### 详情\n\n返回一个由 *X* 组成的向量或元组。\n\n* *X* 是标量时，返回一个向量。\n\n* *X* 是向量、元组等其他数据形式时，返回一个元组。\n\n#### 例子\n\n```\nenlist(1)\n// output\n[1]\n\nenlist(`aaa)\n// output\n[\"aaa\"]\n\nenlist([2022.01.01,2022.01.02,2022.01.03])\n// output\n([2022.01.01,2022.01.02,2022.01.03])\n\nenlist([\"a\",2,3])\n// output\n((\"a\",2,3))\n\na = array(INT[], 0, 10).append!([1 2 3, 4 5,6 7 8, 9 NULL])\nenlist(a)\n// output\n([[1,2,3],[4,5],[6,7,8],[9,00i]])\n```\n"
    },
    "eq": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/eq.html",
        "signatures": [
            {
                "full": "eq(X, Y)",
                "name": "eq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [eq](https://docs.dolphindb.cn/zh/funcs/e/eq.html)\n\n\n\n#### 语法\n\neq(X, Y) 或 X==Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量、矩阵或集合。如果 *X* 或 *Y* 其中一个是数据对、向量或矩阵，另一个必须是标量，或具有相同长度或维度的数据对、向量或矩阵。\n\n#### 详情\n\n如果 *X* 和 *Y* 都不是集合，返回逐个元素比较 *X*==*Y* 的结果。\n\n如果 *X* 和 *Y* 都是集合，则检查 *X* 和 *Y* 是否是同一个集合。\n\n#### 例子\n\n```\n1 2 3 == 2;\n// output\n[0,1,0]\n\n1 2 3==0 2 4;\n// output\n[0,1,0]\n\n1:2==1:6;\n// output\n1 : 0\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 == 4;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 0  | 0  |\n| 0  | 1  | 0  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1==m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 0  | 0  |\n| 0  | 0  | 0  |\n\n集合操作：如果 *X*==*Y*，则 *X* 和 *Y* 是同一个集合。\n\n```\nx=set(4 6)\ny=set(4 6 8);\n\nx==y;\n// output\n0\nx==x;\n// output\n1\n```\n"
    },
    "eqFloat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/eqFloat.html",
        "signatures": [
            {
                "full": "eqFloat(X, Y, [precision=9])",
                "name": "eqFloat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[precision=9]",
                        "name": "precision",
                        "optional": true,
                        "default": "9"
                    }
                ]
            }
        ],
        "markdown": "### [eqFloat](https://docs.dolphindb.cn/zh/funcs/e/eqFloat.html)\n\n\n\n#### 语法\n\neqFloat(X, Y, \\[precision=9])\n\n#### 参数\n\n**X** 和 **Y** 可以是数值类型标量、向量或矩阵。如果 *X* 与 *Y* 其中一个是向量或矩阵，另一个必须是标量或具有相同长度或维度的向量或矩阵。\n\n**precision** 是一个非负整数，表示对 FLOAT 或 DOUBLE 类型，比较精度为小数点后几位。\n\n#### 详情\n\n以给定（小数点后位数）精度，逐个元素比较 *X*==*Y*。\n\n#### 例子\n\n```\neqFloat(0.1234567891, 0.123456789);\n// output\ntrue\n\neqFloat(0.123456788, 0.123456789);\n// output\nfalse\n\neqFloat(0.123456788 0.123456789 0.1234567891, 0.123456789);\n// output\n[false,true,true]\n```\n"
    },
    "eqObj": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/eqObj.html",
        "signatures": [
            {
                "full": "eqObj(obj1, obj2, [precision])",
                "name": "eqObj",
                "parameters": [
                    {
                        "full": "obj1",
                        "name": "obj1"
                    },
                    {
                        "full": "obj2",
                        "name": "obj2"
                    },
                    {
                        "full": "[precision]",
                        "name": "precision",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [eqObj](https://docs.dolphindb.cn/zh/funcs/e/eqObj.html)\n\n\n\n#### 语法\n\neqObj(obj1, obj2, \\[precision])\n\n#### 参数\n\n**obj1** 和 **obj2** 可以是标量、数据对、向量或矩阵。\n\n**precision** 是一个非负整数，表示对 FLOAT 或 DOUBLE 类型，比较精度为小数点后几位。\n\n#### 详情\n\n检验两个对象的类型和值是否相同。只有当类型和值都相同时，此函数才会返回 true。 如果值相同但类型不同，则此函数仍返回 false，这与函数 [eq](https://docs.dolphindb.cn/zh/funcs/e/eq.html) 不同。\n\n**Note:** 使用 `eqObj` 比较浮点数时，根据 abs(obj1-obj2)<=pow(10,-precision) 的结果来判断 obj1 和 obj2 的值是否相等。\n\n#### 例子\n\n```\neqObj(2, 2.0);\n// output: false\n\neq(2, 2.0);\n// output: true\n\neqObj(1.1, 1.2, 0);\n// output: true\n\neqObj(1.1, 1.2, 1);\n// output: true\n\neqObj(1 2 3, 1 2 3);\n// output: true\n\neq(1 2 3, 1 2 3);\n// output: [true,true,true]\n```\n\n`eqObj` 不能直接用于比较两个表是否相同。但是，可以使用高阶函数 [each](https://docs.dolphindb.cn/zh/funcs/ho_funcs/each.html) 来逐列对比两个表的值。\n\n```\nt1=table(1 2 3 as x, 4 5 6 as y);\nt2=table(1 2 3 as x, 4 5 6 as y);\n\nt1.values();\n// output: ([1,2,3],[4,5,6])\n\neach(eqObj, t1.values(), t2.values());\n// output: [true,true]\n```\n"
    },
    "eqPercent": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/eqpercent.html",
        "signatures": [
            {
                "full": "eqPercent(X, Y,[toleranceLevel=0.0001])",
                "name": "eqPercent",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[toleranceLevel=0.0001]",
                        "name": "toleranceLevel",
                        "optional": true,
                        "default": "0.0001"
                    }
                ]
            }
        ],
        "markdown": "### [eqPercent](https://docs.dolphindb.cn/zh/funcs/e/eqpercent.html)\n\n\n\n#### 语法\n\neqPercent(X, Y,\\[toleranceLevel=0.0001])\n\n#### 详情\n\n根据自定义约束条件，判断两个输入参数的每个对应位置上的元素是否都相等。\n\n#### 参数\n\n**X** 和 **Y** 要比较的两个数值，仅支持长度相同的标量、向量、数据对或矩阵。数据类型仅支持 BOOL, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE, DECIMAL。注意：*X* 和 *Y* 中的元素在比较时可以是不同的数据类型。\n\n**toleranceLevel** 可选参数，数值标量，值域为(0,100)，表示可容许误差的百分位数，默认值为 0.0001。即两元素差值的绝对值不多于 *Y* 绝对值的 `toleranceLevel%`。如 *Y* 输入 1000，*toleranceLevel* 取默认值 0.0001，则可容忍误差为 1000\\*0.0001%=0.001，即\\[999.999, 1000.001]之间的 *X* 会被认为相等。\n\n#### 返回值\n\n输出一个 BOOL 标量，true 代表 *X* 与 *Y* 每个对应位置的元素都在约束下相等；false 反之。\n\n注意：\n\n* 如果传入的参数 *X* 或 *Y* 的类型不受支持，则返回 `eqObj(X, Y)` 的结果值。\n\n* NULL 值和其他值不相等。\n\n* 不同类型之间的 NULL 值被认为相等。\n\n#### 例子\n\n以下给出几个简单示例。\n\n```\neqPercent((1.9999 2.9999), (2 3))\n//Output:true\n\neqPercent((1.9 2.9), (2 3), 2)\n//Output:false\n\neqPercent((1.99f 2.99), (2 3h), 2)\n//Output:true\n//X和Y中的元素在比较时可以是不同的数据类型\n\neqPercent((1.9999 NULL), (2 3))\n//Output:false\n\na=double(NULL)\neqPercent(a,NULL)\n//Output:true\n//DOUBLE类型和VOID类型的NULL相等\n\neqPercent(2012.06M, 2)\n//Output:false\n//传入不支持其类型的X，返回eqObj(X, Y)的结果值。\n```\n\n相关函数：[eqObj](https://docs.dolphindb.cn/zh/funcs/e/eqObj.html)\n"
    },
    "erase!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/erase_.html",
        "signatures": [
            {
                "full": "erase!(obj, key|filter)",
                "name": "erase!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "key|filter",
                        "name": "key|filter"
                    }
                ]
            }
        ],
        "markdown": "### [erase!](https://docs.dolphindb.cn/zh/funcs/e/erase_.html)\n\n\n\n#### 语法\n\nerase!(obj, key|filter)\n\n#### 参数\n\n**obj** 可以是集合、字典或表。\n\n对于集合，**key|filter** 表示要删除的元素；对于字典，*key|filter* 表示要删除的键值；对于表，*key|filter* 表示过滤条件的元代码。\n\n#### 详情\n\n删除集合中的某些元素或字典中的键值或表中的某些行。\n\n#### 例子\n\n对于集合：\n\n```\ny=set(8 9 4 6);\ny;\n// output\nset(6,4,9,8)\ny.erase!(6);\n// output\nset(4,9,8)\nerase!(y, 9 8);\n// output\nset(4)\n```\n\n对于字典：\n\n```\nx=1..6;\ny=11..16;\nz=dict(x,y);\nz;\n// output\n6->16\n5->15\n4->14\n3->13\n2->12\n1->11\n\nerase!(z, 1..4);\n// output\n6->16\n5->15\n```\n\n对于表：\n\n```\nx=1..10;\ny=11..20;\nt=table(x,y);\n// output\nerase!(t, <x<=3>);\n```\n\n| x  | y  |\n| -- | -- |\n| 4  | 14 |\n| 5  | 15 |\n| 6  | 16 |\n| 7  | 17 |\n| 8  | 18 |\n| 9  | 19 |\n| 10 | 20 |\n\n```\nerase!(t, <x<=9 and y>=15>);\n```\n\n| x  | y  |\n| -- | -- |\n| 4  | 14 |\n| 10 | 20 |\n"
    },
    "esd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/esd.html",
        "signatures": [
            {
                "full": "esd(data, [hybrid], [maxAnomalies], [alpha])",
                "name": "esd",
                "parameters": [
                    {
                        "full": "data",
                        "name": "data"
                    },
                    {
                        "full": "[hybrid]",
                        "name": "hybrid",
                        "optional": true
                    },
                    {
                        "full": "[maxAnomalies]",
                        "name": "maxAnomalies",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [esd](https://docs.dolphindb.cn/zh/funcs/e/esd.html)\n\n\n\n#### 语法\n\nesd(data, \\[hybrid], \\[maxAnomalies], \\[alpha])\n\n#### 参数\n\n**data** 是一个数值向量。\n\n**hybrid** 是一个布尔值，表示是否用中位数和绝对中位差代替 Grubb's test 中 zscore 计算的平均值和标准差。如果 *hybrid* 为 true，算法更具鲁棒性。默认值为 false。\n\n**maxAnomalies** 是一个正整数或(0, 0.5)之间的浮点数。默认值为0.1。\n\n* 如果 *maxAnomalies* 是正整数，*maxAnomalies* 必须小于 *data* 长度的一半，函数最多检测 *maxAnomalies* 个异常点。\n\n* 如果 *maxAnomalies* 是(0, 0.5)之间的浮点数，函数最多检测 int(size(data) \\* maxAnomalies) 个异常点。\n\n**alpha** 是一个正数，表示检验的显著度。*alpha* 越大，数据越有可能被判断为异常点。\n\n#### 详情\n\n使用 ESD (Extreme Studentized Deviate) 算法对时间序列进行异常检测。返回的结果是一个包含异常值的表，该表有两列，index 列记录原始数据中异常值的下标，anoms 列记录异常值。\n\n#### 例子\n\n```\nn = 1000\nts = rand(10.0, n)\nts[500 600 700 999] += 20\nesd(ts);\n```\n\n| index | anoms     |\n| ----- | --------- |\n| 600   | 29.815742 |\n| 700   | 25.517493 |\n| 500   | 25.17515  |\n| 999   | 24.748516 |\n\n相关函数：[stl](https://docs.dolphindb.cn/zh/funcs/s/stl.html), [seasonalEsd](https://docs.dolphindb.cn/zh/funcs/s/seasonalEsd.html)\n"
    },
    "euclidean": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/euclidean.html",
        "signatures": [
            {
                "full": "euclidean(X, Y)",
                "name": "euclidean",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [euclidean](https://docs.dolphindb.cn/zh/funcs/e/euclidean.html)\n\n\n\n#### 语法\n\neuclidean(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是长度相同的数值型标量/向量/矩阵。\n\n#### 详情\n\n若 *X* 和 *Y* 是标量或向量，计算 *X* 和 *Y* 之间的欧氏距离。\n\n若 *X* 和 *Y* 是矩阵，计算每列元素之间的欧式距离，返回一个向量。 注意，若 *X* 或 *Y* 同时为索引矩阵或索引序列，会自动对齐标签，返回标签相同的行的计算结果，忽略标签不同的行。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\na=[100, 0, 0]\nb=[0, 51, NULL]\neuclidean(a,b)\n// output\n112.254176\n\ns1=indexedSeries(1 2 4, 10.4 11.2 9)\ns2=indexedSeries(1 2 5, 23.5 31.2 26)\neuclidean(s1,s2)\n// output\n23.9084\n\nm=matrix(23 56 47, 112 94 59)\neuclidean(a,m)\n// output\n[106.1791,111.6288]\n\nm1=matrix(11 15 89, 52 41 63)\neuclidean(m,m1)\n// output\n[59.9083,80.1561]\n\nm.rename!(2020.01.01..2020.01.03, `A`B)\nm.setIndexedMatrix!()\nm1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\nm1.setIndexedMatrix!()\neuclidean(m,m1)\n// output\n[34.176,62.6418]\n```\n\n相关函数：[rowEuclidean](https://docs.dolphindb.cn/zh/funcs/r/rowEuclidean.html)\n"
    },
    "eval": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/eval.html",
        "signatures": [
            {
                "full": "eval(expr)",
                "name": "eval",
                "parameters": [
                    {
                        "full": "expr",
                        "name": "expr"
                    }
                ]
            }
        ],
        "markdown": "### [eval](https://docs.dolphindb.cn/zh/funcs/e/eval.html)\n\n\n\n#### 语法\n\neval(expr)\n\n#### 参数\n\n**expr** 是元代码。\n\n#### 详情\n\n解析给定的元代码。\n\n#### 例子\n\n```\neval(<1+2>);\n// output\n3\n\neval(<1+2+3=10>);\n// output\n0\n\neval(expr(6,<,8));\n// output\n1\n\neval(expr(sum, 1 2 3));\n// output\n6\n\na=6; b=9;\neval(expr(<a>,+,<b>));\n// output\n15\n```\n"
    },
    "evalTimer": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/evalTimer.html",
        "signatures": [
            {
                "full": "evalTimer(funcs, [count=1])",
                "name": "evalTimer",
                "parameters": [
                    {
                        "full": "funcs",
                        "name": "funcs"
                    },
                    {
                        "full": "[count=1]",
                        "name": "count",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [evalTimer](https://docs.dolphindb.cn/zh/funcs/e/evalTimer.html)\n\n\n\n#### 语法\n\nevalTimer(funcs, \\[count=1])\n\n#### 参数\n\n**funcs** 是一个或多个没有参数的函数。如果有多个函数，使用元组表示。\n\n**count** 是一个整数，表示执行的次数。它是可选参数，默认值为1。\n\n#### 详情\n\n返回执行指定函数耗费的时间，单位是毫秒。如果 *funcs* 包含多个函数，`evalTimer` 返回的是顺序执行这些函数耗费的时间。\n\n[timer](https://docs.dolphindb.cn/zh/progr/statements/timer.html) 语句和 `evalTimer` 函数的功能类似，两者的区别是：\n\n* `timer` 语句的输入是代码块； `evalTimer` 函数的输入是函数。如果要用 `evalTimer` 函数计算执行一段代码的时间，需要把代码写成自定义函数。\n\n* `timer` 语句的返回结果是一条消息，不能赋值给一个变量； `evalTimer` 函数的返回结果是一个标量，可以赋值给变量。\n\n#### 例子\n\n```\nx=rand(10.0, 1000000)\nevalTimer(dot{x,2},10);\n// output\n39.609375\n\nevalTimer(sort{x},10);\n// output\n837.542702\n\nevalTimer([dot{x,2},sort{x}],10)\n// output\n870.065348\n```\n\n从上面的例子可以看出，`evalTimer` 返回的是顺序执行这些函数耗费的时间，而不是并行执行。\n"
    },
    "ewmCorr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/ewmCorr.html",
        "signatures": [
            {
                "full": "ewmCorr(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [other], [bias=false])",
                "name": "ewmCorr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[com]",
                        "name": "com",
                        "optional": true
                    },
                    {
                        "full": "[span]",
                        "name": "span",
                        "optional": true
                    },
                    {
                        "full": "[halfLife]",
                        "name": "halfLife",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    },
                    {
                        "full": "[minPeriods=0]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[adjust=true]",
                        "name": "adjust",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=false]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[other]",
                        "name": "other",
                        "optional": true
                    },
                    {
                        "full": "[bias=false]",
                        "name": "bias",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [ewmCorr](https://docs.dolphindb.cn/zh/funcs/e/ewmCorr.html)\n\n\n\n#### 语法\n\newmCorr(X, \\[com], \\[span], \\[halfLife], \\[alpha], \\[minPeriods=0], \\[adjust=true], \\[ignoreNA=false], \\[other], \\[bias=false])\n\n#### 参数\n\n**X** 是一个数值型向量、矩阵或表。若 *X* 是表，只对其内数值型和布尔型的列进行计算。\n\n**com** 是一个大于等于0的数值型标量，表示质心。\n\n**span** 是一个大于等于1的数值型标量，表示跨度。\n\n**halfLife** 是一个大于0的数值型标量，表示半衰期。\n\n**alpha** 是一个(0,1]之间的浮点数，表示平滑系数。\n\n**minPeriods** 是一个整数，表示窗口中的最小观察数。默认值为0。\n\n**adjust** 是一个布尔值，表示是否除以开始阶段的衰减调整因子。默认值为 true。\n\n**ignoreNA** 是一个布尔值，表示计算权重时是否忽略NULL值。默认值为 false。\n\n**other** 当 *X* 是向量时，*other* 只能是一个与 *X* 长度相同的数值型向量；当 *X* 是矩阵时，*other* 是一个长度与 *X* 行数相同的数值型向量，或维度与 *X* 相同的矩阵；当 *X* 是表时，*other* 是一个长度与 *X* 行数相同的数值型向量，或维度与 *X* 相同的表。\n\n**bias** 是一个布尔值，表示是否校正系统偏差。默认值为 false。\n\n#### 详情\n\n返回 *X* 和 *other* 的指数加权移动相关系数。该函数必须指定 *com*, *span*, *halfLife*, *alpha* 四个参数中的一个。\n\n#### 例子\n\n```\na=[0,1,2,int(),4]\nb=[2,4,3,6,5]\newmCorr(X=a,other=b,com=0.5);\n// output\n[,1.0000,-0.0533,-0.0533,0.9146]\n\newmCorr(X=a,other=b,com=0.5,ignoreNA=true);\n// output\n[,1.0000,-0.0533,-0.0533,0.8934]\n\nn = 20\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt1 = table(n:0, colNames, colTypes)\ninsert into t1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into t1 values(09:30:00.001,`AAPL,200,30.5)\ninsert into t1 values(09:30:00.001,`DELL,150,35.5)\ninsert into t1 values(09:30:00.001,`DELL,170,60.5)\ninsert into t1 values(09:30:00.001,`DELL,130,40.5)\nb=[2,4,3,6,5]\newmCorr(X=t1,other=b,com=0.5);\n```\n\n| time         | sym  | qty    | price   |\n| ------------ | ---- | ------ | ------- |\n| 09:30:00.001 | AAPL |        |         |\n| 09:30:00.001 | AAPL | 1.0000 | -1.0000 |\n| 09:30:00.001 | DELL | 1.0000 | -0.8481 |\n| 09:30:00.001 | DELL | 0.5536 | 0.8747  |\n| 09:30:00.001 | DELL | 0.3064 | 0.7050  |\n\n相关函数：[ewmCov](https://docs.dolphindb.cn/zh/funcs/e/ewmCov.html), [ewmMean](https://docs.dolphindb.cn/zh/funcs/e/ewmMean.html), [ewmStd](https://docs.dolphindb.cn/zh/funcs/e/ewmStd.html), [ewmVar](https://docs.dolphindb.cn/zh/funcs/e/ewmVar.html)\n"
    },
    "ewmCov": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/ewmCov.html",
        "signatures": [
            {
                "full": "ewmCov(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [other], [bias=false])",
                "name": "ewmCov",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[com]",
                        "name": "com",
                        "optional": true
                    },
                    {
                        "full": "[span]",
                        "name": "span",
                        "optional": true
                    },
                    {
                        "full": "[halfLife]",
                        "name": "halfLife",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    },
                    {
                        "full": "[minPeriods=0]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[adjust=true]",
                        "name": "adjust",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=false]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[other]",
                        "name": "other",
                        "optional": true
                    },
                    {
                        "full": "[bias=false]",
                        "name": "bias",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [ewmCov](https://docs.dolphindb.cn/zh/funcs/e/ewmCov.html)\n\n\n\n#### 语法\n\newmCov(X, \\[com], \\[span], \\[halfLife], \\[alpha], \\[minPeriods=0], \\[adjust=true], \\[ignoreNA=false], \\[other], \\[bias=false])\n\n#### 参数\n\n**X** 是一个数值型向量、矩阵或表。若 *X* 是表，只对其内数值型和布尔型的列进行计算。\n\n**com** 是一个大于等于0的数值型标量，表示质心。\n\n**span** 是一个大于等于1的数值型标量，表示跨度。\n\n**halfLife** 是一个大于0的数值型标量，表示半衰期。\n\n**alpha** 是一个(0,1]之间的浮点数，表示平滑系数。\n\n**minPeriods** 是一个整数，表示窗口中的最小观察数。默认值为0。\n\n**adjust** 是一个布尔值，表示是否除以开始阶段的衰减调整因子。默认值为 true。\n\n**ignoreNA** 是一个布尔值，表示计算权重时是否忽略 NULL 值。默认值为 false。\n\n**other** 当 *X* 是向量时，*other* 只能是一个与 *X* 长度相同的数值型向量；当 *X* 是矩阵时，*other* 是一个长度与 *X* 行数相同的数值型向量，或维度与 *X* 相同的矩阵；当 *X* 是表时，*other* 是一个长度与 *X* 行数相同的数值型向量，或维度与 *X* 相同的表。\n\n**bias** 是一个布尔值，表示是否校正系统偏差。默认值为 false。\n\n#### 详情\n\n返回 *X* 和 *other* 的指数加权移动协方差。该函数必须指定 *com*, *span*, *halfLife*, *alpha* 四个参数中的一个。\n\n#### 例子\n\n```\na=[0,1,2,int(),4]\nb=[2,4,3,6,5]\newmCov(X=a,other=b,com=0.5);\n// output\n[,1,-0.038462,-0.038462,2.112637]\n\newmCov(X=a,other=b,com=0.5,ignoreNA=true);\n// output\n[,1,-0.038462,-0.038462,1.969231]\n\nn = 20\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt1 = table(n:0, colNames, colTypes)\ninsert into t1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into t1 values(09:30:00.001,`AAPL,200,30.5)\ninsert into t1 values(09:30:00.001,`DELL,150,35.5)\ninsert into t1 values(09:30:00.001,`DELL,170,60.5)\ninsert into t1 values(09:30:00.001,`DELL,130,40.5)\nb=[2,4,3,6,5]\newmCov(X=t1,other=b,com=0.5);\n```\n\n| time         | sym  | qty     | price   |\n| ------------ | ---- | ------- | ------- |\n| 09:30:00.001 | AAPL |         |         |\n| 09:30:00.001 | AAPL | 100     | -26     |\n| 09:30:00.001 | DELL | 30.7692 | -6.1538 |\n| 09:30:00.001 | DELL | 25.2308 | 29.5346 |\n| 09:30:00.001 | DELL | 9.405   | 10.0012 |\n\n相关函数：[ewmCorr](https://docs.dolphindb.cn/zh/funcs/e/ewmCorr.html), [ewmMean](https://docs.dolphindb.cn/zh/funcs/e/ewmMean.html), [ewmStd](https://docs.dolphindb.cn/zh/funcs/e/ewmStd.html), [ewmVar](https://docs.dolphindb.cn/zh/funcs/e/ewmVar.html)\n"
    },
    "ewmMean": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/ewmMean.html",
        "signatures": [
            {
                "full": "ewmMean(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false])",
                "name": "ewmMean",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[com]",
                        "name": "com",
                        "optional": true
                    },
                    {
                        "full": "[span]",
                        "name": "span",
                        "optional": true
                    },
                    {
                        "full": "[halfLife]",
                        "name": "halfLife",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    },
                    {
                        "full": "[minPeriods=0]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[adjust=true]",
                        "name": "adjust",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=false]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [ewmMean](https://docs.dolphindb.cn/zh/funcs/e/ewmMean.html)\n\n#### 语法\n\newmMean(X, \\[com], \\[span], \\[halfLife], \\[alpha], \\[minPeriods=0], \\[adjust=true], \\[ignoreNA=false])\n\n#### 详情\n\n返回 *X* 的指数加权移动平均值。该函数必须指定 *com*, *span*, *halfLife*, *alpha* 四个参数中的一个。\n\n#### 参数\n\n*X* 是一个数值型向量、矩阵或表。若 *X* 是表，只对其内数值型和布尔型的列进行计算。\n\n*com* 是一个大于等于 0 的数值型标量，表示质心。根据质心指定平滑系数时，公式如下：\n\n![](https://docs.dolphindb.cn/zh/images/ewmmean_com.png)\n\n*span* 是一个大于等于 1 的数值型标量，表示跨度。根据跨度指定平滑系数时，公式如下：\n\n![](https://docs.dolphindb.cn/zh/images/ewmmean_span.png)\n\n*halfLife* 是一个大于 0 的数值型标量，表示半衰期。根据半衰期指定平滑系数时，公式如下：\n\n![](https://docs.dolphindb.cn/zh/images/ewmmean_halflife.png)\n\n*alpha* 是一个 (0,1] 之间的浮点数，表示平滑系数。\n\n*minPeriods* 是一个整数，表示窗口中的最小观察数。默认值为 0。\n\n*adjust* 是一个布尔值，表示是否除以开始阶段的衰减调整因子。默认值为 true。\n\n* 若 *adjust*为 true，其公式为：\n\n  ![](https://docs.dolphindb.cn/zh/images/ewmmean_adjust_true.png)\n\n* 若 *adjust* 为 false，其公式为：\n\n  ![](https://docs.dolphindb.cn/zh/images/ewmmean_adjust_false.png)\n\n*ignoreNA* 是一个布尔值，表示计算权重时是否忽略 NULL 值。默认值为 false，即不忽略 NULL 值。以 \\[x0, NULL, x2] 为例：\n\n* 若 *ignoreNA* 为 true，\n  * *adjust* 为 false，x0、x2 的最终权重为 1-α、α；\n  * *adjust* 为 true，则 x0、x2 的最终权重为 1-α、1；\n* 若*ignoreNA* 为 false，\n  * *adjust* 为 false，则 x0、x2的最终权重为（1-α）2、α；\n  * *adjust* 为 true,则 x0、x2 的最终权重为（1-α）2、1。\n\n#### 例子\n\n使用以下的 a 作为 X 的值，\n\n```\na=[0,1,2,int(),4];\newmMean(X=a,com=0.5);\n\n```\n\n返回：\\[0,0.75,1.615385,1.615385,3.670213]\n\n```\newmMean(X=a,com=0.5,ignoreNA=true);\n```\n\n返回：\\[0,0.75,1.615385,1.615385,3.225]\n\n使用以下的 t1 作为 X 的值，\n\n```\nn = 20\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt1 = table(n:0, colNames, colTypes)\ninsert into t1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into t1 values(09:30:00.001,`AAPL,200,30.5)\ninsert into t1 values(09:30:00.001,`DELL,150,35.5)\ninsert into t1 values(09:30:00.001,`DELL,170,60.5)\ninsert into t1 values(09:30:00.001,`DELL,130,40.5)\nb=[2,4,3,6,5]\newmMean(X=t1,com=0.5);\n```\n\n返回如下：\n\n| time         | sym  | qty      | price   |\n| ------------ | ---- | -------- | ------- |\n| 09:30:00.001 | AAPL | 100      | 56.5    |\n| 09:30:00.001 | AAPL | 175      | 37      |\n| 09:30:00.001 | DELL | 157.6923 | 35.9615 |\n| 09:30:00.001 | DELL | 166      | 52.525  |\n| 09:30:00.001 | DELL | 141.9008 | 44.4752 |\n\n\n\n**Related information**\n\n[ewmCorr](https://docs.dolphindb.cn/zh/funcs/e/ewmCorr.html)\n\n[ewmCov](https://docs.dolphindb.cn/zh/funcs/e/ewmCov.html)\n\n[ewmStd](https://docs.dolphindb.cn/zh/funcs/e/ewmStd.html)\n\n[ewmVar](https://docs.dolphindb.cn/zh/funcs/e/ewmVar.html)\n"
    },
    "ewmStd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/ewmStd.html",
        "signatures": [
            {
                "full": "ewmStd(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [bias=false])",
                "name": "ewmStd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[com]",
                        "name": "com",
                        "optional": true
                    },
                    {
                        "full": "[span]",
                        "name": "span",
                        "optional": true
                    },
                    {
                        "full": "[halfLife]",
                        "name": "halfLife",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    },
                    {
                        "full": "[minPeriods=0]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[adjust=true]",
                        "name": "adjust",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=false]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[bias=false]",
                        "name": "bias",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [ewmStd](https://docs.dolphindb.cn/zh/funcs/e/ewmStd.html)\n\n\n\n#### 语法\n\newmStd(X, \\[com], \\[span], \\[halfLife], \\[alpha], \\[minPeriods=0], \\[adjust=true], \\[ignoreNA=false], \\[bias=false])\n\n#### 参数\n\n**X** 是一个数值型向量、矩阵或表。若 *X* 是表，只对其内数值型和布尔型的列进行计算。\n\n**com** 是一个大于等于0的数值型标量，表示质心。\n\n**span** 是一个大于等于1的数值型标量，表示跨度。\n\n**halfLife** 是一个大于0的数值型标量，表示半衰期。\n\n**alpha** 是一个(0,1]之间的浮点数，表示平滑系数。\n\n**minPeriods** 是一个整数，表示窗口中的最小观察数。默认值为0。\n\n**adjust** 是一个布尔值，表示是否除以开始阶段的衰减调整因子。默认值为 true。\n\n**ignoreNA** 是一个布尔值，表示计算权重时是否忽略 NULL 值。默认值为 false。\n\n**bias** 是一个布尔值，表示是否校正系统偏差。默认值为 false。\n\n#### 详情\n\n返回 *X* 的指数加权移动标准差。该函数必须指定 *com*, *span*, *halfLife*, *alpha* 四个参数中的一个。\n\n#### 例子\n\n```\na=[0,1,2,int(),4]\newmStd(X=a,com=0.5);\n// output\n[,0.707107,0.919866,0.919866,1.720513]\n\newmStd(X=a,com=0.5,ignoreNA=true);\n// output\n[,0.707107,0.919866,0.919866,1.679057]\n\nn = 20\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt1 = table(n:0, colNames, colTypes)\ninsert into t1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into t1 values(09:30:00.001,`AAPL,200,30.5)\ninsert into t1 values(09:30:00.001,`DELL,150,35.5)\ninsert into t1 values(09:30:00.001,`DELL,170,60.5)\ninsert into t1 values(09:30:00.001,`DELL,130,40.5)\nb=[2,4,3,6,5]\newmStd(X=t1,com=0.5);\n```\n\n| time         | sym  | qty     | price   |\n| ------------ | ---- | ------- | ------- |\n| 09:30:00.001 | AAPL |         |         |\n| 09:30:00.001 | AAPL | 70.7107 | 18.3848 |\n| 09:30:00.001 | DELL | 39.2232 | 9.2487  |\n| 09:30:00.001 | DELL | 23.271  | 17.2418 |\n| 09:30:00.001 | DELL | 27.466  | 12.6944 |\n\n相关函数：[ewmCorr](https://docs.dolphindb.cn/zh/funcs/e/ewmCorr.html), [ewmCov](https://docs.dolphindb.cn/zh/funcs/e/ewmCov.html), [ewmMean](https://docs.dolphindb.cn/zh/funcs/e/ewmMean.html), [ewmVar](https://docs.dolphindb.cn/zh/funcs/e/ewmVar.html)\n"
    },
    "ewmVar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/ewmVar.html",
        "signatures": [
            {
                "full": "ewmVar(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [bias=false])",
                "name": "ewmVar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[com]",
                        "name": "com",
                        "optional": true
                    },
                    {
                        "full": "[span]",
                        "name": "span",
                        "optional": true
                    },
                    {
                        "full": "[halfLife]",
                        "name": "halfLife",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    },
                    {
                        "full": "[minPeriods=0]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[adjust=true]",
                        "name": "adjust",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=false]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[bias=false]",
                        "name": "bias",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [ewmVar](https://docs.dolphindb.cn/zh/funcs/e/ewmVar.html)\n\n\n\n#### 语法\n\newmVar(X, \\[com], \\[span], \\[halfLife], \\[alpha], \\[minPeriods=0], \\[adjust=true], \\[ignoreNA=false], \\[bias=false])\n\n#### 参数\n\n**X** 是一个数值型向量、矩阵或表。若 *X* 是表，只对其内数值型和布尔型的列进行计算。\n\n**com** 是一个大于等于0的数值型标量，表示质心。\n\n**span** 是一个大于等于1的数值型标量，表示跨度。\n\n**halfLife** 是一个大于0的数值型标量，表示半衰期。\n\n**alpha** 是一个(0,1]之间的浮点数，表示平滑系数。\n\n**minPeriods** 是一个整数，表示窗口中的最小观察数。默认值为0。\n\n**adjust** 是一个布尔值，表示是否除以开始阶段的衰减调整因子。默认值为 true。\n\n**ignoreNA** 是一个布尔值，表示计算权重时是否忽略 NULL 值。默认值为 false。\n\n**bias** 是一个布尔值，表示是否校正系统偏差。默认值为 false。\n\n#### 详情\n\n返回 *X* 的指数加权移动方差。该函数必须指定 *com*, *span*, *halfLife*, *alpha* 四个参数中的一个。\n\n#### 例子\n\n```\na=[0,1,2,int(),4]\newmVar(X=a,com=0.5);\n// output\n[,0.5,0.846154,0.846154,2.960165]\n\newmVar(X=a,com=0.5,ignoreNA=true);\n// output\n[,0.5,0.846154,0.846154,2.819231]\n\nn = 20\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nt1 = table(n:0, colNames, colTypes)\ninsert into t1 values(09:30:00.001,`AAPL,100,56.5)\ninsert into t1 values(09:30:00.001,`AAPL,200,30.5)\ninsert into t1 values(09:30:00.001,`DELL,150,35.5)\ninsert into t1 values(09:30:00.001,`DELL,170,60.5)\ninsert into t1 values(09:30:00.001,`DELL,130,40.5)\nb=[2,4,3,6,5]\newmVar(X=t1,com=0.5);\n```\n\n| time         | sym  | qty       | price    |\n| :----------- | :--- | :-------- | :------- |\n| 09:30:00.001 | AAPL |           |          |\n| 09:30:00.001 | AAPL | 4999.9999 | 337.9999 |\n| 09:30:00.001 | DELL | 1538.4615 | 85.5384  |\n| 09:30:00.001 | DELL | 541.5384  | 297.2807 |\n| 09:30:00.001 | DELL | 754.3801  | 161.1487 |\n\n相关函数：[ewmCorr](https://docs.dolphindb.cn/zh/funcs/e/ewmCorr.html), [ewmCov](https://docs.dolphindb.cn/zh/funcs/e/ewmCov.html), [ewmMean](https://docs.dolphindb.cn/zh/funcs/e/ewmMean.html), [ewmStd](https://docs.dolphindb.cn/zh/funcs/e/ewmStd.html)\n"
    },
    "exists": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/exists.html",
        "signatures": [
            {
                "full": "exists(path)",
                "name": "exists",
                "parameters": [
                    {
                        "full": "path",
                        "name": "path"
                    }
                ]
            }
        ],
        "markdown": "### [exists](https://docs.dolphindb.cn/zh/funcs/e/exists.html)\n\n\n\n#### 语法\n\nexists(path)\n\n#### 参数\n\n**path** 字符串标量或向量，表示服务器端文件或文件夹的路径。\n\n#### 详情\n\n检查指定的文件或文件夹是否存在。`exists` 函数也能在分布式文件系统中使用。\n\n#### 例子\n\n```\nt=table(1..10 as ID, rand(1.0, 10) as x);\nsaveText(t, \"/home/DolphinDB/Data/t.txt\");\n\nexists(\"/home/DolphinDB/Data/t.txt\");\n// output\ntrue\nexists(\"/home/DolphinDB/Data/t1.txt\");\n// output\nfalse\nexists(\"/home/DolphinDB/Data\");\n// output\ntrue\n\nexists([\"/home/DolphinDB/Data/t.txt\",\"/home/DolphinDB/Data/t1.txt\",\"/home/DolphinDB/Data\"]);\n// output\n[true,false,true]\n```\n\n在分布式文件系统中检查文件或文件夹是否存在（以下脚本需要在集群中的数据节点/计算节点中执行）：\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt = db.createPartitionedTable(t, `pt, `date);\npt.append!(t);\n\nexists(\"dfs://valueDB/20170807\");\n// output\ntrue\n```\n"
    },
    "existsCatalog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/existsCatalog.html",
        "signatures": [
            {
                "full": "existsCatalog(catalog)",
                "name": "existsCatalog",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    }
                ]
            }
        ],
        "markdown": "### [existsCatalog](https://docs.dolphindb.cn/zh/funcs/e/existsCatalog.html)\n\n\n\n#### 语法\n\nexistsCatalog(catalog)\n\n#### 参数\n\n**catalog** 字符串标量，表示 catalog 的名称。\n\n#### 详情\n\n检查指定 catalog 是否存在。返回 false 或 true，分别表示不存在、存在。\n"
    },
    "existsDatabase": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/existsDatabase.html",
        "signatures": [
            {
                "full": "existsDatabase(dbUrl)",
                "name": "existsDatabase",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    }
                ]
            }
        ],
        "markdown": "### [existsDatabase](https://docs.dolphindb.cn/zh/funcs/e/existsDatabase.html)\n\n\n\n#### 语法\n\nexistsDatabase(dbUrl)\n\n#### 参数\n\n**dbUrl** 是一个字符串，表示数据库的路径。\n\n#### 详情\n\n检查指定数据库是否存在。\n\n#### 例子\n\n检查分布式数据库是否存在：\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt = db.createPartitionedTable(t, `pt, `date);\npt.append!(t);\n\nexistsDatabase(\"dfs://valueDB\");\n```\n\n输出返回：true\n\n```\nexistsDatabase(\"dfs://valueDB/20170807\");\n```\n\n输出返回：false\n"
    },
    "existsPartition": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/existsPartition.html",
        "signatures": [
            {
                "full": "existsPartition(partitionUrl, [tableName])",
                "name": "existsPartition",
                "parameters": [
                    {
                        "full": "partitionUrl",
                        "name": "partitionUrl"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [existsPartition](https://docs.dolphindb.cn/zh/funcs/e/existsPartition.html)\n\n\n\n#### 语法\n\nexistsPartition(partitionUrl, \\[tableName])\n\n#### 参数\n\n**partitionUrl** 字符串，表示分区文件夹的路径。\n\n**tableName** 字符串，表示表名。\n\n* 若分区粒度为数据库级（ [database](https://docs.dolphindb.cn/zh/funcs/d/database.html) : *chunkGranularity* = 'DATABASE'），可以不指定该参数。\n\n* 若分区粒度为表级（ [database](https://docs.dolphindb.cn/zh/funcs/d/database.html) : *chunkGranularity* = 'TABLE'）\n\n  * 若 *path* 指定的路径包含了物理索引（通过函数 [listTables](https://docs.dolphindb.cn/zh/funcs/l/listTables.html) 获取），可以不指定该参数。\n\n  * 否则，必须指定该参数。\n\n#### 详情\n\n检查指定分区是否存在。\n\n#### 例子\n\n检查分区是否在分布式文件系统中（以下脚本需要在集群的数据节点/计算节点中执行）：\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt = db.createPartitionedTable(t, `pt, `date);\npt.append!(t);\n\nlistTables(\"dfs://valueDB\")\n```\n\n| tableName | physicalIndex |\n| --------- | ------------- |\n| pt        | s             |\n\n```\nexistsPartition(\"dfs://valueDB/20170807/s\");\n// output\ntrue\n\n//表级分区时，path 不包含物理索引，检查分区时需指定表名，否则查找不到分区信息\nexistsPartition(\"dfs://valueDB/20170807\", `pt)\n// output\ntrue\n\nexistsPartition(\"dfs://valueDB/20170807\");\n// output\nfalse\n\nexistsPartition(\"dfs://valueDB\");\n// output\nfalse\n\nexistsPartition(\"dfs://valueDB/20170807/s/pt\");\n// output\nfalse\n```\n"
    },
    "existsStreamTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/existsStreamTable.html",
        "signatures": [
            {
                "full": "existsStreamTable(tableName)",
                "name": "existsStreamTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [existsStreamTable](https://docs.dolphindb.cn/zh/funcs/e/existsStreamTable.html)\n\n\n\n#### 语法\n\nexistsStreamTable(tableName)\n\n#### 参数\n\n**tableName** 字符串，表示流数据表名称。可以是普通流表、共享流表、持久化流表或高可用流表。\n\n#### 详情\n\n查询指定的流数据表是否存在。\n\n返回值：true 表示该流数据表存在；false 表示该数据表不存在。\n\n#### 例子\n\n```\nid=`XOM`GS`AAPL\nx=102.1 33.4 73.6\nrt=streamTable(id, x);\nexistsStreamTable(`rt) \n```\n\n返回：true\n\n```\nexistsStreamTable(`srt)\n```\n\n返回：false\n\n```\nshare rt as srt\nexistsStreamTable(`srt)  \n```\n\n返回：true\n"
    },
    "existsSubscriptionTopic": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/existsSubscriptionTopic.html",
        "signatures": [
            {
                "full": "existsSubscriptionTopic([server], tableName, [actionName])",
                "name": "existsSubscriptionTopic",
                "parameters": [
                    {
                        "full": "[server]",
                        "name": "server",
                        "optional": true
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[actionName]",
                        "name": "actionName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [existsSubscriptionTopic](https://docs.dolphindb.cn/zh/funcs/e/existsSubscriptionTopic.html)\n\n\n\n#### 语法\n\nexistsSubscriptionTopic(\\[server], tableName, \\[actionName])\n\n别名：existSubscriptionTopic\n\n#### 参数\n\n**server** 是一个字符串，表示订阅的流数据表所在节点的别名或远程连接的句柄。如果未指定或者为空字符串，表示流数据所在的服务器是本地实例。\n\n**tableName** 是一个字符串，表示一个共享流数据表的名称。\n\n**actionName** 是一个字符串，表示订阅任务的名称。它可以包含字母，数字和下划线。如果创建订阅时指定了 *actionName*，查询订阅时必须指定 *actionName*。\n\n#### 详情\n\n查询共享流数据表的订阅主题是否存在。存在返回 true，不存在则返回 false。\n\n#### 例子\n\n```\nt=streamTable(1000000:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nshare t as trades\ntrades_1=streamTable(1000000:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nsubscribeTable(tableName=`trades, actionName=`vwap, offset=-1, handler=append!{trades_1})\nexistsSubscriptionTopic(,`trades,`vwap)\n// output\ntrue\n```\n"
    },
    "existsTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/existsTable.html",
        "signatures": [
            {
                "full": "existsTable(dbUrl, tableName)",
                "name": "existsTable",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [existsTable](https://docs.dolphindb.cn/zh/funcs/e/existsTable.html)\n\n\n\n#### 语法\n\nexistsTable(dbUrl, tableName)\n\n#### 参数\n\n**dbUrl** 是一个字符串，表示数据库的路径。\n\n**tableName** 是表的名称。它需要用反引号(\\`)或双引号。\n\n#### 详情\n\n检查指定表是否存在于指定数据库中。\n\n#### 例子\n\n检查分区是否在分布式文件系统中（以下脚本需要在集群的数据节点/计算节点中执行）：\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt = db.createPartitionedTable(t, `pt, `date);\npt.append!(t);\n\nexistsTable(\"dfs://valueDB\", `pt);\n// output\ntrue\n\nexistsTable(\"dfs://valueDB/20170807\", `pt);\n// output\ntrue\n```\n"
    },
    "exp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/exp.html",
        "signatures": [
            {
                "full": "exp(X)",
                "name": "exp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [exp](https://docs.dolphindb.cn/zh/funcs/e/exp.html)\n\n\n\n#### 语法\n\nexp(X)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量、矩阵或表。\n\n#### 详情\n\n返回 e 的 *X* 次方。e 是一个常数，为2.71828。\n\n#### 例子\n\n```\nexp(1 2 3);\n// output\n[2.718282,7.389056,20.085537]\n\nlog(exp(1));\n// output\n1\n```\n"
    },
    "exp2": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/exp2.html",
        "signatures": [
            {
                "full": "exp2(X)",
                "name": "exp2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [exp2](https://docs.dolphindb.cn/zh/funcs/e/exp2.html)\n\n\n\n#### 语法\n\nexp2(X)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量、矩阵或表。\n\n#### 详情\n\n返回2的 *X* 次方。返回结果的数据类型为 DOUBLE 类型。\n\n#### 例子\n\n```\nexp2(3);\n// output\n8\n\nexp2(2 4 NULL 6);\n// output\n[4,16,,64]\n\nexp2(1..4$2:2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 2  | 8  |\n| 4  | 16 |\n"
    },
    "expm1": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/expm1.html",
        "signatures": [
            {
                "full": "expm1(X)",
                "name": "expm1",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [expm1](https://docs.dolphindb.cn/zh/funcs/e/expm1.html)\n\n\n\n#### 语法\n\nexpm1(X)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量、矩阵或表。\n\n#### 详情\n\n返回 exp(X)-1 的结果。\n\n#### 例子\n\n```\nexpm1(5);\n// output\n147.413159\n\nexpm1(1 2 3 NULL);\n// output\n[1.718282,6.389056,19.085537,]\n\nexpm1(1..4$2:2);\n```\n\n| #0       | #1        |\n| -------- | --------- |\n| 1.718282 | 19.085537 |\n| 6.389056 | 53.59815  |\n"
    },
    "expr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/expr.html",
        "signatures": [
            {
                "full": "expr(args...)",
                "name": "expr",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [expr](https://docs.dolphindb.cn/zh/funcs/e/expr.html)\n\n\n\n#### 语法\n\nexpr(args...)\n\n#### 参数\n\n**args** 可以是对象、运算符或元代码。元代码是由\"<\"和\">\"包围的对象和/或表达式。参数的最小数量为2。\n\n#### 详情\n\n函数 `expr`从对象、运算符或其他元代码生成元代码。\n\n#### 例子\n\n```\nexpr(6,<,8);\n// output\n< 6 < 8 >\n\nexpr(sum, 1 2 3);\n// output\n< sum [1,2,3] >\n\na=6;\nexpr(a,+,1);\n// output\n< 6 + 1 >\n\nexpr(<a>,+,1);\n// output\n< a + 1 >\n\nexpr(<a>,+,<b>);\n// output\n< a + b >\n\nexpr(a+7,*,8);\n// output\n< 13 * 8 >\n\nexpr(<a+7>,*,8);\n// output\n< (a + 7) * 8 >\n\nexpr(not, < a >);\n// output\n< ! a >\n```\n"
    },
    "extractTextSchema": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/extractTextSchema.html",
        "signatures": [
            {
                "full": "extractTextSchema(filename, [delimiter], [skipRows=0])",
                "name": "extractTextSchema",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    },
                    {
                        "full": "[skipRows=0]",
                        "name": "skipRows",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [extractTextSchema](https://docs.dolphindb.cn/zh/funcs/e/extractTextSchema.html)\n\n\n\n#### 语法\n\nextractTextSchema(filename, \\[delimiter], \\[skipRows=0])\n\n#### 参数\n\n**filename** 字符串，表示输入数据的绝对路径或相对路径。仅支持 CSV 格式的文件。若传入其他格式文件，则无法保证数据准确性。\n\n**delimiter** 字符串标量，表示数据文件中各列的分隔符。分隔符可以是一个或多个字符，默认是逗号（\",\"）。\n\n**skipRows** 是0到1024之间的整数，表示从文件头开始忽略的行数。它是一个可选参数。默认值为0。\n\n#### 详情\n\n生成输入数据文件的表的结构。表的结构有两列：列名和数据类型。\n\n数据文件中包含了表达时间、日期的数据时：\n\n* 满足分隔符要求的这部分数据（日期数据分隔符包含\"-\"、\"/\"和\".\"，时间数据分隔符为\":\"）会转换为相应的类型。例如，\"12:34:56\"转换为SECOND类型；\"23.04.10\"转换为DATE类型。\n* 对于不包含分隔符的数据，形如\"yyMMdd\"的数据同时满足0<=yy<=99，0<=MM<=12，1<=dd<=31，会被优先解析成DATE；形如\"yyyyMMdd\"的数据同时满足1900<=yyyy<=2100，0<=MM<=12，1<=dd<=31会被优先解析成DATE。\n\n**Note:** 从 2.00.10 版本开始，`loadText` 支持加载一条记录中包含多个换行符的数据文件。\n\n#### 例子\n\n```\nn=1000000\ntimestamp=09:30:00+rand(18000,n)\nID=rand(100,n)\nqty=100*(1+rand(100,n))\nprice=5.0+rand(100.0,n)\nt1 = table(timestamp,ID,qty,price)\nsaveText(t1, \"/home/DolphinDB/Data/t1.txt\")\nschema=extractTextSchema(\"/home/DolphinDB/Data/t1.txt\");\nschema;\n```\n\n| name      | type   |\n| --------- | ------ |\n| timestamp | SECOND |\n| ID        | INT    |\n| qty       | INT    |\n| price     | DOUBLE |\n"
    },
    "eye": {
        "url": "https://docs.dolphindb.cn/zh/funcs/e/eye.html",
        "signatures": [
            {
                "full": "eye(n)",
                "name": "eye",
                "parameters": [
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [eye](https://docs.dolphindb.cn/zh/funcs/e/eye.html)\n\n\n\n#### 语法\n\neye(n)\n\n#### 参数\n\n**n** 是一个正整数，表示维度。\n\n#### 详情\n\n生成一个维度为 *n* 的单位矩阵。\n\n#### 例子\n\n```\neye(3);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 0  | 0  |\n| 0  | 1  | 0  |\n| 0  | 0  | 1  |\n"
    },
    "ffill": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/ffill.html",
        "signatures": [
            {
                "full": "ffill(obj, [limit])",
                "name": "ffill",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ffill](https://docs.dolphindb.cn/zh/funcs/f/ffill.html)\n\n\n\n#### 语法\n\nffill(obj, \\[limit])\n\n#### 详情\n\n* 如果 *obj* 是一个向量，使用 NULL 值前的非空元素来填充 NULL 值。\n\n* 如果 *obj* 是一个矩阵或表，对于表中的每一列，使用 NULL 值前的非空元素来填充 NULL 值。\n\n**Attention:** 该函数会生成新的对象，不会改变输入的对象；而函数 `ffill!` 会改变输入的对象。\n\n#### 参数\n\n**obj** 可以是向量、矩阵或表。\n\n**limit** 是正整数，表示需要填充的 NULL 值的数量。\n\n#### 例子\n\n例1.\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.ffill();\n```\n\n返回：\\[1,2,3,3,3,3,4,5,6]\n\n```\nx;\n```\n\n返回：\\[1,2,3,,,,4,5,6]。由此可见，x 中的空值没有被填充。\n\n例2. 指定参数 *limit*\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.ffill(1);\n```\n\n返回：\\[1,2,3,3,,,4,5,6]\n\n```\nx.ffill(2);\nx;\n```\n\n返回：\\[1,2,3,3,3,,4,5,6]\n\n例3. 指定 *obj* 为一个表.\n\n```\ndate=[2012.06.12,2012.06.12,2012.06.13,2012.06.14,2012.06.15]\nsym=[\"IBM\",\"MSFT\",\"IBM\",\"MSFT\",\"MSFT\"]\nprice=[40.56,26.56,,,50.76]\nqty=[2200,4500,,5600,]\ntimestamp=[09:34:07,09:35:26,09:36:42,09:36:51,09:36:59]\nt=table(date,timestamp,sym,price,qty);\nt;\n```\n\n得到：\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 40.56 | 2200 |\n| 2012.06.12 | 09:35:26  | MSFT | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  |       |      |\n| 2012.06.14 | 09:36:51  | MSFT |       | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 |      |\n\n```\nt.ffill();\n```\n\n得到：\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 40.56 | 2200 |\n| 2012.06.12 | 09:35:26  | MSFT | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  | 26.56 | 4500 |\n| 2012.06.14 | 09:36:51  | MSFT | 26.56 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 5600 |\n\n```\nselect date, timestamp, sym, price.ffill() as price, qty.ffill() as qty from t context by sym;\n```\n\n得到：\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 40.56 | 2200 |\n| 2012.06.13 | 09:36:42  | IBM  | 40.56 | 2200 |\n| 2012.06.12 | 09:35:26  | MSFT | 26.56 | 4500 |\n| 2012.06.14 | 09:36:51  | MSFT | 26.56 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 5600 |\n"
    },
    "ffill!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/ffill_.html",
        "signatures": [
            {
                "full": "ffill!(obj,[limit])",
                "name": "ffill!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ffill!](https://docs.dolphindb.cn/zh/funcs/f/ffill_.html)\n\n\n\n#### 语法\n\nffill!(obj,\\[limit])\n\n#### 参数\n\n**obj** 可以是向量、矩阵或表。\n\n**limit** 是正整数，表示需要填充的 NULL 值的数量。\n\n#### 详情\n\n* * 如果 *obj* 是一个向量，使用 NULL 值前的非空元素来填充 NULL 值。\n\n* 如果 *obj* 是一个矩阵或表，对于表中的每一列，使用 NULL 值前的非空元素来填充 NULL 值。\n\n**Attention:**\n\n该函数会改变输入的对象；而函数 `ffill` 会生成新的对象，不会改变输入的对象。\n\n#### 例子\n\n例1.\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.ffill!(); \nx; \n// x 中的空值被填充了\n[1,2,3,3,3,3,4,5,6]\n```\n\n例2. 通过 *limit* 参数，指定需要填充 1 个NULL值：\n\n```\nx=1 2 3 NULL NULL NULL 4 5 6\nx.ffill!(1);\n// output\n[1,2,3,3,,,4,5,6]\n```\n\n例3. *obj* 指定为一个表\n\n```\ndate=[2012.06.12,,2012.06.13,2012.06.14,2012.06.15]\nsym=[\"IBM\",\"MSFT\",\"IBM\",\"MSFT\",\"MSFT\"]\nprice=[40.56,26.56,,,50.76]\nqty=[2200,4500,1200,5600,]\ntimestamp=[09:34:07,,09:36:42,09:36:51,09:36:59]\nt=table(date,timestamp,sym,price,qty);\n\nffill!(t);\nt;\n```\n\n输出返回：\n\n| date       | timestamp | sym  | price | qty  |\n| ---------- | --------- | ---- | ----- | ---- |\n| 2012.06.12 | 09:34:07  | IBM  | 40.56 | 2200 |\n| 2012.06.12 | 09:34:07  | MSFT | 26.56 | 4500 |\n| 2012.06.13 | 09:36:42  | IBM  | 26.56 | 1200 |\n| 2012.06.14 | 09:36:51  | MSFT | 26.56 | 5600 |\n| 2012.06.15 | 09:36:59  | MSFT | 50.76 | 5600 |\n"
    },
    "fflush": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fflush.html",
        "signatures": [
            {
                "full": "fflush(obj)",
                "name": "fflush",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    }
                ]
            }
        ],
        "markdown": "### [fflush](https://docs.dolphindb.cn/zh/funcs/f/fflush.html)\n\n\n\n#### 语法\n\nfflush(obj)\n\n#### 参数\n\n**obj** 是一个文件句柄。通常使用函数 [file](https://docs.dolphindb.cn/zh/funcs/f/file.html) 打开一个文件获得一个文件句柄。\n\n#### 详情\n\n将缓冲区中的数据写入操作系统的文件系统。该函数必须要用户登录后才能执行。\n\n**Note:**\n\n1. 将数据写入文件，建议通过 [close](https://docs.dolphindb.cn/zh/funcs/c/close.html) 关闭该文件或通过 `fflush` 强制将缓冲区的数据写入文件，否则可能丢失数据。\n\n2. 该命令并没有将数据刷入磁盘，因此，发生意外宕机时可能会出现数据丢失。\n\n#### 例子\n\n```\nrows = 10\nt=table(1..rows as id, 1..rows+100 as value)\nf1=file(\"test.bin\", \"w\")\nf1.writeRecord(t)\n// 没有关闭文件或者将缓冲区数据刷入文件。此时读取的文件并不包含新写入的数据\nt1 = table(rows:0,`id`value,`INT`INT)\nf=file('test.bin')\nf.readRecord!(t1)\n::readRecord!(f, t1) => Reach the end of a file or a buffer.\n\n// 调用 fflush\nf1.fflush()\n\nt1 = table(rows:0,`id`value,`INT`INT)\nf=file('test.bin')\nf.readRecord!(t1)\n10\n```\n"
    },
    "file": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/file.html",
        "signatures": [
            {
                "full": "file(name, [mode=\"r\"], [isLittleEndian])",
                "name": "file",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[mode=\"r\"]",
                        "name": "mode",
                        "optional": true,
                        "default": "\"r\""
                    },
                    {
                        "full": "[isLittleEndian]",
                        "name": "isLittleEndian",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [file](https://docs.dolphindb.cn/zh/funcs/f/file.html)\n\n\n\n#### 语法\n\nfile(name, \\[mode=\"r\"], \\[isLittleEndian])\n\n#### 参数\n\n**name** 字符串，表示文件名称。\n\n**mode** 字符串，表示打开的模式。\n\n**isLittleEndian** 布尔值，表示是否采用小端模式。默认情况下，采用的是操作系统的大小端模式。它是一个可选参数。\n\n#### 详情\n\nfile 函数通过给定的模式打开一个文件。该函数必须要用户登录后才能执行。\n\n打开的模式可以是以下 6 种之一：\"r\", \"r+\", \"w\", \"w+\", \"a\" 和 \"a+\"。默认的模式是 \"r\" （只读）。[close](https://docs.dolphindb.cn/zh/funcs/c/close.html) 函数用于关闭一个打开的文件。\n\n\"r\": 只读模式。游标位于文件头。\n\n\"r+\": 读写模式。游标位于文件头。\n\n\"w\": 只写模式，把文件清空。游标位于文件头。\n\n\"w+\": 读写模式。如果文件不存在将创建文件，否则把文件清空。游标位于文件头。\n\n\"a\": 追加模式（只写）。如果文件不存在将创建文件。游标位于文件尾，从文件尾开始写。连续地写文件，每次写完后，游标都会位于文件尾。\n\n\"a+\": 追加模式（读写）。如果文件不存在将创建文件。游标位于文件尾，从文件尾开始读写。连续地写文件，每次写完后，游标都会位于文件尾。\n\n#### 例子\n\n```\nfout=file(\"test.txt\",\"w\");\nfout.writeLine(\"hello world!\");\n// output\n1\nfout.close();\n\nfin = file(\"test.txt\");\nprint fin.readLine();\n// output\nhello world!\nfin.close();\n```\n"
    },
    "files": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/files.html",
        "signatures": [
            {
                "full": "files(directory, [pattern])",
                "name": "files",
                "parameters": [
                    {
                        "full": "directory",
                        "name": "directory"
                    },
                    {
                        "full": "[pattern]",
                        "name": "pattern",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [files](https://docs.dolphindb.cn/zh/funcs/f/files.html)\n\n\n\n#### 语法\n\nfiles(directory, \\[pattern])\n\n#### 参数\n\n**directory** 是表示目录路径的字符串。\n\n**pattern** 是表示在该目录下搜索的文件名的模式的字符串。\n\n#### 详情\n\n该函数必须要用户登录后才能执行。\n\n如果没有指定 *pattern*，返回一个包含目录中的文件和子目录信息的表。\n\n如果指定了 *pattern*，*函数返回一个包含文件名中包含了pattern* 的文件和子目录的表。\n\n#### 例子\n\n```\nfiles(\"/home/06_DolphinDB/01_App/DolphinDB_Win_V0.2\");\n```\n\n| filename                          | isDir | fileSize | lastAccessed  | lastModified  |\n| --------------------------------- | ----- | -------- | ------------- | ------------- |\n| LICENSE\\_AND\\_AGREEMENT.txt       | 0     | 22558    | 1495508675000 | 1483773234998 |\n| README\\_WIN.txt                   | 0     | 5104     | 1495508675000 | 1483866232680 |\n| server                            | 1     | 0        | 1496624932437 | 1496624932437 |\n| THIRD\\_PARTY\\_SOFTWARE\\_LICENS... | 0     | 8435     | 1495508675000 | 1483628426506 |\n\n```\nfiles(\"/home/06_DolphinDB/01_App/DolphinDB_Win_V0.2\", \"readme%\");\n```\n\n| filename        | isDir | fileSize | lastAccessed  | lastModified  |\n| --------------- | ----- | -------- | ------------- | ------------- |\n| README\\_WIN.txt | 0     | 5104     | 1495508675000 | 1483866232680 |\n\n```\nselect * from files(\"/home/06_DolphinDB/01_App/DolphinDB_Win_V0.2\") where filename like \"README%\";\n```\n\n| filename        | isDir | fileSize | lastAccessed  | lastModified  |\n| --------------- | ----- | -------- | ------------- | ------------- |\n| README\\_WIN.txt | 0     | 5104     | 1495508675000 | 1483866232680 |\n"
    },
    "fill!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fill_.html",
        "signatures": [
            {
                "full": "fill!(obj, index, value)",
                "name": "fill!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "index",
                        "name": "index"
                    },
                    {
                        "full": "value",
                        "name": "value"
                    }
                ]
            }
        ],
        "markdown": "### [fill!](https://docs.dolphindb.cn/zh/funcs/f/fill_.html)\n\n\n\n#### 语法\n\nfill!(obj, index, value)\n\n#### 参数\n\n**obj** 可以是一个向量、元组、矩阵、字典或表。\n\n如果 **obj** 是向量、元组或矩阵，**index** 是整数，表示下标；如果 **obj** 是字典或表，**index** 是字符串，分别表示key或列名。\n\n**value** 是标量或向量，表示新的值。\n\n#### 详情\n\n将 *obj* 中 *index* 对应位置的值设为 *value*，相当于赋值语句 obj\\[index]=value。\n\n#### 例子\n\n例1. 向量\n\n```\na=[1,2,3,4];\nfill!(a,3,12);\na;\n// output\n[1,2,3,12]\n\nfill!(a,[0,1],[10,11]);\n// output\n[10,11,3,12]\n```\n\n例2. 元组\n\n```\na=([1,2,3],[\"a\",\"b\",\"c\"]);\nfill!(a,0,[4,2]);\na[0];\n// output\n[4,2]\n\n// 创建一个长度为20，并且每个元素为 FLOAT 类型的 NULL 值\narray(ANY, 20).fill!(0:20, float());\n\n// 相当于以下语句\nt = array(ANY, 20);\nt[0:20] = float()\n```\n\n例3. 矩阵\n\n```\nm=1..12$3:4;\nfill!(m,2,5); // 将第2列的值全部设为5\nm;\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 4  | 5  | 10 |\n| 2  | 5  | 5  | 11 |\n| 3  | 6  | 5  | 12 |\n\n```\nfill!(m,[1,2],5); // 将第1,2列的值全部设为5\nm;\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 5  | 5  | 10 |\n| 2  | 5  | 5  | 11 |\n| 3  | 5  | 5  | 12 |\n\n```\nfill!(m,(1,),9); // 将第1行的值设为9\nm;\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 5  | 5  | 10 |\n| 9  | 9  | 9  | 9  |\n| 3  | 5  | 5  | 12 |\n\n```\nm.fill!((1,2),10).fill!((2,2),12); // 将第1行，第2列的值设为10，第2行第2列的值设为12\nm;\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 5  | 5  | 10 |\n| 9  | 9  | 10 | 9  |\n| 3  | 5  | 12 | 12 |\n\n例4. 表\n\n```\nt=table(1 2 3 as id,10.2 45.2 12.3 as val);\nfill!(t,`id,4 5 6);\nt;\n```\n\n| id | val  |\n| -- | ---- |\n| 4  | 10.2 |\n| 5  | 45.2 |\n| 6  | 12.3 |\n\n```\nfill!(t,`qty,452 142 48);\nt;\n```\n\n| id | val  | qty |\n| -- | ---- | --- |\n| 4  | 10.2 | 452 |\n| 5  | 45.2 | 142 |\n| 6  | 12.3 | 48  |\n\n例5. 字典\n\n```\nd=dict(`a`b`c,1 2 3);\nfill!(d,`a,4);\nd;\n// output\nc->3\na->4\nb->2\n```\n"
    },
    "find": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/find.html",
        "signatures": [
            {
                "full": "find(X, Y)",
                "name": "find",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [find](https://docs.dolphindb.cn/zh/funcs/f/find.html)\n\n\n\n#### 语法\n\nfind(X, Y)\n\n#### 参数\n\n**X** 可以是向量、字典、单列内存表、键值表或者索引内存表。\n\n**Y** 可以是标量、向量、数组向量、元组、字典、矩阵、表。\n\n#### 详情\n\n* 若 *X* 是向量，对 *Y* 中每一个元素，返回其第一次出现在 *X* 中的位置；如果没有在X中出现，返回 -1。若要查找所有出现的位置，可使用 [at](https://docs.dolphindb.cn/zh/funcs/a/at.html) 函数 。\n\n* 若 *X* 是字典，对 *Y* 中每一个元素，若其为 *X* 的键，返回 *X* 中对应的值；若不是 *X* 的键，返回 NULL。\n\n* 若 *X* 是单列内存表，对 *Y* 中每一个元素，返回其第一次出现在 *X* 的唯一列中的位置；如果没有在 *X* 的唯一列中出现，返回-1。注意：表中单列的类型不能是 Array Vector。\n\n* 若 *X* 是键值内存表或索引内存表，对 *Y* 中每一个元素，返回其第一次出现在 *X* 的主键中的位置； 如果没有在 *X* 的主键中出现，返回 -1。\n\n通过 `find` 函数，用一个大向量搜索另一个大向量时，系统将建立一个字典，用以优化性能。但如果只是用几个值搜索一个向量，系统可能不会为了优化性能建立字典。是否建立字典是动态决定的。如果需要在已经排序的向量中搜索少量数据，我们推荐使用 [binsrch](https://docs.dolphindb.cn/zh/funcs/b/binsrch.html) 函数。\n\n#### 例子\n\n*X* 是向量：\n\n```\nfind(7 3 3 5, 3);\n// output\n1\n\nat(7 3 3 5 == 3);\n// output\n[1,2]\n\n(7 3 3 5 6).find(2 4 5);\n// output\n[-1,-1,3]\n```\n\n*X* 是字典：\n\n```\nz=dict(1 2 3,4.5 6.6 3.2);\nz;\n// output\n3->3.2\n1->4.5\n2->6.6\n\nfind(z,3);\n// output\n3.2\n\nfind(z,5);\n// output\n00F\n```\n\n*X* 是单列内存表：\n\n```\nt = table(1 3 5 7 9 as id)\nfind(t, 2 3)\n// output\n[-1,1]\n```\n\n*X* 是键值表或者索引内存表：\n\n```\nkt = keyedTable(`name`id,1000:0,`name`id`age`department,[STRING,INT,INT,STRING])\ninsert into kt values(`Tom`Sam`Cindy`Emma`Nick, 1 2 3 4 5, 30 35 32 25 30, `IT`Finance`HR`HR`IT)\nfind(kt,(`Emma`Sam, 4 1));\n// output\n[3,-1]\n\nt1 = indexedTable(`sym`side, 10000:0, `sym`side`price`qty, [SYMBOL,CHAR,DOUBLE,INT])\ninsert into t1 values(`IBM`MSFT`GOOG, ['B','S','B'], 10.01 10.02 10.03, 10 10 20)\nfind(t1, (`GOOG`MSFT, ['B','S']))\n// output\n[2,1]\n```\n"
    },
    "first": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/first.html",
        "signatures": [
            {
                "full": "first(X)",
                "name": "first",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [first](https://docs.dolphindb.cn/zh/funcs/f/first.html)\n\n\n\n#### 语法\n\nfirst(X)\n\n或\n\nfirst X\n\n#### 参数\n\n**X** 可以是标量、数据对、向量、矩阵或表。\n\n#### 详情\n\n返回向量的第一个元素，或矩阵、表的第一行。\n\n**Note:** 若向量的第一个元素为 NULL，则返回 NULL。若要返回第一个非 NULL 的元素，请使用 [firstNot](https://docs.dolphindb.cn/zh/funcs/f/firstNot.html) 函数。\n\n#### 例子\n\n```\nfirst(`hello `world);\n```\n\n输出返回：hello\n\n```\nfirst(1..10);\n```\n\n输出返回：1\n\n```\nm = matrix(1 2 3, 4 5 6);\nm;\n```\n\n输出返回：\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nfirst(m);\n```\n\n输出返回：\\[1,4]\n\n相关函数：[last](https://docs.dolphindb.cn/zh/funcs/l/last.html)\n"
    },
    "firstHit": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/firstHit.html",
        "signatures": [
            {
                "full": "firstHit(func, X, target)",
                "name": "firstHit",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "target",
                        "name": "target"
                    }
                ]
            }
        ],
        "markdown": "### [firstHit](https://docs.dolphindb.cn/zh/funcs/f/firstHit.html)\n\n\n\n#### 语法\n\nfirstHit(func, X, target)\n\n#### 参数\n\n**func** 关系运算符 >, >=, <, <=, !=, <>, ==。\n\n**X** 向量，矩阵或表。\n\n**target** 和 *X* 类型相同的标量，表示比较的对象。\n\n#### 详情\n\n返回 *X* 中第一个满足 *X* *func* *target* （例如 *X*>5) 条件的元素。\n\n若 *X* 中无元素满足条件，则返回空值。\n\n通过 `firstHit` 查找时，NULL 值会被忽略。如需查找第一个非 NULL 值， 可以调用函数 [firstNot](https://docs.dolphindb.cn/zh/funcs/f/firstNot.html)。\n\n#### 例子\n\n```\nX = NULL 3.2 4.5 1.2 NULL 7.8 0.6 9.1\nfirstHit(<, X, 2.5)\n```\n\n输出返回：1.2\n\n若无元素满足查找条件，返回空值，如下面这个例子：\n\n```\nfirstHit(>, X, 10.0)\n```\n\n输出返回：NULL\n\n相关函数：[ifirstHit](https://docs.dolphindb.cn/zh/funcs/i/ifirstHit.html)\n"
    },
    "firstNot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/firstNot.html",
        "signatures": [
            {
                "full": "firstNot(X, [k])",
                "name": "firstNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k]",
                        "name": "k",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [firstNot](https://docs.dolphindb.cn/zh/funcs/f/firstNot.html)\n\n\n\n#### 语法\n\nfirstNot(X, \\[k])\n\n#### 参数\n\n**X** 可以是标量、数据对、向量、矩阵或表。\n\n**k** 是一个标量，它是可选参数。\n\n#### 详情\n\n若 *X* 是向量：\n\n* 如果没有指定 *k*，返回 *X* 中第一个不为 NULL 的元素。\n\n* 如果指定 *k*，返回 *X* 中第一个不为 *k* 或 NULL 的元素。\n\n若 *X* 是矩阵或表，在每列内进行上述计算，返回一个向量。\n\n`firstNot` 函数也支持查询分布式表和分区表。\n\n#### 例子\n\n*X* 是向量：\n\n```\nfirstNot(0 0 0 6 1, 0);\n// output\n6\n\nfirstNot(NULL 0 3 2 1, 0);\n// output\n3\n\nfirstNot(NULL 0 1 6);\n// output\n0\n\nt=table(1 1 1 1 1 2 2 2 2 2 as id, 0 0 0 2 1 NULL NULL 0 0 3 as x);\nt;\n```\n\n| id | x |\n| -- | - |\n| 1  | 0 |\n| 1  | 0 |\n| 1  | 0 |\n| 1  | 2 |\n| 1  | 1 |\n| 2  |   |\n| 2  |   |\n| 2  | 0 |\n| 2  | 0 |\n| 2  | 3 |\n\n```\nselect firstNot(x, 0) from t group by id;\n```\n\n| id | firstNot\\_x |\n| -- | ----------- |\n| 1  | 2           |\n| 2  | 3           |\n\n```\nm=matrix(0 NULL 1 2 3, NULL 2 NULL 0 3);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 0  | 2  |\n| 1  |    |\n| 2  | 0  |\n| 3  | 3  |\n\n```\nfirstNot(m, 0);\n// output\n[1,2]\n```\n"
    },
    "fixedLengthArrayVector": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fixedLengthArrayVector.html",
        "signatures": [
            {
                "full": "fixedLengthArrayVector(args…)",
                "name": "fixedLengthArrayVector",
                "parameters": [
                    {
                        "full": "args…",
                        "name": "args…"
                    }
                ]
            }
        ],
        "markdown": "### [fixedLengthArrayVector](https://docs.dolphindb.cn/zh/funcs/f/fixedLengthArrayVector.html)\n\n\n\n#### 语法\n\nfixedLengthArrayVector(args…)\n\n#### 参数\n\n**args** 可以是一个或多个向量/固定长度数组向量/元组/矩阵或表。*args* 的每个元素必须具有相同的数据类型，且必须是数组向量支持的类型。\n\n#### 详情\n\n将向量、矩阵或表拼接为一个数组向量。其拼接方式如下图所示（对应例2）：\n\n**Note:** 向量的长度（元组中每个向量的长度）、矩阵、表的行数必须相同。\n\n![](https://docs.dolphindb.cn/zh/images/fixedLengthArrayVector.png)\n\n#### 首发版本\n\n2.00.4\n\n#### 例子\n\n例1. 将多列合并成一列\n\n下例简单示意了将 2 档 bid 报价存储为数组向量的例子。\n\n```\nlogin(\"admin\",\"123456\")\nsyms=\"A\"+string(1..30)\ndatetimes=2019.01.01T00:00:00..2019.01.31T23:59:59\nn=200\nif(existsDatabase(\"dfs://stock\")) {\n      dropDatabase(\"dfs://stock\")\n}\ndb=database(\"dfs://stock\", RANGE, cutPoints(syms,3), engine=\"TSDB\");\nt=table(take(datetimes,n) as trade_time, take(syms,n) as sym,take(500+rand(10.0,n), n) as bid1, take(500+rand(20.0,n),n) as bid2)\nt1=select trade_time, sym, fixedLengthArrayVector(bid1,bid2) as bid from t\n\nquotes=db.createPartitionedTable(t1,`quotes,`sym, sortColumns=`sym`trade_time).append!(t1)\nselect * from quotes\n```\n\n| trade\\_time         | sym | bid                      |\n| ------------------- | --- | ------------------------ |\n| 2019.01.01T00:00:00 | A1  | \\[503.111142,507.55833]  |\n| 2019.01.01T00:00:30 | A1  | \\[502.991382,501.734092] |\n| 2019.01.01T00:01:00 | A1  | \\[500.790709,509.200963] |\n| 2019.01.01T00:01:30 | A1  | \\[501.127932,507.972508] |\n| 2019.01.01T00:02:00 | A1  | \\[500.678614,514.947117] |\n\n通过索引可以取出单档 bid 的数据，单独进行计算。对 bid 列应用函数计算，相当于将所有档的 bid 数据一起计算。\n\n```\nselect avg(bid[0]) as avg_bid1, avg(bid[1]) as avg_bid2, avg(bid) as avg_bid from quotes\n```\n\n| avg\\_bid1 | avg\\_bid2 | avg\\_bid |\n| --------- | --------- | -------- |\n| 505.0263  | 509.2912  | 507.16   |\n\n现实场景下，可能需要将 50 档甚至更多的报价存储为数组向量，编写脚本十分不便。由于报价字段名通常以表示报价类型的字符串加编号的形式存储，可以通过以下方式编写脚本：\n\n```\n// 随机生成 50 档报价\nn = 200\nt=table(take(datetimes,n) as trade_time, take(syms,n) as sym)\nfor(i  in 1:51){\n\n      t[\"bid\"+string(i)] = take(500+rand(10.0,n), n)\n}\n\n// 将 50 档报价存储为数组向量\nt[\"bid\"]=fixedLengthArrayVector(t[\"bid\"+string(1..50)])\nt1=select trade_time, sym, bid from t\n```\n\n结合 [unifiedCall](https://docs.dolphindb.cn/zh/funcs/ho_funcs/unifiedCall.html) 函数，可以进一步提升计算性能：\n\n```\nt[\"bid\"]=unifiedCall(fixedLengthArrayVector, t[\"bid\"+string(1..50)])\nt1=select trade_time, sym, bid from t\n```\n\n参考前例，此处随机生成交易所 A、B 的 5 档行情，然后将交易所 A、B 的 5 档报价分别存储为数组向量，最后将交易所 A、B 的报价数组向量合并存储为一个数组向量。\n\n```\n//随机生成交易所A、B的5档行情\nsyms = \"A\" + string(1..5)\ndatetimes = 2019.01.01T00:00:00..2019.01.31T23:59:59\nn = 10\nt1 = table(take(datetimes, n) as trade_time, take(syms, n) as sym)\nfor(i  in 1:6){\n      t1[\"bid\" + string(i)] = take(50 + rand(10.0, n), n)\n}\nt2 = table(take(datetimes, n) as trade_time, take(syms, n) as sym)\nfor(i  in 1:6){\n      t2[\"bid\" + string(i)] = take(50 + rand(10.0, n), n)\n}\n\n// 将交易所A、B的5档报价分别存储为数组向量\nt1[\"bid\"] = fixedLengthArrayVector(t1[\"bid\" + string(1..5)])\nt2[\"bid\"] = fixedLengthArrayVector(t2[\"bid\" + string(1..5)])\n\n// 将交易所A、B的报价合并存储为一个数组向量\nt1[\"bid\"] = fixedLengthArrayVector(t1[\"bid\"], t2[\"bid\"])\nt3 = select trade_time, sym, bid from t1\n```\n\n| trade\\_time         | sym | bid                                                            |\n| ------------------- | --- | -------------------------------------------------------------- |\n| 2019.01.01T00:00:01 | A2  | \\[58.97,50.65,54.38,50.11,56.26,52.35,52.79,55.43,52.16,53.35] |\n| 2019.01.01T00:00:02 | A3  | \\[50.25,53.45,52.68,58.19,56.51,57.54,55.22,51.74,58.63,57.43] |\n| 2019.01.01T00:00:03 | A4  | \\[56.42,50.28,57.04,52.45,51.83,57.75,55.04,57.34,57.82,53.28] |\n| 2019.01.01T00:00:04 | A5  | \\[59.90,51.73,55.54,57.74,53.48,59.62,57.26,53.99,52.67,57.82] |\n| 2019.01.01T00:00:05 | A1  | \\[53.16,59.27,52.97,50.41,58.30,57.83,54.93,56.91,52.51,57.95] |\n| 2019.01.01T00:00:06 | A2  | \\[53.14,50.87,52.62,54.47,59.97,56.99,55.32,54.66,56.77,58.39] |\n| 2019.01.01T00:00:07 | A3  | \\[58.33,59.80,52.34,57.52,57.39,54.67,51.19,52.11,55.27,53.07] |\n| 2019.01.01T00:00:08 | A4  | \\[55.21,54.88,54.38,52.36,56.56,53.81,57.84,53.24,54.87,54.63] |\n| 2019.01.01T00:00:09 | A5  | \\[52.98,55.72,55.83,50.60,51.01,57.02,54.07,54.63,55.44,59.28] |\n| 2019.01.01T00:00:00 | A1  | \\[56.68,54.55,53.11,53.38,59.60,57.35,59.92,50.62,56.06,54.69] |\n\n例2. 图例代码\n\n```\nvec = 1 5 3\ntp = [3 4 5, 4 5 6]\nm =  matrix(5 0 7, 7 6 9, 1 9 0)\ntb = table(6 9 4 as v1, 1 4 3 as v2)\nf = fixedLengthArrayVector(vec, tp, m, tb)\nf;\n\n[[1,3,4,5,7,1,6,1],[5,4,5,0,6,9,9,4],[3,5,6,7,9,0,4,3]]\n\ntypestr(f);\n// output\nFAST INT[] VECTOR\n```\n"
    },
    "flatten": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/flatten.html",
        "signatures": [
            {
                "full": "flatten(X)",
                "name": "flatten",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [flatten](https://docs.dolphindb.cn/zh/funcs/f/flatten.html)\n\n\n\n#### 语法\n\nflatten(X)\n\n#### 参数\n\n**X** 可以是向量、元组或矩阵。\n\n#### 详情\n\n将一个矩阵、一个元组或一系列向量转换成一维向量。\n\n注意：\n\n* 如果元组中的元素不包含元组，则将元组转化为一维向量。\n\n* 如果是嵌套元组，则把值为元组的元素先转化为一维向量，其它元素不变，返回的结果仍然是一个元组。\n\n#### 例子\n\n将一个矩阵转换成向量。\n\n```\nm=1..10$5:2;\nflatten(m);\n// output\n[1,2,3,4,5,6,7,8,9,10]\n```\n\n将一系列向量转换成一个向量。\n\n```\na=1..10;\nb = a cut 2;\nb;\n// output\n([1,2],[3,4],[5,6],[7,8],[9,10])\nflatten(b);\n// output\n[1,2,3,4,5,6,7,8,9,10]\n\nx=flatten([1, [2,3]]);\nx;\n// output\n[1,2,3]\n```\n\n关于将一个向量分成多个小的向量，参见 [cut](https://docs.dolphindb.cn/zh/funcs/c/cut.html) 函数。\n\n将一个嵌套元组转换成一个向量。\n\n```\nlist = (1, (2, (3, 4, 5)), (6, 7), 8, [9])\nx1 = flatten(list)\nx1\n//此时先将元组元素(3, 4, 5)、(6, 7)转换为一维向量[3,4,5]、[6,7]，返回结果仍然为元组\n// output:(1,(2,[3,4,5]),[6,7],8,[9])\nx2= flatten(x1)\nx2\n//再次执行，将元组元素(2,[3,4,5])转换为一维向量[2,3,4,5]，返回结果仍然为元组\n// output:(1,[2,3,4,5],[6,7],8,[9])\nx3= flatten(x2)\nx3\n//最后，将元组转换为一维向量\n// output:[1,2,3,4,5,6,7,8,9]\n```\n\n也可使用 `reduce` 函数循环执行转换，返回最终结果。\n\n```\nreduce(flatten, init=list)\n// output:[1,2,3,4,5,6,7,8,9]\n```\n\n若想观察逐步转换的结果，可使用 `accumulate`。\n\n```\naccumulate(flatten, init=list)\n// output:[(1,(2,(3,4,5)),(6,7),8,[9]),(1,(2,[3,4,5]),[6,7],8,[9]),(1,[2,3,4,5],[6,7],8,[9]),[1,2,3,4,5,6,7,8,9]]\n```\n\n将一个包含矩阵的元组转换成一个向量。\n\n```\nm = 1..10$5:2;\nn = ( m ,11, (12, 13), [14])\nreduce(flatten, init=n)\n// output:[1,2,3,4,5,6,7,8,9,11,12,13,14]\n```\n\n**Related information**\n\n[flip](https://docs.dolphindb.cn/zh/funcs/f/flip.html)\n"
    },
    "flip": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/flip.html",
        "signatures": [
            {
                "full": "transpose(X)",
                "name": "transpose",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            },
            {
                "full": "flip(X)",
                "name": "flip",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [flip](https://docs.dolphindb.cn/zh/funcs/f/flip.html)\n\n是 [transpose](https://docs.dolphindb.cn/zh/funcs/t/transpose.html) 的别名。\n\n\n以下是 `transpose` 函数的文档：\n### [transpose](https://docs.dolphindb.cn/zh/funcs/t/transpose.html)\n\n\n\n#### 语法\n\ntranspose(X)\n\n别名：flip(X)\n\n#### 参数\n\n**X** 是一个元组、矩阵、表或字典、数组向量或列式元组。如果 *X* 是数组向量或列式元组，则每行包含的元素个数必须相等。\n\n#### 详情\n\n* 如果 *X* 是一个元组，每个向量的长度必须相同，`transpose` 函数返回的是一个与 *X* 中每个向量长度相同的元组，返回结果中的第 n 个元素是由 *X* 中每个向量的第 n 个值组成的向量。\n\n* 如果 *X* 是一个矩阵，`transpose` 函数返回 *X* 的转置矩阵。\n\n* 如果 *X* 是一个表，`transpose` 函数把表 *X* 转换为一个有序字典（从 2.00.9 版本开始支持有序字典），表中的列名为 key，每列的值为 value。\n\n* 如果 *X* 是一个字典，它的 key 必须是 STRING 类型，`transpose` 函数把字典 *X* 转换为一个表，key 为列名，每个 key 对应的 value 可以是标量或等长的向量，表示每列的值。\n\n* 如果 *X* 是一个数组向量或列式元组，transpose 函数将 *X* 的行和列转置。\n\n#### 例子\n\n例1. *X* 是一个元组。\n\n```\nx=(`A`B`C,1 2 3);\nx.transpose();\n// output：((\"A\",1),(\"B\",2),(\"C\",3))\n```\n\n例2. *X* 是一个矩阵。\n\n```\nx=1..6 $ 3:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ntranspose x;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 2  | 3  |\n| 4  | 5  | 6  |\n\n例3. *X* 是一个表。\n\n```\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nt = table(timestamp, sym, qty, price);\nt;\n```\n\n| timestamp | sym | qty  | price  |\n| --------- | --- | ---- | ------ |\n| 09:34:07  | C   | 2200 | 49.6   |\n| 09:36:42  | MS  | 1900 | 29.46  |\n| 09:36:51  | MS  | 2100 | 29.52  |\n| 09:36:59  | MS  | 3200 | 30.02  |\n| 09:32:47  | IBM | 6800 | 174.97 |\n| 09:35:26  | IBM | 5400 | 175.23 |\n| 09:34:16  | C   | 1300 | 50.76  |\n| 09:34:26  | C   | 2500 | 50.32  |\n| 09:38:12  | C   | 8800 | 51.29  |\n\n```\ntranspose(t);\n/*\ntimestamp->[09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym->[C,MS,MS,MS,IBM,IBM,C,C,C]\nqty->[2200,1900,2100,3200,6800,5400,1300,2500,8800]\nprice->[49.6,29.46,29.52,30.02,174.97,175.23,50.76,50.32,51.29]\n*/\n```\n\n例4. *X* 是一个字典。\n\n```\nz=dict(`id`val,[`a`b`c,1 2 3]);\nz;\n/*\nval->[1,2,3]\nid->[a,b,c]\n*/\ntranspose(z);\n```\n\n| val | id |\n| --- | -- |\n| 1   | a  |\n| 2   | b  |\n| 3   | c  |\n\n```\n//当字典的 value 既包含标量又包含向量时，transpose 会重复标量的值以匹配向量的长度\nz1=dict(`id`val,[`a,1 2 3]);\nz1;\ntranspose(z1)\n```\n\n<table id=\"table_fx3_3x5_x1c\"><tbody><tr><td>\n\n**val**\n\n</td><td>\n\n**id**\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\na\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\na\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\na\n\n</td></tr></tbody>\n</table>\n"
    },
    "floor": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/floor.html",
        "signatures": [
            {
                "full": "floor(X)",
                "name": "floor",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [floor](https://docs.dolphindb.cn/zh/funcs/f/floor.html)\n\n\n\n#### 语法\n\nfloor(X)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n#### 详情\n\n`floor` 和 [ceil](https://docs.dolphindb.cn/zh/funcs/c/ceil.html) 函数分别把一个实数映射到小于等于它的最大整数，和大于等于它的最小整数。函数 [round](https://docs.dolphindb.cn/zh/funcs/r/round.html) 根据四舍五入规则把一个实数映射到最接近的整数。\n\n#### 例子\n\n```\nfloor(2.1);\n// output\n2\nfloor(2.9);\n// output\n2\nfloor(-2.1);\n// output\n-3\n\nceil(2.1);\n// output\n3\nceil(2.9);\n// output\n3\nceil(-2.1);\n// output\n-2\n\nround(2.1);\n// output\n2\nround(2.9);\n// output\n3\nround(-2.1);\n// output\n-2\n\nm = 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9 10$2:5;\nm;\n```\n\n| #0  | #1  | #2  | #3  | #4  |\n| --- | --- | --- | --- | --- |\n| 1.1 | 3.3 | 5.5 | 7.7 | 9.9 |\n| 2.2 | 4.4 | 6.6 | 8.8 | 10  |\n\n```\nfloor(m);\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  |\n| 2  | 4  | 6  | 8  | 10 |\n"
    },
    "flushComputeNodeMemCache": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/flushcomputenodememcache.html",
        "signatures": [
            {
                "full": "flushComputeNodeMemCache()",
                "name": "flushComputeNodeMemCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [flushComputeNodeMemCache](https://docs.dolphindb.cn/zh/funcs/f/flushcomputenodememcache.html)\n\n\n\n#### 语法\n\nflushComputeNodeMemCache()\n\n#### 参数\n\n无\n\n#### 详情\n\n应用于计算组中的计算节点上，将该节点的内存缓存的内容写入磁盘缓存。注意：执行该函数并不保证所有缓存内容被写入磁盘。\n\n适用场景：在计算节点升级并需要优雅重启时，首先使用该函数将内存缓存的内容写入磁盘，这样在计算节点重启后，可以避免从远程数据节点集群重新获取数据，从而提升性能。\n"
    },
    "flushOLAPCache": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/flushOLAPCache.html",
        "signatures": [
            {
                "full": "flushOLAPCache()",
                "name": "flushOLAPCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [flushOLAPCache](https://docs.dolphindb.cn/zh/funcs/f/flushOLAPCache.html)\n\n\n\n#### 语法\n\nflushOLAPCache()\n\n#### 参数\n\n无\n\n#### 详情\n\n将 OLAP 引擎缓冲区里已经完成的事务强制写入数据库。请注意，使用该函数前，需配置 *OLAPCacheEngineSize* 和 *dataSync* = 1。\n"
    },
    "flushPKEYCache": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/flushpkeycache.html",
        "signatures": [
            {
                "full": "flushPKEYCache()",
                "name": "flushPKEYCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [flushPKEYCache](https://docs.dolphindb.cn/zh/funcs/f/flushpkeycache.html)\n\n\n\n#### 语法\n\nflushPKEYCache()\n\n#### 详情\n\n将 PKEY 引擎 CacheEngine 里的数据强制写入磁盘，包括各分区上已经完成的事务的数据和长时间未使用的 Symbol Base。\n\n#### 参数\n\n无\n\n#### 例子\n\n```\nflushPKEYCache()\n```\n"
    },
    "flushTSDBCache": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/flushTSDBCache.html",
        "signatures": [
            {
                "full": "flushTSDBCache()",
                "name": "flushTSDBCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [flushTSDBCache](https://docs.dolphindb.cn/zh/funcs/f/flushTSDBCache.html)\n\n\n\n#### 语法\n\nflushTSDBCache()\n\n#### 参数\n\n无\n\n#### 详情\n\n将 TSDB 引擎缓冲区里已经完成的事务强制写入数据库。请注意，使用该函数前，需配置 *TSDBCacheEngineSize*。\n"
    },
    "fmin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fmin.html",
        "signatures": [
            {
                "full": "fmin(func, X0, [xtol=0.0001], [ftol=0.0001], [maxIter], [maxFun])",
                "name": "fmin",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X0",
                        "name": "X0"
                    },
                    {
                        "full": "[xtol=0.0001]",
                        "name": "xtol",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[ftol=0.0001]",
                        "name": "ftol",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[maxFun]",
                        "name": "maxFun",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [fmin](https://docs.dolphindb.cn/zh/funcs/f/fmin.html)\n\n#### 语法\n\nfmin(func, X0, \\[xtol=0.0001], \\[ftol=0.0001], \\[maxIter], \\[maxFun])\n\n#### 详情\n\n使用 Nelder-Mead 单纯形算法找到目标函数的最小值。\n\n注意：该算法只使用函数值，不使用一阶导数或二阶导数。\n\n#### 参数\n\n**func** 函数名，表示需要最小化的目标函数。注意：函数返回值须是数值标量类型。\n\n**X0** 数值类型的标量或向量，表示使目标函数最小化的参数的初始猜测。\n\n**xtol** 可选参数，正数值标量，表示在迭代过程中 `xopt` 之间可接受的收敛的绝对误差。默认值为 0.0001。\n\n**ftol** 可选参数，正数值标量，表示在迭代过程中 `func(xopt)` 的绝对误差可接受的收敛标准。默认值为 0.0001。\n\n**maxIter** 可选参数，非负整数标量，表示执行的最大迭代次数。\n\n**maxFun** 可选参数，非负整数标量，表示最大目标函数调用次数。\n\n#### **返回值**\n\n返回一个字典，包含以下成员：\n\n* xopt：浮点数向量，使目标函数最小化的参数值。\n\n* fopt：浮点数标量，目标函数最小值。fopt=func(xopt)。\n\n* iterations：整数标量，优化过程中执行的总迭代数。\n\n* fcalls：整数标量，优化过程中目标函数的调用次数。\n\n* warnFlag：整数标量，有三个可能值：\n\n  * 0：表示成功执行算法全过程。\n\n  * 1：表示已达最大目标函数调用次数，算法停止执行。\n\n  * 2：表示已达最大迭代次数，算法停止执行。\n\n#### 例子\n\n下例中自定义一个 f(x) 函数，使用 Nelder-Mead 单纯形算法找到其最小值。\n\n```\ndef f(x) {return x*x}\nfmin(f, 1)\n/* Ouput:\nxopt->[-8.881784197001252E-16]\nfopt->7.888609052210119E-31\niterations->17\nfcalls->34\nwarnFlag->0\n*/\n```\n\n"
    },
    "fminBFGS": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fminbfgs.html",
        "signatures": [
            {
                "full": "fminBFGS(func, X0, [fprime], [gtol=1e-5], [norm], [epsilon], [maxIter], [xrtol=0], [c1=1e-4], [c2=0.9])",
                "name": "fminBFGS",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X0",
                        "name": "X0"
                    },
                    {
                        "full": "[fprime]",
                        "name": "fprime",
                        "optional": true
                    },
                    {
                        "full": "[gtol=1e-5]",
                        "name": "gtol",
                        "optional": true,
                        "default": "1e-5"
                    },
                    {
                        "full": "[norm]",
                        "name": "norm",
                        "optional": true
                    },
                    {
                        "full": "[epsilon]",
                        "name": "epsilon",
                        "optional": true
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[xrtol=0]",
                        "name": "xrtol",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[c1=1e-4]",
                        "name": "c1",
                        "optional": true,
                        "default": "1e-4"
                    },
                    {
                        "full": "[c2=0.9]",
                        "name": "c2",
                        "optional": true,
                        "default": "0.9"
                    }
                ]
            }
        ],
        "markdown": "### [fminBFGS](https://docs.dolphindb.cn/zh/funcs/f/fminbfgs.html)\n\n\n\n#### 语法\n\nfminBFGS(func, X0, \\[fprime], \\[gtol=1e-5], \\[norm], \\[epsilon], \\[maxIter], \\[xrtol=0], \\[c1=1e-4], \\[c2=0.9])\n\n#### 详情\n\n使用 BFGS 算法找到目标函数的最小值。\n\n#### 参数\n\n**func** 函数名，表示需要最小化的目标函数。注意：函数返回值须是数值标量类型。\n\n**X0** 数值类型的标量或向量，表示使目标函数最小化的参数的初始猜测。\n\n**fprime** 可选参数，函数名，表示计算 *func* 梯度的函数。如果为空，则使用数值微分方法来获取函数梯度。\n\n**gtol** 可选参数，正数值标量，判断是否停止迭代的梯度范数衡量值。如果梯度的范数小于 *gtol*，则停止迭代。默认值为 1e-5。\n\n**norm** 可选参数，正数值标量，表示范数的阶数，默认使用最大值范数。\n\n**epsilon** 可选参数，正数值标量，表示当使用数值近似方法来求解函数梯度时使用的步长。默认值为 *1.4901161193847656e-08*。\n\n**maxIter** 可选参数，非负整数标量，表示执行的最大迭代次数，默认值为 *X0* 的大小乘以200。\n\n**xrtol** 可选参数，非负数值标量，用于判断是否结束迭代的步长衡量值。如果步长小于`xk * xrtol`（`xk`为当前参数向量），则停止迭代。默认值为 0。\n\n**c1** 可选参数，数值标量，值域为(0,1)，*c1* 应小于 *c2*，表示 Armijo 条件规则的参数。默认值为 1e-4。\n\n**c2** 可选参数，数值标量，值域为(0,1)，*c2* 应大于 *c1*，表示曲率条件规则参数。默认值为 0.9。\n\n#### 返回值\n\n返回一个字典，字典有以下成员：\n\n* xopt：浮点数向量，使目标函数最小化的参数值。\n\n* fopt：浮点数标量，目标函数最小值，fopt=func(xopt)。\n\n* gopt：浮点数向量，目标函数最小值处的梯度，func'(xopt)，应接近 0。\n\n* Hinv：浮点数矩阵，目标函数最小值处Hessian矩阵的逆矩阵。\n\n* iterations：整数标量，优化过程中执行的总迭代数。\n\n* fcalls：整数标量，优化过程中的目标函数调用次数。\n\n* gcalls：整数标量，优化过程中的梯度函数调用次数。\n\n* warnFlag：整数标量，有四个可能值：\n\n  * 0：表示成功执行算法全过程。\n\n  * 1：表示已达最大迭代次数，算法停止执行。\n\n  * 2：表示线搜索失败或者目标函数值出现极值。\n\n  * 3：表示计算结果中出现 NULL 值。\n\n#### 例子\n\n本例自定义条件，传入参数 *func*, *X0*, *fprime*，使用 BFGS 算法找到目标函数 `quadratic_cost` 的最小值。\n\n```\ndef quadratic_cost(x, Q) {\n\treturn dot(dot(x, Q), x)\n}\n\ndef quadratic_cost_grad(x, Q) {\n\treturn 2 * dot(Q, x)\n}\n\nx0 = [-3, -4]\ncost_weight = diag([1., 10.])\n\nfminBFGS(quadratic_cost{,cost_weight}, x0, quadratic_cost_grad{,cost_weight})\n\n/* Ouput:\nfcalls->8\nwarnFlag->0\nxopt->[0.000002859166,-4.54371E-7]\nHinv->\n#0              #1             \n0.508225788096  -0.001307222772\n-0.001307222772 0.050207740748 \n\ngopt->[0.000005718332,-0.000009087439]\nfopt->1.0E-11\ngcalls->8\niterations->7\n*/\n```\n\n相关函数：[fminBFGSB](https://docs.dolphindb.cn/zh/funcs/f/fminlbfgsb.html)\n"
    },
    "fminLBFGSB": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fminlbfgsb.html",
        "signatures": [
            {
                "full": "fminLBFGSB(func, X0, [fprime], [bounds], [m=10], [factr=1e7], [pgtol=1e-5], [epsilon=1e-8], [maxIter=15000], [maxFun=15000], [maxLS=20])",
                "name": "fminLBFGSB",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X0",
                        "name": "X0"
                    },
                    {
                        "full": "[fprime]",
                        "name": "fprime",
                        "optional": true
                    },
                    {
                        "full": "[bounds]",
                        "name": "bounds",
                        "optional": true
                    },
                    {
                        "full": "[m=10]",
                        "name": "m",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[factr=1e7]",
                        "name": "factr",
                        "optional": true,
                        "default": "1e7"
                    },
                    {
                        "full": "[pgtol=1e-5]",
                        "name": "pgtol",
                        "optional": true,
                        "default": "1e-5"
                    },
                    {
                        "full": "[epsilon=1e-8]",
                        "name": "epsilon",
                        "optional": true,
                        "default": "1e-8"
                    },
                    {
                        "full": "[maxIter=15000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "15000"
                    },
                    {
                        "full": "[maxFun=15000]",
                        "name": "maxFun",
                        "optional": true,
                        "default": "15000"
                    },
                    {
                        "full": "[maxLS=20]",
                        "name": "maxLS",
                        "optional": true,
                        "default": "20"
                    }
                ]
            }
        ],
        "markdown": "### [fminLBFGSB](https://docs.dolphindb.cn/zh/funcs/f/fminlbfgsb.html)\n\n\n\n#### 语法\n\nfminLBFGSB(func, X0, \\[fprime], \\[bounds], \\[m=10], \\[factr=1e7], \\[pgtol=1e-5], \\[epsilon=1e-8], \\[maxIter=15000], \\[maxFun=15000], \\[maxLS=20])\n\n#### 详情\n\n使用 L-BFGS-B 算法找到目标函数的最小值。\n\n#### 参数\n\n**func** 函数名，表示需要最小化的目标函数。注意：该函数的返回值须是数值标量类型。\n\n**X0** 数值类型的标量或向量，表示使目标函数最小化的参数的初始猜测。\n\n**fprime** 可选参数，函数名，表示计算 *func* 梯度的函数。如果为空，则使用数值微分方法来获取函数梯度。\n\n**bounds** 可选参数，数值类型矩阵，形状为(N,2)，其中 N 为需要优化的参数数量，即 N=size(X0)。每一行的两个值（min, max），定义了 X0 中对应参数的边界。可以用 `float(\"inf\")` 来表示不设边界。\n\n**m** 可选参数，正整数标量，表示有限内存矩阵的最大可变度量修正数。默认值为 10。\n\n**factr** 可选参数，数值标量，正数，用于衡量迭代是否结束的指标值。当满足条件![](https://docs.dolphindb.cn/zh/funcs/images/fminLBFGSB1.png)时，算法将停止迭代，其中 eps 是机器精度。*factr* 的典型值有：1e12 代表低精度；1e7 代表中等精度；10.0 代表极高的精度。默认值为 1e7。\n\n**pgtol** 可选参数，数值标量，正数，用于衡量迭代是否结束的指标值。当满足条件![](https://docs.dolphindb.cn/zh/funcs/images/fminLBFGSB2.png)时，算法将停止迭代，其中![](https://docs.dolphindb.cn/zh/funcs/images/fminLBFGSB3.png)是投影梯度的第 i 个分量。默认值为 1e-5。\n\n**epsilon** 可选参数，数值标量，正数，表示当使用数值近似方法来求解函数梯度时使用的步长。默认值为 1e-8。\n\n**maxIter** 可选参数，非负整数标量，表示执行的最大迭代次数，默认值为 15000。\n\n**maxFun** 可选参数，非负整数标量，表示最大目标函数调用次数，默认值为 15000。\n\n**maxLS** 可选参数，非负整数标量，表示每轮迭代的最大线搜索步数，默认值为 20。\n\n#### 返回值\n\n返回一个字典，字典有以下成员：\n\n* xopt：浮点数向量，使目标函数最小化的参数值。\n\n* fopt：浮点数标量，目标函数最小值。fopt=func(xopt)。\n\n* gopt：浮点数向量，目标函数最小值点处的函数梯度。gopt=func'(xopt)。\n\n* iterations：整数标量，优化过程中执行的总迭代数。\n\n* fcalls：整数标量，优化过程中的目标函数调用次数。\n\n* warnFlag：整数标量，有三个可能值：\n\n  * 0：表示成功执行算法全过程。\n\n  * 1：表示已达最大目标函数调用次数或已达最大迭代次数，算法停止执行。\n\n  * 2：表示由于其他原因算法停止执行。\n\n#### 例子\n\n本例自定义约束条件，传入参数 *func*, *X0*，使用 L-BFGS-B 算法找到目标函数 `fun` 的最小值。\n\n```\nX = double(0..9)\nM = 2\nB = 3\nY = double(M * X + B)\n\ndef fun(params, x, y) {\n\tm = params[0]\n\tb = params[1]\n\ty_model = m*x + b\n\terror = sum(square(y - y_model))\n\treturn error\n}\n\ninitial_values = [0.0, 1.0]\nfminLBFGSB(fun{,X,Y}, initial_values)\n\n/* Ouput:\n\nfcalls->27\nwarnFlag->0\nxopt->[1.999999985435,3.000000060585]\ngopt->[8.05E-10,8.84E-10]\nfopt->0E-12\niterations->6\n\n*/\n```\n\n相关函数：[fminBFGS](https://docs.dolphindb.cn/zh/funcs/f/fminbfgs.html)\n"
    },
    "fminNCG": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fminncg.html",
        "signatures": [
            {
                "full": "fminNCG(func, X0, fprime, fhess, [xtol=1e-5], [maxIter], [c1=1e-4], [c2=0.9])",
                "name": "fminNCG",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X0",
                        "name": "X0"
                    },
                    {
                        "full": "fprime",
                        "name": "fprime"
                    },
                    {
                        "full": "fhess",
                        "name": "fhess"
                    },
                    {
                        "full": "[xtol=1e-5]",
                        "name": "xtol",
                        "optional": true,
                        "default": "1e-5"
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[c1=1e-4]",
                        "name": "c1",
                        "optional": true,
                        "default": "1e-4"
                    },
                    {
                        "full": "[c2=0.9]",
                        "name": "c2",
                        "optional": true,
                        "default": "0.9"
                    }
                ]
            }
        ],
        "markdown": "### [fminNCG](https://docs.dolphindb.cn/zh/funcs/f/fminncg.html)\n\n\n\n#### 语法\n\nfminNCG(func, X0, fprime, fhess, \\[xtol=1e-5], \\[maxIter], \\[c1=1e-4], \\[c2=0.9])\n\n#### 详情\n\n使用牛顿共轭梯度法（Newton conjugate gradient；也称为截断牛顿法，Truncated Newton method）对目标函数进行无约束最小化。本方法适用于解决大型非线性优化问题。\n\n#### 参数\n\n**func** 函数名，表示需要最小化的目标函数。注意：函数返回值须是数值标量类型。\n\n**X0** 数值类型的标量或向量，表示使目标函数最小化的参数的初始猜测。\n\n**fprime** 函数名，表示计算 *func* 梯度的函数。\n\n**fhess** 函数名，表示计算 *func* 的 Hessian 矩阵的函数。\n\n**xtol** 可选参数，正数值标量，用于判断是否结束迭代的步长衡量值。如果两次迭代间参数变化量的范数小于 `xtol*size(X0)`，则认为算法收敛，停止迭代。默认值为 1e-5。\n\n**maxIter** 可选参数，非负整数标量，表示执行的最大迭代次数。\n\n**c1** 可选参数，数值标量，值域为(0,1)，*c1* 应小于 *c2*，表示 Armijo 条件规则的参数。默认值为 1e-4。\n\n**c2** 可选参数，数值标量，值域为(0,1)，*c2* 应大于 *c1*，表示曲率条件规则参数。默认值为 0.9。\n\n#### 返回值\n\n返回一个字典，字典有以下成员：\n\n* xopt：浮点数向量，使目标函数最小化的参数值。\n\n* fopt：浮点数标量，目标函数最小值。fopt=func(xopt)。\n\n* iterations：整数标量，优化过程中执行的总迭代数。\n\n* fcalls：整数标量，优化过程中的目标函数调用次数。\n\n* gcalls：整数标量，优化过程中的梯度函数调用次数。\n\n* hcalls：整数标量，优化过程中的计算 Hessian 函数的调用次数。\n\n* warnFlag：整数标量，有四个可能值：\n\n  * 0：表示成功执行算法全过程。\n\n  * 1：表示已达最大迭代次数，算法停止执行。\n\n  * 2：表示由于精度损失问题，线搜索失败。\n\n  * 3：表示结果产生 NULL 值。\n\n#### 例子\n\n本例自定义条件，传入参数 *f*, *X0*, *fprime*, *fhess*，使用牛顿共轭梯度法找到目标函数 `rosen` 的最小值。\n\n```\ndef rosen(x) { \n\tN = size(x);\n\treturn sum(100.0*power(x[1:N]-power(x[0:(N-1)], 2.0), 2.0)+power(1-x[0:(N-1)], 2.0));\n}\n\ndef rosen_der(x) {\n\tN = size(x);\n\txm = x[1:(N-1)]\n\txm_m1 = x[0:(N-2)]\n\txm_p1 = x[2:N]\n\tder = array(double, N)\n\tder[1:(N-1)] = (200 * (xm - xm_m1*xm_m1) - 400 * (xm_p1 - xm*xm) * xm - 2 * (1 - xm))\n\tder[0] = -400 * x[0] * (x[1] - x[0]*x[0]) - 2 * (1 - x[0])\n\tder[N-1] = 200 * (x[N-1] - x[N-2]*x[N-2])\n\treturn der\n}\n\ndef diag1(x, k) {\n\tN = size(x)\n\tm = matrix(type(x), N+1,N+1)\n\tif (k == 1) {\n\t\tfor(i in 0:N){\n\t\t\tm[i, i+1] = x[i]\n\t\t}\n\t} else {\n\t\tfor(i in 0:N){\n\t\t\tm[i+1, i] = x[i]\n\t\t}\n\t}\n\n\treturn m\n}\n\ndef rosen_hess(x) {\n\tN = size(x);\n\tx1= x[0:(N-1)] * 400\n\tH = diag1(-x1, 1) - diag1(x1, -1)\n\tdiagonal = array(type(x), N)\n\tdiagonal[0] = 1200 * x[0]*x[0] - 400 * x[1] + 2\n\tdiagonal[N-1] = 200\n\tdiagonal[1:(N-1)] = 202 + 1200 * x[1:(N-1)]*x[1:(N-1)] - 400 * x[2:N]\n\tH = H + diag(diagonal)\n\treturn H\n}\n\nX0 = [4, -2.5]\nfminNCG(rosen, X0, rosen_der, rosen_hess)\n\n/* Ouput:（返回顺序可能略有不同）\nxopt->[0.999999966120496,0.999999932105584]\nfopt->1.149654357653714E-15\niterations->34\nfcalls->45\ngcalls->45\nhcalls->34\nwarnFlag->0\n*/\n```\n"
    },
    "fminSLSQP": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fminslsqp.html",
        "signatures": [
            {
                "full": "fminSLSQP(func, X0, [fprime], [constraints], [bounds], [ftol=1e-6], [epsilon], [maxIter=100])",
                "name": "fminSLSQP",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X0",
                        "name": "X0"
                    },
                    {
                        "full": "[fprime]",
                        "name": "fprime",
                        "optional": true
                    },
                    {
                        "full": "[constraints]",
                        "name": "constraints",
                        "optional": true
                    },
                    {
                        "full": "[bounds]",
                        "name": "bounds",
                        "optional": true
                    },
                    {
                        "full": "[ftol=1e-6]",
                        "name": "ftol",
                        "optional": true,
                        "default": "1e-6"
                    },
                    {
                        "full": "[epsilon]",
                        "name": "epsilon",
                        "optional": true
                    },
                    {
                        "full": "[maxIter=100]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "100"
                    }
                ]
            }
        ],
        "markdown": "### [fminSLSQP](https://docs.dolphindb.cn/zh/funcs/f/fminslsqp.html)\n\n\n\n#### 语法\n\nfminSLSQP(func, X0, \\[fprime], \\[constraints], \\[bounds], \\[ftol=1e-6], \\[epsilon], \\[maxIter=100])\n\n#### 详情\n\n使用顺序最小二乘编程方法（Sequential Least Squares Programming, SLSQP）找到目标函数的最小值。\n\n#### 参数\n\n**func** 函数名，表示需要最小化的目标函数。注意：函数返回值须是数值标量类型。\n\n**X0** 数值类型的标量或向量，表示使目标函数最小化的参数的初始猜测。\n\n**fprime** 可选参数，函数名，表示计算 *func* 梯度的函数。如果为空，则使用数值微分方法来获取函数梯度。\n\n**constraints** 可选参数，字典向量，表示待优化参数需满足的约束条件，每个字典应包含下列成员：\n\n* type：字符串标量，表示约束类型。有两个可选值：'eq'表示等式约束，'ineq'表示不等式约束。\n\n* fun：函数名，表示约束函数。注意：函数返回值须是一个数值标量或向量。\n\n* jac：函数名，表示约束函数 fun 的梯度函数。注意：函数返回值须是一个数值向量或矩阵。\n\n  注意：\n\n  * 假设 fun 返回值的大小为 m，待优化参数的 size 为 n，则 jac 的返回值的形状必须是(n, m)。\n  * *constraints* 中的等式约束（Equality Constraint）的数量不能超过待优化参数的大小。假设待优化参数的大小为 n，*constraints* 中共有 k 个等式约束函数，*constraints* 中第 i 个等式约束的约束函数 fun 的返回值大小为 *leni*，则应满足： ![](https://docs.dolphindb.cn/zh/funcs/images/fminSLSQP2.png)\n\n**bounds** 可选参数，数值矩阵，形状为(N,2)，其中 N 为需要优化的参数数量，即 N=size(X0)。每一行的两个值（min, max），定义了对应参数的边界。\n\n**ftol** 可选参数，数值标量，正数，表示算法停止时对目标函数值的精度要求，默认值为 1e-6。\n\n**epsilon** 可选参数，数值标量，正数，表示当使用数值近似方法来求解函数梯度时使用的步长。默认值为 1.4901161193847656e-08。\n\n**maxIter** 可选参数，非负整数标量，表示最大迭代次数，默认值为 100。\n\n#### 返回值\n\n返回一个字典，字典有以下成员：\n\n* xopt：浮点数向量，使目标函数最小化的参数值。\n\n* fopt：浮点数标量，目标函数最小值。fopt=func(xopt)。\n\n* iterations：整数标量，优化过程中执行的总迭代数。\n\n* mode：整数标量，表示算法退出时的状态。mode=0 时表示成功进行优化，取其他值表示算法异常退出，详细说明可参考文档 [jacobwilliams - slsqp](https://jacobwilliams.github.io/slsqp/proc/slsqp.html)。\n\n#### 例子\n\n本例自定义条件，传入参数 *f*, *X0*, *fargs*, *fprime*, *constraints*, *bounds*，使用 SLSQP 算法找到目标函数 `rosen` 的最小值。\n\n```\ndef rosen(x) { \n\tN = size(x);\n\treturn sum(100.0*power(x[1:N]-power(x[0:(N-1)], 2.0), 2.0)+power(1-x[0:(N-1)], 2.0));\n}\n\ndef rosen_der(x) {\n\tN = size(x);\n\txm = x[1:(N-1)]\n\txm_m1 = x[0:(N-2)]\n\txm_p1 = x[2:N]\n\tder = array(double, N)\n\tder[1:(N-1)] = (200 * (xm - xm_m1*xm_m1) - 400 * (xm_p1 - xm*xm) * xm - 2 * (1 - xm))\n\tder[0] = -400 * x[0] * (x[1] - x[0]*x[0]) - 2 * (1 - x[0])\n\tder[N-1] = 200 * (x[N-1] - x[N-2]*x[N-2])\n\treturn der\n}\n\ndef eq_fun(x) {\n\treturn 2*x[0] + x[1] - 1\n}\n\ndef eq_jac(x) {\n\treturn [2.0, 1.0]\n}\n\ndef ieq_fun(x) {\n\treturn [1 - x[0] - 2*x[1], 1 - x[0]*x[0] - x[1], 1 - x[0]*x[0] + x[1]]\n}\n\ndef ieq_jac(x) {\n\tret = matrix(DOUBLE, 2, 3)\n\tret[0,:] = [-1.0, -2*x[0], -2*x[0]]\n\tret[1,:] = [-2.0, -1.0, 1.0]\n\treturn ret\n}\n\neqCons=dict(STRING, ANY)\neqCons[`type]=`eq\neqCons[`fun]=eq_fun\neqCons[`jac]=eq_jac\n\nineqCons=dict(STRING, ANY)\nineqCons[`type]=`ineq\nineqCons[`fun]=ieq_fun\nineqCons[`jac]=ieq_jac\n\ncons = [eqCons, ineqCons]\n\nX0 = [0.5, 0]\nbounds = matrix([0 -0.5, 1.0 2.0])\nres = fminSLSQP(rosen, X0, rosen_der, cons, bounds, 1e-9)\nres;\n/* Ouput:\nmode->0\nxopt->[0.414944749170,0.170110501659]\nfopt->0.342717574994\niterations->4\n*/\n```\n"
    },
    "form": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/form.html",
        "signatures": [
            {
                "full": "form(X)",
                "name": "form",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [form](https://docs.dolphindb.cn/zh/funcs/f/form.html)\n\n\n\n#### 语法\n\nform(X)\n\n#### 参数\n\n**X** 是一个任意的变量或常数。\n\n#### 详情\n\n生成变量或常数的数据形式标识符（data form ID）。数据形式标识符和对应的数据形式为：0: 标量; 1: 向量; 2: 数据对; 3: 矩阵; 4: 集合; 5: 字典; 6: 表; 10: tensor。\n\n#### 例子\n\n```\nform(false);\n// output\n0\n\nform(`TEST);\n// output\n0\n\nform(`t1`t2`t3);\n// output\n1\n\nform(1 2 3);\n// output\n1\n\nx= 1 2 3\nif(form(x) == VECTOR){y=1}\ny;\n// output\n1\n\nform(1..6$2:3);\n// output\n3\n```\n"
    },
    "format": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/format.html",
        "signatures": [
            {
                "full": "format(X, format)",
                "name": "format",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "format",
                        "name": "format"
                    }
                ]
            }
        ],
        "markdown": "### [format](https://docs.dolphindb.cn/zh/funcs/f/format.html)\n\n\n\n#### 语法\n\nformat(X, format)\n\n#### 参数\n\n**X** 可以是标量或向量。\n\n**format** 是表示 *X* 格式的字符串。\n\n#### 详情\n\n把指定格式应用到给定对象。返回结果是字符串标量或向量。\n\n根据输入对象的数据类型，`format` 函数调用 [decimalFormat](https://docs.dolphindb.cn/zh/funcs/d/decimalFormat.html) 或 [temporalFormat](https://docs.dolphindb.cn/zh/funcs/t/temporalFormat.html)。\n\n有关从数字向指定格式字符串的转换，参考（表中的备注列，请参考 [decimalFormat](https://docs.dolphindb.cn/zh/funcs/d/decimalFormat.html)）：\n\n| 标志 | 含义         | 备注  |\n| -- | ---------- | --- |\n| 0  | 强制数字位数     | 备注1 |\n| #  | 可选数字位数     | 备注2 |\n| .  | 小数点        |     |\n| %  | 百分号        | 备注3 |\n| E  | 科学计数法的符号   | 备注4 |\n| ,  | 分隔符        | 备注5 |\n| ;  | 表示正数和负数的符号 | 备注6 |\n\n有关 DolphinDB 时序对象的格式，参考：\n\n| 格式        | 含义       | 范围                                          |\n| --------- | -------- | ------------------------------------------- |\n| yyyy      | 年份（4个数字） | 1000-9999                                   |\n| yy        | 年份（2个数字  | 00-99. (00-39: 2000-2039; 40-99: 1940-1999) |\n| MM        | 月份       | 1-12                                        |\n| MMM       | 月份       | JAN, FEB, ... DEC （不区分大小写）                  |\n| dd        | 日期       | 1-31                                        |\n| HH        | 时（24小时制） | 0-23                                        |\n| hh        | 时（12小时制） | 0-11                                        |\n| mm        | 分钟       | 0-59                                        |\n| ss        | 秒        | 0-59                                        |\n| aa        | 上午/下午    | AM, PM. （不区分大小写）                            |\n| SSS       | 毫秒       | 0-999                                       |\n| nnnnnn    | 微秒       | 0-999999                                    |\n| nnnnnnnnn | 纳秒       | 0-999999999                                 |\n\n#### 例子\n\n```\nt = table(1..100 as id, (1..100 + 2018.01.01) as date, rand(100.0, 100) as price, rand(10000, 100) as qty);\nt;\n```\n\n| id  | date       | price     | qty  |\n| --- | ---------- | --------- | ---- |\n| 1   | 2018.01.02 | 70.832104 | 1719 |\n| 2   | 2018.01.03 | 12.22557  | 6229 |\n| 3   | 2018.01.04 | 8.695886  | 1656 |\n| 4   | 2018.01.05 | 24.324535 | 2860 |\n| 5   | 2018.01.06 | 0.443173  | 6874 |\n| 6   | 2018.01.07 | 90.302176 | 3277 |\n| 7   | 2018.01.08 | 78.556843 | 3424 |\n| 8   | 2018.01.09 | 45.836447 | 8636 |\n| 9   | 2018.01.10 | 57.416425 | 707  |\n| 10  | 2018.01.11 | 98.879764 | 2267 |\n| ... |            |           |      |\n\n```\nselect id, date.format(\"MM/dd/yyyy\") as date, price.format(\"00.00\") as price, qty.format(\"#,###\") as qty from t;\n```\n\n| id  | date       | price | qty   |\n| --- | ---------- | ----- | ----- |\n| 1   | 01/02/2018 | 70.83 | 1,719 |\n| 2   | 01/03/2018 | 12.23 | 6,229 |\n| 3   | 01/04/2018 | 08.70 | 1,656 |\n| 4   | 01/05/2018 | 24.32 | 2,860 |\n| 5   | 01/06/2018 | 00.44 | 6,874 |\n| 6   | 01/07/2018 | 90.30 | 3,277 |\n| 7   | 01/08/2018 | 78.56 | 3,424 |\n| 8   | 01/09/2018 | 45.84 | 8,636 |\n| 9   | 01/10/2018 | 57.42 | 707   |\n| 10  | 01/11/2018 | 98.88 | 2,267 |\n| ... |            |       |       |\n"
    },
    "fromJson": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fromJson.html",
        "signatures": [
            {
                "full": "fromJson(X)",
                "name": "fromJson",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [fromJson](https://docs.dolphindb.cn/zh/funcs/f/fromJson.html)\n\n\n\n#### 语法\n\nfromJson(X)\n\n#### 参数\n\n**X** 是符合 DolphinDB 规范的 JSON 字符串数据。\n\n#### 详情\n\n将符合 DolphinDB 规范的 JSON 格式的字符串转换为 DolphinDB 对象。\n\n符合 DolphinDB 规范的 JSON 字符串应至少包含3个键值对：\"form\"（数据结构）、\"type\"（数据类型）、\"value\"（值）。键值对 \"value\" 的值为实际数据。\n\n当数据结构为表时，键值对 \"name\" 可用来指定列名；若为其他数据结构，键值对 ''name\" 无意义。\n\n#### 例子\n\n```\nx=1 2 3\ny=toJson(x)\ny;\n// output\n{\"name\":\"x\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[1,2,3]}\n\nfromJson(y);\n// output\n[1,2,3]\n```\n\n相关函数：[toJson](https://docs.dolphindb.cn/zh/funcs/t/toJson.html)\n"
    },
    "fromStdJson": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fromStdJson.html",
        "signatures": [
            {
                "full": "fromStdJson(X)",
                "name": "fromStdJson",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [fromStdJson](https://docs.dolphindb.cn/zh/funcs/f/fromStdJson.html)\n\n\n\n#### 语法\n\nfromStdJson(X)\n\n#### 参数\n\n**X** 符合标准 JSON 格式的字符串，或由这些字符串组成的向量。\n\n#### 详情\n\n将标准 JSON 文本转化为符合 DolphinDB 规范的数据。\n\n转换规则说明：\n\n<table id=\"table_ezp_wtt_mbc\"><thead><tr><th>\n\nJSON 数据类型\n\n</th><th>\n\n对应 DolphinDB 数据类型/形式\n\n</th></tr></thead><tbody><tr><td>\n\n对象\n\n</td><td>\n\n转换为字典，key 类型始终为 STRING；如果其 value 由多种类型组成，那么 value 的类型为 ANY。\n\n</td></tr><tr><td>\n\n数组\n\n</td><td>\n\n向量\n\n</td></tr><tr><td>\n\n字符串\n\n</td><td>\n\n优先解析为 TEMPORAL 类型；如果解析失败，则转换为 STRING。\n\n</td></tr><tr><td>\n\n数字\n\n</td><td>\n\nDOUBLE\n\n</td></tr><tr><td>\n\n布尔值\n\n</td><td>\n\nBOOL\n\n</td></tr><tr><td>\n\nnull\n\n</td><td>\n\nNULL\n\n</td></tr></tbody>\n</table>**Note:**\n\n该函数会自动解析表示转义的特殊字符，如 `\\n`、`\\r` 等。\n\n#### 例子\n\n```\nX = \"\\\"\\\\u4e2d\\\\u6587\\\"\";\nfromStdJson(X);\n//output: 中文\n\nX = \"\\\"\\\\u4e2d\\\\n\\\\u6587\\\"\";\nfromStdJson(X);\n//output: 中\n//        文\n\nX = \"[1, 2, 3]\";\nfromStdJson(X);\n//output:[1,2,3]\n\nX = \"[1, null, false, \\\"2012.06.13 13:30:10\\\", [\\\"\\\\u5d4c\\\\u5957\\\\u6570\\\\u7ec4\\\"]]\";\nfromStdJson(X);\n//output:(1,,false,2012.06.13T13:30:10,[\"嵌套数组\"])\n\nX = \"{\\\"1\\\": \\\"2017.07.10 14:10:12\\\",\\\"0\\\": \\\"2012.06.13 13:30:10\\\"}\";\nfromStdJson(X);\n//output:1->2017.07.10T14:10:12\n//       0->2012.06.13T13:30:10\n```\n\n相关函数：[toStdJson](https://docs.dolphindb.cn/zh/funcs/t/toStdJson.html)\n"
    },
    "fromUTF8": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fromUTF8.html",
        "signatures": [
            {
                "full": "fromUTF8(str, encode)",
                "name": "fromUTF8",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "encode",
                        "name": "encode"
                    }
                ]
            }
        ],
        "markdown": "### [fromUTF8](https://docs.dolphindb.cn/zh/funcs/f/fromUTF8.html)\n\n\n\n#### 语法\n\nfromUTF8(str, encode)\n\n#### 参数\n\n**str** 是一个字符串标量或向量。\n\n**encode** 是一个字符串，表示 *str* 的目标编码名称。\n\n#### 详情\n\n把 UTF8 编码的字符串转换为其他编码。DolphinDB 对编码名称的大小写敏感，所有编码名称必须用小写表示。\n\n因为 Windows 版本目前仅支持 gbk 和 utf-8 两种编码的相互转换，因此在 Windows 中，`fromUTF8` 的第二个参数只能是 \"gbk\"。Linux 版本支持任意两种编码之间的转换。\n\n#### 例子\n\n```\nfromUTF8(\"DolphinDB\",\"gbk\");\n```\n\n输出返回：DolphinDB\n\n```\nfromUTF8([\"hello\",\"world\"],\"euc-cn\");\n```\n\n输出返回：\\[\"hello\",\"world\"]\n\n相关函数：[convertEncode](https://docs.dolphindb.cn/zh/funcs/c/convertEncode.html), [toUTF8](https://docs.dolphindb.cn/zh/funcs/t/toUTF8.html)\n"
    },
    "fTest": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fTest.html",
        "signatures": [
            {
                "full": "fTest(X, Y, [ratio=1.0], [confLevel=0.95])",
                "name": "fTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[ratio=1.0]",
                        "name": "ratio",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[confLevel=0.95]",
                        "name": "confLevel",
                        "optional": true,
                        "default": "0.95"
                    }
                ]
            }
        ],
        "markdown": "### [fTest](https://docs.dolphindb.cn/zh/funcs/f/fTest.html)\n\n\n\n#### 语法\n\nfTest(X, Y, \\[ratio=1.0], \\[confLevel=0.95])\n\n#### 参数\n\n**X** 是一个数值向量，表示用于F检验的样本。\n\n**Y** 是一个数值向量，表示用于独立双样本F检验的另一个样本。它是可选参数。\n\n**ratio** 是一个大于0的浮点数，表示X和Y方差的比例的假设值。默认值是1.0。\n\n**confLevel** 是0到1之间的浮点数，表示置信区间的置信水平。\n\n#### 详情\n\n对 *X* 和 *Y* 进行 F 检验。返回的结果是一个字典，包含以下 key：\n\n* numeratorDf：分子的自由度\n\n* stat：一张表，包含三种不同备择假设下的 p 值和置信区间\n\n* denominatorDf：分母的自由度\n\n* confLevel：置信水平\n\n* fValue：F 统计量\n\n* method：字符串 \"F test to compare two variances\"\n\n#### 例子\n\n```\nx = norm(10.0, 1.0, 20);\ny = norm(1.0, 2.0, 10);\nfTest(x, y, 0.5);\n// output\nnumeratorDf->19\nstat->\nalternativeHypothesis                  pValue    lowerBound upperBound\n-------------------------------------- --------- ---------- ----------\nratio of variances is not equal to 0.5 0.002326  0.025844   0.274161\nratio of variances is less than 0.5    0.001163  0          0.230624\nratio of variances is greater than 0.5 0.998837  0.032295   Infinity\n\ndenominatorDf->9\nconfLevel->0.95\nfValue->0.190386\nmethod->F test to compare two variances\n```\n"
    },
    "funcByName": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/funcByName.html",
        "signatures": [
            {
                "full": "funcByName(name)",
                "name": "funcByName",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [funcByName](https://docs.dolphindb.cn/zh/funcs/f/funcByName.html)\n\n\n\n#### 语法\n\nfuncByName(name)\n\n#### 参数\n\n**name** 是一个字符串，表示运算符或函数。函数可为内置函数或自定义函数。\n\n#### 详情\n\n动态执行函数或运算符，主要用于元编程。\n\n#### 例子\n\n```\ndef f(x, a, b){\n   return funcByName(x)(a, b)\n}\n\nf(\"+\", 1 2 3, 4 5 6);\n// output\n[5,7,9]\n\nf(\"sub\", 1 8 3, 4 8 6);\n// output\n[-3,0,-3]\n\nf(\"corr\", 1 8 3, 4 8 6);\n// output\n0.970725\n\ndef cal(a,b){\n   return pow(a\\b,2)\n}\n\nf(\"cal\", 4 8 10, 2 2 2);\n// output\n[4,16,25]\n\nfuncByName(\"call\")(sum,1..10);\n// output\n55\n```\n"
    },
    "fy5253": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fy5253.html",
        "signatures": [
            {
                "full": "fy5253(X, [weekday=0], [startingMonth=1], [nearest=true], [offset], [n=1])",
                "name": "fy5253",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weekday=0]",
                        "name": "weekday",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[nearest=true]",
                        "name": "nearest",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [fy5253](https://docs.dolphindb.cn/zh/funcs/f/fy5253.html)\n\n\n\n#### 语法\n\nfy5253(X, \\[weekday=0], \\[startingMonth=1], \\[nearest=true], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**weekday** 是0到6之间的整数，表示星期编号。0表示星期一，1表示星期二，... ，6表示星期日。默认值为0。\n\n**startingMonth** 是1到12之间的整数，表示一年的起始月份。默认值是1。\n\n**nearest** 是一个布尔值。默认值为 true。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于X中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n采用52-53周财年（4-4-5历），该函数返回X所在财政年度的起始日期。\n\n* 如果 *nearest*=true，表示将最接近 *startingMonth* 最后一天的 *weekday* 的日期作为财政年度的起始日期。\n\n* 如果 *nearest*=false，表示将 *startingMonth* 中最后一个 *weekday* 的日期作为财政年度的起始日期。\n\n如果指定了 *offset*，表示从 *offset* 开始，结果每隔 *n* 年更新一次。注意，只有当 *n*>1 时，*offset* 才会生效。\n\n#### 例子\n\n```\nfy5253(2016.11.01,0,1,true);\n// output\n2016.02.01\n// 最接近2016.01.31的周一是2016.02.01\n\nfy5253(2016.11.01,0,1,false);\n// output\n2016.01.25\n// 2016年1月中最后一个周一是2016.01.25\n\ndate=2011.10.25 2012.10.25 2013.10.25 2014.10.25 2015.10.25 2016.10.25 2017.10.25 2018.10.25 2019.10.25 2020.10.25\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by fy5253(date,0,1,true,2011.10.01,2);\n```\n\n| fy5253\\_date | avg\\_price | sum\\_qty |\n| ------------ | ---------- | -------- |\n| 2011.01.31   | 39.53      | 4100     |\n| 2013.01.28   | 29.77      | 5300     |\n| 2015.02.02   | 175.1      | 12200    |\n| 2017.01.30   | 50.54      | 3800     |\n| 2019.01.28   | 51.835     | 13300    |\n\n相关函数：[fy5253Quarter](https://docs.dolphindb.cn/zh/funcs/f/fy5253Quarter.html)\n"
    },
    "fy5253Quarter": {
        "url": "https://docs.dolphindb.cn/zh/funcs/f/fy5253Quarter.html",
        "signatures": [
            {
                "full": "fy5253Quarter(X, [weekday=0], [startingMonth=1], [qtrWithExtraWeek=1], [nearest=true], [offset], [n=1])",
                "name": "fy5253Quarter",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weekday=0]",
                        "name": "weekday",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[qtrWithExtraWeek=1]",
                        "name": "qtrWithExtraWeek",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[nearest=true]",
                        "name": "nearest",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [fy5253Quarter](https://docs.dolphindb.cn/zh/funcs/f/fy5253Quarter.html)\n\n\n\n#### 语法\n\nfy5253Quarter(X, \\[weekday=0], \\[startingMonth=1], \\[qtrWithExtraWeek=1], \\[nearest=true], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**weekday** 是0到6之间的整数，表示星期编号。0表示星期一，1表示星期二，... ，6表示星期日。默认值为0。\n\n**startingMonth** 是1到12之间的整数，表示一年的起始月份。默认值是1。\n\n**qtrWithExtraWeek** 是1到4之间的整数。如果有闰季（一般一个季度有13周，闰季有14周），它表示闰季所在的季度。\n\n**nearest** 是一个布尔值。默认值为 true。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n采用52-53周财年（4-4-5历），该函数返回X所在财政季度的起始日期。\n\n* 如果 *nearest*=true，表示将最接近 *startingMonth* 最后一天的 *weekday* 的日期作为财政年度的起始日期。\n\n* 如果 *nearest*=false，表示将 *startingMonth* 中最后一个 *weekday* 的日期作为财政年度的起始日期。\n\n如果指定了 *offset*，表示从 *offset* 开始，结果每隔 *n* 个季度更新一次。注意，只有当 *n*>1 时，*offset* 才会生效。\n\n#### 例子\n\n```\nfy5253Quarter(2019.12.01,0,1,1,true);\n// output\n2019.11.04\n\nfy5253Quarter(2019.12.01,0,1,4,true);\n// output\n2019.10.28\n// 2019年的财年起始日期是2019.01.28，2020年的财年起始日期是2020.02.03，两者相差53周，说明有一个闰季。qtrWithExtraWeek=1表示第一个季度为闰季，它包含14周，因此2019.12.01所在季度的起始日期为2019.11.01；qtrWithExtraWeek=4表示第4个季度为闰季，它包含14周，因此2019.12.01所在季度的起始日期是2019.10.28。\n\ndate=2016.01.12 2016.02.25 2016.05.12 2016.06.28 2016.07.10 2016.08.18 2016.09.02 2016.10.16 2016.11.26 2016.12.30\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by fy5253Quarter(date,0,1,1,true,2016.01.01,2);\n```\n\n| fy5253Quarter\\_date | avg\\_price | sum\\_qty |\n| ------------------- | ---------- | -------- |\n| 2015.11.02          | 39.53      | 4100     |\n| 2016.05.02          | 85.136667  | 21300    |\n| 2016.10.31          | 51.835     | 13300    |\n\n相关函数：[fy5253](https://docs.dolphindb.cn/zh/funcs/f/fy5253.html)\n"
    },
    "hashBucket": {
        "url": "https://docs.dolphindb.cn/zh/funcs/h/hashBucket.html",
        "signatures": [
            {
                "full": "hashBucket(X, buckets)",
                "name": "hashBucket",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "buckets",
                        "name": "buckets"
                    }
                ]
            }
        ],
        "markdown": "### [hashBucket](https://docs.dolphindb.cn/zh/funcs/h/hashBucket.html)\n\n\n\n#### 语法\n\nhashBucket(X, buckets)\n\n#### 参数\n\n**X** 可以是标量或向量。\n\n**buckets** 是一个正整数。\n\n#### 详情\n\n计算 *X* 的哈希值。哈希分区是基于分区列元素的哈希值。\n\n#### 例子\n\n```\nhashBucket(34 45 67, 10);\n\n// output\n[4,5,7]\n\nhashBucket(`AAPL`TSLA`GS`MS`GE`BA`UAL`WMT, 10);\n\n// output\n[9,4,1,8,3,7,5,2]\n```\n"
    },
    "hasNull": {
        "url": "https://docs.dolphindb.cn/zh/funcs/h/hasNull.html",
        "signatures": [
            {
                "full": "hasNull(X)",
                "name": "hasNull",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [hasNull](https://docs.dolphindb.cn/zh/funcs/h/hasNull.html)\n\n\n\n#### 语法\n\nhasNull(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n判断 *X* 中是否包含 NULL 值。\n\n* 如果 *X* 是标量，当 *X* 为 NULL 值时，该函数返回 true。\n\n* 如果 *X* 是向量，当 *X* 中至少有一个元素为 NULL 时，该函数返回 true。\n\n* 如果 *X* 是矩阵或表，当 *X* 中至少有一列包含 NULL 值时，该函数返回 true。\n\n#### 例子\n\n```\nhasNull NULL;\n// output\ntrue\n\nx=00f;\nhasNull x;\n// output\ntrue\n\nhasNull 5;\n// output\nfalse\n\nhasNull(1 2 NULL 4 NULL 6);\n// output\ntrue\n\nx=((NULL,1),2);\nhasNull x;\n// output\nfalse\n\nm=(1 NULL 3 4 5 6)$2:3;\nhasNull m;\n// output\ntrue\n\nt=table(`AAPL`IBM`MSFT as sym, 2200 NULL 4500 as qty);\nhasNull(t);\n// output\ntrue\n```\n\n相关函数：[isNull](https://docs.dolphindb.cn/zh/funcs/i/isNull.html), [nullFill](https://docs.dolphindb.cn/zh/funcs/n/nullFill.html)\n"
    },
    "haStreamTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/h/haStreamTable.html",
        "signatures": [
            {
                "full": "haStreamTable(raftGroup, table, tableName, cacheLimit, [keyColumn], [retentionMinutes=1440])",
                "name": "haStreamTable",
                "parameters": [
                    {
                        "full": "raftGroup",
                        "name": "raftGroup"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "cacheLimit",
                        "name": "cacheLimit"
                    },
                    {
                        "full": "[keyColumn]",
                        "name": "keyColumn",
                        "optional": true
                    },
                    {
                        "full": "[retentionMinutes=1440]",
                        "name": "retentionMinutes",
                        "optional": true,
                        "default": "1440"
                    }
                ]
            }
        ],
        "markdown": "### [haStreamTable](https://docs.dolphindb.cn/zh/funcs/h/haStreamTable.html)\n\n\n\n#### 语法\n\nhaStreamTable(raftGroup, table, tableName, cacheLimit, \\[keyColumn], \\[retentionMinutes=1440])\n\n#### 参数\n\n**raftGroup** 是一个大于1的整数，表示 Raft 组的 ID。\n\n**table** 是一个表对象。它必须是一个由 `table` 函数创建的空表。\n\n**tableName** 是一个字符串，表示高可用流数据表的名称。\n\n**cacheLimit** 是一个整数，表示高可用流数据表在内存中最多保留多少行。如果 *cacheLimit* 是小于100,000的正整数，它会被自动调整为100,000。\n\n**keyColumn** 是一个字符串标量或向量，表示主键。它是一个可选参数。\n\n**retentionMinutes** 是一个整数，表示保留大小超过 1GB 的 log 文件的时间（从文件的最后修改时间开始计算），单位是分钟。默认值是1440，即一天。\n\n#### 详情\n\n创建高可用流数据表。该函数只能在启用流数据高可用后使用。要启用流数据高可用，用户需要在集群配置文件 cluster.cfg 中指定配置参数 *streamingHAMode* 和 *streamingRaftGroups*。系统启动时，配置参数 *streamingRaftGroup* 指定的数据节点/计算节点组成 Raft 组，一个数据节点/计算节点作为 Leader，其他数据节点/计算节点作为 Follower。Raft 组的每个数据节点/计算节点上都有流数据表的副本。\n\n客户端只需订阅 Raft 组中任意一个数据节点/计算节点上的高可用流数据表，并启用订阅的自动重连功能，即把 *reconnect* 参数设置为 true。Leader 上的高可用流数据表会向客户端发布数据。如果 Raft 组中的 Leader 宕机，系统会选举出新的 Leader 继续发布数据，客户端会自动切换订阅到新的 Leader 上的高可用流数据表。\n\n一个 Raft 组可以包含多个高可用流数据表。\n\n#### 例子\n\n假设配置参数 *streamingRaftGroup*=11:NODE1:NODE2:NODE3，在 Raft 组的任意一个节点如 NODE1 上执行以下脚本创建高可用流数据表 trades：\n\n```\ncolNames = `timestamp`sym`qty`price\ncolTypes = [TIMESTAMP,SYMBOL,INT,DOUBLE]\nt=table(1:0,colNames,colTypes)\nhaStreamTable(11,t,`trades,100000);\n```\n\n在集群的另外一个节点 NODE4 上执行以下脚本订阅表 trades，把订阅的数据保存至分布式数据库中。\n\n```\nif(existsDatabase(\"dfs://stock\")){\n   dropDatabase(\"dfs://stock\")\n}\ndb=database(directory=\"dfs://stock\",partitionType=VALUE,partitionScheme=2018.08.01..2019.12.30)\nt=table(1:0,`timestamp`sym`qty`price,[TIMESTAMP,SYMBOL,INT,DOUBLE])\ntrades_slave=db.createPartitionedTable(table=t,tableName=`trades_slave,partitionColumns=`timestamp);\nsubscribeTable(server=NODE2,tableName=`trades,actionName=`sub_trades,offset=-1,handler=append!{trades_slave},msgAsTable=true,batchSize=1000,throttle=1,hash=-1,reconnect=true);\n\n// 这里subscribeTable函数的第一个参数可以是NODE1,NODE2,NODE3中的任意一个，reconnect参数必须为true。\n```\n\n在 NODE4 上执行以下脚本取消订阅：\n\n```\nunsubscribeTable(server=NODE2,tableName=`trades,actionName=`sub_trades);\n// 这里unsubscribeTable函数的第一个参数可以是 NODE1, NODE2, NODE3 中的任意一个。\n```\n\n相关函数：[dropStreamTable](https://docs.dolphindb.cn/zh/funcs/d/dropStreamTable.html), [getStreamingLeader](https://docs.dolphindb.cn/zh/funcs/g/getStreamingLeader.html), [getStreamingRaftGroups](https://docs.dolphindb.cn/zh/funcs/g/getStreamingRaftGroups.html)\n"
    },
    "head": {
        "url": "https://docs.dolphindb.cn/zh/funcs/h/head.html",
        "signatures": [
            {
                "full": "head(X, [n=1])",
                "name": "head",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [head](https://docs.dolphindb.cn/zh/funcs/h/head.html)\n\n\n\n#### 语法\n\nhead(X, \\[n=1])\n\n#### 参数\n\n**X** 可以是向量、矩阵或表。\n\n**n** 是一个正整数。\n\n#### 详情\n\n`head` 返回向量的前 *n* 个元素，或矩阵的前 *n* 列，或表的前 *n* 行。如果 *n* 没有指定，*n* 取默认值1。\n\n#### 例子\n\n```\nx=1..10; head(x);\n// output\n1\n\nx=1..10$2:5;\nx;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  |\n| 2  | 4  | 6  | 8  | 10 |\n\n```\nx.head();\n// output\n[1,2]\n\nhead(x,2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\nx=table(1..5 as a, 6..10 as b);\nx;\n```\n\n| a | b  |\n| - | -- |\n| 1 | 6  |\n| 2 | 7  |\n| 3 | 8  |\n| 4 | 9  |\n| 5 | 10 |\n\n```\nhead(x);\n// output\nb->6\na->1\n\nx.head(2);\n```\n\n| a | b |\n| - | - |\n| 1 | 6 |\n| 2 | 7 |\n\n相关函数：[tail](https://docs.dolphindb.cn/zh/funcs/t/tail.html)\n"
    },
    "hex": {
        "url": "https://docs.dolphindb.cn/zh/funcs/h/hex.html",
        "signatures": [
            {
                "full": "hex(X, [reverse=false])",
                "name": "hex",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[reverse=false]",
                        "name": "reverse",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [hex](https://docs.dolphindb.cn/zh/funcs/h/hex.html)\n\n#### 语法\n\nhex(X, \\[reverse=false])\n\n#### 详情\n\n把如下数据类型转换为十六进制数据显示。返回的结果是 STRING 类型。数据类型如下：\n\n* INTEGRAL\n* FLOAT\n* COMPLEX\n* BINARY\n\n#### 参数\n\n**X** 是一个整型标量或向量。\n\n**reverse** 是一个布尔值，表示高低位是否互换。默认值是 false。\n\n#### 例子\n\n```\nhex(16 25);\n//output: [\"00000010\",\"00000019\"]\n```\n\n```\nhex(16 25,true);\n//output: [\"10000000\",\"19000000\"]\n```\n\n```\nhex(compress(1 2 3));\n//output: [\"00\",\"05\",\"ff\",\"01\",\"04\",\"04\",\"00\",\"00\",\"ff\",\"ff\",\"ff\",\"ff\",\"03\",\"00\",\"00\",\"00\",\"ff\",\"ff\",\"ff\",\"ff\",\"0d\",\"00\",\"00\",\"80\",\"c0\",\"01\",\"00\",\"00\",\"00\",\"02\",\"00\",\"00\",\"00\",\"03\",\"00\",\"00\",\"00\"]\n```\n\n```\na = hex(123.456 3.1415926)\nprint a\n//output: [\"405edd2f1a9fbe77\",\"400921fb4d12d84a\"]\n```\n\n\n\n**Related information**\n\n[数据类型](https://docs.dolphindb.cn/zh/progr/data_types.html)\n"
    },
    "highDouble": {
        "url": "https://docs.dolphindb.cn/zh/funcs/h/highDouble.html",
        "signatures": [
            {
                "full": "highDouble(X)",
                "name": "highDouble",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [highDouble](https://docs.dolphindb.cn/zh/funcs/h/highDouble.html)\n\n\n\n#### 语法\n\nhighDouble(X)\n\n#### 参数\n\n**X** 是一个标量或向量，必须是16字节的数据类型。\n\n#### 详情\n\n返回值为 *X* 的高位8字节的数据，为 DOUBLE 类型。\n\n#### 例子\n\n```\nx=1 2 3 4\ny=4 3 2 1\npoints = point(x, y)\nx1 = highDouble(points)\n// output\n[4,3,2,1]\n```\n\n获取一个复数的虚部（虚数）\n\n```\na=complex(2, 5)\nhighDouble(a)\n// output\n5\n```\n"
    },
    "highLong": {
        "url": "https://docs.dolphindb.cn/zh/funcs/h/highlong.html",
        "signatures": [
            {
                "full": "highLong(X)",
                "name": "highLong",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [highLong](https://docs.dolphindb.cn/zh/funcs/h/highlong.html)\n\n\n\n#### 语法\n\nhighLong(X)\n\n#### 参数\n\n**X** 是一个标量、向量、表、数据对或者字典，且必须为16字节的数据类型（支持 UUID、IPADDR、INT128、COMPLEX、POINT）。\n\n#### 详情\n\n返回值为 *X* 的高位8字节的数据，为 LONG 类型。\n\n#### 例子\n\n```\nx =ipaddr(\"192.168.1.13\")\nx1 = highLong(x)\nprint(x1)\n//output: 0\n```\n\n```\nx=1 2 3 4\ny=4 3 2 1\npoints = point(x, y)\nx1 = highLong(points)\n//output:[4616189618054758400,4613937818241073152,4611686018427387904,4607182418800017408]\n```\n\n**Related information**\n\n[lowLong](https://docs.dolphindb.cn/zh/funcs/l/lowlong.html)\n"
    },
    "histogram2d": {
        "url": "https://docs.dolphindb.cn/zh/funcs/h/histogram2d.html",
        "signatures": [
            {
                "full": "histogram2d(x, y, [bins=10], [range=None], [density], [weights])",
                "name": "histogram2d",
                "parameters": [
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "y",
                        "name": "y"
                    },
                    {
                        "full": "[bins=10]",
                        "name": "bins",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[range=None]",
                        "name": "range",
                        "optional": true,
                        "default": "None"
                    },
                    {
                        "full": "[density]",
                        "name": "density",
                        "optional": true
                    },
                    {
                        "full": "[weights]",
                        "name": "weights",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [histogram2d](https://docs.dolphindb.cn/zh/funcs/h/histogram2d.html)\n\n\n\n#### 语法\n\nhistogram2d(x, y, \\[bins=10], \\[range=None], \\[density], \\[weights])\n\n#### 详情\n\n计算两组数据样本的二维直方图。\n\n#### 参数\n\n**X**, **Y** 两个等长的数值向量，分别作为构造二维直方图的 x 和 y 坐标值。注意：不可包含空值。\n\n**bins** 可选参数，数值标量，严格递增的、长度至少为 2 的数值向量，或者由前两者组成的元组（第一个元素表示 x 维度上的特性，第二个元素表示 y 维度的特性）。默认值为 10。注意：不能包含空值。以下为传入不同形式数据的含义说明：\n\n* 标量：x 和 y 两个维度箱的数目。\n\n* 向量：x 和 y 两个维度分箱的边界。\n\n* 标量组成的二维元组：x 和 y 两个维度分别分箱的数目。\n\n* 向量组成的二维元组：x 和 y 两个维度分别分箱的边界。\n\n* 标量和向量组成的二维元组：标量代表在对应维度上按照均等分箱时箱的数目；向量表示在对应维度上按给定的边界值分箱。\n\n**range** 可选参数，二维向量，形状须为(2, 2)，用来指定每个维度上统计图的最左边界和最右边界（如果 *bins* 参数未显式给出边界值时）。所有超出 *range* 的点将被视为异常点，不会被二维直方图统计。默认为空。\n\n**density** 可选参数，布尔标量。以下为说明：\n\n* 如果为 false（默认值），则表示直方图统计每个二维箱子的样本点个数。\n\n* 如果为 true，则会返回每个箱子的概率密度函数。bin\\_count（当前箱子内的点个数）/sample\\_count（总样本点数）/ bin\\_area（每个箱子的面积）。\n\n**weights** 可选参数，数值向量，长度须与 *X*/*Y* 相同，表示对应样本点（x\\_i, y\\_i）的权重。默认为空。注意：传入向量时不可包含空数据。其中，\n\n* 如果 *density* 为 true，则 weights 会被正则化到 1。\n\n* 如果 *density* 为 false，则每个箱子在二维直方图中的值就是落入这些该箱子的所有点的权重值之和。\n\n#### 返回值\n\n* H：二维直方图的统计结果，形状为（nx, ny）。其中，每一个值代表落入该箱子的样本点的统计值，nx 和 ny 分别为 x 轴和 y 轴的分箱个数。\n\n* xedges：沿着 x 轴分箱时箱子的 x 轴边界，形状为（nx + 1, ）。其中，nx 为 x 轴的分箱个数。\n\n* yedges：沿着 y 轴分箱时箱子的 y 轴边界，形状为（ny + 1, ）。其中，ny 为 y 轴的分箱个数。\n\n#### 例子\n\n例 1：传入两组数据样本，设置 x 和 y 两个维度分别分箱的边界、 *density* 为 false，计算其二维直方图的统计结果。\n\n```\nx = [0.1, 0.2, 0.5, 0.7, 0.9]\ny = [0.2, 0.4, 0.6, 0.8, 1.0]\nbins = [[0, 0.3, 0.6, 1.0], [0, 0.5, 1.0]]\ndensity = false\nresult = histogram2d(x, y, bins, ,density)\n\n/* Output:\nH->#0 #1\n-- --\n2  0 \n0  1 \n0  2 \nxedges->[0,0.3,0.6,1]\nyedges->[0,0.5,1]\n*/\n```\n\n例 2：传入两组数据样本，设置 x 均等分箱时箱的数目、y 分箱的边界、权重、*density* 为 true，计算其二维直方图的统计结果。\n\n```\nx = [0.2, 0.4, 0.6, 0.8, 1.0]\ny = [0.3, 0.5, 0.7, 0.9, 1.1]\nbins = [2, [0.3, 0.5, 1.1]]\nweights = [1, 2, 3, 4, 5]\ndensity = true\nresult = histogram2d(x, y, bins, ,density, weights)\n\n/* Output:\nH->#0 #1\n-- --\n1  5 \n0  9 \nxedges->[0.2,0.6,1]\nyedges->[0.3,0.5,1.1]\n*/\n```\n"
    },
    "hmac": {
        "url": "https://docs.dolphindb.cn/zh/funcs/h/hmac.html",
        "signatures": [
            {
                "full": "hmac(key, message, [digest='sha256'])",
                "name": "hmac",
                "parameters": [
                    {
                        "full": "key",
                        "name": "key"
                    },
                    {
                        "full": "message",
                        "name": "message"
                    },
                    {
                        "full": "[digest='sha256']",
                        "name": "digest",
                        "optional": true,
                        "default": "'sha256'"
                    }
                ]
            }
        ],
        "markdown": "### [hmac](https://docs.dolphindb.cn/zh/funcs/h/hmac.html)\n\n\n\n#### 语法\n\nhmac(key, message, \\[digest='sha256'])\n\n#### 参数\n\n**key** LITERAL 类型标量，表示密钥。\n\n**message** LITERAL 类型标量，表示需要加密的信息。\n\n**digest** 可选参数，STRING 类型标量，表示加密使用的哈希算法。默认值为 sha256。可选值为 sha1, sha224, sha256, sha 384, sha512, md5。\n\n#### 详情\n\n采用 HMAC（Hash-based Message Authentication Code，基于哈希的消息认证码）机制，根据给定的密钥和加密信息，通过指定的加密算法生成并返回一个 STRING 类型的哈希值。\n\n#### 例子\n\n```\nhmac(key=\"myKey\", message=\"myMessage\", digest=\"sha256\")\n// output:'71e5f5ca5f64550ee4524909f7cead7b81d8674a657383aec1b003a8a3f05b04'\n\nhmac(key=\"myKey\", message=\"myMessage\", digest=\"sha1\")\n// output:'5033197fa89dedf5088eed6100dfa5a0f67ef1ce'\n\nhmac(key=\"myKey2\", message=\"myMessage\", digest=\"sha256\")\n// output:'40e2a700754cec30ace1e82abfe7fd233f8f6c299050cc21b0e0a4ea42428126'\n```\n"
    },
    "hour": {
        "url": "https://docs.dolphindb.cn/zh/funcs/h/hour.html",
        "signatures": [
            {
                "full": "hour(X)",
                "name": "hour",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [hour](https://docs.dolphindb.cn/zh/funcs/h/hour.html)\n\n\n\n#### 语法\n\nhour(X)\n\n#### 详情\n\n返回对应的小时数。结果的数据类型是 INTEGER。\n\n#### 参数\n\n**X** 是一个时间标量/向量。\n\n#### 例子\n\n```\nhour(2012.12.03 01:22:01);\n```\n\n返回：1\n\n**Related information**\n\n[date](https://docs.dolphindb.cn/zh/funcs/d/date.html)\n\n[second](https://docs.dolphindb.cn/zh/funcs/s/second.html)\n\n[minute](https://docs.dolphindb.cn/zh/funcs/m/minute.html)\n\n[month](https://docs.dolphindb.cn/zh/funcs/m/month.html)\n\n[year](https://docs.dolphindb.cn/zh/funcs/y/year.html)\n"
    },
    "hourOfDay": {
        "url": "https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html",
        "signatures": [
            {
                "full": "hourOfDay(X)",
                "name": "hourOfDay",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [hourOfDay](https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html)\n\n\n\n#### 语法\n\nhourOfDay(X)\n\n#### 参数\n\n**X** 可以是 TIME, MINUTE, SECOND, DATETIME, TIMESTAMP, NANOTIME, NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n返回 *X* 中的小时。\n\n#### 例子\n\n```\nhourOfDay(00:46:12);\n// output\n0\n\nhourOfDay([2012.06.12T12:30:00,2012.10.28T17:35:00,2013.01.06T02:36:47,2013.04.06T08:02:14]);\n// output\n[12,17,2,8]\n```\n\n相关函数：[dayOfYear](https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html), [minuteOfHour](https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.cn/zh/funcs/m/millisecond.html), [microsecond](https://docs.dolphindb.cn/zh/funcs/m/microsecond.html), [nanosecond](https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html)\n"
    },
    "garch": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/garch.html",
        "signatures": [
            {
                "full": "garch(ds, endogColName, order, [maxIter=50])",
                "name": "garch",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "endogColName",
                        "name": "endogColName"
                    },
                    {
                        "full": "order",
                        "name": "order"
                    },
                    {
                        "full": "[maxIter=50]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "50"
                    }
                ]
            }
        ],
        "markdown": "### [garch](https://docs.dolphindb.cn/zh/funcs/g/garch.html)\n\n\n\n#### 语法\n\ngarch(ds, endogColName, order, \\[maxIter=50])\n\n#### 详情\n\n使用广义自回归条件异方差模型（Generalized Autoregressive Conditional Heteroskedasticity，简称 GARCH 模型）来分析单变量时间序列。返回一个字典，表示 GARCH 模型的分析结果，详细说明请参见“返回值”小节。\n\n#### 参数\n\n**ds** 一张内存表或者一个 DataSource 类型构成的向量，包含需要分析的单变量时间序列。注意：不可为空。\n\n**endogColName** 字符串标量，表示 *ds* 中需要分析的时间序列所对应的列名。\n\n**order** 长度为 2 的正整数向量，表示 GARCH 模型的阶数。比如 `order=[1,2]` 表示 GARCH 模型的 p=1，q=2，其中 p 为 GARCH 项个数，q 为 ARCH 项阶数。\n\n**maxIter** 可选参数，正整数标量，表示优化时的最大迭代次数，默认值为 50。\n\n#### 返回值\n\n返回一个字典，表示 GARCH 模型的分析结果，字典有以下成员：\n\n* volConstant：浮点数标量，表示优化得到的 Vol Constant。\n\n* returnsConstant：浮点数标量，表示优化得到的 Returns Constant。\n\n* archTerm：浮点数向量，表示优化得到的 ARCH Term。\n\n* garchTerm：浮点数向量，表示优化得到的 GARCH Term。\n\n* iterations：整数标量，表示优化迭代次数。\n\n* aic：浮点数标量，表示 aic 准则的值。\n\n* bic：浮点数标量，表示 bic 准则的值。\n\n* nobs：整数标量，表示时间序列的观测数量，即拟合使用的数据量。\n\n* model：字典类型，包含拟合后模型的基本信息，有以下成员：\n\n  * order：长度为 2 的正整数向量，表示模型的阶数。\n\n  * endog：浮点数矩阵类型，表示从 *ds* 中转换而来的观测数据。\n\n  * start：浮点数向量类型，表示经过拟合后的外生变量的值。\n\n* predict：函数指针， 指向预测函数，使用方法为 `model.predict(x)`。其中，*model* 表示 garch 函数的输出结果，*x* 为一个正整数，表示预测的步长。预测函数返回一个数组，数组中每个元素分别表示每一步的预测值。\n\n#### 例子\n\n传入 [macrodata.csv](https://docs.dolphindb.cn/zh/funcs/data/macrodata.csv) 文件，自定义相关参数，计算其使用 GARCH 模型进行分析的结果。\n\n```\ndata = loadText(\"macrodata.csv\");\nmodel = garch(data, \"realgdp\", [1,1]);\nprint(model)\n\n// out:\n\nvolConstant->0.000005999433551\nreturnsConstant->0.008474617943101\narchTerm->[0.70725452294378]\ngarchTerm->[0.248859733003604]\naic->-1353.789403416915774\nbic->-1340.576183784679415\nnobs->201\niterations->38\npredict->garchPredict\nmodel->order->[1,1]\nendog->#0                \n------------------\n0.024942130816387 \n-0.001192952110668\n0.003494532654372 \n...\n\ncoefficients->[-12.023845501294935,-1.104702991485461,0.882087052766567,0.008474617943101]\n\n```\n"
    },
    "gaussianKde": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gaussiankde.html",
        "signatures": [
            {
                "full": "gaussianKde(X,[weights],[bwMethod=\"scott\"])",
                "name": "gaussianKde",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weights]",
                        "name": "weights",
                        "optional": true
                    },
                    {
                        "full": "[bwMethod=\"scott\"]",
                        "name": "bwMethod",
                        "optional": true,
                        "default": "\"scott\""
                    }
                ]
            }
        ],
        "markdown": "### [gaussianKde](https://docs.dolphindb.cn/zh/funcs/g/gaussiankde.html)\n\n\n\n#### 语法\n\ngaussianKde(X,\\[weights],\\[bwMethod=\"scott\"])\n\n#### 详情\n\n使用核密度估计方法中的高斯核来估计随机变量的概率密度。\n\n生成的模型可以作为 `gaussianKdePredict` 函数的输入。\n\n#### 参数\n\n**X** 数值向量、矩阵、元组或表类型，表示给定的数据集合。*X* 的每一行表示一个数据点，元素数量至少为 2（即数据点的维度至少为 2），各数据点的维度保持一致，且 *X* 的行数须大于列数。暂时不支持分布式表。\n\n**weights** 数值向量类型，可选参数，表示每一个数据点的权重，默认每个数据点的权重相同。向量中数值必须非负且不全为0；且向量大小须和 *X* 的行数相同。\n\n**bwMethod**数值标量，字符串标量或函数名类型，可选参数，表示带宽的生成方式。默认值为”scott”。\n\n* 若传入数值标量，则表示带宽的大小。\n\n* 若传入字符串标量类型，可选值为”scott”和”silverman”。\n\n* 若传入函数，表示用于计算带宽的函数，其输入值为已传入的参数*X*，执行后得到带宽的值。注意：返回值须为数值标量。\n\n#### 返回值\n\n返回一个字典，字典的内容有：\n\n* X：浮点型向量或矩阵，表示输入的数据集合 *X*。\n\n* cov：浮点型矩阵，表示的是通过 *weights*、*X* 和带宽生成的协方差矩阵的 cholesky 分解矩阵。\n\n* weights：浮点型向量，表示对应的权重。\n\n* predict：函数指针，表示对应的预测函数。其使用方法为 `model.gaussianKdePredict(model,X)`，详情见 gaussianKdePredict。\n\n* bandwidth：浮点型标量，表示的生成的带宽。\n\n#### 例子\n\n下例传入指定的 [*trainset.txt*](https://docs.dolphindb.cn/zh/funcs/data/trainset.txt)，使用高斯核估计来预测数据的概率密度。\n\n```\ntrainData = loadText(\"trainset.txt\",\" \");\nmodel = gaussianKde(trainData)\nmodel\n/* Output\nX->\n#0      #1     \n0.1460  -0.1659\n-1.3717 -1.6650\n-1.6957 -1.1680\n-0.7976 0.6081 \n0.1088  2.5113 \n-0.0724 -0.8210\n-1.7548 -0.3485\n1.1202  0.9004 \n1.0234  0.7907 \n-0.4256 0.7169 \n\npredict->gaussianKdePredict\ncov->\n#0     #1    \n0.7040 0.0   \n0.4921 0.6700\n\nweights->[0.1000,0.1000,0.1000,0.1000,0.1000,0.1000,0.1000,0.1000,0.1000,0.1000]\nbandwidth->0.6812\n*/\n```\n\n承接上例，传入 [*testset.txt*](https://docs.dolphindb.cn/zh/funcs/data/testset.txt) 文件，`gaussianKde` 可与 `gaussianKdePredict` 函数结合使用，生成其对应的预测结果。\n\n```\ntestData = loadText(\"testset.txt\",\" \");\nmodel.predict(testData)\n/* Output\n->[0.0623,0.0730,0.0336,0.0030,0.0001,0.0552....]\n*/\n```\n\n相关函数：[gaussianKdePredict](https://docs.dolphindb.cn/zh/funcs/g/gaussiankdepredict.html)\n"
    },
    "gaussianKdePredict": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gaussiankdepredict.html",
        "signatures": [
            {
                "full": "gaussianKdePredict(model,X)",
                "name": "gaussianKdePredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [gaussianKdePredict](https://docs.dolphindb.cn/zh/funcs/g/gaussiankdepredict.html)\n\n\n\n#### 语法\n\ngaussianKdePredict(model,X)\n\n#### 详情\n\n[gaussianKde](https://docs.dolphindb.cn/zh/funcs/g/gaussiankde.html) 对应的预测函数。使用其生成的模型对数据进行预测。\n\n#### 参数\n\n**model** 字典类型，表示 `gaussianKde` 生成的字典。\n\n**X** 数值向量、矩阵、元组或表类型，表示需要预测的数据。其维度必须和 `gaussianKde` 的数据集合的维度相同。\n\n#### 返回值\n\n函数返回一个浮点型向量，大小和 *X* 的行数相同，表示 *X* 中每个数据点的预测结果。\n\n#### 例子\n\n下例中先使用 `gaussianKde` 生成模型。传入指定的 [*trainset.txt*](https://docs.dolphindb.cn/zh/funcs/data/trainset.txt)，使用高斯核估计来预测数据的概率密度。然后调用 `predict` 函数，通过模型和传入的 [*testset.txt*](https://docs.dolphindb.cn/zh/funcs/data/testset.txt) 文件生成对应的预测结果。\n\n```\ntrainData = loadText(\"trainset.txt\",\" \");\ntestData = loadText(\"testset.txt\",\" \");\nmodel = gaussianKde(trainData)\ngaussianKdePredict(model, testData)\n/*\n->[0.0623,0.0730,0.0336,0.0030,0.0001,0.0552....]\n*/\n```\n\n相关函数：[gaussianKde](https://docs.dolphindb.cn/zh/funcs/g/gaussiankde.html)\n"
    },
    "gaussianNB": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gaussianNB.html",
        "signatures": [
            {
                "full": "gaussianNB(Y, X, [varSmoothing=1e-9])",
                "name": "gaussianNB",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[varSmoothing=1e-9]",
                        "name": "varSmoothing",
                        "optional": true,
                        "default": "1e-9"
                    }
                ]
            }
        ],
        "markdown": "### [gaussianNB](https://docs.dolphindb.cn/zh/funcs/g/gaussianNB.html)\n\n\n\n#### 语法\n\ngaussianNB(Y, X, \\[varSmoothing=1e-9])\n\n#### 参数\n\n**Y** 是一个长度与 *X* 的行数相等的向量，表示 *X* 中每个样本对应的标签。\n\n**X** 是一个表，表示训练集。表中的每一行表示一个样本，每一列表示一个特征。\n\n**varSmoothing** 是一个浮点类型的正数，表示平滑系数。默认值是 1e-9。\n\n#### 详情\n\n使用高斯朴素贝叶斯（Gaussian Naive Bayes）算法对数据进行分类训练。返回的结果是一个字典，包含以下 key：\n\n* modelName：模型名称，为字符串 \"GaussianNB\"\n\n* model：gaussianNB 的内部模型\n\n* varSmoothing：训练时的平滑系数\n\n#### 例子\n\n本例所用数据集 iris.data 可从 <https://archive.ics.uci.edu/ml/datasets/iris> 下载。\n\n```\nDATA_DIR = \"C:/DolphinDB/Data\"\nt = loadText(DATA_DIR+\"/iris.data\")\nt.rename!(`col0`col1`col2`col3`col4, `sepalLength`sepalWidth`petalLength`petalWidth`class)\nt[`classType] = take(0, t.size())\nupdate t set classType = 1 where class = \"Iris-versicolor\"\nupdate t set classType = 2 where class = \"Iris-virginica\"\n\ntraining = select sepalLength, sepalWidth, petalLength, petalWidth from t\nlabels = t.classType\n\nmodel = gaussianNB(labels, training);\n\npredict(model, training);\n```\n"
    },
    "ge": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/ge.html",
        "signatures": [
            {
                "full": "ge(X, Y)",
                "name": "ge",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ge](https://docs.dolphindb.cn/zh/funcs/g/ge.html)\n\n\n\n#### 语法\n\nge(X, Y) 或 X>=Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量、矩阵或集合。如果 *X* 或 *Y* 的其中一个是数据对、向量或矩阵，另一个必须是标量，或具有相同长度或维度的数据对、向量或矩阵。\n\n#### 详情\n\n如果 *X* 和 *Y* 都不是集合，返回逐个元素比较 *X*>=*Y* 的结果。\n\n如果 *X* 和 *Y* 都是集合，则检查 *Y* 是否为 *X* 的子集。\n\n#### 例子\n\n*X* 是向量：\n\n```\n1 2 3 >= 2;\n// output\n[0,1,1]\n\n1 2 3 >= 0 2 4;\n// output\n[1,1,0]\n\n2:3>=1:6;\n// output\n1 : 0\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 ge 4;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 0  | 1  |\n| 0  | 1  | 1  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1>=m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 0  | 1  |\n| 0  | 1  | 1  |\n\n集合操作：如果 *X*>=*Y*，则 *Y* 是 *X* 的子集。\n\n```\nx=set(4 6);\nx;\n// output\nset(6,4)\ny=set(8 9 4 6);\ny;\n// output\nset(6,4,9,8)\n\ny>=x;\n// output\n1\n\nx>=y;\n// output\n0\n\nx>=x;\n// output\n1\n// x 是 x 的子集\n```\n"
    },
    "gema": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gema.html",
        "signatures": [
            {
                "full": "gema(X, window, alpha)",
                "name": "gema",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "alpha",
                        "name": "alpha"
                    }
                ]
            }
        ],
        "markdown": "### [gema](https://docs.dolphindb.cn/zh/funcs/g/gema.html)\n\n\n\n#### 语法\n\ngema(X, window, alpha)\n\nTA-lib 系列函数参数说明和窗口计算规则请参考: [TA-lib 系列](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 参数\n\n**alpha** 是一个0-1之间的浮点数（不包含0, 1），表示计算系数。\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的指数移动平均（Exponential Moving Average），该函数是 [ema](https://docs.dolphindb.cn/zh/funcs/e/ema.html) 的扩展。\n\n与 [ema](https://docs.dolphindb.cn/zh/funcs/e/ema.html) 相比，该函数引入了计算系数 *alpha*，其计算公式为：\n\n![gema](https://docs.dolphindb.cn/zh/images/gema.png)\n\n其中：![gemak](https://docs.dolphindb.cn/zh/images/gema_k.png)为第 k 个指数移动平均值，alpha 为计算系数，![xk](https://docs.dolphindb.cn/zh/images/xk.png)为向量![x](https://docs.dolphindb.cn/zh/images/x.png)中第 k 个元素。\n\n#### 例子\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\ngema(x,3,0.5);\n// output\n[,,12.299999999999998,12.55,12.225000000000001,11.912500000000001,11.55625]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\ngema(x,3,0.1);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n| 12.3    | 15.6667 |\n| 12.35   | 16      |\n| 12.305  | 16.5    |\n| 12.2345 | 16.05   |\n| 12.131  | 15.445  |\n\n相关函数：[ema](https://docs.dolphindb.cn/zh/funcs/e/ema.html), [wilder](https://docs.dolphindb.cn/zh/funcs/w/wilder.html), [tema](https://docs.dolphindb.cn/zh/funcs/t/tema.html)\n"
    },
    "genericStateIterate": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/genericStateIterate.html",
        "signatures": [
            {
                "full": "genericStateIterate(X, initial, window, func)",
                "name": "genericStateIterate",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "initial",
                        "name": "initial"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    }
                ]
            }
        ],
        "markdown": "### [genericStateIterate](https://docs.dolphindb.cn/zh/funcs/g/genericStateIterate.html)\n\n\n\n#### 语法\n\ngenericStateIterate(X, initial, window, func)\n\n#### 参数\n\n**X** 表中的字段或对表字段其应用向量函数的计算结果。通过元组方式传入多个列字段。传入 \\[] 表示不指定该参数。\n\n**initial** 表中的字段或对表字段应用向量函数的计算结果。其作用是对输出表的第1\\~*window* 个计算结果进行填充。\n\n**window**非负整数，表示窗口的长度（以元素个数衡量）。\n\n**func** 用户自定义的无状态函数，其返回值必须是标量，以部分应用的方式接收参数。当 *window* > 0 时，其第一个参数为当前记录向前取 *window* 个计算结果组成的向量；当 *window* = 0 时，其第一个参数为当前记录向前取1个计算结果。其后参数依次为 *X* 指定的列。\n\n#### 详情\n\n基于以元素个数衡量的窗口进行迭代计算。\n\n假设 *X* 指定为 \\[X1, X2, ..., Xn]，该函数计算结果对应输出表中的列为 factor，初始化字段为 initial，*window* 为 w，迭代函数为 func。\n\n对于输入的第 k 条记录（k = 1, 2 …），其计算逻辑为：\n\n* 当 w = 0 时：\n\n  * k = 1 时：factor\\[0] = func(initial\\[0]，, X1\\[0], X2\\[0], … , Xn\\[0])\n\n  * k > 1 时：factor\\[k-1] = func(factor\\[(k-2)], X1\\[k-1], X2\\[k-1], … , Xn\\[k-1])\n\n* 当 w >0 时：\n\n  * k <= w 时：factor\\[k-1] = initial\\[k-1]\n  * k > w 时：factor\\[k-1] = func(factor\\[(k-1-w):k-1], X1\\[k-1], X2\\[k-1], … , Xn\\[k-1])\n\n注意：数据对用于索引时，不包含右边界的值，即 (k-1-w):k-1 的范围是 \\[k-1-w, k-1)。\n\n#### 例子\n\n```\n// define a function\ndef myfunc(x, w){ \nre = sum(x*w)\nreturn re\n}\n\ndateTime = 2021.09.09T09:30:00.000 2021.09.09T09:31:00.000 2021.09.09T09:32:00.000 2021.09.09T09:33:00.000 2021.09.09T09:34:00.000\nsecurityID = `600021`600021`600021`600021`600021\nvolume = 310 280 300 290 240\nprice = 1.5 1.6 1.7 1.6 1.5\nt = table(1:0, `dateTime`securityID`volume`price, [TIMESTAMP, SYMBOL, INT, DOUBLE])\ntableInsert(t, dateTime, securityID, volume, price)\noutput = table(100:0, `securityID`dateTime`factor1, [SYMBOL, TIMESTAMP, DOUBLE])\n\nengine = createReactiveStateEngine(name=\"test\", metrics=[<dateTime>, <genericStateIterate(volume,price,3,myfunc{,})>], dummyTable=t, outputTable=output, keyColumn=`SecurityID, keepOrder=true)\nengine.append!(t)\ndropAggregator(`test)\n```\n\n| securityID | dateTime                | factor1 |\n| ---------- | ----------------------- | ------- |\n| 600021     | 2021.09.09T09:30:00.000 | 1.5     |\n| 600021     | 2021.09.09T09:31:00.000 | 1.6     |\n| 600021     | 2021.09.09T09:32:00.000 | 1.7     |\n| 600021     | 2021.09.09T09:33:00.000 | 1,392   |\n| 600021     | 2021.09.09T09:34:00.000 | 334,872 |\n\n上例计算过程如下：\n\n* 由于窗口为 3，因此对于前 3 条数据，以 price 的值作为 factor1 的输出；\n\n* 第 4 条数据到来时，历史窗口的数据为 \\[1.5, 1.6, 1.7]，当前 volume 的值为 290，因此调用自定义函数 myfunc(\\[1.5, 1.6, 1.7], 290) = 1392；\n\n* 第 5 条数据到来时，历史窗口的数据为 \\[1.6, 1.7, 1392]，当前 volume 的值为 240，因此调用自定义函数 myfunc(\\[1.6, 1.7, 1392], 240) = 334872；\n\n* 若之后继续有数据注入，其计算过程以此类推。\n\n相关函数：[genericTStateIterate](https://docs.dolphindb.cn/zh/funcs/g/genericTStateIterate.html)\n"
    },
    "genericTStateIterate": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/genericTStateIterate.html",
        "signatures": [
            {
                "full": "genericTStateIterate(T, X, initial, window, func, [leftClosed = false])",
                "name": "genericTStateIterate",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "initial",
                        "name": "initial"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "[leftClosed = false]",
                        "name": "[leftClosed = false]"
                    }
                ]
            }
        ],
        "markdown": "### [genericTStateIterate](https://docs.dolphindb.cn/zh/funcs/g/genericTStateIterate.html)\n\n\n\n#### 语法\n\ngenericTStateIterate(T, X, initial, window, func, \\[leftClosed = false])\n\n#### 参数\n\n**T** 非严格递增的时间类型或整型的向量，且不能包含 NULL 值。注意，时间乱序的数据在计算中会被直接丢弃。\n\n**X** 表中的字段或对其应用向量函数的计算结果。若不指定，需要置为\\[]；若需要输入多个列变量，需要用元组表示。\n\n**initial** 用于初始化的列字段，作为初始化窗口内元素的输出，初始化窗口为 \\[t0, t0 + *window*)（t0 为第一条数据的时间戳，以时间衡量窗口）。*initial* 可以是输入表中的字段或对其应用向量函数的计算结果。\n\n**window** 正整型或 DURATION 标量，表示初始化窗口和历史窗口的长度。当 *window* 为整数时，其单位与 T 一致。\n\n**func** 无状态函数，为用户自定义函数，其返回值必须是标量。以部分应用的形式传入。*func* 参数个数为 1（历史窗口内的数据）+ *X* 指定的列数，第一个参数对应历史窗口的元素值，之后的参数依次对应 X *指定列的元素值*。除前述参数外，若 *func* 包含其他固定的常量参数，则需以部分应用的形式指定。\n\n**leftClosed** 布尔值，表示历史窗口是否包含左边界的数据，默认为 false。\n\n#### 详情\n\n基于以时间衡量的窗口进行迭代计算。\n\n假设时间列为 *T*，*X* 指定为 \\[X1, X2, ..., Xn]，该函数计算结果对应输出表中的列为 factor，初始化字段为 *initial*，*window* 为 w，迭代函数为 func。\n\n以 Tk 表示第 k 条数据的时间戳，对于第 k 条记录(k = 1, 2 ...)，其计算逻辑为：\n\n* Tk ∈ \\[T1, T1+w)：factor\\[k] = initial\\[k]\n\n* 其他情况下，第 k+1 条记录对应的窗口为 (Tk-w, Tk] (leftClosed=false) / \\[Tk-w, Tk] (leftClosed=true)：factor\\[k] = func(subFactor, X1\\[k], X2\\[k], ... , Xn\\[k])，其中 subFactor 为当前窗口范围内 factor 的值。\n\n**Note:**\n\n数据对用于索引时，不包含右边界的值，即 (k-w):k 的范围是 \\[k-w, k)。\n\n#### 例子\n\n指定 *leftClosed*=false：\n\n```\n// define a function\ndef myfunc(x, w){ \n     re = sum(x*w)\n     return re\n    }\n\ndateTime = 2021.09.09T09:28:00.000 2021.09.09T09:28:30.000 2021.09.09T09:30:00.000 2021.09.09T09:31:00.000 2021.09.09T09:32:00.000\nsecurityID = `600021`600021`600021`600021`600021\nvolume = 310 280 300 290 240\nprice = 1.5 1.6 1.7 1.6 1.5\nt = table(1:0, `dateTime`securityID`volume`price, [TIMESTAMP, SYMBOL, INT, DOUBLE])\ntableInsert(t, dateTime, securityID, volume, price)\noutput = table(100:0, `securityID`dateTime`factor1, [SYMBOL, TIMESTAMP, DOUBLE])\n\nengine = createReactiveStateEngine(name=\"test\", metrics=[<dateTime>, <genericTStateIterate(dateTime,volume,price,2m,myfunc{,})>], dummyTable=t, outputTable=output, keyColumn=`SecurityID, keepOrder=true)\nengine.append!(t)\ndropAggregator(`test)\n```\n\n| securityID | dateTime                | factor1    |\n| ---------- | ----------------------- | ---------- |\n| 600021     | 2021.09.09T09:28:00.000 | 1.5        |\n| 600021     | 2021.09.09T09:28:30.000 | 1.6        |\n| 600021     | 2021.09.09T09:30:00.000 | 930        |\n| 600021     | 2021.09.09T09:31:00.000 | 270,164    |\n| 600021     | 2021.09.09T09:32:00.000 | 65,062,560 |\n\n上例计算过程如下：\n\n* 由于第 1 条数据的时间戳为 09:28:00.000 窗口为 2 min，因此初始化窗口为 \\[2021.09.09T09:28:00.000, 2021.09.09T09:30:00.000)，前 2 条数据均属于该窗口，因此直接输出 price 的值。\n\n* 第 3 条记录对应的窗口为 (2021.09.09T09:26:30.000, 2021.09.09T09:28:30.000]，该历史窗口内的元素为 \\[1.5, 1.6]，当前 volume 的值为 300，因此调用自定义函数 myfunc(\\[1.5, 1.6], 300) = 930；\n\n* 同理第 4 条记录对应的窗口为 (2021.09.09T09:28:00.000, 2021.09.09T09:30:00.000]，该历史窗口内的元素为 \\[1.6, 930]，当前 volume 的值为 290，因此调用自定义函数 myfunc(\\[1.6, 930], 290) = 270164；\n\n* 以此类推。\n\n指定 *leftClosed*=true:\n\n```\nengine = createReactiveStateEngine(name=\"test\", metrics=[<dateTime>, <genericTStateIterate(dateTime,volume,price,2m,myfunc{,},true)>], dummyTable=t, outputTable=output, keyColumn=`SecurityID, keepOrder=true)\n```\n\n| securityID | dateTime                | factor1    |\n| ---------- | ----------------------- | ---------- |\n| 600021     | 2021.09.09T09:28:00.000 | 1.5        |\n| 600021     | 2021.09.09T09:28:30.000 | 1.6        |\n| 600021     | 2021.09.09T09:30:00.000 | 930        |\n| 600021     | 2021.09.09T09:31:00.000 | 270,599    |\n| 600021     | 2021.09.09T09:32:00.000 | 65,166,960 |\n\n上例计算过程如下：\n\n* 由于第 1 条数据的时间戳为 09:28:00.000 窗口为 2 min，因此初始化窗口为 \\[2021.09.09T09:28:00.000, 2021.09.09T09:30:00.000)，前 2 条数据均属于该窗口，因此直接以 price 的值作为 factor1 的输出。\n\n* 第 3 条记录对应的窗口为 \\[2021.09.09T09:26:30.000, 2021.09.09T09:28:30.000]，该历史窗口内的元素为 \\[1.5, 1.6]，当前 volume 的值为 300，因此调用自定义函数 myfunc(\\[1.5, 1.6], 300) = 930；\n\n* 同理第 4 条记录对应的窗口为 \\[2021.09.09T09:28:00.000, 2021.09.09T09:30:00.000]，该历史窗口内的元素为 \\[1.5, 1.6, 930]，当前 volume 的值为 290，因此调用自定义函数 myfunc(\\[1.5, 1.6, 930], 290) = 270599；\n\n* 以此类推。\n\n相关函数：[genericStateIterate](https://docs.dolphindb.cn/zh/funcs/g/genericStateIterate.html)\n"
    },
    "genOutputColumnsForOBSnapshotEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/genoutputcolumnsforobsnapshotengine.html",
        "signatures": [
            {
                "full": "genOutputColumnsForOBSnapshotEngine([basic=true], [time=true], [depth], [tradeDetail=true], [orderDetail=true], [withdrawDetail=true], [orderBookDetailDepth=0], [prevDetail=true], [seqDetail=false], [residualDetail=false])",
                "name": "genOutputColumnsForOBSnapshotEngine",
                "parameters": [
                    {
                        "full": "[basic=true]",
                        "name": "basic",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[time=true]",
                        "name": "time",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[depth]",
                        "name": "depth",
                        "optional": true
                    },
                    {
                        "full": "[tradeDetail=true]",
                        "name": "tradeDetail",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[orderDetail=true]",
                        "name": "orderDetail",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[withdrawDetail=true]",
                        "name": "withdrawDetail",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[orderBookDetailDepth=0]",
                        "name": "orderBookDetailDepth",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[prevDetail=true]",
                        "name": "prevDetail",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[seqDetail=false]",
                        "name": "seqDetail",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[residualDetail=false]",
                        "name": "residualDetail",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [genOutputColumnsForOBSnapshotEngine](https://docs.dolphindb.cn/zh/funcs/g/genoutputcolumnsforobsnapshotengine.html)\n\n#### 语法\n\ngenOutputColumnsForOBSnapshotEngine(\\[basic=true], \\[time=true], \\[depth], \\[tradeDetail=true], \\[orderDetail=true], \\[withdrawDetail=true], \\[orderBookDetailDepth=0], \\[prevDetail=true], \\[seqDetail=false], \\[residualDetail=false])\n\n#### 详情\n\n该函数用于配合订单簿引擎，简化订单簿引擎的创建过程。它返回一个元组，包含2个元素。\n\n* 第一个元素是字符串向量，表示订单簿需要包含的字段，可用于`createOrderBookSnapshotEngine` 的 *outputColMap* 参数。\n\n* 第二个元素是空的内存表，表示订单簿需要具备的表结构，可用于`createOrderBookSnapshotEngine` 的 *outputTable* 参数。\n\n#### 参数\n\n以下参数都用于指定订单簿需要包含的字段，每个参数名都表示一个字段类别，每个类别中包含多个字段。通过 `createOrderBookSnapshotEngine` 函数页的[附录](https://docs.dolphindb.cn/zh/funcs/c/createorderbooksnapshotengine.md#)，查看字段类别及其包含的字段。\n\n**basic** 布尔值。表示是否输出类别 basic 中的字段。默认为 true。\n\n**time** 布尔值。表示是否输出类别 time 中的字段。默认为 true。\n\n**depth** 元组。长度为 2，默认为 (10, true)。\n\n* 第一个元素为整型标量，范围是\\[0, 100]，表示报价/询价的价格和数量的档位。若为 0 则不输出 depth 中的字段；\n\n* 第二个元素为布尔值，决定多档报价/询价的价格和数量的输出形式。若为 false，表示以多列的形式输出；若为 true，以数组向量的形式输出。\n\n**tradeDetail** 布尔值，表示是否输出 tradeDetail 中的字段。默认为 true。\n\n**orderDetail** 布尔值，表示是否输出 orderDetail 中的字段。默认为 true。\n\n**withdrawDetail** 布尔值，表示是否输出 withdrawDetail 中的字段。默认为 true。\n\n**orderbookDetailDepth** 整型标量，用于指定输出订单簿明细的档位（orderbookDetail 类别） \\*。\\*默认值为0，表示不输出。该参数的值必须和 `createOrderBookSnapshotEngine` 的 *orderbookDetailDepth* 参数的值保持一致。\n\n**prevDetail** 布尔值，表示是否输出 prevDetail 中的字段。默认为 true。\n\n**seqDetail** 布尔值，表示是否输出 seqDetail 中的字段。默认为 false。\n\n**residualDetail** 布尔值，表示是否输出剩余委托明细（residualDetail）中的字段。默认为 false。\n\n#### 例子\n\n创建订单簿引擎时，需要通过 *outputColMap* 参数指定需要输出的字段；通过 *outputTable* 参数指定输出表。`genOutputColumnsForOBSnapshotEngine`可以简化这两个参数的定义流程。在创建订单簿引擎前，先进行如下操作：\n\n首先，通过 `genOutputColumnsForOBSnapshotEngine` 函数设置需要输出的字段；\n\n然后，指定 *outputColMap* 为 `genOutputColumnsForOBSnapshotEngine` 函数返回值的第一个元素；指定 *outputTable* 为返回值的第二个元素。\n\n运行代码前，先下载 [../data/orderbookDemoInput.zip](https://docs.dolphindb.cn/zh/funcs/data/orderbookDemoInput.zip) 文件。\n\n```\ntry { dropStreamEngine(\"demo\") } catch(ex) { print(ex) }\n\nfilePath = \"./orderbookDemoInput.csv\"\n\n// 创建引擎参数 dummyTable，即指定输入表的表结构\ncolNames = `SecurityID`Date`Time`SecurityIDSource`SecurityType`Index`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo\ncolTypes = [SYMBOL, DATE, TIME, SYMBOL, SYMBOL, LONG, INT, INT, LONG, LONG, INT, LONG, LONG, LONG, INT]\ndummyOrderStream = table(1:0, colNames, colTypes)\n\n// 创建引擎参数 inputColMap，即指定输入表各字段的含义\ninputColMap = dict(`codeColumn`timeColumn`typeColumn`priceColumn`qtyColumn`buyOrderColumn`sellOrderColumn`sideColumn`msgTypeColumn`seqColumn, `SecurityID`Time`Type`Price`Qty`BuyNo`SellNo`BSFlag`SourceType`ApplSeqNum)\n\n// 创建引擎参数 prevClose，即昨日收盘价，prevClose 不影响最终的输出结果中除昨日收盘价以外的其他字段\nprevClose = dict(`000587.SZ`002694.SZ`002822.SZ`000683.SZ`301063.SZ`300459.SZ`300057.SZ`300593.SZ`301035.SZ`300765.SZ, [1.66, 6.56, 6.10, 8.47, 38.10, 5.34, 9.14, 48.81, 60.04, 16.52])\n\n//创建使用 outputColMap 和 outputTableSch 接收 genOutputColumnsForOBSnapshotEngine 的返回值。它们分别用于确定 outputColMap 和 outputTable\noutputColMap, outputTableSch = genOutputColumnsForOBSnapshotEngine(basic=true, time=false, depth=(10, true), tradeDetail=true, orderDetail=false, withdrawDetail=false, orderBookDetailDepth=0, prevDetail=false)\n\nengine = createOrderBookSnapshotEngine(name=\"demo\", exchange=\"XSHE\", orderbookDepth=10, intervalInMilli = 1000, date=2022.01.10, startTime=09:15:00.000, prevClose=prevClose, dummyTable=dummyOrderStream, outputTable=outputTableSch, inputColMap=inputColMap, outputColMap=outputColMap, orderBookAsArray=true)\n\n// 10支股票的逐笔数据批量注入快照合成引擎\nengine.append!(select * from loadText(filePath) order by Time)\nselect top 10 * from outputTableSch where code=\"300593.SZ\", timestamp between 2022.01.10T13:15:01.000 and 2022.01.10T13:15:10.000\n```\n\n部分结果展示如下：\n\n![](https://docs.dolphindb.cn/zh/images/orderBook1.png)\n\n"
    },
    "genShortGenomeSeq": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/genShortGenomeSeq.html",
        "signatures": [
            {
                "full": "genShortGenomeSeq(X, window)",
                "name": "genShortGenomeSeq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [genShortGenomeSeq](https://docs.dolphindb.cn/zh/funcs/g/genShortGenomeSeq.html)\n\n\n\n#### 语法\n\ngenShortGenomeSeq(X, window)\n\n别名：genSGS\n\n#### 参数\n\n**X** STRING 类型标量或 CHAR 类型的向量。\n\n**window** 正整数，范围为\\[2,28]。\n\n#### 详情\n\n对给定长度（以字符个数衡量）的滑动窗口内的 DNA 序列进行编码，不忽略空值。返回一个整型向量，其长度与 *X* 包含的字符个数相同。\n\n**Note:**\n\n* 该函数使用向后的窗口，即从当前元素开始向后选取元素。\n\n* 若 *window* 大于 *X* 中所有字符的个数，则返回一个空的整型向量。\n\n返回值：\n\n| window 范围 | 返回值类型                     |\n| --------- | ------------------------- |\n| \\[2,4]    | 短整型向量（FAST SHORT VECTOR）  |\n| \\[5,12]   | 整型向量（FAST INT VECTOR）     |\n| \\[13,28]  | 返回长整型向量（FAST LONG VECTOR） |\n\n#### 例子\n\n```\ngenShortGenomeSeq(\"NNNNNNNNTCGGGGCAT\",3)\n// output\n[,,,,,,,,795,815,831,831,830,824,801,,]\n\ngenShortGenomeSeq(\"TCGGGGCATNGCCCG\",4)\n// output\n[1135,1215,1279,1278,1272,1249,,,,,1258,1195,,,]\n\ngenShortGenomeSeq(\"GCCCGATNNNNN\",6)\n// output\n[396972,395953,,,,,,,,,,]\ngenShortGenomeSeq(\"TCGATCGTCGATCGTCGATCGTCGATCGG\",5)\n// output\n[328113,328390,328475,327789,328118,328411,328556,328113,328390,328475,327789,328118,328411,328556,328113,328390,328475,327789,328118,328411,328556,328113,328390,328475,327791,,,,]\ngenShortGenomeSeq(\"ACTT\",8)\n// output\n[,,,]\n```\n\n相关函数：[encodeShortGenomeSeq](https://docs.dolphindb.cn/zh/funcs/e/encodeShortGenomeSeq.html), [decodeShortGenomeSeq](https://docs.dolphindb.cn/zh/funcs/d/decodeShortGenomeSeq.html)\n"
    },
    "geoWithin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/geowithin.html",
        "signatures": [
            {
                "full": "geoWithin(X, polygonVertices, [containBoundary=true])",
                "name": "geoWithin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "polygonVertices",
                        "name": "polygonVertices"
                    },
                    {
                        "full": "[containBoundary=true]",
                        "name": "containBoundary",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [geoWithin](https://docs.dolphindb.cn/zh/funcs/g/geowithin.html)\n\n\n\n#### 语法\n\ngeoWithin(X, polygonVertices, \\[containBoundary=true])\n\n#### 参数\n\n**X**是一个 POINT 类型的标量或向量，表示一个或多个点。\n\n**polygonVertices**是一个 POINT 类型向量，表示一个多边形。\n\n**containBoundary**是一个布尔标量，表示是否包含边界上的点，默认值是true。\n\n#### 详情\n\n判断点 *X* 是否在多边形 *polygonVertices*中。\n\n#### 例子\n\n```\npoint1 = point(1,1)\npoint2 = point(2,3)\npoint3 = point(2,1)\npolygon = [point(0,0),point(0,2),point(2,2),point(2,0)]\ngeoWithin([point1,point2],polygon)\n// output:[true,false,true]\ngeoWithin([point1,point2,point3],polygon,false)\n//output:[true,false,false]\n```\n"
    },
    "getActiveMaster": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getActiveMaster.html",
        "signatures": [
            {
                "full": "getActiveMaster()",
                "name": "getActiveMaster",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getActiveMaster](https://docs.dolphindb.cn/zh/funcs/g/getActiveMaster.html)\n\n\n\n#### 语法\n\ngetActiveMaster()\n\n#### 参数\n\n无\n\n#### 详情\n\n对于普通集群，`getActiveMaster` 函数返回控制节点的别名。\n\n对于包含多个控制节点的集群，`getActiveMaster` 函数返回 Leader 控制节点的别名。\n\n**Note:** 该函数只能在控制节点上执行。\n\n#### 例子\n\n```\ngetActiveMaster();\n// output\ncontroller1\n```\n"
    },
    "getAggregator": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getAggregator.html",
        "signatures": [
            {
                "full": "getStreamEngine(name)",
                "name": "getStreamEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [getAggregator](https://docs.dolphindb.cn/zh/funcs/g/getAggregator.html)\n\n是 [getStreamEngine](https://docs.dolphindb.cn/zh/funcs/g/getStreamEngine.html) 的别名。\n\n\n以下是 `getStreamEngine` 函数的文档：\n### [getStreamEngine](https://docs.dolphindb.cn/zh/funcs/g/getStreamEngine.html)\n\n\n\n#### 语法\n\ngetStreamEngine(name)\n\n#### 参数\n\n**name** 是一个字符串，表示流数据引擎的名称。它可以包含字母，数字和下划线，但必须以字母开头。\n\n#### 详情\n\n返回流数据引擎的句柄，可以作为 [subscribeTable](https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html) 函数的 *handler* 参数。\n\n#### 例子\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\noutputTable = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\ntradesAggregator = createTimeSeriesEngine(\"StreamAggregatorDemo\",3, 3, <[sum(qty)]>, trades, outputTable, `time, false,`sym, 50)\nsubscribeTable(, \"trades\", \"tradesAggregator\", 0, append!{tradesAggregator}, true)\n\ndef writeData(n){\n   timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n   symv =take(`A`B, n)\n   qtyv = take(1, n)\n   insert into trades values(timev, symv, qtyv)\n}\n\nwriteData(6);\nh = getStreamEngine(\"StreamAggregatorDemo\")\n```\n"
    },
    "getAggregatorStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getAggregatorStat.html",
        "signatures": [
            {
                "full": "getStreamEngineStat()",
                "name": "getStreamEngineStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getAggregatorStat](https://docs.dolphindb.cn/zh/funcs/g/getAggregatorStat.html)\n\n是 [getStreamEngineStat](https://docs.dolphindb.cn/zh/funcs/g/getStreamEngineStat.html) 的别名。\n\n\n以下是 `getStreamEngineStat` 函数的文档：\n### [getStreamEngineStat](https://docs.dolphindb.cn/zh/funcs/g/getStreamEngineStat.html)\n\n\n\n#### 语法\n\ngetStreamEngineStat()\n\n别名：getAggregatorStat\n\n#### 参数\n\n无\n\n#### 详情\n\n返回流数据引擎的状态。返回一个字典，包含以下表：\n\n* 表 TimeSeriesEngine 返回时间序列引擎的状态。它包含以下列：\n\n| 列名                | 含义                              |\n| ----------------- | ------------------------------- |\n| name              | 时间序列引擎的名称                       |\n| user              | 创建时间序列引擎的用户名                    |\n| status            | 时间序列引擎的状态，\"OK\"表示可用，\"FATAL\"表示不可用 |\n| lastErrMsg        | 最后一条错误信息                        |\n| windowTime        | 窗口的长度                           |\n| step              | 计算的时间间隔                         |\n| useSystemTime     | 时间序列引擎中 useSystemTime 参数值       |\n| garbageSize       | 触发内存清理的阈值                       |\n| numGroups         | 时间序列引擎中的分组数                     |\n| numRows           | 时间序列引擎中的记录行数                    |\n| numMetrics        | 时间序列引擎使用的聚合指标的数量                |\n| metrics           | 时间序列引擎使用的聚合指标的元代码               |\n| memoryUsed        | 时间序列引擎所占用内存量，单位为字节              |\n| snapshotDir       | 保存引擎快照的文件目录                     |\n| snapshotInterval  | 每隔多少条数据保存一次引擎快照                 |\n| snapshotMsgId     | 最后一个 snapshot 的 msgId           |\n| snapshotTimestamp | 引擎快照的时间戳                        |\n\n* 表 CrossSectionalEngine 返回横截面聚合引擎的状态。它包含以下列：\n\n| 列名                 | 含义                               |\n| ------------------ | -------------------------------- |\n| name               | 横截面引擎的名称                         |\n| user               | 创建横截面引擎的用户名                      |\n| status             | 横截面引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg         | 最后一条错误信息                         |\n| numRows            | 横截面引擎中的记录行数                      |\n| numMetrics         | 横截面引擎使用的聚合指标的数量                  |\n| metrics            | 横截面引擎使用的聚合指标的元代码                 |\n| triggeringPattern  | 横截面引擎触发计算的方式                     |\n| triggeringInterval | 横截面引擎触发计算的时间间隔                   |\n| memoryUsed         | 横截面引擎所占用内存量，单位为字节                |\n\n* 表 AnomalyDetectionEngine 返回异常检测引擎的状态。它包含以下列：\n\n| 列名               | 含义                                |\n| ---------------- | --------------------------------- |\n| name             | 异常检测引擎的名称                         |\n| user             | 创建异常检测引擎的用户名                      |\n| status           | 异常检测引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg       | 最后一条错误信息                          |\n| numGroups        | 异常检测引擎中的分组数                       |\n| numRows          | 异常检测引擎中的记录行数                      |\n| numMetrics       | 异常指标的数量                           |\n| metrics          | 异常指标的元代码                          |\n| snapshotDir      | 保存引擎快照的文件目录                       |\n| snapshotInterval | 每隔多少条数据保存一次引擎快照                   |\n| snapshotMsgId    | 最后一个 snapshot 的 msgId             |\n| snapshotTimestam | 引擎快照的时间戳                          |\n| garbageSize      | 触发内存清理的阈值                         |\n| memoryUsed       | 异常检测引擎所占用内存量，单位为字节                |\n\n* 表 ReactiveStreamEngine 返回响应式状态引擎的状态。它包含以下列：\n\n| 列名                | 含义                                 |\n| ----------------- | ---------------------------------- |\n| name              | 响应式状态引擎的名称                         |\n| user              | 创建响应式状态引擎的用户名                      |\n| status            | 响应式状态引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                           |\n| numGroups         | 响应式状态引擎中的分组数                       |\n| numRows           | 响应式状态引擎中的记录行数                      |\n| numMetrics        | 指标的数量                              |\n| memoryUsed        | 响应式状态引擎所占用内存量，单位为字节                |\n| snapshotDir       | 保存引擎快照的文件目录                        |\n| snapshotInterval  | 每隔多少条数据保存一次引擎快照                    |\n| snapshotMsgId     | 最后一个 snapshot 的 msgId              |\n| snapshotTimestamp | 引擎快照的时间戳                           |\n\n* 表 SessionWindowEngine 返回会话窗口引擎的状态。它包含以下列：\n\n| 列名                | 含义                                |\n| ----------------- | --------------------------------- |\n| name              | 会话窗口引擎的名称                         |\n| user              | 创建会话窗口引擎的用户名                      |\n| status            | 会话窗口引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                          |\n| sessionGap        | 每个会话窗口之间的时间间隔                     |\n| useSystemTime     | 会话窗口聚合引擎计算的触发方式                   |\n| numGroups         | 会话窗口引擎中的分组数                       |\n| numRows           | 会话窗口引擎中的记录行数                      |\n| numMetrics        | 指标的数量                             |\n| Metrics           | 会话窗口聚合引擎使用的聚合指标的元代码               |\n| memoryUsed        | 会话窗口引擎所占用内存量，单位为字节                |\n| snapshotDir       | 会话窗口引擎快照保存的文件目录                   |\n| snapshotInterval  | 每隔多少条数据保存一次引擎快照                   |\n| snapshotMsgId     | 最后一个 snapshot 的 msgId             |\n| snapshotTimestamp | 触发保存快照的时间戳                        |\n\n* 表 DailyTimeSeriesEngine 返回日级时间序列引擎的状态。它包含以下列：\n\n| 列名                | 含义                                  |\n| ----------------- | ----------------------------------- |\n| name              | 日级时间序列引擎的名称                         |\n| user              | 创建日级时间序列引擎的用户名                      |\n| status            | 日级时间序列引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                            |\n| windowTime        | 数据窗口的长度                             |\n| step              | 计算的时间间隔                             |\n| useSystemTime     | 日级时间序列引擎中 useSystemTime 参数值         |\n| garbageSize       | 触发内存清理的阈值                           |\n| numGroups         | 日级时间序列引擎中的分组数                       |\n| numRows           | 日级时间序列引擎中的记录行数                      |\n| numMetrics        | 日级时间序列引擎使用的聚合指标的数量                  |\n| metrics           | 日级时间序列引擎使用的聚合指标的元代码                 |\n| memoryUsed        | 日级时间序列引擎所占用内存量，单位为字节                |\n| snapshotDir       | 日级时间序列聚合引擎快照保存的文件目录                 |\n| snapshotInterval  | 每隔多少条数据保存一次引擎快照                     |\n| snapshotMsgId     | 最后一个 snapshot 的 msgId               |\n| snapshotTimestamp | 触发保存快照的时间戳                          |\n\n* 表 TimeBucketEngine 返回时间序列分组引擎的状态。它包含以下列：\n\n| 列名         | 含义                                |\n| ---------- | --------------------------------- |\n| name       | 时间序列分组引擎的名称                       |\n| user       | 创建时间序列分组引擎的用户名                    |\n| status     | 时间序列分组引擎的状态，\"OK\"表示可用，\"FATAL\"表示不可用 |\n| lastErrMsg | 最后一条错误信息                          |\n| numGroups  | 时间序列分组引擎中的分组数                     |\n| numRows    | 时间序列分组引擎中的记录行数                    |\n| numMetrics | 时间序列分组引擎使用的聚合指标的数量                |\n| metrics    | 时间序列分组引擎使用的聚合指标的元代码               |\n| memoryUsed | 时间序列分组引擎所占用内存量，单位为字节              |\n\n* 表 AsofJoinEngine 返回 asof join 引擎的状态。它包含以下列：\n\n| 列名                | 含义                                      |\n| ----------------- | --------------------------------------- |\n| name              | asof join 引擎的名称                         |\n| user              | 创建 asof join 引擎的用户名                     |\n| status            | asof join 引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                                |\n| useSystemTime     | asof join 引擎中 useSystemTime 参数值         |\n| delayedTime       | asof join 引擎中 delayedTime 参数值           |\n| garbageSize       | 触发内存清理的阈值                               |\n| leftTableNumRows  | asof join 引擎左表中的记录行数                    |\n| rightTableNumRows | asof join 引擎右表中的记录行数                    |\n| numMetrics        | asof join 引擎使用的指标的数量                    |\n| metrics           | asof join 引擎使用的指标的元代码                   |\n| memoryUsed        | asof join 引擎所占用内存量，单位为字节                |\n\n* 表 EqualJoinEngine 返回等值连接引擎的状态。它包含以下列：\n\n| 列名                | 含义                                |\n| ----------------- | --------------------------------- |\n| name              | 等值连接引擎的名称                         |\n| user              | 创建等值连接引擎的用户名                      |\n| status            | 等值连接引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                          |\n| garbageSize       | 触发内存清理的阈值                         |\n| leftTableNumRows  | 等值连接引擎左表中的记录行数                    |\n| rightTableNumRows | 等值连接引擎右表中的记录行数                    |\n| numMetrics        | 等值连接引擎使用的指标的数量                    |\n| metrics           | 等值连接引擎使用的指标的元代码                   |\n| memoryUsed        | 等值连接引擎所占用内存量，单位为字节                |\n\n* 表 WindowJoinEngine 返回 window join 引擎的状态。它包含以下列：\n\n| 列名                | 含义                                        |\n| ----------------- | ----------------------------------------- |\n| name              | window join 引擎的名称                         |\n| user              | 创建 window join 引擎的用户名                     |\n| status            | window join 引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                                  |\n| garbageSize       | 触发内存清理的阈值                                 |\n| leftTableNumRows  | window join 引擎左表中的记录行数                    |\n| rightTableNumRows | window join 引擎右表中的记录行数                    |\n| numMetrics        | window join 引擎使用的指标的数量                    |\n| metrics           | window join 引擎使用的指标的元代码                   |\n| memoryUsed        | window join 引擎所占用内存量，单位为字节                |\n\n* 表 LookupJoinEngine 返回 lookup join 引擎的状态。它包含以下列：\n\n| 列名                | 含义                                        |\n| ----------------- | ----------------------------------------- |\n| name              | lookup join 引擎的名称                         |\n| user              | 创建 lookup join 引擎的用户名                     |\n| status            | lookup join 引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                                  |\n| leftTableNumRows  | lookup join 引擎左表中的记录行数                    |\n| rightTableNumRows | lookup join 引擎右表中的记录行数                    |\n| numMetrics        | lookup join 引擎使用的指标的数量                    |\n| metrics           | lookup join 引擎使用的指标的元代码                   |\n| memoryUsed        | lookup join 引擎所占用内存量，单位为字节                |\n\n* 表 LeftSemiJoinEngine 返回左半等值连接引擎的状态。它包含以下列：\n\n| 列名                | 含义                                  |\n| ----------------- | ----------------------------------- |\n| name              | 左半等值连接引擎的名称                         |\n| user              | 创建左半等值连接引擎的用户名                      |\n| status            | 左半等值连接引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                            |\n| garbageSize       | 触发内存清理的阈值                           |\n| leftTableNumRows  | 左半等值连接引擎左表中的记录行数                    |\n| rightTableNumRows | 左半等值连接引擎右表中的记录行数                    |\n| numMetrics        | 左半等值连接引擎使用的指标的数量                    |\n| metrics           | 左半等值连接引擎使用的指标的元代码                   |\n| memoryUsed        | 左半等值连接引擎所占用内存量，单位为字节                |\n\n* 表 StreamFilter 返回流数据过滤引擎的状态。它包含以下列：\n\n| 列名         | 含义                                 |\n| ---------- | ---------------------------------- |\n| name       | 流数据过滤引擎的名称                         |\n| user       | 创建流数据过滤引擎的用户名                      |\n| status     | 流数据过滤引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg | 最后一条错误信息                           |\n| numRows    | 流数据过滤引擎中的记录行数                      |\n| filters    | 流数据过滤引擎的过滤条件                       |\n\n* 表 StreamDispatchEngine 返回流数据分发引擎的状态。它包含以下列：\n\n| 列名         | 含义                            |\n| ---------- | ----------------------------- |\n| name       | 分发引擎的名称                       |\n| user       | 创建分发引擎的用户名                    |\n| status     | 分发引擎的状态，”OK”表示可用，”FATAL”表示不可用 |\n| lastErrMsg | 最后一条错误信息                      |\n| numRows    | 分发引擎中的记录行数                    |\n| memoryUsed | 分发引擎所占用内存量，单位为字节              |\n\n* 表 ReactiveStateEngine 返回响应式状态引擎的状态。它包含以下列：\n\n| 列名                         | 含义                                                |\n| -------------------------- | ------------------------------------------------- |\n| name                       | 响应式状态引擎的名称                                        |\n| metrics                    | 响应式状态引擎使用的计算公式的元代码                                |\n| dummyTable                 | 表对象，可以含有数据，亦可为空表                                  |\n| outputTable                | 计算结果的输出表，可以是内存表或分布式表                              |\n| keyColumn                  | 分组列名                                              |\n| filter                     | 过滤条件的元代码                                          |\n| snapshotDir                | 保存引擎快照的文件目录                                       |\n| snapshotIntervalInMsgCount | 每隔多少条数据保存一次流数据引擎快照                                |\n| keepOrder                  | 输出表数据是否按照输入时的顺序排序                                 |\n| keyPurgeFilter             | 清理条件的元代码                                          |\n| keyPurgeFreqInSecond       | 触发数据清理需要满足的时间间隔（以秒为单位）                            |\n| raftGroup                  | 流数据高可用订阅端 raft 组的 ID                              |\n| outputElapsedMicroseconds  | 是否输出每个 batch 中数据从注入引擎到计算输出的总耗时，以及每个 batch 包含的总记录数 |\n| keyCapacity                | 建表时系统为该表预分配的 key 分组数量                             |\n| parallelism                | 并行计算的工作线程数                                        |\n\n* 表 DualOwnershipReactiveStateEngine 返回 Dual Ownership Reactive State Engine 的状态。它包含以下列：\n\n| 列名                         | 含义                                                |\n| -------------------------- | ------------------------------------------------- |\n| name                       | Dual Ownership Reactive State Engine 的名称          |\n| metrics                    | Dual Ownership Reactive State Engine 使用的计算公式的元代码  |\n| dummyTable                 | 表对象，可以含有数据，亦可为空表                                  |\n| outputTable                | 计算结果的输出表，可以是内存表或分布式表                              |\n| keyColumn                  | 分组列名                                              |\n| filter                     | 过滤条件的元代码                                          |\n| snapshotDir                | 保存引擎快照的文件目录                                       |\n| snapshotIntervalInMsgCount | 每隔多少条数据保存一次流数据引擎快照                                |\n| keepOrder                  | 输出表数据是否按照输入时的顺序排序                                 |\n| keyPurgeFilter             | 清理条件的元代码                                          |\n| keyPurgeFreqInSecond       | 触发数据清理需要满足的时间间隔（以秒为单位）                            |\n| raftGroup                  | 流数据高可用订阅端 raft 组的 ID                              |\n| outputElapsedMicroseconds  | 是否输出每个 batch 中数据从注入引擎到计算输出的总耗时，以及每个 batch 包含的总记录数 |\n| keyCapacity                | 建表时系统为该表预分配的 key 分组数量                             |\n| parallelism                | 并行计算的工作线程数                                        |\n\n* 表 NarrowReactiveStateEngine 返回生成窄表的响应式状态引擎的状态。它包含以下列：\n\n| 列名                        | 含义                                                       |\n| ------------------------- | -------------------------------------------------------- |\n| name                      | 生成窄表的响应式状态引擎的名称                                          |\n| metrics                   | 需要输出到 *outputTable* 中的除 *keyColumn* 外的输入表中的列或计算指标，用元代码表示 |\n| metricNames               | 输出到 *outputTable*中的指标的名称                                 |\n| dummyTable                | 表对象，可以含有数据，亦可为空表                                         |\n| outputTable               | 计算结果的输出表，可以是内存表或分布式表                                     |\n| keyColumn                 | 分组列名                                                     |\n| filter                    | 过滤条件的元代码                                                 |\n| keepOrder                 | 输出表数据是否按照输入时的顺序排序                                        |\n| keyPurgeFilter            | 清理条件的元代码                                                 |\n| keyPurgeFreqInSecond      | 触发数据清理需要满足的时间间隔（以秒为单位）                                   |\n| outputElapsedMicroseconds | 是否输出每个 batch 中数据从注入引擎到计算输出的总耗时，以及每个 batch 包含的总记录数        |\n| keyCapacity               | 建表时系统为该表预分配的 key 分组数量                                    |\n| parallelism               | 并行计算的工作线程数                                               |\n\n* 表 SnapshotJoinEngine 返回快照连接引擎的状态。它包含以下列：\n\n| 列名                | 含义                                |\n| ----------------- | --------------------------------- |\n| name              | 快照连接引擎的名称                         |\n| user              | 创建快照连接引擎的用户名                      |\n| status            | 快照连接引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                          |\n| leftTableNumRows  | 快照连接引擎左表中的记录行数                    |\n| rightTableNumRows | 快照连接引擎右表中的记录行数                    |\n| numMetrics        | 快照连接引擎使用的指标的数量                    |\n| metrics           | 快照连接引擎使用的指标的元代码                   |\n| memoryUsed        | 快照连接引擎所占用内存量，单位为字节                |\n\n#### 例子\n\n```\nshare streamTable(10:0,`time`sym`price`qty,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades\noutputTable1 = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\noutputTable2 = table(1:0, `time`avgPrice`sumqty`Total, [TIMESTAMP,DOUBLE,INT,DOUBLE])\ntradesTsAggregator = createTimeSeriesEngine(name=\"TimeSeriesDemo\", windowSize=3, step=3, metrics=<[sum(qty)]>, dummyTable=trades, outputTable=outputTable1, timeColumn=`time, keyColumn=`sym, garbageSize=50)\ntradesCsAggregator=createCrossSectionalEngine(name=\"CrossSectionalDemo\", metrics=<[avg(price), sum(qty), sum(price*qty)]>, dummyTable=trades, outputTable=outputTable2, keyColumn=`sym, triggeringPattern=`perRow)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesTsAggregator\", offset=0, handler=append!{tradesTsAggregator}, msgAsTable=true)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesCsAggregator\", offset=0, handler=append!{tradesCsAggregator}, msgAsTable=true)\n\ndef writeData(n){\n   timev = 2000.10.08T01:01:01.001 + timestamp(1..n)\n   symv =take(`A`B, n)\n   pricev=take(102.1 33.4 73.6 223,n)\n   qtyv = take(60 74 82 59, n)\n   insert into trades values(timev, symv, pricev,qtyv)\n}\n\nwriteData(4);\n\ngetStreamEngineStat().TimeSeriesEngine;\ngetStreamEngineStat().CrossSectionalEngine;\n```\n"
    },
    "getAllCatalogs": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getAllCatalogs.html",
        "signatures": [
            {
                "full": "getAllCatalogs()",
                "name": "getAllCatalogs",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getAllCatalogs](https://docs.dolphindb.cn/zh/funcs/g/getAllCatalogs.html)\n\n\n\n#### 语法\n\ngetAllCatalogs()\n\n#### 参数\n\n无\n\n#### 详情\n\n检索当前所有可用的 catalog。返回一个包含 catalog name的向量。\n\n#### 例子\n\n```\ngetAllCatalogs()\n//Output:[\"catalog1\", \"catalog2\", \"catalog3\"]\n```\n"
    },
    "getAllDBGranularity": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getAllDBGranularity.html",
        "signatures": [
            {
                "full": "getAllDBGranularity()",
                "name": "getAllDBGranularity",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getAllDBGranularity](https://docs.dolphindb.cn/zh/funcs/g/getAllDBGranularity.html)\n\n\n\n#### 语法\n\ngetAllDBGranularity()\n\n#### 参数\n\n无\n\n#### 详情\n\n该函数只能在数据节点上执行，用于列出该节点上所有数据库的分区粒度。\n\n返回结果是一个字典，其中：\n\n* key：数据库的名称。\n\n* value：分区粒度，结果为 TABLE 或者 DATABASE。详细说明可参考 [database](https://docs.dolphindb.cn/zh/funcs/d/database.html)的参数*chunkGranularity*。\n\n#### 例子\n\n```\ngetAllDBGranularity()\n    \n/valuedb->TABLE\n```\n"
    },
    "getAllDBs": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getAllDBs.html",
        "signatures": [
            {
                "full": "getAllDBs()",
                "name": "getAllDBs",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getAllDBs](https://docs.dolphindb.cn/zh/funcs/g/getAllDBs.html)\n\n\n\n#### 语法\n\ngetAllDBs()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取当前节点上的分布式数据库。返回的结果是字典，key 是数据库名称，不包含 dfs\\://部分，value 是表名，后面的数字分别是该数据库中表的编号（从1开始）和是否已被删除。\n\n2.00.09 版本起，\n\n* 当该函数由管理员或拥有 DB\\_MANAGE 权限的用户执行时，返回当前节点上所有分布式数据库；\n\n* 否则，仅返回该用户有 DB\\_OWNER 权限的数据库。\n\n#### 例子\n\n```\ngetAllDBs();\n```\n"
    },
    "getAuditLog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getauditlog.html",
        "signatures": [
            {
                "full": "getAuditLog([userName], [startTime], [endTime], [opType])",
                "name": "getAuditLog",
                "parameters": [
                    {
                        "full": "[userName]",
                        "name": "userName",
                        "optional": true
                    },
                    {
                        "full": "[startTime]",
                        "name": "startTime",
                        "optional": true
                    },
                    {
                        "full": "[endTime]",
                        "name": "endTime",
                        "optional": true
                    },
                    {
                        "full": "[opType]",
                        "name": "opType",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getAuditLog](https://docs.dolphindb.cn/zh/funcs/g/getauditlog.html)\n\n#### 语法\n\ngetAuditLog(\\[userName], \\[startTime], \\[endTime], \\[opType])\n\n#### 详情\n\n查询用户 userName 在 startTime 到 endTime 这段时间内完成的，类型为 opType 的 DDL 操作记录。\n\n返回一个表，其结构如下：\n\n|     列名     |       类型      |      含义      |\n| :--------: | :-----------: | :----------: |\n|   userId   |     STRING    |   执行操作的用户名称  |\n|  startTime | NANOTIMESTAMP |    事务的开始时间   |\n|   endTime  | NANOTIMESTAMP |    事务的结束时间   |\n|   dbName   |     STRING    |     数据库名     |\n|   tbName   |     STRING    |      表名      |\n|   opType   |     STRING    |     操作类型     |\n|  opDetail  |     STRING    |    操作细节说明    |\n|     tid    |      LONG     |     事务ID     |\n|     cid    |      LONG     |   commit ID  |\n|  remoteIp  |     IPADDR    | 提交该操作的客户端 IP |\n| remotePort |      INT      |  提交该操作的客户端端口 |\n\nopType 的所有取值及其对应的 opDetail 示例如下：\n\n<table id=\"table_jl4_q3v_mbc\"><thead><tr><th>\n\nopType\n\n</th><th>\n\nopDetail\n\n</th><th>\n\nDescription\n\n</th></tr></thead><tbody><tr><td>\n\nCREATE\\_DB\n\n</td><td>\n\n</td><td>\n\n创建数据库\n\n</td></tr><tr><td>\n\nDROP\\_DB\n\n</td><td>\n\n</td><td>\n\n删除数据库\n\n</td></tr><tr><td>\n\nCREATE\\_TABLE\n\n</td><td>\n\n</td><td>\n\n创建维度表\n\n</td></tr><tr><td>\n\nCREATE\\_PARTITIONED\\_TABLE\n\n</td><td>\n\n</td><td>\n\n创建分区表\n\n</td></tr><tr><td>\n\nDROP\\_TABLE\n\n</td><td>\n\n</td><td>\n\n删除表\n\n</td></tr><tr><td>\n\nDROP\\_PARTITION\n\n</td><td>\n\ndeletedPartitions=xxx\n\n</td><td>\n\n删除分区\n\n</td></tr><tr><td>\n\nRENAME\\_TABLE\n\n</td><td>\n\ntableName=\\[xxx], newTableName=\\[xxx]\n\n</td><td>\n\n给表重命名\n\n</td></tr><tr><td>\n\nSQL\\_DELETE\n\n</td><td>\n\nscript=\\[xxx], deletedRows=xxx\n\n</td><td>\n\nSQL 语句 delete 数据\n\n</td></tr><tr><td>\n\nSQL\\_UPDATE\n\n</td><td>\n\nscript=\\[xxx], updatedRows=xxx\n\n</td><td>\n\nSQL 语句 update 数据\n\n</td></tr><tr><td>\n\nUPSERT\n\n</td><td>\n\ninsertedRows=xxx, updatedRows=xxx\n\n</td><td>\n\n调用函数 upsert! 更新数据\n\n</td></tr><tr><td>\n\nADD\\_COLUMN\n\n</td><td>\n\ncolName=\\[xxx], colType=\\[xxx]\n\n</td><td>\n\n增加列\n\n</td></tr><tr><td>\n\nSET\\_COLUMN\\_COMMENT\n\n</td><td>\n\ncolName=\\[xxx], colComment=\\[xxx]\n\n</td><td>\n\n给列添加注释\n\n</td></tr><tr><td>\n\nTRUNCATE\\_TABLE\n\n</td><td>\n\n</td><td>\n\n删除表所有数据并保留表结构\n\n</td></tr><tr><td>\n\nRENAME\\_COLUMN\n\n</td><td>\n\ncolName=\\[xxx], newColName=\\[xxx]\n\n</td><td>\n\n给列重命名\n\n</td></tr><tr><td>\n\nREPLACE\\_COLUMN\n\n</td><td>\n\ncolName=\\[xxx], colType=\\[xxx], newColType=\\[xxx]\n\n</td><td>\n\n调用函数 replaceColumn! 替换表中的列\n\n</td></tr><tr><td>\n\nDROP\\_COLUMN\n\n</td><td>\n\ncolumnName=\\[xxx]\n\n</td><td>\n\n删除列\n\n</td></tr><tr><td>\n\nADD\\_RANGE\\_PARTITION\n\n</td><td>\n\n</td><td>\n\n调用 addRangePartitions 增加 RANGE 类型分区\n\n</td></tr><tr><td>\n\nADD\\_VALUE\\_PARTITION\n\n</td><td>\n\n</td><td>\n\n调用 addValuePartitions 增加 VALUE 类型分区\n\n</td></tr><tr><td>\n\nAPPEND\n\n</td><td>\n\nappendedRows=xxx\n\n</td><td>\n\n向 atomic='TRANS’ 的库表或向 atomic='CHUNKS’ 的库里的维度表中写入数据\n\n</td></tr><tr><td>\n\nAPPEND\\_CHUNK\\_GRANULARITY\n\n</td><td>\n\nappendedRows=xxx\n\n</td><td>\n\n向 atomic='CHUNKS’ 的库里的分区表中写入数据\n\n</td></tr></tbody>\n</table>## 参数\n\n**userName** 字符串标量或向量，表示要查询的用户。默认为 NULL，表示查询所有用户的 DDL 操作日志。\n\n**startTime** 整数标量或者时间标量，时间标量支持DATE, MONTH, DATETIME, TIMESTAMP, DATEHOUR, NANOTIMESTAMP 类型。表示查询的起始时间点。默认值为 1970.01.01 。\n\n**endTime** 整数标量或者时间标量，时间标量支持DATE, MONTH, DATETIME, TIMESTAMP, DATEHOUR, NANOTIMESTAMP 类型。表示查询的结束时间点。默认值为空，表示结束时间为当前时间。endTime 必须大于 startTime。\n\n**opType** 字符串标量或向量，表示查询的操作类型。默认为 NULL，表示查询所有 DDL 操作类型。\n\n**Note:** startTime 和 endTime 规定的是 DDL 操作结束的时间范围。\n\n#### 例子\n\n```\n// 用户 admin 进行一系列 DDL 操作\nlogin(\"admin\",\"123456\")\nn = 3\nid = rand(`st0001`st0002`st0003`st0004`st0005, n)\nsym = rand(`A`B, n)\ntradeDate = take(2022.01.01..2022.01.10, 3)\nval = 1..n\ndummyTb = table(id, sym,tradeDate, val)\n\ndbPath = \"dfs://auditTest\"\nif(existsDatabase(dbPath)){dropDatabase(dbPath)}\ndb = database(directory=dbPath, partitionType=VALUE, partitionScheme=2022.01.01..2022.01.05, engine='TSDB')\npt = createPartitionedTable(dbHandle=db, table=dummyTb, tableName=\"snap\", partitionColumns=`TradeDate, sortColumns=`id`tradeDate, keepDuplicates=ALL)\npt.append!(dummyTb)\n\nrenameTable(db, `snap, `snap_2)\n\n// 查询 DDL 操作记录\ngetAuditLog()\n```\n\n返回：\n\n| userName | startTime                     | endTime                       | dbName           | tbName | opType                     | opDetail                                   | tid | cid | remoteIp      |\n| -------- | ----------------------------- | ----------------------------- | ---------------- | ------ | -------------------------- | ------------------------------------------ | --- | --- | ------------- |\n| admin    | 2024.03.26 14:40:43.659196080 | 2024.03.26 14:40:43.676082419 | dfs\\://auditTest |        | CREATE\\_DB                 |                                            | 1   | 1   | 192.168.0.140 |\n| admin    | 2024.03.26 14:40:43.676154581 | 2024.03.26 14:40:43.687319577 | dfs\\://auditTest | snap   | CREATE\\_PARTITIONED\\_TABLE |                                            | 2   | 2   | 192.168.0.140 |\n| admin    | 2024.03.26 14:40:45.135000207 | 2024.03.26 14:40:45.160530442 | dfs\\://auditTest | snap   | RENAME\\_TABLE              | tableName=\\[snap], newTableName=\\[snap\\_2] | 4   | 4   | 192.168.0.14  |\n\n"
    },
    "getAuthenticatedUsers": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getAuthenticatedUsers.html",
        "signatures": [
            {
                "full": "getAuthenticatedUsers()",
                "name": "getAuthenticatedUsers",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getAuthenticatedUsers](https://docs.dolphindb.cn/zh/funcs/g/getAuthenticatedUsers.html)\n\n\n\n#### 语法\n\ngetAuthenticatedUsers()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取所有节点已经登录的用户信息。返回一个向量，包含所有已登录用户的名称。\n\n#### 例子\n\n```\ngetAuthenticatedUsers()\n// output\n[\"admin\",\"a1\",\"a3\",\"a2\",\"a4\"]\n```\n"
    },
    "getBackupList": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getBackupList.html",
        "signatures": [
            {
                "full": "getBackupList(backupDir, dbPath, tableName)",
                "name": "getBackupList",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [getBackupList](https://docs.dolphindb.cn/zh/funcs/g/getBackupList.html)\n\n\n\n#### 语法\n\ngetBackupList(backupDir, dbPath, tableName)\n\n#### 参数\n\n**backupDir** 是字符串，表示存放备份数据的目录。\n\n**dbPath** 是字符串，表示分布式数据库的名称。\n\n**tableName** 是字符串，表示数据库中表的名称。\n\n#### 详情\n\n返回一个表，包含指定分布式表的备份信息，每个分区对应表中的一行。其中表中各字段的含义如下：\n\n* chunkID：分区的 ID。\n\n* chunkPath：分区的完整路径。\n\n* cid：版本号。\n\n* rows：分区数据包含的行数。\n\n* updateTime：chunk 最后一次更新的时间戳。\n\n#### 例子\n\n```\nif(existsDatabase(\"dfs://valuedb\")){\n   dropDatabase(\"dfs://valuedb\")\n}\nn=3000000\nmonth=take(2000.01M..2000.04M, n);\nx=1..n\nt=table(month,x);\n\n\ndb=database(\"dfs://valuedb\", VALUE, 2000.01M..2000.04M)\npt = db.createPartitionedTable(t, `pt, `month);\npt.append!(t);\nbackup(\"/home/DolphinDB/backup\",\"dfs://valuedb\",tableName=\"pt\");\ngetBackupList(\"/home/DolphinDB/backup\",\"dfs://valuedb\",\"pt\");\n```\n\n| chunkID                              | chunkPath                  | cid    | rows    | updateTime              |\n| ------------------------------------ | -------------------------- | ------ | ------- | ----------------------- |\n| 0061427c-4b24-e3b6-425c-c0e1553d3c35 | dfs\\://valuedb/200001M/b39 | 13,348 | 750,000 | 2022.09.21T15:45:50.931 |\n| dabbd90d-6001-f8a9-4d3e-8000d96eba68 | dfs\\://valuedb/200002M/b39 | 13,348 | 750,000 | 2022.09.21T15:45:50.931 |\n| f5c259b4-4be3-f385-46d4-1a1a2d224e9d | dfs\\://valuedb/200003M/b39 | 13,348 | 750,000 | 2022.09.21T15:45:50.931 |\n| 6ed58eb9-a2ae-6197-4f81-3186ca1e8b20 | dfs\\://valuedb/200004M/b39 | 13,348 | 750,000 | 2022.09.21T15:45:50.931 |\n"
    },
    "getBackupMeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getBackupMeta.html",
        "signatures": [
            {
                "full": "getBackupMeta(backupDir, dbPath, partition, tableName)",
                "name": "getBackupMeta",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "partition",
                        "name": "partition"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [getBackupMeta](https://docs.dolphindb.cn/zh/funcs/g/getBackupMeta.html)\n\n\n\n#### 语法\n\ngetBackupMeta(backupDir, dbPath, partition, tableName)\n\n#### 参数\n\n**backupDir** 是字符串，表示存放备份数据的目录。\n\n**dbPath** 是字符串，表示分布式数据库的名称，例如 `\"dfs://demo\"`。\n\n**partition** 是字符串，表示分区在数据库内的路径，例如 `\"/20190101/GOOG\"`。\n\n请注意：若使用 2.00.4 到 2.00.6 版本 server，对表级分区数据进行备份和恢复时，该参数必须指定路径到物理索引（可通过函数 [listTables](https://docs.dolphindb.cn/zh/funcs/l/listTables.html) 获取），例如分区 `\"/compoDB/20170807/0_50\"` 下表的物理索引为8，则 partition 需指定为 `\"/compoDB/20170807/0_50/8\"`。\n\n**tableName** 是字符串，表示数据库中表的名称。\n\n#### 详情\n\n返回指定某分布式数据表中某个分区的备份信息。返回的结果是一个字典，包含以下 key：\n\n* schema：该数据表的结构。\n\n* dfsPath：该分区的完整路径。\n\n* rows：分区数据包含的行数。\n\n* chunkID：该分区的 ID。\n\n* cid：版本号。\n\n#### 例子\n\n查看数据库 `dfs://valuedb` 中数据表 \"pt\" 在 `\"/200001M\"` 分区的备份信息。\n\n```\ngetBackupMeta(\"/home/DolphinDB/backup\",\"dfs://valuedb\", \"/200001M\",\"pt\")\n// output\nschema->\nname  typeString typeInt extra comment\n----- ---------- ------- ----- -------\nmonth MONTH      7\nx     INT        4\n\ndfsPath->dfs://valuedb/200001M/b39\nrows->750000\nchunkID->0061427c-4b24-e3b6-425c-c0e1553d3c35\ncid->13349\n```\n"
    },
    "getBackupStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getBackupStatus.html",
        "signatures": [
            {
                "full": "getBackupStatus([userName])",
                "name": "getBackupStatus",
                "parameters": [
                    {
                        "full": "[userName]",
                        "name": "userName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getBackupStatus](https://docs.dolphindb.cn/zh/funcs/g/getBackupStatus.html)\n\n\n\n#### 语法\n\ngetBackupStatus(\\[userName])\n\n#### 参数\n\n**userName** 表示用户名的字符串。\n\n#### 详情\n\n查看指定用户的 backup/restore 任务。返回一个表，每一行为一个任务的信息。包含以下字段：\n\n* userName：用户名。\n\n* type：备份或恢复的类型。\n\n* BACKUP\\_BY\\_SQL/RESTORE\\_BY\\_SQL： 表示使用 SQL 元代码方式的备份/恢复。\n\n* BACKUP\\_BY\\_COPY\\_FILE/RESTORE\\_BY\\_COPY\\_FILE：表示使用拷贝文件方式的备份/恢复。\n\n* startTime：任务开始的时间。\n\n* dbName：数据库的路径。\n\n* tableName：表的名称。\n\n* totalPartitions：待备份/恢复的分区数量。\n\n* completedPartitions：完成备份/恢复的分区数量。\n\n* percentComplete：任务完成百分比。\n\n* endTime：若任务已完成，则返回任务完成的时间，否则返回预估完成时间。\n\n* completed ：任务完成状态。若全部完成，则为1，否则为0。\n\n**Note:**\n\n* 一次 backup 执行过程产生的任务数与其备份的分区的个数相同。\n\n* 管理员调用该函数时，若指定了 *userName*，则返回指定用户的 backup/restore 任务；否则返回所有用户的 backup/restore 任务。\n\n* 非管理员调用该函数时，只能返回当前用户的 backup/restore 任务。\n\n#### 例子\n\n```\ngetBackupStatus()\n```\n\n| userName type | startTime                                      | dbName         | tableName | totalPartitions | completedPartitions | percentComplete | endTime                 | completed |\n| ------------- | ---------------------------------------------- | -------------- | --------- | --------------- | ------------------- | --------------- | ----------------------- | --------- |\n| u1            | BACKUP\\_BY\\_COPY\\_FILE 2022.09.21T17:18:04.264 | dfs\\://valuedb | pt        | 1               | 1                   | 100             | 2022.09.21T17:18:04.269 | 1         |\n| u1            | BACKUP 2022.09.21T17:13:04.344                 | dfs\\://valuedb | pt        | 4               | 4                   | 100             | 2022.09.21T17:13:04.413 | 1         |\n| u1            | BACKUP\\_BY\\_COPY\\_FILE 2022.09.21T17:18:04.264 | dfs\\://valuedb | pt1       | 1               | 1                   | 100             | 2022.09.21T17:18:04.265 | 1         |\n| admin         | BACKUP\\_BY\\_COPY\\_FILE 2022.09.21T16:47:42.798 | dfs\\://valuedb | pt        | 4               | 4                   | 100             | 2022.09.21T16:47:42.859 | 1         |\n| admin         | BACKUP\\_BY\\_COPY\\_FILE 2022.09.21T16:37:33.725 | dfs\\://valuedb | pt        | 4               | 4                   | 100             | 2022.09.21T16:37:33.790 | 1         |\n| admin         | BACKUP 2022.09.21T15:10:05.016                 | dfs\\://compoDB | pt2       | 10              | 10                  | 100             | 2022.09.21T15:10:05.075 | 1         |\n"
    },
    "getCachedSymbolBaseMemSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getCachedSymbolBaseMemSize.html",
        "signatures": [
            {
                "full": "getCachedSymbolBaseMemSize()",
                "name": "getCachedSymbolBaseMemSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getCachedSymbolBaseMemSize](https://docs.dolphindb.cn/zh/funcs/g/getCachedSymbolBaseMemSize.html)\n\n\n\n#### 语法\n\ngetCachedSymbolBaseMemSize()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取引擎中 SYMBOL 类型的字典编码的缓存大小，单位是字节。\n"
    },
    "getCacheEngineMemSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getCacheEngineMemSize.html",
        "signatures": [
            {
                "full": "getCacheEngineMemSize()",
                "name": "getCacheEngineMemSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getCacheEngineMemSize](https://docs.dolphindb.cn/zh/funcs/g/getCacheEngineMemSize.html)\n\n\n\n#### 语法\n\ngetCacheEngineMemSize()\n\n#### 参数\n\n无\n\n#### 详情\n\n查看当前节点下 OLAP 引擎的 Cache Engine 的内存情况，单位为字节。\n\n返回一个 ANY VECTOR：\n\n第1个元素表示 Cache Engine 正在使用的内存量；\n\n第2个元素表示 Cache Engine 保存的列文件占用的内存；\n\n第3个元素表示指向列文件的指针所占用的内存；\n\n第4个元素表示 Cache Engine 允许使用的内存上限。\n\n#### 例子\n\n```\nsetCacheEngineMemSize(0.4)\ngetCacheEngineMemSize()\n// output\n(0,0,0,429496729)\n```\n\n相关函数： [setCacheEngineMemSize](https://docs.dolphindb.cn/zh/funcs/s/setCacheEngineMemSize.html)\n"
    },
    "getCacheEngineStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getCacheEngineStat.html",
        "signatures": [
            {
                "full": "getCacheEngineStat()",
                "name": "getCacheEngineStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getCacheEngineStat](https://docs.dolphindb.cn/zh/funcs/g/getCacheEngineStat.html)\n\n\n\n#### 语法\n\ngetCacheEngineStat()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取当前节点下 OLAP 引擎 Cache Engine 的状态信息。该函数只能在数据节点调用。\n\n返回一个表对象，包含以下几列:\n\n* chunkId: chunk 的唯一标识。\n\n* physicalName: chunk 所属表的物理表名。\n\n* timeSinceLastWrite: 距离最后一次写入经过的时间，单位为毫秒。\n\n* cachedRowsOfCompletedTxn: 当前缓存的已完成事务的记录数。\n\n* cachedRowsOfUncompletedTxn: 当前缓存的未完成事务的记录数。注意: 每个 chunk 最多只有最后一个事务是未完成的。\n\n* cachedMemOfCompletedTxn: cachedRowsOfCompletedTxn 占用的内存，单位为字节。\n\n* cachedMemOfUncompletedTxn: cachedRowsOfUncompletedTxn 占用的内存，单位为字节。\n\n* cachedTids: 当前缓存的事务 id 列表。\n\n#### 例子\n\n```\ngetCacheEngineStat()\n```\n\n| chunkId                              | physicalName | timeSinceLastWrite | cachedRowsOfCompletedTxn | cachedRowsOfUncompletedTxn | cachedMemOfCompletedTxn | cachedMemOfUncompletedTxn | cachedTids |\n| ------------------------------------ | ------------ | ------------------ | ------------------------ | -------------------------- | ----------------------- | ------------------------- | ---------- |\n| e4558d3c-fa41-52b5-418b-94e26cb70a75 | pt\\_2        | 1056               | 222,386                  | 0                          | 3,558,176               | 0                         | 2052       |\n"
    },
    "getChunkPath": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getChunkPath.html",
        "signatures": [
            {
                "full": "getChunkPath(ds)",
                "name": "getChunkPath",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    }
                ]
            }
        ],
        "markdown": "### [getChunkPath](https://docs.dolphindb.cn/zh/funcs/g/getChunkPath.html)\n\n\n\n#### 语法\n\ngetChunkPath(ds)\n\n#### 参数\n\n**ds** 是一个或多个数据源。\n\n#### 详情\n\n返回指定数据源代表数据块的路径。\n\n#### 例子\n\n```\nif(existsDatabase(\"dfs://valuedb\")){\n  dropDatabase(\"dfs://valuedb\")\n}\n\ndb=database(\"dfs://valuedb\", VALUE, 1..10)\nn=1000000\nt=table(rand(1..10, n) as id, rand(100.0, n) as val)\npt=db.createPartitionedTable(t, `pt, `id).append!(t);\nds=sqlDS(<select * from pt where id in 1..3>)\ngetChunkPath(ds);\n\n// output\n[\"/valuedb/1/p\",\"/valuedb/2/p\",\"/valuedb/3/p\"]\n```\n"
    },
    "getChunksMeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getChunksMeta.html",
        "signatures": [
            {
                "full": "getChunksMeta([chunkPath], [top = 1024])",
                "name": "getChunksMeta",
                "parameters": [
                    {
                        "full": "[chunkPath]",
                        "name": "chunkPath",
                        "optional": true
                    },
                    {
                        "full": "[top = 1024]",
                        "name": "[top = 1024]"
                    }
                ]
            }
        ],
        "markdown": "### [getChunksMeta](https://docs.dolphindb.cn/zh/funcs/g/getChunksMeta.html)\n\n\n\n#### 语法\n\ngetChunksMeta(\\[chunkPath], \\[top = 1024])\n\n#### 参数\n\n**chunkPath** 是一个或多个 chunk 的 DFS 路径，支持使用通配符 %，\\* 以及？。\n\n**top** 是一个正整数，表示结果中返回的 chunk 的最多个数。默认值为1024。若设置 *top*= -1，则不限制返回的 chunk的数量。\n\n#### 详情\n\n返回本地节点上指定数据库 chunk 的元数据。若不指定 *chunkPath*，返回本地节点上所有数据库 chunk 的元数据。\n\n返回一个表，包含以下列\n\n* site：节点别名\n* chunkId：chunk 的唯一标识\n* path：分区的物理路径\n* dfsPath：分区 DFS 路径\n* type：分区类型。0表示 file chunk；1表示 tablet chunk。\n* flag：删除标志。若 flag=0，表示此 chunk 数据可以正常被查询和访问。若 flag=1，表示此 chunk 数据已在逻辑上被标记为删除，不可被查询，但仍然占用磁盘空间。\n* size：表示 file chunk 占用磁盘空间，单位为字节。对于 tablet chunk，返回0，需要使用 [getTabletsMeta](https://docs.dolphindb.cn/zh/funcs/g/getTabletsMeta.html) 函数来查看其占用的磁盘空间。\n* version：版本号\n* state：chunk 的状态。\n  * 0：表示 chunk 的最终状态，即所涉及的事务最终正确完成，或者 rollback。\n  * 1：before commit，提交事务之前，即 chunk 上正在执行事务。比如正在写数据或者删除数据。\n  * 2： after commit，已经 commit 事务。\n  * 3： waiting for recovery，等待恢复的状态，比如发生版本不一致或者数据损坏时，数据节点向控制节点发起 recovery 请求后，等待控制节点发起 recovery 时，则会处于这种状态。\n  * 4： in recovery 状态，在 recovery 状态中，接收到控制节点的 recovery 请求，开始启动 recovery，则处于这个状态。recovery 完成后变为最终状态（0）。\n* versionList：版本链\n* resolved：表示 chunk 的事务是否处于决议（commit）状态。true 表示决议状态，false 表示决议后的最终状态。\n\n#### 例子\n\n```\nif(existsDatabase(\"dfs://testDB\")){\n  dropDatabase(\"dfs://testDB\")\n}\n\ndb=database(\"dfs://testDB\", VALUE, 1..10)\nn=1000000\nt=table(rand(1..10, n) as id, rand(100.0, n) as x)\nn=2000000\nt=table(rand(1..10, n) as id, rand(100.0, n) as x, rand(100, n) as y)\ndb.createPartitionedTable(t, `pt2, `id).append!(t)\ngetChunksMeta(\"/testDB%\");\n```\n\n| site     | chunkId                              | path               | dfsPath         | type | flag | size | version | state | versionList       | resolved |\n| -------- | ------------------------------------ | ------------------ | --------------- | ---- | ---- | ---- | ------- | ----- | ----------------- | -------- |\n| P2-node1 | 092d5e12-e595-6f9e-b049-83cba1716997 | /ssd/ssd5/jzVol... | /testDB/pt2.tbl | 0    | 0    | 49   | 1       | 0     | 2052:49;          | false    |\n| P2-node1 | d31e6b47-18f0-37a6-0146-45bf6e266c56 | /ssd/ssd6/jzVol... | /testDB/7       | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1... | false    |\n| P2-node1 | cd99d9ef-d864-f3bc-4945-f97017d43bf1 | /ssd/ssd5/jzVol... | /testDB/2       | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1... | false    |\n| P2-node1 | 8da4bea8-31d0-31b5-784f-67aa6339633d | /ssd/ssd5/jzVol... | /testDB/pt1.tbl | 0    | 0    | 41   | 1       | 0     | 2050:41;          | false    |\n| P2-node1 | dd5fc885-f6a6-bfae-8543-254f9fb92484 | /ssd/ssd6/jzVol... | /testDB/10      | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1... | false    |\n| P2-node1 | 4b8aaed1-2dd6-acb7-5148-4add878c3b33 | /ssd/ssd6/jzVol... | /testDB/domain  | 0    | 0    | 88   | 1       | 0     | 2049:88;          | false    |\n| P2-node1 | 28cb59ec-185a-0ebf-a849-267e769936af | /ssd/ssd6/jzVol... | /testDB/8       | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1... | false    |\n| P2-node1 | b2facbd2-e301-428f-f94f-8579023f78af | /ssd/ssd6/jzVol... | /testDB/3       | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1... | false    |\n| P2-node1 | 8bec6445-bc6d-3693-7f46-d1bcdd350182 | /ssd/ssd6/jzVol... | /testDB/5       | 1    | 0    | 0    | 2       | 0     | cid : 2053,pt1... | false    |\n"
    },
    "getClusterChunksStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getClusterChunksStatus.html",
        "signatures": [
            {
                "full": "getClusterChunksStatus()",
                "name": "getClusterChunksStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getClusterChunksStatus](https://docs.dolphindb.cn/zh/funcs/g/getClusterChunksStatus.html)\n\n\n\n#### 语法\n\ngetClusterChunksStatus()\n\n#### 详情\n\n应用在控制节点上，返回集群中所有 chunk（包括 file chunk 和 tablet chunk）的元数据信息。可以查看 chunk 在集群中数据节点上的分布。\n\n返回一个表，包含以下列\n\n* chunkId：chunk 的唯一标识\n\n* file：分区路径\n\n* size：file chunk 占用磁盘空间，单位为 byte。对于 tablet chunk，返回 0，需要使用 getTabletsMeta 来查看它们实际占用的磁盘空间\n\n* version：版本号\n\n* vcLength：版本链长度\n\n* versionChain：版本链\n\n* state：chunk 状态。CONSTRUCTING：正在事务中； RECOVERING：正在 recovery 中；COMPLETE：已经处于事务终止状态\n\n* replicas：副本的分布信息\n\n* replicaCount：副本数\n\n* lastUpdated：上一次更新的时间戳。请注意，server 从 2.00.1 版本才开始支持该字段，因此获取已经存在的由 2.00.1 之前的 server 创建的 chunk 元数据信息时，该字段将返回空值。\n\n* permission：CHUNK 的权限。CHUNK 的权限分为 READ\\_ONLY 以及 READ\\_WRITE（默认权限）两类。正在进行迁移的分区，或存储在 s3 的分区权限均为 READ\\_ONLY\n\n对于 READ\\_ONLY 权限的分区：\n\n(1) 不能追加或更新数据，并只能通过调用 `drop` 类函数进行删除，且遵从事务的原则。（注意：存储在 s3 的分区不支持事务）。\n\n(2) 不能对其进行 recovery, rebalance 以及 TSDB 引擎的 level file 合并操作。\n\n#### 例子\n\n```\nrpc(getControllerAlias(), getClusterChunksStatus);\n```\n\n| chunkId             | file            | size | version | vcLength | versionChain        | state    | replicas            | replicaCount | lastUpdated             | permission  |\n| ------------------- | --------------- | ---- | ------- | -------- | ------------------- | -------- | ------------------- | ------------ | ----------------------- | ----------- |\n| 092d5e12-e595-6f... | /testDB/pt2.tbl | 49   | 1       | 1        | 2052:49:1 ->        | COMPLETE | P1-node1:1:0,P2-... | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n| 42936e31-8be0-fa... | /testDB/9/i     | 0    | 2       | 2        | 2053:0:2 -> 2051... | COMPLETE | P3-node1:2:0,P1-... | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n| d31e6b47-18f0-37... | /testDB/7/i     | 0    | 2       | 2        | 2053:0:2 -> 2051... | COMPLETE | P1-node1:2:0,P2-... | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n| 647a5fd6-cd85-3b... | /testDB/6/i     | 0    | 2       | 2        | 2053:0:2 -> 2051... | COMPLETE | P1-node1:2:0,P3-... | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n| 8bec6445-bc6d-36... | /testDB/5/i     | 0    | 2       | 2        | 2053:0:2 -> 2051... | COMPLETE | P2-node1:2:0,P3-... | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n| ca690ba5-be73-a6... | /testDB/4/i     | 0    | 2       | 2        | 2053:0:2 -> 2051... | COMPLETE | P3-node1:2:0,P1-... | 2            | 2022.03.31T18:09:41.138 | READ\\_WRITE |\n"
    },
    "getClusterDFSDatabases": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getClusterDFSDatabases.html",
        "signatures": [
            {
                "full": "getClusterDFSDatabases()",
                "name": "getClusterDFSDatabases",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getClusterDFSDatabases](https://docs.dolphindb.cn/zh/funcs/g/getClusterDFSDatabases.html)\n\n\n\n#### 语法\n\ngetClusterDFSDatabases()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回集群中所有的分布式数据库。\n\n#### 例子\n\n```\ngetClusterDFSDatabases()\n\n// output\n[\"dfs://demohash\",\"dfs://myDataYesDB\",\"dfs://testDB\"]\n```\n"
    },
    "getClusterDFSTables": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getClusterDFSTables.html",
        "signatures": [
            {
                "full": "getClusterDFSTables()",
                "name": "getClusterDFSTables",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getClusterDFSTables](https://docs.dolphindb.cn/zh/funcs/g/getClusterDFSTables.html)\n\n\n\n#### 语法\n\ngetClusterDFSTables()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回集群中的分布式表。\n\n2.00.9 版本起，\n\n* 该函数由管理员或拥有 DB\\_MANAGE 权限的用户执行时，返回集群中所有的分布 式表；\n\n* 否则，仅返回该用户有访问权限的分布式表。其中，访问权限包含 DB\\_OWNER, TABLE\\_READ, TABLE\\_WRITE, TABLE\\_INSERT, TABLE\\_UPDATE, TABLE\\_DELETE, DB\\_READ, DB\\_WRITE, DB\\_INSERT, DB\\_UPDATE, DB\\_DELETE。\n\n2.00.10.2 版本起，该函数由拥有 DBOBJ\\_CREATE 权限的用户执行时，还会返回其创建的分布式表。\n\n#### 例子\n\n```\ngetClusterDFSTables()\n```\n\n返回：\\[\"dfs\\://demohash/pt\",\"dfs\\://myDataYesDB/tick\",\"dfs\\://testDB/pt1\",\"dfs\\://testDB/pt2\"]\n"
    },
    "getClusterPerf": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getClusterPerf.html",
        "signatures": [
            {
                "full": "getClusterPerf([includeMaster=false])",
                "name": "getClusterPerf",
                "parameters": [
                    {
                        "full": "[includeMaster=false]",
                        "name": "includeMaster",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [getClusterPerf](https://docs.dolphindb.cn/zh/funcs/g/getClusterPerf.html)\n\n\n\n#### 语法\n\ngetClusterPerf(\\[includeMaster=false])\n\n#### 参数\n\n**includeMaster** 表示获取的节点信息中是否包含控制节点的信息。\n\n#### 详情\n\n获取每个节点的多个配置和性能监控度量值。它只能在控制节点上执行。注意：代理节点的 connectionNum 是一个随机值，可以忽略。\n\n返回一个表对象，包含以下几列：\n\n* host：节点的主机名。\n\n* port：节点的端口号。\n\n* site：节点的局域网信息。\n\n* mode：节点的类型。0 表示集群的数据节点，1 表示集群的代理节点，2 表示集群的控制节点，3 表示 single mode 的节点，4 表示计算节点。\n\n* state：节点是否存活。\n\n* agentSite：当前节点的代理节点信息。\n\n* maxConnections：最多可以从多少个外部 GUI ，API 或其它节点连接到本地节点。\n\n* maxMemSize：当前节点的内存空间上限（单位：GB）。\n\n* workerNum：常规作业的工作线程的数量。默认值是 CPU 的内核数。\n\n* executorNum：本地执行线程的数量。默认值是 CPU 内核数减1。\n\n* connectionNum：连接到本地节点的连接数。\n\n* name：节点别名。\n\n* memoryUsed：节点的内存占用量（单位：字节）。\n\n* memoryAlloc：系统已分配给当前节点的内存（单位：字节）。\n\n* cpuUsage：CPU 使用率。\n\n* avgLoad：CPU 平均负载。\n\n* medLast10QueryTime：前 10 个完成的查询执行所耗费时间的中间值（单位：纳秒）。注意：必须指定 perfMonitoring=1 才会返回该字段。\n\n* maxLast10QueryTime：前 10 个完成的查询执行所耗费时间的最大值（单位：纳秒）。注意：必须指定 perfMonitoring=1 才会返回该字段。\n\n* medLast100QueryTime：前 100 个完成的查询执行所耗费时间的中间值（单位：纳秒）。注意：必须指定 perfMonitoring=1 才会返回该字段。\n\n* maxLast100QueryTime：前100个完成的查询执行所耗费时间的最大值（单位：纳秒）。注意：必须指定 perfMonitoring=1 才会返回该字段。\n\n* maxRunningQueryTime：当前正在执行的查询的耗费时间的最大值（单位：纳秒）。\n\n* runningJobs：正在执行中的 Job 个数。\n\n* queuedJobs：队列中的 Job 个数。\n\n* runningTasks：正在执行中的 Task 个数。\n\n* queuedTasks：队列中的 Task 个数。\n\n* jobLoad：作业负载。\n\n* diskCapacity：磁盘容量（单位：字节）。\n\n* diskFreeSpace：磁盘剩余空间（单位：字节）。\n\n* diskFreeSpaceRatio：磁盘可用空间占比。\n\n* diskWriteRate：磁盘写速率 （单位：字节/秒）。\n\n* diskReadRate：磁盘读速率（单位：字节/秒）。\n\n* lastMinuteWriteVolume：前一分钟写磁盘容量（单位：字节）。\n\n* lastMinuteReadVolume：前一分钟读磁盘容量（单位：字节）。\n\n* networkSendRate：网络发送速率（单位：字节/秒）。\n\n* networkRecvRate：网络接收速率（单位：字节/秒）。\n\n* lastMinuteNetworkSend：前一分钟网络发送字节数（单位：字节）。\n\n* lastMinuteNetworkRecv：前一分钟网络接收字节数 （单位：字节）。\n\n* publicName：若为控制节点，且配置了 publicName，则显示 publicName；否则显示控制节点所在服务器的 网卡地址。若为数据节点或代理节点，则显示数据节点或代理节点所在服务器的网卡地址。\n\n* lastMsgLatency：流数据订阅节点最后收到的消息的延时（单位：纳秒）。\n\n* cumMsgLatency：流数据订阅节点所有已接收的消息的平均延时（单位：纳秒）。\n\n* isLeader：是否是 raft 组的 leader，该字段仅在配置了控制节点高可用时才生效。请注意，若 raft 组存在宕机的节点，则该节点的 isLeader 将返回空值。\n\n#### 例子\n\n```\nrpc(getControllerAlias(), getClusterPerf)\n```\n\n| host         | port  | site                        | mode | state | agentSite                | maxConnections | maxMemSize | workerNum | executorNum | connectionNum | name      | memoryUsed | memoryAlloc | cpuUsage | avgLoad | medLast10QueryTime | maxLast10QueryTime | medLast100QueryTime | maxLast100QueryTime | maxRunningQueryTime | runningJobs | queuedJobs | runningTasks | queuedTasks | jobLoad | diskCapacity      | diskFreeSpace   | diskFreeSpaceRatio | diskWriteRate | diskReadRate | lastMinuteWriteVolume | lastMinuteReadVolume | networkSendRate | networkRecvRate | lastMinuteNetworkSend | lastMinuteNetworkRecv | publicName | lastMsgLatency | cumMsgLatency |\n| ------------ | ----- | --------------------------- | ---- | ----- | ------------------------ | -------------- | ---------- | --------- | ----------- | ------------- | --------- | ---------- | ----------- | -------- | ------- | ------------------ | ------------------ | ------------------- | ------------------- | ------------------- | ----------- | ---------- | ------------ | ----------- | ------- | ----------------- | --------------- | ------------------ | ------------- | ------------ | --------------------- | -------------------- | --------------- | --------------- | --------------------- | --------------------- | ---------- | -------------- | ------------- |\n| 192.168.1.48 | 8,894 | 192.168.1.48:8894:datanode3 | 0    | 1     | 192.168.1.48:8891:agent1 | 192            | 16         | 16        | 15          | 4             | datanode3 | 9,073,704  | 12,648,448  | 1.0309   | 0.0103  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 1,000,068,870,144 | 941,631,864,832 | 0.9416             | 0             | 0            | 1,058 0               | 0                    | 0               | 0               | 0                     | 0                     | 127.0.0.1  | 0              | 0             |\n| 192.168.1.48 | 8,895 | 192.168.1.48:8895:datanode4 | 0    | 1     | 192.168.1.48:8891:agent1 | 192            | 16         | 16        | 15          | 4             | datanode4 | 8,862,912  | 9,502,720   | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 1,000,068,870,144 | 941,631,864,832 | 0.9416             | 0             | 0            | 1,058 0               | 0                    | 0               | 0               | 0                     | 0                     | 127.0.0.1  | 0              | 0             |\n| 192.168.1.48 | 8,891 | 192.168.1.48:8891:agent1    | 1    | 1     | 192.168.1.48:8891:agent1 | 32             | 12         | 4         | 15          | 0             | agent1    | 0          | 0           | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                 | 0               | 0                  | 0             | 0            | 0                     | 0                    | 0               | 0               | 0                     | 0                     |            | 0              | 0             |\n| 192.168.1.48 | 8,892 | 192.168.1.48:8892:datanode1 | 0    | 1     | 192.168.1.48:8891:agent1 | 192            | 16         | 16        | 15          | 4             | datanode1 | 8,976,200  | 10,551,296  | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 1,000,068,870,144 | 941,631,864,832 | 0.9416             | 0             | 0            | 1,058 0               | 0                    | 0               | 0               | 0                     | 0                     | 127.0.0.1  | 0              | 0             |\n| 192.168.1.48 | 8,893 | 192.168.1.48:8893:datanode2 | 0    | 1     | 192.168.1.48:8891:agent1 | 192            | 16         | 16        | 15          | 5             | datanode2 | 9,290,232  | 11,599,872  | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 1,000,068,870,144 | 941,631,864,832 | 0.9416             | 0             | 0            | 1,058 0               | 0                    | 0               | 0               | 0                     | 0                     | 127.0.0.1  | 0              | 0             |\n\n```\nrpc(getControllerAlias(), getClusterPerf).keys()\n// output\n[\"host\",\"port\",\"site\",\"mode\",\"state\",\"agentSite\",\"maxConnections\",\"maxMemSize\",\"workerNum\",\"executorNum\",\"connectionNum\",\"name\",\"memoryUsed\",\"memoryAlloc\",\"cpuUsage\",\"avgLoad\",\"medLast10QueryTime\",\"maxLast10QueryTime\",\"medLast100QueryTime\",\"maxLast100QueryTime\",\"maxRunningQueryTime\",\"runningJobs\",\"queuedJobs\",\"runningTasks\",\"queuedTasks\",\"jobLoad\",\"diskCapacity\",\"diskFreeSpace\",\"diskFreeSpaceRatio\",\"diskWriteRate\",\"diskReadRate\",\"lastMinuteWriteVolume\",\"lastMinuteReadVolume\",\"networkSendRate\",\"networkRecvRate\",\"lastMinuteNetworkSend\",\"lastMinuteNetworkRecv\",\"publicName\",\"lastMsgLatency\",\"cumMsgLatency\"]\n```\n\n集群高可用环境下执行：\n\n```\nrpc(getControllerAlias(), getClusterPerf,true)\n```\n\n| host           | port   | site                                    | mode | state | agentSite                            | maxConnections | maxMemSize | workerNum | executorNum | connectionNum | name               | memoryUsed | memoryAlloc | cpuUsage | avgLoad | medLast10QueryTime | maxLast10QueryTime | medLast100QueryTime | maxLast100QueryTime | maxRunningQueryTime | runningJobs | queuedJobs | runningTasks | queuedTasks | jobLoad | diskCapacity       | diskFreeSpace      | diskFreeSpaceRatio | diskWriteRate | diskReadRate | lastMinuteWriteVolume | lastMinuteReadVolume | networkSendRate | networkRecvRate | lastMinuteNetworkSend | lastMinuteNetworkRecv | publicName                                    | lastMsgLatency | cumMsgLatency | isLeader |\n| -------------- | ------ | --------------------------------------- | ---- | ----- | ------------------------------------ | -------------- | ---------- | --------- | ----------- | ------------- | ------------------ | ---------- | ----------- | -------- | ------- | ------------------ | ------------------ | ------------------- | ------------------- | ------------------- | ----------- | ---------- | ------------ | ----------- | ------- | ------------------ | ------------------ | ------------------ | ------------- | ------------ | --------------------- | -------------------- | --------------- | --------------- | --------------------- | --------------------- | --------------------------------------------- | -------------- | ------------- | -------- |\n| 192.168.100.10 | 17,000 | 192.168.100.10:17000:master3            | 2    | 1     |                                      | 512            | 16         | 64        | 3           | 1             | master3            | 23,449,272 | 24,133,632  | 0.7788   | 0.0037  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 4,658        | 2,736                 | 102,468              | 59,193          | 78,351          | 8,012,182             | 2,378,846             | 192.198.1.10;172.17.0.1;10.244.5.0;10.244.5.1 | 0              | 0             | false    |\n| 192.168.100.11 | 17,000 | 192.168.100.11:17000:master2            | 2    | 1     |                                      | 512            | 16         | 64        | 3           | 2             | master2            | 23,527,872 | 24,133,632  | 11.5625  | 0.3219  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 4,670        | 2,785                 | 116,733              | 62,402          | 56,160          | 1,366,293             | 1,398,238             | 192.198.1.11;172.17.0.1;10.244.4.0;10.244.4.1 | 0              | 0             | false    |\n| 192.168.100.12 | 17,000 | 192.168.100.12:17000:master1            | 2    | 1     |                                      | 512            | 16         | 64        | 3           | 20            | master1            | 25,002,792 | 46,538,752  | 14.0406  | 0.1136  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 4,671        | 13,546,528            | 19,964,606           | 53,206          | 56,891          | 22,543,771            | 8,226,278             | 192.198.1.12;172.17.0.1;10.244.3.0;10.244.3.1 | 0              | 0             | true     |\n| 192.168.100.12 | 17,102 | 192.168.100.12:17102:server19-datanode1 | 0    | 1     | 192.168.100.12:17101:server19-agent1 | 254            | 120        | 5         | 31          | 1             | server19-datanode1 | 23,118,960 | 24,133,632  | 13.928   | 0.1136  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 17,790,585,659,392 | 16,826,060,464,128 | 0.9458             | 0             | 4,687        | 1,289                 | 23,477               | 44,197          | 55,104          | 352,258               | 6,163,159             | 192.198.1.12;172.17.0.1;10.244.3.0;10.244.3.1 | 0              | 0             |          |\n| 192.168.100.11 | 17,102 | 192.168.100.11:17102:server18-datanode1 | 0    | 1     | 192.168.100.11:17101:server18-agent1 | 254            | 120        | 5         | 31          | 1             | server18-datanode1 | 23,111,912 | 24,133,632  | 14.1066  | 0.3219  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 17,790,585,659,392 | 16,714,392,956,928 | 0.9395             | 0             | 4,698        | 1,989                 | 23,530               | 40,896          | 50,706          | 243,008               | 250,727               | 192.198.1.11;172.17.0.1;10.244.4.0;10.244.4.1 | 0              | 0             |          |\n| 192.168.100.11 | 17,101 | 192.168.100.11:17101:server18-agent1    | 1    | 1     | 192.168.100.11:17101:server18-agent1 | 304            | 4          | 4         | 63          | 0             | server18-agent1    | 0          | 0           | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 0            | 0                     | 0                    | 0               | 0               | 0                     | 0                     | 192.198.1.11;172.17.0.1;10.244.4.0;10.244.4.1 | 0              | 0             |          |\n| 192.168.100.10 | 17,102 | 192.168.100.10:17102:server17-datanode1 | 0    | 1     | 192.168.100.10:17101:server17-agent1 | 254            | 120        | 5         | 31          | 1             | server17-datanode1 | 40,872,496 | 52,445,184  | 0.7788   | 0.0037  | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 53,783,736,754,176 | 50,336,934,432,768 | 0.9359             | 0             | 4,699        | 13,900,218            | 18,835               | 118,935         | 109,862         | 6,170,512             | 408,018               | 192.198.1.10;172.17.0.1;10.244.5.0;10.244.5.1 | 0              | 0             |          |\n| 192.168.100.12 | 17,101 | 192.168.100.12:17101:server19-agent1    | 1    | 1     | 192.168.100.12:17101:server19-agent1 | 304            | 4          | 4         | 63          | 0             | server19-agent1    | 0          | 0           | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 0            | 0                     | 0                    | 0               | 0               | 0                     | 0                     | 192.198.1.12;172.17.0.1;10.244.3.0;10.244.3.1 | 0              | 0             |          |\n| 192.168.100.10 | 17,101 | 192.168.100.10:17101:server17-agent1    | 1    | 1     | 192.168.100.10:17101:server17-agent1 | 304            | 4          | 4         | 63          | 0             | server17-agent1    | 0          | 0           | 0        | 0       | 0                  | 0                  | 0                   | 0                   | 0                   | 0           | 0          | 0            | 0           | 0       | 0                  | 0                  | 0                  | 0             | 0            | 0                     | 0                    | 0               | 0               | 0                     | 0                     | 192.198.1.10;172.17.0.1;10.244.5.0;10.244.5.1 | 0              | 0             |          |\n"
    },
    "getCompletedQueries": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getCompletedQueries.html",
        "signatures": [
            {
                "full": "getCompletedQueries([top])",
                "name": "getCompletedQueries",
                "parameters": [
                    {
                        "full": "[top]",
                        "name": "top",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getCompletedQueries](https://docs.dolphindb.cn/zh/funcs/g/getCompletedQueries.html)\n\n\n\n#### 语法\n\ngetCompletedQueries(\\[top])\n\n#### 参数\n\n**top** 是一个正整数。可选参数，默认值为 10。\n\n#### 详情\n\n返回本地节点上最近完成的 *top* 条查询分布式数据库的 SQL 语句的描述信息表，包含以下字段：\n\n| 参数        | 含义                                                                |\n| --------- | ----------------------------------------------------------------- |\n| userID    | 用户 ID 。                                                           |\n| sessionID | 发起查询的会话 ID。                                                       |\n| jobID     | 系统中查询任务的唯一标识。                                                     |\n| rootID    | 当前任务所属根任务的 jobID。                                                 |\n| level     | 任务的级别。根任务的 level 为 0，其分解的子任务 level 为 1，该子任务分解的子任务 level 为 2，以此类推。 |\n| startTime | 查询任务开始时间，为 NANOTIMESTAMP 类型。                                      |\n| endTime   | 查询任务结束时间，为 NANOTIMESTAMP 类型。                                      |\n| jobDesc   | 查询语句描述。                                                           |\n| errorMsg  | 报错信息。                                                             |\n| remoteIP  | 发起查询的客户端 IP。                                                      |\n\n本函数只可由系统管理员执行。在使用该函数之前，必须设定配置参数 *perfMonitoring* = 1 以启动性能监控。\n\n#### 例子\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x)\ndb=database(\"dfs://rangedb16\", RANGE,  0 5 10)\npt = db.createPartitionedTable(t, `pt, `ID)\npt.append!(t)\nt1 = select count(x) from pt;\nt2 = select * from pt where ID=1;\nt3 = select * from pt where ID=5;\n\ngetCompletedQueries()\n```\n\n| userID | sessionID  | jobID                                | rootID                               | level | startTime                     | endTime                       | jobDesc                             | errorMsg | remoteIP  |\n| ------ | ---------- | ------------------------------------ | ------------------------------------ | ----- | ----------------------------- | ----------------------------- | ----------------------------------- | -------- | --------- |\n| admin  | 1166953221 | 4be0f403-a62d-7bae-4ded-43938cc2b4e9 | 4be0f403-a62d-7bae-4ded-43938cc2b4e9 | 0     | 2021.06.28T18:05:34.366483000 | 2021.06.28T18:05:34.372467000 | select ID,x from pt where ID == 1   |          | 127.0.0.1 |\n| admin  | 1166953221 | 9e9132c5-60c2-b3ab-41da-039ad2dcb6ff | 4be0f403-a62d-7bae-4ded-43938cc2b4e9 | 0     | 2021.06.28T18:05:34.366483000 | 2021.06.28T18:05:34.372467000 | select ID,x from pt where ID == 5   |          | 127.0.0.1 |\n| admin  | 1166953221 | 98275891-9c9b-948e-425c-6c3083713d84 | 98275891-9c9b-948e-425c-6c3083713d84 | 0     | 2021.06.28T18:05:34.344272000 | 2021.06.28T18:05:34.359201000 | select count(x) as count\\_x from pt |          | 127.0.0.1 |\n\n```\ngetCompletedQueries().keys()\n```\n\n返回：\\[\"userID\",\"sessionID\",\"jobID\",\"rootID\",\"level\",\"startTime\",\"endTime\",\"jobDesc\",\"errorMsg\",\"remoteIP\"]\n\n```\ngetCompletedQueries().ErrorMsg\n```\n\n返回：\\[,,]\n\n```\ngetCompletedQueries().jobDesc\n```\n\n返回：\\[\"select ID,x from pt where ID == 5\",\"select ID,x from pt where ID == 1\",\"select count(x) as count\\_x from pt\"]\n\n**Related information**\n\n[getRunningQueries](https://docs.dolphindb.cn/zh/funcs/g/getRunningQueries.html)\n"
    },
    "getComputeGroupChunksStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getcomputegroupchunksstatus.html",
        "signatures": [
            {
                "full": "getComputeGroupChunksStatus([computeGroup])",
                "name": "getComputeGroupChunksStatus",
                "parameters": [
                    {
                        "full": "[computeGroup]",
                        "name": "computeGroup",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getComputeGroupChunksStatus](https://docs.dolphindb.cn/zh/funcs/g/getcomputegroupchunksstatus.html)\n\n\n\n#### 语法\n\ngetComputeGroupChunksStatus(\\[computeGroup])\n\n#### 参数\n\n**computeGroup** 可选参数，字符串标量，表示计算组名称。\n\n#### 详情\n\n应用于控制节点，获取指定或所有计算组中缓存的所有 chunk （包括 file chunk 和 tablet chunk）的元数据信息。\n\n\\*\\*返回值：\\*\\*返回一个表，包含以下列：\n\n* chunkId：chunk 的唯一标识\n\n* file：分区路径\n\n* routedTo：计算节点别名，控制节点会将对该分区的查询调度到此计算节点。\n\n* cachedOn：缓存分区的计算节点别名，形式为 alias:\\[version]，例如：orca2:\\[29] 表示名为 orca2 的计算节点缓存了分区版本号为 29 的数据。\n\n* computeGroup：缓存分区的计算组名字。一个分区可能被多个计算组缓存。\n\n* size：file chunk 占用磁盘空间，单位为 byte。对于 tablet chunk，返回 0，需要使用 getTabletsMeta 来查看它们实际占用的磁盘空间。\n\n* version：版本号。\n\n* vcLength：版本链长度。\n\n* versionChain：版本链。\n\n* state：chunk 状态。CONSTRUCTING：正在事务中； RECOVERING：正在 recovery 中；COMPLETE：已经处于事务终止状态。\n\n* dataNodeReplicas：数据节点上副本的分布信息。\n\n* dataNodeReplicaCount：数据节点上副本的数量。\n\n* lastUpdated：上一次更新的时间戳。\n\n* permission：CHUNK 的权限。CHUNK 的权限分为 READ\\_ONLY 以及 READ\\_WRITE（默认权限）两类。正在进行迁移的分区，或存储在 s3 的分区权限均为 READ\\_ONLY。\n\n#### 例子\n\n```\ngetComputeGroupChunksStatus()\n```\n\n| chunkId | path                                 | routedTo                                             | cachedOn | computeGroup  | size | version | vcLength | versionChain | state            | dataNodeReplicas | dataNodeReplicaCount | lastUpdated | permission              |             |\n| ------- | ------------------------------------ | ---------------------------------------------------- | -------- | ------------- | ---- | ------- | -------- | ------------ | ---------------- | ---------------- | -------------------- | ----------- | ----------------------- | ----------- |\n| 0       | abec288a-49f7-61b9-464e-56bf134c8340 | /Storage\\_compute\\_separation\\_tsdb/20120110/Key19/2 | orca3    | \\[NOT CACHED] | orca | 0       | 1        | 1            | 1466:0:1:1466 -> | COMPLETE         | dnode2:1:0:false:0   | 1           | 2024.10.12 17:26:51.757 | READ\\_WRITE |\n| 1       | fdb95a8e-72f0-21a7-0443-2cbe02feeca2 | /Storage\\_compute\\_separation\\_tsdb/20120229/Key1/2  | orca1    | \\[NOT CACHED] | orca | 0       | 1        | 1            | 1463:0:1:1463 -> | COMPLETE         | dnode3:1:0:false:0   | 1           | 2024.10.12 17:26:51.708 | READ\\_WRITE |\n| 2       | 55020019-8b2c-75a1-3b40-7ad2469abe48 | /Storage\\_compute\\_separation\\_tsdb/20120110/Key13/2 | orca3    | \\[NOT CACHED] | orca | 0       | 1        | 1            | 1458:0:1:1458 -> | COMPLETE         | dnode3:1:0:false:0   | 1           | 2024.10.12 17:26:51.618 | READ\\_WRITE |\n| 3       | 96678f5f-6ae5-2b98-9944-5d4370473dee | /Storage\\_compute\\_separation\\_tsdb/20120110/Key7/2  | orca2    | \\[NOT CACHED] | orca | 0       | 1        | 1            | 1456:0:1:1456 -> | COMPLETE         | dnode1:1:0:false:0   | 1           | 2024.10.12 17:26:51.583 | READ\\_WRITE |\n"
    },
    "getComputeNodeCacheStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getcomputenodecachestat.html",
        "signatures": [
            {
                "full": "getComputeNodeCacheStat()",
                "name": "getComputeNodeCacheStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getComputeNodeCacheStat](https://docs.dolphindb.cn/zh/funcs/g/getcomputenodecachestat.html)\n\n\n\n#### 语法\n\ngetComputeNodeCacheStat()\n\n#### 参数\n\n无\n\n#### 详情\n\n应用于计算组中的计算节点上，返回该节点的二级缓存信息。\n\n返回值：返回一个表，包含以下列：\n\n* memCacheUsage：内存缓存的使用量，单位为 MB。\n\n* memCacheSize：内存缓存的最大容量，单位为 MB。\n\n* diskCacheUsage：磁盘缓存的使用量，单位为 MB。\n\n* diskCacheSize：磁盘缓存的最大容量，单位为 MB。\n\n#### 例子\n\n```\ngetComputeNodeCacheStat()\n```\n\n| memCacheUsage      | memCacheSize | diskCacheUsage | diskCacheSize |\n| ------------------ | ------------ | -------------- | ------------- |\n| 114.51725769042969 | 1,024        | 0              | 65,536        |\n"
    },
    "getComputeNodeCachingDelay": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getcomputenodecachingdelay.html",
        "signatures": [
            {
                "full": "getComputeNodeCachingDelay()",
                "name": "getComputeNodeCachingDelay",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getComputeNodeCachingDelay](https://docs.dolphindb.cn/zh/funcs/g/getcomputenodecachingdelay.html)\n\n\n\n#### 语法\n\ngetComputeNodeCachingDelay()\n\n#### 参数\n\n无\n\n#### 详情\n\n查看当前节点下配置项 *computeNodeCachingDelay* 的生效值，单位为秒。\n\n\\*\\*返回值：\\*\\*整型标量。\n\n#### 例子\n\n```\ngetComputeNodeCachingDelay() \n\n// output: 580\n```\n\n相关函数：[setComputeNodeCachingDelay](https://docs.dolphindb.cn/zh/funcs/s/setcomputenodecachingdelay.html)\n"
    },
    "getConfig": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getConfig.html",
        "signatures": [
            {
                "full": "getConfig([key])",
                "name": "getConfig",
                "parameters": [
                    {
                        "full": "[key]",
                        "name": "key",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getConfig](https://docs.dolphindb.cn/zh/funcs/g/getConfig.html)\n\n\n\n#### 语法\n\ngetConfig(\\[key])\n\n#### 参数\n\n**key** 是一个字符串，表示配置参数名称，为可选参数。\n\n#### 详情\n\n若不指定 *key*，返回一个字典，显示系统所有的配置信息。若指定的 *key* 为有效配置参数，返回一个 scalar 或 vector，表示具体的配置信息；若指定的 *key* 不是配置参数，则返回空值。\n\n**Related information**\n\n[参数配置](https://docs.dolphindb.cn/zh/db_distr_comp/cfg/para_cfg.html)\n"
    },
    "getConfigure": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getConfigure.html",
        "signatures": [
            {
                "full": "getConfig([key])",
                "name": "getConfig",
                "parameters": [
                    {
                        "full": "[key]",
                        "name": "key",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getConfigure](https://docs.dolphindb.cn/zh/funcs/g/getConfigure.html)\n\n是 [getConfig](https://docs.dolphindb.cn/zh/funcs/g/getConfig.html) 的别名。\n\n\n以下是 `getConfig` 函数的文档：\n### [getConfig](https://docs.dolphindb.cn/zh/funcs/g/getConfig.html)\n\n\n\n#### 语法\n\ngetConfig(\\[key])\n\n#### 参数\n\n**key** 是一个字符串，表示配置参数名称，为可选参数。\n\n#### 详情\n\n若不指定 *key*，返回一个字典，显示系统所有的配置信息。若指定的 *key* 为有效配置参数，返回一个 scalar 或 vector，表示具体的配置信息；若指定的 *key* 不是配置参数，则返回空值。\n\n**Related information**\n\n[参数配置](https://docs.dolphindb.cn/zh/db_distr_comp/cfg/para_cfg.html)\n"
    },
    "getConnections": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getConnections.html",
        "signatures": [
            {
                "full": "getConnections()",
                "name": "getConnections",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getConnections](https://docs.dolphindb.cn/zh/funcs/g/getConnections.html)\n\n\n\n#### 语法\n\ngetConnections()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取当前节点的所有网络连接信息，可以在所有节点上执行。返回结果有三列，第一列（server）为当前节点自己的 IP 和端口信息，第二列（client）为网络连接对端的 IP 和端口信息，第三列（startTime）为连接建立时间。\n\n#### 例子\n\n```\ngetConnections()\n```\n\n| server         | client          | startTimem              |\n| -------------- | --------------- | ----------------------- |\n| localhost:8848 | 127.0.0.1:62546 | 2021.09.02T16:50:57.814 |\n| localhost:8848 | 127.0.0.1:63081 | 2021.09.02T10:50:16.350 |\n| localhost:8848 | 127.0.0.1:57559 | 2021.09.02T16:50:57.736 |\n"
    },
    "getConsoleJobs": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getConsoleJobs.html",
        "signatures": [
            {
                "full": "getConsoleJobs()",
                "name": "getConsoleJobs",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getConsoleJobs](https://docs.dolphindb.cn/zh/funcs/g/getConsoleJobs.html)\n\n\n\n#### 语法\n\ngetConsoleJobs()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回本地节点上正在执行的交互式任务的描述信息。\n\n包含以下字段：\n\n| 参数                  | 含义                                                                                                                     |\n| ------------------- | ---------------------------------------------------------------------------------------------------------------------- |\n| node                | 本地节点的别名。                                                                                                               |\n| userID              | 用户 ID。                                                                                                                 |\n| rootJobId           | 系统中作业的唯一标识。                                                                                                            |\n| jobType             | 作业类型。                                                                                                                  |\n| desc                | 作业描述。                                                                                                                  |\n| priority            | 作业的优先级，为 0-9 之间的整数。                                                                                                    |\n| parallelism         | 作业的并行度，即分配给该作业的线程数上限。                                                                                                  |\n| receiveTime         | 作业被节点接收的时间。                                                                                                            |\n| sessionId           | 发起作业的会话 ID。                                                                                                            |\n| remoteIP            | 发起作业的客户端 IP。                                                                                                           |\n| remotePort          | 发起作业的客户端的端口号。                                                                                                          |\n| totalTasks          | 作业分解出的总任务数。                                                                                                            |\n| finishedTasks       | 作业分解出的任务中已经完成的任务数。                                                                                                     |\n| runningTask         | 作业分解出的任务中正在执行的任务数。                                                                                                     |\n| firstTaskStartTime  | 第一个任务的开始时间。                                                                                                            |\n| latestTaskStartTime | 最近一个任务的开始时间。                                                                                                           |\n| queue               | 任务队列类型： normal queue（0级 worker 队列），web queue（web 端 worker 队列），local task queue（1\\~5级 worker 队列），batchJob queue（批作业队列）。 |\n\n#### 例子\n\n```\ngetConsoleJobs()\n```\n\n| node     | userID | rootJobId                            | jobType | desc             | priority | parallelism | receiveTime             | sessionId  | remoteIP  | remotePort | totalTasks | finishedTasks | runningTask | firstTaskStartTime      | latestTaskStartTime     | queue        |\n| -------- | ------ | ------------------------------------ | ------- | ---------------- | -------- | ----------- | ----------------------- | ---------- | --------- | ---------- | ---------- | ------------- | ----------- | ----------------------- | ----------------------- | ------------ |\n| P2-node1 | admin  | 26681f9c-f914-81ae-47dd-8b8e6e106c48 | script  | getConsoleJobs() | 4        | 2           | 2022.01.05T11:05:06.778 | 1823289176 | 127.0.0.1 | 50595      | 1          | 0             | 1           | 2022.01.05T11:05:06.778 | 2022.01.05T11:05:06.778 | normal queue |\n"
    },
    "getControllerAlias": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getControllerAlias.html",
        "signatures": [
            {
                "full": "getControllerAlias()",
                "name": "getControllerAlias",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getControllerAlias](https://docs.dolphindb.cn/zh/funcs/g/getControllerAlias.html)\n\n\n\n#### 语法\n\ngetControllerAlias()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取控制节点的别名。该别名定义在由配置参数 config 配置的文件中。\n\n#### 例子\n\n```\ngetControllerAlias();\n// output\nmaster\n```\n\n相关函数：[getNodeAlias](https://docs.dolphindb.cn/zh/funcs/g/getNodeAlias.html)\n"
    },
    "getControllerElectionTick": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getControllerElectionTick.html",
        "signatures": [
            {
                "full": "getControllerElectionTick()",
                "name": "getControllerElectionTick",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getControllerElectionTick](https://docs.dolphindb.cn/zh/funcs/g/getControllerElectionTick.html)\n\n\n\n#### 语法\n\ngetControllerElectionTick()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取控制节点组成的 raft 组的 election tick，即通过 `setRaftElectionTick` 设置的 *tickCount* 或配置项 *raftElectionTick* 的设置值。\n\n相关函数： [setRaftElectionTick](https://docs.dolphindb.cn/zh/funcs/s/setRaftElectionTick.html), [getRaftElectionTick](https://docs.dolphindb.cn/zh/funcs/g/getRaftElectionTick.html)\n"
    },
    "getCurrentCatalog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getCurrentCatalog.html",
        "signatures": [
            {
                "full": "getCurrentCatalog()",
                "name": "getCurrentCatalog",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getCurrentCatalog](https://docs.dolphindb.cn/zh/funcs/g/getCurrentCatalog.html)\n\n\n\n#### 语法\n\ngetCurrentCatalog()\n\n#### 参数\n\n无\n\n#### 详情\n\n查看当前 session 位于哪个 catalog 中。返回一个字符串。\n\n#### 例子\n\n```\nselect * from cat1.db1.table1 // 成功\nselect * from db1.table1 // 报错\n\nuse CATALOG cat1;\n\nselect * from db1.table1 // 成功\ngetCurrentCatalog() // Output:\"cat1\"\n```\n"
    },
    "getCurrentSessionAndUser": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getCurrentSessionAndUser.html",
        "signatures": [
            {
                "full": "getCurrentSessionAndUser()",
                "name": "getCurrentSessionAndUser",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getCurrentSessionAndUser](https://docs.dolphindb.cn/zh/funcs/g/getCurrentSessionAndUser.html)\n\n\n\n#### 语法\n\ngetCurrentSessionAndUser()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取当前 session 的 session ID、用户名、远程 IP 地址和远程端口号。\n\n返回一个元组，第一个元素为 sessionId，第二个元素为 userId（若未登录，则返回\"guest\")，第三个元素为 remoteIP，第四个元素为 remotePort。\n\n#### 例子\n\n```\ngetCurrentSessionAndUser()  \n\n//Output (2333906441, \"admin\", \"127.0.0.1\", 60302)\n```\n"
    },
    "getDatabaseClusterReplicationStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getDatabaseClusterReplicationStatus.html",
        "signatures": [
            {
                "full": "getDatabaseClusterReplicationStatus()",
                "name": "getDatabaseClusterReplicationStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDatabaseClusterReplicationStatus](https://docs.dolphindb.cn/zh/funcs/g/getDatabaseClusterReplicationStatus.html)\n\n\n\n#### 语法\n\ngetDatabaseClusterReplicationStatus()\n\n#### 参数\n\n无\n\n#### 详情\n\n查看所有数据库是否启用集群间的异步复制。该函数只能由管理员在主集群的数据节点调用。\n\n返回一个表对象，包含以下字段：\n\n* dbName：数据库的路径。\n\n* enabled：布尔值，表示是否启用集群间的异步复制。\n\n* executionSet：任务所属的执行集ID。\n\n相关函数：[setDatabaseForClusterReplication](https://docs.dolphindb.cn/zh/funcs/s/setDatabaseForClusterReplication.html)\n"
    },
    "getDatanodeRestartInterval": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getDatanodeRestartInterval.html",
        "signatures": [
            {
                "full": "getDatanodeRestartInterval()",
                "name": "getDatanodeRestartInterval",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDatanodeRestartInterval](https://docs.dolphindb.cn/zh/funcs/g/getDatanodeRestartInterval.html)\n\n\n\n#### 语法\n\ngetDatanodeRestartInterval()\n\n#### 参数\n\n无\n\n#### 详情\n\n在线获取内存中 DatanodeRestartInterval 的值。该命令只能由管理员在控制节点上调用。\n\n相关函数：[setDatanodeRestartInterval](https://docs.dolphindb.cn/zh/funcs/s/setDatanodeRestartInterval.html)\n"
    },
    "getDBAccess": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getDBAccess.html",
        "signatures": [
            {
                "full": "getDBAccess(dbUrl)",
                "name": "getDBAccess",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    }
                ]
            }
        ],
        "markdown": "### [getDBAccess](https://docs.dolphindb.cn/zh/funcs/g/getDBAccess.html)\n\n\n\n#### 语法\n\ngetDBAccess(dbUrl)\n\n#### 参数\n\n**dbUrl** 字符串标量，表示分布式数据库的地址。\n\n#### 详情\n\n查看哪些用户和组具有与数据库 *dbUrl* 相关（包括 ALLOW 和 DENY 权限状态）的权限。\n\n该函数仅限 admin 和对数据库 *dbUrl* 具有 DB\\_OWNER 或 DB\\_MANAGE 权限的用户调用。\n\n返回一个表：\n\n* name 具有相关权限的对象的名称。\n* type 该对象的类型，可选值为 user 和 group，分别对应用户和组。\n* DB\\_READ, DB\\_INSERT, DB\\_UPDATE, DB\\_DELETE, DBOBJ\\_CREATE, DBOBJ\\_DELETE, DB\\_MANAGE 分别指代对应权限，权限状态包括 ALLOW, DENY, NONE。关于用户权限的更多信息可参考[用户权限管理](https://docs.dolphindb.cn/zh/tutorials/ACL_and_Security.html)。\n\n#### 例子\n\n用户 user1 具有 DB\\_OWNER 权限，创建了数据库 `dfs://testDB`，并为用户 user2 授予 DB\\_READ 权限，禁止用户 user3 的 DB\\_INSERT 权限，为组 group1 授予 DBOBJ\\_CREATE 权限。此时，用户 user1 可通过 `getDBAccess` 函数查看哪些用户具有 \"dfs\\://testDB\" 相关的权限。\n\n```\nlogin(`user1, `123456)\ngetDBAccess(\"dfs://testDB\")\n```\n\n| name   | type  | DB\\_READ | DB\\_INSERT | DB\\_UPDATE | DB\\_DELETE | DBOBJ\\_CREATE | DBOBJ\\_DELETE | DB\\_MANAGE |\n| ------ | ----- | -------- | ---------- | ---------- | ---------- | ------------- | ------------- | ---------- |\n| group1 | group | NONE     | NONE       | NONE       | NONE       | ALLOW         | NONE          | NONE       |\n| user3  | user  | NONE     | DENY       | NONE       | NONE       | NONE          | NONE          | NONE       |\n| user2  | user  | ALLOW    | NONE       | NONE       | NONE       | NONE          | NONE          | NONE       |\n| admin  | user  | ALLOW    | ALLOW      | ALLOW      | ALLOW      | ALLOW         | ALLOW         | ALLOW      |\n\n**Related information**\n\n[getTableAccess](https://docs.dolphindb.cn/zh/funcs/g/gettableaccess.html)\n"
    },
    "getDFSDatabases": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getDFSDatabases.html",
        "signatures": [
            {
                "full": "getDFSDatabases()",
                "name": "getDFSDatabases",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDFSDatabases](https://docs.dolphindb.cn/zh/funcs/g/getDFSDatabases.html)\n\n\n\n#### 语法\n\ngetDFSDatabases()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回当前节点上的分布式数据库。\n\n2.00.9 版本起，\n\n* 当该函数由管理员或拥有 DB\\_MANAGE 权限的用户执行时，返回当前节点上所有分布式数据库；\n\n* 否则，仅返回该用户有 DB\\_OWNER 权限的数据库。\n\n#### 例子\n\n```\ngetDFSDatabases()\n```\n"
    },
    "getDfsRebalanceConcurrency": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getDfsRebalanceConcurrency.html",
        "signatures": [
            {
                "full": "getDfsRebalanceConcurrency()",
                "name": "getDfsRebalanceConcurrency",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDfsRebalanceConcurrency](https://docs.dolphindb.cn/zh/funcs/g/getDfsRebalanceConcurrency.html)\n\n\n\n#### 语法\n\ngetDfsRebalanceConcurrency()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取控制节点上允许的再平衡任务的最大并发数。此函数只能由管理员在控制节点调用。\n\n#### 例子\n\n```\ngetDfsRebalanceConcurrency()\n```\n\n相关函数：[resetDfsRebalanceConcurrency](https://docs.dolphindb.cn/zh/funcs/r/resetDfsRebalanceConcurrency.html)\n"
    },
    "getDfsRecoveryConcurrency": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getDfsRecoveryConcurrency.html",
        "signatures": [
            {
                "full": "getDfsRecoveryConcurrency()",
                "name": "getDfsRecoveryConcurrency",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDfsRecoveryConcurrency](https://docs.dolphindb.cn/zh/funcs/g/getDfsRecoveryConcurrency.html)\n\n\n\n#### 语法\n\ngetDfsRecoveryConcurrency()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取控制节点上允许的分区恢复任务的最大并发数。此函数只能由管理员在控制节点调用。\n\n#### 例子\n\n```\ngetDfsRecoveryConcurrency()\n```\n\n相关函数：[resetDfsRecoveryConcurrency](https://docs.dolphindb.cn/zh/funcs/r/resetDfsRecoveryConcurrency.html)\n"
    },
    "getDFSTablesByDatabase": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getDFSTablesByDatabase.html",
        "signatures": [
            {
                "full": "getDFSTablesByDatabase(directory)",
                "name": "getDFSTablesByDatabase",
                "parameters": [
                    {
                        "full": "directory",
                        "name": "directory"
                    }
                ]
            }
        ],
        "markdown": "### [getDFSTablesByDatabase](https://docs.dolphindb.cn/zh/funcs/g/getDFSTablesByDatabase.html)\n\n\n\n#### 语法\n\ngetDFSTablesByDatabase(directory)\n\n#### 参数\n\n**directory** 是分布式数据库所在的目录。\n\n#### 详情\n\n返回分布式数据库中的表。\n\n2.00.9 版本起，\n\n* 当该函数由管理员或拥有 DB\\_MANAGE 权限的用户执行时，返回当前节点上所有分布式表；\n\n* 否则，仅返回该用户有 DB\\_OWNER 权限的数据库中的分布式表。\n\n#### 例子\n\n```\ngetDFSTablesByDatabase(\"dfs://db\")\n// output\n[\"dfs://db1/dt\", \"dfs://db1/dt1\"]\n```\n"
    },
    "getDiskIOStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getDiskIOStat.html",
        "signatures": [
            {
                "full": "getDiskIOStat()",
                "name": "getDiskIOStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDiskIOStat](https://docs.dolphindb.cn/zh/funcs/g/getDiskIOStat.html)\n\n\n\n#### 语法\n\ngetDiskIOStat()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回包含两个键值对的字典：\n\n* diskIOQueueDepths 是一个向量，表示每个 IO 队列的深度。在同一个 DolphinDB 实例中的所有 IO 任务都属于同一个 IO 队列。\n\n* diskIOConcurrencyLevel 是一个整数，表示 IO 队列的数量。\n\n#### 例子\n\n```\ngetDiskIOStat()\n\n// output\ndiskIOQueueDepths->[0]\ndiskIOConcurrnecyLevel->1\n```\n"
    },
    "getDynamicConfig": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getdynamicconfig.html",
        "signatures": [
            {
                "full": "getDynamicConfig()",
                "name": "getDynamicConfig",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getDynamicConfig](https://docs.dolphindb.cn/zh/funcs/g/getdynamicconfig.html)\n\n\n\n#### 语法\n\ngetDynamicConfig()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回一个向量，包含所有可以通过 `setDynamicConfig` 在线修改的配置项名。\n\n#### 例子\n\n```\ngetDynamicConfig();\n// output: [\"recoveryWorkers\",\"OLAPCacheEngineSize\",\"memLimitOfAllTempResults\",\"memLimitOfTempResult\",\"dfsChunkNodeHeartBeatTimeout\",\"maxPartitionNumPerQuery\",\"TSDBCacheEngineSize\",\"memLimitOfTaskGroupResult\",\"memLimitOfQueryResult\",\"maxConnections\",\"maxBlockSizeForReservedMemory\",\"logLevel\",\"reservedMemSize\",\"maxMemSize\",\"enableMultiThreadMerge\"]\n```\n\n**Related information**\n\n[setDynamicConfig](https://docs.dolphindb.cn/zh/funcs/s/setdynamicconfig.html)\n"
    },
    "getEnv": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getEnv.html",
        "signatures": [
            {
                "full": "getEnv(name, [default])",
                "name": "getEnv",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[default]",
                        "name": "default",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getEnv](https://docs.dolphindb.cn/zh/funcs/g/getEnv.html)\n\n\n\n#### 语法\n\ngetEnv(name, \\[default])\n\n#### 参数\n\n**name** 是字符串标量，表示环境变量名称。\n\n**default** 是字符串标量，表示不存在对应的环境变量时返回的默认值。如果没有指定 default，默认值为空字符串。\n\n#### 详情\n\n返回指定环境变量的值。如果环境变量不存在，则返回 default 参数。\n\n#### 例子\n\n```\ngetEnv(\"path\")\n```\n\n返回：`C:\\ProgramData\\DockerDesktop\\version-bin;C:\\Program Files\\Docker\\Docker\\Resources\\bin;`\n\n```\ngetEnv(\"JAVA_HOME\");\n```\n\n返回：`C:\\Program Files\\Java\\jdk1.8.0_191`\n\n```\ngetEnv(\"not_exist\",\"not exist\")\n```\n\n返回：`not exist`\n"
    },
    "getFunctionViews": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getFunctionViews.html",
        "signatures": [
            {
                "full": "getFunctionViews()",
                "name": "getFunctionViews",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getFunctionViews](https://docs.dolphindb.cn/zh/funcs/g/getFunctionViews.html)\n\n\n\n#### 语法\n\ngetFunctionViews()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取函数视图。返回一张表，包含两个字段：\n\n* name：函数名。\n\n* body：函数体。对于直接通过 dom 模块封装的视图，或使用 use \\<moduleName> 的方式加载 dom 模块后再封装其中函数得到的函数视图，该字段将显示函数名，不会显示其函数体。\n\n管理员执行该函数，返回所有用户创建的函数视图；拥有 VIEW\\_OWNER 权限的用户执行该函数只返回该用户创建的函数视图。\n\n#### 例子\n\n```\ngetFunctionViews()\n```\n\n| name          | body          |\n| ------------- | ------------- |\n| countTradeAll | countTradeAll |\n"
    },
    "getGroupAccess": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getGroupAccess.html",
        "signatures": [
            {
                "full": "getGroupAccess(groupIds)",
                "name": "getGroupAccess",
                "parameters": [
                    {
                        "full": "groupIds",
                        "name": "groupIds"
                    }
                ]
            }
        ],
        "markdown": "### [getGroupAccess](https://docs.dolphindb.cn/zh/funcs/g/getGroupAccess.html)\n\n\n\n#### 语法\n\ngetGroupAccess(groupIds)\n\n#### 参数\n\n**groupIds** 表示组名的字符串标量或向量。\n\n#### 详情\n\n返回组的权限。只能由管理员执行该函数。\n\n**Note:**\n\n* 自 3.00.2 版本起，支持获取访问计算节点组的权限。\n\n* 自 3.00.0 版本起，支持获取访问 catalog 的相关权限。\n\n#### 例子\n\n```\ngetGroupAccess(\"myGroup\")\n```\n"
    },
    "getGroupList": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getGroupList.html",
        "signatures": [
            {
                "full": "getGroupList()",
                "name": "getGroupList",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getGroupList](https://docs.dolphindb.cn/zh/funcs/g/getGroupList.html)\n\n\n\n#### 语法\n\ngetGroupList()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回所有组。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n```\ngetGroupList()\n\n// output\n[\"MVP\",\"MYMVP\"]\n```\n"
    },
    "getGroupsByUserId": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getGroupsByUserId.html",
        "signatures": [
            {
                "full": "getGroupsByUserId(userId)",
                "name": "getGroupsByUserId",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    }
                ]
            }
        ],
        "markdown": "### [getGroupsByUserId](https://docs.dolphindb.cn/zh/funcs/g/getGroupsByUserId.html)\n\n\n\n#### 语法\n\ngetGroupsByUserId(userId)\n\n#### 参数\n\n**userId** 是表示用户名的字符串。\n\n#### 详情\n\n返回用户所在的组。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n```\ngetGroupsByUserId(\"admin\")\n\n// output\n[\"MVP\",\"MYMVP\"]\n```\n"
    },
    "getHomeDir": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getHomeDir.html",
        "signatures": [
            {
                "full": "getHomeDir()",
                "name": "getHomeDir",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getHomeDir](https://docs.dolphindb.cn/zh/funcs/g/getHomeDir.html)\n\n\n\n#### 语法\n\ngetHomeDir()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回本地节点的主目录。主目录是由配置文件 dolphindb.cfg 定义的。\n\n#### 例子\n\n```\ngetHomeDir()\n\n// output\n/data/ddb/server\n```\n"
    },
    "getJobMessage": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getJobMessage.html",
        "signatures": [
            {
                "full": "getJobMessage(jobId)",
                "name": "getJobMessage",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    }
                ]
            }
        ],
        "markdown": "### [getJobMessage](https://docs.dolphindb.cn/zh/funcs/g/getJobMessage.html)\n\n\n\n#### 语法\n\ngetJobMessage(jobId)\n\n#### 参数\n\n**jobId** 是批处理作业的 ID，是一个字符串。\n\n#### 详情\n\n取得批处理任务的中间信息。详情请参考 [BatchJobManagement](https://docs.dolphindb.cn/zh/sys_man/BatchJobManagement.html)。\n\n#### 例子\n\n```\ndef job1(n){\n   s = 0\n   for (x in 1 : n) {\n       s += sum(sin rand(1.0, 100000000)-0.5)\n       print(\"iteration \" + x + \" \" + s)\n   }\n   return s\n}\njob1_ID=submitJob(\"job1_ID\",\"\", job1, 100);\n```\n\n批处理作业完成后，执行以下命令：\n\n```\ngetJobMessage(job1_ID);\n```\n\n返回：\n\n```\n2024-02-29 10:56:55.125615 Start the job [job1_ID20240229]: job1\n2024-02-29 10:56:55.938532 iteration 1 2542.744146434795766\n2024-02-29 10:56:56.683705 iteration 2 2834.406141847552134\n2024-02-29 10:56:57.421935 iteration 3 2420.08773301971405\n2024-02-29 10:56:58.176558 iteration 4 5787.891641851039821\n2024-02-29 10:56:58.914166 iteration 5 7869.653776258541256\n2024-02-29 10:56:59.658379 iteration 6 6584.060216762638447\n2024-02-29 10:57:00.406996 iteration 7 4886.262633130692847\n2024-02-29 10:57:01.144179 iteration 8 3143.701651700350794\n2024-02-29 10:57:01.873800 iteration 9 387.615360897112623\n2024-02-29 10:57:02.642908 iteration 10 -821.601298788548092\n2024-02-29 10:57:03.393065 iteration 11 1857.255073417691846\n2024-02-29 10:57:04.136316 iteration 12 -2146.698576091761424\n```\n"
    },
    "getJobReturn": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getJobReturn.html",
        "signatures": [
            {
                "full": "getJobReturn(jobId, [blocking=false])",
                "name": "getJobReturn",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    },
                    {
                        "full": "[blocking=false]",
                        "name": "blocking",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [getJobReturn](https://docs.dolphindb.cn/zh/funcs/g/getJobReturn.html)\n\n\n\n#### 语法\n\ngetJobReturn(jobId, \\[blocking=false])\n\n#### 参数\n\n**jobId** 是批处理作业的 ID，是一个字符串。\n\n**blocking** 是一个布尔值，表示是否采用阻塞模式。默认值为 false。如果 *blocking* 为 false，在批处理作业没有完成的情况下，函数会抛出异常。如果 *blocking* 为 true，直到批处理作业完成后，函数才会返回值。\n\n#### 详情\n\n取得批处理作业返回的对象。详情请参考 [BatchJobManagement](https://docs.dolphindb.cn/zh/sys_man/BatchJobManagement.html)。\n\n#### 例子\n\n```\ndef job1(n){\n   s = 0\n   for (x in 1 : n) {\n       s += sum(sin rand(1.0, 100000000)-0.5)\n       print(\"iteration \" + x + \" \" + s)\n   }\n   return s\n}\n\njob1_ID=submitJob(\"job1_ID\",\"\", job1, 100);\ngetJobReturn(job1_ID);\n```\n\n返回：\n\n```\nThe job [job1_ID20210428] is not complete yet.\n```\n\n批处理作业完成后，重新执行`getJobReturn`：\n\n```\ngetJobReturn(job1_ID);\n```\n\n返回：-13318.181243\n\n如需在工作完成后通过 `getJobReturn` 返回结果，可设置 *blocking* 参数为 true。这在批处理作业中非常有用。\n\n```\njob1_ID = submitJob(\"job1_ID\",\"\", job1, 100)\ngetJobReturn(job1_ID, true);\n```\n\n返回：25,199.851552887143\n"
    },
    "getJobStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getJobStat.html",
        "signatures": [
            {
                "full": "getJobStat()",
                "name": "getJobStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getJobStat](https://docs.dolphindb.cn/zh/funcs/g/getJobStat.html)\n\n\n\n#### 语法\n\ngetJobStat()\n\n#### 参数\n\n无\n\n#### 详情\n\n监控正在执行或者队列中的作业和任务的数量。返回一个字典，其 key 的含义为：\n\n| 参数                | 含义           |\n| ----------------- | ------------ |\n| queuedLocalTasks  | 等待执行的本地任务数。  |\n| runningLocalTasks | 正在执行的本地任务数。  |\n| queuedJobs        | 队列中的作业数。     |\n| runningJobs       | 正在执行的作业数。    |\n| queuedRemoteTasks | 发送到远程执行的任务数。 |\n\n#### 例子\n\n```\ngetJobStat();\n```\n\n返回：\n\n```\nqueuedLocalTasks->0\nrunnningJobs->0\nqueuedRemoteTasks->0\nqueuedJobs->0\nrunningLocalTasks->0\n```\n"
    },
    "getJobStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getJobStatus.html",
        "signatures": [
            {
                "full": "getJobStatus(jobId)",
                "name": "getJobStatus",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    }
                ]
            }
        ],
        "markdown": "### [getJobStatus](https://docs.dolphindb.cn/zh/funcs/g/getJobStatus.html)\n\n\n\n#### 语法\n\ngetJobStatus(jobId)\n\n#### 参数\n\n**jobId** 是批处理作业的 ID，是一个字符串。\n\n#### 详情\n\n取得批处理作业返回的对象。\n\n返回一个表，包含以下字段：\n\n| 参数           | 含义                      |\n| ------------ | ----------------------- |\n| node         | 本地节点的别名。                |\n| userID       | 提交作业任务的用户 ID。           |\n| jobId        | 在提交批作业时指定的作业名。          |\n| rootJobId    | 系统中作业的唯一标识。             |\n| jobDesc      | 用于描述作业的字符串。             |\n| priority     | 作业的优先级，为 0-9 之间的整数。     |\n| parallelism  | 作业的并行度，即分配给该作业的线程数上限。   |\n| clientIp     | 发起作业任务的客户端 IP。          |\n| clientPort   | 发起作业任务的客户端端口号。          |\n| receivedTime | 作业接收的时间，为 TIMESTAMP 类型。 |\n| startTime    | 作业开始时间，为 TIMESTAMP 类型。  |\n| endTime      | 作业结束时间，为 TIMESTAMP 类型。  |\n| errorMsg     | 报错信息。                   |\n\n详情请参考 [BatchJobManagement](https://docs.dolphindb.cn/zh/sys_man/BatchJobManagement.html)。\n\n#### 例子\n\n```\ndef job1(n){\n   s = 0\n   for (x in 1 : n) {\n       s += sum(sin rand(1.0, 100000000)-0.5)\n       print(\"iteration \" + x + \" \" + s)\n   }\n   return s\n}\n\njob1_ID=submitJob(\"job1_ID\",\"\", job1, 100);\ngetJobStatus(job1_ID);\n```\n\n返回：\n\n| node        | userID | jobId               | rootJobId                            | jobDesc | priority | parallelism | clientIP       | clientPort | receivedTime            | startTime | endTime | errorMsg |\n| ----------- | ------ | ------------------- | ------------------------------------ | ------- | -------- | ----------- | -------------- | ---------- | ----------------------- | --------- | ------- | -------- |\n| controller2 | guest  | job1\\_ID20210428... | b9263bfd-50b8-70b3-9845-e595f9b0c506 | job1    | 4        | 1           | 115.204.199.28 | 61537      | 2023.12.12T02:50:32.598 |           |         |          |\n\n在作业的状态中，*EndTime* 是空的。这意味着作业还在执行中。作业完成后，就能在状态中看到 EndTime。\n\n```\ngetJobStatus(job1_ID);\n```\n\n| node        | userID | jobId               | rootJobId                            | jobDesc | priority | parallelism | clientIP       | clientPort | receivedTime            | startTime               | endTime                 | errorMsg |\n| ----------- | ------ | ------------------- | ------------------------------------ | ------- | -------- | ----------- | -------------- | ---------- | ----------------------- | ----------------------- | ----------------------- | -------- |\n| controller2 | guest  | job1\\_ID20210428... | b9263bfd-50b8-70b3-9845-e595f9b0c506 | job1    | 4        | 1           | 115.204.199.28 | 61537      | 2023.12.12T02:50:32.598 | 2023.12.12T02:50:32.599 | 2023.12.12T02:52:32.477 |          |\n"
    },
    "getLeftStream": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getLeftStream.html",
        "signatures": [
            {
                "full": "getLeftStream(joinEngine)",
                "name": "getLeftStream",
                "parameters": [
                    {
                        "full": "joinEngine",
                        "name": "joinEngine"
                    }
                ]
            }
        ],
        "markdown": "### [getLeftStream](https://docs.dolphindb.cn/zh/funcs/g/getLeftStream.html)\n\n\n\n#### 语法\n\ngetLeftStream(joinEngine)\n\n#### 参数\n\n**joinEngine** 创建连接引擎返回的对象。目前 DolphinDB 支持的连接引擎有：\n\n* createAsofJoinEngine\n\n* createEquiJoinEngine\n\n* createLookupJoinEngine\n\n* createWindowJoinEngine\n\n* createLeftSemiJoinEngine\n\n#### 详情\n\n返回连接引擎左表的表结构对象。向该对象注入的数据，会注入到 *joinEngine* 中。\n\n通过该函数，可以将一个引擎的计算结果直接注入到连接引擎中，实现引擎间的级联。\n\n#### 例子\n\n```\nshare streamTable(1000:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\n\noutput=table(100:0, `timestamp`sym`price1`price2, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE])\n\nleftTable=table(1:0, `sym`timestamp`price, [SYMBOL, TIMESTAMP, DOUBLE])\nrightTable=table(1:0, `sym`timestamp`price, [SYMBOL, TIMESTAMP, DOUBLE])\n\najEngine = createAsofJoinEngine(\"asofjoin_engine\", leftTable, rightTable, output, <[leftTable.price, rightTable.price]>, `sym, `timestamp)\n\nleftEngine = createReactiveStateEngine(name=`left_reactive_engine, metrics=<[time,msum(price,3)]>, dummyTable=trades, outputTable=getLeftStream(ajEngine), keyColumn=\"sym\")\nrightEngine = createReactiveStateEngine(name=`right_reactive_engine, metrics=<[time,mfirst(price,3)]>, dummyTable=trades, outputTable=getRightStream(ajEngine), keyColumn=\"sym\")\n\nsubscribeTable(, \"trades\", \"left_reactive_engine\", 0, append!{leftEngine}, true)\nsubscribeTable(, \"trades\", \"right_reactive_engine\", 0, append!{rightEngine}, true)\n\nt = table(2022.01.01 + 1..20 as time, take(`AMZN`IBM`APPL, 20) as sym, rand(100.0, 20) as price)\ntrades.append!(t)\nselect * from output order by timestamp,sym\n```\n\n| timestamp               | sym  | price1   | price2  |\n| ----------------------- | ---- | -------- | ------- |\n| 2022.01.02T00:00:00.000 | AMZN |          |         |\n| 2022.01.03T00:00:00.000 | IBM  |          |         |\n| 2022.01.04T00:00:00.000 | APPL |          |         |\n| 2022.01.05T00:00:00.000 | AMZN |          |         |\n| 2022.01.06T00:00:00.000 | IBM  |          |         |\n| 2022.01.07T00:00:00.000 | APPL |          |         |\n| 2022.01.08T00:00:00.000 | AMZN | 102.192  | 26.2273 |\n| 2022.01.09T00:00:00.000 | IBM  | 152.2704 | 43.6296 |\n| 2022.01.10T00:00:00.000 | APPL | 126.1056 | 74.929  |\n| 2022.01.11T00:00:00.000 | AMZN | 137.4656 | 57.6015 |\n| 2022.01.12T00:00:00.000 | IBM  | 116.7775 | 54.2854 |\n| 2022.01.13T00:00:00.000 | APPL | 58.8909  | 49.3149 |\n| 2022.01.14T00:00:00.000 | AMZN | 148.5405 | 18.3633 |\n| 2022.01.15T00:00:00.000 | IBM  | 141.0848 | 54.3554 |\n| 2022.01.16T00:00:00.000 | APPL | 93.9003  | 1.8618  |\n| 2022.01.17T00:00:00.000 | AMZN | 210.4329 | 61.5008 |\n| 2022.01.18T00:00:00.000 | IBM  | 88.7772  | 8.1367  |\n\n相关函数：[getRightStream](https://docs.dolphindb.cn/zh/funcs/g/getRightStream.html)。\n"
    },
    "getLevelFileIndexCacheStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getLevelFileIndexCacheStats.html",
        "signatures": [
            {
                "full": "getLevelFileIndexCacheStatus()",
                "name": "getLevelFileIndexCacheStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getLevelFileIndexCacheStatus](https://docs.dolphindb.cn/zh/funcs/g/getLevelFileIndexCacheStats.html)\n\n\n\n#### 语法\n\ngetLevelFileIndexCacheStatus()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取所有 level file 的索引内存占用的情况。返回一个字典，包含以下 key 值：\n\n* capacity：level file 索引内存占用上限；\n\n* usage：level file 索引使用的内存，单位为字节。\n\n#### 例子\n\n```\ngetLevelFileIndexCacheStatus()\n\n// output\nusage->0\ncapacity->429496729\n```\n"
    },
    "getLicenseExpiration": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getLicenseExpiration.html",
        "signatures": [
            {
                "full": "getLicenseExpiration()",
                "name": "getLicenseExpiration",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getLicenseExpiration](https://docs.dolphindb.cn/zh/funcs/g/getLicenseExpiration.html)\n\n\n\n#### 语法\n\ngetLicenseExpiration()\n\n#### 参数\n\n无\n\n#### 详情\n\n查看当前节点的 license 过期时间。可用于更新 license 之后，验证新的 license 是否生效。\n\n#### 例子\n\n```\ngetLicenseExpiration()\n```\n\n输出返回：2021.09.30\n"
    },
    "getLoadedPlugins": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getloadedplugins.html",
        "signatures": [
            {
                "full": "getLoadedPlugins()",
                "name": "getLoadedPlugins",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getLoadedPlugins](https://docs.dolphindb.cn/zh/funcs/g/getloadedplugins.html)\n\n\n\n#### 语法\n\ngetLoadedPlugins()\n\n#### 详情\n\n获取当前节点已加载的插件列表。\n\n#### 参数\n\n无\n\n#### 返回值\n\n一张表，包含以下字段：\n\n* plugin：STRING，插件名称。\n\n* version：STRING，插件的版本（*PluginXXX.txt* 文件的版本）\n\n* user：STRING，加载该插件的用户名称。\n\n* time：TIMESTAMP，加载该插件的时间。\n\n#### 例子\n\n```\nlogin(\"admin\",\"123456\")\nloadPlugin(\"zip\")\nlogin(\"user1\",\"123456\")\nloadPlugin(\"httpclient\")\n\ngetLoadedPlugins()\n```\n\n返回结果：\n\n<table id=\"table_w2c_qyx_bdc\"><thead><tr><th align=\"left\">\n\nplugin\n\n</th><th align=\"left\">\n\nversion\n\n</th><th align=\"left\">\n\nuser\n\n</th><th align=\"left\">\n\ntime\n\n</th></tr></thead><tbody><tr><td>\n\nzip\n\n</td><td>\n\n3.00.1\n\n</td><td>\n\nadmin\n\n</td><td>\n\n2024.09.01T10:00:01.000\n\n</td></tr><tr><td>\n\nhttpClient\n\n</td><td>\n\n3.00.1\n\n</td><td>\n\nuser1\n\n</td><td>\n\n2024.09.01T10:00:02.000\n\n</td></tr></tbody>\n</table>\n"
    },
    "getMachineFingerprint": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getMachineFingerprint.html",
        "signatures": [
            {
                "full": "getMachineFingerprint(outputPath)",
                "name": "getMachineFingerprint",
                "parameters": [
                    {
                        "full": "outputPath",
                        "name": "outputPath"
                    }
                ]
            }
        ],
        "markdown": "### [getMachineFingerprint](https://docs.dolphindb.cn/zh/funcs/g/getMachineFingerprint.html)\n\n#### 语法\n\ngetMachineFingerprint(outputPath)\n\n别名：generateMachineFingerprint\n\n#### 参数\n\n**outputPath** 是字符串，表示存放机器指纹的目录。\n\n#### 详情\n\n生成机器指纹，用于 license 验证。该命令必须要用户登录后才能执行。Windows 操作系统下执行该函数需要管理员权限。\n\n#### 例子\n\n```\ngenerateMachineFingerprint(\"/home/DolphinDB\")\n```\n"
    },
    "getMarketCalendar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getMarketCalendar.html",
        "signatures": [
            {
                "full": "getMarketCalendar(marketName, [startDate], [endDate])",
                "name": "getMarketCalendar",
                "parameters": [
                    {
                        "full": "marketName",
                        "name": "marketName"
                    },
                    {
                        "full": "[startDate]",
                        "name": "startDate",
                        "optional": true
                    },
                    {
                        "full": "[endDate]",
                        "name": "endDate",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getMarketCalendar](https://docs.dolphindb.cn/zh/funcs/g/getMarketCalendar.html)\n\n\n\n#### 语法\n\ngetMarketCalendar(marketName, \\[startDate], \\[endDate])\n\n#### 参数\n\n**marketName** 字符串标量，表示交易日历标识，例如：国外交易所的 ISO Code、国内交易所简称或自定义交易日历名称。必须是 *marketHolidayDir* 下存在的文件名，否则会报错。\n\n**startDate** DATE 类型标量。默认为空，表示起始日期为 *marketName* 同名文件中最小年份的1月1日。\n\n**endDate** DATE 类型标量。默认为空，表示结束日期为 *marketName* 同名文件中最大年份的12月31日。\n\n#### 详情\n\nDolphinDB 提供国内外超过50个交易所的交易日历信息（对应文件存放于 *marketHolidayDir* 中），通过该函数可以获取由 *startDate* 和 *endDate* 确定的时间范围内的交易日历。\n\n#### 例子\n\n```\ngetMarketCalendar(\"CCFX\",2022.01.01, 2022.01.10)\n```\n\n输出返回：\\[2022.01.04,2022.01.06,2022.01.07,2022.01.10]\n\n**Related information**\n\n[addMarketHoliday](https://docs.dolphindb.cn/zh/funcs/a/addMarketHoliday.html)\n\n[updateMarketHoliday](https://docs.dolphindb.cn/zh/funcs/u/updateMarketHoliday.html)\n"
    },
    "getMasterReplicationStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getMasterReplicationStatus.html",
        "signatures": [
            {
                "full": "getMasterReplicationStatus([limit=-1])",
                "name": "getMasterReplicationStatus",
                "parameters": [
                    {
                        "full": "[limit=-1]",
                        "name": "limit",
                        "optional": true,
                        "default": "-1"
                    }
                ]
            }
        ],
        "markdown": "### [getMasterReplicationStatus](https://docs.dolphindb.cn/zh/funcs/g/getMasterReplicationStatus.html)\n\n\n\n#### 语法\n\ngetMasterReplicationStatus(\\[limit=-1])\n\n#### 参数\n\n**limit** 一个整数，表示结果中最多可返回的任务数量。\n\n#### 详情\n\n获取主集群的异步复制状态。已完成的任务排列在前面，未完成的任务排列在后面。\n\n* 如果未指定 *limit*，则返回的任务数量不受限制。\n\n* 如果指定 *limit*，则返回最多 *limit* 个任务列表。\n\n其中，已完成的任务最多显示最近的1万条记录；而未完成的任务只显示从最早时间开始，直到满足指定条数的记录。\n\n该函数只能由管理员在主集群的控制节点调用。\n\n返回一个表，包含以下字段：\n\n* taskId：异步复制任务 id。\n\n* tid：事务 id。\n\n* groupId：异步复制任务所属的组 id。\n\n* operationType：任务类型，参照异步复制支持性表。\n\n* submitTime：任务提交的时间，类型为 NANOTIMESTAMP。\n\n* dbName：任务对应的数据库的路径。\n\n* tableName：任务对应的表名。\n\n* srcIP：存储写任务数据的数据节点 ip。\n\n* srcPort：存储写任务数据的数据节点 port。\n\n* isTruncated：该任务是否已经完成并从发送队列回收。\n\n#### 例子\n\n```\ngetMasterReplicationStatus();\n```\n\n输出返回：\n\n| taskId | tid | groupId | operationType              | submitTime                    | dbName                          | tableName | srcIP     | srcPort | isTruncated |\n| ------ | --- | ------- | -------------------------- | ----------------------------- | ------------------------------- | --------- | --------- | ------- | ----------- |\n| 1      | 1   | 1       | CREATE\\_DB                 | 2022.11.08T10:50:35.442141722 | db://test\\_dropPartition\\_value |           | 127.0.0.1 | 8002    | true        |\n| 2      | 2   | 2       | CREATE\\_PARTITIONED\\_TABLE | 2022.11.08T10:50:35.447716190 | db://test\\_dropPartition\\_value | pt        | 127.0.0.1 | 8002    | true        |\n| 3      | 3   | 3       | APPEND                     | 2022.11.08T10:50:35.584920262 | db://test\\_dropPartition\\_value | pt        | 127.0.0.1 | 8002    | true        |\n| 4      | 4   | 4       | DROP\\_PARTITION            | 2022.11.08T10:50:35.632575800 |                                 | pt        | 127.0.0.1 | 8002    | false       |\n\n相关函数：[getSlaveReplicationStatus](https://docs.dolphindb.cn/zh/funcs/g/getSlaveReplicationStatus.html)\n"
    },
    "getMemLimitOfAllTempResults": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getmemlimitofalltempresults.html",
        "signatures": [
            {
                "full": "getMemLimitOfAllTempResults()",
                "name": "getMemLimitOfAllTempResults",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getMemLimitOfAllTempResults](https://docs.dolphindb.cn/zh/funcs/g/getmemlimitofalltempresults.html)\n\n\n\n#### 语法\n\ngetMemLimitOfAllTempResults()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取分布式查询操作（例如表连接、GROUP BY、CONTEXT BY、PIVOT BY）产生的临时表可以占用的内存上限。\n\n#### 例子\n\n```\ngetMemLimitOfAllTempResults ()\n// output: 3.0\n```\n\n相关函数：[setMemLimitOfAllTempResults](https://docs.dolphindb.cn/zh/funcs/s/setmemlimitofalltempresults.html)\n"
    },
    "getMemLimitOfQueryResult": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getMemLimitOfQueryResult.html",
        "signatures": [
            {
                "full": "getMemLimitOfQueryResult()",
                "name": "getMemLimitOfQueryResult",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getMemLimitOfQueryResult](https://docs.dolphindb.cn/zh/funcs/g/getMemLimitOfQueryResult.html)\n\n\n\n#### 语法\n\ngetMemLimitOfQueryResult()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取单次查询结果占用的内存上限（单位为字节），返回一个 DOUBLE 类型数据。\n\n#### 例子\n\n```\nsetMemLimitOfQueryResult(0.2)\ngetMemLimitOfQueryResult() / 1024 / 1024 / 1024\n// output\n0.2\n```\n\n相关函数：[setMemLimitOfQueryResult](https://docs.dolphindb.cn/zh/funcs/s/setMemLimitOfQueryResult.html)\n"
    },
    "getMemLimitOfTaskGroupResult": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getMemLimitOfTaskGroupResult.html",
        "signatures": [
            {
                "full": "getMemLimitOfTaskGroupResult()",
                "name": "getMemLimitOfTaskGroupResult",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getMemLimitOfTaskGroupResult](https://docs.dolphindb.cn/zh/funcs/g/getMemLimitOfTaskGroupResult.html)\n\n\n\n#### 语法\n\ngetMemLimitOfTaskGroupResult()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取当前节点发送的批量子查询占用的内存上限（单位为字节），返回一个 DOUBLE 类型数据。\n\n#### 例子\n\n```\nsetMemLimitOfTaskGroupResult(10)\ngetMemLimitOfTaskGroupResult() / 1024 / 1024 / 1024\n// output\n10\n```\n\n相关函数：[setMemLimitOfTaskGroupResult](https://docs.dolphindb.cn/zh/funcs/s/setMemLimitOfTaskGroupResult.html)\n"
    },
    "getMemoryStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getMemoryStat.html",
        "signatures": [
            {
                "full": "getMemoryStat()",
                "name": "getMemoryStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getMemoryStat](https://docs.dolphindb.cn/zh/funcs/g/getMemoryStat.html)\n\n\n\n#### 语法\n\ngetMemoryStat()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回当前节点已分配的内存和未使用的内存。返回一个字典其 key 值的含义为：\n\n* freeBytes：当前节点未使用的内存，单位为字节。\n\n* allocatedBytes：当前节点已分配的内存，单位为字节。\n\n#### 例子\n\n```\ngetMemoryStat();\n\n// output\nfreeBytes->6430128\nallocatedBytes->35463168\n```\n"
    },
    "getNodeAlias": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getNodeAlias.html",
        "signatures": [
            {
                "full": "getNodeAlias()",
                "name": "getNodeAlias",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getNodeAlias](https://docs.dolphindb.cn/zh/funcs/g/getNodeAlias.html)\n\n\n\n#### 语法\n\ngetNodeAlias()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取本地节点的别名。该别名为配置参数 *localSite* 中定义的 alias。\n\n#### 例子\n\n```\ngetNodeAlias();\n\n// output\ncontroller2\n```\n\n相关函数：[getControllerAlias](https://docs.dolphindb.cn/zh/funcs/g/getControllerAlias.html)\n"
    },
    "getNodeHost": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getNodeHost.html",
        "signatures": [
            {
                "full": "getNodeHost()",
                "name": "getNodeHost",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getNodeHost](https://docs.dolphindb.cn/zh/funcs/g/getNodeHost.html)\n\n\n\n#### 语法\n\ngetNodeHost()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取本地节点的主机名。该主机名为配置参数 *localSite* 中定义的 host。\n\n#### 例子\n\n```\ngetNodeHost();\n\n// output\n10.6.0.6\n```\n"
    },
    "getNodePort": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getNodePort.html",
        "signatures": [
            {
                "full": "getNodePort()",
                "name": "getNodePort",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getNodePort](https://docs.dolphindb.cn/zh/funcs/g/getNodePort.html)\n\n\n\n#### 语法\n\ngetNodePort()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取节点使用的端口号。该端口号为配置参数 *localSite* 中定义的 port。\n\n#### 例子\n\n```\ngetNodePort();\n\n// output\n8888\n```\n"
    },
    "getNodeType": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getNodeType.html",
        "signatures": [
            {
                "full": "getNodeType()",
                "name": "getNodeType",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getNodeType](https://docs.dolphindb.cn/zh/funcs/g/getNodeType.html)\n\n\n\n#### 语法\n\ngetNodeType()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回节点的类型。0表示数据节点；1表示代理节点；2表示控制器节点；3表示单节点模式；4表示计算节点。\n\n#### 例子\n\n```\ngetNodeType();\n\n// output\n2\n```\n"
    },
    "getOLAPCachedSymbolBaseMemSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getOLAPCachedSymbolBaseMemSize.html",
        "signatures": [
            {
                "full": "getOLAPCachedSymbolBaseMemSize()",
                "name": "getOLAPCachedSymbolBaseMemSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getOLAPCachedSymbolBaseMemSize](https://docs.dolphindb.cn/zh/funcs/g/getOLAPCachedSymbolBaseMemSize.html)\n\n\n\n#### 语法\n\ngetOLAPCachedSymbolBaseMemSize()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取 OLAP 引擎中 SYMBOL 类型的字典编码的缓存大小，单位是字节。\n"
    },
    "getOLAPCacheEngineSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getOLAPCacheEngineSize.html",
        "signatures": [
            {
                "full": "getOLAPCacheEngineSize()",
                "name": "getOLAPCacheEngineSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getOLAPCacheEngineSize](https://docs.dolphindb.cn/zh/funcs/g/getOLAPCacheEngineSize.html)\n\n\n\n#### 语法\n\ngetOLAPCacheEngineSize()\n\n别名：getCacheEngineMemSize\n\n#### 参数\n\n无\n\n#### 详情\n\n查看当前节点下 OLAP 引擎的 Cache Engine 的内存情况，单位为字节。\n\n返回一个 ANY VECTOR：\n\n第1个元素表示 Cache Engine 正在使用的内存量；\n\n第2个元素表示 Cache Engine 保存的列文件占用的内存；\n\n第3个元素表示指向列文件的指针所占用的内存；\n\n第4个元素表示 Cache Engine 允许使用的内存上限。\n\n#### 例子\n\n```\nsetOLAPCacheEngineSize(0.4)\ngetOLAPCacheEngineSize()\n// output\n(0,0,0,429496729)\n```\n\n相关函数： [setOLAPCacheEngineSize](https://docs.dolphindb.cn/zh/funcs/s/setOLAPCacheEngineSize.html)\n"
    },
    "getOLAPCacheEngineStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getOLAPCacheEngineStat.html",
        "signatures": [
            {
                "full": "getOLAPCacheEngineStat()",
                "name": "getOLAPCacheEngineStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getOLAPCacheEngineStat](https://docs.dolphindb.cn/zh/funcs/g/getOLAPCacheEngineStat.html)\n\n\n\n#### 语法\n\ngetOLAPCacheEngineStat()\n\n别名：getCacheEngineStat\n\n#### 参数\n\n无\n\n#### 详情\n\n获取当前节点下 OLAP 引擎 Cache Engine 的状态信息。该函数只能在数据节点调用。\n\n返回一个表对象，包含以下几列:\n\n* chunkId：chunk 的唯一标识。\n\n* physicalName：chunk 所属表的物理表名。\n\n* timeSinceLastWrite：距离最后一次写入经过的时间，单位为毫秒。\n\n* cachedRowsOfCompletedTxn：当前缓存的已完成事务的记录数。\n\n* cachedRowsOfUncompletedTxn：当前缓存的未完成事务的记录数。注意：每个 chunk 最多只有最后一个事务是未完成的。\n\n* cachedMemOfCompletedTxn：cachedRowsOfCompletedTxn 占用的内存，单位为字节。\n\n* cachedMemOfUncompletedTxn：cachedRowsOfUncompletedTxn 占用的内存，单位为字节。\n\n* cachedTids：当前缓存的事务 id 列表。\n\n#### 例子\n\n```\ngetOLAPCacheEngineStat()\n```\n\n| chunkId                              | physicalName | timeSinceLastWrite | cachedRowsOfCompletedTxn | cachedRowsOfUncompletedTxn | cachedMemOfCompletedTxn | cachedMemOfUncompletedTxn | cachedTids |\n| ------------------------------------ | ------------ | ------------------ | ------------------------ | -------------------------- | ----------------------- | ------------------------- | ---------- |\n| e4558d3c-fa41-52b5-418b-94e26cb70a75 | pt\\_2        | 1056               | 222,386                  | 0                          | 3,558,176               | 0                         | 2052       |\n"
    },
    "getOS": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getOS.html",
        "signatures": [
            {
                "full": "getOS()",
                "name": "getOS",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getOS](https://docs.dolphindb.cn/zh/funcs/g/getOS.html)\n\n\n\n#### 语法\n\ngetOS()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回 DolphinDB server 所在操作系统的类型。\n\n#### 例子\n\n```\ngetOS();\n\n// output\nlinux\n```\n"
    },
    "getOSBit": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getOSBit.html",
        "signatures": [
            {
                "full": "getOSBit()",
                "name": "getOSBit",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getOSBit](https://docs.dolphindb.cn/zh/funcs/g/getOSBit.html)\n\n\n\n#### 语法\n\ngetOSBit()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回 DolphinDB server 所在操作系统的位数。\n\n#### 例子\n\n```\ngetOSBit();\n\n// output\n64\n```\n"
    },
    "getPerf": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getPerf.html",
        "signatures": [
            {
                "full": "getPerf()",
                "name": "getPerf",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getPerf](https://docs.dolphindb.cn/zh/funcs/g/getPerf.html)\n\n\n\n#### 语法\n\ngetPerf()\n\n#### 参数\n\n无\n\n#### 详情\n\n以字典的形式返回本地节点上的多个性能监控度量值。包含以下 key：\n\n* runningJobs：正在执行中的 Job 个数。\n\n* jobLoad：作业负载。\n\n* avgLoad：CPU 平均负载。\n\n* queuedJobs：队列中的 Job 个数。\n\n* lastMinuteNetworkSend：前一分钟网络发送字节数（单位：字节）。\n\n* lastMinuteNetworkRecv：前一分钟网络接收字节数 （单位：字节）。\n\n* lastMinuteReadVolume：前一分钟读磁盘容量（单位：字节）。\n\n* lastMinuteWriteVolume：前一分钟写磁盘容量（单位：字节）。\n\n* lastMsgLatency：前一批消息的延时（单位：纳秒）。\n\n* cumMsgLatency：所有消息的平均延时（单位：纳秒）。\n\n* maxLast10QueryTime：前 10 个完成的查询执行所耗费时间的最大值（单位：纳秒）。\n\n* maxLast100QueryTime：前100个完成的查询执行所耗费时间的最大值（单位：纳秒）。\n\n* medLast10QueryTime：前 10 个完成的查询执行所耗费时间的中间值（单位：纳秒）。\n\n* medLast100QueryTime：前 100 个完成的查询执行所耗费时间的中间值（单位：纳秒）。\n\n* maxRunningQueryTime：当前正在执行的查询的耗费时间的最大值（单位：纳秒）。\n\n* diskFreeSpaceRatio：磁盘可用空间占比。\n\n* diskReadRate：磁盘读速率（单位：字节/秒）。\n\n* diskWriteRate：磁盘写速率（单位：字节/秒）。\n\n* diskFreeSpace：磁盘剩余空间（单位：字节）。\n\n* diskCapacity：磁盘容量（单位：字节）。\n\n* cpuUsage：CPU 使用率。\n\n* memoryAlloc：系统已分配给当前节点的内存（单位：字节）。\n\n* memoryUsed：节点的内存占用量（单位：字节）。\n\n* networkSendRate：网络发送速率（单位：字节/秒）。\n\n* networkRecvRate：网络接收速率（单位：字节/秒）。\n\n* connectionNum：连接到本地节点的连接数。\n\n#### 例子\n\n```\ngetPerf();\n\n// output\ncumMsgLatency->-9.223372036854776E18\nlastMsgLatency->-9.223372036854776E18\nlastMinuteNetworkRecv->2184101\nmaxLast10QueryTime->224829\nlastMinuteNetworkSend->378283\ndiskWriteRate->144\nnetworkSendRate->3924\nmedLast100QueryTime->131965\navgLoad->1.0228125\nrunningJobs->0\nconnectionNum->2\nmedLast10QueryTime->131965\ncpuUsage->0\ndiskFreeSpaceRatio->0.041250206237365\njobLoad->0\nmemoryUsed->7970304\nmemoryAlloc->19513344\nmaxLast100QueryTime->224829\nnetworkRecvRate->32238\nmaxRunningQueryTime->0\ndiskCapacity->1.859747577856E12\nqueuedJobs->0\ndiskFreeSpace->7.6714971136E10\ndiskReadRate->6538\nlastMinuteWriteVolume->1515\nlastMinuteReadVolume->392408\n```\n"
    },
    "getPersistenceMeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getPersistenceMeta.html",
        "signatures": [
            {
                "full": "getPersistenceMeta(table)",
                "name": "getPersistenceMeta",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [getPersistenceMeta](https://docs.dolphindb.cn/zh/funcs/g/getPersistenceMeta.html)\n\n\n\n#### 语法\n\ngetPersistenceMeta(table)\n\n#### 参数\n\n**table** 是一个表。\n\n#### 详情\n\n返回启用了持久化的共享流数据表的元数据。返回的结果是一个字典，包含以下 key：\n\n* lastLogSeqNum：最新的 Raft 日志的逻辑序列号\n\n* sizeInMemory：内存中保留的记录数\n\n* asynWrite：持久化是否采用异步的方式\n\n* totalSize：流数据表中的总记录数\n\n* raftGroup：高可用流数据表所属 Raft 组的 ID。对于普通的流数据表，该值为-1\n\n* compress：是否采用压缩存储\n\n* memoryOffset：当前内存中数据相对总记录数的偏移量，memoryOffset = totalSize - sizeInMemory\n\n* sizeOnDisk：已经持久化到磁盘的记录数\n\n* retentionMinutes：日志文件的保留时间，默认值是1440分钟，即一天\n\n* persistenceDir：持久化路径\n\n* hashValue：对本表做持久化的工作线程标识，当配置项 persistenceWorkerNum>1时，hashValue 可能不为0\n\n* diskOffset：当前磁盘上数据相对总记录数的偏移量\n\n#### 例子\n\n```\ncolName=[\"time\",\"x\"]\ncolType=[\"timestamp\",\"int\"]\nt = streamTable(100:0, colName, colType);\nenableTableShareAndPersistence(table=t, tableName=`st, cacheSize=1200000)\n\ngo;\n\nfor(s in 0:200){\n   n=10000\n   time=2019.01.01T00:00:00.000+s*n+1..n\n   x=rand(10.0, n)\n   insert into st values(time, x)\n}\n\ngetPersistenceMeta(st);\n\n// output\nastLogSeqNum->-1\nsizeInMemory->800000\nasynWrite->true\ntotalSize->2000000\nraftGroup->-1\ncompress->true\nmemoryOffset->1200000\nretentionMinutes->1440\nsizeOnDisk->2000000\npersistenceDir->/dolphindb/server/streamPersistDir/st\nhashValue->0\ndiskOffset->0\n```\n"
    },
    "getPKEYCompactionTaskStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getpkeycompactiontaskstatus.html",
        "signatures": [
            {
                "full": "getPKEYCompactionTaskStatus([count])",
                "name": "getPKEYCompactionTaskStatus",
                "parameters": [
                    {
                        "full": "[count]",
                        "name": "count",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getPKEYCompactionTaskStatus](https://docs.dolphindb.cn/zh/funcs/g/getpkeycompactiontaskstatus.html)\n\n\n\n#### 语法\n\ngetPKEYCompactionTaskStatus(\\[count])\n\n#### 参数\n\n**count** 可选参数，非负整数。设置后，将返回配置项 volumes 中的每一个 volume 的最近的 *count* 个已结束的合并任务的记录（包括成功和失败），以及所有正在执行或尚未开始的任务的记录。默认值为 0，表示返回所有合并任务的状态信息。\n\n#### 详情\n\n返回一个表，显示 PKEY 引擎 level file 合并操作任务的状态。该函数只能在数据节点调用。\n\n状态表包含以下几列：\n\n<table id=\"table_ev1_2ml_cdc\"><thead><tr><th>\n\n列名\n\n</th><th>\n\n含义\n\n</th></tr></thead><tbody><tr><td>\n\nvolume\n\n</td><td>\n\n发生合并的文件所在的磁盘卷路径。由配置项 *volumes* 进行配置。\n\n</td></tr><tr><td>\n\nlevel\n\n</td><td>\n\nSTRING 类型，当前合并的 level file 层级。一次合并最多涉及两个层级。如果此列为空，说明该合并任务尚未开始、正在执行，或执行失败。\n\n</td></tr><tr><td>\n\nchunkId\n\n</td><td>\n\n发生合并操作的 chunk 的 ID。\n\n</td></tr><tr><td>\n\ntableName\n\n</td><td>\n\n发生合并操作的数据表的物理表名。\n\n</td></tr><tr><td>\n\nfiles\n\n</td><td>\n\n参与当前合并任务的 level file。如果此列为空，说明该合并任务尚未开始、正在执行，或执行失败。\n\n</td></tr><tr><td>\n\nforce\n\n</td><td>\n\n是否由 `triggerPKEYCompaction` 强制触发。\n\n</td></tr><tr><td>\n\nreceivedTime\n\n</td><td>\n\n当前合并任务进入任务队列的时间戳。\n\n</td></tr><tr><td>\n\nstartTime\n\n</td><td>\n\n当前合并任务开始执行的时间戳。\n\n</td></tr><tr><td>\n\nendTime\n\n</td><td>\n\n当前合并任务执行结束的时间戳。\n\n</td></tr><tr><td>\n\nerrorMessage\n\n</td><td>\n\n报错信息。如果失败，则显示失败的原因；否则显示空。\n\n</td></tr></tbody>\n</table>## 例子\n\n```\ngetPKEYCompactionTaskStatus()\n```\n\n<table id=\"table_myr_gml_cdc\"><thead><tr><th>\n\nvolume\n\n</th><th>\n\nlevel\n\n</th><th>\n\nchunkId\n\n</th><th>\n\ntableName\n\n</th><th>\n\nfiles\n\n</th><th>\n\nforce\n\n</th><th>\n\nreceivedTime\n\n</th><th>\n\nstartTime\n\n</th><th>\n\nendTime\n\n</th><th>\n\nerrorMessage\n\n</th></tr></thead><tbody><tr><td>\n\n/home/dolphindb/server/local8848/storage\n\n</td><td>\n\n2\n\n</td><td>\n\nac872f06-abed-339c-8642-ce7dcf415691\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n2-000000046-002\n\n</td><td>\n\ntrue\n\n</td><td>\n\n2024.09.24 13:52:37.746\n\n</td><td>\n\n2024.09.24 13:52:37.746\n\n</td><td>\n\n2024.09.24 13:52:37.816\n\n</td><td>\n\n</td></tr><tr><td>\n\n/home/dolphindb/server/local8848/storage\n\n</td><td>\n\n1\n\n</td><td>\n\nac872f06-abed-339c-8642-ce7dcf415691\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n1-000000046-001\n\n</td><td>\n\ntrue\n\n</td><td>\n\n2024.09.24 13:52:32.431\n\n</td><td>\n\n2024.09.24 13:52:32.431\n\n</td><td>\n\n2024.09.24 13:52:32.437\n\n</td><td>\n\n</td></tr><tr><td>\n\n/home/dolphindb/server/local8848/storage\n\n</td><td>\n\n0\n\n</td><td>\n\nac872f06-abed-339c-8642-ce7dcf415691\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000046-000\n\n</td><td>\n\ntrue\n\n</td><td>\n\n2024.09.24 11:58:42.006\n\n</td><td>\n\n2024.09.24 11:58:42.006\n\n</td><td>\n\n2024.09.24 11:58:42.011\n\n</td><td>\n\n</td></tr><tr><td>\n\n/home/dolphindb/server/local8848/storage\n\n</td><td>\n\n0\n\n</td><td>\n\n62ab7ebb-03f2-10a5-5445-c537512aee06\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000045-000\n\n</td><td>\n\ntrue\n\n</td><td>\n\n2024.09.24 11:57:13.596\n\n</td><td>\n\n2024.09.24 11:57:13.596\n\n</td><td>\n\n2024.09.24 11:57:13.601\n\n</td><td>\n\n</td></tr></tbody>\n</table>\n"
    },
    "getPKEYMetaData": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getpkeymetadata.html",
        "signatures": [
            {
                "full": "getPKEYMetaData()",
                "name": "getPKEYMetaData",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getPKEYMetaData](https://docs.dolphindb.cn/zh/funcs/g/getpkeymetadata.html)\n\n\n\n#### 语法\n\ngetPKEYMetaData()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取 PKEY 引擎下所有 chunk 的元数据。该函数只能在数据节点上执行。\n\n返回一个表，包含以下列:\n\n* chunkId：chunk 的唯一标识\n\n* chunkPath：分区的物理路径\n\n* level：数据文件所在的 level 级别\n\n* table：数据表名称\n\n* files：数据文件名称，即 level file 名称\n\n#### 例子\n\n```\ngetPKEYMetaData()\n```\n\n<table id=\"table_szt_rll_cdc\"><thead><tr><th>\n\nchunkId\n\n</th><th>\n\nchunkPath\n\n</th><th>\n\nlevel\n\n</th><th>\n\ntable\n\n</th><th>\n\nfiles\n\n</th></tr></thead><tbody><tr><td>\n\na0a7b031-15b8-32be-664b-21b156dc94c0\n\n</td><td>\n\n/home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200102/Key94/1B8\n\n</td><td>\n\n0\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000006-000\n\n</td></tr><tr><td>\n\nb3307046-77cb-bbb4-2244-dc4dcdd4c4e2\n\n</td><td>\n\n/home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200104/Key39/1B8\n\n</td><td>\n\n0\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000009-000\n\n</td></tr><tr><td>\n\n1b47193f-39a4-8b93-3f44-d1b32b892126\n\n</td><td>\n\n/home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200105/Key94/1B8\n\n</td><td>\n\n0\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000007-000\n\n</td></tr><tr><td>\n\n65ac20af-e1ea-21a6-254a-0c7a1f4a1bcf\n\n</td><td>\n\n/home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200102/Key39/1B8\n\n</td><td>\n\n0\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000003-000\n\n</td></tr><tr><td>\n\n600e024e-e280-62bb-084d-b440f7ccc349\n\n</td><td>\n\n/home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200101/Key94/1B8\n\n</td><td>\n\n0\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000002-000\n\n</td></tr><tr><td>\n\n4f33838b-1b90-3f84-6943-e0da5fda3e10\n\n</td><td>\n\n/home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200104/Key94/1B8\n\n</td><td>\n\n0\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000005-000\n\n</td></tr><tr><td>\n\ne625607d-03ce-00bc-ab47-a419ae5af3f3\n\n</td><td>\n\n/home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200103/Key94/1B8\n\n</td><td>\n\n0\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000004-000\n\n</td></tr><tr><td>\n\n9e0004ea-33b5-b2b4-d947-065c9333709f\n\n</td><td>\n\n/home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200101/Key39/1B8\n\n</td><td>\n\n0\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000001-000\n\n</td></tr><tr><td>\n\n595d1703-88b4-4397-4b46-281eb8014251\n\n</td><td>\n\n/home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200103/Key39/1B8\n\n</td><td>\n\n0\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000008-000\n\n</td></tr><tr><td>\n\n280b3b44-8006-52a8-694e-1133e8740c07\n\n</td><td>\n\n/home/dolphindb/server/local8848/storage/CHUNKS/test\\_pkey/20200105/Key39/1B8\n\n</td><td>\n\n0\n\n</td><td>\n\npt1\\_2\n\n</td><td>\n\n0-000000010-000\n\n</td></tr></tbody>\n</table>\n"
    },
    "getPrefetchComputeNodeData": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getprefetchcomputenodedata.html",
        "signatures": [
            {
                "full": "getPrefetchComputeNodeData()",
                "name": "getPrefetchComputeNodeData",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getPrefetchComputeNodeData](https://docs.dolphindb.cn/zh/funcs/g/getprefetchcomputenodedata.html)\n\n\n\n#### 语法\n\ngetPrefetchComputeNodeData()\n\n#### 参数\n\n无\n\n#### 详情\n\n当前节点下配置项 *enableComputeNodePrefetchData* 的生效值。\n\n\\*\\*返回值：\\*\\*布尔标量。\n\n#### 例子\n\n```\ngetPrefetchComputeNodeData() \n\n// output: false\n```\n\n相关函数：[setPrefetchComputeNodeData](https://docs.dolphindb.cn/zh/funcs/s/setprefetchcomputenodedata.html)\n"
    },
    "getQueryStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getQueryStatus.html",
        "signatures": [
            {
                "full": "getQueryStatus()",
                "name": "getQueryStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getQueryStatus](https://docs.dolphindb.cn/zh/funcs/g/getQueryStatus.html)\n\n\n\n#### 语法\n\ngetQueryStatus()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取由当前节点发起且正在执行的查询任务状态，返回一个表对象，包含以下几列：\n\n* id：表示到该查询任务为止，系统已执行的查询任务总数。\n\n* sessionId：任务发起会话的 id。请注意，无法获取通过 `submitJob` 提交的查询任务的 sessionId。\n\n* userId：任务发起会话的用户名。\n\n* query：原始查询语句中主要的查询信息。\n\n* startTime：查询任务开始的时间戳。\n\n* elapsedTimeInMs：查询任务已经经过的时间，单位为毫秒。\n\n* memoryUsage：查询过程中变量和结果所占用的内存空间，单位为字节。\n\n* totalTaskCount：查询子任务总数。\n\n* completedTaskCount：已完成的查询子任务数。\n\n* percentComplete：已完成的查询子任务占比。\n\n该函数只能在任务发起节点上调用。\n\n#### 例子\n\n```\ngetQueryStatus();\n```\n\n| id | sessionId  | userId | query                        | startTime               | elapsedTimeInMs | memoryUsage | totalTaskCount | completedTaskCount | percentComplete |\n| -- | ---------- | ------ | ---------------------------- | ----------------------- | --------------- | ----------- | -------------- | ------------------ | --------------- |\n| 2  | 1166953221 | admin  | select ticker, id, x from pt | 2022.06.14 08:15:00.606 | 1052            | 184550000   | 4              | 1                  | 0.25            |\n"
    },
    "getRaftElectionTick": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getRaftElectionTick.html",
        "signatures": [
            {
                "full": "getRaftElectionTick(groupId)",
                "name": "getRaftElectionTick",
                "parameters": [
                    {
                        "full": "groupId",
                        "name": "groupId"
                    }
                ]
            }
        ],
        "markdown": "### [getRaftElectionTick](https://docs.dolphindb.cn/zh/funcs/g/getRaftElectionTick.html)\n\n\n\n#### 语法\n\ngetRaftElectionTick(groupId)\n\n#### 参数\n\n**groupId** 是一个正整数，表示 raft 组的 ID，目前只能是1，表示控制节点组成的 raft 组 ID。\n\n#### 详情\n\n获取 group ID 对应的 raft 组当前有效的 election tick，即通过 `setRaftElectionTick` 设置的 *tickCount* 或配置项 *raftElectionTick* 的设置值。\n\n相关函数： [setRaftElectionTick](https://docs.dolphindb.cn/zh/funcs/s/setRaftElectionTick.html), [getControllerElectionTick](https://docs.dolphindb.cn/zh/funcs/g/getControllerElectionTick.html)\n"
    },
    "getReactiveMetrics": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getreactivemetrics.html",
        "signatures": [
            {
                "full": "getReactiveMetrics(name)",
                "name": "getReactiveMetrics",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [getReactiveMetrics](https://docs.dolphindb.cn/zh/funcs/g/getreactivemetrics.html)\n\n\n\n#### 语法\n\ngetReactiveMetrics(name)\n\n##### 参数\n\n**name** 字符串，表示 narrowReactiveStateEngine 的名称。\n\n##### 详情\n\n获取指定名称的 narrowReactiveStateEngine 的计算指标列。\n\n返回一个表，第一列为 metricName，第二列为 metricCode。\n\n##### 例子\n\n```\ndummy = streamTable(1:0, [\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"upToDatePrice\",\"qty\",\"value\"], [STRING,STRING,STRING,TIMESTAMP,TIMESTAMP,DOUBLE,DOUBLE,INT]) \noutputTable = streamTable(1:0,[\"securityID1\",\"securityID2\",\"securityID3\",\"createTime\",\"updateTime\",\"metricNames\",\"factorValue\"], [STRING,STRING,STRING, TIMESTAMP,TIMESTAMP,STRING,DOUBLE])\nfactor = [<createTime>, <updateTime>,<cumsum(qty)>]\nNarrowtest = createNarrowReactiveStateEngine(name=\"narrowtest1\",metrics=factor,metricNames=\"factor1\",dummyTable=dummy,outputTable=outputTable,keyColumn=[\"securityID1\",\"securityID2\",\"securityID3\"])\ngetReactiveMetrics(\"narrowtest1\")\n```\n\n| metricName | metricCode  |\n| ---------- | ----------- |\n| factor1    | cumsum(qty) |\n\n相关函数：[createNarrowReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createnarrowreactivestateengine.html)，[addReactiveMetrics](https://docs.dolphindb.cn/zh/funcs/a/addreactivemetrics.html)\n"
    },
    "getRecentJobs": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getRecentJobs.html",
        "signatures": [
            {
                "full": "getRecentJobs([n])",
                "name": "getRecentJobs",
                "parameters": [
                    {
                        "full": "[n]",
                        "name": "n",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getRecentJobs](https://docs.dolphindb.cn/zh/funcs/g/getRecentJobs.html)\n\n\n\n#### 语法\n\ngetRecentJobs(\\[n])\n\n#### 参数\n\n**n** 是一个可选参数，为正整数。 无参数时返回所有 Jobs。\n\n#### 详情\n\n取得本地节点上最近 *n* 个批处理作业的状态。\n\n返回一个表，包含以下字段：\n\n| 参数           | 含义                      |\n| ------------ | ----------------------- |\n| node         | 本地节点的别名。                |\n| userID       | 提交作业任务的用户 ID。           |\n| jobId        | 在提交批作业时指定的作业名。          |\n| rootJobId    | 系统中作业的唯一标识。             |\n| jobDesc      | 用于描述作业的字符串。             |\n| priority     | 作业的优先级，为 0-9 之间的整数。     |\n| parallelism  | 作业的并行度，即分配给该作业的线程数上限。   |\n| clientIp     | 发起作业任务的客户端 IP。          |\n| clientPort   | 发起作业任务的客户端端口号。          |\n| receivedTime | 作业接收的时间，为 TIMESTAMP 类型。 |\n| startTime    | 作业开始时间，为 TIMESTAMP 类型。  |\n| endTime      | 作业结束时间，为 TIMESTAMP 类型。  |\n| errorMsg     | 报错信息。                   |\n\n详情参考：[BatchJobManagement](https://docs.dolphindb.cn/zh/sys_man/BatchJobManagement.html)。\n\n#### 例子\n\n```\ndef jobDemo(n){\n   s = 0\n   for (x in 1 : n) {\n       s += sum(sin rand(1.0, 100000000)-0.5)\n       print(\"iteration \" + x + \" \" + s)\n   }\n   return s\n};\n\nsubmitJob(\"jobDemo1\",\"job demo\", jobDemo, 100);\nsubmitJob(\"jobDemo2\",, jobDemo, 10);\ngetRecentJobs(10);\n```\n\n| node      | userID | jobId    | rootJobId                            | jobDesc  | priority | parallelism | clientIp  | clientPort | receivedTime            | startTime | endTime | errorMsg |\n| --------- | ------ | -------- | ------------------------------------ | -------- | -------- | ----------- | --------- | ---------- | ----------------------- | --------- | ------- | -------- |\n| local8848 | admin  | jobDemo1 | 859c3c53-c9ad-1abc-41f5-6dbaaf8003e9 | job demo | 0        | 1           | 127.0.0.1 | 61,436     | 2024.02.29 10:18:07.160 |           |         |          |\n| local8848 | admin  | jobDemo2 | 5515626b-0dd9-e7ac-466c-d8b4d1fff2d1 | jobDemo  | 0        | 1           | 127.0.0.1 | 61,436     | 2024.02.29 10:18:07.164 |           |         |          |\n"
    },
    "getRecentSlaveReplicationInfo": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getRecentSlaveReplicationInfo.html",
        "signatures": [
            {
                "full": "getRecentSlaveReplicationInfo()",
                "name": "getRecentSlaveReplicationInfo",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getRecentSlaveReplicationInfo](https://docs.dolphindb.cn/zh/funcs/g/getRecentSlaveReplicationInfo.html)\n\n\n\n#### 语法\n\ngetRecentSlaveReplicationInfo()\n\n#### 参数\n\n无\n\n#### 详情\n\n查看跨集群异步复制进程中，连接到主集群的各从集群最近一次的任务状态。该函数只能由管理员在主集群的控制节点调用。\n\n返回一个表对象，包含以下字段：\n\n* connectedController：从集群的 controller 的 ip:port。\n\n* allControllersInRaft：若从集群为高可用集群，则将显示 raft 组所有控制节点的 ip:port。\n\n* lastFinishedTaskId：最近一次执行完成的异步复制任务 id。\n\n* lastPullTime：从集群最近一次连接到主集群拉取异步复制任务的时间。\n\n#### 例子\n\n```\ngetRecentSlaveReplicationInfo()\n```\n\n输出返回：\n\n| connectedController | allControllersInRaft                               | lastFinishedTaskId | lastPullTime        |\n| ------------------- | -------------------------------------------------- | ------------------ | ------------------- |\n| 192.168.2.2:1111    | 192.168.2.2:1111,192.168.2.2:1112,192.168.2.2:1113 | 233                | 2022.11.11T11:11:11 |\n"
    },
    "getRecoveryTaskStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getRecoveryTaskStatus.html",
        "signatures": [
            {
                "full": "getRecoveryTaskStatus()",
                "name": "getRecoveryTaskStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getRecoveryTaskStatus](https://docs.dolphindb.cn/zh/funcs/g/getRecoveryTaskStatus.html)\n\n\n\n#### 语法\n\ngetRecoveryTaskStatus()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回副本恢复任务的状态。该函数只能在控制节点上执行。\n\n返回一个表，包含以下列：\n\n* TaskId：表示恢复副本任务的 ID。\n\n* TaskType：恢复任务的类型，包括 LoadRebalance 和 ChunkRecovery 。\n\n* ChunkId：分区的 ID。\n\n* ChunkPath：分区的 DFS 路径。\n\n* Source：恢复数据的源节点，即正常的数据节点。\n\n* Dest：需要进行数据恢复的节点(目的节点)。\n\n* Status：数据恢复的状态，包括 “Waiting”, “In-Progress”, “Finished”, “Aborted”。\n\n* AttemptCount：恢复任务尝试的次数。\n\n* DeleteSource：是否删除源节点的数据。当 TaskType 是 ChunkRecovery 时，只能返回 false；当 TaskType 是 LoadRebalance 时，可以返回 true 或 false。\n\n* StartTime：创建恢复任务的时间。\n\n* LastDequeueTime：任务最后一次从任务队列出队的时间。\n\n* LastStartTime：最后一次开始执行任务的时间。\n\n* FinishTime：任务结束的时间。\n\n* IsIncrementalRecovery：是否启用增量复制。\n\n* IsAsyncRecovery：是否启用异步复制。\n\n* ChangeFromIncrementalToFull：是否从增量恢复转为全量恢复。系统多次尝试增量恢复失败会自动转换成全量恢复。\n\n* ChangeToSyncTime：节点在线恢复时，从异步恢复阶段转为同步恢复阶段的时刻。\n\n* FailureReason：recovery 任务失败的原因。\n\n#### 例子\n\n```\ngetRecoveryTaskStatus();\n```\n"
    },
    "getRecoveryWorkerNum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getRecoveryWorkerNum.html",
        "signatures": [
            {
                "full": "getRecoveryWorkerNum()",
                "name": "getRecoveryWorkerNum",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getRecoveryWorkerNum](https://docs.dolphindb.cn/zh/funcs/g/getRecoveryWorkerNum.html)\n\n\n\n#### 语法\n\ngetRecoveryWorkerNum()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取当前节点用于 chunk 恢复的工作线程数。\n\n#### 例子\n\n```\nresetRecoveryWorkerNum(2)\ngetRecoveryWorkerNum()\n// output\n2\n```\n\n相关函数：[resetRecoveryWorkerNum](https://docs.dolphindb.cn/zh/funcs/r/resetRecoveryWorkerNum.html)\n"
    },
    "getRedoLogGCStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getRedoLogGCStat.html",
        "signatures": [
            {
                "full": "getRedoLogGCStat()",
                "name": "getRedoLogGCStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getRedoLogGCStat](https://docs.dolphindb.cn/zh/funcs/g/getRedoLogGCStat.html)\n\n\n\n#### 语法\n\ngetRedoLogGCStat()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取 redo log 垃圾回收的状态。返回一个表对象，包含以下几列：\n\n* physicalName：物理表名，格式为 \"/数据库名/物理表名\"\n\n* txnCount：redo log 尚未回收的事务数\n\n* numOfTxnPendingGC：等待回收的事务数\n\n* minTidPendingGC：等待回收的事务的最小 tid\n\n* numOfTxnPendingFlush：等待刷盘的事务数\n\n* minTidPendingFlush：等待刷盘的事务的最小 tid\n\n#### 例子\n\n```\ngetRedoLogGCStat();\n```\n\n| physicalName  | txnCount | numOfTxnPendingGC | minTidPendingGC | numOfTxnPendingFlush | minTidPendingFlush |\n| ------------- | -------- | ----------------- | --------------- | -------------------- | ------------------ |\n| /test/pt\\_2   | 2        | 0                 |                 | 2                    | 1031               |\n| /listdb/pt\\_2 | 1        | 1                 | 1033            | 0                    |                    |\n"
    },
    "getRightStream": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getRightStream.html",
        "signatures": [
            {
                "full": "getRightStream(joinEngine)",
                "name": "getRightStream",
                "parameters": [
                    {
                        "full": "joinEngine",
                        "name": "joinEngine"
                    }
                ]
            }
        ],
        "markdown": "### [getRightStream](https://docs.dolphindb.cn/zh/funcs/g/getRightStream.html)\n\n\n\n#### 语法\n\ngetRightStream(joinEngine)\n\n#### 参数\n\n**joinEngine** 创建连接引擎返回的对象。目前 DolphinDB 支持的连接引擎有：\n\n* createAsofJoinEngine\n\n* createEquiJoinEngine\n\n* createLookupJoinEngine\n\n* createWindowJoinEngine\n\n* createLeftSemiJoinEngine\n\n#### 详情\n\n返回连接引擎右表的表结构对象。向该对象注入的数据，会注入到 *joinEngine* 中。\n\n通过该函数，可以将一个引擎的计算结果直接注入到连接引擎中，实现引擎间的级联。\n\n使用案例请参考 [getLeftStream](https://docs.dolphindb.cn/zh/funcs/g/getLeftStream.html)。\n"
    },
    "getRules": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getrules.html",
        "signatures": [
            {
                "full": "getRules([engineName])",
                "name": "getRules",
                "parameters": [
                    {
                        "full": "[engineName]",
                        "name": "engineName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getRules](https://docs.dolphindb.cn/zh/funcs/g/getrules.html)\n\n\n\n#### 语法\n\ngetRules(\\[engineName])\n\n#### 参数\n\n**engineName** 字符串向量，代表要查询的规则引擎的名称。该参数省略时，返回当前节点所有规则引擎的规则信息。\n\n#### 详情\n\n查询规则引擎的规则信息，包括规则集、规则检查策略和回调函数等。\n\n返回一个字典，key 为引擎的名称， value 为字典，包含以下信息：\n\n* ruleSets：该引擎的规则集。类型为一个字典，key 和 value 定义如下：\n\n  * key：规则集的键值。key 为 “Default” 指默认规则。\n\n  * value：规则集中该键值对应的规则。\n\n* policy：指定引擎的规则检查策略。\n\n* callback：指定引擎的回调函数的名称，未配置回调函数时为空字符串。\n\n#### 例子\n\n```\n// 设置规则集\nx = [1, 2, NULL]\ny = [ [ < value > 1 > ], [ < price < 2 >, < price > 6 > ], [ < value*price > 10 > ] ]\nruleSets = dict(x, y)\n\n// 创建规则引擎\nnames = `sym`value`price`quantity\ntypes = [INT, DOUBLE, DOUBLE, DOUBLE]\ndummy = table(1:0, names, types)\noutputNames = `sym`value`price`rule\noutputTypes = [INT, DOUBLE, DOUBLE, BOOL[]]\noutputTable = table(10:0, outputNames, outputTypes)\ntest = createRuleEngine(name=\"ruleEngineTest\", ruleSets=ruleSets, dummyTable=dummy, outputColumns=[\"sym\",\"value\",\"price\"], outputTable=outputTable, policy=\"all\", ruleSetColumn=\"sym\")\ntest2 = createRuleEngine(name=\"ruleEngineTest2\", ruleSets=ruleSets, dummyTable=dummy, outputColumns=[\"sym\",\"value\",\"price\"], outputTable=outputTable, policy=\"all\", ruleSetColumn=\"sym\")\n\n// 查询规则\ngetRules([\"ruleEngineTest\"])\n/*\nruleEngineTest->\n    ruleSets->\n        Default->(value * price > 10)\n        1->(value > 1)\n        2->(price < 2, price > 6)\n\n    policy->all\n    callback->\n*/\n\n// 更新规则\nupdateRule(\"ruleEngineTest\", 1, [<value > 2>])\n\n// 再次查询\ngetRules()\n/*\nruleEngineTest->\n    ruleSets->\n        Default->(value * price > 10)\n        1->(value > 2)\n        2->(price < 2, price > 6)\n\n    policy->all\n    callback->\n*/\n```\n\n相关函数：[createRuleEngine](https://docs.dolphindb.cn/zh/funcs/c/createRuleEngine.html), [updateRule](https://docs.dolphindb.cn/zh/funcs/u/updateRule.html), [deleteRule](https://docs.dolphindb.cn/zh/funcs/d/deleteRule.html)\n"
    },
    "getRunningQueries": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getRunningQueries.html",
        "signatures": [
            {
                "full": "getRunningQueries()",
                "name": "getRunningQueries",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getRunningQueries](https://docs.dolphindb.cn/zh/funcs/g/getRunningQueries.html)\n\n\n\n#### 语法\n\ngetRunningQueries()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取本地节点上正在执行的查询任务的描述信息。\n\n返回一张表，包含以下字段：\n\n| 参数        | 含义                                                                |\n| --------- | ----------------------------------------------------------------- |\n| userID    | 用户 ID 。                                                           |\n| sessionID | 发起查询的会话 ID。                                                       |\n| jobID     | 系统中查询任务的唯一标识。                                                     |\n| rootID    | 当前任务所属根任务的 jobID。                                                 |\n| level     | 任务的级别。根任务的 level 为 0，其分解的子任务 level 为 1，该子任务分解的子任务 level 为 2，以此类推。 |\n| startTime | 查询任务开始时间，为 NANOTIMESTAMP 类型。                                      |\n| endTime   | 查询任务结束时间，为 NANOTIMESTAMP 类型。                                      |\n| jobDesc   | 查询语句描述。                                                           |\n| errorMsg  | 报错信息。                                                             |\n| remoteIP  | 发起查询的客户端 IP。                                                      |\n\n使用该函数之前，必须设定参数 *perfMonitoring* = 1 来启用性能监控。\n\n#### 例子\n\n```\ngetRunningQueries();\n```\n\n| userID | sessionID | jobID                                | rootID                               | level | startTime                     | endTime | jobDesc                           | errorMsg | remoteIP      |\n| ------ | --------- | ------------------------------------ | ------------------------------------ | ----- | ----------------------------- | ------- | --------------------------------- | -------- | ------------- |\n| admin  | 738481026 | 88e738a8-a749-4dcb-9cfe-740df2d9ce7d | 88e738a8-a749-4dcb-9cfe-740df2d9ce7d | 0     | 2019.02.07T19:02:26.809905612 |         | select count(\\*) as count from pt |          | 192.168.1.106 |\n\n**Related information**\n\n[getCompletedQueries](https://docs.dolphindb.cn/zh/funcs/g/getCompletedQueries.html)\n"
    },
    "getScheduledJobs": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getScheduledJobs.html",
        "signatures": [
            {
                "full": "getScheduledJobs([jobIdPattern])",
                "name": "getScheduledJobs",
                "parameters": [
                    {
                        "full": "[jobIdPattern]",
                        "name": "jobIdPattern",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getScheduledJobs](https://docs.dolphindb.cn/zh/funcs/g/getScheduledJobs.html)\n\n\n\n#### 语法\n\ngetScheduledJobs(\\[jobIdPattern])\n\n#### 参数\n\n**jobIdPattern** 是表示任务 ID 或任务 ID 模式的字符串。它支持通配符“%”和“?”。\n\n#### 详情\n\n以表格的形式返回定时任务。如果 *jobIdPattern* 没有指定，返回所有已有的定时作业。\n\n包含以下字段：\n\n| 参数            | 含义                                 |\n| ------------- | ---------------------------------- |\n| userId        | 用户 ID。                             |\n| jobId         | 在提交定时作业时指定的作业名。                    |\n| jobDesc       | 作业描述。                              |\n| startDate     | 定时作业的开始日期，为 DATE 类型。               |\n| endDate       | 定时作业的结束日期，为 DATE 类型。               |\n| frequency     | 定时作业的执行频率。                         |\n| scheduledTime | 定时作业的执行间隔，为 MINUTE 类型。             |\n| days          | frequency 为 'W' 或 'M' 时，执行定时任务的日期。 |\n\n#### 例子\n\n```\ngetScheduledJobs();\n```\n\n| userId | jobId   | jobDesc     | startDate  | endDate    | frequency | scheduleTime | days |\n| ------ | ------- | ----------- | ---------- | ---------- | --------- | ------------ | ---- |\n| root   | monthly | Monthly Job | 2018.01.01 | 2018.12.31 | M         | 17:00m       | 1    |\n| root   | weekly  | Weekly Job  | 2018.01.01 | 2018.12.31 | W         | 17:30m       | 2    |\n| root   | daily   | Daily Job   | 2018.01.01 | 2018.12.31 | D         | 18:00m       |      |\n"
    },
    "getSchemaByCatalog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getSchemaByCatalog.html",
        "signatures": [
            {
                "full": "getSchemaByCatalog(catalog)",
                "name": "getSchemaByCatalog",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    }
                ]
            }
        ],
        "markdown": "### [getSchemaByCatalog](https://docs.dolphindb.cn/zh/funcs/g/getSchemaByCatalog.html)\n\n\n\n#### 语法\n\ngetSchemaByCatalog(catalog)\n\n#### 参数\n\n**catalog** 字符串标量，表示 catalog 的名称。\n\n#### 详情\n\n检索指定 catalog 中的所有 schema。返回一个 Table，包含 schema 的名称（schema）和对应路径（dbUrl）。\n\n#### 例子\n\n```\ngetSchemaByCatalog(\"catalog1\")\n```\n\n返回：\n\n| schema  | dbUrl      |\n| ------- | ---------- |\n| schema1 | dfs\\://db1 |\n| schema2 | dfs\\://db2 |\n"
    },
    "getSessionMemoryStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getSessionMemoryStat.html",
        "signatures": [
            {
                "full": "getSessionMemoryStat()",
                "name": "getSessionMemoryStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getSessionMemoryStat](https://docs.dolphindb.cn/zh/funcs/g/getSessionMemoryStat.html)\n\n\n\n#### 语法\n\ngetSessionMemoryStat()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取当前节点所有连接会话的内存占用状态，返回一张表包含以下字段：\n\n* userId：用户 ID 或缓存类型的标识符（形如：\\_\\_xxx\\_\\_）。\n\n* sessionId：会话 ID。\n\n* memSize：会话所占用的内存，单位为字节。\n\n* remoteIP：发起会话的客户端的 IP。\n\n* remotePort：发起会话的客户端的端口号。\n\n* createTime：会话创建的时间，为 TIMESTAMP 类型。\n\n* lastActiveTime：会话最近一次执行脚本的时间戳。\n\n缓存类型说明:\n\n| 缓存类型                          | 含义                                |\n| ----------------------------- | --------------------------------- |\n| \\_\\_DimensionalTable\\_\\_      | 维度表缓存，单位为字节。                      |\n| \\_\\_SharedTable\\_\\_           | 共享表缓存，单位为字节。                      |\n| \\_\\_OLAPTablet\\_\\_            | OLAP 引擎数据库表的缓存，单位为字节。             |\n| \\_\\_OLAPCacheEngine \\_\\_      | OLAP 引擎 Cache Engine 的内存占用，单位为字节。 |\n| \\_\\_OLAPCachedSymbolBase\\_\\_  | OLAP 引擎 SYMBOL 类型字典编码的缓存，单位为字节。   |\n| \\_\\_DFSMetadata\\_\\_           | 分布式存储的元数据内存占用情况，单位为字节。            |\n| \\_\\_TSDBCacheEngine\\_\\_       | TSDB 引擎 Cache Engine 的内存占用，单位为字节。 |\n| \\_\\_TSDBLevelFileIndex\\_\\_    | TSDB 引擎 level file 索引的缓存，单位为字节。   |\n| \\_\\_TSDBCachedSymbolBase\\_\\_  | TSDB 引擎 SYMBOL 类型字典编码的缓存，单位为字节。   |\n| \\_\\_StreamingPubQueue\\_\\_     | 流数据发布队列里未处理的消息数。                  |\n| \\_\\_StreamingSubQueue\\_\\_     | 流数据订阅队列里未处理的消息数。                  |\n| \\_\\_IOTDBStaticTableCache\\_\\_ | 静态表缓存，单位为字节。                      |\n| \\_\\_IOTDBLatestKeyCache\\_\\_   | 最新值表缓存，单位为字节。                     |\n\n**Note:**\n\n* 此函数无法统计到会话中正在执行的任务所占用的内存情况。\n\n* 对于返回表中的 createTime 和 lastActiveTime，2.00.9.4 之前版本的 DolphinDB，返回零时区时间；2.00.9.4 及之后版本的 DolphinDB，返回当前时区的时间。\n\n#### 例子\n\n```\nt = getSessionMemoryStat();\nt;\n```\n\n| userId                     | sessionId  | memSize | remoteIP     | remotePort | createTime              | lastActiveTime          |\n| -------------------------- | ---------- | ------- | ------------ | ---------- | ----------------------- | ----------------------- |\n| \\_\\_DimensionalTable\\_\\_   |            | 0       | 0.0.0.0      |            |                         |                         |\n| \\_\\_SharedTable\\_\\_        |            | 0       | 0.0.0.0      |            |                         |                         |\n| \\_\\_OLAPTablet\\_\\_         |            | 0       | 0.0.0.0      |            |                         |                         |\n| \\_\\_OLAPCacheEngine\\_\\_    |            | 0       | 0.0.0.0      |            |                         |                         |\n| \\_\\_OLAPCachedSymbolBa...  |            | 0       | 0.0.0.0      |            |                         |                         |\n| \\_\\_DFSMetadata\\_\\_        |            | 2769    | 0.0.0.0      |            |                         |                         |\n| \\_\\_TSDBCacheEngine\\_\\_    |            | 0       | 0.0.0.0      |            |                         |                         |\n| \\_\\_TSDBLevelFileIndex\\_\\_ |            | 0       | 0.0.0.0      |            |                         |                         |\n| \\_\\_TSDBCachedSymbolBa...  |            | 0       | 0.0.0.0      |            |                         |                         |\n| \\_\\_StreamingPubQueue\\_\\_  |            | 0       | 0.0.0.0      |            |                         |                         |\n| \\_\\_StreamingSubQueue\\_\\_  |            | 0       | 0.0.0.0      |            |                         |                         |\n| admin                      | 2882591513 | 1416    | 60.176.105.0 | 20861      | 2023.02.15T02:15:22.384 | 2023.02.15T02:24:16.307 |\n"
    },
    "getSlaveReplicationQueueStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getslavereplicationqueuestatus.html",
        "signatures": [
            {
                "full": "getSlaveReplicationQueueStatus()",
                "name": "getSlaveReplicationQueueStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getSlaveReplicationQueueStatus](https://docs.dolphindb.cn/zh/funcs/g/getslavereplicationqueuestatus.html)\n\n#### 语法\n\ngetSlaveReplicationQueueStatus()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取从集群每个执行队列的任务执行状态。该函数只能由管理员在从集群的控制节点调用。\n\n返回一个表，包含以下字段：\n\n* executionSet：任务所属的执行集ID。\n\n* queueId：任务所属队列的编号。\n\n* unifinishedTasks：队列中未执行的任务数量。\n\n* executionGroupId：正在执行任务所属的组号。\n\n* executionNode：执行该 group 的数据节点别名。\n\n* executionTime：当前 group 已经执行的时间。\n\n* status：任务执行状态，包含四种类型： EXECUTING（正在执行）、FAILED（执行失败）、STOPPED（停止执行）、FINISHED（执行完成）\n\n#### 例子\n\n```\ngetSlaveReplicationQueueStatus()\n```\n\n输出返回：\n\n| executionSet | queueId | unfinishedTasks | executionGroupId | executionNode | executionTime | status   |\n| ------------ | ------- | --------------- | ---------------- | ------------- | ------------- | -------- |\n| 0            | 0       | 0               | -1               | dnode1        | 00:00:00.000  | FINISHED |\n| 0            | 1       | 0               | -1               | dnode2        | 00:00:00.000  | FINISHED |\n| 0            | 2       | 0               | -1               | dnode3        | 00:00:00.000  | FINISHED |\n| 1            | 3       | 0               | -1               | dnode1        | 00:00:00.000  | FINISHED |\n| 1            | 4       | 0               | -1               | dnode2        | 00:00:00.000  | FINISHED |\n| 1            | 5       | 0               | -1               | dnode3        | 00:00:00.000  | FINISHED |\n\n"
    },
    "getSlaveReplicationStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getSlaveReplicationStatus.html",
        "signatures": [
            {
                "full": "getSlaveReplicationStatus([limit=-1])",
                "name": "getSlaveReplicationStatus",
                "parameters": [
                    {
                        "full": "[limit=-1]",
                        "name": "limit",
                        "optional": true,
                        "default": "-1"
                    }
                ]
            }
        ],
        "markdown": "### [getSlaveReplicationStatus](https://docs.dolphindb.cn/zh/funcs/g/getSlaveReplicationStatus.html)\n\n\n\n#### 语法\n\ngetSlaveReplicationStatus(\\[limit=-1])\n\n#### 参数\n\n**limit** 一个整数，表示结果中最多可返回的任务数量。\n\n#### 详情\n\n由管理员在从集群的控制节点调用，获取从集群的异步复制状态。若通过 slaveReplicationDBScope 指定了回放数据库的范围，则仅获取该范围内的异步复制情况。其中，已完成的任务排列在前面，未完成的任务排列在后面。\n\n* 如果未指定 *limit*，则返回的任务数量不受限制。\n\n* 如果指定 *limit*，则返回最多 *limit* 个任务列表。\n\n其中，已完成的任务最多显示最近的1万条记录；而未完成的任务只显示从最早时间开始，直到满足指定条数的记录。\n\n\\*\\*返回值：\\*\\*返回一个表，包含以下字段：\n\n* taskId：异步复制任务 id。\n\n* masterTid：该任务对应主集群中的事务 id。\n\n* groupId：异步复制任务所属的组。\n\n* executionSet：任务所属的执行集ID。\n\n* queueId：任务所属执行队列的编号。\n\n* operationType：任务类型，参照异步复制支持性表。\n\n* createTime：从集群从主集群获取任务的时间，类型为 NANOTIMESTAMP。\n\n* dbName：任务对应的数据库的路径。\n\n* tableName：任务对应的表名。\n\n* srcIP：存储写任务数据的数据节点 ip。\n\n* srcPort：存储写任务数据的数据节点 port。\n\n* finishTime：任务的完成时间，类型为 NANOTIMESTAMP。\n\n* executionNode：执行该任务的从集群的数据节点别名。\n\n* state：任务执行状态，包含四种类型： WAITING（等待执行）、EXECUTING（正在执行）、FINISHED（执行完成/任务skip）、FAILED（执行失败）。\n\n* details：补充说明。若 state = FAILED，则该列为执行失败的原因；若 state = FINISHED，该列用于对该任务进行补充说明。\n\n#### 例子\n\n```\ngetSlaveReplicationStatus();\n```\n\n输出返回：\n\n| taskId | masterTid | groupId | queueId | operationType              | createTime                    | dbName                          | tableName | srcIP     | srcPort | finishTime                    | executionNode | state    | details |\n| ------ | --------- | ------- | ------- | -------------------------- | ----------------------------- | ------------------------------- | --------- | --------- | ------- | ----------------------------- | ------------- | -------- | ------- |\n| 1      | 1         | 1       | 0       | CREATE\\_DOMAIN             | 2022.11.08T10:50:37.425056956 | db://test\\_dropPartition\\_value |           | localhost | 8002    | 2022.11.08T10:50:37.452792885 | NODE2         | FINISHED |         |\n| 2      | 2         | 2       | 1       | CREATE\\_PARTITIONED\\_TABLE | 2022.11.08T10:50:37.425056988 | db://test\\_dropPartition\\_value | pt        | localhost | 8002    | 2022.11.08T10:50:37.479906033 | NODE3         | FINISHED |         |\n| 3      | 3         | 3       | 2       | APPEND                     | 2022.11.08T10:50:37.425057012 | db://test\\_dropPartition\\_value | pt        | localhost | 8002    | 2022.11.08T10:50:37.638746819 | NODE1         | FINISHED |         |\n| 4      | 4         | 4       | 3       | DROP\\_PARTITION            | 2022.11.08T10:50:37.425057037 |                                 | pt        | localhost | 8002    | 2022.11.08T10:50:37.869783336 | NODE2         | FINISHED |         |\n\n相关函数：[getMasterReplicationStatus](https://docs.dolphindb.cn/zh/funcs/g/getMasterReplicationStatus.html), [getSlaveReplicationQueueStatus](https://docs.dolphindb.cn/zh/funcs/g/getslavereplicationqueuestatus.html)\n"
    },
    "getSnapshotMsgId": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getSnapshotMsgId.html",
        "signatures": [
            {
                "full": "getSnapshotMsgId(engine)",
                "name": "getSnapshotMsgId",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    }
                ]
            }
        ],
        "markdown": "### [getSnapshotMsgId](https://docs.dolphindb.cn/zh/funcs/g/getSnapshotMsgId.html)\n\n\n\n#### 语法\n\ngetSnapshotMsgId(engine)\n\n#### 参数\n\n**engine** 是流数据引擎，即 [createReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createReactiveStateEngine.html) 等函数返回的抽象表对象。\n\n#### 详情\n\n用于订阅断开后重新订阅时，获取指定流数据引擎的最近一个快照（snapshot）的 msgId。启用 snapshot 后，重订阅时，`subscribeTable` 函数的 *offset* 参数设置为 getSnapshotMsgId(engine)+1，引擎会加载 snapshot，并从 getSnapshotMsgId(engine) 之后一条消息开始重新订阅。\n"
    },
    "getStreamEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getStreamEngine.html",
        "signatures": [
            {
                "full": "getStreamEngine(name)",
                "name": "getStreamEngine",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    }
                ]
            }
        ],
        "markdown": "### [getStreamEngine](https://docs.dolphindb.cn/zh/funcs/g/getStreamEngine.html)\n\n\n\n#### 语法\n\ngetStreamEngine(name)\n\n#### 参数\n\n**name** 是一个字符串，表示流数据引擎的名称。它可以包含字母，数字和下划线，但必须以字母开头。\n\n#### 详情\n\n返回流数据引擎的句柄，可以作为 [subscribeTable](https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html) 函数的 *handler* 参数。\n\n#### 例子\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\noutputTable = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\ntradesAggregator = createTimeSeriesEngine(\"StreamAggregatorDemo\",3, 3, <[sum(qty)]>, trades, outputTable, `time, false,`sym, 50)\nsubscribeTable(, \"trades\", \"tradesAggregator\", 0, append!{tradesAggregator}, true)\n\ndef writeData(n){\n   timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n   symv =take(`A`B, n)\n   qtyv = take(1, n)\n   insert into trades values(timev, symv, qtyv)\n}\n\nwriteData(6);\nh = getStreamEngine(\"StreamAggregatorDemo\")\n```\n"
    },
    "getStreamEngineList": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getstreamenginelist.html",
        "signatures": [
            {
                "full": "getStreamEngineList()",
                "name": "getStreamEngineList",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getStreamEngineList](https://docs.dolphindb.cn/zh/funcs/g/getstreamenginelist.html)\n\n\n\n#### 语法\n\ngetStreamEngineList()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取当前节点上所有流计算引擎的信息。\n\n\\*\\*返回值：\\*\\*一个表，包含以下字段：\n\n* engineType：引擎的类型。\n\n* engineName：引擎的名称。\n\n* user：创建引擎的用户名。\n\n#### 例子\n\n假设在当前节点上，admin 用户已创建1个时序引擎和1个 window join 引擎，user1 用户已创建1个响应式状态引擎，则调用 `getStreamEngineList` 后返回可以所有已创建引擎的信息。\n\n```\ngetStreamEngineList()\n```\n\n| engineType           | engineName   | user  |\n| -------------------- | ------------ | ----- |\n| ReactiveStreamEngine | reactiveDemo | user1 |\n| WindowJoinEngine     | test1        | admin |\n| TimeSeriesEngine     | engine1      | admin |\n"
    },
    "getStreamEngineStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getStreamEngineStat.html",
        "signatures": [
            {
                "full": "getStreamEngineStat()",
                "name": "getStreamEngineStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getStreamEngineStat](https://docs.dolphindb.cn/zh/funcs/g/getStreamEngineStat.html)\n\n\n\n#### 语法\n\ngetStreamEngineStat()\n\n别名：getAggregatorStat\n\n#### 参数\n\n无\n\n#### 详情\n\n返回流数据引擎的状态。返回一个字典，包含以下表：\n\n* 表 TimeSeriesEngine 返回时间序列引擎的状态。它包含以下列：\n\n| 列名                | 含义                              |\n| ----------------- | ------------------------------- |\n| name              | 时间序列引擎的名称                       |\n| user              | 创建时间序列引擎的用户名                    |\n| status            | 时间序列引擎的状态，\"OK\"表示可用，\"FATAL\"表示不可用 |\n| lastErrMsg        | 最后一条错误信息                        |\n| windowTime        | 窗口的长度                           |\n| step              | 计算的时间间隔                         |\n| useSystemTime     | 时间序列引擎中 useSystemTime 参数值       |\n| garbageSize       | 触发内存清理的阈值                       |\n| numGroups         | 时间序列引擎中的分组数                     |\n| numRows           | 时间序列引擎中的记录行数                    |\n| numMetrics        | 时间序列引擎使用的聚合指标的数量                |\n| metrics           | 时间序列引擎使用的聚合指标的元代码               |\n| memoryUsed        | 时间序列引擎所占用内存量，单位为字节              |\n| snapshotDir       | 保存引擎快照的文件目录                     |\n| snapshotInterval  | 每隔多少条数据保存一次引擎快照                 |\n| snapshotMsgId     | 最后一个 snapshot 的 msgId           |\n| snapshotTimestamp | 引擎快照的时间戳                        |\n\n* 表 CrossSectionalEngine 返回横截面聚合引擎的状态。它包含以下列：\n\n| 列名                 | 含义                               |\n| ------------------ | -------------------------------- |\n| name               | 横截面引擎的名称                         |\n| user               | 创建横截面引擎的用户名                      |\n| status             | 横截面引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg         | 最后一条错误信息                         |\n| numRows            | 横截面引擎中的记录行数                      |\n| numMetrics         | 横截面引擎使用的聚合指标的数量                  |\n| metrics            | 横截面引擎使用的聚合指标的元代码                 |\n| triggeringPattern  | 横截面引擎触发计算的方式                     |\n| triggeringInterval | 横截面引擎触发计算的时间间隔                   |\n| memoryUsed         | 横截面引擎所占用内存量，单位为字节                |\n\n* 表 AnomalyDetectionEngine 返回异常检测引擎的状态。它包含以下列：\n\n| 列名               | 含义                                |\n| ---------------- | --------------------------------- |\n| name             | 异常检测引擎的名称                         |\n| user             | 创建异常检测引擎的用户名                      |\n| status           | 异常检测引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg       | 最后一条错误信息                          |\n| numGroups        | 异常检测引擎中的分组数                       |\n| numRows          | 异常检测引擎中的记录行数                      |\n| numMetrics       | 异常指标的数量                           |\n| metrics          | 异常指标的元代码                          |\n| snapshotDir      | 保存引擎快照的文件目录                       |\n| snapshotInterval | 每隔多少条数据保存一次引擎快照                   |\n| snapshotMsgId    | 最后一个 snapshot 的 msgId             |\n| snapshotTimestam | 引擎快照的时间戳                          |\n| garbageSize      | 触发内存清理的阈值                         |\n| memoryUsed       | 异常检测引擎所占用内存量，单位为字节                |\n\n* 表 ReactiveStreamEngine 返回响应式状态引擎的状态。它包含以下列：\n\n| 列名                | 含义                                 |\n| ----------------- | ---------------------------------- |\n| name              | 响应式状态引擎的名称                         |\n| user              | 创建响应式状态引擎的用户名                      |\n| status            | 响应式状态引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                           |\n| numGroups         | 响应式状态引擎中的分组数                       |\n| numRows           | 响应式状态引擎中的记录行数                      |\n| numMetrics        | 指标的数量                              |\n| memoryUsed        | 响应式状态引擎所占用内存量，单位为字节                |\n| snapshotDir       | 保存引擎快照的文件目录                        |\n| snapshotInterval  | 每隔多少条数据保存一次引擎快照                    |\n| snapshotMsgId     | 最后一个 snapshot 的 msgId              |\n| snapshotTimestamp | 引擎快照的时间戳                           |\n\n* 表 SessionWindowEngine 返回会话窗口引擎的状态。它包含以下列：\n\n| 列名                | 含义                                |\n| ----------------- | --------------------------------- |\n| name              | 会话窗口引擎的名称                         |\n| user              | 创建会话窗口引擎的用户名                      |\n| status            | 会话窗口引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                          |\n| sessionGap        | 每个会话窗口之间的时间间隔                     |\n| useSystemTime     | 会话窗口聚合引擎计算的触发方式                   |\n| numGroups         | 会话窗口引擎中的分组数                       |\n| numRows           | 会话窗口引擎中的记录行数                      |\n| numMetrics        | 指标的数量                             |\n| Metrics           | 会话窗口聚合引擎使用的聚合指标的元代码               |\n| memoryUsed        | 会话窗口引擎所占用内存量，单位为字节                |\n| snapshotDir       | 会话窗口引擎快照保存的文件目录                   |\n| snapshotInterval  | 每隔多少条数据保存一次引擎快照                   |\n| snapshotMsgId     | 最后一个 snapshot 的 msgId             |\n| snapshotTimestamp | 触发保存快照的时间戳                        |\n\n* 表 DailyTimeSeriesEngine 返回日级时间序列引擎的状态。它包含以下列：\n\n| 列名                | 含义                                  |\n| ----------------- | ----------------------------------- |\n| name              | 日级时间序列引擎的名称                         |\n| user              | 创建日级时间序列引擎的用户名                      |\n| status            | 日级时间序列引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                            |\n| windowTime        | 数据窗口的长度                             |\n| step              | 计算的时间间隔                             |\n| useSystemTime     | 日级时间序列引擎中 useSystemTime 参数值         |\n| garbageSize       | 触发内存清理的阈值                           |\n| numGroups         | 日级时间序列引擎中的分组数                       |\n| numRows           | 日级时间序列引擎中的记录行数                      |\n| numMetrics        | 日级时间序列引擎使用的聚合指标的数量                  |\n| metrics           | 日级时间序列引擎使用的聚合指标的元代码                 |\n| memoryUsed        | 日级时间序列引擎所占用内存量，单位为字节                |\n| snapshotDir       | 日级时间序列聚合引擎快照保存的文件目录                 |\n| snapshotInterval  | 每隔多少条数据保存一次引擎快照                     |\n| snapshotMsgId     | 最后一个 snapshot 的 msgId               |\n| snapshotTimestamp | 触发保存快照的时间戳                          |\n\n* 表 TimeBucketEngine 返回时间序列分组引擎的状态。它包含以下列：\n\n| 列名         | 含义                                |\n| ---------- | --------------------------------- |\n| name       | 时间序列分组引擎的名称                       |\n| user       | 创建时间序列分组引擎的用户名                    |\n| status     | 时间序列分组引擎的状态，\"OK\"表示可用，\"FATAL\"表示不可用 |\n| lastErrMsg | 最后一条错误信息                          |\n| numGroups  | 时间序列分组引擎中的分组数                     |\n| numRows    | 时间序列分组引擎中的记录行数                    |\n| numMetrics | 时间序列分组引擎使用的聚合指标的数量                |\n| metrics    | 时间序列分组引擎使用的聚合指标的元代码               |\n| memoryUsed | 时间序列分组引擎所占用内存量，单位为字节              |\n\n* 表 AsofJoinEngine 返回 asof join 引擎的状态。它包含以下列：\n\n| 列名                | 含义                                      |\n| ----------------- | --------------------------------------- |\n| name              | asof join 引擎的名称                         |\n| user              | 创建 asof join 引擎的用户名                     |\n| status            | asof join 引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                                |\n| useSystemTime     | asof join 引擎中 useSystemTime 参数值         |\n| delayedTime       | asof join 引擎中 delayedTime 参数值           |\n| garbageSize       | 触发内存清理的阈值                               |\n| leftTableNumRows  | asof join 引擎左表中的记录行数                    |\n| rightTableNumRows | asof join 引擎右表中的记录行数                    |\n| numMetrics        | asof join 引擎使用的指标的数量                    |\n| metrics           | asof join 引擎使用的指标的元代码                   |\n| memoryUsed        | asof join 引擎所占用内存量，单位为字节                |\n\n* 表 EqualJoinEngine 返回等值连接引擎的状态。它包含以下列：\n\n| 列名                | 含义                                |\n| ----------------- | --------------------------------- |\n| name              | 等值连接引擎的名称                         |\n| user              | 创建等值连接引擎的用户名                      |\n| status            | 等值连接引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                          |\n| garbageSize       | 触发内存清理的阈值                         |\n| leftTableNumRows  | 等值连接引擎左表中的记录行数                    |\n| rightTableNumRows | 等值连接引擎右表中的记录行数                    |\n| numMetrics        | 等值连接引擎使用的指标的数量                    |\n| metrics           | 等值连接引擎使用的指标的元代码                   |\n| memoryUsed        | 等值连接引擎所占用内存量，单位为字节                |\n\n* 表 WindowJoinEngine 返回 window join 引擎的状态。它包含以下列：\n\n| 列名                | 含义                                        |\n| ----------------- | ----------------------------------------- |\n| name              | window join 引擎的名称                         |\n| user              | 创建 window join 引擎的用户名                     |\n| status            | window join 引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                                  |\n| garbageSize       | 触发内存清理的阈值                                 |\n| leftTableNumRows  | window join 引擎左表中的记录行数                    |\n| rightTableNumRows | window join 引擎右表中的记录行数                    |\n| numMetrics        | window join 引擎使用的指标的数量                    |\n| metrics           | window join 引擎使用的指标的元代码                   |\n| memoryUsed        | window join 引擎所占用内存量，单位为字节                |\n\n* 表 LookupJoinEngine 返回 lookup join 引擎的状态。它包含以下列：\n\n| 列名                | 含义                                        |\n| ----------------- | ----------------------------------------- |\n| name              | lookup join 引擎的名称                         |\n| user              | 创建 lookup join 引擎的用户名                     |\n| status            | lookup join 引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                                  |\n| leftTableNumRows  | lookup join 引擎左表中的记录行数                    |\n| rightTableNumRows | lookup join 引擎右表中的记录行数                    |\n| numMetrics        | lookup join 引擎使用的指标的数量                    |\n| metrics           | lookup join 引擎使用的指标的元代码                   |\n| memoryUsed        | lookup join 引擎所占用内存量，单位为字节                |\n\n* 表 LeftSemiJoinEngine 返回左半等值连接引擎的状态。它包含以下列：\n\n| 列名                | 含义                                  |\n| ----------------- | ----------------------------------- |\n| name              | 左半等值连接引擎的名称                         |\n| user              | 创建左半等值连接引擎的用户名                      |\n| status            | 左半等值连接引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                            |\n| garbageSize       | 触发内存清理的阈值                           |\n| leftTableNumRows  | 左半等值连接引擎左表中的记录行数                    |\n| rightTableNumRows | 左半等值连接引擎右表中的记录行数                    |\n| numMetrics        | 左半等值连接引擎使用的指标的数量                    |\n| metrics           | 左半等值连接引擎使用的指标的元代码                   |\n| memoryUsed        | 左半等值连接引擎所占用内存量，单位为字节                |\n\n* 表 StreamFilter 返回流数据过滤引擎的状态。它包含以下列：\n\n| 列名         | 含义                                 |\n| ---------- | ---------------------------------- |\n| name       | 流数据过滤引擎的名称                         |\n| user       | 创建流数据过滤引擎的用户名                      |\n| status     | 流数据过滤引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg | 最后一条错误信息                           |\n| numRows    | 流数据过滤引擎中的记录行数                      |\n| filters    | 流数据过滤引擎的过滤条件                       |\n\n* 表 StreamDispatchEngine 返回流数据分发引擎的状态。它包含以下列：\n\n| 列名         | 含义                            |\n| ---------- | ----------------------------- |\n| name       | 分发引擎的名称                       |\n| user       | 创建分发引擎的用户名                    |\n| status     | 分发引擎的状态，”OK”表示可用，”FATAL”表示不可用 |\n| lastErrMsg | 最后一条错误信息                      |\n| numRows    | 分发引擎中的记录行数                    |\n| memoryUsed | 分发引擎所占用内存量，单位为字节              |\n\n* 表 ReactiveStateEngine 返回响应式状态引擎的状态。它包含以下列：\n\n| 列名                         | 含义                                                |\n| -------------------------- | ------------------------------------------------- |\n| name                       | 响应式状态引擎的名称                                        |\n| metrics                    | 响应式状态引擎使用的计算公式的元代码                                |\n| dummyTable                 | 表对象，可以含有数据，亦可为空表                                  |\n| outputTable                | 计算结果的输出表，可以是内存表或分布式表                              |\n| keyColumn                  | 分组列名                                              |\n| filter                     | 过滤条件的元代码                                          |\n| snapshotDir                | 保存引擎快照的文件目录                                       |\n| snapshotIntervalInMsgCount | 每隔多少条数据保存一次流数据引擎快照                                |\n| keepOrder                  | 输出表数据是否按照输入时的顺序排序                                 |\n| keyPurgeFilter             | 清理条件的元代码                                          |\n| keyPurgeFreqInSecond       | 触发数据清理需要满足的时间间隔（以秒为单位）                            |\n| raftGroup                  | 流数据高可用订阅端 raft 组的 ID                              |\n| outputElapsedMicroseconds  | 是否输出每个 batch 中数据从注入引擎到计算输出的总耗时，以及每个 batch 包含的总记录数 |\n| keyCapacity                | 建表时系统为该表预分配的 key 分组数量                             |\n| parallelism                | 并行计算的工作线程数                                        |\n\n* 表 DualOwnershipReactiveStateEngine 返回 Dual Ownership Reactive State Engine 的状态。它包含以下列：\n\n| 列名                         | 含义                                                |\n| -------------------------- | ------------------------------------------------- |\n| name                       | Dual Ownership Reactive State Engine 的名称          |\n| metrics                    | Dual Ownership Reactive State Engine 使用的计算公式的元代码  |\n| dummyTable                 | 表对象，可以含有数据，亦可为空表                                  |\n| outputTable                | 计算结果的输出表，可以是内存表或分布式表                              |\n| keyColumn                  | 分组列名                                              |\n| filter                     | 过滤条件的元代码                                          |\n| snapshotDir                | 保存引擎快照的文件目录                                       |\n| snapshotIntervalInMsgCount | 每隔多少条数据保存一次流数据引擎快照                                |\n| keepOrder                  | 输出表数据是否按照输入时的顺序排序                                 |\n| keyPurgeFilter             | 清理条件的元代码                                          |\n| keyPurgeFreqInSecond       | 触发数据清理需要满足的时间间隔（以秒为单位）                            |\n| raftGroup                  | 流数据高可用订阅端 raft 组的 ID                              |\n| outputElapsedMicroseconds  | 是否输出每个 batch 中数据从注入引擎到计算输出的总耗时，以及每个 batch 包含的总记录数 |\n| keyCapacity                | 建表时系统为该表预分配的 key 分组数量                             |\n| parallelism                | 并行计算的工作线程数                                        |\n\n* 表 NarrowReactiveStateEngine 返回生成窄表的响应式状态引擎的状态。它包含以下列：\n\n| 列名                        | 含义                                                       |\n| ------------------------- | -------------------------------------------------------- |\n| name                      | 生成窄表的响应式状态引擎的名称                                          |\n| metrics                   | 需要输出到 *outputTable* 中的除 *keyColumn* 外的输入表中的列或计算指标，用元代码表示 |\n| metricNames               | 输出到 *outputTable*中的指标的名称                                 |\n| dummyTable                | 表对象，可以含有数据，亦可为空表                                         |\n| outputTable               | 计算结果的输出表，可以是内存表或分布式表                                     |\n| keyColumn                 | 分组列名                                                     |\n| filter                    | 过滤条件的元代码                                                 |\n| keepOrder                 | 输出表数据是否按照输入时的顺序排序                                        |\n| keyPurgeFilter            | 清理条件的元代码                                                 |\n| keyPurgeFreqInSecond      | 触发数据清理需要满足的时间间隔（以秒为单位）                                   |\n| outputElapsedMicroseconds | 是否输出每个 batch 中数据从注入引擎到计算输出的总耗时，以及每个 batch 包含的总记录数        |\n| keyCapacity               | 建表时系统为该表预分配的 key 分组数量                                    |\n| parallelism               | 并行计算的工作线程数                                               |\n\n* 表 SnapshotJoinEngine 返回快照连接引擎的状态。它包含以下列：\n\n| 列名                | 含义                                |\n| ----------------- | --------------------------------- |\n| name              | 快照连接引擎的名称                         |\n| user              | 创建快照连接引擎的用户名                      |\n| status            | 快照连接引擎的状态，\"OK\" 表示可用，\"FATAL\" 表示不可用 |\n| lastErrMsg        | 最后一条错误信息                          |\n| leftTableNumRows  | 快照连接引擎左表中的记录行数                    |\n| rightTableNumRows | 快照连接引擎右表中的记录行数                    |\n| numMetrics        | 快照连接引擎使用的指标的数量                    |\n| metrics           | 快照连接引擎使用的指标的元代码                   |\n| memoryUsed        | 快照连接引擎所占用内存量，单位为字节                |\n\n#### 例子\n\n```\nshare streamTable(10:0,`time`sym`price`qty,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades\noutputTable1 = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\noutputTable2 = table(1:0, `time`avgPrice`sumqty`Total, [TIMESTAMP,DOUBLE,INT,DOUBLE])\ntradesTsAggregator = createTimeSeriesEngine(name=\"TimeSeriesDemo\", windowSize=3, step=3, metrics=<[sum(qty)]>, dummyTable=trades, outputTable=outputTable1, timeColumn=`time, keyColumn=`sym, garbageSize=50)\ntradesCsAggregator=createCrossSectionalEngine(name=\"CrossSectionalDemo\", metrics=<[avg(price), sum(qty), sum(price*qty)]>, dummyTable=trades, outputTable=outputTable2, keyColumn=`sym, triggeringPattern=`perRow)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesTsAggregator\", offset=0, handler=append!{tradesTsAggregator}, msgAsTable=true)\nsubscribeTable(tableName=\"trades\", actionName=\"tradesCsAggregator\", offset=0, handler=append!{tradesCsAggregator}, msgAsTable=true)\n\ndef writeData(n){\n   timev = 2000.10.08T01:01:01.001 + timestamp(1..n)\n   symv =take(`A`B, n)\n   pricev=take(102.1 33.4 73.6 223,n)\n   qtyv = take(60 74 82 59, n)\n   insert into trades values(timev, symv, pricev,qtyv)\n}\n\nwriteData(4);\n\ngetStreamEngineStat().TimeSeriesEngine;\ngetStreamEngineStat().CrossSectionalEngine;\n```\n"
    },
    "getStreamingLeader": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getStreamingLeader.html",
        "signatures": [
            {
                "full": "getStreamingLeader(groupId)",
                "name": "getStreamingLeader",
                "parameters": [
                    {
                        "full": "groupId",
                        "name": "groupId"
                    }
                ]
            }
        ],
        "markdown": "### [getStreamingLeader](https://docs.dolphindb.cn/zh/funcs/g/getStreamingLeader.html)\n\n\n\n#### 语法\n\ngetStreamingLeader(groupId)\n\n#### 参数\n\n**groupId** 是一个整数，表示流数据 Raft 组的 ID\n\n#### 详情\n\n获取流数据 Raft 组中的 Leader。\n\n#### 例子\n\n```\ngetStreamingLeader(11);\n// output\n\nDFS_NODE2\n```\n"
    },
    "getStreamingRaftGroups": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getStreamingRaftGroups.html",
        "signatures": [
            {
                "full": "getStreamingRaftGroups()",
                "name": "getStreamingRaftGroups",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getStreamingRaftGroups](https://docs.dolphindb.cn/zh/funcs/g/getStreamingRaftGroups.html)\n\n\n\n#### 语法\n\ngetStreamingRaftGroups()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取当前节点所在的流数据 Raft 组的信息。返回的结果是一个表，第一列表示 Raft 组的 id，第二列表示 Raft 组包含的数据节点/计算节点信息。\n\n#### 例子\n\n```\ngetStreamingRaftGroups();\n```\n\n| id | sites                                                                         |\n| -- | ----------------------------------------------------------------------------- |\n| 12 | 192.168.1.135:18102:NODE1,192.168.1.135:18103:NODE2,192.168.1.135:18104:NODE3 |\n| 11 | 192.168.1.135:18102:NODE1,192.168.1.135:18103:NODE2,192.168.1.135:18105:NODE4 |\n\n使用以下脚本可以获取当前集群所有流数据 Raft 组的信息。\n\n```\nselect id,sites from pnodeRun(getStreamingRaftGroups) where isDuplicated([id,sites],FIRST)=false;\n```\n"
    },
    "getStreamingStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getStreamingStat.html",
        "signatures": [
            {
                "full": "getStreamingStat()",
                "name": "getStreamingStat",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getStreamingStat](https://docs.dolphindb.cn/zh/funcs/g/getStreamingStat.html)\n\n\n\n#### 语法\n\ngetStreamingStat()\n\n#### 参数\n\n无\n\n#### 详情\n\n监控流计算的状态。返回的结果是一个字典，包含以下表：\n\n* 表 pubConns 监控本地发布节点和它的所有订阅节点之间的连接状态。每一行表示一个订阅节点。它包含以下列：\n\n  | 列名              | 含义              |\n  | --------------- | --------------- |\n  | client          | 订阅节点的 IP 地址和端口号 |\n  | queueDepthLimit | 发布节点上的消息队列深度的上限 |\n  | queueDepth      | 发布节点上的当前消息队列深度  |\n  | tables          | 发布节点上所有的共享流数据表  |\n\n* 表 subConns 监控本地订阅节点和发布节点之间的连接状态。每一行表示一个发布节点。它包含以下列：\n\n  | 列名             | 含义            |\n  | -------------- | ------------- |\n  | publisher      | 发布节点的别名       |\n  | cumMsgCount    | 已经接收到的消息数量    |\n  | cumMsgLatency  | 所有已接收的消息的平均延迟 |\n  | LastMsgLatency | 最后接收到的消息的延迟   |\n  | lastUpdate     | 最后接收到消息的时间    |\n\n* 表 pubTables 监控流数据表状态。每一行表示一个流数据表的信息。它包含以下列：\n\n  | 列名         | 含义                   |\n  | ---------- | -------------------- |\n  | tableName  | 发布的流数据表名             |\n  | subscriber | 订阅端的 ip 和端口信息        |\n  | msgOffset  | 已经发布的最后一条数据在总数据中的偏移量 |\n  | actions    | 订阅任务的名称              |\n\n  上表中的延迟表示从消息到达发布节点的消息队列开始，到消息到达订阅节点的消息队列所耗费的时间。\n\n* 表 persistWorkers 监控负责持久化流数据表的工作线程的状态。它包含以下列：\n\n  | 列名              | 含义            |\n  | --------------- | ------------- |\n  | workerId        | 线程 ID         |\n  | queueDepthLimit | 持久化的消息队列深度的上限 |\n  | queueDepth      | 持久化的当前消息队列深度  |\n  | tables          | 已经持久化的流数据表    |\n\n* 表 subWorkers 监控订阅节点的工作线程的状态。工作线程状态信息会按照 topic 来展示。它包含以下列：\n\n  | 列名                  | 含义                                                            |\n  | ------------------- | ------------------------------------------------------------- |\n  | workerId            | 线程 ID。若此列为空，代表该订阅尚未收到数据。                                      |\n  | topics              | 订阅主题                                                          |\n  | type                | 当前订阅节点的订阅方式：UDP 组播订阅（udp）或 TCP 订阅（tcp）                        |\n  | queueDepthLimit     | 订阅节点上的消息队列深度的上限                                               |\n  | queueDepth          | 订阅节点上的当前消息队列深度                                                |\n  | processedMsgCount   | 已经处理的消息数                                                      |\n  | lastMsgId           | 最后一条消息的 ID                                                    |\n  | failedMsgCount      | 处理失败的消息数                                                      |\n  | lastFailedMsgId     | 最后一条错误消息的 ID                                                  |\n  | lastFailedTimestamp | 最后一条错误消息发生的时间                                                 |\n  | lastErrMsg          | 最后一条错误消息的信息                                                   |\n  | msgAsTable          | 布尔值，表示订阅的数据是否为表。true 表示订阅的数据为表；false 表示订阅的数据是由列组成的元组。         |\n  | batchSize           | handler 批量处理的消息数                                              |\n  | throttle            | 数值类型，单位为毫秒。表示继上次 handler 处理消息之后，若 batchSize 条件一直未达到，多久后再次处理消息 |\n  | hash                | 非负整数，指定某个订阅线程处理进来的消息                                          |\n  | filter              | 流数据表指定的过滤列                                                    |\n  | persistOffset       | 布尔值，表示是否持久化保存最新一条已经处理的订阅数据的偏移量                                |\n  | timeTrigger         | 布尔值，若为 true，表示即使没有新的消息进入，handler 也会在 throttle 参数所设定的时间间隔被触发   |\n  | handlerNeedMsgId    | 布尔值，默认值为 false。若为 true，handler 必须支持两个参数：msgBody，msgId         |\n  | raftGroup           | 高可用下 Raft 组的 ID                                               |\n\n* 表 udpPubTables 用于监控流数据表进行 UDP 组播发布的状态。它包含以下列：\n\n  | 列名        | 含义                   |\n  | --------- | -------------------- |\n  | tableName | 发布的流数据表名             |\n  | channel   | 发布的 UDP 组播地址         |\n  | msgOffset | 已经发布的最后一条数据在总数据中的偏移量 |\n  | actions   | 订阅该发布表的所有订阅任务名称      |\n  | subNum    | 订阅该发布表的所有订阅数量        |\n\n#### 例子\n\n```\ngetStreamingStat().pubConns;\ngetStreamingStat().subConns;\ngetStreamingStat().pubTables;\ngetStreamingStat().persistWorkers;\ngetStreamingStat().subWorkers;\n```\n\n```\ngetStreamingStat().udpPubTables\n```\n"
    },
    "getStreamTableCacheOffset": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getstreamtablecacheoffset.html",
        "signatures": [
            {
                "full": "getStreamTableCacheOffset(streamTable)",
                "name": "getStreamTableCacheOffset",
                "parameters": [
                    {
                        "full": "streamTable",
                        "name": "streamTable"
                    }
                ]
            }
        ],
        "markdown": "### [getStreamTableCacheOffset](https://docs.dolphindb.cn/zh/funcs/g/getstreamtablecacheoffset.html)\n\n\n\n#### 语法\n\ngetStreamTableCacheOffset(streamTable)\n\n#### 参数\n\n**streamTable** 是一个自动清理的非持久化流表，即由 `enableTableShareAndCachePurge` 创建的流表，或由 `enableTableCachePurge` 设置后的流表。\n\n#### 详情\n\n查看指定的流表在内存中的最旧的记录相较于流表已写入的总记录数的偏移量（offset），即总记录数减去内存中数据行的值。\n\n#### 例子\n\n```\nt = streamTable(1000:0, `time`sym`volume, [DATETIME, SYMBOL, INT])\nenableTableShareAndCachePurge(table=t, tableName=`st, cachePurgeTimeColumn=`time,\n cachePurgeInterval=30m, cacheRetentionTime=20m)\n\ntime = datetime(2024.01.01T09:00:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\n\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n//0\n\ntime = datetime(2024.01.01T09:35:00) +1..1000*2\nsym=take(`a`b`c, 1000)\nvolume = rand(10,1000)\ninsert into t values([time, sym, volume])\ngetStreamTableCacheOffset(t)\n//999\n```\n"
    },
    "getStreamTableFilterColumn": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getStreamTableFilterColumn.html",
        "signatures": [
            {
                "full": "getStreamTableFilterColumn(streamTable)",
                "name": "getStreamTableFilterColumn",
                "parameters": [
                    {
                        "full": "streamTable",
                        "name": "streamTable"
                    }
                ]
            }
        ],
        "markdown": "### [getStreamTableFilterColumn](https://docs.dolphindb.cn/zh/funcs/g/getStreamTableFilterColumn.html)\n\n\n\n#### 语法\n\ngetStreamTableFilterColumn(streamTable)\n\n#### 参数\n\n**streamTable** 是流数据表。\n\n#### 详情\n\n返回由函数 [setStreamTableFilterColumn](https://docs.dolphindb.cn/zh/funcs/s/setStreamTableFilterColumn.html) 指定的流数据表中过滤列的名称。\n\n#### 例子\n\n```\nshare streamTable(10000:0,`time`symbol`price, [TIMESTAMP,SYMBOL,INT]) as trades\nsetStreamTableFilterColumn(trades, `symbol)\ntrades_1=table(10000:0,`time`symbol`price, [TIMESTAMP,SYMBOL,INT])\nfilter=symbol(`IBM`GOOG)\nsubscribeTable(tableName=`trades, actionName=`trades_1, handler=append!{trades_1}, msgAsTable=true, filter=filter);\n\nn=100\ntime=take(2018.01.01T09:30:00.000,n)\nsymbol=take((`IBM`GOOG`AAPL`C`BABA),n)\nprice=1..n\n\nt=table(time,symbol,price)\ntrades.append!(t)\n\n// 获取流数据表trades由setStreamTableFilterColumn函数指定的过滤列名\ngetStreamTableFilterColumn(trades) ;\n// output\nsymbol\n```\n"
    },
    "getStreamTables": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getstreamtables.html",
        "signatures": [
            {
                "full": "getStreamTables([option=0])",
                "name": "getStreamTables",
                "parameters": [
                    {
                        "full": "[option=0]",
                        "name": "option",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [getStreamTables](https://docs.dolphindb.cn/zh/funcs/g/getstreamtables.html)\n\n#### 语法\n\ngetStreamTables(\\[option=0])\n\n#### 详情\n\n获取流数据表的信息，返回一个表，包含如下列：\n\n* name：表的名称。\n* shared：是否为共享表。\n* persisted：是否为持久化表。\n* cachePurgeEnabled：是否为定时清理的非持久化流表。\n* loaded：是否已加载到内存。\n* columns：表所包含的列数。\n* rowsInMemory：内存中的行数。\n* totalRows：写入流表的总行数。\n* memoryUsed：表所占用的内存大小，单位为字节。\n\n**Note:** 若持久化表没被加载到内存时，则只返回 name, persisted 和 loaded 字段，其它字段返回 NULL。\n\n#### 参数\n\n`option` 整型标量，表示需要获取的流表的类型。可取以下值：\n\n* 0：获取所有流表\n* 1：获取持久化流表\n* 2：获取非持久化流表\n\n#### 例子\n\n```\nid=`XOM`GS`AAPL;\nx=102.1 33.4 73.6;\n\nrt=streamTable(id, x);\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades1;\nshare streamTable(10:0,`time`sym`price`volume,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades2;\n\ngetStreamTables()\n```\n\n<table id=\"table_f3d_k5y_bdc\"><thead><tr><th align=\"left\">\n\nname\n\n</th><th align=\"left\">\n\nshared\n\n</th><th align=\"left\">\n\npersisted\n\n</th><th align=\"left\">\n\ncachePurgeEnabled\n\n</th><th align=\"left\">\n\nloaded\n\n</th><th align=\"left\">\n\ncolumns\n\n</th><th align=\"left\">\n\nrowsInMemory\n\n</th><th align=\"left\">\n\ntotalRows\n\n</th><th align=\"left\">\n\nmemoryUsed\n\n</th></tr></thead><tbody><tr><td>\n\nrt\n\n</td><td>\n\nfalse\n\n</td><td>\n\nfalse\n\n</td><td>\n\nfalse\n\n</td><td>\n\ntrue\n\n</td><td>\n\n2\n\n</td><td>\n\n3\n\n</td><td>\n\n3\n\n</td><td>\n\n152\n\n</td></tr><tr><td>\n\ntrades1\n\n</td><td>\n\ntrue\n\n</td><td>\n\nfalse\n\n</td><td>\n\nfalse\n\n</td><td>\n\ntrue\n\n</td><td>\n\n4\n\n</td><td>\n\n0\n\n</td><td>\n\n0\n\n</td><td>\n\n240\n\n</td></tr><tr><td>\n\ntrades2\n\n</td><td>\n\ntrue\n\n</td><td>\n\nfalse\n\n</td><td>\n\nfalse\n\n</td><td>\n\ntrue\n\n</td><td>\n\n4\n\n</td><td>\n\n0\n\n</td><td>\n\n0\n\n</td><td>\n\n240\n\n</td></tr></tbody>\n</table>**Parent topic:**[函数参考](../../funcs/funcs_intro.md)\n"
    },
    "getSubscriptionTopic": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getSubscriptionTopic.html",
        "signatures": [
            {
                "full": "getSubscriptionTopic(tableName, [actionName])",
                "name": "getSubscriptionTopic",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[actionName]",
                        "name": "actionName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getSubscriptionTopic](https://docs.dolphindb.cn/zh/funcs/g/getSubscriptionTopic.html)\n\n\n\n#### 语法\n\ngetSubscriptionTopic(tableName, \\[actionName])\n\n#### 参数\n\n**tableName** 是一个字符串，表示共享的流数据表的名称。\n\n**actionName** 是一个字符串，表示订阅任务的名称。它可以包含字母，数字和下划线。\n\n#### 详情\n\n返回具有两个元素的元组：订阅主题的名称和流数据表的列名。\n\n订阅主题名称是流数据表所在节点的局域网信息（包括内网 IP 地址、端口号和节点别名）、流数据表的名称和订阅任务名称（如果指定了actionName）的组合，它们之间使用\"/\"分隔。例如，如果服务器的局域网信息为是 \"localhost:8848:nodeA\"，流数据表的名称是 \"trades\"，那么主题名称是 \"localhost:8848:nodeA/trades\"；如果订阅任务名称是 \"vwap\"，那么主题名称是 \"localhost:8848:nodeA/trades/vwap\"。\n\n#### 例子\n\n在别名为 rh8502 的节点上执行以下脚本，该节点的内网 IP 为192.168.1.135，端口号为8502：\n\n```\nt=streamTable(1000000:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nshare t as trades\ntrades_1=streamTable(1000000:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nsubscribeTable(tableName=`trades, actionName=`vwap, offset=-1, handler=append!{trades_1})\ngetSubscriptionTopic(`trades,`vwap);\n\n// output\n(\"192.168.1.135:8502/rh8502/trades/vwap\",[\"date\",\"time\",\"sym\",\"qty\",\"price\",\"exch\"])\n```\n"
    },
    "getSupportBundle": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getSupportBundle.html",
        "signatures": [
            {
                "full": "getSupportBundle([dir])",
                "name": "getSupportBundle",
                "parameters": [
                    {
                        "full": "[dir]",
                        "name": "dir",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getSupportBundle](https://docs.dolphindb.cn/zh/funcs/g/getSupportBundle.html)\n\n\n\n#### 语法\n\ngetSupportBundle(\\[dir])\n\n#### 参数\n\n**dir** 可选参数，用于指定存储路径。若不指定该参数，单节点环境下默认存储至 \\<HomeDir>（可通过 [getHomeDir](https://docs.dolphindb.cn/zh/funcs/g/getHomeDir.html) 查看 \\<HomeDir>）；集群环境下默认存储至 \\<HomeDir> 同级目录。\n\n#### 详情\n\n生成一个包含所有配置信息的文件，并返回文件路径。该函数只能在数据节点/计算节点调用。\n\n配置文件包含以下信息：\n\n| 模块名                                           | 含义                                                     | 信息来源                                                                                    |\n| :-------------------------------------------- | :----------------------------------------------------- | :-------------------------------------------------------------------------------------- |\n| VERSION                                       | server 的版本信息。                                          | version()                                                                               |\n| CONFIGS                                       | 配置信息。单机环境下，返回单节点的配置信息；集群环境下，包含集群、控制节点、 和数据节点/计算节点的配置。  | 单机: dolphindb.cfg 集群: cluster.cfg, cluster.nodes, controller.cfg                        |\n| DB AND TABLE SCHEMA                           | 所有数据库和表的结构。                                            | schema                                                                                  |\n| LICENSE AND MACHINE INFO                      | license、机器核数和内存信息。 节点绑定的 CPU 内核绑定和端口信息。                | 许可证: dolphindb.lic                                                                      |\n| OLAP CACHE ENGINE STATUS                      | OLAP 引擎 cache Engine 的状态信息，包含各节点的内存信息以及当前节点的状态表。       | pnodeRun(getOLAPCacheEngineSize) pnodeRun(getOLAPCacheEngineStat)                       |\n| TSDB META                                     | TSDB 引擎下所有 chunk 的元数据。                                 | pnodeRun(getTSDBMetaData)                                                               |\n| REDO LOG GC STATUS                            | 事务 redo log 回收的状态。                                     | pnodeRun(getRedoLogGCStat)                                                              |\n| TRANSACTION STATUS                            | 事务的状态。                                                 | pnodeRun(getTransactionStatus)                                                          |\n| TABLETS META                                  | 集群中行数最多的前100个 chunk 的元数据信息。                            | select top 100 \\* from pnodeRun(getTable tsMeta{“%”,”%”,false,-1}) order by rowNum desc |\n| ANOMALOUS CHUNK STATUS (only in cluster mode) | 处于异常状态的 chunk 信息。异常状态包含处于 recovery 状态，版本号不一致， 副本数不一致等。 | getClusterChunksStatus()                                                                |\n\n#### 例子\n\n```\ngetSupportBundle()\n// output\n/home/dolphindb/server/getSupportBundle.1655869793424\n\ngetSupportBundle(\"/home/dolphindb/sup\")\n// output\n/home/dolphindb/sup/getSupportBundle.1655869853178\n```\n"
    },
    "getSystemCpuUsage": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getSystemCpuUsage.html",
        "signatures": [
            {
                "full": "getSystemCpuUsage()",
                "name": "getSystemCpuUsage",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getSystemCpuUsage](https://docs.dolphindb.cn/zh/funcs/g/getSystemCpuUsage.html)\n\n\n\n#### 语法\n\ngetSystemCpuUsage()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回当前节点上 DolphinDB 进程实时占用 CPU 的百分比。\n\n注意，若 DolphinDB 进程占用多个 CPU，则返回各个 CPU 占用率的总和。\n\n#### 例子\n\n```\ngetSystemCpuUsage();\n\n// output\n1.771654\n```\n"
    },
    "getSystemLoadAvg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getSystemLoadAvg.html",
        "signatures": [
            {
                "full": "getSystemLoadAvg()",
                "name": "getSystemLoadAvg",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getSystemLoadAvg](https://docs.dolphindb.cn/zh/funcs/g/getSystemLoadAvg.html)\n\n\n\n#### 语法\n\ngetSystemLoadAvg()\n\n#### 详情\n\n返回实时系统平均负载。使用该函数前，需要启动性能监控，即在配置文件中把 *perfMonitoring* 设为1。\n\n#### 例子\n\n```\ngetSystemLoadAvg();\n\n// output\n5.664062\n```\n"
    },
    "getTableAccess": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gettableaccess.html",
        "signatures": [
            {
                "full": "getTableAccess(dbUrl, table)",
                "name": "getTableAccess",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [getTableAccess](https://docs.dolphindb.cn/zh/funcs/g/gettableaccess.html)\n\n\n\n#### 语法\n\ngetTableAccess(dbUrl, table)\n\n#### 参数\n\n**dbUrl** 字符串标量，表示分布式数据库的地址。\n\n**table** 字符串标量，表示分布式表的表名。\n\n#### 详情\n\n查看哪些用户和组具有与分布式数据表 *dbUrl/table* 相关（包括 ALLOW 和 DENY 权限状态）的权限。\n\n该函数仅限 admin 和对数据库 *dbUrl* 具有 DB\\_OWNER 或 DB\\_MANAGE 权限的用户调用。\n\n返回一个表：\n\n* name 具有相关权限的对象的名称。\n* type 该对象的类型，可选值为 user 和 group，分别对应用户和组。\n* TABLE\\_READ, TABLE\\_INSERT, TABLE\\_UPDATE, TABLE\\_DELETE 分别指代对应权限，权限状态包括 ALLOW, DENY, NONE。关于用户权限的更多信息可参考[用户权限管理](https://docs.dolphindb.cn/zh/tutorials/ACL_and_Security.html)。\n\n#### 例子\n\n具有 DB\\_OWNER 权限的用户 user1 创建了分布式表 `dfs://testDB/pt`，并为用户 user2 授予 TABLE\\_READ 权限，禁止用户 user3 的 TABLE\\_INSERT 权限，为组 group1 授予 TABLE\\_DELETE 权限。此时，用户 user1 可通过 `getTableAccess` 函数查看哪些用户具有 \"dfs\\://testDB/pt\" 相关的权限。\n\n```\nlogin(`user1, `123456)\ngetTableAccess(\"dfs://testDB\", \"pt\")\n```\n\n| name   | type  | TABLE\\_READ | TABLE\\_INSERT | TABLE\\_UPDATE | TABLE\\_DELETE |\n| ------ | ----- | ----------- | ------------- | ------------- | ------------- |\n| group1 | group | NONE        | NONE          | NONE          | ALLOW         |\n| user3  | user  | NONE        | DENY          | NONE          | NONE          |\n| user2  | user  | ALLOW       | NONE          | NONE          | NONE          |\n| admin  | user  | ALLOW       | ALLOW         | ALLOW         | ALLOW         |\n\n**Related information**\n\n[getDBAccess](https://docs.dolphindb.cn/zh/funcs/g/getDBAccess.html)\n"
    },
    "getTables": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getTables.html",
        "signatures": [
            {
                "full": "getTables(dbHandle)",
                "name": "getTables",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    }
                ]
            }
        ],
        "markdown": "### [getTables](https://docs.dolphindb.cn/zh/funcs/g/getTables.html)\n\n\n\n#### 语法\n\ngetTables(dbHandle)\n\n#### 参数\n\n**dbHandle** 是数据库句柄。\n\n#### 详情\n\n返回指定数据库中的所有表。\n\n#### 例子\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\ny=rand(10, n)\nt1=table(ID, date, x)\nt2=table(ID, date, y)\ndb = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\npt1 = db.createPartitionedTable(t1, `pt1, `date)\npt1.append!(t1)\npt2 = db.createPartitionedTable(t2, `pt2, `date)\npt2.append!(t2);\ngetTables(db);\n```\n\n输出返回：\\[\"pt1\",\"pt2\"]\n"
    },
    "getTablet": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getTablet.html",
        "signatures": [
            {
                "full": "getTablet(table, partition)",
                "name": "getTablet",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "partition",
                        "name": "partition"
                    }
                ]
            }
        ],
        "markdown": "### [getTablet](https://docs.dolphindb.cn/zh/funcs/g/getTablet.html)\n\n\n\n#### 语法\n\ngetTablet(table, partition)\n\n#### 参数\n\n**table** 是一个内存分区表。\n\n**partition** 是一个标量或向量，代表分区。若 *partition* 中某元素属于某个分区的分区列，此元素代表该分区。\n\n#### 详情\n\n返回内存分区表指定分区的子表。\n\n* 如果 *partition* 是标量，返回一个表。\n\n* 如果 *partition* 是向量，返回一个元组，其中每个元素是一个表。\n\n#### 例子\n\n```\ndb=database(partitionType=RANGE, partitionScheme=2012.06.01 2012.06.10 2012.06.20 2012.07.01)\nn=30\nt=table(take(2012.06.01..2012.06.30, n) as date, n..1 as val)\npt=db.createPartitionedTable(table=t, tableName=`pt, partitionColumns=`date).append!(t);\n\ngetTablet(pt, 2012.06.05);\n```\n\n| date       | val |\n| ---------- | --- |\n| 2012.06.01 | 30  |\n| 2012.06.02 | 29  |\n| 2012.06.03 | 28  |\n| 2012.06.04 | 27  |\n| 2012.06.05 | 26  |\n| 2012.06.06 | 25  |\n| 2012.06.07 | 24  |\n| 2012.06.08 | 23  |\n| 2012.06.09 | 22  |\n\n```\nresult=getTablet(pt, 2012.06.22 2012.06.11);\nresult.size();\n\n// output\n2\n\nresult[0];\n```\n\n| date       | val |\n| ---------- | --- |\n| 2012.06.20 | 11  |\n| 2012.06.21 | 10  |\n| 2012.06.22 | 9   |\n| 2012.06.23 | 8   |\n| 2012.06.24 | 7   |\n| 2012.06.25 | 6   |\n| 2012.06.26 | 5   |\n| 2012.06.27 | 4   |\n| 2012.06.28 | 3   |\n| 2012.06.29 | 2   |\n| 2012.06.30 | 1   |\n"
    },
    "getTabletsMeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getTabletsMeta.html",
        "signatures": [
            {
                "full": "getTabletsMeta([chunkPath], [tableName], [diskUsage=false], [top=1024])",
                "name": "getTabletsMeta",
                "parameters": [
                    {
                        "full": "[chunkPath]",
                        "name": "chunkPath",
                        "optional": true
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    },
                    {
                        "full": "[diskUsage=false]",
                        "name": "diskUsage",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[top=1024]",
                        "name": "top",
                        "optional": true,
                        "default": "1024"
                    }
                ]
            }
        ],
        "markdown": "### [getTabletsMeta](https://docs.dolphindb.cn/zh/funcs/g/getTabletsMeta.html)\n\n\n\n#### 语法\n\ngetTabletsMeta(\\[chunkPath], \\[tableName], \\[diskUsage=false], \\[top=1024])\n\n#### 参数\n\n**chunkPath** 是一个或多个 chunk 的 DFS 路径，支持使用通配符 %，\\* 以及？。\n\n**tableName** 是字符串，表示数据表名。\n\n**diskUsage** 是一个 Boolean 值，表示结果是否输出磁盘占用。\n\n**top** 是一个正整数，表示结果中返回的 chunk 的个数上限。默认值为1024。若不设上限，需将 *top* 参数设为-1。\n\n#### 详情\n\n返回当前节点上指定数据表 chunk 的元数据信息。若结合 [pnodeRun](https://docs.dolphindb.cn/zh/funcs/p/pnodeRun.html) 函数使用，可返回所有节点上指定数据表的元数据信息。\n\n返回一个表，包含以下列：\n\n* chunkId：chunk的唯一标识\n\n* path：分区的物理路径\n\n* dfsPath：分区DFS路径\n\n* tableName：表名\n\n* version：版本号\n\n* rowNum：分区的记录条数\n\n* createCids：update/delete表时创建的版本号\n\n* latestPhysicalDir：最新版本号（cid）对应的存储数据的临时物理路径\n\n* diskUsage：分区占用的磁盘空间，单位为字节。\n\n#### 例子\n\n```\nif(existsDatabase(\"dfs://testDB\")){\n   dropDatabase(\"dfs://testDB\")\n}\ndb=database(\"dfs://testDB\", VALUE, 1..10)\nn=1000000\nt=table(rand(1..10, n) as id, rand(100.0, n) as x)\ndb.createPartitionedTable(t, `pt1, `id).append!(t)\nn=2000000\nt=table(rand(1..10, n) as id, rand(100.0, n) as x, rand(100, n) as y)\ndb.createPartitionedTable(t, `pt2, `id).append!(t)\ngetTabletsMeta(\"/testDB/%\", `pt1, true);\n```\n\n| chunkId                              | path              | dfsPath      | tableName | version | rowNum | createCids | latestPhysicalDir | diskUsage |\n| ------------------------------------ | ----------------- | ------------ | --------- | ------- | ------ | ---------- | ----------------- | --------- |\n| dbfd1767-f9ca-689e-4d5e-643b8506e82d | C:\\Users\\Downl... | /testDB/10/8 | pt1       | 2       | 100155 | \\[2059]    | pt1\\_2\\_2059      | 696295    |\n| d221b457-fa7b-5990-4caa-13c99f56f716 | C:\\Users\\Downl... | /testDB/9/8  | pt1       | 2       | 99703  | \\[2059]    | pt1\\_2\\_2059      | 693026    |\n| 92904d3b-0147-9bb8-4a28-f99525b250e7 | C:\\Users\\Downl... | /testDB/8/8  | pt1       | 2       | 99791  | \\[2059]    | pt1\\_2\\_2059      | 693848    |\n| 7478c15a-0629-c8ab-47ee-a1d12c3c1cd6 | C:\\Users\\Downl... | /testDB/1/8  | pt1       | 2       | 100215 | \\[2059]    | pt1\\_2\\_2059      | 696932    |\n| 8bc48c11-86ca-97ac-4ee4-8f829de92cc8 | C:\\Users\\Downl... | /testDB/5/8  | pt1       | 2       | 100156 | \\[2059]    | pt1\\_2\\_2059      | 696584    |\n| 6b3a0a09-bc64-3bab-4535-344b7316d244 | C:\\Users\\Downl... | /testDB/2/8  | pt1       | 2       | 100121 | \\[2059]    | pt1\\_2\\_2059      | 696303    |\n| a7452c44-5d2b-6f82-4150-7bc48e941d64 | C:\\Users\\Downl... | /testDB/4/8  | pt1       | 2       | 99858  | \\[2059]    | pt1\\_2\\_2059      | 696572    |\n| a1a375cc-b6c0-29b2-485a-330af7447564 | C:\\Users\\Downl... | /testDB/6/8  | pt1       | 2       | 100280 | \\[2059]    | pt1\\_2\\_2059      | 697596    |\n| b04b4c04-6d43-0d8d-4000-6ae88e349eda | C:\\Users\\Downl... | /testDB/3/8  | pt1       | 2       | 99858  | \\[2059]    | pt1\\_2\\_2059      | 694400    |\n| b20df3a7-678b-1cbe-400d-d8e566706682 | C:\\Users\\Downl... | /testDB/7/8  | pt1       | 2       | 99865  | \\[2059]    | pt1\\_2\\_2059      | 6942755   |\n"
    },
    "getTopicProcessedOffset": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getTopicProcessedOffset.html",
        "signatures": [
            {
                "full": "getTopicProcessedOffset(topic)",
                "name": "getTopicProcessedOffset",
                "parameters": [
                    {
                        "full": "topic",
                        "name": "topic"
                    }
                ]
            }
        ],
        "markdown": "### [getTopicProcessedOffset](https://docs.dolphindb.cn/zh/funcs/g/getTopicProcessedOffset.html)\n\n\n\n#### 语法\n\ngetTopicProcessedOffset(topic)\n\n#### 参数\n\n**topic** 是 [subscribeTable](https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html) 函数返回的订阅主题。\n\n#### 详情\n\n如果 `subscribeTable` 函数的 *persistOffset* 参数为 true，那么该函数返回最新一条已经处理的订阅数据的偏移量；如果 `subscribeTable` 函数的 *persistOffset* 参数为 false，那么该函数返回-1。\n\n#### 例子\n\n```\nshare streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\ntrades_1 = streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT])\ntopic=subscribeTable(tableName=\"trades\", actionName=\"trades_1\", offset=0, handler=append!{trades_1}, msgAsTable=true, persistOffset=true)\ndef writeData(n){\n   timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n   symv =take(`A`B, n)\n   qtyv = take(1, n)\n   insert into trades values(timev, symv, qtyv)\n}\nwriteData(6);\nselect * from trades_1;\n```\n\n| time                    | sym | qty |\n| ----------------------- | --- | --- |\n| 2018.10.08T01:01:01.002 | A   | 1   |\n| 2018.10.08T01:01:01.003 | B   | 1   |\n| 2018.10.08T01:01:01.004 | A   | 1   |\n| 2018.10.08T01:01:01.005 | B   | 1   |\n| 2018.10.08T01:01:01.006 | A   | 1   |\n| 2018.10.08T01:01:01.007 | B   | 1   |\n\n```\ngetTopicProcessedOffset(topic);\n\n// output\n5\n```\n"
    },
    "getTradingCalendarType": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gettradingcalendartype.html",
        "signatures": [
            {
                "full": "getTradingCalendarType(marketName)",
                "name": "getTradingCalendarType",
                "parameters": [
                    {
                        "full": "marketName",
                        "name": "marketName"
                    }
                ]
            }
        ],
        "markdown": "### [getTradingCalendarType](https://docs.dolphindb.cn/zh/funcs/g/gettradingcalendartype.html)\n\n#### 语法\n\ngetTradingCalendarType(marketName)\n\n#### 详情\n\n获取指定交易所对应的交易日历的类型。返回值是字符串标量，为 \"holidayDate\" 或 \"tradingDate\"。\n\n#### 参数\n\n**marketName** 字符串标量，表示交易日历标识，例如：国外交易所的 ISO Code、国内交易所简称或自定义交易日历名称。\n\n#### 例子\n\n运行以下命令获取交易日历类型：\n\n```\ngetTradingCalendarType(\"SZSE\")\n```\n\n返回：holidayDate\n\n\n\n**Related information**\n\n[updateMarketHoliday](https://docs.dolphindb.cn/zh/funcs/u/updateMarketHoliday.html)\n\n[getMarketCalendar](https://docs.dolphindb.cn/zh/funcs/g/getMarketCalendar.html)\n\n[addMarketHoliday](https://docs.dolphindb.cn/zh/funcs/a/addMarketHoliday.html)\n"
    },
    "getTransactionStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getTransactionStatus.html",
        "signatures": [
            {
                "full": "getTransactionStatus()",
                "name": "getTransactionStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getTransactionStatus](https://docs.dolphindb.cn/zh/funcs/g/getTransactionStatus.html)\n\n\n\n#### 语法\n\ngetTransactionStatus()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取事务的状态，该函数只能在数据节点/计算节点执行。返回一个表，包含以下列：\n\n* tid ：事务的 id。\n\n* startTime：事务开始的时间。\n\n* type：事务涉及到的操作类型，包括 APPEND, DROP, SQLUPDATE, SQLUPSERT, SQLDELETE, FILEOPERATE 和 UNKNOWN。\n\n* status：事务当前的状态，包括 BEGIN, COMMIT, COMPLETE, ROLLBACK。\n\n* partitionCount：事务涉及到的分区数量。\n\n* endTime：事务结束的时间。\n\n* elapsedTime：事务持续的时间。\n\n#### 例子\n\n```\ngetTransactionStatus()\n```\n\n| tid  | startTime               | type   | status | partitionCount | endTime                 | elapsedTime |\n| ---- | ----------------------- | ------ | ------ | -------------- | ----------------------- | ----------- |\n| 3135 | 2022.06.07 16:19:48.477 | APPEND | BEGIN  | 4              |                         | 584         |\n| 3143 | 2022.06.07 16:11:27.489 | APPEND | COMMIT | 4              | 2022.06.07 16:11:33.100 | 484         |\n"
    },
    "getTSDBCachedSymbolBaseMemSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getTSDBCachedSymbolBaseMemSize.html",
        "signatures": [
            {
                "full": "getTSDBCachedSymbolBaseMemSize()",
                "name": "getTSDBCachedSymbolBaseMemSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBCachedSymbolBaseMemSize](https://docs.dolphindb.cn/zh/funcs/g/getTSDBCachedSymbolBaseMemSize.html)\n\n\n\n#### 语法\n\ngetTSDBCachedSymbolBaseMemSize()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取 TSDB 引擎中 SYMBOL 类型的字典编码的缓存大小，单位是字节。\n"
    },
    "getTSDBCacheEngineSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getTSDBCacheEngineSize.html",
        "signatures": [
            {
                "full": "getTSDBCacheEngineSize()",
                "name": "getTSDBCacheEngineSize",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBCacheEngineSize](https://docs.dolphindb.cn/zh/funcs/g/getTSDBCacheEngineSize.html)\n\n\n\n#### 语法\n\ngetTSDBCacheEngineSize()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回一个 LONG 类型数据，表示 TSDB 引擎 Cache Engine 允许使用的内存上限（单位为字节）。\n\n**首发版本**：2.00.4\n\n#### 例子\n\n```\nsetTSDBCacheEngineSize(0.5)\ngetTSDBCacheEngineSize()\n// output\n536870912\n```\n\n相关函数： [setTSDBCacheEngineSize](https://docs.dolphindb.cn/zh/funcs/s/setTSDBCacheEngineSize.html)\n"
    },
    "getTSDBCompactionTaskStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getTSDBCompactionTaskStatus.html",
        "signatures": [
            {
                "full": "getTSDBCompactionTaskStatus([count])",
                "name": "getTSDBCompactionTaskStatus",
                "parameters": [
                    {
                        "full": "[count]",
                        "name": "count",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBCompactionTaskStatus](https://docs.dolphindb.cn/zh/funcs/g/getTSDBCompactionTaskStatus.html)\n\n\n\n#### 语法\n\ngetTSDBCompactionTaskStatus(\\[count])\n\n#### 参数\n\n**count** 非负整数。设置后，将返回最近的 *count* 条合并任务的记录。默认值为 0，返回每个 volume 中最新的 256 个已完成的合并任务以及所有未完成的合并任务。\n\n#### 详情\n\n返回一个表，显示 TSDB 引擎 level file 合并操作任务的状态。该函数只能在数据节点调用。\n\n状态表包含以下几列：\n\n| 列名           | 含义                                   |\n| ------------ | ------------------------------------ |\n| volume       | 发生合并的文件所在的磁盘卷路径。由配置项 *volumes* 进行配置。 |\n| level        | 当前合并的 level file 层级。                 |\n| chunkId      | 发生合并操作的 chunk 的 ID。                  |\n| tableName    | 发生合并操作的数据表的物理表名。                     |\n| files        | 参与当前合并任务的 level file。                |\n| force        | 是否由 `triggerTSDBCompaction` 强制触发。    |\n| receivedTime | 当前合并任务进入任务队列的时间戳。                    |\n| startTime    | 当前合并任务开始执行的时间戳。                      |\n| endTime      | 当前合并任务执行结束的时间戳。                      |\n| errorMessage | 报错信息。如果失败，则显示失败的原因；否则显示空。            |\n\n#### 例子\n\n```\ngetTSDBCompactionTaskStatus()\n```\n\n| volume                                                                            | level | chunkId                              | tableName | files                    | force | receivedTime            | startTime               | endTime                 | errorMessage |\n| --------------------------------------------------------------------------------- | ----- | ------------------------------------ | --------- | ------------------------ | ----- | ----------------------- | ----------------------- | ----------------------- | ------------ |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 0     | e0e00bc2-b81e-6eb9-4d01-7bb17fb39595 | pt\\_2     | 0\\_00000006,0\\_00000011, | true  | 2023.06.22T12:47:32.009 | 2023.06.22T12:47:32.010 | 2023.06.22T12:47:32.182 |              |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 1     | a9dfccad-cec1-0786-480a-9ae809481a8b | pt\\_2     | 0\\_00000003,0\\_00000007, | true  | 2023.06.22T12:47:32.010 | 2023.06.22T12:47:32.182 | 2023.06.22T12:47:32.326 |              |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 1     | 331324ce-b49f-94ac-4da8-a4bcf6c34e1c | pt\\_2     | 0\\_00000004,0\\_00000010, | true  | 2023.06.22T12:47:32.010 | 2023.06.22T12:47:32.326 | 2023.06.22T12:47:32.451 |              |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 2     | f3597e0f-6ad9-6eb6-45c8-d42adc5c50f7 | pt\\_2     | 0\\_00000002,0\\_00000008, | true  | 2023.06.22T12:47:32.010 | 2023.06.22T12:47:32.451 | 2023.06.22T12:47:32.527 |              |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 2     | d36ac640-3428-069b-4382-0b9608b94d17 | pt\\_2     | 0\\_00000005,0\\_00000009, | true  | 2023.06.22T12:47:32.010 | 2023.06.22T12:47:32.527 | 2023.06.22T12:47:32.616 |              |\n| /home/DolphinDB/DolphinDB\\_Linux64\\_V2.00.9/server/clusterDemo/data/node1/storage | 2     | e0e00bc2-b81e-6eb9-4d01-7bb17fb39595 | pt\\_2     | 0\\_00000016,0\\_00000021, | true  | 2023.06.22T12:47:33.058 | 2023.06.22T12:47:33.058 | 2023.06.22T12:47:33.151 |              |\n\n相关函数：[triggerTSDBCompaction](https://docs.dolphindb.cn/zh/funcs/t/triggerTSDBCompaction.html)\n"
    },
    "getTSDBDataStat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gettsdbdatastat.html",
        "signatures": [
            {
                "full": "getTSDBDataStat([dbName=\"*\"],[tableName=\"*\"],[chunkId])",
                "name": "getTSDBDataStat",
                "parameters": [
                    {
                        "full": "[dbName=\"*\"]",
                        "name": "dbName",
                        "optional": true,
                        "default": "\"*\""
                    },
                    {
                        "full": "[tableName=\"*\"]",
                        "name": "tableName",
                        "optional": true,
                        "default": "\"*\""
                    },
                    {
                        "full": "[chunkId]",
                        "name": "chunkId",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBDataStat](https://docs.dolphindb.cn/zh/funcs/g/gettsdbdatastat.html)\n\n\n\n#### 语法\n\ngetTSDBDataStat(\\[dbName=\"\\*\"],\\[tableName=\"\\*\"],\\[chunkId])\n\n#### 参数\n\n**dbName** 字符串，表示数据库的名称。可以包含通配符(“\\*“, “%”和”?”)。\n\n**tableName** 字符串，表示数据表名。可以包含通配符(“\\*“, “%”和”?”)。\n\n通配符 ”\\*” 表示匹配所有，”?”表示单个字符，”%”表示0，1或多个字符。\n\n**chunkId** 字符串标量或向量，表示 chunk 的 ID。若指定该参数，则 *dbName* 和 *tableName* 必须为空或者 \\*。\n\n#### 详情\n\n获取当前节点上 TSDB 引擎存储的表的所有或指定 chunk 下的 Level File 和 sortKeyEntry 的数量。\n\n结合 pnodeRun 函数，可以查看一个集群内（某个）表的 Level File 和 sortKeyEntry 的数量。\n\n返回一个表，包含以下列：\n\n**levelFileCount**: 每个分区内表的 Level File 的数量。\n\n**sortKeyEntryCount**：每个分区内所有 Level File 文件里未去重的 sortKeyEntry 数量。\n\n#### 例子\n\n```\nt = table(1 2 1 1 2 2 3 as month, `Rome`Paris`London`Paris`Rome`London`Rome as city, 200 500 100 300 300 400 400 as sold)\ndb_name = \"dfs://window_function\"\nif (existsDatabase(db_name)) {\n    dropDatabase(db_name)\n}\ndb = database(db_name, HASH, [INT, 4], , 'TSDB')\n\npt = db.createPartitionedTable(t, \"pt\", \"month\", ,\"sold\")\npt.append!(t)\n\npt1 = db.createPartitionedTable(t, \"pt1\", \"month\", ,\"sold\")\npt1.append!(t)\n\nflushTSDBCache()\n```\n\n获取以 `dfs://window` 开头的数据库下所有表的 Level File 和 sortKeyEntry 的数量\n\n```\ngetTSDBDataStat(\"dfs://window%\") \n```\n\n| dbName                  | chunkId                              | tableName | levelFileCount | sortKeyEntryCount |\n| ----------------------- | ------------------------------------ | --------- | -------------- | ----------------- |\n| dfs\\://window\\_function | d334ffab-741a-dcbd-174e-42b412058877 | pt1       | 1              | 1                 |\n| dfs\\://window\\_function | c3de728c-4efb-7e8e-024c-cfafd46c506c | pt1       | 1              | 3                 |\n| dfs\\://window\\_function | 572b1660-790e-e3a0-3944-9b81e50f4eb4 | pt1       | 1              | 3                 |\n| dfs\\://window\\_function | e9ea31f6-4e12-2881-b04a-c540dc3947c8 | pt        | 1              | 1                 |\n| dfs\\://window\\_function | 673a7c12-c0d4-72bf-6a42-9c374589e2d6 | pt        | 1              | 3                 |\n| dfs\\://window\\_function | 57ceedc9-4aaf-2aad-aa43-37924da3d32e | pt        | 1              | 3                 |\n\n获取以 `dfs://window` 开头的数据库下表 pt 的 Level File 和 sortKeyEntry 的数量\n\n```\ngetTSDBDataStat(\"dfs://window%\",\"pt\")\n```\n\n| dbName                  | chunkId                              | tableName | levelFileCount | sortKeyEntryCount |\n| ----------------------- | ------------------------------------ | --------- | -------------- | ----------------- |\n| dfs\\://window\\_function | e9ea31f6-4e12-2881-b04a-c540dc3947c8 | pt        | 1              | 1                 |\n| dfs\\://window\\_function | 673a7c12-c0d4-72bf-6a42-9c374589e2d6 | pt        | 1              | 3                 |\n| dfs\\://window\\_function | 57ceedc9-4aaf-2aad-aa43-37924da3d32e | pt        | 1              | 3                 |\n\n获取指定 chunkId 的分区下的 Level File 和 sortKeyEntry 的数量。\n\n```\ngetTSDBDataStat(chunkId=[\"e9ea31f6-4e12-2881-b04a-c540dc3947c8\", \"673a7c12-c0d4-72bf-6a42-9c374589e2d6\"])\n```\n\n| dbName                  | chunkId                              | tableName | levelFileCount | sortKeyEntryCount |\n| ----------------------- | ------------------------------------ | --------- | -------------- | ----------------- |\n| dfs\\://window\\_function | 673a7c12-c0d4-72bf-6a42-9c374589e2d6 | pt        | 1              | 3                 |\n| dfs\\://window\\_function | 57ceedc9-4aaf-2aad-aa43-37924da3d32e | pt        | 1              | 3                 |\n"
    },
    "getTSDBMetaData": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getTSDBMetaData.html",
        "signatures": [
            {
                "full": "getTSDBMetaData()",
                "name": "getTSDBMetaData",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBMetaData](https://docs.dolphindb.cn/zh/funcs/g/getTSDBMetaData.html)\n\n\n\n#### 语法\n\ngetTSDBMetaData()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取 TSDB 引擎下所有 chunk 的元数据。该函数只能在数据节点上执行。\n\n返回一个表，包含以下列:\n\n* chunkId：chunk 的唯一标识\n\n* chunkPath：分区的物理路径\n\n* level：数据文件所在的 level 级别\n\n* table：数据表名称\n\n* files：数据文件名称，即 level file 名称\n\n**首发版本**：2.00.4\n\n#### 例子\n\n```\ngetTSDBMetaData()\n```\n\n| chunkId                          | chunkPath           | level | table | files                    |\n| -------------------------------- | ------------------- | ----- | ----- | ------------------------ |\n| 7e0c65ca-5e4a-4594-2948-fa0b5... | /hdd/hdd7/test/v... | 0     | pt\\_2 | 0\\_00211490,0\\_002115580 |\n| 7e0c65ca-5e4a-4594-2948-fa0b5... | /hdd/hdd7/test/v... | 1     | pt\\_2 | 1\\_00013041              |\n"
    },
    "getTSDBSortKeyEntry": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getTSDBSortKeyEntry.html",
        "signatures": [
            {
                "full": "getTSDBSortKeyEntry(chunkId, [tableName])",
                "name": "getTSDBSortKeyEntry",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBSortKeyEntry](https://docs.dolphindb.cn/zh/funcs/g/getTSDBSortKeyEntry.html)\n\n\n\n#### 语法\n\ngetTSDBSortKeyEntry(chunkId, \\[tableName])\n\n#### 参数\n\n**chunkId** 字符串标量或向量，表示 chunk 的 ID。注意：不可超过 1024。\n\n**tableName** 可选参数，是字符串标量，表示分布表的名称。若不指定该参数，则表示该 chunk 下所包含的所有表。\n\n#### 详情\n\n获取 TSDB 引擎已经写入磁盘的每个 chunk 分区的 sort key（详见 [sortColumns](https://docs.dolphindb.cn/zh/funcs/c/createPartitionedTable.html) 参数介绍）信息。\n\n返回一个表，包含以下字段：\n\n* chunkId：chunk 的唯一标识。\n\n* chunkPath：chunk 数据所存储的路径。\n\n* tableName：分布式表表名。\n\n* file：level file 文件名。\n\n* key：sort key 的组合值。sort key 之间以下划线 “\\_” 分隔。\n\n* size：当前 sort key 组合值对应的记录数。\n\n**Note:** 该函数不支持查询 Cache Engine 中的分区数据，因此，调用该函数前，需要先调用 [flushTSDBCache](https://docs.dolphindb.cn/zh/funcs/f/flushTSDBCache.html)，将 cacheEngine 中已完成的分区数据写入磁盘。\n\n#### 例子\n\n```\nn = 10000\nSecurityID = rand(`st0001`st0002`st0003`st0004`st0005, n)\nsym = rand(`A`B`C`D`E, n)\nTradeDate = 2022.01.01 + rand(100,n)\nTotalVolumeTrade = rand(1000..3000, n)\nTotalValueTrade = rand(100.0, n)\nschemaTable_snap = table(SecurityID, sym, TradeDate, TotalVolumeTrade, TotalValueTrade).sortBy!(`SecurityID`sym`TradeDate)\n\ndbPath = \"dfs://TSDB_STOCK\"\nif(existsDatabase(dbPath)){dropDatabase(dbPath)}\ndb_snap = database(dbPath, VALUE, 2022.01.01..2022.01.05, engine='TSDB')\n\nsnap=createPartitionedTable(dbHandle=db_snap, table=schemaTable_snap, tableName=\"snap\", partitionColumns=`TradeDate, sortColumns=`SecurityID`sym`TradeDate, keepDuplicates=ALL, sortKeyMappingFunction=[hashBucket{,3}, hashBucket{,2}])\nsnap.append!(schemaTable_snap)\n\nsnap1=createPartitionedTable(dbHandle=db_snap, table=schemaTable_snap, tableName=\"snap1\", partitionColumns=`TradeDate, sortColumns=`SecurityID`sym`TradeDate, keepDuplicates=ALL)\nsnap1.append!(schemaTable_snap)\n\nflushTSDBCache()\n\ngetChunksMeta()\n```\n\n输出返回：\n\n| site        | chunkId                              | path                                                                 | dfsPath                  | type | flag | size | version | state | versionList                   | resolved |\n| ----------- | ------------------------------------ | -------------------------------------------------------------------- | ------------------------ | ---- | ---- | ---- | ------- | ----- | ----------------------------- | -------- |\n| server11352 | fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | /TSDB\\_STOCK/20220410/yv | 1    | 0    | 0    | 1       | 0     | cid : 2134,snap1=>2134:89; #  | false    |\n| server11352 | 5c30ef71-3e51-c5ac-6b4d-4458feb8454a | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220407/yv | /TSDB\\_STOCK/20220407/yv | 1    | 0    | 0    | 1       | 0     | cid : 2134,snap1=>2134:95; #  | false    |\n| server11352 | 4216dbe9-c238-49a9-4d45-66829c98a7b5 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220406/yv | /TSDB\\_STOCK/20220406/yv | 1    | 0    | 0    | 1       | 0     | cid : 2134,snap1=>2134:92; #  | false    |\n| server11352 | 47ea0d35-7ea9-c3b3-cc4b-cc6cd1fe039d | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220401/yv | /TSDB\\_STOCK/20220401/yv | 1    | 0    | 0    | 1       | 0     | cid : 2134,snap1=>2134:100; # | false    |\n| server11352 | aafd71c5-a197-63a9-2d4c-b65cbced3d21 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220330/yv | /TSDB\\_STOCK/20220330/yv | 1    | 0    | 0    | 1       | 0     | cid : 2134,snap1=>2134:97; #  | false    |\n\n```\ngetTSDBSortKeyEntry(\"fe93077a-5a05-34a8-554c-67467415bf68\")\n```\n\n输出返回：\n\n| chunkId                              | chunkPath                                                            | tableName | file        | key       | size |\n| ------------------------------------ | -------------------------------------------------------------------- | --------- | ----------- | --------- | ---- |\n| fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | snap1     | 0\\_00000058 | st0001\\_A | 2    |\n| fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | snap1     | 0\\_00000058 | st0001\\_B | 3    |\n| fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | snap1     | 0\\_00000058 | st0001\\_C | 2    |\n| fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | snap1     | 0\\_00000058 | st0001\\_D | 6    |\n| fe93077a-5a05-34a8-554c-67467415bf68 | /dolphindb/server/server11352/storage/CHUNKS/TSDB\\_STOCK/20220410/yv | snap1     | 0\\_00000058 | st0002\\_A | 4    |\n"
    },
    "getTSDBTableIndexCacheStatus": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gettsdbtableindexcachestatus.html",
        "signatures": [
            {
                "full": "getTSDBTableIndexCacheStatus()",
                "name": "getTSDBTableIndexCacheStatus",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getTSDBTableIndexCacheStatus](https://docs.dolphindb.cn/zh/funcs/g/gettsdbtableindexcachestatus.html)\n\n#### 语法\n\ngetTSDBTableIndexCacheStatus()\n\n#### 参数\n\n无。\n\n#### 详情\n\nTSDB 引擎在查询 Level File 时，会将其尾部的索引信息（包括 zonemap 等）加载 Level File 时加载到内存中。该函数用于获取已加载的数据库中表的 Level File 索引所占用的内存（单位为字节）。结合 getTSDBDataStat 函数，可以评估内存中的 Level File 对应的表的 sort key 设置是否合理。\n\n输出一个表，包含以下字段：\n\n* dbName：数据库名称。\n\n* chunkId：chunk 的唯一标识。\n\n* tableName：chunk 所属的表名称。\n\n* memUsage：Level File 索引占用的内存，单位为字节。\n\n#### 例子\n\n```\nt = table(1 2 1 1 2 2 3 as month, `Rome`Paris`London`Paris`Rome`London`Rome as city, 200 500 100 300 300 400 400 as sold)\ndb_name = \"dfs://tsdb_01\"\nif (existsDatabase(db_name)) {\n    dropDatabase(db_name)\n}\ndb = database(db_name, HASH, [INT, 4], , 'TSDB')\n\npt = db.createPartitionedTable(t, \"pt\", \"month\", ,\"sold\")\npt.append!(t)\n\npt1 = db.createPartitionedTable(t, \"pt1\", \"month\", ,\"sold\")\npt1.append!(t)\n\nflushTSDBCache()\n\ngetTSDBTableIndexCacheStatus()\n```\n\n| dbName          | chunkId                              | tableName | memUsage |\n| --------------- | ------------------------------------ | --------- | -------- |\n| dfs\\://tsdb\\_01 | 01e891fa-f66d-7599-7544-4e0449f4e608 | pt1\\_3    | 680      |\n| dfs\\://tsdb\\_01 | 81c0f8f7-e195-b298-da4a-d007492f4733 | pt1\\_3    | 680      |\n| dfs\\://tsdb\\_01 | 17f8bc0b-946e-f688-374c-955c586faccf | pt\\_2     | 296      |\n| dfs\\://tsdb\\_01 | 1df88c41-bccf-449b-504c-5978df9cc03f | pt\\_2     | 680      |\n| dfs\\://tsdb\\_01 | 10371e0c-685a-51b1-3042-1ba289514bb9 | pt1\\_3    | 296      |\n| dfs\\://tsdb\\_01 | 0be81d1e-1962-108b-274e-3dc2632921bc | pt\\_2     | 680      |\n\n"
    },
    "getUnresolvedTxn": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getUnresolvedTxn.html",
        "signatures": [
            {
                "full": "getUnresolvedTxn()",
                "name": "getUnresolvedTxn",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getUnresolvedTxn](https://docs.dolphindb.cn/zh/funcs/g/getUnresolvedTxn.html)\n\n\n\n#### 语法\n\ngetUnresolvedTxn()\n\n#### 参数\n\n无\n\n#### 详情\n\n获取两阶段提交协议中处于决议状态的节点及其事务。只能由管理员在控制节点执行。返回一个表，包含以下字段：\n\n* tid：事务 id。\n\n* cid：提交的版本号。\n\n* chunkId：chunk 的唯一标识。\n\n* initiatingNode：事务决议的发起节点。\n\n* firstResolutionAt：事务开始决议的时间。\n\n* lastResolutionAt：若事务发生多次决议，则会显示最后一次决议的时间。\n"
    },
    "getUserAccess": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getUserAccess.html",
        "signatures": [
            {
                "full": "getUserAccess([userIds], [finalAccess=false])",
                "name": "getUserAccess",
                "parameters": [
                    {
                        "full": "[userIds]",
                        "name": "userIds",
                        "optional": true
                    },
                    {
                        "full": "[finalAccess=false]",
                        "name": "finalAccess",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [getUserAccess](https://docs.dolphindb.cn/zh/funcs/g/getUserAccess.html)\n\n\n\n#### 语法\n\ngetUserAccess(\\[userIds], \\[finalAccess=false])\n\n#### 参数\n\n**userId** 是表示一个或多个用户的字符串标量或向量。\n\n**finalAccess** 为布尔值，表示是否获取用户及其所属组权限叠加的结果。默认值为 false。\n\n#### 详情\n\n指定 *userId* 时：\n\n* 若 *finalAccess* = false，则返回指定用户所单独被赋予的权限，不包括用户所属组的权限。\n\n* 若 *finalAccess* = true，则返回指定用户及其所属组的权限组合后的最终生效权限。\n\n当没有指定 *userId* 时，返回当前登录用户的权限。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n以下分别介绍返回表的各参数的详情：\n\n| 参数                        | 详情                                                          |\n| :------------------------ | :---------------------------------------------------------- |\n| userId                    | 用户名                                                         |\n| groups                    | 组名                                                          |\n| isAdmin                   | 是否是管理员。                                                     |\n| MAX\\_JOB\\_PRIORITY        | 该用户对应的作业最高优先级，范围是0-8，可以通过 `setMaxJobPriority` 指定。           |\n| MAX\\_PARALLELISM          | 该用户提交的作业最多可以有多少个子任务同时并行执行，可以通过 `setMaxJobParallelism` 指定。   |\n| QUERY\\_RESULT\\_MEM\\_LIMIT | 该用户单次查询结果的占用内存上限，浮点类型，单位为 GB。可以通过 `grant` 指定，`revoke` 撤销。   |\n| TASK\\_GROUP\\_MEM\\_LIMIT   | 该用户发送的批量子查询占用的内存上限，浮点类型，单位为 GB。可以通过 `grant` 指定，`revoke` 撤销。 |\n\n以下字段对应权限，其值为 “allow\" / \"none\" / \"deny\" ：\n\n| 权限                   |\n| -------------------- |\n| ACCESS\\_READ         |\n| ACCESS\\_INSERT       |\n| ACCESS\\_UPDATE       |\n| ACCESS\\_DELETE       |\n| VIEW\\_EXEC           |\n| SCRIPT\\_EXEC         |\n| TEST\\_EXEC           |\n| DBOBJ\\_CREATE        |\n| DBOBJ\\_DELETE        |\n| DB\\_MANAGE           |\n| DB\\_OWNER            |\n| VIEW\\_OWNER          |\n| COMPUTE\\_GROUP\\_EXEC |\n\n**注意**：\n\n* 自 3.00.2 版本起，支持获取访问计算节点组的权限。\n\n* 自 3.00.0.0 版本起，支持获取访问 catalog 的相关权限。\n\n* 自 2.00.9版本开始，新增了表和数据库的插入更新和删除权限（即对写权限进行拓展），因此旧版本的 TABLE\\_WRITE 字段由 TABLE\\_INSERT，TABLE\\_UPDATE，TALBE\\_DELETE 字段替代。\n\n* 由于 DB\\_READ / DB\\_WRITE / DB\\_INSERT / DB\\_UPDATE / DB\\_DELETE 权限其作用对象为库下的所有表，因此在 getUserAccess 函数的返回字段中，被统一为 TABLE\\_READ / TABLE\\_INSERT / TABLE\\_UPDATE / TALBE\\_DELETE，可以通过下述权限应用的具体对象表的字段来区分其作用范围。\n\n以下几个字段表示权限应用的具体对象：\n\n| 对象                            |\n| ----------------------------- |\n| TABLE\\_READ\\_allowed          |\n| TABLE\\_READ\\_denied           |\n| TABLE\\_INSERT\\_allowed        |\n| TABLE\\_INSERT\\_denied         |\n| TABLE\\_UPDATE\\_allowed        |\n| TABLE\\_UPDATE\\_denied         |\n| TABLE\\_DELETE\\_allowed        |\n| TABLE\\_DELETE\\_denied         |\n| DB\\_READ\\_allowed             |\n| DB\\_READ\\_denied              |\n| DB\\_INSERT\\_allowed           |\n| DB\\_INSERT\\_denied            |\n| DB\\_UPDATE\\_allowed           |\n| DB\\_UPDATE\\_denied            |\n| DB\\_DELETE\\_allowed           |\n| DB\\_DELETE\\_denied            |\n| VIEW\\_EXEC\\_allowed           |\n| VIEW\\_EXEC\\_denied            |\n| DBOBJ\\_CREATE\\_allowed        |\n| DBOBJ\\_CREATE\\_denied         |\n| DBOBJ\\_DELETE\\_allowed        |\n| DBOBJ\\_DELETE\\_denied         |\n| DB\\_OWNER\\_allowed            |\n| DB\\_MANAGE\\_allowed           |\n| DB\\_MANAGE\\_denied            |\n| CATALOG\\_READ\\_allowed        |\n| CATALOG\\_READ\\_denied         |\n| CATALOG\\_INSERT\\_allowed      |\n| CATALOG\\_INSERT\\_denied       |\n| CATALOG\\_UPDATE\\_allowed      |\n| CATALOG\\_UPDATE\\_denied       |\n| CATALOG\\_DELETE\\_allowed      |\n| CATALOG\\_DELETE\\_denied       |\n| COMPUTE\\_GROUP\\_EXEC\\_allowed |\n| COMPUTE\\_GROUP\\_EXEC\\_denied  |\n"
    },
    "getUserHardwareUsage": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getUserHardwareUsage.html",
        "signatures": [
            {
                "full": "getUserHardwareUsage([from=0], [to])",
                "name": "getUserHardwareUsage",
                "parameters": [
                    {
                        "full": "[from=0]",
                        "name": "from",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[to]",
                        "name": "to",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getUserHardwareUsage](https://docs.dolphindb.cn/zh/funcs/g/getUserHardwareUsage.html)\n\n\n\n#### 语法\n\ngetUserHardwareUsage(\\[from=0], \\[to])\n\n#### 参数\n\n**from**整型或时间类型，表示查询的起始时间点。默认值为0，表示查询从1970.01.01零点开始的记录。\n\n**to**整型或时间类型，表示查询的结束时间点。默认为空，表示查询到目前时间点为止的记录。\n\n*from* 必须小于等于 *to*。\n\n#### 详情\n\n从已保存的所有记录了 CPU 和内存使用量日志文件中，提取指定时间内的 CPU 和 内存使用量。返回一个表。含以下字段：\n\n* timestamp：NANOTIMESTAMP 类型的时间戳。\n\n* userId：登录用户名。\n\n* cpu：当前用户占用的工作线程数量。\n\n* memory：内存使用量，当前用户使用的所有变量的内存占用大小。单位是字节。\n\n该函数仅限管理员在数据节点上调用。\n\n#### 例子\n\n```\ngetUserHardwareUsage(2023.12.29T10:55:43.280031346,2023.12.29T10:56:23.321355134)\n// output\ntimestamp                            userId      cpu       memory\n2023.12.29T10:55:43.280031346\tguest\t1\t16\n2023.12.29T10:55:53.290361530\tadmin\t0\t16\n2023.12.29T10:55:53.290361530\tguest\t1\t16\n2023.12.29T10:56:03.299225976\tadmin\t0\t16\n2023.12.29T10:56:03.299225976\tguest\t1\t16\n2023.12.29T10:56:13.310316778\tadmin\t0\t16\n2023.12.29T10:56:13.310316778\tguest\t1\t16\n```\n"
    },
    "getUserList": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getUserList.html",
        "signatures": [
            {
                "full": "getUserList()",
                "name": "getUserList",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [getUserList](https://docs.dolphindb.cn/zh/funcs/g/getUserList.html)\n\n\n\n#### 语法\n\ngetUserList()\n\n#### 详情\n\n返回包含除管理员之外的所有用户名称的向量。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n```\nlogin(`admin, `123456);\ngetUserList().sort();\n// output\n[\"AA\",\"AAA\",\"BB\",\"BBB\",\"CC\",\"DeionSanders\",\"EliManning\",\"JoeFlacco\"]\n```\n"
    },
    "getUsersByGroupId": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getUsersByGroupId.html",
        "signatures": [
            {
                "full": "getUsersByGroupId(groupId)",
                "name": "getUsersByGroupId",
                "parameters": [
                    {
                        "full": "groupId",
                        "name": "groupId"
                    }
                ]
            }
        ],
        "markdown": "### [getUsersByGroupId](https://docs.dolphindb.cn/zh/funcs/g/getUsersByGroupId.html)\n\n\n\n#### 语法\n\ngetUsersByGroupId(groupId)\n\n#### 参数\n\n**groupId** 是表示组名的字符串。\n\n#### 详情\n\n返回属于指定组的用户。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n"
    },
    "getUserTableAccessRecords": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/getUserTableAccessRecords.html",
        "signatures": [
            {
                "full": "getUserTableAccessRecords([from=0], [to])",
                "name": "getUserTableAccessRecords",
                "parameters": [
                    {
                        "full": "[from=0]",
                        "name": "from",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[to]",
                        "name": "to",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [getUserTableAccessRecords](https://docs.dolphindb.cn/zh/funcs/g/getUserTableAccessRecords.html)\n\n\n\n#### 语法\n\ngetUserTableAccessRecords(\\[from=0], \\[to])\n\n#### 参数\n\n**from**整型或时间类型，表示查询的起始时间点。默认值为0，表示查询从1970.01.01零点开始的记录。\n\n**to**整型或时间类型，表示查询的结束时间点。默认为空，表示查询到目前时间点为止的记录。\n\n*from* 必须小于等于 *to*。\n\n#### 详情\n\n从已保存记录了分布式表查询信息的日志中，提取指定时间段内的查询日志。返回一个表。含以下字段：\n\n* timestamp：NANOTIMESTAMP 类型的时间戳。如果 type 是 sql，则这里记录开始执行 SQL 的时间戳；如果 type 是 rowCount 或 memUsage，则这里记录的是读出数据的时间戳。\n\n* rootQueryId：SQL 查询任务的 ID，是分布式 SQL 查询任务的唯一标识符。一个分布式查询会按分区拆分为多个 SQL 子查询。该 ID 为分布式查询及其拆分出的子查询的根 ID。\n\n* userid：用户名。\n\n* database：数据库名。\n\n* table：表名。\n\n* type：记录的信息类型，包括3类：sql, rowCount, memUsage。\n\n* value：\n\n  * 当类型为 sql 时，为 SQL 查询任务的执行次数。该值总是为1。\n\n  * 当类型为 rowCount 时，为 SQL 执行时存储引擎返回的表的行数。\n\n  * 当类型为 memUsage 时，为查询结果占用的内存大小。单位是字节。\n\n* script：当类型为 sql 时，记录 SQL 脚本，其他类型则为空字符串。\n\n该函数仅限管理员在数据节点上调用。\n\n#### 例子\n\n```\ngetUserTableAccessRecords(2023.12.30T09:18:35.894150296,2023.12.30T09:18:35.894538439)\n// output\ntimestamp\t                    rootQueryId\t                         userId       database\t    table     type\tvalue    script\n2023.12.30T09:18:35.894150296\te892855b-7843-1492-0140-a85810662006\tadmin\tdfs://rangedb\tpt\tsql\t1\tselect count(x) as count_x from pt\n2023.12.30T09:18:35.894497304\te892855b-7843-1492-0140-a85810662006\tadmin\tdfs://rangedb\tpt\trowCount   43\t\n2023.12.30T09:18:35.894501600\te892855b-7843-1492-0140-a85810662006\tadmin\tdfs://rangedb\tpt\tmemUsage   516\n```\n"
    },
    "glm": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/glm.html",
        "signatures": [
            {
                "full": "glm(ds, yColName, xColNames, [family], [link], [tolerance=1e-6], [maxIter=100])",
                "name": "glm",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[family]",
                        "name": "family",
                        "optional": true
                    },
                    {
                        "full": "[link]",
                        "name": "link",
                        "optional": true
                    },
                    {
                        "full": "[tolerance=1e-6]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "1e-6"
                    },
                    {
                        "full": "[maxIter=100]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "100"
                    }
                ]
            }
        ],
        "markdown": "### [glm](https://docs.dolphindb.cn/zh/funcs/g/glm.html)\n\n\n\n#### 语法\n\nglm(ds, yColName, xColNames, \\[family], \\[link], \\[tolerance=1e-6], \\[maxIter=100])\n\n#### 参数\n\n**ds** 是数据源，通常由 [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html) 函数生成。\n\n**yColName** 是字符串，表示数据源中作为因变量的列名。\n\n**xColNames** 是字符串标量或向量，表示数据源中作为自变量的列名。\n\n**family** 是字符串标量，表示指数族分布的类型。它的取值可以是 guassian, poisson, gamma, inverseGuassian, binomial。\n\n**link** 是字符串标量，表示 *link* 函数的类型。对于不同取值的 *family*, *link* 的默认值如下表所示。\n\n**tolerance** 是浮点数，表示迭代中止的边界差值。如果相邻两次迭代的对数似然函数值的差值小于 *tolerance*，则停止迭代。默认值为0.000001。\n\n**maxIter** 是正整数，表示最大的迭代次数。默认值为100。\n\n*family* 参数对 *link* 参数、因变量的限制如下：\n\n| *family* 的取值    | *link* 可选值                             | 默认的 *link* 取值   | 因变量的取值    |\n| --------------- | -------------------------------------- | --------------- | --------- |\n| gaussian        | identity, inverse, log                 | identity        | DOUBLE 类型 |\n| poisson         | log, sqrt, identity                    | log             | 非负整数      |\n| gamma           | inverse, identity, log                 | inverse         | 大于等于0     |\n| inverseGaussian | nverseOfSquare, inverse, identity, log | inverseOfSquare | 大于等于0     |\n| binomial        | logit, probit                          | logit           | 0或1       |\n\n#### 详情\n\n训练广义线性模型。返回结果是一个字典，包含以下 key：coefficients, link, tolerance, family, xColNames, tolerance, modelName, residualDeviance, iterations 和 dispersion。其中，coefficients 是一张表，包括计算得到的自变量系数值、每个系数的标准误差、t 值、p 值；modelName 为 \"Generalized Linear Model\"；iterations 是实际迭代次数；dispersion 是模型的规范系数。\n\n#### 例子\n\n下面的例子使用模拟数据训练一个广义线性模型：\n\n```\nx1 = rand(100.0, 100)\nx2 = rand(100.0, 100)\nb0 = 6\nb1 = 1\nb2 = -2\nerr = norm(0, 10, 100)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(x1, x2, y)\nmodel = glm(sqlDS(<select * from t>), `y, `x1`x2, `gaussian, `identity);\nmodel;\n\n// output\ncoefficients->\n\nbeta     stdError tstat      pvalue\n-------- -------- ---------- --------\n1.027483 0.032631 31.487543  0\n-1.99913 0.03517  -56.842186 0\n5.260677 2.513633 2.092858   0.038972\n\nlink->identity\ntolerance->1.0E-6\nfamily->gaussian\nxColNames->[\"x1\",\"x2\"]\nmodelName->Generalized Linear Model\nresidualDeviance->8873.158697\niterations->5\ndispersion->91.475863\n```\n\n把模型用于预测：\n\n```\npredict(model, t);\n```\n\n把模型保存到磁盘：\n\n```\nsaveModel(model, \"C:/DolphinDB/Data/GLMModel.txt\");\n```\n\n把模型加载到内存中：\n\n```\nloadModel(\"C:/DolphinDB/Data/GLMModel.txt\");\n```\n"
    },
    "gmm": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gmm.html",
        "signatures": [
            {
                "full": "gmm(X, k, [maxIter=300], [tolerance=1e-4], [randomSeed], [mean], [sigma])",
                "name": "gmm",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "k",
                        "name": "k"
                    },
                    {
                        "full": "[maxIter=300]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "300"
                    },
                    {
                        "full": "[tolerance=1e-4]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "1e-4"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    },
                    {
                        "full": "[mean]",
                        "name": "mean",
                        "optional": true
                    },
                    {
                        "full": "[sigma]",
                        "name": "sigma",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [gmm](https://docs.dolphindb.cn/zh/funcs/g/gmm.html)\n\n\n\n#### 语法\n\ngmm(X, k, \\[maxIter=300], \\[tolerance=1e-4], \\[randomSeed], \\[mean], \\[sigma])\n\n#### 参数\n\n**X** 训练数据集。若为一元数据，则 *X* 是一个向量；若为多元数据，则 *X* 是一个矩阵或表，矩阵的每列代表一个样本数据。\n\n**k** 正整数。表示混合模型中子模型的数量。\n\n**maxlter** 正整数，表示最大的迭代次数。默认为 300。\n\n**tolerance** 浮点数，表示 EM 迭代中止的边界差值。如果相邻两次迭代的对数似然函数值的差值小于 *tolerance*，则停止迭代。默认为 1e-4。\n\n**randomSeed** 随机数种子。\n\n**mean** 可选参数，向量/矩阵。表示模型初始化的均值。若 *X* 为一元数据，则 *mean* 是元素个数为 *k* 的向量；若 *X* 为多元数据，则 *mean* 是列数为 *k*，行数与 *X* 的元数相同的矩阵。若不指定，系统随机从 *X* 中选择 *k* 个值作为模型的初始化均值。\n\n**sigma** 可选参数，向量/元组，元素个数为 *k*。若 *X* 为一元数据，表示每个子模型初始化的方差；若 *X* 为多元数据，表示每个子模型初始化的协方差矩阵。若不指定，系统使用 1 作为方差，或单位矩阵作为协方差矩阵。\n\n#### 详情\n\n通过数据集训练 GMM（高斯混合模型）。返回一个字典，包含以下键值：\n\n* modelName：字符串 \"Gaussian Mixture Model\"。\n\n* prior：观测数据属于各子模型的先验概率。\n\n* mean：训练获得的每个子模型的期望。\n\n* sigma：若 *X* 为 一元数据，表示训练获得的每个子模型的方差；若 *X* 为多元数据，表示训练获得的每个子模型的协方差矩阵。\n\n#### 例子\n\n```\ndataT = 6.8 7.2 5.3 9.4 6.5 11.2 25.6 0.6 8.9 4.3 2.2 1.9 8.7 0.2 1.5\nmean = [2, 2]\nre = gmm(dataT, 2, 300, 1e-4, 42, mean)\nre\n\n// output\nsigma->[36.759822,36.759822]\nmodelName->Gaussian Mixture Model\nprior->[0.5,0.5]\nmean->[6.686667,6.686667]\n\ndataT = transpose(matrix(3.2 1.5 2.6 7.8 6.3 4.2 5.1 8.9 11.2 25.8, 25.6 4.6 8.9 4.3 2.2 1.9 8.7 0.2 1.5 9.3))\nmean = transpose(matrix([1, 0], [0, 1]))\nre = gmm(dataT, 2, 300, 1e-4, 42, mean)\nre\n\n// output\nsigma->(#0        #1\n51.001369 18.273032\n18.273032 9.34789\n,#0       #1\n1.718475 0.629584\n0.629584 67.713701\n)\nmodelName->Gaussian Mixture Model\nprior->[0.558683,0.441317]\nmean->\n#0        #1\n11.152841 3.238262\n3.341493  10.996997\n```\n"
    },
    "gmtime": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gmtime.html",
        "signatures": [
            {
                "full": "gmtime(X)",
                "name": "gmtime",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [gmtime](https://docs.dolphindb.cn/zh/funcs/g/gmtime.html)\n\n\n\n#### 语法\n\ngmtime(X)\n\n#### 参数\n\n**X** 可以是 DATATIME, TIMESTAMP, NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n把本地时间 *X* 转换成零时区时间，即格林尼治时间（GMT）。\n\n#### 例子\n\n以下例子在美国东部时区执行：\n\n```\ngmtime(2018.01.22 10:20:26);\n\n// output\n2018.01.22T15:20:26\n\ngmtime(2017.12.16T13:30:10.008);\n\n// output\n2017.12.16T18:30:10.008\n```\n"
    },
    "gpFit": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gpfit.html",
        "signatures": [
            {
                "full": "gpFit(engine, [programNum=1], [programCorr=false])",
                "name": "gpFit",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "[programNum=1]",
                        "name": "programNum",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[programCorr=false]",
                        "name": "programCorr",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [gpFit](https://docs.dolphindb.cn/zh/funcs/g/gpfit.html)\n\n#### 语法\n\ngpFit(engine, \\[programNum=1], \\[programCorr=false])\n\n**Note:**\n\n社区版 License 暂不支持该函数，如需使用此功能，请联系技术支持。\n\n#### 详情\n\n查看训练生成的公式。函数返回一个表：\n\n* 第一列为 program 列，STRING 类型，用于存储得到的公式；\n* 第二列为 fitness 列，DOUBLE 类型，存储公式的适应度；\n* 当 programCorr 为 true 时，第三列为 programCorr 列，是DOUBLE 类型的数组向量，存储公式之间的相关性。\n\n#### 参数\n\n**engine** 通过函数 createGPLearnEngine 创建引擎的返回对象。\n\n**programNum** 整型标量，表示训练完返回的公式数量。\n\n**programCorr** 布尔标量，指示是否返回公式之间的相关性。\n\n#### 例子\n\n参考：[Shark GPLearn 快速上手](https://docs.dolphindb.cn/zh/tutorials/gplearn.html)。\n\n\n\n**Related information**\n\n[Shark GPLearn 快速上手](https://docs.dolphindb.cn/zh/tutorials/gplearn.html)\n"
    },
    "gpPredict": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gppredict.html",
        "signatures": [
            {
                "full": "gpPredict(engine, input, [programNum = 1], [groupCol], [deviceId=0])",
                "name": "gpPredict",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "input",
                        "name": "input"
                    },
                    {
                        "full": "[programNum = 1]",
                        "name": "[programNum = 1]"
                    },
                    {
                        "full": "[groupCol]",
                        "name": "groupCol",
                        "optional": true
                    },
                    {
                        "full": "[deviceId=0]",
                        "name": "deviceId",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [gpPredict](https://docs.dolphindb.cn/zh/funcs/g/gppredict.html)\n\n#### 语法\n\ngpPredict(engine, input, \\[programNum = 1], \\[groupCol], \\[deviceId=0])\n\n**Note:**\n\n社区版 License 暂不支持该函数，如需使用此功能，请联系技术支持。\n\n#### 详情\n\n采用上次训练得到的适应度函数较小的前 programNum 个公式用于预测。如果指定 groupCol，计算时还会依据 groupCol 分组。函数返回一个表，共 programNum 列，列名为 gpFit 训练得到的公式。\n\n#### 参数\n\n**engine**通过函数 createGPLearnEngine 创建引擎的返回对象。\n\n**input** 浮点型的表，表示需要预测的数据。\n\n**programNum** 整型标量，表示参与预测的公式数量，默认为 1。\n\n**groupCol** 字符型标量，表示进行分组的列名，默认为空。此列不会参与计算。\n\n**deviceId** INT类型的标量或向量。当前机器拥有多卡时，可以指定使用的设备 ID，默认为 0 。\n\n#### 例子\n\n参考：[Shark GPLearn 快速上手](https://docs.dolphindb.cn/zh/tutorials/gplearn.html)。\n\n\n\n**Related information**\n\n[Shark GPLearn 快速上手](https://docs.dolphindb.cn/zh/tutorials/gplearn.html)\n"
    },
    "gram": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gram.html",
        "signatures": [
            {
                "full": "gram(ds, [colNames], [subMean], [normalize])",
                "name": "gram",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "[colNames]",
                        "name": "colNames",
                        "optional": true
                    },
                    {
                        "full": "[subMean]",
                        "name": "subMean",
                        "optional": true
                    },
                    {
                        "full": "[normalize]",
                        "name": "normalize",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [gram](https://docs.dolphindb.cn/zh/funcs/g/gram.html)\n\n\n\n#### 语法\n\ngram(ds, \\[colNames], \\[subMean], \\[normalize])\n\n#### 参数\n\n**ds** 是一个或多个数据源，通常由 [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html) 生成。\n\n**colNames** 是字符串标量或向量，表示数据源中用于计算的列名。默认值是数据源中所有列的列名。\n\n**subMean** 是一个布尔值，表示每列是否减去该列的均值。默认值为 true。\n\n**normalize** 是一个布尔值，表示每列是否除以该列的标准差。默认值为 false。\n\n#### 详情\n\n计算数据源中对应列的数据的格拉姆矩阵。假设数据对应的矩阵为 A，返回的结果为 A 的转置与其自身的点积，即 A.tranpose() dot A。\n\n#### 例子\n\n```\nx = [7,1,1,0,5,2]\ny = [0.7, 0.9, 0.01, 0.8, 0.09, 0.23]\nt=table(x, y)\nds = sqlDS(<select * from t>);\ngram(ds);\n```\n\n| #0        | #1      |\n| --------- | ------- |\n| 37.333333 | -0.56   |\n| -0.56     | 0.75895 |\n"
    },
    "gramSchmidt": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gramSchmidt.html",
        "signatures": [
            {
                "full": "gramSchmidt(X, [normalize = false])",
                "name": "gramSchmidt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[normalize = false]",
                        "name": "[normalize = false]"
                    }
                ]
            }
        ],
        "markdown": "### [gramSchmidt](https://docs.dolphindb.cn/zh/funcs/g/gramSchmidt.html)\n\n\n\n#### 语法\n\ngramSchmidt(X, \\[normalize = false])\n\n#### 参数\n\n**X** 一个列满秩矩阵（每个列向量均线性无关），且不能包含空值。\n\n**normalize** 可选参数，一个布尔值，表示是否输出标准正交矩阵，默认值为 false。\n\n#### 详情\n\n将列满秩矩阵转换为一个列向量正交的矩阵。\n\n返回值：DOUBLE 类型矩阵。\n\n#### 例子\n\n```\nx = matrix([2 3 5, 3 6 2, 8 3 6]);\ngramSchmidt(x)\n\n// output\ncol1    col2    col3\n2.0000  1.2105  4.7932\n3.0000  3.3157  -2.1968\n5.0000  -2.4736 -0.5991\n\n// 指定 normalize=true，则输出标准正交矩阵。\ngramSchmidt(x, true)\n\n// output\ncol1    col2    col3\n0.3244      0.2808  0.9033\n0.4867      0.7693  -0.414\n0.8111      -0.5739 -0.1129\n\n\n// 矩阵的列向量线性相关时，则会报错\nx = matrix([1 4, 2 5, 3 6]);\ngramSchmidt(x)\n\n// output\nvector set must be linearly independent\n```\n"
    },
    "grant": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/grant.html",
        "signatures": [
            {
                "full": "grant(userId|groupId, accessType, [objs])",
                "name": "grant",
                "parameters": [
                    {
                        "full": "userId|groupId",
                        "name": "userId|groupId"
                    },
                    {
                        "full": "accessType",
                        "name": "accessType"
                    },
                    {
                        "full": "[objs]",
                        "name": "objs",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [grant](https://docs.dolphindb.cn/zh/funcs/g/grant.html)\n\n\n\n#### 语法\n\ngrant(userId|groupId, accessType, \\[objs])\n\n#### 参数\n\n**userId** | **groupId** 是表示用户名或组名的字符串。\n\n**accessType** 权限类型/内存限制。\n\n**objs** 标量或向量，表示权限类型的应用对象/约束规则。\n\n**Note:** 注：当 *accessType* 指定为 COMPUTE\\_GROUP\\_EXEC 时，*objs* 必须为对应的计算组名，或 \\*（表示所有计算组）。\n\n*accessType* 和 *objs* 的取值请参照 [用户权限管理](https://docs.dolphindb.cn/zh/tutorials/ACL_and_Security.html) 权限类型表。\n\n#### 详情\n\n`grant` 函数执行以下操作：\n\n* 授予某个用户或某个用户组权限。当 *accessType* = DB\\_OWNER 时，还支持约束某个用户只能创建指定前缀的数据库。\n* 约束某个用户查询返回结果的内存上限（指定 *accessType* = QUERY\\_RESULT\\_MEM\\_LIMIT）和发送的批量子查询占用的内存上限（指定 *accessType* = TASK\\_GROUP\\_MEM\\_LIMIT）。其功能等效于 [setMemLimitOfQueryResult](https://docs.dolphindb.cn/zh/funcs/s/setMemLimitOfQueryResult.html) 函数和 [setMemLimitOfTaskGroupResult](https://docs.dolphindb.cn/zh/funcs/s/setMemLimitOfTaskGroupResult.html) 函数，区别在于 `grant` 只对指定用户生效（暂不支持用户组），`setMemLimitOfQueryResult` 函数和 `setMemLimitOfTaskGroupResult` 函数对所有用户生效。\n\n管理员可以通过该命令赋予用户所有权限（*accessType*），但普通用户在拥有相关的 OWNER 权限后，只能通过该命令赋予以下权限：TABLE\\_READ, TABLE\\_WRITE, TABLE\\_INSERT, TABLE\\_UPDATE, TABLE\\_DELETE, DB\\_READ, DB\\_WRITE, DB\\_INSERT, DB\\_UPDATE, DB\\_DELETE, DBOBJ\\_DELETE, DBOBJ\\_CREATE 和 VIEW\\_EXEC。\n\n**Note:** 该函数可在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n授予组 \"research\" 的所有成员读取所有数据库表的权限：\n\n```\ngrant(`research, TABLE_READ, \"*\")\n```\n\n授予组 \"research\" 的所有成员读写表 `dfs://db1/t1` 的权限：\n\n```\ngrant(`research, TABLE_WRITE, \"dfs://db1/t1\")\n```\n\n授予组 \"research\" 的所有成员在数据库 `dfs://db1` 和 `dfs://db2` 创建表的权限：\n\n```\ngrant(\"research\", DBOBJ_CREATE, [\"dfs://db1\",\"dfs://db2\"])\n```\n\n授予用户 \"AlexSmith\" 删除数据库的权限：\n\n```\ngrant(\"AlexSmith\", DB_MANAGE)\n```\n\n授予用户\"AlexSmith\"执行脚本的权限：\n\n```\ngrant(\"AlexSmith\", SCRIPT_EXEC)\n```\n\n授予用户 \"AlexSmith\" 测试脚本的权限：\n\n```\ngrant(\"AlexSmith\", TEST_EXEC)\n```\n\n授予用户”AlexSmith”命名空间 test1下函数 f1 的执行权限：\n\n```\ngrant(\"AlexSmith\", VIEW_EXEC, \"test1::f1\")\n```\n\n授予用户”AlexSmith”命名空间 test2 下所有函数的执行权限：\n\n```\ngrant(\"AlexSmith\", VIEW_EXEC, \"test2::*\")\n```\n\n命名空间必须是模块级别。例如有一个模块 *test.dos*，所在路径为 `moduleDir/mod1/test.dos`，为用户授权执行模块中所有函数时，应通过以下脚本实现：\n\n```\ngrant(\"AlexSmith\", VIEW_EXEC, \"mod1::test::*\")\n```\n\n不支持写成：\n\n```\ngrant(\"AlexSmith\", VIEW_EXEC, \"mod1::*\")\n```\n\n如果授权了某个命名空间，后来命名空间中的函数视图被通过 `dropFunctionView` 删除，一旦命名空间中的最后一个函数视图被删除，对该命名空间的授权也将自动回收。同理，授权时如果发现该命名空间下没有函数视图，会抛出异常。\n\n对于没有命名空间的函数视图，被认为是全局的。以下两种方式等价：\n\n```\ngrant(\"AlexSmith\", VIEW_EXEC, \"::f\")\ngrant(\"AlexSmith\", VIEW_EXEC, f)\n```\n\n约束用户查询所占用的内存：\n\n指定 *accessType* 为 QUERY\\_RESULT\\_MEM\\_LIMIT，此时 *objs* 表示限制的内存大小，单位为 GB。下述脚本限制用户 \"AlexSmith\" 查询时，查询结果所占用的内存大小不能超过 4 GB。\n\n```\ngrant(\"AlexSmith\", QUERY_RESULT_MEM_LIMIT, 4)\n```\n\n约束用户只能创建指定前缀的数据库：\n\n假设管理员要求限制用户 \"AlexSmith\" 只能创建并管理以 ddb 作为库名前缀的数据库，可以通过以下脚本实现：\n\n```\ngrant(\"AlexSmith\", DB_OWNER, \"dfs://ddb*\")\n```\n\n当指定 `grant` 函数的 *accessType* 为 DB\\_OWNER 时，可以指定 *objs* 为一个规则，目前仅支持约束用户可以创建的库名前缀，便于不同用户管理不同范围的数据库。\n\n当需要指定多个规则时，可以为 objs 传入一个向量，如下脚本所示：\n\n```\ngrant(\"AlexSmith\", DB_OWNER, [\"dfs://ddb_prefix1*\",\"dfs://ddb_prefix2*\"])\n```\n\n授权时，如果当前已有全局授权，则对某一前缀规则的授权将无效。如果前缀规则之间存在包含关系，则这些规则不会相互覆盖。\n\n当用户创建或管理数据库时，如有全局禁止，则禁止执行，否则，用户的权限为所有前缀规则的并集，即如果库名符合已授权的任一前缀规则，则允许执行。已授权的前缀规则可以通过函数 `getUserAccess` 查看。\n\n**Note:** 特定的前缀约束规则，只能通过 `grant` 指定、通过 `revoke` 移除，但不能通过 `deny` 禁止。当 *accessType* 为 DB\\_OWNER 时，`deny` 只能对全局生效，且会覆盖之前已有的前缀约束规则。\n"
    },
    "groups": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/groups.html",
        "signatures": [
            {
                "full": "groups(X, [mode='dict'])",
                "name": "groups",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[mode='dict']",
                        "name": "mode",
                        "optional": true,
                        "default": "'dict'"
                    }
                ]
            }
        ],
        "markdown": "### [groups](https://docs.dolphindb.cn/zh/funcs/g/groups.html)\n\n\n\n#### 语法\n\ngroups(X, \\[mode='dict'])\n\n#### 参数\n\n**X** 是一个向量。\n\n**mode** 可选参数，用于指定 `groups` 返回值的数据形式，默认为 \"dict\"。可指定为以下值：\n\n* \"dict\"：返回一个字典。字典的 key 存储 *X* 中的独特值（unique value）；字典的 value 为一个向量，存储该值在 *X* 中对应的下标。\n\n* \"table\"：返回一个包含两列的表。字段为 \"key\" 和 \"index\"，分别存储 *X* 中的独特值和其在 *X* 中对应的下标。\n\n* \"vector\"：返回一个 array vector，按照 *X* 中独特值升序排列，存储每个独特值在 *X* 中对应的下标。\n\n* \"tuple\"：返回一个 tuple，其存储方式同 *mode*=\"vector\"。\n\n#### 详情\n\n对 *X* 中每一个独特值，列出其在 *X* 中的所有对应数据的下标。\n\n若 *mode* = 'dict'，返回一个字典；若 *mode* = 'table'，返回一个数据表，其中 index 列表示下标，为数组向量类型。\n\n#### 例子\n\n```\nx=NULL NULL 12 15 12 16 15 14 NULL NULL\ngroups(x);\n\n// output\n16->[5]\n->[0,1,8,9]\n12->[2,4]\n14->[7]\n15->[3,6]\n\ngroups\\(x, \"vector\"\\)\n// output\n\\[\\[0,1,8,9\\],\\[2,4\\],\\[7\\],\\[3,6\\],\\[5\\]\\]\n\ngroups\\(x, \"tuple\"\\)\n// output\n\\(\\[0,1,8,9\\],\\[2,4\\],\\[7\\],\\[3,6\\],\\[5\\]\\)\n\ngroups\\(x, \"table\"\\)\n```\n\n| key | index    |\n| --- | -------- |\n|     | \\[0,1,8] |\n| 2   | \\[2,4]   |\n| 4   | \\[7]     |\n| 5   | \\[3,6]   |\n| 6   | \\[5]     |\n"
    },
    "gt": {
        "url": "https://docs.dolphindb.cn/zh/funcs/g/gt.html",
        "signatures": [
            {
                "full": "gt(X, Y)",
                "name": "gt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [gt](https://docs.dolphindb.cn/zh/funcs/g/gt.html)\n\n\n\n#### 语法\n\ngt(X, Y)或 X>Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量、矩阵或集合。如果 *X* 或 *Y* 的其中一个是数据对、向量或矩阵，另一个必须是一个标量，或具有相同长度或维度的数据对、向量或矩阵。\n\n#### 详情\n\n如果 *X* 和 *Y* 都不是集合，返回逐个元素比较 *X*>*Y* 的结果。\n\n如果 *X* 和 *Y* 都是集合，则检查 *Y* 是否为 *X* 的真子集。\n\n#### 例子\n\n```\n1 2 3 > 2;\n// output\n[0,0,1]\n\n1 2 3>0 2 4;\n// output\n[1,0,0]\n\n2:3>1:6;\n// output\n1 : 0\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 gt 4;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 0  | 1  |\n| 0  | 0  | 1  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1>m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 0  | 0  | 1  |\n| 0  | 1  | 1  |\n\n集合操作：如果 *X*>*Y*，则 *Y* 是 *X* 的真子集。\n\n```\nx=set(4 6);\nx;\n\nset(6,4)\n\ny=set(8 9 4 6);\ny;\n\nset(6,4,9,8)\ny>x;\n// output\n1\n\nx>y;\n// output\n0\n\nx>x;\n// output\n0\n# x 不是 x 的真子集\n```\n"
    },
    "accumulate": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/accumulate.html",
        "signatures": [
            {
                "full": "accumulate(func, X, [init], [consistent=false])",
                "name": "accumulate",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "func:A([init], X)",
                "name": "func:A",
                "parameters": [
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            },
            {
                "full": "func:AC([init], X)",
                "name": "func:AC",
                "parameters": [
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [accumulate](https://docs.dolphindb.cn/zh/funcs/ho_funcs/accumulate.html)\n\n\n\n#### 语法\n\naccumulate(func, X, \\[init], \\[consistent=false])\n\n或\n\nfunc:A(\\[init], X)（表示 consistent 为 false）\n\n或\n\nfunc:AC(\\[init], X)（表示 consistent 为 true）\n\n或\n\n\\[func:AC(\\[init], X )\n\n或\n\n\\[init] \\<operator>:AC X （表示 consistent 为 true）\n\n#### 参数\n\n*func*：函数。\n\n* 当 *func* 是一元函数时，*X* 可以是非负整数、一元函数或空值。*init* 表示 *func* 的参数，必须指定。\n\n* *func* 是二元函数时，*X* 是向量、矩阵或表。*init* 表示初始值。\n\n* *func* 是三元函数时，*X* 必须是一个 Tuple，包含2个元素，分别表示 *func* 的后两个参数。\n\n*consistent*：布尔值，默认 false，表示每次迭代输出的数据类型由实际计算结果决定。否则，每次迭代输出的数据类型将与第一次迭代输出值的数据类型保持一致。 注意，若迭代结果的数据形式不一致，只能指定 *consistent* = false，否则会报错。\n\n其他相关的 cum 系列函数的参数说明和窗口计算规则请参考: [累计窗口系列（cum 系列）](https://docs.dolphindb.cn/zh/funcs/themes/cumFunctions.html)\n\n#### 详情\n\n* 当 func 是一元函数时，accumulate 先输出 *init*，再应用 *func* 在 *init* 上，然后迭代地应用 *func* 到前一个结果上，直至满足 *X* 指定地迭代条件后输出结果。\n\n* *X* 为整数时，表示 *func* 进行迭代的次数，输出结果包含 *X* + 1 个元素。注意，X 为负数时，将按0处理。\n\n* *X* 为一元函数时，表示终止条件，返回结果必须为一个布尔标量。若 *X* 应用在前一个结果上的返回值为 true，*func* 继续迭代；否则，*func* 停止迭代。\n\n* *X* 没有设置或为 NULL，*func* 将进行迭代计算直至输出的结果与前一个结果相同时停止迭代。\n\n* 当 *func* 是二元函数时，accumulate 先应用函数 / 运算符在 *init* 和 *X\\[0]* 上，再迭代地应用函数 / 运算符在前一个结果和当前元素上。当 *init* 缺失时，accumulate 返回值的第一个元素是 *X\\[0]*。accumulate 等同于下面伪代码的执行过程：\n\n  ```\n  result[0]=iif(init==NULL,X[0],<function>(init,X[0]));\n\n  for(i:1~size(X)-1){\n      result[i]=<function>(result[i-1], X[i]);\n  }\n\n  return result;\n  ```\n\n* 当 *func* 是三元函数时，其迭代规则等同于二元函数。\n\n  与 [reduce](https://docs.dolphindb.cn/zh/funcs/ho_funcs/reduce.html) 返回最后一个结果不同，accumulate 输出所有中间结果。\n\n#### 例子\n\n当*func* 是一元函数时：\n\n通过以下方式定义一个一元函数：\n\n```\ndef func1(x){\n  if(x<5){\n          return x*3\n  }\n  else{\n          return x+3\n  }\n}\n```\n\n当 X 为整数时，输出结果长度为 X + 1：\n\n```\naccumulate(func1, 5, 1)\n```\n\n返回：\\[1,3,9,12,15,18]。\n\n当 X 为一元函数 condition 时，第3次迭代时因 condition 返回 false，停止迭代并输出前 2 次的迭代结果。\n\n```\ndef condition(x){\n  return x<9\n}\naccumulate(func1, condition, 1)\n```\n\n返回：\\[1,3,9]。\n\n当 X 为 NULL（或不指定）时，自定义函数 func2 作为迭代的函数。由于第 4 次迭代结果和第 3 次相同，停止迭代并输出前 3 次迭代结果。\n\n```\ndef func2(x){\n  if(x<5){\n          return x*3\n  }\n  else{\n          return 6\n  }\n}\n\naccumulate(func2,NULL,1)\n```\n\n返回：\\[1,3,9,6]。\n\n*func* 是二元函数时，在一个向量上执行 accumulate：\n\n```\nx = 1 2 3;\naccumulate(add, 1 2 3);\n```\n\n返回：\\[1,3,6]。这样的运算等同于 \\[1, 1+2, 3+3]。\n\n```\n1 +:A x;\n```\n\n返回：\\[2,4,7]。这样的运算等同于 \\[1+1, 2+2, 4+3]。\n\n```\naccumulate(-, x, 2);\n```\n\n返回：\\[1,-1,-4]。这样的运算等同于 \\[2-1, 1-2, -1-3]。\n\n```\naccumulate(mul, x);\n```\n\n返回：\\[1,2,6]。这样的运算等同于 \\[1, 1\\*2, 2\\*3]。\n\n通过以下方式计算累积因式分解：\n\n```\ndef facts(a) {return 1*:A 1..a;};\nfacts 5;\n```\n\n返回：\\[1,2,6,24,120]\n\n通过以下方式计算 log(1) 到 log(i) 之间的累加和。其中，第一行的结果用作第二行 `accumulate` 的第一个参数值：\n\n```\ndef f1(a,b): a+log(b);\naccumulate(f1, 1..5, 0);\n```\n\n返回：\\[0,0.693147,1.791759,3.178054,4.787492]。这等同于：`0+log(1)=0, 0+log(2)=0.693147, 0.693147+log(3)=1.791759, ......`\n\n在下面这个例子中，由于忽略了初始条件，输入向量的第一个元素的数据类型决定了返回值的数据类型。\n\n```\naccumulate(f1, 1..5);\n```\n\n返回：\\[1,1.693147,2.791759,4.178053,5.787491]。\n\n对一个矩阵执行 `accumulate`:\n\n```\nx=1..12$3:4;\nx;\n```\n\n得到：\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 1    | 4    | 7    | 10   |\n| 2    | 5    | 8    | 11   |\n| 3    | 6    | 9    | 12   |\n\n```\n+ :A x;\n```\n\n得到：\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 1    | 5    | 12   | 22   |\n| 2    | 7    | 15   | 26   |\n| 3    | 9    | 18   | 30   |\n\n*func* 是三元函数时：\n\n```\ndef fun3(x,y,z){\n  return x+y+z\n}\naccumulate(fun3,[[1,2,3],[10,10,10]],5)\n```\n\n返回：\\[16,28,41]。\n"
    },
    "aggrTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/aggrTopN.html",
        "signatures": [
            {
                "full": "aggrTopN(func, funcArgs, sortingCol, top, [ascending=true])",
                "name": "aggrTopN",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "sortingCol",
                        "name": "sortingCol"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [aggrTopN](https://docs.dolphindb.cn/zh/funcs/ho_funcs/aggrTopN.html)\n\n\n\n#### 语法\n\naggrTopN(func, funcArgs, sortingCol, top, \\[ascending=true])\n\n#### 参数\n\n* **func** 必须是一个聚合函数。\n\n* **funcArgs** 是 *func* 的参数，可以是标量或向量。 *func* 有多个参数时，它是一个元组。\n\n* **sortingCol** 是一个数值类型或时间类型的向量，提供 *funcArgs* 的排序指标。\n\n* **top** 可以是整数或者浮点数。\n\n  * 如果是整数，表示选取的前 *top* 行数据；\n\n  * 如果是浮点数，表示百分比，必须小于1.0。根据 *funcArgs* 的总行数 *top* 来确定需要选取的行数。若结果不是整数，则向下取整，至少取一行。\n\n* **ascending** 是一个布尔值，表示是否按升序排序。 默认值是 true。\n\n其他相关 TopN 系列函数参数说明和窗口计算规则请参考: [TopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 详情\n\n将 *sortingCol* 根据 *ascending* 指定方式进行排序后，得到 *funcArgs* 中对应的前 *top* 个元素，使用 *func* 指定的聚合函数进行计算。*sortingCol* 包含的 NULL 值当作最小值处理。\n\n#### 例子\n\n```\naggrTopN(func=sum, funcArgs=1 2 3 4 5, sortingCol=5 1 2 3 4, top=3, ascending=false)\n// output\n10\n\naggrTopN(func=corr,funcArgs=[1..5, 3 9 4 2 5], sortingCol=2 3 4 5 3, top=3)\n// output\n0.052414\n```\n\n*top* =3，aggrTopN严格取前3个元素进行计算，下例中有3个3对应第三位，只取满足 *top* 数量的值进行计算\n\n```\naggrTopN(func=min,funcArgs=1 6 4 -6 4 5, sortingCol=2 3 3 3 4 5, top=3)\n// output\n1\n```\n\n计算每个股票每天最大交易量前25%的交易平均价格。\n\n```\nt = table(`A`A`A`B`B`B`B`B`B`B`B as sym, 09:30:06 09:30:28 09:31:46 09:31:59 09:30:19 09:30:43 09:31:23 09:31:56 09:30:44 09:31:25 09:31:57 as time, 10 20 10 30 20 40 30 30 30 20 40 as volume, 10.05 10.06 10.07 10.05 20.12 20.13 20.14 20.15 20.12 20.13 20.16 as price);\nt;\n```\n\n| sym | time     | volume | price |\n| --- | -------- | ------ | ----- |\n| A   | 09:30:06 | 10     | 10.05 |\n| A   | 09:30:28 | 20     | 10.06 |\n| A   | 09:31:46 | 10     | 10.07 |\n| B   | 09:31:59 | 30     | 10.05 |\n| B   | 09:30:19 | 20     | 20.12 |\n| B   | 09:30:43 | 40     | 20.13 |\n| B   | 09:31:23 | 30     | 20.14 |\n| B   | 09:31:56 | 30     | 20.15 |\n| B   | 09:30:44 | 30     | 20.12 |\n| B   | 09:31:25 | 20     | 20.13 |\n| B   | 09:31:57 | 40     | 20.16 |\n\n```\nselect aggrTopN(func=avg, funcArgs=price, sortingCol=volume, top=0.25, ascending=false) from t group by sym, time\n```\n\n| sym | time     | aggrTopN\\_avg |\n| --- | -------- | ------------- |\n| A   | 09:30:06 | 10.05         |\n| A   | 09:30:28 | 10.06         |\n| A   | 09:31:46 | 10.07         |\n| B   | 09:30:19 | 20.12         |\n| B   | 09:30:43 | 20.13         |\n| B   | 09:30:44 | 20.12         |\n| B   | 09:31:23 | 20.14         |\n| B   | 09:31:25 | 20.13         |\n| B   | 09:31:56 | 20.15         |\n| B   | 09:31:57 | 20.16         |\n| B   | 09:31:59 | 10.05         |\n"
    },
    "byColumn": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/byColumn.html",
        "signatures": [
            {
                "full": "byColumn(func, X, [Y])",
                "name": "byColumn",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            },
            {
                "full": "func:V(X)",
                "name": "func:V",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            },
            {
                "full": "func:V(X, [Y])",
                "name": "func:V",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [byColumn](https://docs.dolphindb.cn/zh/funcs/ho_funcs/byColumn.html)\n\n\n\n#### 语法\n\nbyColumn(func, X, \\[Y])\n\n或\n\nfunc:V(X)\n\n或\n\nfunc:V(X, \\[Y])\n\n#### 参数\n\n* **func** 一个单目函数，支持以部分应用的形式传入。该函数可以是向量函数（输入与输出为等长的向量），亦可为聚合函数。\n\n* **X** 一个矩阵、表、元组、数组向量、列式元组。\n\n* **Y** 矩阵、表、元组、数组向量、列式元组。\n\n#### 详情\n\n*func* 为单目函数时，对 *X* 的每一列应用指定函数；*func* 为双目函数时，对 *X* 和 *Y* 的每列执行 func(Xi, Yi) 。\n\n同时指定 X 和 Y 时，则对 X 和 Y 的每列执行 func(Xi, Yi) 。\n\n支持在响应式状态引擎中使用 `byColumn` 函数。\n\n**计算规则**：\n\n* 如果 *X/Y*是矩阵、表或元组，byColumn 对 X/Y 的每一列数据应用指定的函数。\n\n* 如果 X/Y 是数组向量或列式元组：byColumn 首先将对象转置，然后对转置后的对象的每一行应用指定函数。\n\n  * 当 *func* 是向量函数时，byColumn 会把 *func* 的计算结果转置后输出。\n\n  * 当 *func* 是聚合函数时，输出结果是一个向量。特别地，当 *func* 是以下聚合函数时，由于 byColumn 不对 X/Y 进行转置，从而提高了计算性能：sum, sum2, avg, min, max, count, imax, imin, imaxLast, iminLast, prod, std, stdp, var, varp, skew, kurtosis, any, all, corr, covar, wavg, wsum, beta, euclidean, dot, tanimoto\n\n**返回值**：\n\n* 当 *func* 是聚合函数时，\n\n  * 如果 *X/Y*是矩阵、数组向量或列式元组，则输出结果是一个向量。向量的长度与 *X/Y*的列数相同。\n\n  * 如果 *X/Y*是元组，则输出结果是一个元组。\n\n  * 如果 *X/Y*是表，则输出结果是一个表。\n\n* 当 *func* 是向量函数时，输出结果的形式、维度和 *X/Y*的形式、维度相同。\n\n#### 计算规则\n\n* 如果 *X/Y*是矩阵、表或元组，byColumn 对 X/Y 的每一列数据应用指定的函数。\n\n* 如果 X/Y 是数组向量或列式元组：byColumn 首先将对象转置，然后对转置后的对象的每一行应用指定函数。\n\n  * 当 *func* 是向量函数时，byColumn 会把 *func* 的计算结果转置后输出。\n\n  * 当 *func* 是聚合函数时，输出结果是一个向量，无需进行转置操作。特别地，当 *func* 是以下聚合函数时，byColumn 进行了优化，不会对 *X*/*Y* 进行上步的转置操作，从而提高了计算性能：sum, sum2, avg, min, max, count, imax, imin, imaxLast, iminLast, prod, std, stdp, var, varp, skew, kurtosis, any, all, corr, covar, wavg, wsum, beta, euclidean, dot, tanimoto。\n\n#### 例子\n\n对于不支持矩阵运算的单目向量函数，通过 `byColumn` 进行按列计算，等效于 `each`。\n\n```\ndef myvfunc(x): var(x).log()\nm = matrix(1.1 2.3 2.1 3.5 4.2, 3.3 2.5 4.2 5.1 0, -1 3.3 2 1.7 2.3)\nbyColumn(myvfunc, m)\n```\n\n输出返回： \\[0.3974329364109,1.334211281249665,0.945072533299607]\n\n传入多元函数时，需要把该函数的其他参数通过部分应用进行固定，然后传入 `func`。\n\n```\nbyColumn(autocorr{,2},m)\n```\n\n返回：\\[-0.05,-0.28,-0.06]\n\n输出返回：\n\n```\ncol1 col2 col3\n3.1  5.3  1\n4.3  4.5  5.3\n4.1  6.2  4\n5.5  7.1  3.7\n6.2  2    4.3\n```\n\n```\nbyColumn(add{1 2 3 4 5}, m)\n```\n\n输出返回：\n\n```\ncol1 col2 col3\n2.1  4.3  0\n4.3  4.5  5.3\n5.1  7.2  5\n7.5  9.1  5.7\n9.2  5    7.3\n```\n\n`func` 是一个自定义函数。\n\n```\ndef my_func(x){\n   return iif(x > 0, 1, -1)\n}\nm = matrix(3 -6 5 0, 2 -9 -4 5)\nbyColumn(my_func, m)\n```\n\n输出返回：\n\n```\ncol1 col2\n 1    1\n-1   -1\n 1    -1\n-1    1\n```\n\n`func` 是一个嵌套函数。\n\n```\nm = matrix(1 5 3 , 7 5 2)\nbyColumn(accumulate{def (x, y):iif(x > 5, y-1, y+1), ,1}, m)\n```\n\n输出返回：\n\n```\ncol1 col2\n2    8\n6    4\n2    3\n```\n\n入参是矩阵：\n\n```\nm=matrix([1 3 4 2,1 2 2 1])\nmax:V(m)\n[4,2]\n\ncummax:V(m)\n\ncol1\tcol2\n1\t1\n3\t2\n4\t2\n4\t2\n\nn=matrix([11 5 9 2,8 5 3 2])\ncorr:V(m,n)\n[-0.09,-0.21]\n\n```\n\n入参是表：\n\n```\nqty1 = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nqty2 = 2100 1800  6800 5400 1300 2400 8500 4100 3200\nt = table(qty1, qty2);\nmax:V(t) \n\nqty1\tqty2\n8,800\t8,500\n\ncummax:V(t) \n\nqty1\tqty2\n2,200\t2,100\n2,200\t2,100\n2,200\t6,800\n3,200\t6,800\n6,800\t6,800\n6,800\t6,800\n6,800\t8,500\n6,800\t8,500\n8,800\t8,500\n\n\nqty3 = 7800 5400 5300 2500 1800 2200 3900 3100 1200\nqty4 = 3200 2800 6400 8300 2300 3800 2900 1600 2900\nt1 = table(qty3, qty4);\n\ncorr:V(t,t1)   \n\nqty1\tqty2\n-0.7267\t0.4088\n\n```\n\n入参是元组：\n\n```\ntp=[1 3 4 2,1 2 2 1]\nsum:V(tp)  \n(10,6) \n\ncummax:V(tp) \n([1,3,4,4],[1,2,2,2]) \n\ntp1=[11 23 14 21,10 12 32 21]\n\ncorr:V(tp,tp1)  \n(0.25,0.37)\n```\n\n入参是数组向量：\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5 4, 6 7 8, 1 9 10]);\nsum:V(a) \n[12,23,25] \n\ncummax:V(a)\n[[1,2,3],[4,5,4],[6,7,8],[6,9,10]]\n\nb=array(DOUBLE[], 0, 10).append!([11.8 21.2 23.9, 83.3 90.2 78.2, 86.5 52 36.5, 10.1 12.4 16.8])\ncorr:V(a,b)  \n\n[0.95,-0.13,-0.46]\n```\n\n入参是列式元组：\n\n```\nctp=[1 3 4 2,1 2 2 1]\nctp.setColumnarTuple!()\nsum:V(ctp)  \n[2,5,6,3]\n\ncummax:V(ctp)\n([1,3,4,2],[1,3,4,2])\n\nctp1=[11 23 14 21,10 12 32 21]\nctp1.setColumnarTuple!()\n\ncorr:V(ctp,ctp1) \n[,1,-1,]\n```\n\n**Related information**\n\n[byRow](https://docs.dolphindb.cn/zh/funcs/ho_funcs/byRow.html)\n"
    },
    "byRow": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/byRow.html",
        "signatures": [
            {
                "full": "byRow(func, X, [Y])",
                "name": "byRow",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            },
            {
                "full": "func:H(X)",
                "name": "func:H",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            },
            {
                "full": "func:H(X, [Y])",
                "name": "func:H",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [byRow](https://docs.dolphindb.cn/zh/funcs/ho_funcs/byRow.html)\n\n\n\n#### 语法\n\nbyRow(func, X, \\[Y])\n\n或\n\nfunc:H(X)\n\n或\n\nfunc:H(X, \\[Y])\n\n#### 参数\n\n**func** 是一个函数。该函数可以是向量函数（输入与输出均为等长向量），亦可为聚合函数。\n\n**X** 是一个矩阵、表、元组、数组向量、列式元组。\n\n**Y** 可以是矩阵、表、元组、数组向量或列式元组。\n\n其他相关的 row 系列函数的参数说明和窗口计算规则请参考: [行计算系列（row 系列）](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n*func* 为单目函数时，对矩阵 *X* 的每一行应用指定函数。\n\n*func* 为双目函数时，对 *X* 和 *Y* 的每行执行 func(Xi, Yi) 。\n\n**计算规则**\n\n* 如果 *X/Y*是矩阵、表或元组：byRow 首先将对象转置，然后对转置后的对象的每一列应用指定函数。\n\n  * 当 *func* 是向量函数时，byRow 会把 *func* 的计算结果转置后输出。\n\n  * 当 *func* 是聚合函数时，输出结果是一个向量，无需进行转置操作。特别地，当 *func* 是以下聚合函数时，byRow 进行了优化，不会对 *X*/*Y* 进行上步的转置操作，从而提高了计算性能：sum, sum2, avg, min, max, count, imax, imin, imaxLast, iminLast, prod, std, stdp, var, varp, skew, kurtosis, any, all, corr, covar, wavg, wsum, beta, euclidean, dot, tanimoto。\n\n* 如果 X/Y 是数组向量或列式元组，byRow 对 X/Y的每一行数据应用指定函数。\n\n**返回值**\n\n* 当 *func* 是聚合函数时，输出结果是一个向量。向量的长度与 *X/Y*的行数相同。\n\n* 当 *func* 是向量函数时，输出结果的形式、维度和 *X/Y*的形式、维度相同。\n\n**Note:** 通过 byRow 函数，可以实现与内置 row 系列函数相同的功能，并且计算结果和性能与 row 系列函数相同。例如 byRow(sum, X) 等效于 rowSum(X)。因此 byRow 函数可以应用于所有需要进行行计算的场景中。\n\n#### 例子\n\n入参是矩阵：\n\n```\nm=matrix([1 3 4 2,1 2 2 1])\nmax:H(m)\n[1,3,4,2]\n\ncummax:H(m) \n\ncol1\tcol2\n1\t1\n3\t3\n4\t4\n2\t2\n\nn=matrix([11 5 9 2,8 5 3 2])\ncorr:H(m,n)\n[,,1,]\n```\n\n入参是表：\n\n```\nqty1 = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nqty2 = 2100 1800  6800 5400 1300 2400 8500 4100 3200\nt = table(qty1, qty2);\nmax:H(t) \n[2200,1900,6800,5400,6800,5400,8500,4100,8800]\n\ncummax:H(t) \n\nqty1\tqty2\n2,200\t2,200\n1,900\t1,900\n2,100\t6,800\n3,200\t5,400\n6,800\t6,800\n5,400\t5,400\n1,300\t8,500\n2,500\t4,100\n8,800\t8,800\n\nqty3 = 7800 5400 5300 2500 1800 2200 3900 3100 1200\nqty4 = 3200 2800 6400 8300 2300 3800 2900 1600 2900\nt1 = table(qty3, qty4);\ncorr:H(t,t1)   \n[1,1,1,1,-1,-1,-1,-1,-1]\n```\n\n入参是元组：\n\n```\ntp=[1 3 4 2,1 2 2 1]\nsum:H(tp)  \n[2,5,6,3] \n\ncummax:H(tp) \n([1,3,4,2],[1,3,4,2]) \n\ntp1=[11 23 14 21,10 12 32 21]\ncorr:H(tp,tp1)  \n[,1,-1,]\n```\n\n入参是数组向量：\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5 4, 6 7 8, 1 9 10]);\nsum:H(a) \n[6,13,21,20] \n\ncummax:H(a)\n[[1,2,3],[4,5,5],[6,7,8],[1,9,10]]\n\nb=array(DOUBLE[], 0, 10).append!([11.8 21.2 23.9, 83.3 90.2 78.2, 86.5 52 36.5, 10.1 12.4 16.8])\ncorr:H(a,b)  \n[0.95,0.90,-0.97,0.82]\n```\n\n入参是列式元组：\n\n```\nctp=[1 3 4 2,1 2 2 1]\nctp.setColumnarTuple!()\nsum:H(ctp)  \n[10,6]\n\ncummax:H(ctp)\n([1,3,4,4],[1,2,2,2])\n\nctp1=[11 23 14 21,10 12 32 21]\nctp1.setColumnarTuple!()\n\ncorr:H(ctp,ctp1)\n[0.25, 0.37]\n```\n\n```\nm=matrix(1 1, 2 3, 2 1);\nm;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 2    | 2    |\n| 1    | 3    | 1    |\n\n```\nbyRow(add{10 20 30},m);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 11   | 22   | 32   |\n| 11   | 23   | 31   |\n\n```\nbyRow(mode,m);\n// output\n[2,1]\n```\n\n```\nb=array(DOUBLE[], 0, 10).append!([11.8 21.2 23.9, 83.3 90.2 78.2 86.5, 10.1 12.4 16.8])\nbyRow(add{100},b)\n// output\n[111.8 121.2 123.9,183.3 190.2 178.2 86.5,110.1 112.4 116.8]\nbyRow(imax,b)\n// output\n[2,1,2]\n```\n"
    },
    "call": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/call.html",
        "signatures": [
            {
                "full": "call(func, args...)",
                "name": "call",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [call](https://docs.dolphindb.cn/zh/funcs/ho_funcs/call.html)\n\n\n\n#### 语法\n\ncall(func, args...)\n\n#### 参数\n\n* **func** 是一个函数名。\n\n* **args** 是函数func的参数。\n\n#### 详情\n\n用指定的参数调用一个函数。常常用在 [each](https://docs.dolphindb.cn/zh/funcs/ho_funcs/each.html)/[peach](https://docs.dolphindb.cn/zh/funcs/ho_funcs/peach.html) 或 [loop](https://docs.dolphindb.cn/zh/funcs/ho_funcs/loop.html)/[ploop](https://docs.dolphindb.cn/zh/funcs/ho_funcs/ploop.html) 中，用来调用一批函数。\n\n#### 例子\n\n```\ncall(sum, 1..10);\n// output\n55\n// 等同于sum(1..10)\n\neach(call, [avg, sum], [0..10, 0..100]);\n// output\n[5,5050]\n\neach(call{, 1..3},(sin,log));\n// 注意call{, 1..3}是一个部分应用\n```\n\n| sin      | log      |\n| -------- | -------- |\n| 0.841471 | 0        |\n| 0.909297 | 0.693147 |\n| 0.14112  | 1.098612 |\n"
    },
    "contextby": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/contextby.html",
        "signatures": [
            {
                "full": "contextby(func, funcArgs, groupingCol, [sortingCol], [semanticFilter=1])",
                "name": "contextby",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "groupingCol",
                        "name": "groupingCol"
                    },
                    {
                        "full": "[sortingCol]",
                        "name": "sortingCol",
                        "optional": true
                    },
                    {
                        "full": "[semanticFilter=1]",
                        "name": "semanticFilter",
                        "optional": true,
                        "default": "1"
                    }
                ]
            },
            {
                "full": "func:X(funcArgs, groupingCol, [sortingCol], [semanticFilter=1])",
                "name": "func:X",
                "parameters": [
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "groupingCol",
                        "name": "groupingCol"
                    },
                    {
                        "full": "[sortingCol]",
                        "name": "sortingCol",
                        "optional": true
                    },
                    {
                        "full": "[semanticFilter=1]",
                        "name": "semanticFilter",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [contextby](https://docs.dolphindb.cn/zh/funcs/ho_funcs/contextby.html)\n\n\n\n#### 语法\n\ncontextby(func, funcArgs, groupingCol, \\[sortingCol], \\[semanticFilter=1])\n\n或\n\nfuncArg func:X groupingCol\n\n或\n\nfunc:X(funcArgs, groupingCol, \\[sortingCol], \\[semanticFilter=1])\n\n#### 参数\n\n**func** 是一个函数。**注意**：对于第二种用法，func表示的函数只能有一个参数。\n\n**funcArgs** 是函数func的参数。如果有多个参数，则用元组表示。\n\n**groupingCol** 是分组变量，可为一组或多组。\n\n**sortingCol** 是可选参数，表示在应用函数func前，依此列进行组内排序。\n\n**semanticFilter** 可选参数，当 *funcArgs* 指定为表时，用于指定表中参与计算的字段。它是一个正整数，可取以下值：\n\n* 0：所有列。\n\n* 1（默认值）：数值列（FLOATING/INTEGRAL/DECIMAL 分类，COMPRESSED 除外）。\n\n* 2：时间列（TEMPORAL 类型）。\n\n* 3：字符串列（LITERAL 类型，BLOB 除外）。\n\n* 4：数值列和时间列。\n\n*funcArgs*, *groupingCol* 和 *sortingCol* 中包含的向量长度相等。\n\n#### 详情\n\n根据 groupingCol 分组，并在组内进行指定计算。返回一个与输入参数长度相同的向量。\n\n如果func是聚合函数，每组内的所有结果相同。若指定了sortingCol，在计算前，依此列进行组内排序。\n\n**Note:** 当 func 为聚合函数时，用于定义该聚合函数的关键词为 defg。\n\n#### 例子\n\n```\nsym=`IBM`IBM`IBM`MS`MS`MS\nprice=172.12 170.32 175.25 26.46 31.45 29.43\nqty=5800 700 9000 6300 2100 5300\ntrade_date=2013.05.08 2013.05.06 2013.05.07 2013.05.08 2013.05.06 2013.05.07;\ncontextby(avg, price, sym);\n```\n\n输出返回：\\[172.563,172.563,172.563,29.113,29.113,29.113]\n\n```\nprice avg :X sym;\n```\n\n输出返回：\\[172.563,172.563,172.563,29.113,29.113,29.113]\n\n```\nprice at price>contextby(avg, price,sym);\n```\n\n输出返回：\\[175.25,31.45,29.43]\n\n```\nprice at price>price avg :X sym;\n```\n\n输出返回：\\[175.25,31.45,29.43]\n\n```\nsym at price>contextby(avg, price,sym);\n```\n\n输出返回：\\[\"IBM\",\"MS\",\"MS\"]\n\n```\ncontextby(wavg, [price, qty], sym);\n```\n\n输出返回：\\[173.856,173.856,173.856,28.374,28.374,28.374]\n\n```\n// 计算数量加权的平均值\ncontextby(ratios, price, sym, trade_date) - 1;\n```\n\n输出返回：\\[-0.01786,,0.028946,-0.100917,,-0.064229]\n\ngroupingCol 可包含多个向量：\n\n```\nsym=`IBM`IBM`IBM`IBM`IBM`IBM`MS`MS`MS`MS`MS`MS\ndate=2020.12.01 + 0 0 0 1 1 1 0 0 0 1 1 1\nqty=5800 700 9000 1000 3500 3900 6300 2100 5300 7800 1200 4300\ncontextby(cumsum, qty, [sym,date]);\n```\n\n输出返回：\\[5800,6500,15500,1000,4500,8400,6300,8400,13700,7800,9000,13300]\n\n*contextby* 高阶函数可在 SQL 查询中使用：\n\n```\nt1=table(trade_date,sym,qty,price);\nt1;\n```\n\n输出返回：\n\n| trade\\_date | sym | qty  | price  |\n| ----------- | --- | ---- | ------ |\n| 2013.05.08  | IBM | 5800 | 172.12 |\n| 2013.05.06  | IBM | 700  | 170.32 |\n| 2013.05.07  | IBM | 9000 | 175.25 |\n| 2013.05.08  | MS  | 6300 | 26.46  |\n| 2013.05.06  | MS  | 2100 | 31.45  |\n| 2013.05.07  | MS  | 5300 | 29.43  |\n\n```\n// 选出价格高于组内平均价的交易记录\nselect trade_date, sym, qty, price from t1 where price > contextby(avg, price,sym);\n```\n\n输出返回：\n\n| trade\\_date | sym | qty  | price  |\n| ----------- | --- | ---- | ------ |\n| 2013.05.07  | IBM | 9000 | 175.25 |\n| 2013.05.06  | MS  | 2100 | 31.45  |\n| 2013.05.07  | MS  | 5300 | 29.43  |\n\n```\n// t1 的所有交易日期都增加一天\ncontextby(temporalAdd{,1d}, t1, t1.sym,,2)\n```\n\n<table id=\"table_x4v_cj2_xbc\"><thead><tr><th>\n\ntrade\\_date\n\n</th><th>\n\nsym\n\n</th><th>\n\nqty\n\n</th><th>\n\nprice\n\n</th></tr></thead><tbody><tr><td>\n\n2013.05.09\n\n</td><td>\n\nIBM\n\n</td><td>\n\n5,800\n\n</td><td>\n\n172.12\n\n</td></tr><tr><td>\n\n2013.05.07\n\n</td><td>\n\nIBM\n\n</td><td>\n\n700\n\n</td><td>\n\n170.32\n\n</td></tr><tr><td>\n\n2013.05.08\n\n</td><td>\n\nIBM\n\n</td><td>\n\n9,000\n\n</td><td>\n\n175.25\n\n</td></tr><tr><td>\n\n2013.05.09\n\n</td><td>\n\nMS\n\n</td><td>\n\n6,300\n\n</td><td>\n\n26.46\n\n</td></tr><tr><td>\n\n2013.05.07\n\n</td><td>\n\nMS\n\n</td><td>\n\n2,100\n\n</td><td>\n\n31.45\n\n</td></tr><tr><td>\n\n2013.05.08\n\n</td><td>\n\nMS\n\n</td><td>\n\n5,300\n\n</td><td>\n\n29.43\n\n</td></tr></tbody>\n</table>\n"
    },
    "cross": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/cross.html",
        "signatures": [
            {
                "full": "cross(func, X, [Y])",
                "name": "cross",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            },
            {
                "full": "func:C(X, [Y])",
                "name": "func:C",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [cross](https://docs.dolphindb.cn/zh/funcs/ho_funcs/cross.html)\n\n\n\n#### 语法\n\ncross(func, X, \\[Y])\n\n或\n\nX \\<operator>:C Y\n\n或\n\nfunc:C(X, \\[Y])\n\n#### 参数\n\n* **func** 是一个二元函数。\n\n* **X** 和 **Y** 可以是数据对、向量或矩阵。X 和 Y 可以有不同的数据形式和长度或维度。\n\n* **Y** 是一个可选参数。如果Y没有指定，将会执行cross(func, X, X)，其中func必须是对称二元函数，如 [corr](https://docs.dolphindb.cn/zh/funcs/c/corr.html) 函数。\n\n#### 详情\n\n将 X 和 Y 中元素的两两组合作为参数来调用函数。如果 X 或 Y 是矩阵，以列为单位遍历。以下是 `cross` 高阶函数的伪代码：\n\n```\nfor(i:0~(size(X)-1)){\n\nfor(j:0~(size(Y)-1)){\n\n  result[i,j]=<function>(X[i], Y[j]);\n\n}\n\n}\n\nreturn result;\n```\n\n假设 X 有 m 个元素或 m 列，Y 有 n 个元素或 n 列，如果 func(X\\[i], Y\\[j]) 是标量，将返回一个 m×n 矩阵，如果 func(X\\[i], Y\\[j]) 是向量，将返回一个长度为 m 的元组，每个元素是一个长度为 n 的元组。\n\n*pcross* 是并行计算版本的 *cross* 高阶函数。\n\n#### 例子\n\n基于以下的 x 和 y 值，两个向量执行 `cross`：\n\n```\nx=1 2;\ny=3 5 7;\nx+:C y;\n```\n\n返回：\n\n| lable | 3 | 5 | 7 |\n| ----- | - | - | - |\n| 1     | 4 | 6 | 8 |\n| 2     | 5 | 7 | 9 |\n\n```\ncross(mul, x, y);\n```\n\n得到：\n\n| lable | 3 | 5  | 7  |\n| ----- | - | -- | -- |\n| 1     | 3 | 5  | 7  |\n| 2     | 6 | 10 | 14 |\n\n```\ncross(pow, x, y);\n```\n\n得到：\n\n| lable | 3 | 5  | 7   |\n| ----- | - | -- | --- |\n| 1     | 1 | 1  | 1   |\n| 2     | 8 | 32 | 128 |\n\n矩阵 m：\n\n```\nm = 1..6$2:3;\nm;\n```\n\n| clo1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 3    | 5    |\n| 2    | 4    | 6    |\n\n矩阵 n：\n\n```\nn=1..4$2:2;\nn;\n```\n\n| clo1 | col2 |\n| ---- | ---- |\n| 1    | 3    |\n| 2    | 4    |\n\n对矩阵 m 和 n 执行 `cross`：\n\n```\ncross(**, m, n);\n```\n\n得到：\n\n| clo1 | col2 |\n| ---- | ---- |\n| 5    | 11   |\n| 11   | 25   |\n| 17   | 39   |\n\n一个向量和一个矩阵执行 `cross`，返回一个矩阵：\n\n```\ndef topsum(x,n){return sum x[0:n]};\na=1..18$6:3;\na;\n```\n\n得到：\n\n| clo1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 7    | 13   |\n| 2    | 8    | 14   |\n| 3    | 9    | 15   |\n| 4    | 10   | 16   |\n| 5    | 11   | 17   |\n| 6    | 12   | 18   |\n\n```\nb=2 4;\na topsum :C b;\n```\n\n| 2  | 4  |\n| -- | -- |\n| 3  | 10 |\n| 15 | 34 |\n| 27 | 58 |\n\n一个向量和一个矩阵执行 `cross`，返回一个元组：\n\n```\nx=1 2\ny=1..6$2:3\ncross(add, x, y);\n```\n\n返回：((\\[2,3],\\[4,5],\\[6,7]),(\\[3,4],\\[5,6],\\[7,8]))\n\n```\nx=1 2\ny=1..6$3:2\ncross(add, x, y);\n```\n\n返回：((\\[2,3,4],\\[5,6,7]),(\\[3,4,5],\\[6,7,8]))\n"
    },
    "each": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/each.html",
        "signatures": [
            {
                "full": "each(func, args...)",
                "name": "each",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            },
            {
                "full": "func:E(args...)",
                "name": "func:E",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [each](https://docs.dolphindb.cn/zh/funcs/ho_funcs/each.html)\n\n\n\n#### 语法\n\neach(func, args...)\n\n(把一个函数应用到指定参数中的每个元素。)\n\n或\n\nF :E X\n\n(把一个函数应用到X中的每个元素。)\n\n或\n\nX \\<operator> :E Y\n\n(把一个函数应用到X和Y中的每个元素，X和Y长度相同。)\n\n或\n\nfunc:E(args...)\n\n#### 参数\n\n* **func** 是一个函数。\n\n* **args** 是func的参数。\n\n* **operator** 是一个二元运算符。\n\n* **X** 和 **Y** 可以是数据对、向量、矩阵、表、数组向量或字典。\n\n#### 详情\n\n将指定函数（func）或运算符（operator）按以下规则应用到输入对象(args, X, Y)上：\n\n* 对于矩阵，把函数应用到每一列；\n\n* 对于表，把函数应用到每一行；\n\n* 对于数组向量，把函数应用到每一行；\n\n* 对于字典，把函数应用到字典的每一个 value。\n\neach 根据每个子任务计算结果的数据类型和形式，决定返回值的数据形式。若所有子任务的数据类型和形式都相同，则返回 Vector 或 Matrix，否则返回 Tuple。\n\nfunc(X) 和 func :E X 的区别是前者将X视作一个输入变量，而后者取遍X中的每一个参数。如果 func 是一个向量函数，应该避免使用 \"each (:E) \" ，因为在元素比较多的时候，元素的比对就会很慢。\n\n*peach* 是并行计算版本的 *each* 高阶函数。对于执行时间较长的任务，*peach* 比 *each* 能节省大量的时间。但对于小任务，*peach* 可能执行时间要比each更长，因为并行函数调用的开销很大。\n\n#### 例子\n\n假设需要计算3个员工的日薪，员工的工时存放在向量x=\\[9,6,8]中，员工的时薪在8小时以下是$10，在8小时以上是$20。考虑下面的 *wage* 函数：\n\n```\nx=[9,6,8]\ndef wage(x){if(x<=8) return 10*x; else return 20*x-80}\nwage x;\n\nThe vector can't be converted to bool scalar.\n```\n\n*wage(x)* 不返回结果，因为x<=8，即 \\[9,6,8]<=8 返回了一个向量的条件值\\[0,1,1]，而不是if 需要的标量。\n\n可使用以下方案来解决这个问题：\n\n```\neach(wage, x);\n\n[100,60,80]\n\nwage :E x;\n\n[100,60,80]\n\ndef wage2(x){return iif(x<=8, 10*x, 20*x-80)};\n// iif 函数是一个逐元素的条件操作\n\nwage2(x);\n\n[100,60,80]\n```\n\n类似的，*each* 也可以用于有多个参数的函数：\n\n```\ndef addeven(x,y){if (x%2==0) return x+y; else return 0}\nx1=1 2 3\nx2=4 5 6;\neach(addeven, x1, x2);\n\n[0,7,0]\n```\n\n*each* 所用数据可以是数据对：\n\n```\nt = table(1 2 3 as id, 4 5 6 as value, `IBM`MSFT`GOOG as name);\nt;\n```\n\n| id | value | name |\n| -- | ----- | ---- |\n| 1  | 4     | IBM  |\n| 2  | 5     | MSFT |\n| 3  | 6     | GOOG |\n\n```\neach(max, t[`id`value]);\n\n[3,6]\n```\n\n*each* 所用数据可以是矩阵：\n\n```\nm=1..12$4:3;\nm;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 5    | 9    |\n| 2    | 6    | 10   |\n| 3    | 7    | 11   |\n| 4    | 8    | 12   |\n\n```\neach(add{1 2 3 4}, m);\n// add{1 2 3 4}是一个部分应用，each将向量[1, 2, 3, 4]与矩阵m的每列相加。\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 2    | 6    | 10   |\n| 4    | 8    | 12   |\n| 6    | 10   | 14   |\n| 8    | 12   | 16   |\n\n```\nx=1..6$2:3;\ny=6..1$2:3;\nx;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 3    | 5    |\n| 2    | 4    | 6    |\n\n```\ny;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 6    | 4    | 2    |\n| 5    | 3    | 1    |\n\n```\neach(**, x, y);\n\n[16,24,16]\n// 比如，24=3*4+4*3\n```\n\n当输入对象有多个时，每次取出每个对象相同位置的元素，作为指定函数的参数。例如：\n\n```\nm1 = matrix(1 3 6, 4 6 8, 5 -1 3)\nm2 = matrix(3 -6 0, 2 NULL 3, 6 7 9)\neach(corr, m1, m2)\n// 等价于 corr(m1[0], m2[0]) join corr(m1[1], m2[1]) join corr(m1[2], m2[2])\n\n[-0.216777, 1, -0.142857]\n```\n\n从 2.00.9 版本开始，*each* 所用数据可以是字典：\n\n```\nd=dict(`a`b`c, [[1, 2, 3],[4, 5, 6], [7, 8, 9]])\neach(sum, d)\n\nb->15\nc->24\na->6\n```\n\n下例中，我们在一个部分应用中使用了 *call* 函数，该部分应用将向量\\[1 2 3]作为参数，分别调用函数 *sin* 与 *log*。\n\n```\n// 当 \"functionName\" 为空时，将动态地选择一个函数名字。\neach(call{, 1..3},(sin,log));\n```\n\n| sin      | log      |\n| -------- | -------- |\n| 0.841471 | 0        |\n| 0.909297 | 0.693147 |\n| 0.14112  | 1.098612 |\n\nfunc 为自定义函数，对字典进行操作。当字典的 key 的类型是字符串时，*each* 会对字典进行合并，返回一个表。合并规则如下：\n\n1. 根据第一个字典确定表的 schema，并将字典的 value 写入表中第一行。字段名为该字典的 keys，列数为该字典的 keys 的个数。无论后续被遍历字典 keys 的个数如何变化，表的 schema 不会被修改。\n\n2. 在遍历后续字典时，每一个字典对应表中一行数据。若某个 key 与表字段名相同，则将其 value 追加到表中，若某个 key 与表字段不同，则追加空值到表中。\n\n   ```\n   days = 2023.01.01..2023.01.10\n   def mf(day) {  \n       out = dict(STRING, ANY)\n       if(day==2023.01.05){\n           out[\"v\"] = 3\n       }\n       else{\n           out[\"day\"] = day\n           out[\"v\"] = 1\n       }\n       return out\n   }\n   each(mf, days)\n\n   ```\n\n   | v | day        |\n   | - | ---------- |\n   | 1 | 2023.01.01 |\n   | 1 | 2023.01.02 |\n   | 1 | 2023.01.03 |\n   | 1 | 2023.01.04 |\n   | 3 |            |\n   | 1 | 2023.01.06 |\n   | 1 | 2023.01.07 |\n   | 1 | 2023.01.08 |\n   | 1 | 2023.01.09 |\n   | 1 | 2023.01.10 |\n\n从2.00.12和3.00.0版本开始，each 可以接受多元函数且第一个参数为字典。\n\n对于表 t 中 id 列的每个元素，计算其向前累加直到不小于3经过的周期数（可用 `sumbars` 函数实现）；对 id2 的每个元素，计算其向前累加直到不小于5经过的周期数。因为用 `sumbars` 计算每列数据时，*Y* 不同（分别是3和5），必须用一个二元函数跟 each 搭配使用。对一个表转置（`transpose`），返回一个以列名为键值，列为数值的字典。对字典应用转置函数，则还原为表。\n\n```\nt = table(1..10 as id, 2..11 as id2)\nsumbars:E(t.transpose(), 3 5).transpose()\n```\n\n| id | id2 |\n| -- | --- |\n| 0  | 0   |\n| 2  | 2   |\n| 1  | 2   |\n| 1  | 1   |\n| 1  | 1   |\n| 1  | 1   |\n| 1  | 1   |\n| 1  | 1   |\n| 1  | 1   |\n| 1  | 1   |\n\n**Tip:**\n\n1. 对于执行时间长的任务，使用 *peach* 进行并行计算，可以节约任务执行时间。\n\n   ```\n   m=rand(1,20000:5000)\n   timer f=peach(mskew{,8},m)\n\n   Time elapsed: 3134.71 ms\n   timer f=mskew(m,8)\n\n   Time elapsed: 8810.485 ms\n   ```\n\n2. 当元素数量很多时候，不推荐使用 *:E (each)* 高阶函数，可以使用更高效的向量解决方案。\n\n   ```\n   x=rand(16, 1000000);\n   timer(10){each(wage, x)};\n\n   Time elapsed: 38164.9 ms\n\n   timer(10){iif(x<8,10*x,20*x-80)};\n\n   Time elapsed: 81.516 ms\n   ```\n"
    },
    "eachLeft": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/eachLeft.html",
        "signatures": [
            {
                "full": "eachLeft(func, X, Y, [consistent=false])",
                "name": "eachLeft",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "func:L(X, Y)",
                "name": "func:L",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            },
            {
                "full": "func:LC(X, Y)",
                "name": "func:LC",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [eachLeft](https://docs.dolphindb.cn/zh/funcs/ho_funcs/eachLeft.html)\n\n#### 语法\n\neachLeft(func, X, Y, \\[consistent=false])\n\n或\n\nfunc:L(X, Y)（表示 consistent 为 false）\n\n或\n\nfunc:LC(X, Y)（表示 consistent 为 true）\n\n或\n\nX \\<operator>:L Y（表示 consistent 为 false）\n\n或\n\nX \\<operator>:LC Y（表示 consistent 为 true）\n\n#### 参数\n\n* **func** 是一个二元函数。\n* **X** 和 **Y** 可以是向量、矩阵、表、数组向量或字典。\n* **consistent** 布尔值，默认 false，表示每个子任务输出的数据类型由实际计算结果决定。否则，每个子任务输出的数据类型将与第一个子任务输出的数据类型保持一致。\n\n  **Note:** 若子任务输出的数据形式不一致，只能指定 *consistent* = false，否则会报错。\n\n#### 详情\n\n把 func 应用到 *X* 的每个元素上，即依次执行 func(X(i),Y)。\n\n* 对于向量，X(i) 为每个元素\n\n* 对于矩阵，X(i) 为每一列\n\n* 对于表，X(i) 为每一行\n\n* 对于数组向量，X(i) 为每一行\n\n* 对于字典，X(i) 为字典的每一个 value\n\n如果 func 支持向量操作，并且输入数据是一个向量，使用向量函数或运算符比使用 eachLeft 更为高效。\n\n#### 例子\n\n*eachLeft* 作用于两个向量：\n\n```\nx = 4 3 2 1\ny = 3 0 6;\nx +:L y;\n```\n\n| 4  | 3 | 2 | 1 |\n| -- | - | - | - |\n| 7  | 6 | 5 | 4 |\n| 4  | 3 | 2 | 1 |\n| 10 | 9 | 8 | 7 |\n\n```\neachLeft(pow, x, y);\n```\n\n| 4    | 3   | 2  | 1 |\n| ---- | --- | -- | - |\n| 64   | 27  | 8  | 1 |\n| 1    | 1   | 1  | 1 |\n| 4096 | 729 | 64 | 1 |\n\n*eachLeft* 作用于一个矩阵以及一个向量：\n\n```\nx=1..6$2:3;\nx;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 3    | 5    |\n| 2    | 4    | 6    |\n\n```\nx ** :L 1 1;\n// output\n[3,7,11]\n```\n\n*eachLeft* 作用于两个矩阵：\n\n```\ny=6..1$2:3;\ny;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 6    | 4    | 2    |\n| 5    | 3    | 1    |\n\n```\nz = x **:L y;\nz;\n\n// output\n(#0 #1 #2\n-- -- --\n16 10 4\n,#0 #1 #2\n-- -- --\n38 24 10\n,#0 #1 #2\n-- -- --\n60 38 16\n)\n```\n\n```\ntypestr z;\n// output\nANY VECTOR\n```\n\n*eachLeft* 作用于一个字典和一个向量：\n\n```\nd=dict(`a`b`c, [[1, 2, 3],[4, 5, 6], [7, 8, 9]])\neachLeft(add,d,10 20 30)\n// output\na->[11,22,33]\nb->[14,25,36]\nc->[17,28,39]\n```\n\n"
    },
    "eachPost": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/eachPost.html",
        "signatures": [
            {
                "full": "eachPost(func, X, [post], [consistent=false])",
                "name": "eachPost",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[post]",
                        "name": "post",
                        "optional": true
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "func:O(X, [post])",
                "name": "func:O",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[post]",
                        "name": "post",
                        "optional": true
                    }
                ]
            },
            {
                "full": "func:OC(X, [post])",
                "name": "func:OC",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[post]",
                        "name": "post",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [eachPost](https://docs.dolphindb.cn/zh/funcs/ho_funcs/eachPost.html)\n\n\n\n#### 语法\n\neachPost(func, X, \\[post], \\[consistent=false])\n\n或\n\nfunc:O(X, \\[post])（表示 consistent 为 false）\n\n或\n\nfunc:OC(X, \\[post])（表示 consistent 为 true）\n\n或\n\nX \\<operator>:O \\[post]（表示 consistent 为 false）\n\n或\n\nX \\<operator>:OC \\[post]（表示 consistent 为 true）\n\n#### 参数\n\n**func** 是一个二元函数。\n\n**X** 可以是向量、矩阵或表。当X是向量时，post必须是标量；当X是矩阵时，post必须是标量或向量；当X是表时，pre是标量或表；当post未指定时，结果的最后一个元素为NULL。\n\n**consistent** 布尔值，默认 false，表示每个子任务输出的数据类型由实际计算结果决定。否则，每个子任务输出的数据类型将与第一个子任务输出的数据类型保持一致。 注意，若子任务输出的数据形式不一致，只能指定 *consistent* = false，否则会报错。\n\n#### 详情\n\n将给定函数/运算符应用到所有相邻的数据对上。\n\n*eachPost* 高阶函数等同于：F(X\\[0], X\\[1]), F(X\\[1], X\\[2]), ..., F(X\\[n], post).\n\n#### 例子\n\n```\nx=1..10;\neachPost(sub, x);\n// output\n[-1,-1,-1,-1,-1,-1,-1,-1,-1,]\n// 等同于 [1-2, 2-3, ..., 9-10, NULL]\n\n+:O x;\n// output\n[3,5,7,9,11,13,15,17,19,]\n// 等同于 [1+2, 2+3, ..., 9+10, NULL]\n\nx +:O 0;\n// output\n[3,5,7,9,11,13,15,17,19,10]\n// 等同于 [1+2, 2+3, ..., 9+10, 10+0]\n\nx=1..12$3:4;\nx;\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 1    | 4    | 7    | 10   |\n| 2    | 5    | 8    | 11   |\n| 3    | 6    | 9    | 12   |\n\n```\n-:O x;\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| -3   | -3   | -3   |      |\n| -3   | -3   | -3   |      |\n| -3   | -3   | -3   |      |\n\n```\neachPost(\\, x, x[0]);\n```\n\n| col1 | col2     | col3     | col4 |\n| ---- | -------- | -------- | ---- |\n| 0.25 | 0.571429 | 0.7      | 10   |\n| 0.4  | 0.625    | 0.727273 | 5.5  |\n| 0.5  | 0.666667 | 0.75     | 4    |\n\n```\ndef f1(a,b){\n    return (a[`x])+(a[`y])+(b[`x])+(b[`y])\n}\n\nt = table(1 2 3 as x,2 3 4 as y)\nt1 = table(1 as x,2 as y)\neachPost(f1,t,t1)\n\n// output\n(8,12,[10])\n```\n"
    },
    "eachPre": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/eachPre.html",
        "signatures": [
            {
                "full": "eachPre(func, X, [pre], [consistent=false])",
                "name": "eachPre",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[pre]",
                        "name": "pre",
                        "optional": true
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "func:P([pre], X)",
                "name": "func:P",
                "parameters": [
                    {
                        "full": "[pre]",
                        "name": "pre",
                        "optional": true
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            },
            {
                "full": "func:PC([pre], X)",
                "name": "func:PC",
                "parameters": [
                    {
                        "full": "[pre]",
                        "name": "pre",
                        "optional": true
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [eachPre](https://docs.dolphindb.cn/zh/funcs/ho_funcs/eachPre.html)\n\n#### 语法\n\neachPre(func, X, \\[pre], \\[consistent=false])\n\n或\n\nfunc:P(\\[pre], X)（表示 consistent 为 false）\n\n或\n\nfunc:PC(\\[pre], X)（表示 consistent 为 true）\n\n或\n\n\\[pre] \\<operator>:P X （表示 consistent 为 false）\n\n或\n\n\\[pre] \\<operator>:PC X（表示 consistent 为 true）\n\n#### 参数\n\n* **func** 是一个二元函数。\n* **X** 可以是向量、矩阵或表。当X是向量时，pre必须是标量；当X是矩阵时，pre必须是标量或向量；当X是表时，pre必须是标量或表；当pre未指定时，结果的第一个元素为NULL。\n* **consistent** 布尔值，默认 false，表示每个子任务输出的数据类型由实际计算结果决定。否则，每个子任务输出的数据类型将与第一个子任务输出的数据类型保持一致。\n\n  **Note:** 若子任务输出的数据形式不一致，只能指定 *consistent* = false，否则会报错。\n\n#### 详情\n\n将给定函数/运算符应用于X中所有相邻的数据对。\n\n*eachPre* 高阶函数等同于： F(X\\[0], pre), F(X\\[1], X\\[0]), ..., F(X\\[n], X\\[n-1])。\n\n内置函数 [ratios](https://docs.dolphindb.cn/zh/funcs/r/ratios.html) 和 [deltas](https://docs.dolphindb.cn/zh/funcs/d/deltas.html) 也是通过用 *eachPre* 高阶函数实现。定义如下：\n\n* function deltas(a){return a\\[0] -:P a}\n\n* function ratios(a){return a\\[0] :P a}\n\n#### 例子\n\n```\nx=1..10;\neachPre(sub, x);\n```\n\n返回：\\[,1,1,1,1,1,1,1,1,1]。该用法等同于 \\[NULL, 2-1, ..., 10-9]\n\n```\n-:P x;\n```\n\n返回：\\[,1,1,1,1,1,1,1,1,1]。该用法等同于 \\[NULL, 2-1, ..., 10-9]\n\n```\neachPre(+, x);\n```\n\n返回：\\[,3,5,7,9,11,13,15,17,19]。该用法等同于 \\[NULL, 2+1, ..., ]。\n\n```\n0 +:P x;\n```\n\n返回：\\[1,3,5,7,9,11,13,15,17,19]。该用法等同于 \\[1+0, 2+1, ..., ]。\n\n```\nx=1..12$3:4;\nx;\n```\n\n返回：\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 1    | 4    | 7    | 10   |\n| 2    | 5    | 8    | 11   |\n| 3    | 6    | 9    | 12   |\n\n```\n- :P x;\n```\n\n返回：\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n|      | 3    | 3    | 3    |\n|      | 3    | 3    | 3    |\n|      | 3    | 3    | 3    |\n\n```\neachPre(\\, x, x[0]);\n```\n\n返回：\n\n| col1 | col2 | col3 | col4     |\n| ---- | ---- | ---- | -------- |\n| 1    | 4    | 1.75 | 1.428571 |\n| 1    | 2.5  | 1.6  | 1.375    |\n| 1    | 2    | 1.5  | 1.333333 |\n\n```\ndef f1(a,b){\n    return (a[`x])+(a[`y])+(b[`x])+(b[`y])\n}\n\nt = table(1 2 3 as x,2 3 4 as y)\nt1 = table(1 as x,2 as y)\neachPre(f1,t,t1)\n```\n\n返回：(\\[6],8,12)\n\n"
    },
    "eachRight": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/eachRight.html",
        "signatures": [
            {
                "full": "eachRight(func, X, Y, [consistent=false])",
                "name": "eachRight",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "func:R(X, Y)",
                "name": "func:R",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            },
            {
                "full": "func:RC(X, Y)",
                "name": "func:RC",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [eachRight](https://docs.dolphindb.cn/zh/funcs/ho_funcs/eachRight.html)\n\n\n\n#### 语法\n\neachRight(func, X, Y, \\[consistent=false])\n\n或\n\nfunc:R(X, Y)（表示 consistent 为 false）\n\n或\n\nfunc:RC(X, Y)（表示 consistent 为 true）\n\n或\n\nX \\<operator>:R Y（表示 consistent 为 false）\n\n或\n\nX \\<operator>:RC Y（表示 consistent 为 true）\n\n#### 参数\n\n**func** 是一个二元函数。\n\n**X** 和 **Y** 可以是向量，矩阵、表、数组向量或字典。\n\n**consistent** 布尔值，默认 false，表示每个子任务输出的数据类型由实际计算结果决定。否则，每个子任务输出的数据类型将与第一个子任务输出的数据类型保持一致。 注意，若子任务输出的数据形式不一致，只能指定 *consistent* = false，否则会报错。\n\n#### 详情\n\n把 func 应用到 *Y* 的每个元素上，即依次执行 func(X,Y(i))。\n\n* 对于向量，Y(i) 为每个元素\n\n* 对于矩阵，Y(i) 为每一列\n\n* 对于表，Y(i) 为每一行\n\n* 对于数组向量，Y(i) 为每一行\n\n* 对于字典，Y(i) 为字典的每一个 value\n\n如果 func 支持向量操作，并且输入数据是一个向量，为性能考虑，应直接使用向量函数或运算符，不要使用 *eachRight*。\n\n#### 例子\n\n*eachRight* 作用于两个向量：\n\n```\nx = 4 3 2 1\ny = 3 0 6;\neachRight(add, x, y);\n```\n\n| 3 | 0 | 6  |\n| - | - | -- |\n| 7 | 4 | 10 |\n| 6 | 3 | 9  |\n| 5 | 2 | 8  |\n| 4 | 1 | 7  |\n\n```\nx pow :R y;\n```\n\n| 3  | 0 | 6    |\n| -- | - | ---- |\n| 64 | 1 | 4096 |\n| 27 | 1 | 729  |\n| 8  | 1 | 64   |\n| 1  | 1 | 1    |\n\n*eachRight* 作用于一个矩阵以及一个向量：\n\n```\nx=1..6$2:3;\nx;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 3    | 5    |\n| 2    | 4    | 6    |\n\n```\n1 1 ** :R x;\n// output\n[3,7,11]\n```\n\n*eachRight* 作用于两个矩阵：\n\n```\ny=6..1$3:2;\ny;\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 6    | 3    |\n| 5    | 2    |\n| 4    | 1    |\n\n```\neachRight(**, x, y);\n\n// output\n(#0\n--\n41\n56\n,#0\n--\n14\n20\n)\n```\n\n*eachRight* 作用于一个字典和一个向量：\n\n```\nd=dict(`a`b`c, [[1, 2, 3],[4, 5, 6], [7, 8, 9]])\neachRight(add,10 20 30,d)\n// output\na->[11,22,33]\nb->[14,25,36]\nc->[17,28,39]\n```\n"
    },
    "groupby": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/groupby.html",
        "signatures": [
            {
                "full": "groupby(func, funcArgs, groupingCol)",
                "name": "groupby",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "groupingCol",
                        "name": "groupingCol"
                    }
                ]
            },
            {
                "full": "func:G(funcArgs, groupingCol)",
                "name": "func:G",
                "parameters": [
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "groupingCol",
                        "name": "groupingCol"
                    }
                ]
            }
        ],
        "markdown": "### [groupby](https://docs.dolphindb.cn/zh/funcs/ho_funcs/groupby.html)\n\n#### 语法\n\ngroupby(func, funcArgs, groupingCol)\n\n或\n\nfuncArg func:G groupingCol\n\n或\n\nfunc:G(funcArgs, groupingCol)\n\n#### 详情\n\n对 *groupingCol* 排序后分组，然后在每个分组中计算 func(funcArgs)。每组的计算结果可以是标量，向量或字典。该函数的输出结果是一个表，它的行数与分组数相等。\n\n#### 参数\n\n* **func** 是一个函数。\n* **funcArgs** 是函数 func 的参数。如果有多个参数，则用元组表示。\n* **groupingCol** 表示分组变量。可以是向量，表示一个分组列；也可以是等长向量组成的元组，表示多个分组列。\n\n*groupingCol*和 *funcArgs*中的每个参数都是相同长度的向量。\n\n**Note:** 对于第二种情况，*func* 表示的函数只能有一个参数。\n\n#### 例子\n\n```\nsym=`IBM`IBM`IBM`MS`MS`MS$symbol;\nprice=172.12 170.32 175.25 26.46 31.45 29.43;\nqty=5800 700 9000 6300 2100 5300;\ntrade_date=2013.05.08 2013.05.06 2013.05.07 2013.05.08 2013.05.06 2013.05.07;\ngroupby(avg, price, sym);\n```\n\n| sym | avg\\_price |\n| --- | ---------- |\n| IBM | 172.563333 |\n| MS  | 29.113333  |\n\n```\nprice avg :G sym;\n```\n\n| sym | avg\\_price |\n| --- | ---------- |\n| IBM | 172.563333 |\n| MS  | 29.113333  |\n\n```\ngroupby(wavg, [price, qty], sym);\n// 计算每个股票标记数量加权后的平均价格\n```\n\n| sym | avg\\_price |\n| --- | ---------- |\n| IBM | 173.856129 |\n| MS  | 28.373869  |\n\n```\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C$SYMBOL\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\n\ngroupby(max, price, [sym,minute(timestamp)])\n```\n\n| sym | groupingKey | max\\_price |\n| --- | ----------- | ---------- |\n| C   | 09:34m      | 50.76      |\n| C   | 09:38m      | 51.29      |\n| IBM | 09:32m      | 174.97     |\n| IBM | 09:35m      | 175.23     |\n| MS  | 09:36m      | 30.02      |\n\n"
    },
    "loop": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/loop.html",
        "signatures": [
            {
                "full": "loop(func, args...)",
                "name": "loop",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            },
            {
                "full": "func:U(args…)",
                "name": "func:U",
                "parameters": [
                    {
                        "full": "args…",
                        "name": "args…"
                    }
                ]
            }
        ],
        "markdown": "### [loop](https://docs.dolphindb.cn/zh/funcs/ho_funcs/loop.html)\n\n#### 语法\n\nloop(func, args...)\n\n或\n\nfunc:U(args…)\n\n或\n\nfunc:U X\n\n或\n\nX func:U Y\n\n#### 详情\n\nloop 高阶函数与 each 高阶函数很相似，区别在于函数返回值的格式和类型。ploop 是相应的并行版本。\n\neach 高阶函数根据每个子任务计算结果的数据类型和形式，决定返回值的数据形式。若所有子任务的数据类型和形式都相同， 则返回 Vector 或 Matrix，否则返回 Tuple。而 loop 总是返回 Tuple。\n\n#### 参数\n\n* **func** 是一个函数。\n\n* **args/X/Y** 是 *func* 的参数。\n\n#### 例子\n\n函数入参是矩阵时：\n\n```\nm=matrix([1 3 4 2,1 2 2 1])\nmax:U(m) \n```\n\n返回：(4,2)\n\n```\nn=matrix([11 5 9 2,8 5 3 2])\nm add:U n\n```\n\n返回：(\\[12,8,13,4],\\[9,7,5,3])\n\n函数入参是数组向量时：\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5 4, 6 7 8, 1 9 10]);\nsum:U(a)\n```\n\n返回：(6,9,21,19)\n\n下例中，通过 loop 函数将数组转换为元组。\n\n```\na=[1,2,3,4,5]\nasis:U(a)\n```\n\n返回：(1,2,3,4,5)\n\n"
    },
    "moving": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/moving.html",
        "signatures": [
            {
                "full": "moving(func, funcArgs, window, [minPeriods])",
                "name": "moving",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [moving](https://docs.dolphindb.cn/zh/funcs/ho_funcs/moving.html)\n\n#### 语法\n\nmoving(func, funcArgs, window, \\[minPeriods])\n\n#### 详情\n\n应用函数/运算符到给定对象的一个滚动窗口上。\n\n`moving` 高阶函数总是返回一个向量，长度与输入参数的长度相同。当第一个滑动窗口出现时高阶函数开始计算，每计算一次，滑动窗口向右移动一个元素。\n\n内置函数 [msum](https://docs.dolphindb.cn/zh/funcs/m/msum.html), [mcount](https://docs.dolphindb.cn/zh/funcs/m/mcount.html) 和 [mavg](https://docs.dolphindb.cn/zh/funcs/m/mavg.html) 为各自的计算场景进行了优化，因此比 `moving` 高阶函数有更好的性能。\n\n#### 参数\n\n* **func** 是一个**聚合**函数。\n\n  **Note:** 使用该参数时，用于定义相应聚合函数的关键词为 **defg**。有关 **defg** 的详细用法，参考：[自定义聚合函数](https://docs.dolphindb.cn/zh/tutorials/udaf.html)。\n\n* **funcArgs** 是函数 func 的参数。可为向量、字典或矩阵。如果有多个参数，则用元组表示，并且每个参数的长度（向量/字典的元素个数）必须相同。\n\n* **window** 是正整型 或 DURATION 标量。\n\n  * 当 *window* 是整型时，表示以窗口内元素个数衡量的滑动窗口的长度。\n\n  * 当 *window* 是 DURATION 时，表示以时间衡量的滑动窗口的长度。此时，*X* 必须是带有时间类型行索引的索引矩阵或者索引序列。\n\n* **minPeriods** 是一个正整数。为滑动窗口中最少包含的观测值数据。如果滑动窗口中的观测值小于 *minPeriods*，那么该窗口的结果为 NULL 值。默认值与 *window* 相等。 如果 *window* 是 DURATION，且需要设置 *minPeriods* 时，*minPeriods* 必须是 1。\n\n有关其他 m 系列函数的参数说明和窗口计算规则，参考: [滑动窗口系列（m 系列）](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 例子\n\n计算 APPL 相对于市场（SPY） 的 moving beta，移动窗口长度为 10。\n\n```\ndate=2016.08.01..2016.08.31\ndate=date[1<=weekday(date)<=5]\naaplRet=0.0177 -0.0148 0.0125 0.0008 0.0152 0.0083 0.0041 -0.0074 -0.0006 0.0023 0.0120 -0.0009 -0.0015 -0.0013 0.0026 -0.0078 0.0031 -0.0075 -0.0043 -0.0059 -0.0011 -0.0077 0.0009\nspyRet=-0.0008 -0.0064 0.0029 0.0011 0.0082 -0.0006 0.0006 -0.0025 0.0046 -0.0009 0.0029 -0.0052 0.0019 0.0022 -0.0015 0.0000 0.0020 -0.0051 -0.0007 -0.0019 0.0049 -0.0016 -0.0028\nt=table(date, aaplRet, spyRet);\nt;\n```\n\n输出返回：\n\n| date       | aaplRet | spyRet  |\n| ---------- | ------- | ------- |\n| 2016.08.01 | 0.0177  | -0.0008 |\n| 2016.08.02 | -0.0148 | -0.0064 |\n| 2016.08.03 | 0.0125  | 0.0029  |\n| 2016.08.04 | 0.0008  | 0.0011  |\n| 2016.08.05 | 0.0152  | 0.0082  |\n| 2016.08.08 | 0.0083  | -0.0006 |\n| 2016.08.09 | 0.0041  | 0.0006  |\n| 2016.08.10 | -0.0074 | -0.0025 |\n| 2016.08.11 | -0.0006 | 0.0046  |\n| 2016.08.12 | 0.0023  | -0.0009 |\n| 2016.08.15 | 0.012   | 0.0029  |\n| 2016.08.16 | -0.0009 | -0.0052 |\n| 2016.08.17 | -0.0015 | 0.0019  |\n| 2016.08.18 | -0.0013 | 0.0022  |\n| 2016.08.19 | 0.0026  | -0.0015 |\n| 2016.08.22 | -0.0078 | 0       |\n| 2016.08.23 | 0.0031  | 0.002   |\n| 2016.08.24 | -0.0075 | -0.0051 |\n| 2016.08.25 | -0.0043 | -0.0007 |\n| 2016.08.26 | -0.0059 | -0.0019 |\n| 2016.08.29 | -0.0011 | 0.0049  |\n| 2016.08.30 | -0.0077 | -0.0016 |\n| 2016.08.31 | 0.0009  | -0.0028 |\n\n通过以下语句计算移动 beta：\n\n```\nupdate t set beta_value=moving(beta, [aaplRet, spyRet],10);\nt;\n```\n\n输出返回：\n\n| date       | aaplRet | spyRet  | beta\\_value |\n| ---------- | ------- | ------- | ----------- |\n| 2016.08.01 | 0.0177  | -0.0008 |             |\n| 2016.08.02 | -0.0148 | -0.0064 |             |\n| 2016.08.03 | 0.0125  | 0.0029  |             |\n| 2016.08.04 | 0.0008  | 0.0011  |             |\n| 2016.08.05 | 0.0152  | 0.0082  |             |\n| 2016.08.08 | 0.0083  | -0.0006 |             |\n| 2016.08.09 | 0.0041  | 0.0006  |             |\n| 2016.08.10 | -0.0074 | -0.0025 |             |\n| 2016.08.11 | -0.0006 | 0.0046  |             |\n| 2016.08.12 | 0.0023  | -0.0009 | 1.601173    |\n| 2016.08.15 | 0.012   | 0.0029  | 1.859846    |\n| 2016.08.16 | -0.0009 | -0.0052 | 1.248804    |\n| 2016.08.17 | -0.0015 | 0.0019  | 1.114282    |\n| 2016.08.18 | -0.0013 | 0.0022  | 1.064296    |\n| 2016.08.19 | 0.0026  | -0.0015 | 0.512656    |\n| 2016.08.22 | -0.0078 | 0       | 0.614963    |\n| 2016.08.23 | 0.0031  | 0.002   | 0.642491    |\n| 2016.08.24 | -0.0075 | -0.0051 | 0.70836     |\n| 2016.08.25 | -0.0043 | -0.0007 | 0.977279    |\n| 2016.08.26 | -0.0059 | -0.0019 | 1.064465    |\n| 2016.08.29 | -0.0011 | 0.0049  | 0.422221    |\n| 2016.08.30 | -0.0077 | -0.0016 | 0.793236    |\n| 2016.08.31 | 0.0009  | -0.0028 | 0.588027    |\n\n*minPeriods* 的作用：\n\n```\nmoving(avg, 1..4, 3);\n```\n\n输出返回：\\[,,2,3]\n\n```\nmoving(avg, 1..4, 3, 1);\n```\n\n输出返回：\\[1,1.5,2,3]\n\n```\nv1=indexedSeries(2020.08.01..2020.08.04,1..4)\nmoving(avg, v1, 3d, 1);\n```\n\n输出返回：\n\n| label      | col1 |\n| ---------- | ---- |\n| 2020.08.01 | 1    |\n| 2020.08.02 | 1.5  |\n| 2020.08.03 | 2    |\n| 2020.08.04 | 3    |\n\n*moving* 高阶函数的参数 *func* 的所有参数必须要有相同的长度。如果 *func* 的参数长度不等，例如 [percentile](https://docs.dolphindb.cn/zh/funcs/p/percentile.html) 函数，可以使用 [部分应用](https://docs.dolphindb.cn/zh/progr/partial_app.html) 产生一个新的函数以满足此要求。请见下例：\n\n```\nmoving(percentile{,50},1..20, 10);\n```\n\n输出返回：\\[,,,,,,,,,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5]\n\n#### 性能提示\n\n计算移动均值时，应该使用内置函数 `mavg` 而不是 `moving` 高阶函数，这是因为内置版本是经过优化的版本，运行速度比高阶函数更快。\n\n```\nn=1000000\nx=norm(0,1, n);\ntimer mavg(x, 10);\n```\n\n输出返回：Time elapsed: 3.501ms\n\n```\ntimer moving(avg, x, 10);\n```\n\n输出返回：Time elapsed: 976.03ms\n\n"
    },
    "nullCompare": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/nullCompare.html",
        "signatures": [
            {
                "full": "nullCompare(func, X, Y)",
                "name": "nullCompare",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [nullCompare](https://docs.dolphindb.cn/zh/funcs/ho_funcs/nullCompare.html)\n\n#### 语法\n\nnullCompare(func, X, Y)\n\n#### 详情\n\n返回一个布尔值，是表达式 “func(X,Y)” 的结果。涉及 NULL 值的计算结果均为 NULL。该函数不受配置项 nullAsMinValueForComparison 影响。\n\n#### 参数\n\n* **func** 是<, >, >=, <=运算符，或函数 between, in。\n\n* **X** 和 **Y** 可以是标量、数据对、向量、矩阵或集合。当 *X* 和 *Y* 都是向量或矩阵时，它们的长度或维度必须相同。\n\n**Note:** *X* 和 *Y* 暂不支持以下数据类型：STRING, SYMBOL, IPADDR, UUID, BLOB 和I NT128。\n\n#### 例子\n\n配置项 *nullAsMinValueForComparison* = true 时，在比较运算中，NULL 元素取相应数据类型的最小值。若使用 nullCompare，则不受该配置影响，依然取 NULL 值。\n\n```\nNULL < 3\n// output\ntrue\nnullCompare(<, NULL, 3)\n// output\nNULL\nm1=matrix(1 2 NULL, NULL 8 4, 4 7 2 )\nm2 = 1..9$3:3\nm1>m2\n```\n\n| col1  | col2  | col3  |\n| ----- | ----- | ----- |\n| false | false | false |\n| false | true  | false |\n| false | false | false |\n\n```\nnullCompare(>,m1,m2)\n```\n\n| col1  | col2  | col3  |\n| ----- | ----- | ----- |\n| false |       | false |\n| false | true  | false |\n|       | false | false |\n\n```\nnullCompare(between, 4 5 NULL, 4:9)\n// output\n[1,1,]\n```\n\n"
    },
    "pcall": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/pcall.html",
        "signatures": [
            {
                "full": "pcall(func, args...)",
                "name": "pcall",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [pcall](https://docs.dolphindb.cn/zh/funcs/ho_funcs/pcall.html)\n\n#### 语法\n\npcall(func, args...)\n\n#### 详情\n\n将输入参数分成几个部分，并行计算，最后将结果合并。如果输入参数的长度小于100,000，*pcall* 函数不会并行计算。\n\n#### 参数\n\n* **func** 是一个函数。该函数的输出结果可以是一个向量或表，并且它们的长度必须与输入参数args的长度相同。\n* **args** 是func的参数。它可以是表、向量或元组。输入参数中的所有向量或表列必须长度相同。\n\n#### 例子\n\n```\nx = rand(1.0, 10000000);\ntimer(10) sin(x);\n```\n\n输出返回：\n\nTime elapsed: 739.561 ms\n\n```\ntimer(10) pcall(sin, x);\n```\n\n输出返回：\n\nTime elapsed: 404.56 ms\n\n"
    },
    "pcross": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/pcross.html",
        "signatures": [
            {
                "full": "pcross(func, X, [Y])",
                "name": "pcross",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [pcross](https://docs.dolphindb.cn/zh/funcs/ho_funcs/pcross.html)\n\n#### 语法\n\npcross(func, X, \\[Y])\n\n#### 详情\n\n*pcross* 是并行计算版本的 *cross* 高阶函数。\n\n"
    },
    "peach": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/peach.html",
        "signatures": [
            {
                "full": "peach(func, args...)",
                "name": "peach",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [peach](https://docs.dolphindb.cn/zh/funcs/ho_funcs/peach.html)\n\n\n\n#### 语法\n\npeach(func, args...)\n\n#### 详情\n\n*peach* 是并行计算版本的 *each* 高阶函数。对于执行时间较长的任务，*peach* 比 *each* 能节省大量的时间。但对于小任务，*peach* 可能执行时间要比each更长，因为并行函数调用的开销很大。\n\n#### 例子\n\n对于执行时间长的任务，使用 *peach* 进行并行计算，可以节约任务执行时间。\n\n```\nm=rand(1,20000:5000)\ntimer f=peach(mskew{,8},m)\n\nTime elapsed: 3134.71 ms\ntimer f=mskew(m,8)\n\nTime elapsed: 8810.485 ms\n```\n"
    },
    "pivot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/pivot.html",
        "signatures": [
            {
                "full": "pivot(func, funcArgs, rowAlignCol, colAlignCol)",
                "name": "pivot",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "rowAlignCol",
                        "name": "rowAlignCol"
                    },
                    {
                        "full": "colAlignCol",
                        "name": "colAlignCol"
                    }
                ]
            }
        ],
        "markdown": "### [pivot](https://docs.dolphindb.cn/zh/funcs/ho_funcs/pivot.html)\n\n\n\n#### 语法\n\npivot(func, funcArgs, rowAlignCol, colAlignCol)\n\n#### 参数\n\n* **func** 函数。\n\n* **funcArgs** func 的参数。如果 func 有多个参数，那么它是一个元组。\n\n* **rowAlignCol** 行的分组变量。\n\n* **colAlignCol** 列的分组变量。\n\n*rowAlignCol*, *colAlignCol* 和 *funcArgs* 中的每个参数都是相同长度的向量。\n\n#### 详情\n\n在指定的二维维度上重组数据，结果为一个矩阵。\n\n假设 *rowAlignCol* 有 n 个不同元素，*colAlignCol* 有 m 个不同元素。该高阶函数将会返回 n 行 m 列的矩阵，*colAlignCol* 的唯一值作为行标签，*rowAlignCol* 的唯一值作为列标签。对于矩阵的每一个元素，将指定函数应用到 *rowAlignCol* 和 *colAlignCol* 所指定的矩阵单元格的元素上。\n\n#### 例子\n\n本例计算多只股票收益率的两两相关性。\n\n原始数据表有 4 列：sym, price, volume 和 time。\n\n```\nsyms=`600300`600400`600500$SYMBOL\nsym=syms[0 0 0 0 0 0 0 1 1 1 1 1 1 1 2 2 2 2 2 2 2]\ntime=09:40:00+1 30 65 90 130 185 195 10 40 90 140 160 190 200 5 45 80 140 170 190 210\nprice=172.12 170.32 172.25 172.55 175.1 174.85 174.5 36.45 36.15 36.3 35.9 36.5 37.15 36.9 40.1 40.2 40.25 40.15 40.1 40.05 39.95\nvolume=100 * 10 3 7 8 25 6 10 4 5 1 2 8 6 10 2 2 5 5 4 4 3\nt1=table(sym, time, price, volume);\nt1;\n```\n\n| sym    | time     | price  | volume |\n| ------ | -------- | ------ | ------ |\n| 600300 | 09:40:01 | 172.12 | 1000   |\n| 600300 | 09:40:30 | 170.32 | 300    |\n| 600300 | 09:41:05 | 172.25 | 700    |\n| 600300 | 09:41:30 | 172.55 | 800    |\n| 600300 | 09:42:10 | 175.1  | 2500   |\n| 600300 | 09:43:05 | 174.85 | 600    |\n| 600300 | 09:43:15 | 174.5  | 1000   |\n| 600400 | 09:40:10 | 36.45  | 400    |\n| 600400 | 09:40:40 | 36.15  | 500    |\n| 600400 | 09:41:30 | 36.3   | 100    |\n| 600400 | 09:42:20 | 35.9   | 200    |\n| 600400 | 09:42:40 | 36.5   | 800    |\n| 600400 | 09:43:10 | 37.15  | 600    |\n| 600400 | 09:43:20 | 36.9   | 1000   |\n| 600500 | 09:40:05 | 40.1   | 200    |\n| 600500 | 09:40:45 | 40.2   | 200    |\n| 600500 | 09:41:20 | 40.25  | 500    |\n| 600500 | 09:42:20 | 40.15  | 500    |\n| 600500 | 09:42:50 | 40.1   | 400    |\n| 600500 | 09:43:10 | 40.05  | 400    |\n| 600500 | 09:43:30 | 39.95  | 300    |\n\n将数据依据 time 和 sym 维度对齐，并且计算每分钟内股价以交易量为权重的加权平均值。结果为一个矩阵。\n\n```\nstockprice=pivot(wavg, [t1.price, t1.volume], minute(t1.time), t1.sym)\nstockprice.round(2);\n```\n\n| label  | 600300 | 600400 | 600500 |\n| ------ | ------ | ------ | ------ |\n| 09:40m | 171.7  | 36.28  | 40.15  |\n| 09:41m | 172.41 | 36.3   | 40.25  |\n| 09:42m | 175.1  | 36.38  | 40.13  |\n| 09:43m | 174.63 | 36.99  | 40.01  |\n\n计算每分钟的股票收益率：\n\n```\nstockreturn = each(ratios, stockprice)-1\nstockreturn;\n```\n\n| label  | 600300    | 600400   | 600500    |\n| ------ | --------- | -------- | --------- |\n| 09:40m |           |          |           |\n| 09:41m | 0.004108  | 0.000459 | 0.002491  |\n| 09:42m | 0.015602  | 0.002204 | -0.003037 |\n| 09:43m | -0.002677 | 0.016871 | -0.003006 |\n\n计算股票收益率的两两相关性：\n\n```\ncross(corr, stockreturn, stockreturn);\n```\n\n| label  | 600300    | 600400    | 600500    |\n| ------ | --------- | --------- | --------- |\n| 600300 | 1         | -0.719182 | -0.151824 |\n| 600400 | -0.719182 | 1         | -0.577578 |\n| 600500 | -0.151824 | -0.577578 | 1         |\n\n统计每个股票每分钟内的记录数量：\n\n```\npivot(count, price, minute(time), sym);\n```\n\n| label  | 600300 | 600400 | 600500 |\n| ------ | ------ | ------ | ------ |\n| 09:40m | 2      | 2      | 2      |\n| 09:41m | 2      | 1      | 1      |\n| 09:42m | 1      | 2      | 2      |\n| 09:43m | 2      | 2      | 2      |\n\n每个股票每分钟里的最后一条记录：\n\n```\npivot(last, price, minute(time), sym);\n```\n\n| label  | 600300 | 600400 | 600500 |\n| ------ | ------ | ------ | ------ |\n| 09:40m | 170.32 | 36.15  | 40.2   |\n| 09:41m | 172.55 | 36.3   | 40.25  |\n| 09:42m | 175.1  | 36.5   | 40.1   |\n| 09:43m | 174.5  | 36.9   | 39.95  |\n\n**Related information**\n\n[unpivot](https://docs.dolphindb.cn/zh/funcs/u/unpivot.html)\n"
    },
    "ploop": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/ploop.html",
        "signatures": [
            {
                "full": "ploop(func, args...)",
                "name": "ploop",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [ploop](https://docs.dolphindb.cn/zh/funcs/ho_funcs/ploop.html)\n\n\n\n#### 语法\n\nploop(func, args...)\n\nploop 是 [loop](https://docs.dolphindb.cn/zh/funcs/ho_funcs/loop.html) 的并行版本。\n"
    },
    "reduce": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/reduce.html",
        "signatures": [
            {
                "full": "reduce(func, X, [init], [consistent=false])",
                "name": "reduce",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    },
                    {
                        "full": "[consistent=false]",
                        "name": "consistent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "reduce:T(X, [init])",
                "name": "reduce:T",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    }
                ]
            },
            {
                "full": "reduce:TC(X, [init])",
                "name": "reduce:TC",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[init]",
                        "name": "init",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [reduce](https://docs.dolphindb.cn/zh/funcs/ho_funcs/reduce.html)\n\n#### 语法\n\nreduce(func, X, \\[init], \\[consistent=false])\n\n或\n\nreduce:T(X, \\[init])（表示 consistent 为 false）\n\n或\n\nreduce:TC(X, \\[init])（表示 consistent 为 true）\n\n或\n\n\\[init] \\<operator>:T X（表示 consistent 为 false）\n\n或\n\n\\[init] \\<operator>:TC X\n\n#### 参数\n\n* **func** 函数。\n  * 当 *func* 是一元函数时，*X* 可以是非负整数、一元函数或空值。*init* 表示 *func* 的参数，必须指定。\n\n  * *func* 是二元函数时，*X* 是向量、矩阵或表。*init* 表示初始值。\n\n  * *func* 是三元函数时，*X* 必须是一个 Tuple，包含2个元素，分别表示 *func* 的后两个参数。\n\n* **consistent** 布尔值，默认 false，表示每个子任务输出的数据类型由实际计算结果决定。否则，每个子任务输出的数据类型将与第一个子任务输出的数据类型保持一致。\n\n  **Note:** 当前版本的实现不受 *consistent* 参数的影响，即 *consistent* 设置无效。\n\n#### 详情\n\n该函数与 `accumulate` 的功能相同，唯一区别是返回值不同。`reduce` 返回最后一个结果，而 `accumulate` 输出所有中间结果。关于函数功能描述，参见  [accumulate](https://docs.dolphindb.cn/zh/funcs/ho_funcs/accumulate.html)。\n\n`reduce` 等同于以下伪代码的执行过程：\n\n```\nresult=<function>(init,X[0]);\n\nfor(i:1~size(X)){\n\nresult=<function>(result, X[i]);\n\n}\n\nreturn result;\n```\n\n#### 例子\n\n*func* 是一元函数时：\n\n通过以下方式定义一个一元函数：\n\n```\ndef func1(x){\n  if(x<5){\n          return x*3\n  }\n  else{\n          return x+3\n  }\n}\n```\n\n当 X 为整数时，迭代 X 次，输出最后一个结果：\n\n```\nreduce(func1, 5, 1)\n```\n\n返回：18\n\n当 X 为一元函数 condition 时，第3次迭代时因 condition 返回false，停止迭代2次后停止，并输出最后一个结果。\n\n```\ndef condition(x){\n  return x<9\n}\nreduce(func1, condition, 1)\n```\n\n返回：9\n\n当 X 为 NULL（或不指定）时，自定义函数 func2 作为进行迭代的函数。\n\n```\ndef func2(x){\n  if(x<5){\n          return x*3\n  }\n  else{\n          return 6\n  }\n}\n\n//因第4次迭代结果和第3次相同，停止迭代并输出最后一个结果。\nreduce(func2,NULL,1)\n```\n\n返回：6\n\n*func* 是二元函数时，在一个向量上执行 `reduce`：\n\n```\nreduce(mul, 1..10);\n```\n\n返回：3628800，即 10 的阶乘。上例如果由 `accumulate` 高阶函数实现，则是：\n\n```\n*:A 1..10;\n```\n\n返回：\\[1,2,6,24,120,720,5040,40320,362880,3628800]\n\n```\n2 *:T 1..10;\n```\n\n返回：7257600\n\n```\ndef f1(a,b):a+log(b);\nreduce(f1, 1..5, 0);\n```\n\n返回：4.787492\n\n对一个矩阵执行 `reduce`：\n\n```\nx=1..12$3:4;\nx;\n```\n\n得到：\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 1    | 4    | 7    | 10   |\n| 2    | 5    | 8    | 11   |\n| 3    | 6    | 9    | 12   |\n\n```\n+ :T x;\n```\n\n返回：\\[22,26,30]\n\n*func* 是三元函数时：\n\n```\ndef fun3(x,y,z){\n  return x+y+z\n}\nreduce(fun3,[[1,2,3],[10,10,10]],5)\n```\n\n返回：41\n\n"
    },
    "rolling": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/rolling.html",
        "signatures": [
            {
                "full": "rolling(func, funcArgs, window, [step=1])",
                "name": "rolling",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[step=1]",
                        "name": "step",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [rolling](https://docs.dolphindb.cn/zh/funcs/ho_funcs/rolling.html)\n\n#### 语法\n\nrolling(func, funcArgs, window, \\[step=1])\n\n#### 参数\n\n* **func** 聚合函数或向量函数。若 *func* 是向量函数，则 *step* 必须和 *window* 相等。\n\n* **funcArgs** 函数 *func* 的参数。可为向量或矩阵。如果有多个参数，则用元组表示，并且每个参数的长度（向量的元素个数或矩阵的行数）必须相同。\n\n* **window** 滑动窗口长度。\n\n* **step** 应用函数的频率。默认值为1。\n\n#### 详情\n\n应用函数/运算符到给定对象的一个滑动窗口（ *step* 与 *window* 取相同值时为滚动窗口）上。\n\n当第一个滑动窗口出现时，高阶函数开始计算，然后每经过 *step* 个元素就进行一次变量计算。\n\n**Note:**\n\n* 当 *func* 指定为向量函数时，*window* 必须等于 *step*。\n\n* 若窗口内的元素个数小于窗口长度，则该窗口不会计算输出。\n\n和 *moving* 高阶函数类似，即对矩阵来说滑动窗口还是按行计算，而其他高阶函数通常是按列计算。\n\n`rolling` 的 *func* 支持向量函数和聚合函数，而 `moving` 的 *func* 只支持聚合函数。\n\n*func* 为聚合函数时，`rolling` 与 `moving` 的区别是：\n\n1. `rolling` 支持参数 *step*，可以指定窗口滑动的步长；而 `moving` 的滑动步长只能是 1。\n\n2. `rolling` 不输出前 *window* - 1 个 NULL 值结果。\n\n#### 例子\n\n*func* 为向量函数：\n\n```\nm = matrix(3 4 6 8 5 2 0 -2, 2 9 NULL 1 3 -4 2 1, NULL 8 9 8 0 1 9 -3)\nrolling(cummax, m, 4, 4)\n```\n\n输出返回：\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 3    | 2    |      |\n| 4    | 9    | 8    |\n| 6    | 9    | 9    |\n| 8    | 9    | 9    |\n| 5    | 3    | 0    |\n| 5    | 3    | 1    |\n| 5    | 3    | 9    |\n| 5    | 3    | 9    |\n\n```\nrolling(cumsum, m, 3, 3)\n```\n\n输出返回：\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 3    | 2    |      |\n| 7    | 11   | 8    |\n| 13   | 11   | 17   |\n| 8    | 1    | 8    |\n| 13   | 4    | 8    |\n| 15   | 0    | 9    |\n\n*func* 为聚合函数：\n\n```\nrolling(sum, m, 4)\n```\n\n输出返回：\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 21   | 12   | 25   |\n| 23   | 13   | 25   |\n| 21   | 0    | 18   |\n| 15   | 2    | 18   |\n| 5    | 2    | 7    |\n\n计算APPL相对于市场(SPY)的beta值，滑动窗口长度为10，频率为5。\n\n```\ndate=2016.08.01..2016.08.31\ndate=date[1<=weekday(date)<=5]\naaplRet=0.0177 -0.0148 0.0125 0.0008 0.0152 0.0083 0.0041 -0.0074 -0.0006 0.0023 0.0120 -0.0009 -0.0015 -0.0013 0.0026 -0.0078 0.0031 -0.0075 -0.0043 -0.0059 -0.0011 -0.0077 0.0009\nspyRet=-0.0008 -0.0064 0.0029 0.0011 0.0082 -0.0006 0.0006 -0.0025 0.0046 -0.0009 0.0029 -0.0052 0.0019 0.0022 -0.0015 0.0000 0.0020 -0.0051 -0.0007 -0.0019 0.0049 -0.0016 -0.0028\nt=table(date, aaplRet, spyRet);\nt;\n```\n\n输出返回：\n\n| date       | aaplRet | spyRet  |\n| ---------- | ------- | ------- |\n| 2016.08.01 | 0.0177  | -0.0008 |\n| 2016.08.02 | -0.0148 | -0.0064 |\n| 2016.08.03 | 0.0125  | 0.0029  |\n| 2016.08.04 | 0.0008  | 0.0011  |\n| 2016.08.05 | 0.0152  | 0.0082  |\n| 2016.08.08 | 0.0083  | -0.0006 |\n| 2016.08.09 | 0.0041  | 0.0006  |\n| 2016.08.10 | -0.0074 | -0.0025 |\n| 2016.08.11 | -0.0006 | 0.0046  |\n| 2016.08.12 | 0.0023  | -0.0009 |\n| 2016.08.15 | 0.012   | 0.0029  |\n| 2016.08.16 | -0.0009 | -0.0052 |\n| 2016.08.17 | -0.0015 | 0.0019  |\n| 2016.08.18 | -0.0013 | 0.0022  |\n| 2016.08.19 | 0.0026  | -0.0015 |\n| 2016.08.22 | -0.0078 | 0       |\n| 2016.08.23 | 0.0031  | 0.002   |\n| 2016.08.24 | -0.0075 | -0.0051 |\n| 2016.08.25 | -0.0043 | -0.0007 |\n| 2016.08.26 | -0.0059 | -0.0019 |\n| 2016.08.29 | -0.0011 | 0.0049  |\n| 2016.08.30 | -0.0077 | -0.0016 |\n| 2016.08.31 | 0.0009  | -0.0028 |\n\n```\n// 计算滚动beta\nbetas = rolling(beta, [aaplRet, spyRet], 10,5);\ndates = rolling(last, date, 10,5);\ntable(dates, betas);\n```\n\n输出返回：\n\n| dates      | betas    |\n| ---------- | -------- |\n| 2016.08.12 | 1.601173 |\n| 2016.08.19 | 0.512656 |\n| 2016.08.26 | 1.064465 |\n\n生成一个带有行标签的矩阵 m，将其作为参数 *func*Args。\n\n当传入参数 *func* 是一个聚合函数，输出带有行标签的结果矩阵。\n\n```\nminBar = 2024.03.08T10:00:00 + 0..9\naaplClose = [170.88,170.88,170.90,171.05,171.18,171.30,171.51,171.49,171.31,171.14]\nibmClose = [150.15,150.18,150.20,150.05,150.18,150.25,150.32,150.30,150.31,150.20]\nm = matrix(aaplClose, ibmClose).rename!(minBar, `aapl`ibm)\n\n// func 也支持传入自定义的聚合函数\nrolling(func=avg, funcArgs=m, window=5, step=2)\n```\n\n输出结果：\n\n<table id=\"table_kqz_mfs_xbc\"><tbody><tr><td>\n\nlabel\n\n</td><td>\n\naapl\n\n</td><td>\n\nibm\n\n</td></tr><tr><td>\n\n2024.03.08T10:00:00\n\n</td><td>\n\n170.978\n\n</td><td>\n\n150.152\n\n</td></tr><tr><td>\n\n2024.03.08T10:00:02\n\n</td><td>\n\n171.188\n\n</td><td>\n\n150.2\n\n</td></tr><tr><td>\n\n2024.03.08T10:00:04\n\n</td><td>\n\n171.358\n\n</td><td>\n\n150.272\n\n</td></tr></tbody>\n</table>承接上例，当传入参数 *func* 是一个部分应用，也可输出带有行标签的结果矩阵。\n\n```\ndefg f1(x,y){\n\treturn (last(x)-first(x))/size(x)+y\n}\nf2 = f1{,1}\nrolling(func=f2, funcArgs=m, window=5, step=2)\n```\n\n输出结果：\n\n<table id=\"table_s2r_nfs_xbc\"><tbody><tr><td>\n\nlabel\n\n</td><td>\n\naapl\n\n</td><td>\n\nibm\n\n</td></tr><tr><td>\n\n2024.03.08T10:00:00\n\n</td><td>\n\n1.06\n\n</td><td>\n\n1.006\n\n</td></tr><tr><td>\n\n2024.03.08T10:00:02\n\n</td><td>\n\n1.122\n\n</td><td>\n\n1.024\n\n</td></tr><tr><td>\n\n2024.03.08T10:00:04\n\n</td><td>\n\n1.026\n\n</td><td>\n\n1.026\n\n</td></tr></tbody>\n</table>**Parent topic:**[函数参考](../../funcs/funcs_intro.md)\n"
    },
    "rowGroupby": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/rowgroupby.html",
        "signatures": [
            {
                "full": "rowGroupby(func, funcArgs, groupingCol, [mode='tuple'], [ascending=true])",
                "name": "rowGroupby",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "groupingCol",
                        "name": "groupingCol"
                    },
                    {
                        "full": "[mode='tuple']",
                        "name": "mode",
                        "optional": true,
                        "default": "'tuple'"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [rowGroupby](https://docs.dolphindb.cn/zh/funcs/ho_funcs/rowgroupby.html)\n\n#### 语法\n\nrowGroupby(func, funcArgs, groupingCol, \\[mode='tuple'], \\[ascending=true])\n\n#### 参数\n\n**func** 一个聚合函数。\n\n**funcArgs** 是函数 *func* 的参数。如果有多个参数，则用元组表示，且每个元素的维度必须和 *groupingCol* 保持一致。\n\n**groupingCol** 非空矩阵或数组向量，用于分组。\n\n**mode** 可选参数，指定 `rowGroupby` 返回值的数据形式，默认为 \"tuple\"。可取值为：\n\n* \"tuple\"：返回一个长度为2的 tuple，其第1个元素是一个数组向量，存储分组变量，第2个元素是一个数组向量，存储各分组中 *funcArgs* 应用 *func* 后的结果。\n\n* \"dict\"：返回一个字典。包含两个元素：'key' 和 'value'，分别存储分组变量和各分组中 *funcArgs* 应用*func* 后的结果。\n\n* \"table\"：返回一个包含两列的表。字段为 \"key\" 和 \"value\"，分别存储分组变量及各分组中 *funcArgs* 应用 *func* 后的结果。\n\n**ascending** 布尔值，表示输出结果按 *groupingCol* 升序还是降序排序。默认值为 true（升序）。\n\n#### 详情\n\n对 *groupingCol* 的每一行分组后，在每个分组中计算 *func(funcArgs)*，每组的计算结果是一个标量。该函数将根据 *mode* 指定的形式输出结果。\n\n#### 例子\n\n下例对表 t 中的 price 列按升序排序后分组，对每个分组内对应的 qty 进行求和。\n\n```\nsym=`A`B\nprice = array(DOUBLE[], 0).append!([12.5 12.6 12.5 12.5 12.6, 15.5 15.5 15.5 15.3 15.3])\nqty = array(INT[], 0).append!([201 212 220 215 214, 210 213 223 219 211])\nt=table(sym,price,qty) \n//指定 mode='dict' 时，以字典形式输出结果，其中 key 存储 price 排序后分组的结果，value 存储对 qty 分组求和的结果\nrowGroupby(func=sum,funcArgs=t.qty,groupingCol=t.price,mode='dict') \n\n/* output:\nvalue->[[636,426],[430,646]]\nkey->[[12.5,12.6],[15.3,15.5]]\n*/\n\n//指定 ascending=false，按照 price 降序输出结果。\nrowGroupby(func=sum,funcArgs=t.qty,groupingCol=t.price,mode='dict', ascending=false)\n/* output:\nvalue->[[426,636],[646,430]]\nkey->[[12.6000,12.5000],[15.5000,15.3000]]\n*/\n\n//指定 mode='table' 时，以表的形式输出结果，其中 key 存储 price 排序后分组的结果，value 存储对 qty 分组求和的结果\nrowGroupby(func=sum,funcArgs=t.qty,groupingCol=t.price,mode='table')\n```\n\n| key          | value      |\n| ------------ | ---------- |\n| \\[12.5,12.6] | \\[636,426] |\n| \\[15.3,15.5] | \\[430,646] |\n\n```\n//指定 mode='tuple'，输出结果为 tuple，将 tuple 的两个元素重命名后作为表的一列输出。\nselect rowGroupby(sum, qty, price, 'tuple') as `a`b from t\n```\n\n| a            | b          |\n| ------------ | ---------- |\n| \\[12.5,12.6] | \\[636,426] |\n| \\[15.3,15.5] | \\[430,646] |\n\n接下来通过一个例子来展示如何在矩阵上使用 `rowGroupby` 函数：\n\n```\nm=matrix([32.5 12.6 22.5 42.5 32.6, 17.5 25.5 35.5 17.3 19.3, 17 20.1 30 13 19])\ng=matrix([1 2 2 5 4, 2 2 3 2 1, 1 3 2 3 5])\n//对 g 的每行排序后分组，对 m 的每行在每个组内进行求和\nrowGroupby(func=sum, funcArgs=m, groupingCol=g, mode='table')\n```\n\n| key      | value           |\n| -------- | --------------- |\n| \\[1,2]   | \\[49.5,17.5]    |\n| \\[2,3]   | \\[38.1,20.1]    |\n| \\[2,3]   | \\[52.5,35.5]    |\n| \\[2,3,5] | \\[17.3,13,42.5] |\n| \\[1,4,5] | \\[19.3,32.6,19] |\n\n"
    },
    "segmentby": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/segmentby.html",
        "signatures": [
            {
                "full": "segmentby(func, funcArgs, segment)",
                "name": "segmentby",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "segment",
                        "name": "segment"
                    }
                ]
            }
        ],
        "markdown": "### [segmentby](https://docs.dolphindb.cn/zh/funcs/ho_funcs/segmentby.html)\n\n\n\n#### 语法\n\nsegmentby(func, funcArgs, segment)\n\n#### 详情\n\n根据 *segment* 参数确定分组方案，把 *funcArgs* 分组，并把函数 *func* 应用到每个分组中。返回的结果与 *segment* 参数的长度相同。\n\n#### 参数\n\n* **func** 是一个函数。\n\n* **funcArgs** 是函数的参数。\n\n* **segment** 是分组向量。segment参数中连续相同的元素为一组。segment的长度必须和funcArgs相同。\n\n#### 例子\n\n下面的例子中，y确定了3个分组：1 1 1、-1 -1 -1和1 1 1。第一个分组的index是0-2，第二个分组的index是3-5，第三个分组的index是6-9。按照这个规则把x分成3组，1 2 3、0 3 2和1 4 5，并把 [cumsum](https://docs.dolphindb.cn/zh/funcs/c/cumsum.html) 函数应用到x的每个分组，计算每个分组的累计和。\n\n```\nx=1 2 3 0 3 2 1 4 5\ny=1 1 1 -1 -1 -1 1 1 1\nsegmentby(cumsum,x,y);\n// output\n[1,3,6,0,3,5,1,5,10]\n```\n\n*segmentby* 可用于止损回测。下面的例子把回报率ret分为两组，分别判断position=1和position=-1这两种情况下，是否需要止损。\n\n```\ndef stoploss(ret, threshold){\n     cumret = cumprod(1+ret)\n     drawDown = cumret.cummax() / cumret - 1\n     firstCutIndex = at(drawDown >= threshold).first() + 1\n     indicator = take(false, ret.size())\n     if(isValid(firstCutIndex) and firstCutIndex < ret.size())\n         indicator[firstCutIndex:] = true\n     return indicator\n}\nposition = 1 1 1 1 1 -1 -1 -1 -1\nret = 0.01 0.02 -0.04 -0.02 -0.01 -0.005 -0.015 0.005 0.025\nsegmentby(stoploss{,0.05}, ret, position);\n// output\n[false,false,false,false,true,false,false,false,false]\n```\n"
    },
    "talib": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/talib.html",
        "signatures": [
            {
                "full": "talib(func, args...)",
                "name": "talib",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [talib](https://docs.dolphindb.cn/zh/funcs/ho_funcs/talib.html)\n\n\n\n#### 语法\n\ntalib(func, args...)\n\n#### 参数\n\n* **func** 是一个函数名。\n\n* **args** 是函数 func 的参数。\n\n其他相关的 talib 系列函数的参数说明和窗口计算规则请参考: [TA-lib 系列](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 详情\n\n当 args 的前几个元素为 NULL 时，DolphinDB 内置滑动窗口函数与 python TA-lib 的处理方式不同：\n\n* DolphinDB 滑动窗口函数：窗口从第一个元素开始进行滑动窗口计算；\n\n* python TA-lib： 保留开始的所有前置 NULL 值，然后从第一个非空元素开始进行滑动窗口计算。\n\n若需要与 python TA-lib 保持一致的处理方式，可以使用 talib 函数。\n\n#### 例子\n\n以下例子通过对比说明了 `talib` 函数和 DolphinDB 函数处理 NULL 值的区别。\n\n```\nmsum(NULL 1 2 3 4 5 6 7 8 9, 3)\n```\n\n输出返回：\\[,,3,6,9,12,15,18,21,24]\n\n```\ntalib(msum, NULL 1 2 3 4 5 6 7 8 9, 3)\n```\n\n输出返回：\\[,,,6,9,12,15,18,21,24]\n"
    },
    "tmoving": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/tmoving.html",
        "signatures": [
            {
                "full": "tmoving(func, T, funcArgs, window, [excludedPeriod])",
                "name": "tmoving",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[excludedPeriod]",
                        "name": "excludedPeriod",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [tmoving](https://docs.dolphindb.cn/zh/funcs/ho_funcs/tmoving.html)\n\n#### 语法\n\ntmoving(func, T, funcArgs, window, \\[excludedPeriod])\n\n#### 详情\n\n应用函数/运算符到给定对象的一个滚动窗口上。*tmoving* 高阶函数返回一个向量，长度与输入参数的长度相同。\n\n内置函数 [tmsum](https://docs.dolphindb.cn/zh/funcs/t/tmsum.html), [tmcount](https://docs.dolphindb.cn/zh/funcs/t/tmcount.html) 和 [tmavg](https://docs.dolphindb.cn/zh/funcs/t/tmavg.html) 为各自的计算场景进行了优化，因此比 *tmoving* 高阶函数有更好的性能。\n\n#### 参数\n\n* **func** 是一个函数。\n\n* **T** 是一个递增的整型或时间类型的向量，且不能包含NULL值。\n\n* **funcArgs** 是函数func的参数。可为向量、字典或表。如果有多个参数，则用元组表示，并且每个参数的长度（向量/字典的元素个数或表的行数）必须相同。\n\n* **window** 是一个正整数或一个 [duration](https://docs.dolphindb.cn/zh/funcs/d/duration.html)，表示滚动窗口的区间大小。 对于 *T* 中每个元素Ti，确定一个区间为\\[Ti - window + 1, Ti]的移动窗口，所有包含在这个区间的数据均属于该窗口。\n\n* **excludedPeriod** 是　TIME、NANOTIME、MINUTE 和 SECOND 类型的数据对。用于设定一个交易日内的非交易时间段（该时间段被排除在计算窗口之外）。若设置该参数，必须同时保证以下3点：\n\n  * 数据对中的右值必须大于左值。\n\n  * 时间段长度必须小于 (24 - *window*)\n\n  * *T* 中不能包含 *excludedPeriod* 区间内的时间，且数据类型必须是 TIMESTAMP, NANOTIMESTAMP, TIME 或 NANOTIME。\n\n其他相关的 tm 系列函数的参数说明和窗口计算规则请参考: [tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 例子\n\n```\ndate=2021.08.01 2021.08.02 2021.08.02 2021.08.02 2021.08.03 2021.08.04 2021.08.05 2021.08.06 2021.08.09 2021.08.10 2021.08.14\nvalue=1..11\nt = table(date,value)\ntimer(100) select date, value, tmoving(avg,date,value,3d) from t;\n\n//output: Time elapsed: 7.9 ms\n```\n\n```\ntimer(100) select date, value, tmavg(date, value, 3d) from t;\n\n//output: Time elapsed: 6.805 ms\n```\n\n单独打印计算结果，可以看到，当窗口滑动到2021.08.09，计算窗口范围为 \\[2021.08.07, 2021.08.08, 2021.08.09]，但 7 日和 8 日值缺失，因此不参与计算。\n\n| date       | value | tmoving\\_sum |\n| ---------- | ----- | ------------ |\n| 2021.08.01 | 1     | 1            |\n| 2021.08.02 | 2     | 1.5          |\n| 2021.08.02 | 3     | 2            |\n| 2021.08.02 | 4     | 2.5          |\n| 2021.08.03 | 5     | 3            |\n| 2021.08.04 | 6     | 4            |\n| 2021.08.05 | 7     | 6            |\n| 2021.08.06 | 8     | 7            |\n| 2021.08.09 | 9     | 9            |\n| 2021.08.10 | 10    | 9.5          |\n| 2021.08.14 | 11    | 11           |\n\n下例通过 *excludedPeriod* 参数指定股市上午的休市时间，计算长度为一分钟的滚动窗口内的价格平均值。\n\n```\nexcludedPeriod=(11:30:00:13:00:00)\nts=timestamp(2023.11.01T11:21:00+1..500) join timestamp(2023.11.01T13:00:00+1..500)\nt=table(ts, rand(10.0,size(ts)) as price)\n\n// 通过 excludedPeriod 指定休市时间为11:30:00 到 13:00:00，则此段时间被忽略，不会被作为计算窗口。\nres1=select ts, tmoving(func=avg, T=ts, funcArgs=price, window=1m, excludedPeriod=excludedPeriod) from t\n// 不指定 excludedPeriod 时，休市时间也会被考虑为计算窗口。\nres2=select ts, tmoving(func=avg, T=ts, funcArgs=price, window=1m) from t\n\n// 对比是否指定 excludedPeriod 的计算结果。\nselect * from res1 where ts between timestamp(2023.11.01T13:00:00) and timestamp(2023.11.01T13:01:00)\n\nselect * from res2 where ts between timestamp(2023.11.01T13:00:00) and timestamp(2023.11.01T13:01:00)\n```\n\n下例通过指定多个 *funcArgs* 参数，计算长度为 5 分钟的滚动窗口内债券价格在达到峰值后的最低值。\n\n```\ndata_time = 2023.01.01T00:00:00 + 0..5 * 3600000  \nlast_price_bond = 100 + rand(10.0, 10) \n\ndefg getMinPrice(data_time, last_price_bond){\n        maxPriceTime = atImax(last_price_bond, data_time)\n        maxPrice = max(last_price_bond)\n        newPriceList = min(iif(data_time<maxPriceTime, maxPrice, last_price_bond))\n        return min(newPriceList)\n}\ncalTime = \"5m\"\ntmoving(getMinPrice, data_time, [data_time, last_price_bond], duration(calTime))\n```\n\n"
    },
    "twindow": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/twindow.html",
        "signatures": [
            {
                "full": "twindow(func, funcArgs, T, range, [prevailing=false], [excludedPeriod])",
                "name": "twindow",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "range",
                        "name": "range"
                    },
                    {
                        "full": "[prevailing=false]",
                        "name": "prevailing",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[excludedPeriod]",
                        "name": "excludedPeriod",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [twindow](https://docs.dolphindb.cn/zh/funcs/ho_funcs/twindow.html)\n\n#### 语法\n\ntwindow(func, funcArgs, T, range, \\[prevailing=false], \\[excludedPeriod])\n\n#### 参数\n\n* **func** 是一个聚合函数。\n\n* **funcArgs** 是 *func* 的参数。*func* 有多个参数时，它是一个元组。\n\n* **T** 是一个非严格递增的整型或时间类型的向量。\n\n* **range** 是一个整型数据对或 DURATION 数据对，左右边界都包含在内。\n\n* **prevailing** 只能为 0/false，1/true 或 2。\n\n  * 如果 *prevailing* = 0/false，则滑动窗口不对边界重复值做处理，请阅读详情部分。\n\n  * 如果 *prevailing* = 1/true，则滑动窗口边界的选取规则同 [pwj](https://docs.dolphindb.cn/zh/progr/sql/windowjoin.html)。\n\n  * 如果 *prevailing* = 2，（假设 *range* 参数为 d1:d2）：\n\n    * 若 d1 为 0，则滑动窗口将把当前索引对象作为边界，窗口左边的重复值不参与计算。\n\n    * 若 d2 为 0，则滑动窗口将把当前索引对象作为边界，窗口右边的重复值不参与计算。\n\n    * 当前情况下不可以同时设置参数 *excludedPeriod*。\n\n* **excludedPeriod** 是　TIME、NANOTIME、MINUTE 和 SECOND 类型的数据对。用于设定一个交易日内的非交易时间段（该时间段被排除在计算窗口之外）。若设置该参数，必须同时保证以下3点：\n\n  * 数据对中的右值必须大于左值。\n\n  * 时间段长度必须小于 (24 - *range*)\n\n  * *T* 中不能包含 *excludedPeriod* 区间内的时间，且数据类型必须是 TIMESTAMP, NANOTIMESTAMP, TIME 或 NANOTIME。\n\n#### 详情\n\n应用函数/运算符到给定对象的滑动窗口。对给定对象的每一个元素，滑动窗口由 *T* 和 *range* 决定。 结果的维度与 *funcArgs* 的维度相同（若 *funcArgs* 是一个元组，结果的维度与该元组中每个元素的维度相同）。\n\n滑动窗口的确定规则（假设 *range* 参数为 d1:d2）：\n\n1. *range* 是整型数据对时：\n\n   * *T* 如果为整型向量，对 *T* 内元素 Ti，可以确定 *T* 对应的窗口范围为 \\[Ti+d1, Ti+d2]。\n\n   * *T* 如果为时间类型向量，*range* 的精度默认为 *T* 的精度，对于 *T* 内元素 Ti，确定的窗口范围为 \\[temporalAdd(Ti, d1, unit), temporalAdd(Ti, d2, unit)]，其中 unit 是 *T* 的精度。\n\n2. *range* 是 DURATION 数据对时，*T* 只能是时间类型向量，对于 *T* 内元素 Ti，确定 *T* 对应的窗口元素范围为 \\[temporalAdd(Ti, d1), temporalAdd(Ti, d2)]。\n\n与 `tmoving` 函数相比，`twindow` 函数具有更灵活的窗口。`tmoving` 可以视为 `twindow` 指定 *range* 右边界为 0 的特殊情况， 但需要注意以时间长度衡量窗口时，两者对窗口边界的处理有区别：\n\n1. `twindow` 窗口的右边界与多条相同的值匹配时，该窗口会包含所有重复匹配的记录。当其窗口左边界与多条相同的值匹配时， 若 *prevailing* = true，则窗口只包含最后一个值；若 *prevailing* = false，则窗口亦会包含所有重复值。\n\n2. `tmoving` 函数的窗口范围为(Ti - window, Ti] 或 (temporalAdd(Ti - window), Ti]，即 `tmoving` 函数只基于当前滑动到的记录，确定一个向前的窗口， 不考虑右边界是否有重复值；且左边界不包含在内。\n\n#### 例子\n\n*prevailing* = false，左边界对应多个重复值，计算窗口会包含所有重复值\n\n```\nt = 2021.01.02 2021.01.02 2021.01.06 2021.03.09 2021.03.10 2021.03.12 2021.03.12\nx = -5 5 NULL -1 2 4 -8\ntwindow(func=min,funcArgs=x,T=t,range=0:2)\n```\n\n输出返回：\\[-5, -5, , -1, -8, -8, -8]\n\n*prevailing* = true，左边界对应多个重复值，计算窗口只包含最后一个值\n\n```\ntwindow(func=min, funcArgs=x, T=t, range=0:3, prevailing=true)\n```\n\n输出返回：\\[5, 5, ,-8, -8, -8, -8]\n\n```\ntwindow(func=max, funcArgs=x, T=t, range=0d:3d)\n```\n\n输出返回：\\[5, 5, , 4, 4, 4, 4]\n\n```\ntwindow(func=max, funcArgs=x, T=t, range=0:3, prevailing=true)\n```\n\n输出返回：\\[5, 5, , 4, 4, -8, -8]\n\n```\ntwindow(func=max, funcArgs=x, T=t, range=0M:3M)\n```\n\n输出返回：\\[5, 5, 4, 4, 4, 4, 4]\n\n```\ntwindow(func=max, funcArgs=x, T=t, range=0M:3M, prevailing=true)\n```\n\n输出返回：\\[5, 5, 4, 4, 4, -8, -8]\n\n```\ny = 4.8 9.6 7.1 3.3 5.9 2.7 6.9\ntwindow(func=corr, funcArgs=(x,y), T=t, range=0:3)\n```\n\n输出返回：\\[1, 1, , -0.685, -0.7893, -1, -1]\n\n```\nt1 = table(`A`A`B`B`C`C as sym, 09:56:03 09:56:07 09:56:02 09:56:05 09:56:04 09:56:06 as time, 10.6 10.7 20.6 11.6 11.7 19.6 as price)\nselect *, twindow(func=avg, funcArgs=t1.price, T=t1.time, range=2s:4s) from t1 context by sym\n```\n\n返回：\n\n| sym | time     | price | window\\_avg |\n| --- | -------- | ----- | ----------- |\n| A   | 09:56:03 | 10.6  | 10.7        |\n| A   | 09:56:07 | 10.7  |             |\n| B   | 09:56:02 | 20.6  | 11.6        |\n| B   | 09:56:05 | 11.6  |             |\n| C   | 09:56:04 | 11.7  | 19.6        |\n| C   | 09:56:06 | 19.6  |             |\n\n下例通过 *excludedPeriod* 参数指定股市上午的休市时间，计算长度为一分钟的滑动窗口内的价格平均值。\n\n```\nexcludedPeriod=(11:30:00:13:00:00)\nts=timestamp(2023.11.01T11:21:00+1..500) join timestamp(2023.11.01T13:00:00+1..500)\nt=table(ts, rand(10.0,size(ts)) as price)\n\n// 通过 excludedPeriod 指定休市时间为11:30:00 到 13:00:00，则此段时间被忽略，不会被作为计算窗口。\nres1=select ts, twindow(func=avg, T=ts, funcArgs=price, range=-1m:0m, excludedPeriod=excludedPeriod) from t\n// 不指定 excludedPeriod 时，休市时间也会被考虑为计算窗口。\nres2=select ts, twindow(func=avg, T=ts, funcArgs=price, range=-1m:0m) from t\n\n// 对比是否指定 excludedPeriod 的计算结果。\nselect * from res1 where ts between timestamp(2023.11.01T13:00:00) and timestamp(2023.11.01T13:01:00)\n\nselect * from res2 where ts between timestamp(2023.11.01T13:00:00) and timestamp(2023.11.01T13:01:00)\n```\n\n只传入前四个参数，且设置 *prevailing* 为 2。\n\n```\nt=[09:30:00.020,09:30:00.020,09:30:00.020,09:30:00.030,09:30:00.040,09:30:00.040]\nv=0 1 2 3 5 4\ntwindow(min,v,t,0ms:10ms,prevailing = 2) \n//Output: [0,1,2,3,4,4]\ntwindow(min,v,t,-10ms:0ms,prevailing = 2) \n//Output: [0,0,0,0,3,3]\n\n//非法输入\ntwindow(min,v,t,-10ms:10ms,prevailing = 2) \n//Output: Usage: twindow(func, funcArgs, T, range, [prevailing=0], [excludedPeriod]). left offset or right offset must be zero when prevailing =2.\ntwindow(min,v,t,0ms:0ms,prevailing = 2) \n//Output: Usage: twindow(func, funcArgs, T, range, [prevailing=0], [excludedPeriod]). 0:0 is illegal window when prevailing =2.\n```\n\n"
    },
    "unifiedCall": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/unifiedCall.html",
        "signatures": [
            {
                "full": "unifiedCall(func, args)",
                "name": "unifiedCall",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args",
                        "name": "args"
                    }
                ]
            }
        ],
        "markdown": "### [unifiedCall](https://docs.dolphindb.cn/zh/funcs/ho_funcs/unifiedCall.html)\n\n\n\n#### 语法\n\nunifiedCall(func, args)\n\n#### 参数\n\n**func** 是一个函数。\n\n**args** 是一个tuple, tuple的每一个元素作为函数的参数。\n\n#### 详情\n\n用指定的参数调用一个函数。同 [call](https://docs.dolphindb.cn/zh/funcs/ho_funcs/call.html) 类似，可以用在 [each/peach](https://docs.dolphindb.cn/zh/funcs/ho_funcs/each.html) 或 [loop](https://docs.dolphindb.cn/zh/funcs/ho_funcs/loop.html)/[ploop](https://docs.dolphindb.cn/zh/funcs/ho_funcs/ploop.html) 函数中，来调用一批函数。区别在于，*call* 函数的args参数个数不确定，由func传入的函数决定。 而 *unifiedCall* 的args只有一个，通过tuple来给func函数传入多个参数。\n\n#### 例子\n\n```\nunifiedCall(sum, [1..10])\n```\n\n返回：55\n\n```\nunifiedCall(add, ([1,2,3,4,5,6,7,8,9,10],2))\n```\n\n返回：\\[3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\n```\neach(unifiedCall, [std, max], [[matrix(1 3 5 7 9, 1 4 7 10 13)], [0..100]]);\n```\n\n得到：\n\n| col1   | col2 |\n| ------ | ---- |\n| 3.1623 | 100  |\n| 4.7434 | 100  |\n\n下面这个例子，自定义一个函数，再通过unifiedCall传入参数，进行调用。\n\n```\ndef f(a,b){return (a+2)*b}\nunifiedCall(f, (5,10))\n```\n\n返回：70\n"
    },
    "window": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/window.html",
        "signatures": [
            {
                "full": "window(func, funcArgs, range)",
                "name": "window",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "funcArgs",
                        "name": "funcArgs"
                    },
                    {
                        "full": "range",
                        "name": "range"
                    }
                ]
            }
        ],
        "markdown": "### [window](https://docs.dolphindb.cn/zh/funcs/ho_funcs/window.html)\n\n\n\n#### 语法\n\nwindow(func, funcArgs, range)\n\n#### 参数\n\n* **func** 是一个聚合函数。\n\n* **funcArgs** 是 *func* 的参数。*func* 有多个参数时，它是一个元组。\n\n* **range** 是一个整型数据对或 DURATION 数据对，左右边界都包含在内。\n\n**Note:** 如果 *range* 是 DURATION 类型，则 *funcArgs* 必须是一个索引矩阵（indexed matrix）或者是索引序列（indexed series）。\n\n#### 详情\n\n应用函数/运算符到给定对象的滑动窗口。对给定对象的每一个元素，滑动窗口由 *range* 决定。结果的维度与 *funcArgs* 的维度相同（若 *funcArgs* 是一个元组， 结果的维度与该元组中每个元素的维度相同）。\n\n滑动窗口的确定规则（假设 *range* 参数为 d1:d2）：\n\n1. 若 *funcArgs* 为向量，*range* 必须为整型。对 *funcArgs* 中第 i 位的元素，窗口所含元素的位置区间为 \\[i+d1, i+d2] 。\n\n2. 若 *funcArgs* 为索引序列或索引矩阵：\n\n   * 若 *funcArgs* 的索引为时间类型，对 *funcArgs* 中索引为 fi 的元素，其对应的窗口索引范围为 \\[temporalAdd(fi, d1), temporalAdd(fi, d2)]。\n\n   * 若 *funcArgs* 的索引为整型，*range* 必须亦为整型。对 *funcArgs* 中索引为 fi 的元素，其对应的窗口索引范围为 \\[fi+d1, fi+d2] 。\n\n与 `moving` 函数相比，`window` 函数具有更灵活的窗口。`moving` 可以视为 `window` 指定 *range* 右边界为 0 的特殊情况。但需要注意以下两点：\n\n1. 元素个数决定窗口长度时，窗口内元素个数不足时，`moving` 函数将输出空值，但 `window` 会输出计算结果。\n\n2. 时间长度决定窗口长度时，`moving` 确定的窗口左开右闭，但 `window` 确定窗口左闭右闭。详见以下说明：\n\n假定索引类型为 DATETIME, 需要指定一个长度为 “3d” 的窗口进行滑动窗口计算。对于索引中的某个时间点 “2022.01.05T09:00:00”， `moving` 函数根据该时间点确定的窗口为 (2022.01.02T09:00:00，2022.01.05T09:00:00]，`window` 指定 *range* 为 “-2d:0d”， 确定的窗口为 \\[2022.01.03T09:00:00，2022.01.05T09:00:00]。\n\n#### 例子\n\n*funcArgs* 为向量, 确定窗口位置区间为 \\[i+1,i+3], i 是 x 的下标。\n\n```\nx = 5 4 NULL -1 2 4\nwindow(min, x, 1:3)\n// output\n[-1, -1, -1, 2, 4, ]\n\ny = 4.8 9.6 7.1 3.3 5.9 2.7\nwindow(corr, (x, y), 1:3)\n// output\n[1, 1, -0.623, -1, , ]\n```\n\n*funcArgs* 为索引序列, 索引为时间类型，确定的窗口范围为 \\[temporalAdd(ti, 1d), temporalAdd(ti, 3d)]，ti 是 t 第 i 个元素对应的值。\n\n```\nt = 2021.01.02 2021.01.05 2021.01.06 2021.01.09 2021.01.10 2021.01.12\nx1 = indexedSeries(t, x)\nwindow(min, x1, 1d:3d)\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2021.01.02 | 4    |\n| 2021.01.05 |      |\n| 2021.01.06 | -1   |\n| 2021.01.09 | 2    |\n| 2021.01.10 | 4    |\n| 2021.01.12 |      |\n\n*funcArgs* 为索引矩阵, 索引为时间，确定索引对应的窗口范围 \\[temporalAdd(ti, 1d), temporalAdd(ti, 3d)]，ti 是 t 第 i 个元素对应的值。 以 a, b 列分组进行滑动窗口计算。\n\n```\nt= 2021.01.02 2021.01.05  2021.01.06  2021.01.09 2021.01.10 2021.01.12\nm=matrix(5 4 NULL -1 2 4, 3 2 8 1 0 5)\nm1=m.rename!(t, `a`b).setIndexedMatrix!()\nwindow(min, m1, 1d:3d)\n```\n\n| label      | a  | b |\n| ---------- | -- | - |\n| 2021.01.02 | 4  | 2 |\n| 2021.01.05 |    | 8 |\n| 2021.01.06 | -1 | 1 |\n| 2021.01.09 | 2  | 0 |\n| 2021.01.10 | 4  | 5 |\n| 2021.01.12 |    |   |\n\n```\nt1 = table(`A`A`B`B`C`C as sym, 09:56:03 09:56:07 09:56:02 09:56:05 09:56:04 09:56:06 as time, 10.6 10.7 20.6 11.6 11.7 19.6 as price)\nselect *, window(avg, t1.time.indexedSeries(t1.price), 2s:4s) from t1 context by sym\n```\n\n| sym | time     | price | window\\_avg |\n| --- | -------- | ----- | ----------- |\n| A   | 09:56:03 | 10.6  | 10.7        |\n| A   | 09:56:07 | 10.7  |             |\n| B   | 09:56:02 | 20.6  | 11.6        |\n| B   | 09:56:05 | 11.6  |             |\n| C   | 09:56:04 | 11.7  | 19.6        |\n| C   | 09:56:06 | 19.6  |             |\n"
    },
    "withNullFill": {
        "url": "https://docs.dolphindb.cn/zh/funcs/ho_funcs/withNullFill.html",
        "signatures": [
            {
                "full": "withNullFill(func, x, y, fillValue)",
                "name": "withNullFill",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "y",
                        "name": "y"
                    },
                    {
                        "full": "fillValue",
                        "name": "fillValue"
                    }
                ]
            }
        ],
        "markdown": "### [withNullFill](https://docs.dolphindb.cn/zh/funcs/ho_funcs/withNullFill.html)\n\n#### 语法\n\nwithNullFill(func, x, y, fillValue)\n\n#### 详情\n\n* 如果 x 与 y 中相同位置的元素只有一个为NULL，使用 fillValue 替换 NULL 值参与计算。\n* 如果 x 和 y 相同位置的元素均为 NULL，返回 NULL。\n\n#### 参数\n\n* **func** 是一个DolphinDB内置函数，须为双目运算符，例如+, -, \\*, /, , %, pow, and, or 等。\n* **x** 与 **y** 是向量或矩阵。\n* **fillValue** 是一个标量。\n\n#### 例子\n\n```\nx = 0 1 NULL NULL 2\ny = 1 NULL 2 NULL 3;\nadd(x,y);\n// output\n[1,,,,5]\n\nwithNullFill(add, x, y, 0);\n// output\n[1,1,2,,5]\n\nm=matrix(1..5, y);\nm;\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 1    |\n| 2    |      |\n| 3    | 2    |\n| 4    |      |\n| 5    | 3    |\n\n```\nadd(x, m);\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 1    |\n| 3    |      |\n|      |      |\n|      |      |\n| 7    | 5    |\n\n```\nwithNullFill(add, x, m, 0);\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 1    |\n| 3    | 1    |\n| 3    | 2    |\n| 4    |      |\n| 7    | 5    |\n\n"
    },
    "ifirstHit": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/ifirstHit.html",
        "signatures": [
            {
                "full": "ifirstHit(func, X, target)",
                "name": "ifirstHit",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "target",
                        "name": "target"
                    }
                ]
            }
        ],
        "markdown": "### [ifirstHit](https://docs.dolphindb.cn/zh/funcs/i/ifirstHit.html)\n\n\n\n#### 语法\n\nifirstHit(func, X, target)\n\n#### 参数\n\n**func** 关系运算符 >, >=, <, <=, !=, <>, ==。\n\n**X** 向量，矩阵或表。\n\n**target** 和 *X* 类型相同的标量，表示与 *X* 比较的对象。\n\n#### 详情\n\n返回 *X* 中第一个满足 *X* *func* *target* （例如 *X*>5) 条件的元素的下标。\n\n若 *X* 中无元素满足条件，则返回-1。\n\n通过 `ifirstHit` 查找时，NULL 值会被忽略：\n\n* 如需查找第一个非 NULL 的下标， 可以通过函数 [ifirstNot](https://docs.dolphindb.cn/zh/funcs/i/ifirstNot.html)；\n\n* 如需查找第一个空值的下标，可以通过函数 [find](https://docs.dolphindb.cn/zh/funcs/f/find.html)。\n\n#### 例子\n\n```\nX = NULL 3.2 4.5 1.2 NULL 7.8 0.6 9.1\nifirstHit(<, X, 2.5)\n// output\n3\n\n// 若无元素满足查找条件，返回 -1\nifirstHit(>, X, 10.0)\n// output\n-1\n\n```\n\n相关函数：[firstHit](https://docs.dolphindb.cn/zh/funcs/f/firstHit.html)\n"
    },
    "ifirstNot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/ifirstNot.html",
        "signatures": [
            {
                "full": "ifirstNot(X)",
                "name": "ifirstNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ifirstNot](https://docs.dolphindb.cn/zh/funcs/i/ifirstNot.html)\n\n\n\n#### 语法\n\nifirstNot(X)\n\n#### 参数\n\n**X** 可以是一个向量，也可以是由多个等长向量组成的元组，亦可是一个矩阵或表。\n\n#### 详情\n\n如果 *X* 是一个向量，返回第一个非空元素的下标。如果 *X* 中的所有元素都为空，返回-1。\n\n如果 *X* 是一个元组，返回第一个所有向量中均不为空的位置的下标。\n\n如果 *X* 是一个矩阵，返回每列中第一个非空元素的下标。返回一个向量。\n\n如果 *X* 是一个表，返回每列中第一个非空元素的下标。返回一个表。\n\n#### 例子\n\n```\nifirstNot(NULL NULL 2 4 8 NULL 1);\n// output\n2\n\nifirstNot(take(int(),5));\n// output\n-1\n\nx=NULL NULL 4 7 8 NULL\ny=1 NULL NULL 4 NULL NULL\nifirstNot([x,y]);\n// output\n3\n\nx=NULL NULL 4 7 8 NULL\ny=1 2 NULL NULL NULL 6\nifirstNot([x,y]);\n// output\n-1\n\nm=matrix(0 NULL 1 2 3, NULL 2 NULL 0 3);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 0  |    |\n|    | 2  |\n| 1  |    |\n| 2  | 0  |\n| 3  | 3  |\n\n```\nifirstNot(m);\n// output\n[0,1]\n```\n\n相关函数：[ilastNot](https://docs.dolphindb.cn/zh/funcs/i/ilastNot.html), [firstNot](https://docs.dolphindb.cn/zh/funcs/f/firstNot.html), [lastNot](https://docs.dolphindb.cn/zh/funcs/l/lastNot.html)\n"
    },
    "ifNull": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/ifNull.html",
        "signatures": [
            {
                "full": "ifNull(X, Y)",
                "name": "ifNull",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ifNull](https://docs.dolphindb.cn/zh/funcs/i/ifNull.html)\n\n\n\n#### 语法\n\nifNull(X, Y)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量或矩阵。\n\n**Y** 可以是标量、数据对、向量或矩阵。\n\n*X* 和 *Y* 必须具有相同的数据类型。\n\n#### 详情\n\n判断 *X* 是否为空。若为 NULL，则返回 *X* 的值，若为非 NULL，则返回 *Y* 的值。\n\n#### 例子\n\n```\nx = take(1..5 join NULL 6,7)\ny = 1..7\nifNull(x,y)\n// output\n[1,2,3,4,5,,7]\ny1 = int(take(1..5 join int(),6))$2:3\nx1 = int(take(100,6))$2:3\nifNull(x1,y1)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 100  | 100  | 100  |\n| 100  | 100  |      |\n\n若 *X* 为向量，*Y* 为 n 行 m 列的矩阵，则 *X* 的长度为 n\\*m\n\n```\nm=int(take(1..4 join NULL 8,6))\nifNull(m,y1)\n// output\n[100,100,100,100,,100]\n```\n"
    },
    "ifValid": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/ifValid.html",
        "signatures": [
            {
                "full": "ifValid(X,Y)",
                "name": "ifValid",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ifValid](https://docs.dolphindb.cn/zh/funcs/i/ifValid.html)\n\n\n\n#### 语法\n\nifValid(X,Y)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量或矩阵。\n\n**Y** 可以是标量、数据对、向量或矩阵。\n\n*X* 和 *Y* 必须具有相同的数据类型。\n\n#### 详情\n\n判断 *X* 是否非空。若为非空，则返回 *X* 的值，若为 NULL，则返回 *Y* 的值。\n\n#### 例子\n\n```\nx = take(1..5 join NULL 6,7)\ny = 1..7\nifValid(x,y)\n// output\n[1,2,3,4,5,6,6]\nx1 = int(take(1..5 join int(),6))$2:3\ny1 = int(take(100,6))$2:3\nifValid(x1,y1)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 3    | 5    |\n| 2    | 4    | 100  |\n\n若 *X* 为向量，*Y* 为 n 行 m 列的矩阵，则 *X* 的长度为 n\\*m\n\n```\nm=int(take(1..4 join NULL 8,6))\nifValid(m,y1)\n// output\n[1,2,3,4,100,8]\n```\n"
    },
    "iif": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/iif.html",
        "signatures": [
            {
                "full": "iif(cond, trueResult, falseResult)",
                "name": "iif",
                "parameters": [
                    {
                        "full": "cond",
                        "name": "cond"
                    },
                    {
                        "full": "trueResult",
                        "name": "trueResult"
                    },
                    {
                        "full": "falseResult",
                        "name": "falseResult"
                    }
                ]
            }
        ],
        "markdown": "### [iif](https://docs.dolphindb.cn/zh/funcs/i/iif.html)\n\n\n\n#### 语法\n\niif(cond, trueResult, falseResult)\n\n#### 参数\n\n**cond** 是布尔标量、向量或矩阵。可为产生布尔标量、向量或矩阵的表达式。\n\n**trueResult** 和 **falseResult** 可以是标量、与 *cond* 等长的向量或与 *cond* 维度相同的矩阵。\n\n#### 详情\n\n`iif` 是元素级的条件运算符。通常 *cond* 是布尔类型。如果 cond\\[i] 为 true，它返回 trueResult(cond\\[i])；否则它返回 falseResult(cond\\[i])。 当 cond\\[i] 为NULL值时，返回的结果也是 NULL 值。\n\n**Note:** 此函数会首先执行其中的三个参数，然后根据 *cond* 的结果决定返回 *trueResult* 或 *falseResult*。\n\n#### 例子\n\n```\niif(true true true false false false, 1..6, 6..1);\n// output\n[1,2,3,3,2,1]\n\niif(1..6==3, 1, 2);\n// output\n[2,2,1,2,2,2]\n\nx=9 6 8;\niif(x<=8, 10*x, 20*x-80);\n// output\n[100,60,80]\n\nt=table(1..5 as id, 11..15 as x);\nt1=table(take(12,5) as a, take(14,5) as b);\nt;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n\n```\nt1;\n```\n\n| a  | b  |\n| -- | -- |\n| 12 | 14 |\n| 12 | 14 |\n| 12 | 14 |\n| 12 | 14 |\n| 12 | 14 |\n\n```\nupdate t set x=iif(x<t1.a, t1.a, iif(x>t1.b,t1.b, x));\nt;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 12 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 14 |\n\n当配置了 *nullAsMinValueForComparison*=true时，在比较运算中，NULL 元素取相应数据类型的最小值。使用 [nullCompare](https://docs.dolphindb.cn/zh/funcs/ho_funcs/nullCompare.html) 可以保持 `iif` 条件语句里的 NULL 值。\n\n```\na = NULL 1 -3 5\niif(a > 0, a, 0)\n// output\n[0, 1, 0, 5]\niif(nullCompare(>,a,0), a, 0)\n// output\n[ , 1, 0, 5]\n```\n\n```\nm1=1..6$3:2\nm2=6..1$3:2\niif(m1>m2, m1, m2);\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 6    | 4    |\n| 5    | 5    |\n| 4    | 6    |\n"
    },
    "ilastNot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/ilastNot.html",
        "signatures": [
            {
                "full": "ilastNot(X)",
                "name": "ilastNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ilastNot](https://docs.dolphindb.cn/zh/funcs/i/ilastNot.html)\n\n\n\n#### 语法\n\nilastNot(X)\n\n#### 参数\n\n**X** 可以是一个向量，也可以是由多个等长向量组成的元组，亦可是一个矩阵或表。\n\n#### 详情\n\n如果 *X* 是一个向量，返回最后一个非空元素的下标。如果 *X* 中的所有元素都为空，返回-1。\n\n如果 *X* 是一个元组，返回最后一个所有向量中均不为空的位置的下标。\n\n如果 *X* 是一个矩阵，返回每列中最后一个非空元素的下标。返回一个向量。\n\n如果 *X* 是一个表，返回每列中最后一个非空元素的下标。返回一个表。\n\n#### 例子\n\n```\nilastNot(NULL NULL 2 4 8 1 NULL);\n// output\n5\n\nilastNot(take(int(),5));\n// output\n-1\n\nx=NULL NULL 4 7 8 NULL\ny=1 NULL NULL 4 NULL NULL\nilastNot([x,y]);\n// output\n3\n\nx=NULL NULL 4 7 8 NULL\ny=1 2 NULL NULL NULL 6\nilastNot([x,y]);\n// output\n-1\n\nm=matrix(2 NULL 1 0 NULL, NULL 2 NULL 6 0);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 2  |    |\n|    | 2  |\n| 1  |    |\n| 0  | 6  |\n|    | 0  |\n\n```\nilastNot(m);\n// output\n[3,4]\n```\n\n相关函数：[ifirstNot](https://docs.dolphindb.cn/zh/funcs/i/ifirstNot.html), [lastNot](https://docs.dolphindb.cn/zh/funcs/l/lastNot.html), [firstNot](https://docs.dolphindb.cn/zh/funcs/f/firstNot.html)\n"
    },
    "ilike": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/ilike.html",
        "signatures": [
            {
                "full": "ilike(X, pattern)",
                "name": "ilike",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    }
                ]
            }
        ],
        "markdown": "### [ilike](https://docs.dolphindb.cn/zh/funcs/i/ilike.html)\n\n\n\n#### 语法\n\nilike(X, pattern)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n**pattern** 是一个字符串，通常包含类似 \"%\" 的通配符。\n\n#### 详情\n\n判断字符串 *X* 中是否包含字符串 *pattern*。和函数 [like](https://docs.dolphindb.cn/zh/funcs/l/like.html) 不同，比较是不区分大小写的。\n\n#### 例子\n\n```\nilike(`ABCDEFG, `de);\n// output\n0\n\nilike(`ABCDEFG, \"%de%\");\n// output\n1\n\na=`IBM`ibm`MSFT`Goog`YHOO`ORCL;\na ilike  \"%OO%\";\n// output\n[0,0,0,1,1,0]\n\na[a ilike  \"%OO%\"];\n// output\n[\"Goog\",\"YHOO\"]\n```\n\n相关函数：[like](https://docs.dolphindb.cn/zh/funcs/l/like.html)\n"
    },
    "imax": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/imax.html",
        "signatures": [
            {
                "full": "imax(X)",
                "name": "imax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [imax](https://docs.dolphindb.cn/zh/funcs/i/imax.html)\n\n\n\n#### 语法\n\nimax(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n* 若 *X* 是向量，返回最大值的位置。如果有多个相同的最大值，返回左起第一个最大值的位置。\n\n* 若 *X* 为矩阵，计算在每列内部进行，返回一个向量。\n\n* 若 *X* 为表，计算在每列内部进行，返回一个表。\n\n#### 例子\n\n```\nx = 1.2 2 NULL 6 -1 6;\nimax(x);\n// output\n3\n\nx = 5 3 1 6 4 6 $ 3:2;\nimax(x);\n// output\n(0,1)\n\nx=array(INT,0);\nx;\n// output\n[]\n\nimax(x);\n// output\n-1\n// 对于一个空向量，imax 返回 -1\n\nm=matrix(1 2 3, 6 5 4);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 6  |\n| 2  | 5  |\n| 3  | 4  |\n\n```\nimax(m);\n// output\n[2,0]\n```\n\n相关函数：[imaxLast](https://docs.dolphindb.cn/zh/funcs/i/imaxlast.html)\n"
    },
    "imaxLast": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/imaxlast.html",
        "signatures": [
            {
                "full": "imaxLast(X)",
                "name": "imaxLast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [imaxLast](https://docs.dolphindb.cn/zh/funcs/i/imaxlast.html)\n\n\n\n#### 语法\n\nimaxLast(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n若 *X* 是向量，返回最大值的位置。如果有多个相同的最大值，返回右起第一个最大值的位置。\n\n若 *X* 为矩阵，计算在每列内部进行，返回一个向量。\n\n若 *X* 为表，计算在每列内部进行，返回一个表。\n\n#### 例子\n\n```\nx = 1.2 2 NULL -1 6 -1\nimaxLast(x);\n// output\n4\n\nm=matrix(3 2 4 4 2, 1 4 2 4 3);\nimaxLast(m) \n// output\n[3,3]\n\nt=table(3 3 2 as c1, 1 4 4 as c2)\nimaxLast(t)\n// output\nc1       c2\n0\t2\n```\n\n相关函数：[imax](https://docs.dolphindb.cn/zh/funcs/i/imax.html)\n"
    },
    "imin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/imin.html",
        "signatures": [
            {
                "full": "imin(X)",
                "name": "imin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [imin](https://docs.dolphindb.cn/zh/funcs/i/imin.html)\n\n\n\n#### 语法\n\nimin(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n* 若 *X* 是向量，返回最小元素的位置。如果有多个相同的最小值，返回左起第一个最小值的位置。与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n* 若 *X* 为矩阵，计算在每列内部进行，返回一个向量。\n\n* 若 *X* 为表，计算在每列内部进行，返回一个表。\n\n#### 例子\n\n```\nx = 1.2 2 NULL -1 6 -1\nimin(x);\n// output\n3\n\nx = 5 3 1 6 4 1 $ 3:2\nimin(x);\n// output\n[2,2]\n```\n\n```\nm=matrix(1 3 2 4, 4 2 3 1);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 3  | 2  |\n| 2  | 3  |\n| 4  | 1  |\n\n```\nimin(m);\n// output\n[0,3]\n```\n\n相关函数：[iminLast](https://docs.dolphindb.cn/zh/funcs/i/iminlast.html)\n"
    },
    "iminLast": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/iminlast.html",
        "signatures": [
            {
                "full": "iminLast(X)",
                "name": "iminLast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [iminLast](https://docs.dolphindb.cn/zh/funcs/i/iminlast.html)\n\n\n\n#### 语法\n\niminLast(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n若 *X* 是向量，返回最小元素的位置。如果有多个相同的最小值，返回右起第一个最小值的位置。与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n若 *X* 为矩阵，计算在每列内部进行，返回一个向量。\n\n若 *X* 为表，计算在每列内部进行，返回一个表。\n\n#### 例子\n\n```\nx = 1.2 2 NULL -1 6 -1\niminLast(x);\n// output\n5\n\nm=matrix(3 2 2 4 2, 1 4 2 1 3);\niminLast(m) \n// output\n[4,3]\n\nt=table(3 2 2 as c1, 1 1 4 as c2)\niminLast(t)\n// output\nc1       c2\n2\t1\n```\n\n相关函数：[imin](https://docs.dolphindb.cn/zh/funcs/i/imin.html)\n"
    },
    "imr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/imr.html",
        "signatures": [
            {
                "full": "imr(ds, initValue, mapFunc, [reduceFunc], [finalFunc], terminateFunc, [carryover=false])",
                "name": "imr",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "initValue",
                        "name": "initValue"
                    },
                    {
                        "full": "mapFunc",
                        "name": "mapFunc"
                    },
                    {
                        "full": "[reduceFunc]",
                        "name": "reduceFunc",
                        "optional": true
                    },
                    {
                        "full": "[finalFunc]",
                        "name": "finalFunc",
                        "optional": true
                    },
                    {
                        "full": "terminateFunc",
                        "name": "terminateFunc"
                    },
                    {
                        "full": "[carryover=false]",
                        "name": "carryover",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [imr](https://docs.dolphindb.cn/zh/funcs/i/imr.html)\n\n\n\n#### 语法\n\nimr(ds, initValue, mapFunc, \\[reduceFunc], \\[finalFunc], terminateFunc, \\[carryover=false])\n\n#### 参数\n\n**ds** 数据源列表。它必须是每个元素作为数据源对象的元组。即使只有一个数据源，我们仍然需要一个元组来包装数据源。在迭代计算中，数据源自动缓存，缓存将在最后一次迭代后被清除。\n\n**initValue** 模型参数估计的初始值。初始值的格式必须与最终函数的输出相同。\n\n**mapFunc** map函数。它有两个参数。第一个参数是由相应数据源表示的数据实体。第二个参数是前一次迭代中最终函数的输出，这是对模型参数的更新估算。对于第一次迭代，它是用户给出的初始值。\n\n**reduceFunc** 二元 reduce 函数组合了两个 map 函数调用结果。如果有 M 个 map 调用，reduce 函数将被调用 M-1 次。在大多数情况下，reduce 功能是不重要的。一个例子是加法函数。reduce 函数是可选的。\n\n**finalFunc** 每次迭代的最终函数。它接受两个参数。第一个参数是前一次迭代中最终函数的输出。对于第一次迭代，它是用户给出的初始值。第二个参数是 reduce 函数调用的输出。如果没有指定 reduce 函数，则各个 map 调用结果的集合的元组将是第二个参数。\n\n**terminateFunc** 这是一个确定计算是否继续的函数，或是指定次数的迭代。终止函数接受两个参数。第一个是前一次迭代中 reduce 函数的输出，第二个是当前迭代中 reduce 函数的输出。如果函数返回 true，迭代将结束。\n\n**carryover** 布尔值，表示 map 函数调用是否生成一个传递给下一次 map 函数调用的对象。默认值为 false。如果 *carryover* 为 true，那么 map 函数有3个参数并且最后一个参数为携带的对象，同时 map 函数的输出结果是一个元组，最后一个元素为携带的对象。在第一次迭代中，携带的对象为 NULL。\n\n#### 详情\n\nDolphinDB 提供了基于 map-reduce 方法的迭代计算函数 `imr`。每次迭代使用上一次迭代的结果和输入数据集。每次迭代的输入数据集不变，因此可以被缓存。迭代计算需要模型参数的初始值和终止标准。\n\n#### 例子\n\n现在我们使用分布式中位数计算的例子来说明函数 `imr`。假设数据分散在多个节点上，我们想计算所有节点之间的变量的中位数。首先，对于每个数据源，将数据放入桶中，并使用 map 函数对每个数据桶中的数据点数进行计数。然后使用 reduce 函数来合并来自多个数据源的计数。找到包含中位数的桶。在下一次迭代中，所选择的桶分为更小的桶。当所选择的桶的长度不超过指定的数量时，迭代就完成了。\n\n```\ndef medMap(data, range, colName){\n return bucketCount(data[colName], double(range), 1024, true)\n}\n\ndef medFinal(range, result){\n   x= result.cumsum()\n   index = x.asof(x[1025]/2.0)\n   ranges = range[1] - range[0]\n   if(index == -1)\n      return (range[0] - ranges*32):range[1]\n   else if(index == 1024)\n      return range[0]:(range[1] + ranges*32)\n   else{\n      interval = ranges / 1024.0\n      startValue = range[0] + (index - 1) * interval\n      return startValue : (startValue + interval)\n   }\n}\n\ndef medEx(ds, colName, range, precision){\n   termFunc = def(prev, cur): cur[1] - cur[0] <= precision\n   return imr(ds, range, medMap{,,colName}, +, medFinal, termFunc).avg()\n}\n```\n"
    },
    "imtForceGCRedolog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/imtForceGCRedolog.html",
        "signatures": [
            {
                "full": "imtForceGCRedolog(tid)",
                "name": "imtForceGCRedolog",
                "parameters": [
                    {
                        "full": "tid",
                        "name": "tid"
                    }
                ]
            }
        ],
        "markdown": "### [imtForceGCRedolog](https://docs.dolphindb.cn/zh/funcs/i/imtForceGCRedolog.html)\n\n\n\n#### 语法\n\nimtForceGCRedolog(tid)\n\n#### 参数\n\n**tid** 事务的 id。\n\n#### 详情\n\n系统会自动将已完成（处于 COMPLETE 状态）事务的 redo log 将放入待回收列表。并根据此列表中事务 tid 的大小，顺序对成功落盘的事务进行回收。\n\n若回收过程中出现某个编号为 tid 的事务尚未刷盘，在该事务被成功刷盘前，无法对编号大于 *tid* 且成功刷盘事务的 redo log 进行回收。此时调用该命令，可以取消等待编号为 *tid* 事务的回收，继续对后续满足回收条件的事务进行回收。\n\n该函数建议搭配 [getRedoLogGCStat](https://docs.dolphindb.cn/zh/funcs/g/getRedoLogGCStat.html) 函数使用。\n"
    },
    "imtUpdateChunkVersionOnDataNode": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/imtUpdateChunkVersionOnDataNode.html",
        "signatures": [
            {
                "full": "imtUpdateChunkVersionOnDataNode(chunkId, version)",
                "name": "imtUpdateChunkVersionOnDataNode",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    },
                    {
                        "full": "version",
                        "name": "version"
                    }
                ]
            }
        ],
        "markdown": "### [imtUpdateChunkVersionOnDataNode](https://docs.dolphindb.cn/zh/funcs/i/imtUpdateChunkVersionOnDataNode.html)\n\n\n\n#### 语法\n\nimtUpdateChunkVersionOnDataNode(chunkId, version)\n\n#### 参数\n\n**chunkId** 字符串标量或向量，表示 chunk 的 ID。\n\n**version** 整型数字，表示版本号。\n\n#### 详情\n\n修改数据节点上对应 *chunkId* 的版本号，以维护集群中多副本数据之间，或数据节点与控制节点之间的版本一致性。\n\n该函数只能在数据节点执行。\n\n#### 相关函数\n\n控制节点可调用函数 [getClusterChunksStatus](https://docs.dolphindb.cn/zh/funcs/g/getClusterChunksStatus.html) 查询所有节点上 chunk 对应的版本号。\n\n数据节点可调用函数 [getChunksMeta](https://docs.dolphindb.cn/zh/funcs/g/getChunksMeta.html) 查询当前数据节点上 chunk 对应的版本号。\n"
    },
    "in": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/in.html",
        "signatures": [
            {
                "full": "in(X, Y)",
                "name": "in",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [in](https://docs.dolphindb.cn/zh/funcs/i/in.html)\n\n\n\n#### 语法\n\nin(X, Y)\n\n#### 参数\n\n**X** 可以是标量、向量、元组、矩阵、数组向量、字典、表。\n\n**Y** 可以是标量、向量、字典、单列内存表、键值内存表或索引内存表。\n\n#### 详情\n\n* 若 *Y* 是非时间类型的标量，检查 *X* 和 *Y* 是否相等；若 *Y* 是时间类型的标量，则会检查 *X* 中的每个元素是否在 *Y* 中。当 *Y* 是 NULL 值时，无论 *X* 为何值都返回 false。\n\n* 若 *Y* 是向量，检查 *X* 中的每一个元素是否在 *Y* 中。\n\n* 若 *Y* 是字典，检查 *X* 中的每一个元素是否是 *Y* 中的键。\n\n* 若 *Y* 是单列内存表，检查 *X* 中的每一个元素是否是 *Y* 唯一列中的值。\n\n  **Note:** 表中单列的类型不能是数组向量。\n\n* 若 *Y* 是键值表或索引内存表，检查 *X* 中的每一个元素是否为 *Y* 中的主键。*X* 中元素的个数必须与 *Y* 中主键列的个数一致。\n\n**Note:** *X* 和 *Y* 的数据类型需保持一致。若类型不一致，但属于同一分类，系统会将 *X* 强制转换为与 *Y* 一致的类型。\n\n#### 例子\n\n```\nin(3 3 5 2, 2 3);\n// output\n[true,true,false,true]\n\nx=dict(INT,DOUBLE);\nx[1, 2, 3]=[4.5, 6.6, 3.2];\nx;\n// output\n3->3.2\n1->4.5\n2->6.6\n\nin(1..6, x);\n// output\n[true,true,true,false,false,false]\n\nt = table(1 3 5 7 9 as id)\n2 3 in t\n// output\n[false,true]\n\nkt = keyedTable(`name`id,1000:0,`name`id`age`department,[STRING,INT,INT,STRING])\ninsert into kt values(`Tom`Sam`Cindy`Emma`Nick, 1 2 3 4 5, 30 35 32 25 30, `IT`Finance`HR`HR`IT)\nin((`Tom`Cindy, 1 3), kt);\n// output\n[true,true]\n\nt1 = indexedTable(`sym`side, 10000:0, `sym`side`price`qty, [SYMBOL,CHAR,DOUBLE,INT])\ninsert into t1 values(`IBM`MSFT`GOOG, ['B','S','B'], 10.01 10.02 10.03, 10 10 20)\nin((`IBM`MSFT, ['S','S']), t1);\n[false,true]\n\n```\n\n*X* 为浮点型，*Y* 为整型，数据类型不一致，会将 *X* 转换为与 *Y* 一致的类型进行比较。\n\n```\nin(10, NULL)\n// output\nfalse\n\nin('a', 97)\n// output\ntrue\n\nin(1, 1.1 1.2 1.3)\n// output\nfalse\n\nin(float(1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8), 1..9)\n// output\n[true,true,true,true,true,true,true,true]\n```\n\n`in` 可以搭配 `select` 使用，用于限定条件的筛选的范围：\n\n```\nselect * from kt where name in [`Tom, `Cindy];\n```\n\n| name  | id | age | department |\n| ----- | -- | --- | ---------- |\n| Tom   | 1  | 30  | IT         |\n| Cindy | 3  | 32  | HR         |\n\n相关函数：[find](https://docs.dolphindb.cn/zh/funcs/f/find.html), [binsrch](https://docs.dolphindb.cn/zh/funcs/b/binsrch.html)。\n"
    },
    "indexedSeries": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/indexedSeries.html",
        "signatures": [
            {
                "full": "indexedSeries(index, value)",
                "name": "indexedSeries",
                "parameters": [
                    {
                        "full": "index",
                        "name": "index"
                    },
                    {
                        "full": "value",
                        "name": "value"
                    }
                ]
            }
        ],
        "markdown": "### [indexedSeries](https://docs.dolphindb.cn/zh/funcs/i/indexedSeries.html)\n\n\n\n#### 语法\n\nindexedSeries(index, value)\n\n#### 参数\n\n**index** 与 **value** 为等长向量。*index* 须严格递增，无重复项。\n\n#### 详情\n\n创建一个有索引的序列。\n\n索引序列支持面板数据对齐运算。普通矩阵或向量进行二元运算时，按照对应元素分别进行计算，需要保持维度（shape）一致。而索引序列之间，索引序列与索引矩阵之间，进行二元运算时，根据行列标签（index）自动对齐，对维度没有硬性要求。\n\n支持的二元操作包括：\n\n(1) 算术运算符和函数：+, -, \\*, /(整除), (ratio), %(mod), pow\n\n(2) 逻辑运算符和函数：<, <=, >, >=, ==, !=, <>, &&, ||, &, |, ^\n\n(3) 滑动窗口函数：mwavg, mwsum, mbeta, mcorr, mcovar\n\n(4) 累计窗口函数：cumwavg, cumwsum, cumbeta, cumcorr, cumcovar\n\n(5) 聚合函数：wavg, wsum, beta, corr, covar\n\n#### 例子\n\n例1. 索引序列之间的运算，长度可以相等或者不等，根据索引对齐。\n\n```\ns1 = indexedSeries(2012.01.01..2012.01.04, [10, 20, 30, 40])\ns2 = indexedSeries(2011.12.30..2012.01.01, [50, 60, 70])\nres = s1 + s2\n```\n\n|            | col1 |\n| ---------- | ---- |\n| 2011.12.30 |      |\n| 2011.12.31 |      |\n| 2012.01.01 | 80   |\n| 2012.01.02 |      |\n| 2012.01.03 |      |\n| 2012.01.04 |      |\n\n例2. 索引序列和向量之间运算，长度必须相等。\n\n```\ns1 = indexedSeries(2012.01.01..2012.01.04, [10, 20, 30, 40])\nv = [1,2,3,4]\nres = s1+v\n```\n\n|            | col1 |\n| ---------- | ---- |\n| 2012.01.01 | 11   |\n| 2012.01.02 | 22   |\n| 2012.01.03 | 33   |\n| 2012.01.04 | 44   |\n\n例3. 索引序列和索引矩阵进行运算时，根据索引对齐。\n\n```\ns1 = indexedSeries(2012.01.01 2012.01.03 2012.01.04 2012.01.06, [10, 20, 30, 40])\nm = matrix(1..6, 11..16).rename!(2012.01.01..2012.01.06,`x`y).setIndexedMatrix!()\ns1 + m\n```\n\n|            | IBM | MSFT |\n| ---------- | --- | ---- |\n| 2012.01.01 | 11  | 21   |\n| 2012.01.02 |     |      |\n| 2012.01.03 | 23  | 33   |\n| 2012.01.04 | 34  | 44   |\n| 2012.01.05 |     |      |\n| 2012.01.06 | 46  | 56   |\n\n例4. 索引序列与没有设置索引的矩阵进行运算，长度必须相等。\n\n```\ns1 = indexedSeries(2012.01.01..2012.01.04, [10, 20, 30, 40])\nm = matrix([1,1,1,1], [2,2,2,2])\nres = s1 pow m\n```\n\n| col1 | col2  |\n| ---- | ----- |\n| 10   | 100   |\n| 20   | 400   |\n| 30   | 900   |\n| 40   | 1,600 |\n"
    },
    "indexedTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/indexedTable.html",
        "signatures": [
            {
                "full": "indexedTable(keyColumns, X, [X1], [X2], .....)",
                "name": "indexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "indexedTable(keyColumns, capacity:size, colNames, colTypes)",
                "name": "indexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            },
            {
                "full": "indexedTable(keyColumns, table)",
                "name": "indexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [indexedTable](https://docs.dolphindb.cn/zh/funcs/i/indexedTable.html)\n\n\n\n#### 语法\n\nindexedTable(keyColumns, X, \\[X1], \\[X2], .....)\n\n或\n\nindexedTable(keyColumns, capacity:size, colNames, colTypes)\n\n或\n\nindexedTable(keyColumns, table)\n\n#### 参数\n\n**keyColumns** 是一个字符串标量或向量，表示主键。主键的数据类型必须属于以下类别： INTEGRAL, TEMPORAL 或 LITERAL。\n\n第一种用法中，**X**, **X1**....是向量。\n\n第二种用法中：\n\n**capacity** 是正整数，表示建表时系统为该表分配的内存（以记录数为单位）。当记录数超过 *capacity* 时，系统会首先会分配 *capacity* 1.2\\~2倍的新的内存空间，然后复制数据到新的内存空间，最后释放原来的内存。对于规模较大的表，此类操作的内存占用会很高。因此，建议建表时预先分配一个合理的 *capacity*。\n\n**size** 只能是0或1。当数据列是 array vector 时，size 只能是0；当数据列是其它类型时，size 可以是0或1。\n\n* 若 size=0，则建立一个空表；\n* 若 size=1，则建立一个只包含1条记录的表，记录初始值如下：\n  * BOOL 类型默认值为 false；\n  * 数值类型、时间类型、IPADDR、COMPLEX、POINT 的默认值为 0；\n  * Literal, INT128 类型的默认值为 NULL。\n\n**colNames** 是字符串向量，表示列名。\n\n**colTypes** 是向量，表示各列的数据类型。\n\n第三种用法中，**table** 是一个表。注意，*table* 中的 *keyColumns* 不能包含重复值。\n\n#### 详情\n\n创建索引内存表（indexed table）。一个索引内存表有一个主键。主键可由一个或多个字段组成。索引内存表使用红黑树存储主键索引。在查询时，只要查询条件中包含主键的第1个列字段，便可通过索引定位数据，而无需进行全表扫描。\n\n向表中添加新记录时，系统会检查新记录的主键值。如果新记录的主键值与已有记录的主键值重复，系统会更新表中对应的记录；否则，系统会将新记录添加到表中。\n\n键值内存表在指定所有键值字段时才能达到最佳的查询性能。然而，在实际应用中，并不总是需要查询所有键值字段的信息。对于那些只需查询部分键值字段的情况，可以考虑使用索引内存表。\n\n关于对索引内存表和[键值内存表](https://docs.dolphindb.cn/zh/funcs/k/keyedTable.html)使用怎样的查询语句以及如何进行查询优化，详见下表：\n\n<table id=\"table_sbg_tkx_dcc\"><thead><tr><th>\n\n</th><th>\n\nindexedTable\n\n</th><th>\n\nkeyedTable\n\n</th></tr></thead><tbody><tr><td>\n\n查询优化\n\n</td><td>\n\n* 查询语句必须包含 *keyColumns* 的第 1 列，且该列过滤条件中只能使用 =, in 或 and；\n\n* 除 keyColumns 的第 1 列外，其它列可以通过 between、比较运算符等进行范围查询，且查询效率高于使用 in 谓词。\n\n* 所有过滤条件中，对不同列使用的 in 的次数不超过2次；\n\n* 建议调用 [sliceByKey](https://docs.dolphindb.cn/zh/funcs/s/sliceByKey.dita) 以提高性能。\n\n</td><td>\n\n* 查询语句必须包含 *keyColumns* 所有列。\n\n* 过滤条件中只能使用 =, in 或 and，且对不同列使用 in 的次数不超过2次；\n\n* 建议调用 [sliceByKey](https://docs.dolphindb.cn/zh/funcs/s/sliceByKey.dita) 以提高性能。\n\n</td></tr><tr><td>\n\n查询语句特点\n\n</td><td>\n\n只需要包含 *keyColumns* 的第 1 列，而无需包含所有列。\n\n</td><td>\n\n包含 keyColumns 的所有列。此时查询性能优于 indexedTable。\n\n</td></tr></tbody>\n</table>## 例子\n\n例1. 创建索引表\n\n第一种写法：\n\n```\nsym=`A`B`C`D`E\nid=5 4 3 2 1\nval=52 64 25 48 71\nt=indexedTable(`sym`id,sym,id,val)\nt;\n```\n\n| sym | id | col1 |\n| --- | -- | ---- |\n| A   | 5  | 52   |\n| B   | 4  | 64   |\n| C   | 3  | 25   |\n| D   | 2  | 48   |\n| E   | 1  | 71   |\n\n第二种写法：\n\n```\nt=indexedTable(`sym`id,1:0,`sym`id`val,[SYMBOL,INT,INT])\ninsert into t values(`A`B`C`D`E,5 4 3 2 1,52 64 25 48 71);\n```\n\n第三种写法：\n\n```\ntmp=table(sym, id, val)\nt=indexedTable(`sym`id, tmp);\n```\n\n创建索引内存分区表：\n\n```\nt=indexedTable(`sym`id,sym,id,val)\ndb=database(\"\",VALUE, sym)\npt=db.createPartitionedTable(t,`pt,`sym).append!(t);\n```\n\n例2. 更新索引表\n\n```\nt=indexedTable(`sym,1:0,`sym`datetime`price`qty,[SYMBOL,DATETIME,DOUBLE,DOUBLE])\ninsert into t values(`APPL`IBM`GOOG,2018.06.08T12:30:00 2018.06.08T12:30:00 2018.06.08T12:30:00,50.3 45.6 58.0,5200 4800 7800)\nt;\n```\n\n| sym  | datetime            | price | qty  |\n| ---- | ------------------- | ----- | ---- |\n| APPL | 2018.06.08T12:30:00 | 50.3  | 5200 |\n| IBM  | 2018.06.08T12:30:00 | 45.6  | 4800 |\n| GOOG | 2018.06.08T12:30:00 | 58    | 7800 |\n\n插入新记录，并且新记录中的 *keyColumns* 的值与表中 *keyColumns* 的值重复：\n\n```\ninsert into t values(`APPL`IBM`GOOG,2018.06.08T12:30:01 2018.06.08T12:30:01 2018.06.08T12:30:01,65.8 45.2 78.6,5800 8700 4600)\nt;\n```\n\n| sym  | datetime            | price | qty  |\n| ---- | ------------------- | ----- | ---- |\n| APPL | 2018.06.08T12:30:01 | 65.8  | 5800 |\n| IBM  | 2018.06.08T12:30:01 | 45.2  | 8700 |\n| GOOG | 2018.06.08T12:30:01 | 78.6  | 4600 |\n\n*keyColumns* 的值不允许更新：\n\n```\nupdate t set sym=\"C_\"+sym;\n// output: Can't update a key column.\n```\n\n例3. 查询索引内存表\n\nSQL 语句中若不使用 or，且某个过滤条件包含 *keyColumns* 的第1列，且该过滤条件使用 = 或 in 谓词，且 in 谓词使用不超过两次，则查询索引内存表的性能优于查询普通内存表。与之对比，若希望查询键值表的性能优于普通内存表，过滤条件必须包含全部 *keyColumns*。\n\n首先，分别创建包含100万条记录的普通内存表 t 和索引内存表 t1。\n\n```\nid=shuffle(1..1000000)\ndate=take(2012.06.01..2012.06.10, 1000000)\ntype=take(0..9, 1000000)\nval=rand(100.0, 1000000)\nt=table(id, date, type, val)\nt1=indexedTable(`id`date`type, id, date, type, val);\n```\n\n使用 *keyColumns* 的第一列进行过滤：\n\n```\ntimer(100) select * from t where id=500000;\n// output: Time elapsed: 177.286 ms\n\ntimer(100) select * from t1 where id=500000;\n// output: Time elapsed: 1.245 ms\n\ntimer(100) sliceByKey(t1, 500000)\n// output: Time elapsed: 0.742 ms\n\ntimer(100) select * from t where id in [500000, 600000, 700000];\n// output: Time elapsed: 1134.429 ms\n\ntimer(100) select * from t1 where id in [500000, 600000, 700000];\n// output: Time elapsed: 1.377 ms\n```\n\n若 *keyColumns* 第一列的过滤条件不使用 = 或 in ，则查询索引内存表的性能不会优化：\n\n```\ntimer(100) select * from t where id between 500000:500010;\n// output: Time elapsed: 641.544 ms\n\ntimer(100) select * from t1 where id between 500000:500010;\n// output: Time elapsed: 599.752 ms\n```\n\n使用 *keyColumns* 的第一列与第三列进行过滤：\n\n```\ntimer(100) select * from t where id=500000, type in [3,6];\n// output: Time elapsed: 172.808 ms\n\ntimer(100) select * from t1 where id=500000, type in [3,6];\n// output: Time elapsed: 1.664 ms\n```\n\n若不使用第一列 *keyColumns* 进行过滤，则查询索引内存表的性能不会优化：\n\n```\ntimer(100) select * from t where date in [2012.06.03, 2012.06.06];\n// output: Time elapsed: 490.182 ms\n\ntimer(100) select * from t1 where date in [2012.06.03, 2012.06.06];\n// output: Time elapsed: 544.015 ms\n\ntimer(100) select * from t where date=2012.06.03, type=8;\n// output: Time elapsed: 205.443 ms\n\ntimer(100) select * from t1 where date=2012.06.03, type=8;\n// output: Time elapsed: 204.532 ms\n```\n\n若过滤条件使用超过两个 in 谓词，则查询索引内存表的性能不会优化：\n\n```\ntimer(100) select * from t where id in [100,200], date in [2012.06.03, 2012.06.06], type in [3,6];\n// output: Time elapsed: 208.714 ms\n\ntimer(100) select * from t1 where id in [100,200], date in [2012.06.03, 2012.06.06], type in [3,6];\n// output: Time elapsed: 198.674 ms\n```\n\n例4. 使用 `indexedTable` 保留每只股票卖方委托的最新五档报价。\n\n```\nsym=[\"a\",\"b\",\"c \"] \ntime=22:58:52.827 22:58:53.627 22:58:53.827 \nvolume=array(INT[]).append!([[100,110,120,115,125],[200,230,220,225,230],[320,300,310,315,310]])\nprice=array(DOUBLE[]).append!([[10.5,10.6,10.7,10.77,10.85],[8.6,8.7,8.76,8.83,8.9],[6.3,6.37,6.42,6.48,6.52]])\nt=indexedTable(`sym,sym,time,volume,price)\nt\n```\n\n<table id=\"table_lr3_2wt_x1c\"><thead><tr><th>\n\nsym\n\n</th><th>\n\ntime\n\n</th><th>\n\nvolume\n\n</th><th>\n\nprice\n\n</th></tr></thead><tbody><tr><td>\n\na\n\n</td><td>\n\n22:58:52.827\n\n</td><td>\n\n\\[100, 110, 120, 115, 125]\n\n</td><td>\n\n\\[10.5, 10.6, 10.7, 10.77, 10.85]\n\n</td></tr><tr><td>\n\nb\n\n</td><td>\n\n22:58:53.627\n\n</td><td>\n\n\\[200, 230, 220, 225, 230]\n\n</td><td>\n\n\\[8.6, 8.7, 8.76, 8.83, 8.9]\n\n</td></tr><tr><td>\n\nc\n\n</td><td>\n\n22:58:53.827\n\n</td><td>\n\n\\[320, 300, 310, 315, 310]\n\n</td><td>\n\n\\[6.3, 6.37, 6.42, 6.48, 6.52]\n\n</td></tr></tbody>\n</table>```\n//最新的报价数量和价格\nnewVolume=array(INT[]).append!([[130,110,110,115,120]])\nnewPrice= array(DOUBLE[]).append!([[10.55,10.57,10.62,10.68,10.5]])\n//更新名为 a 的股票的最新报价\nupdate t set volume=newVolume, price=newPrice where sym=\"a\"\nt\n```\n\n<table id=\"table_qr3_2wt_x1c\"><thead><tr><th>\n\nsym\n\n</th><th>\n\ntime\n\n</th><th>\n\nvolume\n\n</th><th>\n\nprice\n\n</th></tr></thead><tbody><tr><td>\n\na\n\n</td><td>\n\n22:58:52.827\n\n</td><td>\n\n\\[130, 110, 110, 115, 120]\n\n</td><td>\n\n\\[10.55, 10.57, 10.62, 10.68, 10.5]\n\n</td></tr><tr><td>\n\nb\n\n</td><td>\n\n22:58:53.627\n\n</td><td>\n\n\\[200, 230, 220, 225, 230]\n\n</td><td>\n\n\\[8.6, 8.7, 8.76, 8.83, 8.9]\n\n</td></tr><tr><td>\n\nc\n\n</td><td>\n\n22:58:53.827\n\n</td><td>\n\n\\[320, 300, 310, 315, 310]\n\n</td><td>\n\n\\[6.3, 6.37, 6.42, 6.48, 6.52]\n\n</td></tr></tbody>\n</table>需要注意的是，更新 array vector 列的数据时，新记录中各行向量的元素个数必须和原记录中对应行向量的元素个数相同，否则会出现报错。如下例，新记录向量中有4个元素，而已有记录对应行的向量中有5个元素，数量不相同，出现报错：\n\n```\nnewPrice= array(DOUBLE[]).append!([[10.55,10.57,10.62,10.5]])\nupdate t set volume=newVolume, price=newPrice where sym=\"a\"\n// error: Failed to update column: price\n```\n\n相关函数：[keyedTable](https://docs.dolphindb.cn/zh/funcs/k/keyedTable.html)\n"
    },
    "initcap": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/initcap.html",
        "signatures": [
            {
                "full": "initcap(X)",
                "name": "initcap",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [initcap](https://docs.dolphindb.cn/zh/funcs/i/initcap.html)\n\n\n\n#### 语法\n\ninitcap(X)\n\n#### 参数\n\n**X** STRING 类型的标量/向量，或 SYMBOL 类型的向量。\n\n#### 详情\n\n将 *X* 中由分隔符分隔的字符串中的第一个英文字符设置为大写，其余英文字符设置为小写。其中，分隔符是除英文字符和数字外的任意字符，例如：汉字，空格，@ 等。\n\n**Note:** 该函数将数字也视为英文字符。\n\n返回值：和 *X* 类型保持一致。\n\n#### 例子\n\n```\ninitcap(\"hello world\")\n// output\nHello World\n\ninitcap(\"1aBBBBBB\")\n// output\n1abbbbbb\n\ninitcap(\"nihao, hello@you\")\n// output\nNihao, Hello@You\n\ninitcap(\"你好hello\" \"hello You\")\n// output\n[\"你好Hello\",\"Hello You\"]\ninitcap(symbol([\"adhE\",\"\",\"1yI\"]))\n// output\n[\"Adhe\",,\"1yi\"]\n```\n"
    },
    "installPlugin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/installPlugin.html",
        "signatures": [
            {
                "full": "installPlugin(pluginName, [pluginVersion], [pluginServerAddr])",
                "name": "installPlugin",
                "parameters": [
                    {
                        "full": "pluginName",
                        "name": "pluginName"
                    },
                    {
                        "full": "[pluginVersion]",
                        "name": "pluginVersion",
                        "optional": true
                    },
                    {
                        "full": "[pluginServerAddr]",
                        "name": "pluginServerAddr",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [installPlugin](https://docs.dolphindb.cn/zh/funcs/i/installPlugin.html)\n\n#### 语法\n\ninstallPlugin(pluginName, \\[pluginVersion], \\[pluginServerAddr])\n\n#### 详情\n\n下载并解压指定名称的插件的二进制文件（Windows 版本 server 使用 .dll，Linux 版本 server 使用 .so）和插件描述文件（.txt）到 DolphinDB 的插件目录（`/server/plugins/`）下。返回插件描述文件的完整路径。后续可通过该路径加载插件。\n\n可通过 [listRemotePlugins](https://docs.dolphindb.cn/zh/funcs/l/listRemotePlugins.html) 函数查看所支持的插件名称及版本信息。\n\n#### 参数\n\n**pluginName** STRING 类型，用于指定插件名称。\n\n**pluginVersion** 可选，STRING 类型，用于指定插件版本。如果不指定该参数，则使用插件的最新版本。\n\n**pluginServerAddr** 可选，STRING 类型，用于指定插件仓库的 HTTP 地址。如果不配置该参数，使用默认的 HTTP 地址：\"<http://plugins.dolphindb.cn/plugins\"。如果> DolphinDB 服务位于国外，建议填写 \"<http://plugins.dolphindb.com/plugins>\" 以提高查询速度。\n\n#### 例子\n\n在 Linux 中下载指定的插件：\n\n```\ninstallPlugin(\"mysql\")\n```\n\n返回： `/home/DolphinDB_Linux64_V2.00.10/server/plugins/mysql/PluginMySQL.txt`\n\n通过 `loadPlugin` 加载插件：\n\n```\nloadPlugin(\"mysql\")\n```\n\n\n\n**Related information**\n\n[listRemotePlugins](https://docs.dolphindb.cn/zh/funcs/l/listRemotePlugins.html)\n\n[loadPlugin](https://docs.dolphindb.cn/zh/funcs/l/loadPlugin.html)\n"
    },
    "int": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/int.html",
        "signatures": [
            {
                "full": "int(X)",
                "name": "int",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [int](https://docs.dolphindb.cn/zh/funcs/i/int.html)\n\n\n\n#### 语法\n\nint(X)\n\n#### 详情\n\n将输入的数据转换为 INT 类型数据。\n\n#### 参数\n\n**X** 可以是任意数据类型。\n\n#### 例子\n\n```\nx=int();\nx;\n```\n\n返回：null\n\n```\ntypestr x;\n```\n\n返回：INT\n\n```\nint(`10.9);\n```\n\n返回：10\n\n```\nint(2147483647);\n```\n\n返回：2,147,483,647\n\n**Note:** INT 数据类型的最大值为 231 -1 = 2,147,483,647。\n\n```\nint(2147483648);\n```\n\n由于2,147,483,648 超出了 INT 数据类型的最大值，因此返回：null\n"
    },
    "int128": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/int128.html",
        "signatures": [
            {
                "full": "int128(X)",
                "name": "int128",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [int128](https://docs.dolphindb.cn/zh/funcs/i/int128.html)\n\n\n\n#### 语法\n\nint128(X)\n\n#### 参数\n\n**X** 是一个字符串标量或向量。\n\n#### 详情\n\n把字符串转换为 INT128 类型。\n\n#### 例子\n\n```\na=int128(\"e1671797c52e15f763380b45e841ec32\")\n```\n\n返回：e1671797c52e15f763380b45e841ec32\n\n```\ntypestr(a);\n```\n\n返回：INT128\n"
    },
    "integral": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/integral.html",
        "signatures": [
            {
                "full": "integral(func, start, end, [start2], [end2])",
                "name": "integral",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "start",
                        "name": "start"
                    },
                    {
                        "full": "end",
                        "name": "end"
                    },
                    {
                        "full": "[start2]",
                        "name": "start2",
                        "optional": true
                    },
                    {
                        "full": "[end2]",
                        "name": "end2",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [integral](https://docs.dolphindb.cn/zh/funcs/i/integral.html)\n\n\n\n#### 语法\n\nintegral(func, start, end, \\[start2], \\[end2])\n\n#### 参数\n\n**func** 是一元或二元函数。\n\n**start** 是一个数值标量或向量，表示开始值。*start* 用 NULL 值表示负无穷。\n\n**end** 是一个数值标量或向量，表示结束值。*end* 用 NULL 值表示正无穷。\n\n**start2** 是一个数值标量，向量或一元函数，表示二重积分第二维度的开始值。*start2* 用 NULL 值表示负无穷。\n\n**end2** 是一个数值标量，向量或一元函数，表示二重积分第二维度的结束值。*end2* 用 NULL 值表示正无穷。\n\n如果 *start* 和 *end* 都是向量，或需要计算二重积分时，*start*, *end* , *start2* 和 *end2* 为向量，则它们的长度必须相同。如果部分为标量，其余为向量时，则会将标量当作与向量长度相同，所有元素值等于该标量的向量。\n\n#### 详情\n\n返回 *func* 在 *start* 和 *end* 范围内的积分，或在平面区域 *start* ≤ x ≤ *end* 和 *start2* ≤ y ≤ *end2* 上 *func* 的积分。\n\n当结果中出现无穷值或者计算过程中出现有关复数的计算时会返回 NULL。\n\n#### 例子\n\n```\nintegral(abs, -10, 10);\n// output\n100\n\nintegral(acos, [0.1, -0.10], [0.3, 0.10]);\n// output\n[0.273816,0.314159]\n\nintegral(acosh, [1, 2, 9, 9], 10);\n// output\n[19.982354,19.080489,2.941187,2.941187]\n\nintegral(pow{,3}, 5, 9);\n// output\n1484\n\nintegral(abs, NULL, NULL);\n// output\n00F\n\ndef f(x1,x2){\n   fx=100*(x2-x1*2)+square(1-x1)\n   return fx\n}\n\nintegral(f,0,1,7,1)\n// output\n-1802\n\nintegral(f,[0,1,2,3],7,2,[0,1,2,3])\n// output\n[8255.333333, 8256, 7856.666667, 7061.333333]\n```\n"
    },
    "interpolate": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/interpolate.html",
        "signatures": [
            {
                "full": "interpolate(X, [method='linear'], [limit], [inplace=false], [limitDirection='forward'], [limitArea])",
                "name": "interpolate",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[method='linear']",
                        "name": "method",
                        "optional": true,
                        "default": "'linear'"
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    },
                    {
                        "full": "[inplace=false]",
                        "name": "inplace",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[limitDirection='forward']",
                        "name": "limitDirection",
                        "optional": true,
                        "default": "'forward'"
                    },
                    {
                        "full": "[limitArea]",
                        "name": "limitArea",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [interpolate](https://docs.dolphindb.cn/zh/funcs/i/interpolate.html)\n\n\n\n#### 语法\n\ninterpolate(X, \\[method='linear'], \\[limit], \\[inplace=false], \\[limitDirection='forward'], \\[limitArea])\n\n#### 参数\n\n必填参数：\n\n**X** 是一个数值型向量。\n\n可选参数：\n\n**method** 是一个字符串，表示插值的方式。它的可取值为：\n\n* 'linear'：线性插值\n\n* 'pad'：使用已有的值填充\n\n* 'nearest'：使用最接近 NULL 值的有效值填充\n\n* 'krogh'：使用 krogh 多项式插值\n\n如果没有指定，默认值为 'linear'。\n\n**limit** 是一个正整数，表示最多要填充的连续 NULL 值的个数。\n\n**inplace** 是一个布尔值，表示是否使用结果覆盖输入的 *X*。默认值为 false，会返回一个新的向量。\n\n**limitDirection** 是一个字符串，表示填充 NULL 的方向。它的可取值为：'forward', 'backward' 和 'both'。默认值为 'forward'。\n\n**limitArea** 是一个字符串，表示填充的区域。它的可取值为：\n\n* 空字符串： 填充的区域没有限制\n\n* 'inside'： 只填充有效值包围的 NULL 值\n\n* 'outside'： 只填充有效值之外的 NULL 值\n\n#### 详情\n\n填充数值型向量中的 NULL 值。\n\n#### 返回值\n\n返回填充了指定个数 NULL 值的数值型向量。数据类型：数值型向量。\n\n#### 例子\n\n```\na=[NULL,NULL,1,2,NULL,NULL,5,6,NULL,NULL];\n\ninterpolate(a);\n// output\n[,,1,2,3,4,5,6,6,6]\n\ninterpolate(X=a, method=\"pad\");\n// output\n[,,1,2,2,2,5,6,6,6]\n\ninterpolate(X=a, limitDirection='both');\n// output\n[1,1,1,2,3,4,5,6,6,6]\n\ninterpolate(X=a, limit=1, limitDirection='both');\n// output\n[,1,1,2,3,4,5,6,6,]\n\ninterpolate(X=a, limitDirection='both', limitArea='outside');\n// output\n[1,1,1,2,,,5,6,6,6]\n\na;\n// output\n[,,1,2,,,5,6,,]\n\ninterpolate(X=a, limitDirection='backward', inplace=true);\n// output\n[1,1,1,2,3,4,5,6,,]\n\na;\n// output\n[1,1,1,2,3,4,5,6,,]\n```\n"
    },
    "intersection": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/intersection.html",
        "signatures": [
            {
                "full": "intersection(X, Y)",
                "name": "intersection",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [intersection](https://docs.dolphindb.cn/zh/funcs/i/intersection.html)\n\n\n\n#### 语法\n\nintersection(X, Y) 或 X\\&Y\n\n#### 参数\n\n**X** 和 **Y** 均为集合，或是相同长度的整形向量或标量。\n\n#### 详情\n\n若 *X* 和 *Y* 均为集合，返回其交集。\n\n若 *X* 和 *Y* 是相同长度的整形向量或标量，返回位运算 `AND` 的结果。\n\n#### 例子\n\n```\nx=set([5,5,3,4,6])\ny=set(8 9 4 4 6)\nx & y;\n\nset(4,6)\n\n6 7 8 & 4 5 6;\n// output\n[4,5,0]\n```\n"
    },
    "invBeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invBeta.html",
        "signatures": [
            {
                "full": "invBeta(alpha, beta, X)",
                "name": "invBeta",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invBeta](https://docs.dolphindb.cn/zh/funcs/i/invBeta.html)\n\n\n\n#### 语法\n\ninvBeta(alpha, beta, X)\n\n#### 参数\n\n形状参数 **alpha** 和 **beta** 都是正数。\n\n**X** 是 0 到 1 之间的浮点型标量或向量。\n\n#### 详情\n\n返回 Beta 分布的累计密度函数的逆函数值。\n\n#### 例子\n\n```\ninvBeta(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0.068102, 0.852866, 0.999994]\n\ninvBeta(2.31, 0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.471316, 0.717156, 0.852866, 0.939378, 0.989912]]\n```\n"
    },
    "invBinomial": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invBinomial.html",
        "signatures": [
            {
                "full": "invBinomial(trials, p, X)",
                "name": "invBinomial",
                "parameters": [
                    {
                        "full": "trials",
                        "name": "trials"
                    },
                    {
                        "full": "p",
                        "name": "p"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invBinomial](https://docs.dolphindb.cn/zh/funcs/i/invBinomial.html)\n\n\n\n#### 语法\n\ninvBinomial(trials, p, X)\n\n#### 参数\n\n**trials** 是正整数，形状参数。\n\n**p** 是0到1之间的浮点数，形状参数。\n\n**X** 是0到1之间的浮点型标量或向量。\n\n#### 详情\n\n返回二项分布的累计密度函数的逆函数值\n\n#### 例子\n\n```\ninvBinomial(10, 0.1, [0.1, 0.5, 0.9]);\n// output\n[0, 1, 2]\n\ninvBinomial(12,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[5, 7, 8, 8, 10]\n```\n"
    },
    "invChiSquare": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invChiSquare.html",
        "signatures": [
            {
                "full": "invChiSquare(df, X)",
                "name": "invChiSquare",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invChiSquare](https://docs.dolphindb.cn/zh/funcs/i/invChiSquare.html)\n\n\n\n#### 语法\n\ninvChiSquare(df, X)\n\n#### 参数\n\n**df** 是正数，表示卡方分布的自由度。\n\n**X** 是0到1之间的浮点型标量或向量。\n\n#### 详情\n\n返回卡方分布的累计密度函数的逆函数值。\n\n#### 例子\n\n```\ninvChiSquare(1, [0, 0.05, 0.15, 0.25]);\n// output\n[0, 0.003932, 0.035766, 0.101531]\n\ninvChiSquare(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n\n// output\n[0.015791, 0.148472, 0.454936, 1.074194, 2.705543]\n```\n"
    },
    "inverse": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/inverse.html",
        "signatures": [
            {
                "full": "inverse(X)",
                "name": "inverse",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [inverse](https://docs.dolphindb.cn/zh/funcs/i/inverse.html)\n\n\n\n#### 语法\n\ninverse(X)\n\n#### 参数\n\n**X** 是一个矩阵。\n\n#### 详情\n\n如果 *X* 可逆，返回矩阵 *X* 的逆矩阵。\n\n#### 例子\n\n```\nx=1..4$2:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\nx.inverse();\n```\n\n| #0 | #1   |\n| -- | ---- |\n| -2 | 1.5  |\n| 1  | -0.5 |\n"
    },
    "invExp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invExp.html",
        "signatures": [
            {
                "full": "invExp(mean, X)",
                "name": "invExp",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invExp](https://docs.dolphindb.cn/zh/funcs/i/invExp.html)\n\n\n\n#### 语法\n\ninvExp(mean, X)\n\n#### 参数\n\n**mean** 是指数分布的均值。\n\n**X** 是0到1之间的浮点型标量或向量。\n\n#### 详情\n\n返回指数分布的累计密度函数的逆函数值。\n\n#### 例子\n\n```\ninvExp(1, [0.05 0.15 0.25 0.35]);\n// output\n[0.051293, 0.162519, 0.287682, 0.430783]\n\ninvExp(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.105361, 0.356675, 0.693147, 1.203973, 2.302585]\n```\n"
    },
    "invF": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invF.html",
        "signatures": [
            {
                "full": "invF(numeratorDF, denominatorDF, X)",
                "name": "invF",
                "parameters": [
                    {
                        "full": "numeratorDF",
                        "name": "numeratorDF"
                    },
                    {
                        "full": "denominatorDF",
                        "name": "denominatorDF"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invF](https://docs.dolphindb.cn/zh/funcs/i/invF.html)\n\n\n\n#### 语法\n\ninvF(numeratorDF, denominatorDF, X)\n\n#### 参数\n\n**numeratorDF** 和 **denominatorDF** 都是正数，表示F分布的自由度。\n\n**X** 是0到1之间的浮点型标量或向量。\n\n#### 详情\n\n返回F分布的累计密度函数的逆函数值。\n\n#### 例子\n\n```\ninvF(2.31, 0.627, [0.001, 0.5, 0.7]);\n// output\n[0.002024, 2.69427, 14.992595]\n\ninvF(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.146649, 0.718555, 2.69427, 14.992595, 508.444221]\n```\n"
    },
    "invGamma": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invGamma.html",
        "signatures": [
            {
                "full": "invGamma(shape, scale, X)",
                "name": "invGamma",
                "parameters": [
                    {
                        "full": "shape",
                        "name": "shape"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invGamma](https://docs.dolphindb.cn/zh/funcs/i/invGamma.html)\n\n\n\n#### 语法\n\ninvGamma(shape, scale, X)\n\n#### 参数\n\n**shape** 为形状参数，是正数。\n\n**scale** 为尺度参数，是正数。\n\n**X** 是0到1之间的浮点型标量或向量。\n\n#### 详情\n\n返回Gamma分布的累计密度函数的逆函数值。\n\n#### 例子\n\n```\ninvGamma(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0.049713, 1.245583, 6.191955]\n\ninvGamma(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.437696, 0.843572, 1.245583, 1.760732, 2.724121]\n```\n"
    },
    "invLogistic": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invLogistic.html",
        "signatures": [
            {
                "full": "invLogistic(mean, s, X)",
                "name": "invLogistic",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "s",
                        "name": "s"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invLogistic](https://docs.dolphindb.cn/zh/funcs/i/invLogistic.html)\n\n\n\n#### 语法\n\ninvLogistic(mean, s, X)\n\n#### 参数\n\n**mean** 是Logistic分布的均值。\n\n**s** 是Logistic分布的尺度参数。\n\n**X** 是0到1之间的浮点型标量或向量。\n\n#### 详情\n\n返回Logistic分布的累计密度函数的逆函数值。\n\n#### 例子\n\n```\ninvLogistic( 2.31, 0.627, [0.5, 0.3, 0.5, 0.7, 0.1]);\n// output\n[2.31, 1.778744, 2.31, 2.841256, 0.93234]\n```\n"
    },
    "invNormal": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invNormal.html",
        "signatures": [
            {
                "full": "invNormal(mean, stdev, X)",
                "name": "invNormal",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "stdev",
                        "name": "stdev"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invNormal](https://docs.dolphindb.cn/zh/funcs/i/invNormal.html)\n\n\n\n#### 语法\n\ninvNormal(mean, stdev, X)\n\n#### 参数\n\n**mean** 是正态分布的均值。\n\n**stdev** 是正态分布的标准差。\n\n**X** 是0到1之间的浮点型标量或向量。\n\n#### 详情\n\n返回均值为 *mean*，标准差为 *stdev* 的正态分布的累计密度函数的逆函数值。\n\n#### 例子\n\n```\ninvNormal(0,1,0.33);\n// output\n-0.439913\n\ninvNormal(10, 20, [0.1, 0.2, 0.3]);\n// output\n[-15.631031, -6.832425, -0.48801]\n```\n"
    },
    "invPoisson": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invPoisson.html",
        "signatures": [
            {
                "full": "invPoisson(mean, X)",
                "name": "invPoisson",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invPoisson](https://docs.dolphindb.cn/zh/funcs/i/invPoisson.html)\n\n\n\n#### 语法\n\ninvPoisson(mean, X)\n\n#### 参数\n\n**mean** 是泊松分布的均值。\n\n**X** 是0到1之间的浮点型标量或向量。\n\n#### 详情\n\n返回泊松分布的累计分布函数的逆函数值。\n\n#### 例子\n\n```\ninvPoisson(1, [0.91, 0.92, 0.93]);\n// output\n[2, 3, 3]\n\ninvPoisson(3, [0.81, 0.83, 0.95, 0.97, 0.99]);\n// output\n[4, 5, 6, 7, 8]\n```\n"
    },
    "invStudent": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invStudent.html",
        "signatures": [
            {
                "full": "invStudent(df, X)",
                "name": "invStudent",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invStudent](https://docs.dolphindb.cn/zh/funcs/i/invStudent.html)\n\n\n\n#### 语法\n\ninvStudent(df, X)\n\n#### 参数\n\n**df** 是正数，表示t分布的自由度。\n\n**X** 是0到1之间的浮点型标量或向量。\n\n#### 详情\n\n返回t分布的累计密度函数的逆函数值。\n\n#### 例子\n\n```\ninvStudent(1, [0.15, 0.25, 0.35]);\n// output\n[-1.962611, -1, -0.509525]\n\ninvStudent(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[-3.077684, -0.726543, 0, 0.726543, 3.077684]\n```\n"
    },
    "invUniform": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invUniform.html",
        "signatures": [
            {
                "full": "invUniform(lower, upper, X)",
                "name": "invUniform",
                "parameters": [
                    {
                        "full": "lower",
                        "name": "lower"
                    },
                    {
                        "full": "upper",
                        "name": "upper"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invUniform](https://docs.dolphindb.cn/zh/funcs/i/invUniform.html)\n\n\n\n#### 语法\n\ninvUniform(lower, upper, X)\n\n#### 参数\n\n**lower** 和 **upper** 是数值型标量，表示连续均匀分布的下限和上限。\n\n**X** 是0到1之间的浮点型标量或向量。\n\n#### 详情\n\n返回均匀分布的累计密度函数的逆函数值。\n\n#### 例子\n\n```\ninvUniform(0.627, 2.31, [0.001, 0.5, 0.999]);\n// output\n[0.628683, 1.4685, 2.308317]\n\ninvUniform(0.627, 2.31, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.7953, 1.1319, 1.4685, 1.8051, 2.1417]\n```\n"
    },
    "invWeibull": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/invWeibull.html",
        "signatures": [
            {
                "full": "invWeibull(alpha, beta, X)",
                "name": "invWeibull",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [invWeibull](https://docs.dolphindb.cn/zh/funcs/i/invWeibull.html)\n\n\n\n#### 语法\n\ninvWeibull(alpha, beta, X)\n\n#### 参数\n\n**alpha** 和 **beta** 为形状参数，都是正数。\n\n**X** 是0到1之间的浮点型标量或向量。\n\n#### 详情\n\n返回Weibull分布的累计密度函数的逆函数值。\n\n#### 例子\n\n```\ninvWeibull(2.31, 0.627, [0.001, 0.5, 0.999]);\n// output\n[0.031525, 0.535009, 1.447494]\n\ninvWeibull(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n// output\n[0.236692, 0.401279, 0.535009, 0.679464, 0.899644]\n```\n"
    },
    "ipaddr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/ipaddr.html",
        "signatures": [
            {
                "full": "ipaddr(X)",
                "name": "ipaddr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ipaddr](https://docs.dolphindb.cn/zh/funcs/i/ipaddr.html)\n\n\n\n#### 语法\n\nipaddr(X)\n\n#### 详情\n\n把字符串转换成用于表达 IPv4 或 IPv6 地址的 IPADDR 类型数据。\n\n#### 参数\n\n**X** 是一个字符串标量或向量。\n\n#### 例子\n\n```\na=ipaddr(\"192.168.1.13\");\na;\n```\n\n返回：192.168.1.13\n\n```\ntypestr(a);\n```\n\n返回：IPADDR\n"
    },
    "irs": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/irs.html",
        "signatures": [
            {
                "full": "irs(settlement, resetInterval, start, maturity, notional, fixedRate, spread, curve, frequency, calendar, [convention='ModifiedFollowing'], [basis=1], [rateType=0])",
                "name": "irs",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "resetInterval",
                        "name": "resetInterval"
                    },
                    {
                        "full": "start",
                        "name": "start"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "notional",
                        "name": "notional"
                    },
                    {
                        "full": "fixedRate",
                        "name": "fixedRate"
                    },
                    {
                        "full": "spread",
                        "name": "spread"
                    },
                    {
                        "full": "curve",
                        "name": "curve"
                    },
                    {
                        "full": "frequency",
                        "name": "frequency"
                    },
                    {
                        "full": "calendar",
                        "name": "calendar"
                    },
                    {
                        "full": "[convention='ModifiedFollowing']",
                        "name": "convention",
                        "optional": true,
                        "default": "'ModifiedFollowing'"
                    },
                    {
                        "full": "[basis=1]",
                        "name": "basis",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[rateType=0]",
                        "name": "rateType",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [irs](https://docs.dolphindb.cn/zh/funcs/i/irs.html)\n\n\n\n#### 语法\n\n```\nirs(settlement, resetInterval, start, maturity, notional, fixedRate, spread, curve, frequency, calendar, [convention='ModifiedFollowing'], [basis=1], [rateType=0])\n```\n\n#### 描述\n\n本函数返回对于浮动利率支付方的利率互换估值，该估值是一个 DOUBLE 类型的标量或向量。\n\n利率互换是一种金融交易，交易双方同意交换未来一段时间内的利率支付流，一方支付固定利率，另一方支付浮动利率（通常是基于某个利率基准，如 SHIBOR），持续多个周期，直到合约结束。市场上的利率互换产品的互换间隔有1个月、3个月、半年、一年等。\n\n#### 参数\n\n**settlement** DATE 类型标量或向量，表示交易日，即利率互换估值日。\n\n**resetInterval** DURATION 标量或向量，表示利率的重置间隔。比如对于标的利率 FR007 来说，resetInterval 应设置为 7d，表示每 7 天重置一次利率。\n\n**start** DATE 类型标量或向量，表示第一次利率互换的日期。\n\n**maturity** DATE 类型标量或向量，表示最后一次利率互换的日期。\n\n**notional** 数值型标量或向量，表示利率互换所基于的本金。\n\n**fixedRate** 数值型标量或向量，表示利率互换中固定利率支付方所支付的利率，在整个利率互换期间该利率不变。\n\n**spread** 数值型标量或向量，表示浮动利率的利差。\n\n**curve** 字典类型标量或向量，表示拟合后的利率曲线。\n\n**frequency** 表示利率互换的频率，支持两种输入类型：\n\n* 整型标量或向量：表示一年内进行利率互换的次数；比如输入 1，表示每年互换 1 次；输入 2，表示每年互换 2 次。\n\n* DURATION 标量或向量：表示隔多久进行一次利率互换。比如输入 3M，表示每隔 3 个月互换一次。\n\n<table id=\"table_f5w_kvq_bdc\"><thead><tr><th align=\"left\">\n\n可选值\n\n</th><th align=\"left\">\n\n含义\n\n</th></tr></thead><tbody><tr><td>\n\n1 / 1y\n\n</td><td>\n\n表示每年付息1次\n\n</td></tr><tr><td>\n\n2 / 6M\n\n</td><td>\n\n表示每年付息2次 / 每6个月付息1次\n\n</td></tr><tr><td>\n\n3 / 4M\n\n</td><td>\n\n表示每年付息3次 / 每4个月付息1次\n\n</td></tr><tr><td>\n\n4 / 3M\n\n</td><td>\n\n表示每年付息4次 / 每3个月付息1次\n\n</td></tr><tr><td>\n\n6 / 2M\n\n</td><td>\n\n表示每年付息6次 / 每2个月付息1次\n\n</td></tr><tr><td>\n\n12 / 1M\n\n</td><td>\n\n表示每年付息12次 / 每月付息1次\n\n</td></tr><tr><td>\n\n13 / 4w\n\n</td><td>\n\n表示每年付息13次 / 每4周付息1次\n\n</td></tr><tr><td>\n\n26 / 2w\n\n</td><td>\n\n表示每年付息26次 / 每2周付息1次\n\n</td></tr><tr><td>\n\n52 / 1w\n\n</td><td>\n\n表示每年付息52次 / 每周付息1次\n\n</td></tr><tr><td>\n\n365 / 1d\n\n</td><td>\n\n表示每年付息365次 / 每天付息1次\n\n</td></tr></tbody>\n</table>**calendar** 字符串类型标量或向量，表示使用的市场日历类型，请参阅[交易日历](https://docs.dolphindb.cn/zh/modules/MarketHoliday/mkt_calendar.html#11-%E6%9F%A5%E8%AF%A2%E4%BA%A4%E6%98%93%E6%97%A5%E5%8E%86-getmarketcalendar)。\n\n**convention** 可选参数，字符串标量或向量，表示把非工作日调整到工作日的方法，可选值为：\n\n* 'Following'：表示选择给定假日后的第一个工作日。\n\n* 'ModifiedFollowing'：表示选择给定假日后的第一个工作日，除非该工作日属于不同的月份，此时应选择假日前的第一个工作日，默认值。\n\n* 'Preceding'：表示选择给定假日前的第一个工作日。\n\n* 'ModifiedPreceding'：表示选择给定假日前的第一个工作日，除非该工作日属于不同的月份，此时应选择假日后的第一个工作日。\n\n* 'Unadjusted'：表示不作调整。\n\n* 'HalfMonthModifiedFollowing'：表示选择给定假日后的第一个工作日，除非该工作日跨越了月中（15日）或月末，此时应选择假日前的第一个工作日。\n\n* 'Nearest'：表示选择离给定假日最近的工作日。如果前一个和后一个工作日距离给定假日同样远，则默认选择后一个工作日。\n\n**basis** 可选参数，整型标量或向量，表示要使用的日计数基准类型。如果省略此参数，则使用默认值 1。可选值为：\n\n| **Basis** | **日计数基准**        |\n| --------- | ---------------- |\n| 0         | US (NASD) 30/360 |\n| 1 或省略     | 实际/实际            |\n| 2         | 实际/360           |\n| 3         | 实际/365           |\n| 4         | 欧洲 30/360        |\n\n**rateType** 可选参数，整数标量或向量，表示估值过程使用的复利类型，可选值为：\n\n* 0：表示使用连续复利，默认值。\n\n* 1：表示使用普通复利。\n\n注意：如果输入参数中，部分为标量，其余为向量时，则会将标量当作与向量长度相同，所有元素值等于该标量的向量。所有向量的长度必须一致。\n\n#### 例子\n\n本例为 2023 年 7 月 10 日交易的一笔利率互换进行估值。其本金为 100 万人民币，利率互换频率为每周一次，2023 年 1 月 10 日进行第一次互换，5年后（2028 年 1 月 10 日）到期，采用上交所的交易日历。固定利率为 2.765%，浮动利率规定在 *curveRateValue*中，日计数基准为 US (NASD) 30/360，估值过程使用连续复利。\n\n```\nsettlement = 2023.07.10\ncalendar = `SSE\nday0 = temporalAdd(settlement, 0, calendar)\ncurveRateTime = [10y, 14d, 1d, 1M, 1y, 2y, 3M, 3y, 4y, 5y, 6M, 7d, 7y, 9M]\ncurveRateValue = [ 2.7013, 1.8, 1.27, 1.9425, 2.0263, 2.1265, 1.9725, 2.2438, 2.3575, 2.4538, 1.9938, 1.86, 2.5863, 2.0088] * 0.01\ndates = []\nfor (dur in curveRateTime) {\n\tdates.append!(temporalAdd(settlement, dur))\n}\nX = (dates - day0)$INT\n// a curve for base rate (without spread)\ncurve = linearInterpolateFit(X, curveRateValue)\nresetIntv = 7d\nstartDay = 2023.01.10\nendDay = 2028.01.10\npar = 100.0\nfixRate = 0.02765\nspread = 0.0\nfreq = 3M\nbasis = 0\nirs(settlement, resetIntv, startDay, endDay, par, fixRate, spread, curve, freq, calendar, basis=basis)\n// -1.5451083233900798\n```\n"
    },
    "isAlNum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isAlNum.html",
        "signatures": [
            {
                "full": "isAlNum(X)",
                "name": "isAlNum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isAlNum](https://docs.dolphindb.cn/zh/funcs/i/isAlNum.html)\n\n\n\n#### 语法\n\nisAlNum(X)\n\n#### 参数\n\n**X** 是字符或字符串类型的标量或向量。\n\n#### 详情\n\n判断 *X* 是否只包含字母或数字。如果 *X* 中的所有字符都是字母和数字，该函数返回true，反之返回false。对于空字符串（STRING类型的NULL值），该函数返回false。\n\n#### 例子\n\n```\nisAlNum(\"123456\");\n// output\ntrue\n\nisAlNum(\"1And1\");\n// output\ntrue\n\nisAlNum(\"10.05\");\n// output\nfalse\n\nisAlNum(string());\n// output\nfalse\n```\n"
    },
    "isAlpha": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isAlpha.html",
        "signatures": [
            {
                "full": "isAlpha(X)",
                "name": "isAlpha",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isAlpha](https://docs.dolphindb.cn/zh/funcs/i/isAlpha.html)\n\n\n\n#### 语法\n\nisAlpha(X)\n\n#### 参数\n\n**X** 是字符或字符串类型的标量、向量或表。\n\n#### 详情\n\n判断 *X* 是否只包含字母。如果 *X* 中的所有字符都是字母，该函数返回 true，反之，返回 false。对于空字符串（STRING 类型的 NULL 值），该函数返回 false。\n\n#### 例子\n\n```\nisAlpha(\"hello\");\n// output\ntrue\n\nisAlpha(\"hello world\");\n// output\nfalse\n\nisAlpha(\"1And1\");\n// output\nfalse\n\nisAlpha(string());\n// output\nfalse\n```\n"
    },
    "isChunkNodeInit": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isChunkNodeInit.html",
        "signatures": [
            {
                "full": "isDataNodeInitialized()",
                "name": "isDataNodeInitialized",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [isChunkNodeInit](https://docs.dolphindb.cn/zh/funcs/i/isChunkNodeInit.html)\n\n是 [isDataNodeInitialized](https://docs.dolphindb.cn/zh/funcs/i/isDataNodeInitialized.html) 的别名。\n\n\n以下是 `isDataNodeInitialized` 函数的文档：\n### [isDataNodeInitialized](https://docs.dolphindb.cn/zh/funcs/i/isDataNodeInitialized.html)\n\n\n\n#### 语法\n\nisDataNodeInitialized()\n\n#### 参数\n\n无\n\n#### 详情\n\n查看当前节点是否启动完成。若启动完成返回true，否则返回false。\n\n只适用于数据节点/计算节点。代理节点和控制节点不可用。\n\n#### 例子\n\n```\nisDataNodeInitialized()\n// output\ntrue\n```\n\n相关函数：[isControllerInitialized](https://docs.dolphindb.cn/zh/funcs/i/isControllerInitialized.html)\n"
    },
    "isColumnarTuple": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isColumnarTuple.html",
        "signatures": [
            {
                "full": "isColumnarTuple(X)",
                "name": "isColumnarTuple",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isColumnarTuple](https://docs.dolphindb.cn/zh/funcs/i/isColumnarTuple.html)\n\n\n\n#### 语法\n\nisColumnarTuple(X)\n\n#### 参数\n\n`X` 是一个元组。\n\n#### 详情\n\n判断一个元组是否是 columnar tuple。\n\n#### 例子\n\n```\ntp = [[1,2,3], [4,5,6], [7,8]]\nisColumnarTuple(tp)\n    false\n\ntp.setColumnarTuple!()\nisColumnarTuple(tp)\n    true\n```\n\n```\n\nid = 3 2 1 4\nval = [`aa`bb, `aa`cc`dd, `bb, `cc`dd]\nt = table(id, val)\n\nisColumnarTuple(t.val)\n    true\n\nisColumnarTuple(t.id)\n    false\n\nexec isColumnarTuple(val) from t\n    true\n\nav = array(INT[], 0, 10).append!([1 1 1 3, 2 4 2 5, 8 9 7 1, 5 4 3])\nt = table(id, av)\nisColumnarTuple(t.av)\n    false\n```\n"
    },
    "isControllerInitialized": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isControllerInitialized.html",
        "signatures": [
            {
                "full": "isControllerInitialized()",
                "name": "isControllerInitialized",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [isControllerInitialized](https://docs.dolphindb.cn/zh/funcs/i/isControllerInitialized.html)\n\n\n\n#### 语法\n\nisControllerInitialized()\n\n#### 参数\n\n无\n\n#### 详情\n\n查看控制节点是否启动完成。若启动完成返回 true，否则返回 false。普通集群环境下，仅在控制节点调用；高可用集群环境下，仅在 leader 节点调用。\n\n#### 例子\n\n```\nisControllerInitialized()\n// output\ntrue\n```\n\n相关函数：[isDataNodeInitialized](https://docs.dolphindb.cn/zh/funcs/i/isDataNodeInitialized.html)\n"
    },
    "isDataNodeInitialized": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isDataNodeInitialized.html",
        "signatures": [
            {
                "full": "isDataNodeInitialized()",
                "name": "isDataNodeInitialized",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [isDataNodeInitialized](https://docs.dolphindb.cn/zh/funcs/i/isDataNodeInitialized.html)\n\n\n\n#### 语法\n\nisDataNodeInitialized()\n\n#### 参数\n\n无\n\n#### 详情\n\n查看当前节点是否启动完成。若启动完成返回true，否则返回false。\n\n只适用于数据节点/计算节点。代理节点和控制节点不可用。\n\n#### 例子\n\n```\nisDataNodeInitialized()\n// output\ntrue\n```\n\n相关函数：[isControllerInitialized](https://docs.dolphindb.cn/zh/funcs/i/isControllerInitialized.html)\n"
    },
    "isDigit": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isDigit.html",
        "signatures": [
            {
                "full": "isDigit(X)",
                "name": "isDigit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isDigit](https://docs.dolphindb.cn/zh/funcs/i/isDigit.html)\n\n\n\n#### 语法\n\nisDigit(X)\n\n#### 参数\n\n**X** 是字符或字符串类型的标量、向量或表。\n\n#### 详情\n\n判断 *X* 是否只包含数字。如果 *X* 中的所有字符都是数字，该函数返回 true，反之返回 false。对于空字符串（STRING 类型的 NULL 值），该函数返回 false。\n\n#### 例子\n\n```\nisDigit(\"123456\");\n// output\ntrue\n\nisDigit(\"1And1\");\n// output\nfalse\n\nisDigit(\"10.05\");\n// output\nfalse\n\nisDigit(string());\n// output\nfalse\n```\n"
    },
    "isDuplicated": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isDuplicated.html",
        "signatures": [
            {
                "full": "isDuplicated(X, [keep=FIRST])",
                "name": "isDuplicated",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[keep=FIRST]",
                        "name": "keep",
                        "optional": true,
                        "default": "FIRST"
                    }
                ]
            }
        ],
        "markdown": "### [isDuplicated](https://docs.dolphindb.cn/zh/funcs/i/isDuplicated.html)\n\n\n\n#### 语法\n\nisDuplicated(X, \\[keep=FIRST])\n\n#### 参数\n\n**X** 是一个向量或包含多个等长向量的元组。\n\n**keep** 是一个常量，表示系统处理多个重复值的方式。它的取值可以是 FIRST, LAST 或 NONE。它是一个可选参数，默认值为 FIRST。\n\n#### 详情\n\n判断向量中是否包含重复值。如果 *X* 是一个向量，返回的结果是一个与 *X* 长度相同的布尔向量。如果 *X* 是一个元组，返回的结果是一个与 *X* 中每个元素等长的布尔向量。\n\n如果输入向量中有多个重复值，\n\n* *keep* 的取值为 FIRST 表示，返回结果中第一个重复值对应位置的值为 false，其他重复值对应位置的值为 true。\n\n* *keep* 的取值为 LAST 表示，返回结果中最后一个重复值对应位置的值为 false，其他重复值对应位置的值为 true。\n\n* *keep* 的取值为 NONE 表示，返回结果中所有重复值对应位置的值都为 true。\n\n#### 例子\n\n下面通过一个例子说明 *keep* 参数不同取值的区别。\n\n```\nv = [1,3,1,-6,NULL,2,NULL,1]\nisDuplicated(v,FIRST);\n//output:[false,false,true,false,false,false,true,true]\n// 1在向量 v 中出现了三次，所在的位置是第0、第2和第7位，由于 isDuplicated 的第二个参数为 FIRST，因此返回结果中第0位为 false，第2和第7位为 true。\n\nv = [1,3,1,-6,NULL,2,NULL,1]\nisDuplicated(v,LAST);\n//output:[true,false,true,false,true,false,false,false]\n// 1在向量 v 中出现了三次，所在的位置是第0、第2和第7位，由于 isDuplicated 的第二个参数为 LAST，因此返回结果中第7位为 false，第0和第1位为 true。\n\nv = [1,3,1,-6,NULL,2,NULL,1]\nisDuplicated(v,NONE);\n//output:[true,false,true,false,true,false,true,true]\n// 1在向量 v 中出现了三次，所在的位置是第0、第2和第7位，由于 isDuplicated 的第二个参数为 NONE，因此返回结果中第0、第1位和第7位都为 true。\n```\n\n`isDuplicated` 函数可以去除表中的重复记录。\n\n```\nt=table(1 2 4 8 4 2 7 1 as id, 10 20 40 80 40 20 70 10 as val);\nt;\n```\n\n| id | val |\n| -- | --- |\n| 1  | 10  |\n| 2  | 20  |\n| 4  | 40  |\n| 8  | 80  |\n| 4  | 40  |\n| 2  | 20  |\n| 7  | 70  |\n| 1  | 10  |\n\n```\nselect * from t where isDuplicated([id,val],FIRST)=false;\n// 保留第一条重复的记录，去除表中其他重复的记录\n```\n\n| id | val |\n| -- | --- |\n| 1  | 10  |\n| 2  | 20  |\n| 4  | 40  |\n| 8  | 80  |\n| 7  | 70  |\n\n下例展示 `isDuplicated` 判断 BLOB 类型数据。\n\n```\na=[blob(\"s1\"), blob(\"s2\")]\nisDuplicated(a)\n//output: [false, false]\n\na1=[blob(\"s1\"), blob(\"s2\"), blob(\"s1\"), blob(\"s2\")]\nisDuplicated(a1)\n//output: [false, false, true, true]\n```\n"
    },
    "isIndexedMatrix": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isIndexedMatrix.html",
        "signatures": [
            {
                "full": "isIndexedMatrix(X)",
                "name": "isIndexedMatrix",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isIndexedMatrix](https://docs.dolphindb.cn/zh/funcs/i/isIndexedMatrix.html)\n\n\n\n#### 语法\n\nisIndexedMatrix(X)\n\n#### 参数\n\n**X** 是一个矩阵。\n\n#### 详情\n\n判断 *X* 是否为有索引的矩阵。\n\n#### 例子\n\n```\nm=matrix(1..10, 11..20)\nm.rename!(2020.01.01..2020.01.10, `A`B);\n\nisIndexedMatrix(m);\n// output\nfalse\n\nm.setIndexedMatrix!()\nisIndexedMatrix(m);\n// output\ntrue\n```\n"
    },
    "isIndexedSeries": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isIndexedSeries.html",
        "signatures": [
            {
                "full": "isIndexedSeries(X)",
                "name": "isIndexedSeries",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isIndexedSeries](https://docs.dolphindb.cn/zh/funcs/i/isIndexedSeries.html)\n\n\n\n#### 语法\n\nisIndexedSeries(X)\n\n#### 参数\n\n**X** 是一个单列矩阵。\n\n#### 详情\n\n判断 *X* 是否为有索引的序列。\n\n#### 例子\n\n```\ns=matrix(1..10).rename!(2020.01.01..2020.01.10, );\n\nisIndexedSeries(s);\n// output\nfalse\n\ns.setIndexedSeries!()\nisIndexedSeries(s);\n\ntrue\n```\n"
    },
    "isLeapYear": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isLeapYear.html",
        "signatures": [
            {
                "full": "isLeapYear(X)",
                "name": "isLeapYear",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isLeapYear](https://docs.dolphindb.cn/zh/funcs/i/isLeapYear.html)\n\n\n\n#### 语法\n\nisLeapYear(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n判断 *X* 是否为闰年。\n\n#### 例子\n\n```\nisLeapYear(2012.06.12T12:30:00);\n// output\ntrue\n\nisLeapYear([2012.01.01,2013.01.01,2014.01.01,2015.01.01]);\n// output\n[true,false,false,false]\n```\n"
    },
    "isLoggedIn": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isLoggedIn.html",
        "signatures": [
            {
                "full": "isLoggedIn(userId)",
                "name": "isLoggedIn",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    }
                ]
            }
        ],
        "markdown": "### [isLoggedIn](https://docs.dolphindb.cn/zh/funcs/i/isLoggedIn.html)\n\n\n\n#### 语法\n\nisLoggedIn(userId)\n\n#### 参数\n\n**userId** 是表示用户名的字符串。它只能包含字母、数字和下划线。它不能以数字开头，长度不能超过30个字符。\n\n#### 详情\n\n返回一个表示用户是否已经登录的布尔值。\n\n#### 例子\n\n```\nisLoggedIn(`AlexSmith)\n// output\nfalse\n```\n"
    },
    "isLower": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isLower.html",
        "signatures": [
            {
                "full": "isLower(X)",
                "name": "isLower",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isLower](https://docs.dolphindb.cn/zh/funcs/i/isLower.html)\n\n\n\n#### 语法\n\nisLower(X)\n\n#### 参数\n\n**X** 是字符或字符串类型的标量、向量或表。\n\n#### 详情\n\n判断字符串中的字母是否全部为小写。对于空字符串，该函数返回 false。\n\n#### 例子\n\n```\nisLower(\"this is string example....wow!!!\");\n// output\ntrue\n\nisLower(\"THIS is string example....wow!!!\");\n// output\nfalse\n\nisLower(\"123456abc\");\n// output\ntrue\n\nisLower(\"123\");\n// output\nfalse\n\nisLower([\"  \",string()]);\n// output\n[false,false]\n```\n\n相关函数：[isUpper](https://docs.dolphindb.cn/zh/funcs/i/isUpper.html), [isTitle](https://docs.dolphindb.cn/zh/funcs/i/isTitle.html)\n"
    },
    "isMonotonic": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isMonotonic.html",
        "signatures": [
            {
                "full": "isMonotonicIncreasing(X)",
                "name": "isMonotonicIncreasing",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isMonotonic](https://docs.dolphindb.cn/zh/funcs/i/isMonotonic.html)\n\n是 [isMonotonicIncreasing](https://docs.dolphindb.cn/zh/funcs/i/isMonotonicIncreasing.html) 的别名。\n\n\n以下是 `isMonotonicIncreasing` 函数的文档：\n### [isMonotonicIncreasing](https://docs.dolphindb.cn/zh/funcs/i/isMonotonicIncreasing.html)\n\n\n\n#### 语法\n\nisMonotonicIncreasing(X)\n\n#### 参数\n\n**X** 可以是标量或向量。\n\n#### 详情\n\n判断 *X* 是否为单调递增。\n\n#### 例子\n\n```\na=[int(),2,5,7,10]\nisMonotonicIncreasing(a);\n// output\ntrue\n\na=[2.1,double(),3.5,4.7,8.2,10.5]\nisMonotonicIncreasing(a);\n// output\nfalse\n\na=[5,10,14,20,int()]\nisMonotonicIncreasing(a);\n// output\nfalse\n```\n\n相关函数：[isMonotonicDecreasing](https://docs.dolphindb.cn/zh/funcs/i/isMonotonicDecreasing.html), [isMonotonic](https://docs.dolphindb.cn/zh/funcs/i/isMonotonic.html)\n"
    },
    "isMonotonicDecreasing": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isMonotonicDecreasing.html",
        "signatures": [
            {
                "full": "isMonotonicDecreasing(X)",
                "name": "isMonotonicDecreasing",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isMonotonicDecreasing](https://docs.dolphindb.cn/zh/funcs/i/isMonotonicDecreasing.html)\n\n\n\n#### 语法\n\nisMonotonicDecreasing(X)\n\n#### 参数\n\n**X** 可以是标量或向量。\n\n#### 详情\n\n判断 *X* 是否为单调递减。\n\n#### 例子\n\n```\na=[10,7,5,2,int()];\nisMonotonicDecreasing(a);\n// output\ntrue\n\na=[10.5,8.7,int(),5.3,1.0];\nisMonotonicDecreasing(a);\n// output\nfalse\n\na=[5,10,14,20,int()];\nisMonotonicDecreasing(a);\n// output\nfalse\n```\n\n相关函数：[isMonotonicIncreasing](https://docs.dolphindb.cn/zh/funcs/i/isMonotonicIncreasing.html), [isMonotonic](https://docs.dolphindb.cn/zh/funcs/i/isMonotonic.html)\n"
    },
    "isMonotonicIncreasing": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isMonotonicIncreasing.html",
        "signatures": [
            {
                "full": "isMonotonicIncreasing(X)",
                "name": "isMonotonicIncreasing",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isMonotonicIncreasing](https://docs.dolphindb.cn/zh/funcs/i/isMonotonicIncreasing.html)\n\n\n\n#### 语法\n\nisMonotonicIncreasing(X)\n\n#### 参数\n\n**X** 可以是标量或向量。\n\n#### 详情\n\n判断 *X* 是否为单调递增。\n\n#### 例子\n\n```\na=[int(),2,5,7,10]\nisMonotonicIncreasing(a);\n// output\ntrue\n\na=[2.1,double(),3.5,4.7,8.2,10.5]\nisMonotonicIncreasing(a);\n// output\nfalse\n\na=[5,10,14,20,int()]\nisMonotonicIncreasing(a);\n// output\nfalse\n```\n\n相关函数：[isMonotonicDecreasing](https://docs.dolphindb.cn/zh/funcs/i/isMonotonicDecreasing.html), [isMonotonic](https://docs.dolphindb.cn/zh/funcs/i/isMonotonic.html)\n"
    },
    "isMonthEnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isMonthEnd.html",
        "signatures": [
            {
                "full": "isMonthEnd(X)",
                "name": "isMonthEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isMonthEnd](https://docs.dolphindb.cn/zh/funcs/i/isMonthEnd.html)\n\n\n\n#### 语法\n\nisMonthEnd(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n判断 *X* 是否为月末最后一天。\n\n#### 例子\n\n```\nisMonthEnd(2012.05.31);\n// output\ntrue\n\nisMonthEnd([2012.05.30,2012.05.31]);\n// output\n[false,true]\n```\n\n相关函数：[isMonthStart](https://docs.dolphindb.cn/zh/funcs/i/isMonthStart.html)\n"
    },
    "isMonthStart": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isMonthStart.html",
        "signatures": [
            {
                "full": "isMonthStart(X)",
                "name": "isMonthStart",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isMonthStart](https://docs.dolphindb.cn/zh/funcs/i/isMonthStart.html)\n\n\n\n#### 语法\n\nisMonthStart(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n判断 *X* 是否为月初第一天。\n\n#### 例子\n\n```\nisMonthStart(2012.05.01);\n// output\ntrue\n\nisMonthStart([2012.05.01,2012.05.02]);\n// output\n[true,false]\n```\n\n相关函数：[isMonthEnd](https://docs.dolphindb.cn/zh/funcs/i/isMonthEnd.html)\n"
    },
    "isNanInf": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isNanInf.html",
        "signatures": [
            {
                "full": "isNanInf(X, [includeNull=false])",
                "name": "isNanInf",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[includeNull=false]",
                        "name": "includeNull",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [isNanInf](https://docs.dolphindb.cn/zh/funcs/i/isNanInf.html)\n\n\n\n#### 语法\n\nisNanInf(X, \\[includeNull=false])\n\n#### 参数\n\n**X** 是 DOUBLE 类型的标量/向量/矩阵。\n\n**includeNull** 是一个布尔值。\n\n#### 详情\n\n检测 *X* 中的每一个元素是否为 NaN 或 Inf。返回与 *X* 等长的布尔类型。若 *includeNull* 设为 true，NULL 值会被视为 Nan 或 Inf，默认为 false。\n\n相关函数：[countNanInf](https://docs.dolphindb.cn/zh/funcs/c/countNanInf.html)\n"
    },
    "isNothing": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isNothing.html",
        "signatures": [
            {
                "full": "isNothing(X)",
                "name": "isNothing",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isNothing](https://docs.dolphindb.cn/zh/funcs/i/isNothing.html)\n\n\n\n#### 语法\n\nisNothing(X)\n\n#### 参数\n\n**X** 可以是标量或向量。\n\n#### 详情\n\n\"Nothing\" 是两个 VOID 类型的对象之一。\n\n`isNothing` 用于检查一个函数被调用时，函数的参数是否被传了值进来。\n\n#### 例子\n\n```\nf=def(x,y): isNothing(y);\nf(5,);\n// output\ntrue\n\nf(5, NULL);\n// output\nfalse\n```\n"
    },
    "isNull": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isNull.html",
        "signatures": [
            {
                "full": "isNull(X)",
                "name": "isNull",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isNull](https://docs.dolphindb.cn/zh/funcs/i/isNull.html)\n\n\n\n#### 语法\n\nisNull(X)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量、字典、矩阵或内存表。\n\n#### 详情\n\n用于检查是否是 NULL 值。如果元素是 NULL，返回 true。\n\n**Note:** 自 2.00.5 版本开始，当 *X* 是字典、元组、数据向量或表时，该函数将检查每一行中的元素是否是 NULL 值，返回一个具有相同维度的字典、元组或表。\n\n#### 例子\n\n```\nisNull(00i);\n// output\ntrue\n\nisNull(1 NULL NULL 6 NULL 7);\n\n[0,1,1,0,1,0]\n\nisNull(1/0);\n// output\ntrue\n\nx=1 NULL 5 NULL 4 6$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 5  | 4  |\n|    |    | 6  |\n\n```\nisNull(x);\n```\n\n| #0    | #1    | #2    |\n| ----- | ----- | ----- |\n| false | false | false |\n| true  | true  | false |\n\n```\nt=table(1 2 3 as id, `a`b`c as name, 10 NULL 7 as vol)\nisNull(t)\n```\n\n| id    | name  | vol   |\n| ----- | ----- | ----- |\n| false | false | false |\n| false | false | true  |\n| false | false | false |\n\n相关函数：[hasNull](https://docs.dolphindb.cn/zh/funcs/h/hasNull.html), [nullFill](https://docs.dolphindb.cn/zh/funcs/n/nullFill.html)\n"
    },
    "isNumeric": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isNumeric.html",
        "signatures": [
            {
                "full": "isNumeric(X)",
                "name": "isNumeric",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isNumeric](https://docs.dolphindb.cn/zh/funcs/i/isNumeric.html)\n\n\n\n#### 语法\n\nisNumeric(X)\n\n#### 参数\n\n**X** 是字符或字符串类型的标量、向量或表。\n\n#### 详情\n\n判断 *X* 是否只包含数字。如果 *X* 中的所有字符都是数字，该函数返回 true，反之返回 false。对于空字符串（STRING 类型的 NULL 值），该函数返回 false。\n\n#### 例子\n\n```\nisNumeric(\"123456\");\n// output\ntrue\n\nisNumeric(\"1And1\");\n// output\nfalse\n\nisNumeric(\"10.05\");\n// output\nfalse\n\nisNumeric(string());\n// output\nfalse\n```\n"
    },
    "isOrderedDict": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isOrderedDict.html",
        "signatures": [
            {
                "full": "isOrderedDict(X)",
                "name": "isOrderedDict",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isOrderedDict](https://docs.dolphindb.cn/zh/funcs/i/isOrderedDict.html)\n\n\n\n#### 语法\n\nisOrderedDict(X)\n\n#### 参数\n\n**X**：一个字典对象。\n\n#### 详情\n\n判断 *X* 是否为一个有序字典：\n\n* 如果是，返回 *true*；\n* 如果不是， *false*。\n\n#### 例子\n\n```\nx=1 5 3\ny=4.5 7.8 4.3\nz=dict(x,y);\nisOrderedDict(z)\n// output\nfalse\n\nz1=dict(x,y,true);\nisOrderedDict(z1)\n// output\ntrue\n```\n"
    },
    "isort": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isort.html",
        "signatures": [
            {
                "full": "isort(X, [ascending=true])",
                "name": "isort",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [isort](https://docs.dolphindb.cn/zh/funcs/i/isort.html)\n\n\n\n#### 语法\n\nisort(X, \\[ascending=true])\n\n#### 参数\n\n**X** 是一个向量或一个由多个等长向量组成的元组。\n\n**ascending** 是布尔值标量或向量，表示按升序排序还是按降序排序。默认值为 true（按升序排序）。\n\n#### 详情\n\n和 [sort!](https://docs.dolphindb.cn/zh/funcs/s/sort_.html) 返回一个排序后的数组不同，*isort* 返回排序后的每个元素在原始向量中的索引。\n\nX\\[isort X] 等价于 sort(X)。\n\n#### 例子\n\n```\nx = 4 1 3 2;\ny = isort(x);\ny;\n// output\n[1,3,2,0]\n// 对于排序后的 x: [1 2 3 4]，第一个元素 1 在原始的 x 中的位置是 1，第二个元素 2 在原始 x 中的位置是 3，... 以此类推。\nx[y];\n// output\n[1,2,3,4]\n// 等价于 sort(x)\n\nz=isort(x, false);\nz;\n// output\n[0,2,3,1]\nx[z];\n// output\n[4,3,2,1]\n\nx=2 2 1 1\ny=2 1 1 2\nisort([x,y]);\n// output\n[2,3,1,0]\nisort([x,y],[0,0]);\n// output\n[0,1,3,2]\n```\n\n基于表的单列排序：\n\n```\nt2 = table(4 2 3 1 as x, 9 6 7 3 as y);\nt2;\n```\n\n| x | y |\n| - | - |\n| 4 | 9 |\n| 2 | 6 |\n| 3 | 7 |\n| 1 | 3 |\n\n```\nt2[isort(t2.x)];\n```\n\n| x | y |\n| - | - |\n| 1 | 3 |\n| 2 | 6 |\n| 3 | 7 |\n| 4 | 9 |\n\n```\nt2[isort(t2.x, false)];\n```\n\n| x | y |\n| - | - |\n| 4 | 9 |\n| 3 | 7 |\n| 2 | 6 |\n| 1 | 3 |\n\n基于表的多列排序：\n\n```\na=5 5 5 3 3 8 7 7;\nb=`MSFT`GOOG`IBM`YHOO`X`YHOO`C`ORCL;\nt=table(a,b);\nt;\n```\n\n| a | b    |\n| - | ---- |\n| 5 | MSFT |\n| 5 | GOOG |\n| 5 | IBM  |\n| 3 | YHOO |\n| 3 | X    |\n| 8 | YHOO |\n| 7 | C    |\n| 7 | ORCL |\n\n```\nt[isort([a,b], false true)];\n// 先基于 a 降序排序，再基于 b 升序排序\n```\n\n| a | b    |\n| - | ---- |\n| 8 | YHOO |\n| 7 | C    |\n| 7 | ORCL |\n| 5 | GOOG |\n| 5 | IBM  |\n| 5 | MSFT |\n| 3 | X    |\n| 3 | YHOO |\n\n```\nt[isort([a,b], false)];\n// 等价于 t[isort([a,b], false false)];\n```\n\n| a | b    |\n| - | ---- |\n| 8 | YHOO |\n| 7 | ORCL |\n| 7 | C    |\n| 5 | MSFT |\n| 5 | IBM  |\n| 5 | GOOG |\n| 3 | YHOO |\n| 3 | X    |\n"
    },
    "isortTop": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isortTop.html",
        "signatures": [
            {
                "full": "isortTop(X, top, [ascending=true])",
                "name": "isortTop",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [isortTop](https://docs.dolphindb.cn/zh/funcs/i/isortTop.html)\n\n\n\n#### 语法\n\nisortTop(X, top, \\[ascending=true])\n\n#### 参数\n\n**X** 可以是一个向量或一个由多个等长向量组成的元组。\n\n**top** 是一个正整数，它的值不能超过 *X* 的长度。\n\n**ascending** 是一个布尔型的标量或向量，表示 *X* 按升序排序还是降序排序。它是可选参数，默认值为 true，表示按升序排序。\n\n#### 详情\n\n返回 *X* 排序后前 *top* 个元素对应的索引。\n\n#### 例子\n\n```\nisortTop(2 1 4 3 6 5, 3);\n// output\n[1,0,3]\n\nisortTop(2 1 4 3 6 5, 3, false);\n// output\n[4,5,2]\n\nx=1 1 2 2 3 3\ny=1 2 1 2 1 2\nisortTop([x,y], 3);\n// output\n[0,1,2]\n\nx=1 1 2 2 3 3\ny=1 2 1 2 1 2\nisortTop([x,y], 3, [false, false]);\n# 先基于 x 降序排序，对于 x 中相同的元素，再基于 y 降序排序后，取前3个元素对应的索引\n// output\n[5,4,3]\n```\n"
    },
    "isort!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isort_.html",
        "signatures": [
            {
                "full": "isort!(X, [ascending=true], indices)",
                "name": "isort!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "indices",
                        "name": "indices"
                    }
                ]
            }
        ],
        "markdown": "### [isort!](https://docs.dolphindb.cn/zh/funcs/i/isort_.html)\n\n\n\n#### 语法\n\nisort!(X, \\[ascending=true], indices)\n\n#### 参数\n\n**X** 是一个向量或一个由多个等长向量组成的元组。\n\n**ascending** 是布尔值，表示按升序排序还是按降序排序。默认值为 true（按升序排序）。\n\n**indices** 是一个向量，它的长度与 *X* 中每个向量的长度相同。\n\n#### 详情\n\nisort!(x, ascending, y) 相当于 y\\[isort(x, ascending)]，结果会赋给 y。\n\n#### 例子\n\n```\nx=3 1 NULL 2\ny=5 7 8 3\nisort!(x, false, y);\n// output\n[5, 3, 7, 8]\n// 排序后的x为[3, 2, 1, NULL]，第一个元素3与y中的5对应，第二个元素与2与y中的3对应，第三个元素1与y中的7对应，...以此类推。\n\nx=2 2 1 1\ny=2 1 1 2\nisort!([x,y],[1,0],5 4 3 2);\n// output\n[2,3,5,4]\n```\n"
    },
    "isPeak": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isPeak.html",
        "signatures": [
            {
                "full": "isPeak(X, [strict=true])",
                "name": "isPeak",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[strict=true]",
                        "name": "strict",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [isPeak](https://docs.dolphindb.cn/zh/funcs/i/isPeak.html)\n\n\n\n#### 语法\n\nisPeak(X, \\[strict=true])\n\n#### 参数\n\n**X** 数值型向量/矩阵/表。\n\n**strict** 布尔值，默认值为 true。\n\n* 若 *strict* = true，相邻元素不为空且严格小于该元素\n* 若 *strict* = false，相邻元素不为空且小于等于该元素\n\n#### 详情\n\n若 *X* 为向量，计算 *X* 中的每个元素是否为峰值点，若是则返回 true，否则返回 false。\n\n若 *X* 为矩阵，在每列进行上述计算，返回值一个同 *X* 维度相同的矩阵。若 *X* 为表，则只对数值型的列进行上述计算。\n\n#### 例子\n\n```\nv = [1, 2.2, 2.2, 2.2, 2.3, 1, 1.2]\nisPeak(v)\n// output\n[false,false,false,false,true,false,false]\n\nv = [1, 2.2, 2.2, 2.2, 1.6, 1, 1.2]\nisPeak(v)\n// output\n[false,false,false,false,false,false,false]\nisPeak(v, false)\n// output\n[false,true,true,true,false,false,false]\n\n// 矩阵在每列单独计算\nm = matrix(3.3 2.8 5.6 NULL 2.5 1.2, 4.5 3.5 4.6 2.8 3.9 NULL)\nisPeak(m)\n```\n\n| #0    | #1    |\n| ----- | ----- |\n| false | false |\n| false | false |\n| false | true  |\n| false | false |\n| false | false |\n| false | false |\n\n```\n// 表只在数值列进行计算\nt = table(`01`01`00`01`02`00 as id, 388.3 390.6 390.8 390.6 390.3 391.5 as price)\nisPeak(t)\n```\n\n| id | price |\n| -- | ----- |\n| 01 | false |\n| 01 | false |\n| 00 | true  |\n| 01 | false |\n| 02 | false |\n| 00 | false |\n\n相关函数：[isValley](https://docs.dolphindb.cn/zh/funcs/i/isValley.html)\n"
    },
    "isQuarterEnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isQuarterEnd.html",
        "signatures": [
            {
                "full": "isQuarterEnd(X)",
                "name": "isQuarterEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isQuarterEnd](https://docs.dolphindb.cn/zh/funcs/i/isQuarterEnd.html)\n\n\n\n#### 语法\n\nisQuarterEnd(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n判断 *X* 是否为季度最后一天。\n\n#### 例子\n\n```\nisQuarterEnd(2012.06.30);\n// output\ntrue\n\nisQuarterEnd([2012.06.30,2012.07.01]);\n// output\n[true,false]\n```\n\n相关函数：[isQuarterStart](https://docs.dolphindb.cn/zh/funcs/i/isQuarterStart.html)\n"
    },
    "isQuarterStart": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isQuarterStart.html",
        "signatures": [
            {
                "full": "isQuarterStart(X)",
                "name": "isQuarterStart",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isQuarterStart](https://docs.dolphindb.cn/zh/funcs/i/isQuarterStart.html)\n\n\n\n#### 语法\n\nisQuarterStart(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n判断 *X* 是否为季度第一天。\n\n#### 例子\n\n```\nisQuarterStart(2012.04.01);\n// output\ntrue\n\nisQuarterStart([2012.04.01,2012.05.01]);\n// output\n[true,false]\n```\n\n相关函数：[isQuarterEnd](https://docs.dolphindb.cn/zh/funcs/i/isQuarterEnd.html)\n"
    },
    "isSorted": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isSorted.html",
        "signatures": [
            {
                "full": "isSorted(X, [ascending=true])",
                "name": "isSorted",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [isSorted](https://docs.dolphindb.cn/zh/funcs/i/isSorted.html)\n\n\n\n#### 语法\n\nisSorted(X, \\[ascending=true])\n\n#### 参数\n\n**X** 是一个向量。\n\n**ascending** 是布尔值，表示 *X* 按升序排序（true）或降序排序（false）。默认值为 true。\n\n#### 详情\n\n检查 *X* 是否排序。\n\n#### 例子\n\n```\nx=NULL 1 2 3\nisSorted(x);\n// output\ntrue\n\nt=table(9 7 5 3 as x, 1 5 2 4 as y)\nt.x.isSorted(false);\n// output\ntrue\n\nt.y.isSorted();\n// output\nfalse\n```\n"
    },
    "isSpace": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isSpace.html",
        "signatures": [
            {
                "full": "isSpace(X)",
                "name": "isSpace",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isSpace](https://docs.dolphindb.cn/zh/funcs/i/isSpace.html)\n\n\n\n#### 语法\n\nisSpace(X)\n\n#### 参数\n\n**X** 是字符或字符串类型的标量、向量或表。\n\n#### 详情\n\n判断 *X* 是否为空格类字符串。如果 *X* 中的字符都是空格、跳格符(\\t)、回车符(\\r)或换行符(\\n)，该函数返回 true，反之，返回 false。对于空字符串（STRING 类型的 NULL 值），该函数返回 false。\n\n#### 例子\n\n```\nisSpace(\"hello world\");\n// output\nfalse\n\nisSpace(\" \\t \");\n// output\ntrue\n\nisSpace(string());\n// output\nfalse\n```\n"
    },
    "isTitle": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isTitle.html",
        "signatures": [
            {
                "full": "isTitle(X)",
                "name": "isTitle",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isTitle](https://docs.dolphindb.cn/zh/funcs/i/isTitle.html)\n\n\n\n#### 语法\n\nisTitle(X)\n\n#### 参数\n\n**X** 可以是字符串标量或向量。\n\n#### 详情\n\n判断字符串中每个单词的第一个字母是否为大写，其他字母都为小写。对于不包含字母的字符串和空字符串，该函数返回 false。\n\n#### 例子\n\n```\nisTitle(\"Hello World\");\n// output\ntrue\n\nisTitle(\"Hello world\");\n// output\nfalse\n\nisTitle([\"Hello\",\"468\",\"  \"]);\n// output\n[true,false,false]\n\nisTitle(\"1And1\");\n// output\ntrue\n```\n\n相关函数：[isLower](https://docs.dolphindb.cn/zh/funcs/i/isLower.html), [isUpper](https://docs.dolphindb.cn/zh/funcs/i/isUpper.html)\n"
    },
    "isUpper": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isUpper.html",
        "signatures": [
            {
                "full": "isUpper(X)",
                "name": "isUpper",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isUpper](https://docs.dolphindb.cn/zh/funcs/i/isUpper.html)\n\n\n\n#### 语法\n\nisUpper(X)\n\n#### 参数\n\n**X** 是字符或字符串类型的标量或向量。\n\n#### 详情\n\n判断字符串中的字母是否全部为大写。对于空字符串，该函数返回 false。\n\n#### 例子\n\n```\nisUpper(\"THIS IS STRING EXAMPLE....WOW!!!\");\n// output\ntrue\n\nisUpper(\"THIS is string example....wow!!!\");\n// output\nfalse\n\nisUpper(\"123456ABC\");\n// output\ntrue\n\nisUpper(\"123\");\n// output\nfalse\n\nisUpper([\"  \",string()]);\n// output\n[false,false]\n```\n\n相关函数：[isLower](https://docs.dolphindb.cn/zh/funcs/i/isLower.html), [isTitle](https://docs.dolphindb.cn/zh/funcs/i/isTitle.html)\n"
    },
    "isValid": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isValid.html",
        "signatures": [
            {
                "full": "isValid(X)",
                "name": "isValid",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isValid](https://docs.dolphindb.cn/zh/funcs/i/isValid.html)\n\n\n\n#### 语法\n\nisValid(X)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量或矩阵。\n\n#### 详情\n\n检查每个元素是否为有效数（非 NULL 值）。如果是，返回 true；否则返回 false。\n\n#### 例子\n\n```\nisValid(00i);\n// output\nfalse\n\nisValid(1 NULL NULL 6 NULL 7);\n// output\n[true,false,false,true,false,true]\n\nisValid(1/0);\n// output\nfalse\n```\n"
    },
    "isValley": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isValley.html",
        "signatures": [
            {
                "full": "isValley(X, [strict=true])",
                "name": "isValley",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[strict=true]",
                        "name": "strict",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [isValley](https://docs.dolphindb.cn/zh/funcs/i/isValley.html)\n\n\n\n#### 语法\n\nisValley(X, \\[strict=true])\n\n#### 参数\n\n**X** 数值型向量/矩阵/表。\n\n**strict** 布尔值，表示是否取严格的谷值点。默认值为 true。\n\n* 若 *strict* = true，相邻元素不为空且严格大于该元素\n* 若 *strict* = false，相邻元素不为空且大于等于该元素\n\n#### 详情\n\n若 *X* 为向量，计算 *X* 中的每个元素是否为谷值点，若是则返回 true，否则返回 false。\n\n若 *X* 为矩阵，在每列进行上述计算，返回值一个同 X 维度相同的矩阵。若 *X* 为表，则只对数值型的列进行上述计算。\n\n#### 例子\n\n```\nv = [3.1, 2.2, 2.2, 2.2, 1.3, 2.1, 1.2]\nisValley(v)\n// output\n[false,false,false,false,true,false,false]\n\nv = [3.1, 2.2, 2.2, 2.2, 2.6, 1, 1.2]\nisValley(v)\n// output\n[false,false,false,false,false,true,false]\nisValley(v, false)\n// output\n[false,true,true,true,false,true,false]\n\n// 矩阵在每列单独计算\nm = matrix(5.3 5.8 5.6 NULL 5.7 1.2, 4.5 3.5 4.6 2.8 3.9 NULL)\nisValley(m)\n```\n\n| #0    | #1    |\n| ----- | ----- |\n| false | false |\n| false | true  |\n| false | false |\n| false | true  |\n| false | false |\n| false | false |\n\n```\n// 表只在数值列进行计算\nt = table(`01`01`00`01`02`00 as id, 388.3 390.6 390.8 390.6 390.3 391.5 as price)\nisValley(t)\n```\n\n| id | price |\n| -- | ----- |\n| 01 | false |\n| 01 | false |\n| 00 | false |\n| 01 | false |\n| 02 | true  |\n| 00 | false |\n\n相关函数：[isPeak](https://docs.dolphindb.cn/zh/funcs/i/isPeak.html)\n"
    },
    "isVoid": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isVoid.html",
        "signatures": [
            {
                "full": "isVoid(X)",
                "name": "isVoid",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isVoid](https://docs.dolphindb.cn/zh/funcs/i/isVoid.html)\n\n\n\n#### 语法\n\nisVoid(X)\n\n#### 参数\n\n**X** 可以是系统支持的任意数据形式。\n\n#### 详情\n\n检查一个对象是否是 VOID 类型。有两种 VOID 类型的对象：一种是 NULL 对象；另一种是 Nothing 对象。参见 [isNothing](https://docs.dolphindb.cn/zh/funcs/i/isNothing.html)。\n\n#### 例子\n\n```\nisVoid(NULL);\n// output\ntrue\n\nisVoid(1 NULL 2);\n// output\nfalse\n\n# 和 isNull 相比\nisNull(1 NULL 2);\n// output\n[false,true,false]\n\nisVoid(matrix(NULL 2 NULL, NULL 2 1))\n// output\nfalse\n```\n"
    },
    "isYearEnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isYearEnd.html",
        "signatures": [
            {
                "full": "isYearEnd(X)",
                "name": "isYearEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isYearEnd](https://docs.dolphindb.cn/zh/funcs/i/isYearEnd.html)\n\n\n\n#### 语法\n\nisYearEnd(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n判断 *X* 是否为年末最后一天。\n\n#### 例子\n\n```\nisYearEnd(2012.12.31);\n// output\ntrue\n\nisYearEnd([2012.12.30,2012.12.31]);\n// output\n[false,true]\n```\n\n相关函数：[isYearStart](https://docs.dolphindb.cn/zh/funcs/i/isYearStart.html)\n"
    },
    "isYearStart": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/isYearStart.html",
        "signatures": [
            {
                "full": "isYearStart(X)",
                "name": "isYearStart",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [isYearStart](https://docs.dolphindb.cn/zh/funcs/i/isYearStart.html)\n\n\n\n#### 语法\n\nisYearStart(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n判断 *X* 是否为年初第一天。\n\n#### 例子\n\n```\nisYearStart(2012.01.01);\n// output\ntrue\n\nisYearStart([2012.01.01,2012.02.01]);\n// output\n[true,false]\n```\n\n相关函数：[isYearEnd](https://docs.dolphindb.cn/zh/funcs/i/isYearEnd.html)\n"
    },
    "iterate": {
        "url": "https://docs.dolphindb.cn/zh/funcs/i/iterate.html",
        "signatures": [
            {
                "full": "iterate(init, coeffs, input)",
                "name": "iterate",
                "parameters": [
                    {
                        "full": "init",
                        "name": "init"
                    },
                    {
                        "full": "coeffs",
                        "name": "coeffs"
                    },
                    {
                        "full": "input",
                        "name": "input"
                    }
                ]
            }
        ],
        "markdown": "### [iterate](https://docs.dolphindb.cn/zh/funcs/i/iterate.html)\n\n\n\n#### 语法\n\niterate(init, coeffs, input)\n\n#### 参数\n\n**init** 是初始值。\n\n**coeffs** 是迭代系数。*init* 和 *coeffs* 的长度必须相同。\n\n**input** 是整型标量，或者是向量。如果 *input* 是整型标量，表示迭代的次数；如果 *input* 是向量，其长度表示迭代的次数，每个元素在每次迭代后都添加到结果中。\n\n#### 详情\n\n* 若 *init*、*coeffs* 与 *input* 均为标量，返回等比数列\\[ *init* \\* *coeffs* , *init* \\* *coeffs* 2, *init* \\* *coeffs*3, ...]，其长度为 *input*。\n\n* 若 *init*、*coeffs* 为标量，*input* 为向量，返回数列x，满足以下条件：x\\[0]= *init* \\* *coeffs* + *input* \\[0]，x\\[n]=x\\[n-1]\\* *coeffs* + *input* \\[n]。数列x的长度为 *input* 的长度。\n\n* 若 *init*、*coeffs* 为向量，*input* 为标量，返回数列x，满足以下条件：x\\[n]=y(n)\\*\\* *coeffs* , y(n)=y(n-1)\\[1:].append!(x\\[n-1]), y(0)= *init*, x的长度为 *input* 。其中\\*\\*表示点乘，返回两个向量的内积。\n\n* 若 *init*、*coeffs* 与 *input* 均为向量，返回数列x，满足以下条件：x\\[n]=y(n)\\*\\* *coeffs* + *input* \\[n], y(n)=y(n-1)\\[1:].append!(x\\[n-1]), y(0)= *init*。其中\\*\\*表示点乘，返回两个向量的内积。\n\n#### 例子\n\n```\niterate(1, 0.8, 3);\n// output\n[0.8,0.64,0.512]\n// 1*0.8=0.8, 0.8*0.8=0.64, 0.64*0.8=0.512\n\niterate(1, 0.8, 0.1 0.2 0.3);\n// output\n[0.9,0.92,1.036]\n// 1*0.8+0.1=0.9, 0.9*0.8+0.2=0.92, 0.92*0.8+0.3=1.036\n\niterate(1 1, 1 1, 10);\n// output\n[2,3,5,8,13,21,34,55,89,144]\n// 斐波那契数列: 1*1+1*1=2; 1*1+2*1=3; 2*1+3*1=5; 3*1+5*1=8; ... ; 55*1+89*1=144.\n\niterate(1 1, 1 1, 1 2 3 4 5);\n// output\n[3,6,12,22,39]\n// 1*1+1*1+1=3; 1*1+3*1+2=6; 3*1+6*1+3=12; 6*1+12*1+4=22; 12*1+22*1+5=39.\n```\n"
    },
    "join!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/j/join!.html",
        "signatures": [
            {
                "full": "join!(X, Y)",
                "name": "join!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [join!](https://docs.dolphindb.cn/zh/funcs/j/join!.html)\n\n\n\n#### 语法\n\njoin!(X, Y)\n\n#### 参数\n\n**X** 可以是向量、元组、矩阵或表。\n\n**Y** 可以是标量、向量、元组、矩阵或表。\n\n如果 *X* 是向量或元组，*Y* 可以是标量、向量或元组。如果 *X* 是矩阵，*Y* 可以是向量或矩阵。如果 *X* 是表，*Y* 可以是向量或表。\n\n#### 详情\n\n把 *Y* 合并到 *X* 中，`join!` 函数会改变 *X* 的值。\n\n#### 例子\n\n如果 *X* 是向量，*Y* 可以是标量、向量或数据类型与 X 相同的元组。返回结果是长度更长的向量。\n\n```\nx=[1,2,3]\nx.join!(4)\nx;\n```\n\n输出返回：\\[1,2,3,4]\n\n```\nx.join!(5 6 7)\nx;\n```\n\n输出返回：\\[1,2,3,4,5,6,7]\n\n```\nx.join!((8,9))\nx;\n```\n\n输出返回：\\[1,2,3,4,5,6,7,8,9]\n\n如果 *X* 是元组，*Y* 可以是标量、向量或元组。返回结果是长度更长的元组。\n\n```\nx = (1,\"A\")\nx.join!(2)\nx;\n```\n\n返回：(1,\"A\",2)\n\n```\nx.join!([3,4,5])\nx;\n```\n\n返回：(1,\"A\",2,\\[3,4,5])\n\n如果配置项 appendTupleAsAWhole 设置为 true，运行以下脚本：\n\n```\nx.join!((\"B\",\"C\"))   // 配置参数 appendTupleAsAWhole=true 时\nx;\n```\n\n返回：(1,\"A\",2,\\[3,4,5],(\"B\",\"C\"))\n\n如果配置项 appendTupleAsAWhole 设置为 false，运行以上脚本后，返回：(1,\"A\",2,\\[3,4,5],\"B\",\"C\")\n\n如果 *X* 是矩阵，*Y* 可以是向量或者是与 *X* 行数相同的矩阵。返回结果是与 *X* 行数相同的矩阵。\n\n```\nx=1..6$2:3\njoin!(x, [7,8])\nx;\n```\n\n输出返回：\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  |\n| 2  | 4  | 6  | 8  |\n\n```\nx.join!(9..12$2:2)\nx;\n```\n\n输出返回：\n\n| #0 | #1 | #2 | #3 | #4 | #5 |\n| -- | -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  | 11 |\n| 2  | 4  | 6  | 8  | 10 | 12 |\n\n如果 *X* 是表，*Y* 必须是和 *X* 行数相同的表或向量。返回结果是与 *X* 行数相同的表。\n\n```\na=table(1..3 as x, 4.5 6.7 8.5 as y);\na;\n```\n\n输出返回：\n\n| x | y   |\n| - | --- |\n| 1 | 4.5 |\n| 2 | 6.7 |\n| 3 | 8.5 |\n\n```\nb=table(700 500 800 as z);\nb;\n```\n\n输出返回：\n\n| z   |\n| --- |\n| 700 |\n| 500 |\n| 800 |\n\n```\njoin!(a,b);\na;\n```\n\n输出返回：\n\n| x | y   | z   |\n| - | --- | --- |\n| 1 | 4.5 | 700 |\n| 2 | 6.7 | 500 |\n| 3 | 8.5 | 800 |\n\n```\na=table(1..3 as x, `IBM`C`AAPL as y);\nb=table(172.3 25 106.5 as z);\na.join!(b);\na;\n```\n\n输出返回：\n\n| x | y    | z     |\n| - | ---- | ----- |\n| 1 | IBM  | 172.3 |\n| 2 | C    | 25    |\n| 3 | AAPL | 106.5 |\n"
    },
    "join": {
        "url": "https://docs.dolphindb.cn/zh/funcs/j/join.html",
        "signatures": [
            {
                "full": "join(X,Y)",
                "name": "join",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [join](https://docs.dolphindb.cn/zh/funcs/j/join.html)\n\n\n\n#### 语法\n\njoin(X,Y) 或 X<-Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、向量、元组、矩阵或表。\n\n#### 详情\n\n合并 *X* 和 *Y*。\n\n#### 例子\n\n如果 *X* 是标量，*Y* 可以是标量或向量，结果是一个向量；*Y* 可以是元组，结果是一个元组\n\n```\n1 <- 3;\n// output\n[1,3]\n\n4<-1 2 3;\n// output\n[4,1,2,3]\n\n1 <- (2,\"A\")\n// 配置参数 appendTupleAsAWhole=true 时\n// output\n(1,(2,\"A\"))\n// 配置参数 appendTupleAsAWhole=false 时\n// output\n(1,2,\"A\")\n```\n\n如果 *X* 是向量，*Y* 可以是标量、向量或元素类型与 X 相同的元组。它将产生一个更长的向量。\n\n```\n[1,2,3] <- 4;\n// output\n[1,2,3,4]\n\n[1,2,3] <- [4,5,6];\n// output\n[1,2,3,4,5,6]\n```\n\n如果 X 是元组，Y可以是标量、向量或元组。它将产生一个更长的元组。\n\n```\nx = (1,\"A\")\ny = 2\nx <- y\n(1,\"A\",2)\n\ny = [2,3]\n(1,\"A\",[2,3])\n\ny = (2,\"B\")\n// 配置参数 appendTupleAsAWhole=true 时\n// output\n(1,\"A\",(2,\"B\"))\n// 配置参数 appendTupleAsAWhole=false 时\n// output\n(1,\"A\",2,\"B\")\n```\n\n如果 *X* 是矩阵，*Y* 必须是和 *X* 具有相同行数的向量或矩阵。结果是一个和 *X* 具有相同行数的矩阵。\n\n```\n1..6$2:3 <- [7,8];\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  |\n| 2  | 4  | 6  | 8  |\n\n```\n(1..6$2:3) <- (7..12$2:3);\n```\n\n| #0 | #1 | #2 | #3 | #4 | #5 |\n| -- | -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  | 11 |\n| 2  | 4  | 6  | 8  | 10 | 12 |\n\n如果 *X* 是一个表，*Y* 必须是一个和 *X* 具有相同行数的向量或表。结果是一个和 *X* 具有相同行数的表。\n\n```\na=table(1..3 as x, 4.5 6.7 8.5 as y);\na;\n```\n\n| x | y   |\n| - | --- |\n| 1 | 4.5 |\n| 2 | 6.7 |\n| 3 | 8.5 |\n\n```\nb=table(700 500 800 as z);\nb\n```\n\n| z   |\n| --- |\n| 700 |\n| 500 |\n| 800 |\n\n```\nc=join(a,b);\nc;\n```\n\n| x | y   | z   |\n| - | --- | --- |\n| 1 | 4.5 | 700 |\n| 2 | 6.7 | 500 |\n| 3 | 8.5 | 800 |\n\n```\na=table(1..3 as x, `IBM`C`AAPL as y);\nb=table(172.3 25 106.5 as z);\nc=a<-b;\nc\n```\n\n| x | y    | z     |\n| - | ---- | ----- |\n| 1 | IBM  | 172.3 |\n| 2 | C    | 25    |\n| 3 | AAPL | 106.5 |\n\n相关函数：[cj (cross\\_join)](https://docs.dolphindb.cn/zh/funcs/c/cj.html)\n"
    },
    "jsonExtract": {
        "url": "https://docs.dolphindb.cn/zh/funcs/j/jsonextract.html",
        "signatures": [
            {
                "full": "jsonExtract(json, location, type)",
                "name": "jsonExtract",
                "parameters": [
                    {
                        "full": "json",
                        "name": "json"
                    },
                    {
                        "full": "location",
                        "name": "location"
                    },
                    {
                        "full": "type",
                        "name": "type"
                    }
                ]
            }
        ],
        "markdown": "### [jsonExtract](https://docs.dolphindb.cn/zh/funcs/j/jsonextract.html)\n\n\n\n#### 语法\n\njsonExtract(json, location, type)\n\n#### 参数\n\n**json** LITERAL 类型标量或向量，表示符合标准 JSON 字符串。\n\n**location** 标量/向量/元组。每个元素可以是字符串或非零整数，用于指定相应维度的位置。\n\n* 如果为字符串，表示查询指定键对应的元素。\n\n* 如果为整数：表示查询该整数对应位置的元素。正整数表示从头开始查询，负整数表示从尾部开始查询。\n\n**type** 字符串标量，表示返回结果的类型，可选值为 \"long\", \"int\", \"double\", \"string\" 。\n\n#### 详情\n\n查询 JSON 对象中指定位置的数据，并按指定类型输出结果。\n\n**返回值：**\n\n* 当参数 *json*为标量时，返回标量结果；为向量时，返回向量结果。\n\n* 返回值类型由参数 *type* 指定。\n\n* 如果参数 *location* 指定的元素不存在，或无法解析为指定的类型，则返回空值 。\n\n#### 例子\n\n例1 基础用法\n\n```\nA = '{\"a\": \"hello\", \"b\": [-100, 200.5, 300], \"c\": { \"b\" : 2} }'\njsonExtract(A, [2, 1], \"int\") \n// output: -100\n\njsonExtract(A, 1, \"int\") \n// output: NULL\n\njsonExtract(A, 999, \"int\") \n// output: NULL\n\njsonExtract(A, [\"b\", 2], \"int\") \n// output: 200\n\njsonExtract(A, [\"c\", \"b\"], \"double\") \n// output: 2\n\nB = '{\"a\": \"hello\", \"b\": [200, 300]}'\njsonExtract([A, B], [\"c\", \"b\"], \"int\") \n// output: [2, NULL]\n\njsonExtract([A, B], [2, -1], \"int\") \n// output: [300, 300]\n```\n\n例2 查询表中 JSON 字符串里指定位置的数据。\n\n```\nA1 = '{\"a\": \"a1\",\"c\": { \"b\" : 2} }'\nA2 = '{\"a\": \"a2\", \"c\": { \"b\" : 3} }'\nB1 = '{\"a\": \"b1\",  \"c\": { \"b\" : 3} }'\nB2 = '{\"a\": \"b2\", \"c\": { \"b\" : 4} }'\nt1 = table([A1, A2] as json, [2,3] as val)\nt2 = table([B1, B2] as json, [3,4] as val)\n\nselect\n    jsonExtract(t1.json, \"a\", \"string\") as json1, \n    jsonExtract(t2.json, \"a\", \"string\") as json2 \nfrom t1 \njoin t2 on t1.val = t2.val\n```\n\n| json1 | json2 |\n| ----- | ----- |\n| a2    | b1    |\n"
    },
    "kama": {
        "url": "https://docs.dolphindb.cn/zh/funcs/k/kama.html",
        "signatures": [
            {
                "full": "kama(X, window)",
                "name": "kama",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [kama](https://docs.dolphindb.cn/zh/funcs/k/kama.html)\n\n\n\n#### 语法\n\nkama(X, window)\n\nTA-lib 系列函数参数说明和窗口计算规则请参考：[TA-lib 系列](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的考夫曼自适应移动平均值（Kaufman Adaptive Moving Average）。\n\n#### 例子\n\n```\nx=[51.65, 81.18, 43.37, 11.26, 82.79, 13.4, 81.87, 63.53, 21.28, 94.23]\nkama(x, 5);\n// output\n[,,,,,81.006144,81.009907,80.793626,80.344572,80.456788]\n\nt=table(take(`A`B,10) as sym, rand(100.0,10) as close)\nselect sym, kama(close, 3) as kama from t context by sym;\n```\n\n输出返回：\n\n| sym | kama      |\n| --- | --------- |\n| A   |           |\n| A   |           |\n| A   |           |\n| A   | 66.342572 |\n| A   | 62.500023 |\n| B   |           |\n| B   |           |\n| B   |           |\n| B   | 17.376469 |\n| B   | 42.27882  |\n"
    },
    "kendall": {
        "url": "https://docs.dolphindb.cn/zh/funcs/k/kendall.html",
        "signatures": [
            {
                "full": "kendall(X, Y)",
                "name": "kendall",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [kendall](https://docs.dolphindb.cn/zh/funcs/k/kendall.html)\n\n\n\n#### 语法\n\nkendall(X, Y)\n\n#### 参数\n\n**X** 一个标量/向量/矩阵/内存表。\n\n**Y** 一个标量/向量/矩阵/内存表。\n\n#### 详情\n\n计算 *X* 和 *Y* 的 Kendall 相关性系数。计算时忽略 NULL 值。\n\n若 *X* 或 *Y* 是矩阵，对每一列执行上述计算，返回一个向量。\n\n如果 *X* 或 *Y* 是内存表，则对表中的每个数值列执行上述计算，非数值列将返回空，结果为一个表。\n\n#### 例子\n\n```\nx = [33,21,46,-11,78,47,18,20,-5,66]\ny = [1,NULL,10,6,10,3,NULL,NULL,5,3]\nkendall(x, y)\n//output\n0.05\n```\n\n如果 *X* 是矩阵，*Y* 可以长度是与 *X* 行数相同的向量，或者是与 *X* 维度相同的矩阵。返回结果是长度与 *X* 列数相同的向量。\n\n```\nm=1..20$10:2\nkendall(m,x)\n//output\n[-0.0222,-0.0222]\n\nn=rand(20,20)$10:2\nkendall(m,n)\n//output\n[0.3865,-0.1591]\n```\n\n如果 *X* 是表，*Y* 可以是长度与 *X* 行数相同的向量，或者是维度与 *X* 相同的表。返回结果是与 *X* 列数相同的向量。\n\n```\nt=table(2..11 as id, \"a\"+string(2..11) as name)\nkendall(t,x)\n```\n\n| id      | name |\n| :------ | :--- |\n| -0.0222 |      |\n\n```\nt1=table(x as col1, y as col2)\nkendall(t,t1)\n```\n\n| id      | name |\n| :------ | :--- |\n| -0.0222 |      |\n"
    },
    "keyedStreamTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/k/keyedStreamTable.html",
        "signatures": [
            {
                "full": "keyedStreamTable(keyColumn, X, [X1], [X2], .....)",
                "name": "keyedStreamTable",
                "parameters": [
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "keyedStreamTable(keyColumn, capacity:size, colNames, colTypes)",
                "name": "keyedStreamTable",
                "parameters": [
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            }
        ],
        "markdown": "### [keyedStreamTable](https://docs.dolphindb.cn/zh/funcs/k/keyedStreamTable.html)\n\n\n\n#### 语法\n\nkeyedStreamTable(keyColumn, X, \\[X1], \\[X2], .....)\n\n或\n\nkeyedStreamTable(keyColumn, capacity:size, colNames, colTypes)\n\n#### 参数\n\n**keyColumn** 是一个字符串或向量，表示主键。主键的数据类型必须属于以下类别：INTEGRAL, TEMPORAL, LITERAL 或 FLOATING。\n\n第一种用法中： *X*, *X1*....是向量。\n\n第二种用法中：\n\n**capacity** 是正整数，表示建表时系统为该表分配的内存（以记录数为单位）。当记录数超过 *capacity* 时，系统会首先会分配 *capacity* 1.2\\~2 倍的新的内存空间，然后复制数据到新的内存空间，最后释放原来的内存。对于规模较大的表，此类操作的内存占用会很高。因此，建议建表时预先分配一个合理的 *capacity*。\n\n**size** 只能是0或1。若 size=0，则建立一个空表；若 size=1，则建立一个只包含1条记录的表，记录初始值如下：\n\n* BOOL 类型默认值为 false；\n\n* 数值类型、时间类型、IPADDR、COMPLEX、POINT 的默认值为 0；\n\n* Literal, INT128 类型的默认值为 NULL。\n\n**colNames** 是字符串向量，表示列名。\n\n**colTypes** 是向量，表示各列的数据类型。自 2.00.11.2 版本起，允许主键外的其它列指定为数组向量类型。\n\n#### 详情\n\n创建键值流数据表。该表的主键不允许包含重复值。主键支持一个或多个字段。\n\n实际应用中，可能由于网络原因，会出现数据重复提交写入的情况；或者在上游采用了多路高可用的方式写入数据。面对上述场景，键值流数据表可以实现流数据的幂等性写入，即多次写入键值相同的数据，其结果与第一次写入的结果相同，从而避免数据重复写入。\n\n需要注意的是，此处的键值唯一性并非全局唯一，而是指内存中数据的唯一性。为流数据表开启持久化，可以设置内存中保留的数据条数，一旦数据条数超过设定的上限，系统将一半旧的数据持久化至磁盘。这种方案确保了内存中数据键值的唯一性，而不是全局唯一性。尽管如此，已足以解决多路写入或网络延迟导致的重复提交写入的问题。\n\n向表中添加新记录时，系统会自动检查新记录的主键值：\n\n* 如果新记录的主键值与内存中已有记录的主键值重复时，已有的记录不会被更新。\n\n* 一次性批量插入新记录时，若有多条记录具有相同的主键值，且该主键值与已有记录的主键值不同，只有第一条记录能成功插入。\n\n#### 例子\n\n第一种用法：\n\n```\nid=`A`B`C`D`E\nx=1 2 3 4 5\nt1=keyedStreamTable(`id, id, x)\nt1;\n```\n\n| id | x |\n| -- | - |\n| A  | 1 |\n| B  | 2 |\n| C  | 3 |\n| D  | 4 |\n| E  | 5 |\n\n第二种用法：\n\n```\nt2=keyedStreamTable(`id,100:0,`id`x, [INT,INT])\ninsert into t2 values(1 2 3,10 20 30);\nt2;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 10 |\n| 2  | 20 |\n| 3  | 30 |\n\n往表 t2 中插入重复主键值的数据：\n\n```\ninsert into t2 values(3 4 5,35 45 55)\nt2;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 10 |\n| 2  | 20 |\n| 3  | 30 |\n| 4  | 45 |\n| 5  | 55 |\n\n可以看到，id=3 的记录并没有被覆盖。\n\n主键为多个字段：\n\n```\nt=keyedStreamTable(`sym`id,1:0,`sym`id`val,[SYMBOL,INT,DOUBLE])\ninsert into t values(`A`B`C`D`E,5 4 3 2 1,52.1 64.2 25.5 48.8 71.9);\ninsert into t values(`A`B`R`T`Y,5 8 3 2 1,152.3 164.6 125.5 148.8 171.6);\nt;\n```\n\n| sym | id | val   |\n| --- | -- | ----- |\n| A   | 5  | 52.1  |\n| B   | 4  | 64.2  |\n| C   | 3  | 25.5  |\n| D   | 2  | 48.8  |\n| E   | 1  | 71.9  |\n| B   | 8  | 164.6 |\n| R   | 3  | 125.5 |\n| T   | 2  | 148.8 |\n| Y   | 1  | 171.6 |\n"
    },
    "keyedTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/k/keyedTable.html",
        "signatures": [
            {
                "full": "keyedTable(keyColumns, X, [X1], [X2], .....)",
                "name": "keyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "keyedTable(keyColumns, capacity:size, colNames, colTypes)",
                "name": "keyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            },
            {
                "full": "keyedTable(keyColumns, table)",
                "name": "keyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [keyedTable](https://docs.dolphindb.cn/zh/funcs/k/keyedTable.html)\n\n\n\n#### 语法\n\nkeyedTable(keyColumns, X, \\[X1], \\[X2], .....)\n\n或\n\nkeyedTable(keyColumns, capacity:size, colNames, colTypes)\n\n或\n\nkeyedTable(keyColumns, table)\n\n#### 参数\n\n**keyColumns** 是一个字符串标量或向量，表示主键。主键的数据类型必须属于以下类别： INTEGRAL, TEMPORAL 或 LITERAL。\n\n第一种用法中，*X*, *X1*....是向量。\n\n第二种用法中，\n\n**capacity** 是正整数，表示建表时系统为该表分配的内存（以记录数为单位）。当记录数超过 *capacity* 时，系统会首先会分配 *capacity* 1.2\\~2倍的新的内存空间，然后复制数据到新的内存空间，最后释放原来的内存。对于规模较大的表，此类操作的内存占用会很高。因此，建议建表时预先分配一个合理的 *capacity*。\n\n**size** 只能是0或1。当数据列是 array vector 时，size 只能是0；当数据列是其它类型时，size 可以是0或1。\n\n* 若 *size*=0，则建立一个空表；\n* 若 *size*=1，则建立一个只包含1条记录的表，记录初始值如下：\n  * BOOL 类型默认值为 false；\n  * 数值类型、时间类型、IPADDR、COMPLEX、POINT 的默认值为 0；\n  * Literal, INT128 类型的默认值为 NULL。\n\n**colNames** 是字符串向量，表示列名。\n\n**colTypes** 是向量，表示各列的数据类型。\n\n第三种用法中，`table` 是一个表。注意，*table* 中的 *keyColumns* 不能包含重复值。\n\n#### 详情\n\n创建键值内存表。一个键值内存表有一个主键。主键可由一个或多个字段组成。键值内存表基于哈希表实现，将主键字段的组合值存成一个键值，每个键值对应表中的一行数据。在查询时，指定主键的所有字段，便可通过键值定位数据，而无需进行全表扫描。\n\n向表中添加新记录时，系统会自动检查新记录的主键值，如果新记录的主键值与已有记录的主键值重复时，系统会更新表中对应的记录，否则向表中添加记录。\n\n键值表对单行的更新和查询效率很高，是数据缓存的理想选择。键值表也可作为时间序列聚合引擎的输出表，用于实时更新输出表的结果。\n\n关于对键值内存表和[索引内存表](https://docs.dolphindb.cn/zh/funcs/i/indexedTable.html)使用怎样的查询语句以及如何进行查询优化，详见下表：\n\n<table id=\"table_fwd_3lx_dcc\"><thead><tr><th>\n\n</th><th>\n\nkeyedTable\n\n</th><th>\n\nindexedTable\n\n</th></tr></thead><tbody><tr><td>\n\n查询优化\n\n</td><td>\n\n* 查询语句必须包含 *keyColumns* 所有列。\n\n* 过滤条件中只能使用 =, in 或 and，且对不同列使用 in 的次数不超过2次；\n\n* 建议调用 [sliceByKey](https://docs.dolphindb.cn/zh/funcs/s/sliceByKey.dita) 以提高性能。\n\n</td><td>\n\n* 查询语句必须包含 *keyColumns* 的第 1 列，且该列过滤条件中只能使用 =, in 或 and；\n\n* 除 keyColumns 的第 1 列外，其它列可以通过 between、比较运算符等进行范围查询，且查询效率高于使用 in 谓词。\n\n* 所有过滤条件中，对不同列使用的 in 的次数不超过2次；\n\n* 建议调用 [sliceByKey](https://docs.dolphindb.cn/zh/funcs/s/sliceByKey.dita) 以提高性能。\n\n</td></tr><tr><td>\n\n查询语句特点\n\n</td><td>\n\n包含 keyColumns 的所有列。此时查询性能优于 indexedTable。\n\n</td><td>\n\n只需要包含 *keyColumns* 的第 1 列，而无需包含所有列。\n\n</td></tr></tbody>\n</table>## 例子\n\n例1. 创建键值表\n\n第一种写法：\n\n```\nsym=`A`B`C`D`E\nid=5 4 3 2 1\nval=52 64 25 48 71\nt=keyedTable(`sym`id,sym,id,val)\nt;\n```\n\n| sym | id | val |\n| --- | -- | --- |\n| A   | 5  | 52  |\n| B   | 4  | 64  |\n| C   | 3  | 25  |\n| D   | 2  | 48  |\n| E   | 1  | 71  |\n\n第二种写法：\n\n```\nt=keyedTable(`sym`id,1:0,`sym`id`val,[SYMBOL,INT,INT])\ninsert into t values(`A`B`C`D`E,5 4 3 2 1,52 64 25 48 71);\n```\n\n第三种写法：\n\n```\ntmp=table(sym, id, val)\nt=keyedTable(`sym`id, tmp);\n```\n\n创建键值内存分区表：\n\n```\nsym=`A`B`C`D`E\nid=5 4 3 2 1\nval=52 64 25 48 71\nt=keyedTable(`sym`id,sym,id,val)\ndb=database(\"\",VALUE,sym)\npt=db.createPartitionedTable(t,`pt,`sym).append!(t);\n```\n\n例2. 更新键值表\n\n```\nt=keyedTable(`sym,1:0,`sym`datetime`price`qty,[SYMBOL,DATETIME,DOUBLE,DOUBLE])\ninsert into t values(`APPL`IBM`GOOG,2018.06.08T12:30:00 2018.06.08T12:30:00 2018.06.08T12:30:00,50.3 45.6 58.0,5200 4800 7800)\nt;\n```\n\n| sym  | datetime            | price | qty  |\n| ---- | ------------------- | ----- | ---- |\n| APPL | 2018.06.08T12:30:00 | 50.3  | 5200 |\n| IBM  | 2018.06.08T12:30:00 | 45.6  | 4800 |\n| GOOG | 2018.06.08T12:30:00 | 58    | 7800 |\n\n插入新记录，并且新记录中的主键值与表中主键值重复：\n\n```\ninsert into t values(`APPL`IBM`GOOG,2018.06.08T12:30:01 2018.06.08T12:30:01 2018.06.08T12:30:01,65.8 45.2 78.6,5800 8700 4600)\nt;\n```\n\n| sym  | datetime            | price | qty  |\n| ---- | ------------------- | ----- | ---- |\n| APPL | 2018.06.08T12:30:01 | 65.8  | 5800 |\n| IBM  | 2018.06.08T12:30:01 | 45.2  | 8700 |\n| GOOG | 2018.06.08T12:30:01 | 78.6  | 4600 |\n\n插入新记录，并且新记录中的主键值重复：\n\n```\ninsert into t values(`MSFT`MSFT,2018.06.08T12:30:01 2018.06.08T12:30:01,45.7 56.9,3600 4500)\nt;\n```\n\n| sym  | datetime            | price | qty  |\n| ---- | ------------------- | ----- | ---- |\n| APPL | 2018.06.08T12:30:01 | 65.8  | 5800 |\n| IBM  | 2018.06.08T12:30:01 | 45.2  | 8700 |\n| GOOG | 2018.06.08T12:30:01 | 78.6  | 4600 |\n| MSFT | 2018.06.08T12:30:01 | 56.9  | 4500 |\n\n主键不允许更新：\n\n```\nupdate t set sym=\"C_\"+sym;\n// output: Can't update a key column.\n```\n\n例3. 查询键值内存表\n\n当过滤条件不使用 or，包含所有 *keyColumns*，并且每个条件都使用了等值谓词(=)或 in 谓词，且 in 谓词数量不超过两个时，键值内存表的查询性能优于普通内存表。\n\n以下例子将比较键值内存表和普通内存表的查询性能。首先，分别创建包含100万条记录的普通内存表 t 和键值内存表 kt。\n\n```\nid=shuffle(1..1000000)\ndate=take(2012.06.01..2012.06.10, 1000000)\ntype=rand(9, 1000000)\nval=rand(100.0, 1000000)\nt=table(id, date, type, val)\nkt=keyedTable(`id`date`type, id, date, type, val);\n```\n\n例3.1\n\n```\ntimer(100) select * from t where id=500000, date=2012.06.01, type=0;\n// output: Time elapsed: 161.574 ms\n\ntimer(100) select * from kt where id=500000, date=2012.06.01, type=0;\n// output: Time elapsed: 1.483 ms\n\ntimer(100) sliceByKey(t1, (500000, 2012.06.01, 0))\n// output: Time elapsed: 0.705 ms\n```\n\n例3.2\n\n```\ntimer(100) select * from t where id in [1, 500000], date in 2012.06.01..2012.06.05, type=5;\n// output: Time elapsed: 894.241 ms\n\ntimer(100) select * from kt where id in [1, 500000], date in 2012.06.01..2012.06.05, type=5;\n// output: Time elapsed: 2.322 ms\n```\n\nin 谓词数量超过两个时，键值内存表不会进行查询优化：\n\n例3.3\n\n```\ntimer(100) select * from t where id in [1, 500000], date in 2012.06.01..2012.06.05, type in 1..5;\n// output: Time elapsed: 801.347 ms\n\ntimer(100) select * from kt where id in [1, 500000], date in 2012.06.01..2012.06.05, type in 1..5;\n// output: Time elapsed: 834.184 ms\n```\n\n若过滤条件没有包括所有 *keyColumns*，键值内存表亦不会进行查询优化：\n\n例3.4\n\n```\ntimer(100) select * from t where id=500000, date in 2012.06.01..2012.06.05;\n// output: Time elapsed: 177.113 ms\n\ntimer(100) select * from kt where id=500000, date in 2012.06.01..2012.06.05;\n// output: Time elapsed: 163.265 ms\n```\n\n例4. 使用 `keyedTable` 保留每只股票卖方委托的最新五档报价。\n\n```\nsym=[\"a\",\"b\",\"c \"] \ntime=22:58:52.827 22:58:53.627 22:58:53.827 \nvolume=array(INT[]).append!([[100,110,120,115,125],[200,230,220,225,230],[320,300,310,315,310]])\nprice=array(DOUBLE[]).append!([[10.5,10.6,10.7,10.77,10.85],[8.6,8.7,8.76,8.83,8.9],[6.3,6.37,6.42,6.48,6.52]])\nt=keyedTable(`sym,sym,time,volume,price)\nt\n```\n\n<table id=\"table_lr3_2wt_x1c\"><thead><tr><th>\n\nsym\n\n</th><th>\n\ntime\n\n</th><th>\n\nvolume\n\n</th><th>\n\nprice\n\n</th></tr></thead><tbody><tr><td>\n\na\n\n</td><td>\n\n22:58:52.827\n\n</td><td>\n\n\\[100, 110, 120, 115, 125]\n\n</td><td>\n\n\\[10.5, 10.6, 10.7, 10.77, 10.85]\n\n</td></tr><tr><td>\n\nb\n\n</td><td>\n\n22:58:53.627\n\n</td><td>\n\n\\[200, 230, 220, 225, 230]\n\n</td><td>\n\n\\[8.6, 8.7, 8.76, 8.83, 8.9]\n\n</td></tr><tr><td>\n\nc\n\n</td><td>\n\n22:58:53.827\n\n</td><td>\n\n\\[320, 300, 310, 315, 310]\n\n</td><td>\n\n\\[6.3, 6.37, 6.42, 6.48, 6.52]\n\n</td></tr></tbody>\n</table>```\n//最新的报价数量和价格\nnewVolume=array(INT[]).append!([[130,110,110,115,120]])\nnewPrice= array(DOUBLE[]).append!([[10.55,10.57,10.62,10.68,10.5]])\n//更新名为 a 的股票的最新报价\nupdate t set volume=newVolume, price=newPrice where sym=\"a\"\nt\n```\n\n<table id=\"table_qr3_2wt_x1c\"><thead><tr><th>\n\nsym\n\n</th><th>\n\ntime\n\n</th><th>\n\nvolume\n\n</th><th>\n\nprice\n\n</th></tr></thead><tbody><tr><td>\n\na\n\n</td><td>\n\n22:58:52.827\n\n</td><td>\n\n\\[130, 110, 110, 115, 120]\n\n</td><td>\n\n\\[10.55, 10.57, 10.62, 10.68, 10.5]\n\n</td></tr><tr><td>\n\nb\n\n</td><td>\n\n22:58:53.627\n\n</td><td>\n\n\\[200, 230, 220, 225, 230]\n\n</td><td>\n\n\\[8.6, 8.7, 8.76, 8.83, 8.9]\n\n</td></tr><tr><td>\n\nc\n\n</td><td>\n\n22:58:53.827\n\n</td><td>\n\n\\[320, 300, 310, 315, 310]\n\n</td><td>\n\n\\[6.3, 6.37, 6.42, 6.48, 6.52]\n\n</td></tr></tbody>\n</table>需要注意的是，更新 array vector 列的数据时，新记录中各行向量的元素个数必须和原记录中对应行向量的元素个数相同，否则会出现报错。如下例，新记录向量中有4个元素，而已有记录对应行的向量中有5个元素，数量不相同，出现报错：\n\n```\nnewVolume=array(INT[]).append!([[130,110,110,120]])\nnewPrice= array(DOUBLE[]).append!([[10.55,10.57,10.62,10.5]])\n\nupdate t set volume=newVolume, price=newPrice where sym=\"a\"\n// error: Failed to update column: volume\n```\n\n相关函数：[indexedTable](https://docs.dolphindb.cn/zh/funcs/i/indexedTable.html)\n"
    },
    "keys": {
        "url": "https://docs.dolphindb.cn/zh/funcs/k/keys.html",
        "signatures": [
            {
                "full": "keys(X)",
                "name": "keys",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [keys](https://docs.dolphindb.cn/zh/funcs/k/keys.html)\n\n\n\n#### 语法\n\nkeys(X)\n\n#### 参数\n\n**X** 是一个字典、数据表，或集合。\n\n#### 详情\n\n返回一个字典中的所有键作为一个向量，或一个数据表中的列名作为一个向量，或将一个集合转化为一个向量。\n\n#### 例子\n\n```\nz=dict(INT,DOUBLE)\nz[5]=7.9\nz[3]=6\nz.keys();\n// output\n[3,5]\n\nt = table(1 2 3 as id, 4 5 6 as x, `IBM`MSFT`GOOG as name);\nkeys(t);\n// output\n[\"id\",\"x\",\"name\"]\n\na=set(1 2 4)\na.keys();\n// output\n[4,2,1]\n```\n\n相关函数：[values](https://docs.dolphindb.cn/zh/funcs/v/values.html)\n"
    },
    "kmeans": {
        "url": "https://docs.dolphindb.cn/zh/funcs/k/kmeans.html",
        "signatures": [
            {
                "full": "kmeans(X, k, [maxIter=300], [randomSeed], [init='random'])",
                "name": "kmeans",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "k",
                        "name": "k"
                    },
                    {
                        "full": "[maxIter=300]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "300"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    },
                    {
                        "full": "[init='random']",
                        "name": "init",
                        "optional": true,
                        "default": "'random'"
                    }
                ]
            }
        ],
        "markdown": "### [kmeans](https://docs.dolphindb.cn/zh/funcs/k/kmeans.html)\n\n\n\n#### 语法\n\nkmeans(X, k, \\[maxIter=300], \\[randomSeed], \\[init='random'])\n\n#### 参数\n\n**X** 是一个表，表示训练集。\n\n**k** 是一个正整数，表示要生成的聚类数。\n\n**maxIter** 是一个正整数，表示质心更新的最大迭代次数。默认值是300。\n\n**randomSeed** 是一个整数，表示质心初始化时随机算法的种子。默认值为 NULL。\n\n**init** 可以是一个字符串或者一个矩阵，表示初始值的选择方式。默认值是 'random'。\n\n* 若 *init* 是一个字符串，则可选参数为 'random' 或 'k-means++'。'random' 表示根据 *randomSeed* 随机生成，'kmeans++' 表示根据 kmeans++ 算法生成。\n\n* 若 *init* 是一个矩阵，表示自定义的质心。其列数与表 *X* 需保持一致，行数为 *k*。\n\n#### 详情\n\n对训练集执行 K-Means 聚类。返回的结果是一个字典，包含以下 key：\n\n* centers：一个 *k* 行 m 列的矩阵（m 是 *X* 的列数），包含各个类的质心坐标。\n\n* predict：一个聚类模型预测函数，数据类型是 FUNCTIONDEF。\n\n* modelName：字符串 'KMeans'。\n\n* model：保存的模型，数据类型为 RESOURCE，用于预测。\n\n* labels：一个向量，表示 *X* 中每一行数据对应的聚类的类标签。\n\n#### 例子\n\n使用模拟数据训练一个 K-Means 模型：\n\n```\nt = table(100:0, `x0`x1, [DOUBLE, DOUBLE])\nx0 = norm(1.0, 1.0, 50)\nx1 = norm(1.0, 1.5, 50)\ninsert into t values (x0, x1)\nx0 = norm(2.0, 1.0, 50)\nx1 = norm(-1.0, 1.5, 50)\ninsert into t values (x0, x1)\nx0 = norm(-1.0, 1.0, 50)\nx1 = norm(-3.0, 1.5, 50)\ninsert into t values (x0, x1);\n\nmodel = kmeans(t, 3);\nmodel;\n\n// output\ncenters->\n\n#0        #1\n--------- ---------\n-1.048027 -3.809539\n1.110899  1.24216\n1.677974  -1.19158\n\npredict->kmeansPredict\nmodelName->KMeans\nmodel->KMeans\nlabels->[2,2,2,2,2,2,3,2,3,2,...]\n```\n"
    },
    "knn": {
        "url": "https://docs.dolphindb.cn/zh/funcs/k/knn.html",
        "signatures": [
            {
                "full": "knn(Y, X, type, nNeighbor, [power=2])",
                "name": "knn",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "type",
                        "name": "type"
                    },
                    {
                        "full": "nNeighbor",
                        "name": "nNeighbor"
                    },
                    {
                        "full": "[power=2]",
                        "name": "power",
                        "optional": true,
                        "default": "2"
                    }
                ]
            }
        ],
        "markdown": "### [knn](https://docs.dolphindb.cn/zh/funcs/k/knn.html)\n\n\n\n#### 语法\n\nknn(Y, X, type, nNeighbor, \\[power=2])\n\n#### 参数\n\n**Y** 是一个长度与X的行数相等的向量，表示X中每个样本对应的标签。\n\n**X** 是一张表，表示训练集。表中的每一行表示一个样本，每一列表示一个特征。\n\n**type** 是一个字符串。它的取值可以是 'regressor' 或 'classifier'。\n\n**nNeighbor** 是一个正整数，表示 K 邻近算法的邻近节点个数。\n\n**power** 是一个正整数，表示闵可夫斯基距离（Minkowski Distance）的参数。默认值是2，表示使用欧几里得距离（Euclidean Distance）。如果 *power*=1，表示使用曼哈顿距离（Manhattan Distance）。\n\n#### 详情\n\n通过 K 邻近算法（暴力搜索法）对表中的数据进行训练。返回的结果是一个字典，包含以下 key：\n\n* nNeighbor：训练时所用的邻近节点个数\n\n* modelName：模型的名称，为字符串 \"KNN\"\n\n* model：内部模型\n\n* power：训练时所用的闵可夫斯基距离\n\n* type：字符串 \"regressor\" 或 \"classifier\"\n\n#### 例子\n\n```\nheight = 158 158 158 160 160 163 163 160 163 165 165 165 168 168 168 170 170 170\nweight = 58 59 63 59 60 60 61 64 64 61 62 65 62 63 66 63 64 68\nt=table(height, weight)\nlabels=take(1,7) join take(2,11)\nmodel = knn(labels,t,\"classifier\", 5);\n```\n"
    },
    "kroghInterpolate": {
        "url": "https://docs.dolphindb.cn/zh/funcs/k/kroghinterpolate.html",
        "signatures": [
            {
                "full": "kroghInterpolate(X, Y, newX, [der=0])",
                "name": "kroghInterpolate",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "newX",
                        "name": "newX"
                    },
                    {
                        "full": "[der=0]",
                        "name": "der",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [kroghInterpolate](https://docs.dolphindb.cn/zh/funcs/k/kroghinterpolate.html)\n\n\n\n#### 语法\n\nkroghInterpolate(X, Y, newX, \\[der=0])\n\n#### 参数\n\n**X** 数值向量，表示用于插值的点的 x 坐标。必须是递增序列，不能包含 NULL 值。\n\n**Y** 数值向量，与 *Xi* 等长，表示用于插值的点的 y 坐标。不能包含 NULL 值。\n\n**newX** 数值向量，表示需要求值的点的 x 坐标。不能包含 NULL 值。\n\n**der** 可选参数，非负整数，表示返回值的导数阶数。默认值为 0，表示计算多项式函数本身的值。\n\n#### 详情\n\n对一组点集进行多项式插值，该多项式通过点集中所有的数据点对 (x, y)。返回在 X 点处指定导数阶数的多项式估值。\n\n可以额外指定在每个点 x 处的多个导数值：用户通过重复 xi 值并将导数值指定为连续的 yi 值来实现。\n\n* 当 x 是唯一值时，y 为多项式 f(x) 的值。\n\n* 当 x 出现相同值时，则第一个 y 是 f(x) 的值，第二个为对应的 x 的一阶导数值，第三个为对应的 x 的二阶导数值，依此类推。比如对于输入X = \\[0,0,1,1]，Yi= \\[1,0,2,3]，有 Y\\[0]=f(0)，Y\\[1]=f'(0)，Y\\[2]=f(1)，Y\\[3]=f'(1)。\n\n#### 例子\n\n以正弦函数为例进行多项式插值，分别计算 xx 点处的多项式估值和其一阶导数值。\n\n```\ndef linspace(start, end, num, endpoint=true){\n\tif(endpoint) return end$DOUBLE\\(num-1), start + end$DOUBLE\\(num-1)*0..(num-1)\n\telse return start + end$DOUBLE\\(num-1)*0..(num-1)\t\n}\n\nx = 0 1 2 3 4 5\ny = sin(x)\nxx = linspace(0.0, 5.0, 10)[1]\nyy=kroghInterpolate(x,y,xx)\nyy;\n\nyy1=kroghInterpolate(x,y,xx,1)\nyy1;\n```\n\nyy 返回值：\n\n\\[0,0.515119011157387,0.898231239576709,0.998548648650381,0.793484053410063,0.354287125066207,-0.188319604452395,-0.678504737959061,-0.969692008469677,-0.958924274663139]\n\nyy1 返回值：\n\n\\[0.885486080979582,0.875967413938641,0.459031117252456,-0.103633680213926,-0.612193041424271,-0.92866822117116,-0.976935666075988,-0.742727014588963,-0.273629096989106,0.320916064615744]\n"
    },
    "kroghInterpolateFit": {
        "url": "https://docs.dolphindb.cn/zh/funcs/k/kroghinterpolatefit.html",
        "signatures": [
            {
                "full": "kroghInterpolateFit(X, Y, [der=0])",
                "name": "kroghInterpolateFit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[der=0]",
                        "name": "der",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [kroghInterpolateFit](https://docs.dolphindb.cn/zh/funcs/k/kroghinterpolatefit.html)\n\n\n\n#### 语法\n\nkroghInterpolateFit(X, Y, \\[der=0])\n\n#### 详情\n\n对一组点集进行多项式插值，该多项式通过点集中所有的点对 (X, Y)。并且可以额外指定在每个点 X 处的多个导数值：用户通过重复 X 值并将导数值指定为连续的 Y 值来实现：\n\n* 当 X 只出现一次时，Y 为多项式 f(x) 的值。\n\n* 当 X 出现多次时，则第一个 Y 是 f(X) 的值，第二个为对应的 X 的一阶导数值，第三个为对应的 X 的二阶导数值，依此类推。比如对于输入 X = \\[0,0,1,1], Y= \\[1,0,2,3], 有 Y\\[0]=f(0)，Y\\[1]=f'(0)，Y\\[2]=f(1)，Y\\[3]=f'(1)。\n\n另外，本函数可结合 [predict](https://docs.dolphindb.cn/zh/funcs/p/predict.html) 函数先后使用，针对生成的模型进行预测。\n\n#### 参数\n\n**X** 数值向量，表示用于插值的点的 x 坐标，必须是递增序列。注意：X 中不可包含 NULL 值。\n\n**Y** 数值向量，表示用于插值的点的 y 坐标。注意：Y 和 X 的长度必须一致，且 Y 中不可包含 NULL 值。\n\n**der** 可选参数，非负整数，表示要求的导数阶数。*der*=0 时计算多项式函数本身的值。其默认值为 0。\n\n#### 返回值\n\n返回一个字典，字典有以下成员：\n\n* modelName：字符串类型，表示模型名称，值为“kroghInterpolate”。\n\n* X：数值向量，表示用于插值的点的x坐标，即输入 X。\n\n* der：非负整数，即输入 der。\n\n* coeffs：数值向量，表示根据输入数据点拟合得到的多项式系数。\n\n* predict：模型的预测函数。其使用方法为 `model.predict(X)`，或者通过 [predict](https://docs.dolphindb.cn/zh/funcs/p/predict.html?hl=) 函数进行调用：`predict(model, X)`。其参数为：\n\n  * model：字典类型，即 kroghInterpolateFit 的输出。\n\n  * X： 数值向量，表示需要求值的点的 x 坐标，`predict` 函数将返回在 X 点处的多项式估值。\n\n#### 例子\n\n以正弦函数为例进行多项式插值，计算 x 点处的多项式估值。\n\n```\nx = 0 1 2 3 4 5\ny = sin(x)\nmodel = kroghInterpolateFit(x,y)\nmodel\n\n/*\noutput:\nX->[0,1,2,3,4,5]\nder->0\npredict->kroghInterpolateFitPredict\nmodelName->kroghInterpolate\ncoeffs->[0.0,0.841470984807,-0.386822271395,-0.010393219665,0.032025753923,-0.005411092181,0.0]\n*/\n```\n\n根据生成的模型，自定义函数 `linspace`，并传入相关参数，进一步预测模型。\n\n```\ndef linspace(start, end, num, endpoint=true){\n\tif(endpoint) return end$DOUBLE\\(num-1), start + end$DOUBLE\\(num-1)*0..(num-1)\n\telse return start + end$DOUBLE\\(num-1)*0..(num-1)\t\n}\nxx = linspace(0.0, 5.0, 10)[1]\nmodel.predict(xx)\n\n/*\noutput:\n[0,0.515119011157387,0.898231239576709,0.998548648650381,0.793484053410063,0.354287125066207,-0.188319604452395,-0.678504737959061,-0.969692008469677,-0.958924274663139]\n*/\n```\n\n相关函数：[predict,](https://docs.dolphindb.cn/zh/funcs/p/predict.html) [kroghinterpolate](https://docs.dolphindb.cn/zh/funcs/k/kroghinterpolate.html)\n"
    },
    "ksTest": {
        "url": "https://docs.dolphindb.cn/zh/funcs/k/ksTest.html",
        "signatures": [
            {
                "full": "ksTest(X, Y)",
                "name": "ksTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ksTest](https://docs.dolphindb.cn/zh/funcs/k/ksTest.html)\n\n\n\n#### 语法\n\nksTest(X, Y)\n\n#### 参数\n\n**X** 是一个数值向量。\n\n**Y** 是一个数值向量。\n\n#### 详情\n\n对 *X* 和 *Y* 进行 Kolmogorov-Smirnov 检验，检验它们是否符合同一个分布。返回的结果是一个字典，包含以下 key：\n\n* ksValue：Kolmogorov-Smirnov 统计量\n\n* pValue：p 值\n\n* D：D 统计量\n\n* method：字符串 \"Two-sample Kolmogorov-Smirnov test\"\n\n#### 例子\n\n```\nx = norm(0.0, 1.0, 50)\ny = norm(0.0, 1.0, 20)\nksTest(x, y);\n\n// output\nksValue->0.739301\npValue->0.645199\nD->0.19\nmethod->Two-sample Kolmogorov-Smirnov test\n```\n"
    },
    "kurtosis": {
        "url": "https://docs.dolphindb.cn/zh/funcs/k/kurtosis.html",
        "signatures": [
            {
                "full": "kurtosis(X, [biased=true])",
                "name": "kurtosis",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [kurtosis](https://docs.dolphindb.cn/zh/funcs/k/kurtosis.html)\n\n\n\n#### 语法\n\nkurtosis(X, \\[biased=true])\n\n#### 参数\n\n**X** 是一个向量、矩阵或表。\n\n**biased** 是一个布尔值，表示是否为有偏估计。默认值为 true，表示为有偏估计。\n\n#### 详情\n\n计算 *X* 的峰度。`kurtosis` 函数在计算时会忽略 NULL 值。\n\n* 若 *biased*=true，表示结果为有偏估计，计算公式为：\n\n![k1](https://docs.dolphindb.cn/zh/images/k1.png)\n\n* 若 *biased*=false，表示结果为无偏估计，计算公式为：\n\n![k0](https://docs.dolphindb.cn/zh/images/k0.png)\n\n* 若 *X* 为矩阵，计算每列的峰度，返回一个向量。\n\n* 若 *X* 为表，计算每列的峰度，返回一个表。\n\n`kurtosis` 函数也支持校正偏差查询分区表和分布式表。\n\nDolphinDB 的 `kurtosis` 默认情况（当 *biased*=true 时）存在偏差，而 pandas 和 Excel 的 kurt 默认为无偏估计，且减去了正态分布的峰度3。参考下面例子，可以使 DolphinDB 的峰度计算结果与 pandas 和 excel 的结果保持一致：\n\n```\npython\nm = [1111, 323, 43, 51]\ndf = pandas.DataFrame(m)\ny = df.kurt()\n// output\n2.504252\n\ndolphindb\nm=matrix(1111 323 43 51)\nkurtosis(m, false) - 3\n// output\n2.5043\n```\n\n#### 例子\n\n下面的例子使用了 [norm](https://docs.dolphindb.cn/zh/funcs/n/norm.html) 函数生成数据，每次生成的数据都会有细微差别，因此每次计算的结果会有所偏差。\n\n```\nx=norm(0, 1, 1000000);\nkurtosis(x);\n// output\n3.000249\n\nx[0]=100;\nkurtosis(x);\n// output\n100.626722\n\nm=matrix(1..10, 1 2 3 4 5 6 7 8 9 100);\nm;\n```\n\n| #0 | #1  |\n| -- | --- |\n| 1  | 1   |\n| 2  | 2   |\n| 3  | 3   |\n| 4  | 4   |\n| 5  | 5   |\n| 6  | 6   |\n| 7  | 7   |\n| 8  | 8   |\n| 9  | 9   |\n| 10 | 100 |\n\n```\nkurtosis(m);\n// output\n[1.775757575757576,7.997552566718839]\n```\n"
    },
    "lasso": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lasso.html",
        "signatures": [
            {
                "full": "lasso(ds, yColName, xColNames, [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])",
                "name": "lasso",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alpha=1.0]",
                        "name": "alpha",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[positive=false]",
                        "name": "positive",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    },
                    {
                        "full": "[checkInput=true]",
                        "name": "checkInput",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [lasso](https://docs.dolphindb.cn/zh/funcs/l/lasso.html)\n\n\n\n#### 语法\n\nlasso(ds, yColName, xColNames, \\[alpha=1.0], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[positive=false], \\[swColName], \\[checkInput=true])\n\n#### 参数\n\n**ds** 是内存表或通常用 [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html) 函数生成的数据源。\n\n**yColName** 是字符串，表示数据源中因变量的列名。\n\n**xColNames** 是字符串标量或向量，表示数据源中自变量的列名。\n\n**alpha** 是浮点数，表示乘以 L1 范数惩罚项的系数。默认值是1.0。\n\n**intercept** 是布尔值，表示是否回归模型包含截距。默认值为 true。\n\n**normalize** 是布尔值。默认值为 false。若设为 true，则所有自变量均会进行如下标准化：减去平均值，然后除以 L2 范数。若 *intercept* 为 false，该参数会被忽略。\n\n**maxIter** 是正整数，表示最大迭代次数。默认值是1000。\n\n**tolerance** 是浮点数，表示迭代中止的边界差值。默认值是0.0001。\n\n**positive** 是布尔值，表示是否强制系数为正数。默认值是 false。\n\n**swColName** 字符串，表示列名，必须为 *ds* 中存在的列名。如果未指定该参数，则所有样本的权重都默认为1；如果指定该参数，则将指定的列作为样本的权重。\n\n**checkInput** 布尔值，表示是否检查输入参数（*yColName*, *xColNames* 和 *swColName*）的合法性。\n\n* 若 *checkInput*=true（默认值），则会检查这些参数中是否存在无效值（NULL），若存在，则会报错；\n\n* 若 *checkInput*=false，则不检查无效值。\n\n**Note:** 强烈建议开启 *checkInput*，以检查输入参数的有效性。如果不开启 *checkInput*，则必须确保输入参数中不存在无效值，并且中间计算过程中不会产生无效值，否则可能得到一个无用的模型。\n\n#### 详情\n\n进行 lasso 回归估计。\n\n最小化以下目标函数：\n\n![lasso](https://docs.dolphindb.cn/zh/images/lasso.png)\n\n#### 例子\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288];\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599];\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219];\nt = table(y, x0, x1);\n\nlasso(t, `y, `x0`x1);\n```\n\n如果 t 是一个 DFS 表，则应使用数据源作为输入：\n\n```\nlasso(sqlDS(<select * from t>), `y, `x0`x1);\n```\n"
    },
    "lassoBasic": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lassoBasic.html",
        "signatures": [
            {
                "full": "lassoBasic(Y, X, [mode=0], [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])",
                "name": "lassoBasic",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[alpha=1.0]",
                        "name": "alpha",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[positive=false]",
                        "name": "positive",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    },
                    {
                        "full": "[checkInput=true]",
                        "name": "checkInput",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [lassoBasic](https://docs.dolphindb.cn/zh/funcs/l/lassoBasic.html)\n\n\n\n#### 语法\n\nlassoBasic(Y, X, \\[mode=0], \\[alpha=1.0], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[positive=false], \\[swColName], \\[checkInput=true])\n\n#### 详情\n\n进行 lasso 回归估计。最小化以下目标函数：\n\n![lasso](https://docs.dolphindb.cn/zh/images/lasso.png)\n\n#### 参数\n\n**Y** 数值类型的向量，表示因变量。\n\n**X** 数值类型的向量/元组/矩阵/表，表示自变量。\n\n* 当 *X* 是向量/元组时，其长度必须等于 *Y* 的长度。\n\n* 当 *X* 是矩阵/表时，其行数必须等于 *Y* 的长度。\n\n**mode** 一个整数，可取以下 3 个值:\n\n* 0（默认值）: 输出一个系数估计向量\n\n* 1: 输出一个具有系数估计，标准差，t 统计量和 p 值的表\n\n* 2: 输出一个具有 ANOVA（方差分析）、RegressionStat（回归统计）、Cofficient（系数）和 Residual（残差）的字典，具体含义见下表：\n\n键 ANOVA 对应值：\n\n| Source of Variance | 自由度(Degree of freedom) | 平方和(Sum of Square) | 均方差(Mean of square) | F统计量          | Significance |\n| ------------------ | ---------------------- | ------------------ | ------------------- | ------------- | ------------ |\n| Regression（回归）     | 变量个数（p）                | 回归平方和（SSR）         | 回归均方差（MSR=SSR/R）    | MSR 对 MSE 的比值 | 显著性，即统计出的P值  |\n| Residual（残差）       | 残差自由度（n-p-1）           | 残差平方和（SSE）         | 残差均方差（MSE=MSE/E）    |               |              |\n| Total              | 样本自由度， 不包括常数项（n-1）     | 总离差平方和（SST）        |                     |               |              |\n\n键 RegressionStat 对应值：\n\n| item         | 统计值                                                              |\n| ------------ | ---------------------------------------------------------------- |\n| R2           | R 决定系数，描述回归曲线对真实数据点拟合程度的统计量。范围在 \\[0,1]之间，越接近1 ，说明对y的解释能力越强，拟合越好。 |\n| AdjustedR2   | 经自由度修正后的决定系数，通过样本数量与模型数量对 R-squared 进行修正。                        |\n| StdError     | 回归残差标准误差，残差经自由度修正后的标准差。                                          |\n| Observations | 观察样本个数。                                                          |\n\n键 Coefficient 对应值：\n\n| 元素       | 说明                |\n| -------- | ----------------- |\n| factor   | 自变量名称             |\n| beta     | 回归系数估计值           |\n| stdError | 回归系数标准误差。         |\n| tstat    | T 统计值，衡量系数的统计显著性。 |\n\n键 Residual 对应每一个预测值和实际值之间的残差。\n\n**alpha** 一个浮点数，表示乘以 L1 范数惩罚项的系数。默认值是1.0。\n\n**intercept** 布尔值，表示是否包含回归中的截距。默认值为 true，此时系统自动给 *X* 添加一列 “1” 以生成截距。\n\n**normalize** 布尔值，默认值为 false。若设为 true，则所有自变量均会进行如下标准化：减去平均值，然后除以 L2 范数。若 *intercept* 为 false，该参数会被忽略。\n\n**maxIter** 一个正整数，表示最大迭代次数。默认值是1000。\n\n**tolerance** 一个浮点数，表示迭代中止的边界差值。默认值是0.0001。\n\n**positive** 是布尔值，表示是否强制系数为正数。默认值是 false。\n\n**swColName** 字符串，表示列名，必须为 *X* 中存在的列名。如果未指定该参数，则所有样本的权重都默认为1；如果指定该参数，则将指定的列作为自变量的权重。\n\n**checkInput** 布尔值，表示是否检查输入参数（*Y* 和 *X*）的合法性。\n\n* 若 *checkInput*=true（默认值），则会检查参数中是否存在无效值（NULL），若存在，则会报错；\n\n* 若 *checkInput*=false，则不检查无效值。\n\n**Note:** 强烈建议开启 *checkInput*，以检查输入参数的有效性。如果不开启 *checkInput*，则必须确保输入参数中不存在无效值，并且中间计算过程中不会产生无效值，否则可能得到一个无用的模型。\n\n#### 例子\n\n```\nx1=1 3 5 7 11 16 23\nx2=2 8 11 34 56 54 100\ny=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\nprint(lassoBasic(y, (x1,x2), mode = 0));\n// output\n[-9.133706333069543,2.535935196073186,0.189298948643987]\n\n\nprint(lassoBasic(y, (x1,x2), mode = 1));\n// output\nfactor    beta               stdError          tstat              pvalue           \n--------- ------------------ ----------------- ------------------ -----------------\nintercept -9.133706333069543 5.247492365971091 -1.740584968222107 0.156730846105191\nx1        2.535935196073186  1.835793667840723 1.38138356205138   0.239309472176311\nx2        0.189298948643987  0.410201227095842 0.461478260277749  0.66843504931137 \n\n\nprint(lassoBasic(y, (x1,x2), mode = 2));\n// output\nCoefficient->\nfactor    beta               stdError          tstat              pvalue           \n--------- ------------------ ----------------- ------------------ -----------------\nintercept -9.133706333069543 5.247492365971091 -1.740584968222107 0.156730846105191\nx1        2.535935196073186  1.835793667840723 1.38138356205138   0.239309472176311\nx2        0.189298948643987  0.410201227095842 0.461478260277749  0.66843504931137 \n\nRegressionStat->\nitem         statistics       \n------------ -----------------\nR2           0.931480447323074\nAdjustedR2   0.897220670984611\nStdError     8.195817208870076\nObservations 7                \n\nANOVA->\nBreakdown  DF SS                   MS                   F                  Significance     \n---------- -- -------------------- -------------------- ------------------ -----------------\nRegression 2  4165.242566095043912 2082.621283047521956 31.004574440904473 0.003672076469395\nResidual   4  268.685678884843582  67.171419721210895                                       \nTotal      6  4471.637142857141952                                                          \n\nResidual->\n[6.319173239708383,4.21150915569809,-0.028258082380245,-6.254004293338318,-7.262321947798779,-6.063400030876729,9.077301958987561]\n```\n"
    },
    "lassoCV": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lassoCV.html",
        "signatures": [
            {
                "full": "lassoCV(ds, yColName, xColNames, [alpha=[0.01,0.1,1.0]], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])",
                "name": "lassoCV",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alpha=[0.01",
                        "name": "[alpha=[0.01"
                    },
                    {
                        "full": "0.1",
                        "name": "0.1"
                    },
                    {
                        "full": "1.0]]",
                        "name": "1.0]]"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[positive=false]",
                        "name": "positive",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    },
                    {
                        "full": "[checkInput=true]",
                        "name": "checkInput",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [lassoCV](https://docs.dolphindb.cn/zh/funcs/l/lassoCV.html)\n\n#### 语法\n\nlassoCV(ds, yColName, xColNames, \\[alpha=\\[0.01,0.1,1.0]], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[positive=false], \\[swColName], \\[checkInput=true])\n\n#### 详情\n\n使用五折交叉验证方法进行 lasso 回归估计，输出最优参数对应的模型。结果为一个字典，包含以下 key：\n\n* modelName：模型名称。LassoCV 方法对应的模型名为 \"LassoCV\"。\n* coefficients：模型的回归系数。\n* intercept：截距。\n* dual\\_gap：优化结束时的对偶间隙。\n* tolerance：迭代中止的边界差值。\n* iterations：迭代次数。\n* xColNames：数据源中自变量的列名。\n* predict：用于预测的函数。\n* alpha：交叉验证选择的惩罚量。\n\n#### 参数\n\n**alphas** 是浮点型标量或向量，表示乘以 L1 范数惩罚项的系数。默认值是 \\[0.01, 0.1, 1.0]。\n\n**Note:** 除 *alphas* 参数外，其它参数都和 [lasso](https://docs.dolphindb.cn/zh/funcs/l/lasso.html) 的参数相同，参数描述可参考 [lasso](https://docs.dolphindb.cn/zh/funcs/l/lasso.html)。这里仅说明 *alphas* 参数。\n\n#### 例子\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288]\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599]\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219]\nt = table(y, x0, x1);\n\nlassoCV(t, `y, `x0`x1);\n```\n\n返回如下：\n\n```\ndual_gap->0.0009\nmodelName->lassoCV\nintercept->0.0313\nalpha->0.0100\ncoefficients->[94.4493,14.3045]\npredict->coordinateDescentPredict\nxColNames->[x0,x1]\ntolerance->0.0001\niterations->5\n```\n\n\n\n#### 语法\n\n`lasso(ds, yColName, xColNames, [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])`\n\n#### 参数\n\n**ds** 是内存表或通常用 [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html) 函数生成的数据源。\n\n**yColName** 是字符串，表示数据源中因变量的列名。\n\n**xColNames** 是字符串标量或向量，表示数据源中自变量的列名。\n\n**alpha** 是浮点数，表示乘以 L1 范数惩罚项的系数。默认值是1.0。\n\n**intercept** 是布尔值，表示是否回归模型包含截距。默认值为 true。\n\n**normalize** 是布尔值。默认值为 false。若设为 true，则所有自变量均会进行如下标准化：减去平均值，然后除以 L2 范数。若 *intercept* 为 false，该参数会被忽略。\n\n**maxIter** 是正整数，表示最大迭代次数。默认值是1000。\n\n**tolerance** 是浮点数，表示迭代中止的边界差值。默认值是0.0001。\n\n**positive** 是布尔值，表示是否强制系数为正数。默认值是 false。\n\n**swColName** 字符串，表示列名，必须为 *ds* 中存在的列名。如果未指定该参数，则所有样本的权重都默认为1；如果指定该参数，则将指定的列作为样本的权重。\n\n**checkInput** 布尔值，表示是否检查输入参数（*yColName*, *xColNames* 和 *swColName*）的合法性。\n\n* 若 *checkInput*=true（默认值），则会检查这些参数中是否存在无效值（NULL, nan 或 Inf），若存在，则会报错；\n\n* 若 *checkInput*=false，则不检查无效值，则将 NULL 当作 DOUBLE 类型的正数最小值处理。\n\n**Note:** 强烈建议开启 *checkInput*，以检查输入参数的有效性。如果不开启 *checkInput*，则必须确保输入参数中不存在无效值，并且中间计算过程中不会产生无效值，否则可能得到一个无用的模型。\n\n#### 详情\n\n进行 lasso 回归估计。\n\n最小化以下目标函数：\n\n![lasso](https://docs.dolphindb.cn/zh/images/lasso.png)\n\n#### 例子\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288];\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599];\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219];\nt = table(y, x0, x1);\n\nlasso(t, `y, `x0`x1);\n```\n\n如果 t 是一个 DFS 表，则应使用数据源作为输入：\n\n```\nlasso(sqlDS(<select * from t>), `y, `x0`x1);\n```\n"
    },
    "last": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/last.html",
        "signatures": [
            {
                "full": "last(X)",
                "name": "last",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [last](https://docs.dolphindb.cn/zh/funcs/l/last.html)\n\n\n\n#### 语法\n\nlast(X)\n\n或\n\nlast X\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n返回向量的最后一个元素，或矩阵、表的最后一行。\n\n**Note:** 若向量的最后一个元素为 NULL，则返回 NULL。若要返回最后一个非 NULL 的元素，请使用 [lastNot](https://docs.dolphindb.cn/zh/funcs/l/lastNot.html) 函数。\n\n#### 例子\n\n```\nlast(`hello `world);\n```\n\n输出返回：world\n\n```\nlast(1..10);\n```\n\n输出返回：10\n\n```\nm = matrix(1 2 3, 4 5 6);\nm;\n```\n\n输出返回：\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nlast(m);\n```\n\n输出返回：\\[3,6]\n\n相关函数：[first](https://docs.dolphindb.cn/zh/funcs/f/first.html)\n"
    },
    "lastNot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lastNot.html",
        "signatures": [
            {
                "full": "lastNot(X, [k])",
                "name": "lastNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k]",
                        "name": "k",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [lastNot](https://docs.dolphindb.cn/zh/funcs/l/lastNot.html)\n\n\n\n#### 语法\n\nlastNot(X, \\[k])\n\n#### 参数\n\n**X** 是向量、矩阵或表。\n\n**k** 是标量。它是一个可选参数。\n\n#### 详情\n\n若 *X* 是向量：\n\n* 如果没有指定 *k*，返回 *X* 中最后一个不为 NULL 的元素。\n\n* 如果指定 *k*，返回 *X* 中最后一个不为 *k* 或 NULL 的元素。\n\n若 *X* 是矩阵或表，在每列内进行上述计算，返回一个向量。\n\n`lastNot` 函数也支持查询分布式表和分区表。\n\n#### 例子\n\n```\nlastNot(1 6 0 0 0, 0);\n```\n\n输出返回：6\n\n```\nlastNot(1 6 0 0 0 2 3 0 NULL, 0);\n```\n\n输出返回：3\n\n```\nlastNot(1 6 0 0 0 2 3 0 NULL);\n```\n\n输出返回：0\n\n```\nt=table(1 1 1 1 1 2 2 2 2 2 as id, 1 2 0 0 0 3 NULL NULL 0 0 as x);\nt;\n```\n\n输出返回：\n\n| id | x  |\n| :- | :- |\n| 1  | 1  |\n| 1  | 2  |\n| 1  | 0  |\n| 1  | 0  |\n| 1  | 0  |\n| 2  | 3  |\n| 2  |    |\n| 2  |    |\n| 2  | 0  |\n| 2  | 0  |\n\n```\nselect lastNot(x, 0) from t group by id;\n```\n\n输出返回：\n\n| id | lastNot\\_x |\n| -- | ---------- |\n| 1  | 2          |\n| 2  | 3          |\n\n```\nm=matrix(2 NULL 1 0 NULL, NULL 2 NULL 6 0);\nm;\n```\n\n输出返回：\n\n| #0 | #1  |\n| :- | :-- |\n| 2  | 2   |\n| 1  |     |\n| 0  | 6 0 |\n\n```\nlastNot(m, 0);\n```\n\n输出返回：\\[1,6]\n"
    },
    "lastWeekOfMonth": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lastWeekOfMonth.html",
        "signatures": [
            {
                "full": "lastWeekOfMonth(X, [weekday=0], [offset], [n=1])",
                "name": "lastWeekOfMonth",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weekday=0]",
                        "name": "weekday",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [lastWeekOfMonth](https://docs.dolphindb.cn/zh/funcs/l/lastWeekOfMonth.html)\n\n\n\n#### 语法\n\nlastWeekOfMonth(X, \\[weekday=0], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**weekday** 是0到6之间的整数，表示星期编号。0表示星期一，1表示星期二，... ，6表示星期日。默认值为0。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，offset默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在月份或上一个月份中最后一个 *weekday* 对应的日期。假设 *X* 所在月份的最后一个 *weekday* 对应日期为 d：\n\n* 如果 *X\\<d*，*lastWeekOfMonth* 函数返回 *X* 的上一个月中最后一个 *weekday* 对应的日期。\n\n* 如果 *X>=d*，*lastWeekOfMonth* 函数返回 *X* 所在月份的最后一个 *weekday* 对应的日期。\n\n如果指定了 *offset*，表示从 *offset* 开始，结果每隔 *n* 个月更新一次。注意，只有当 *n* >1时，*offset* 才会生效。\n\n#### 例子\n\n```\nlastWeekOfMonth(2019.11.24,2);\n// output\n2019.10.30\n// 2019年11月最后一个星期三为2019.11.27，2019.11.24在2019.11.27之前，因此返回2019年10月的最后一个星期三\n\nlastWeekOfMonth(2019.11.29,2);\n// output\n2019.11.27\n\ndate=2012.01.02 2012.02.03 2012.03.07 2012.04.08 2012.05.12 2012.06.16 2012.07.18 2012.08.20 2012.09.25 2012.10.28\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by lastWeekOfMonth(date,4,2012.01.01,2);\n```\n\n| lastWeekOfMonth\\_date | avg\\_price | sum\\_qty |\n| --------------------- | ---------- | -------- |\n| 2011.12.30            | 39.53      | 4100     |\n| 2012.02.24            | 29.77      | 5300     |\n| 2012.04.27            | 175.1      | 12200    |\n| 2012.06.29            | 50.54      | 3800     |\n| 2012.08.31            | 51.29      | 8800     |\n| 2012.10.26            | 52.38      | 4500     |\n"
    },
    "latestIndexedTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/latestIndexedTable.html",
        "signatures": [
            {
                "full": "latestIndexedTable(keyColumns, timeColumn, [X1], [X2], .....)",
                "name": "latestIndexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "latestIndexedTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)",
                "name": "latestIndexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            },
            {
                "full": "latestIndexedTable(keyColumns, timeColumn, table)",
                "name": "latestIndexedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [latestIndexedTable](https://docs.dolphindb.cn/zh/funcs/l/latestIndexedTable.html)\n\n\n\n#### 语法\n\nlatestIndexedTable(keyColumns, timeColumn, \\[X1], \\[X2], .....)\n\n或\n\nlatestIndexedTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)\n\n或\n\nlatestIndexedTable(keyColumns, timeColumn, table)\n\n#### 参数\n\n在 [indexedTable](https://docs.dolphindb.cn/zh/funcs/i/indexedTable.html) 的基础上，增加了 *timeColumn* 参数。\n\n**timeColumn** 字符串，表示时间列，可以为整型或时间类型。\n\n#### 详情\n\n该函数用于创建索引内存表，包含一个主键。主键可由一个或多个字段组成。其相较于 indexedTable，除主键外，还包含一个时间列，用于判断是否更新记录。\n\n向表中添加新记录时，系统自动检查新记录的主键值。如果新记录的主键值与已有记录的主键值相同，且新记录的时间戳大于等于已有记录的时间戳，则更新表中对应的记录，否则不更新。因为在写入数据时会判断时间列，对相同主键的记录进行去重，所以`latestIndexedTable`写入性能较`indexedTable`差，但查询性能不受影响。\n\n**Note:**\n\n* 不允许对主键进行更新操作。\n\n优化查询 latestIndexedTable 的方法和相关案例请参照函数 indexedTable。\n\n#### 例子\n\n例1. 创建索引表\n\n第一种写法：\n\n```\nsym=`A`B`C`D`E\nid=5 4 3 2 1\nval=52 64 25 48 71\ntimeCol = 2022.12.07T00:00:00.001+0..4\nt=latestIndexedTable(`sym`id,`timeCol,sym,id,timeCol,val)\nt;\n```\n\n输出返回：\n\n| sym | id | timeCol                 | val |\n| --- | -- | ----------------------- | --- |\n| A   | 5  | 2022.12.07T00:00:00.001 | 52  |\n| B   | 4  | 2022.12.07T00:00:00.002 | 64  |\n| C   | 3  | 2022.12.07T00:00:00.003 | 25  |\n| D   | 2  | 2022.12.07T00:00:00.004 | 48  |\n| E   | 1  | 2022.12.07T00:00:00.005 | 71  |\n\n第二种写法：\n\n```\nt=latestIndexedTable(`sym`id,1:0,`sym`id`val,[SYMBOL,INT,INT])\ninsert into t values(`A`B`C`D`E,5 4 3 2 1,2022.12.07T00:00:00.001+0..4,52 64 25 48 71);\n```\n\n第三种写法：\n\n```\ntmp=table(sym, id, timeCol, val)\nt=latestIndexedTable(`sym`id, `timeCol, tmp);\n```\n\n例2. 更新内存表\n\n插入新记录，并且新记录中的主键值与表中主键值重复，根据时间列来确定保留哪条记录：\n\n```\ninsert into t values(`A`A`E,5 5 1, 2022.12.07T00:00:00.001 2022.12.07T00:00:00.007 2022.12.07T00:00:00.003, 44 66 28);\nt;\n```\n\n输出返回：\n\n| sym | id | timeCol                 | val |\n| --- | -- | ----------------------- | --- |\n| A   | 5  | 2022.12.07T00:00:00.007 | 66  |\n| B   | 4  | 2022.12.07T00:00:00.002 | 64  |\n| C   | 3  | 2022.12.07T00:00:00.003 | 25  |\n| D   | 2  | 2022.12.07T00:00:00.004 | 48  |\n| E   | 1  | 2022.12.07T00:00:00.005 | 71  |\n\n相关函数：[keyedTable](https://docs.dolphindb.cn/zh/funcs/k/keyedTable.html), [indexedTable](https://docs.dolphindb.cn/zh/funcs/i/indexedTable.html), [latestKeyedTable](https://docs.dolphindb.cn/zh/funcs/l/latestKeyedTable.html)\n"
    },
    "latestKeyedStreamTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/latestkeyedstreamtable.html",
        "signatures": [
            {
                "full": "latestKeyedStreamTable(keyColumns, timeColumn, [X1], [X2], .....)",
                "name": "latestKeyedStreamTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "latestKeyedStreamTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)",
                "name": "latestKeyedStreamTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            }
        ],
        "markdown": "### [latestKeyedStreamTable](https://docs.dolphindb.cn/zh/funcs/l/latestkeyedstreamtable.html)\n\n\n\n#### 语法\n\nlatestKeyedStreamTable(keyColumns, timeColumn, \\[X1], \\[X2], .....)\n\n或\n\nlatestKeyedStreamTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)\n\n#### 参数\n\n在 [keyedStreamTable](https://docs.dolphindb.cn/zh/funcs/k/keyedStreamTable.html) 的基础上，增加了 *timeColumn* 参数。\n\n**timeColumn** 字符串标量或长度为 2 的向量，分别用于指定 1 个或 2 个时间列。当仅指定 1 个时间列时，该列可以为整型或时间类型；当指定 2 个时间列时，第 1 列必须是 DATE 类型，第 2 列则是 TIME, SECOND 或 NANOTIME 类型。通过这两列，可以共同确定唯一的时间值。\n\n#### 详情\n\n创建一个键值流数据表，该表包含一个主键，且该主键不允许重复值。主键可由一个或多个字段组成。其相较于 keyedStreamTable，除主键外，还包含一个时间列，用于判断是否添加记录。\n\n向表中添加新记录时，系统会自动检查新记录的主键值：\n\n* 如果新记录的主键值与内存中已有记录的主键值相同，且新记录的时间戳大于已有记录的时间戳，则将新记录添加至表中，否则直接舍弃。\n\n* 一次性批量插入新记录时，若有多条记录具有相同的主键值，且该主键值与已有记录的主键值不同，只有时间戳最大的记录可以插入成功。\n\n#### 例子\n\n例1. 主键为 1 个字段\n\n第一种写法：\n\n```\nid = `A`B`C`D`E\nx = 1 2 3 4 5\ntimeCol = 2024.09.10T00:00:00.001+0..4\nt1 = latestKeyedStreamTable(`id, `timeCol, id, x, timeCol)\nt1;\n```\n\n<table id=\"table_p5k_xlw_bdc\"><thead><tr><th>\n\nid\n\n</th><th>\n\nx\n\n</th><th>\n\ntimeCol\n\n</th></tr></thead><tbody><tr><td>\n\nA\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.09.10T00:00:00.001\n\n</td></tr><tr><td>\n\nB\n\n</td><td>\n\n2\n\n</td><td>\n\n2024.09.10T00:00:00.002\n\n</td></tr><tr><td>\n\nC\n\n</td><td>\n\n3\n\n</td><td>\n\n2024.09.10T00:00:00.003\n\n</td></tr><tr><td>\n\nD\n\n</td><td>\n\n4\n\n</td><td>\n\n2024.09.10T00:00:00.004\n\n</td></tr><tr><td>\n\nE\n\n</td><td>\n\n5\n\n</td><td>\n\n2024.09.10T00:00:00.005\n\n</td></tr></tbody>\n</table>第二种写法：\n\n```\nt2=latestKeyedStreamTable(`id, `timeCol, 100:0, `id`x`timeCol, [INT,INT,TIMESTAMP])\ninsert into t2 values(1 2 3, 10 20 30, [2024.09.10T00:00:00.001,\n2024.09.10T00:00:00.002, 2024.09.10T00:00:00.003])\n\nt2\n```\n\n<table id=\"table_u5k_xlw_bdc\"><thead><tr><th>\n\nid\n\n</th><th>\n\nx\n\n</th><th>\n\ntimeCol\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\n10\n\n</td><td>\n\n2024.09.10T00:00:00.001\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n20\n\n</td><td>\n\n2024.09.10T00:00:00.002\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n30\n\n</td><td>\n\n2024.09.10T00:00:00.003\n\n</td></tr></tbody>\n</table>向表 t1 中插入新记录，并且新记录中的主键值与表中主键值相同时，将根据 *timeColumn* 来确定是否插入新记录：\n\n```\ninsert into t1 values(`D`E`F, 6 7 8, [2024.09.10T00:00:00.005,\n 2024.09.10T00:00:00.005, 2024.09.10T00:00:00.005])\nt1\n```\n\n<table id=\"table_uyx_1mw_bdc\"><thead><tr><th>\n\nid\n\n</th><th>\n\nx\n\n</th><th>\n\ntimeCol\n\n</th></tr></thead><tbody><tr><td>\n\nA\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.09.10T00:00:00.001\n\n</td></tr><tr><td>\n\nB\n\n</td><td>\n\n2\n\n</td><td>\n\n2024.09.10T00:00:00.002\n\n</td></tr><tr><td>\n\nC\n\n</td><td>\n\n3\n\n</td><td>\n\n2024.09.10T00:00:00.003\n\n</td></tr><tr><td>\n\nD\n\n</td><td>\n\n4\n\n</td><td>\n\n2024.09.10T00:00:00.004\n\n</td></tr><tr><td>\n\nE\n\n</td><td>\n\n5\n\n</td><td>\n\n2024.09.10T00:00:00.005\n\n</td></tr><tr><td>\n\nD\n\n</td><td>\n\n6\n\n</td><td>\n\n2024.09.10T00:00:00.005\n\n</td></tr><tr><td>\n\nF\n\n</td><td>\n\n8\n\n</td><td>\n\n2024.09.10T00:00:00.005\n\n</td></tr></tbody>\n</table>可以看到，新插入了 id=\\`D 和 id=\\`F 的记录，而 id=\\`E 的记录被丢弃了。新增的 id 为 D 的记录因为时间戳大于已存在的 id 为 D 的记录，所以插入成功；id 为 E 的记录因为时间戳等于已有的 id 为 E 的记录，所以被舍弃；因为已有记录中没有 id 为 F 的记录，所以它被成功插入。\n\n例2. 主键为多个字段\n\n```\nt3 = latestKeyedStreamTable(`id`x, `timeCol, id, x, timeCol)\ninsert into t3 values(`D`E, 4 5, [2024.09.10T00:00:00.004, 2024.09.10T00:00:00.005])\ninsert into t3 values(`D`F, 6 7, [2024.09.10T00:00:00.004, 2024.09.10T00:00:00.005])\nt3\n```\n\n<table id=\"table_bfb_dmw_bdc\"><thead><tr><th>\n\nid\n\n</th><th>\n\nx\n\n</th><th>\n\ntimeCol\n\n</th></tr></thead><tbody><tr><td>\n\nA\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.09.10T00:00:00.001\n\n</td></tr><tr><td>\n\nB\n\n</td><td>\n\n2\n\n</td><td>\n\n2024.09.10T00:00:00.002\n\n</td></tr><tr><td>\n\nC\n\n</td><td>\n\n3\n\n</td><td>\n\n2024.09.10T00:00:00.003\n\n</td></tr><tr><td>\n\nD\n\n</td><td>\n\n4\n\n</td><td>\n\n2024.09.10T00:00:00.004\n\n</td></tr><tr><td>\n\nE\n\n</td><td>\n\n5\n\n</td><td>\n\n2024.09.10T00:00:00.005\n\n</td></tr><tr><td>\n\nD\n\n</td><td>\n\n6\n\n</td><td>\n\n2024.09.10T00:00:00.004\n\n</td></tr><tr><td>\n\nF\n\n</td><td>\n\n7\n\n</td><td>\n\n2024.09.10T00:00:00.005\n\n</td></tr></tbody>\n</table>例3. 时间列指定为两列\n\n```\nid = `A`B`C`D`E\ndateCol = take(2024.09.10, 5)\ntimeCol = 00:00:00.001+0..4\nt4 = latestKeyedStreamTable(`id, `dateCol`timeCol, id, x, dateCol, timeCol)\nt4\n```\n\n<table id=\"table_s3f_fmw_bdc\"><thead><tr><th>\n\nid\n\n</th><th>\n\nx\n\n</th><th>\n\ndateCol\n\n</th><th>\n\ntimeCol\n\n</th></tr></thead><tbody><tr><td>\n\nA\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.09.10\n\n</td><td>\n\n00:00:00.001\n\n</td></tr><tr><td>\n\nB\n\n</td><td>\n\n2\n\n</td><td>\n\n2024.09.10\n\n</td><td>\n\n00:00:00.002\n\n</td></tr><tr><td>\n\nC\n\n</td><td>\n\n3\n\n</td><td>\n\n2024.09.10\n\n</td><td>\n\n00:00:00.003\n\n</td></tr><tr><td>\n\nD\n\n</td><td>\n\n4\n\n</td><td>\n\n2024.09.10\n\n</td><td>\n\n00:00:00.004\n\n</td></tr><tr><td>\n\nE\n\n</td><td>\n\n5\n\n</td><td>\n\n2024.09.10\n\n</td><td>\n\n00:00:00.005\n\n</td></tr></tbody>\n</table>向表 t4 中插入新记录，并且新记录中的主键值与表中主键值相同时，将根据`concatDateTime(dateCol, timeCol)` 的值来确定是否插入新记录：\n\n```\ninsert into t4 values(`D`E, 4 5, [2024.09.10,  2024.09.11], [00:00:00.004, 00:00:00.005]);\nt4\n```\n\n<table id=\"table_j3v_hmw_bdc\"><thead><tr><th>\n\nid\n\n</th><th>\n\nx\n\n</th><th>\n\ndateCol\n\n</th><th>\n\ntimeCol\n\n</th></tr></thead><tbody><tr><td>\n\nA\n\n</td><td>\n\n1\n\n</td><td>\n\n2024.09.10\n\n</td><td>\n\n00:00:00.001\n\n</td></tr><tr><td>\n\nB\n\n</td><td>\n\n2\n\n</td><td>\n\n2024.09.10\n\n</td><td>\n\n00:00:00.002\n\n</td></tr><tr><td>\n\nC\n\n</td><td>\n\n3\n\n</td><td>\n\n2024.09.10\n\n</td><td>\n\n00:00:00.003\n\n</td></tr><tr><td>\n\nD\n\n</td><td>\n\n4\n\n</td><td>\n\n2024.09.10\n\n</td><td>\n\n00:00:00.004\n\n</td></tr><tr><td>\n\nE\n\n</td><td>\n\n5\n\n</td><td>\n\n2024.09.10\n\n</td><td>\n\n00:00:00.005\n\n</td></tr><tr><td>\n\nE\n\n</td><td>\n\n5\n\n</td><td>\n\n2024.09.11\n\n</td><td>\n\n00:00:00.005\n\n</td></tr></tbody>\n</table>\n"
    },
    "latestKeyedTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/latestKeyedTable.html",
        "signatures": [
            {
                "full": "latestKeyedTable(keyColumns, timeColumn, [X1], [X2], .....)",
                "name": "latestKeyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "latestKeyedTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)",
                "name": "latestKeyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            },
            {
                "full": "latestKeyedTable(keyColumns, timeColumn, table)",
                "name": "latestKeyedTable",
                "parameters": [
                    {
                        "full": "keyColumns",
                        "name": "keyColumns"
                    },
                    {
                        "full": "timeColumn",
                        "name": "timeColumn"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    }
                ]
            }
        ],
        "markdown": "### [latestKeyedTable](https://docs.dolphindb.cn/zh/funcs/l/latestKeyedTable.html)\n\n\n\n#### 语法\n\nlatestKeyedTable(keyColumns, timeColumn, \\[X1], \\[X2], .....)\n\n或\n\nlatestKeyedTable(keyColumns, timeColumn, capacity:size, colNames, colTypes)\n\n或\n\nlatestKeyedTable(keyColumns, timeColumn, table)\n\n#### 参数\n\n在 [keyedTable](https://docs.dolphindb.cn/zh/funcs/k/keyedTable.html) 的基础上，增加了 *timeColumn* 参数。\n\n**timeColumn** 字符串，表示时间列，可以为整型或时间类型。\n\n#### 详情\n\n该函数用于创建键值内存表，包含一个主键。主键可由一个或多个字段组成。其相较于 keyedTable，除主键外，还包含一个时间列，用于判断是否更新记录。\n\n向表中添加新记录时，系统自动检查新记录的主键值。如果新记录的主键值与已有记录的主键值相同，且新记录的时间戳大于等于已有记录的时间戳，则更新表中对应的记录，否则不更新。因为在写入数据时会判断时间列，对相同主键的记录进行去重，所以`latestKeyedTable`写入性能较`keyedTable`差，但查询性能不受影响。\n\n**Note:**\n\n* 不允许对主键进行修改（update, replaceColumn!）和删除（alter, dropColumns!）操作。\n\n优化查询 latestKeyedTable 的方法和相关案例请参照函数 keyedTable。\n\n#### 例子\n\n例1. 创建键值表\n\n第一种写法：\n\n```\nsym=`A`B`C`D`E\nid=5 4 3 2 1\nval=52 64 25 48 71\ntimeCol = 2022.12.07T00:00:00.001+0..4\nt=latestKeyedTable(`sym`id,`timeCol,sym,id,timeCol,val)\nt;\n```\n\n输出返回：\n\n| sym | id | timeCol                 | val |\n| --- | -- | ----------------------- | --- |\n| A   | 5  | 2022.12.07T00:00:00.001 | 52  |\n| B   | 4  | 2022.12.07T00:00:00.002 | 64  |\n| C   | 3  | 2022.12.07T00:00:00.003 | 25  |\n| D   | 2  | 2022.12.07T00:00:00.004 | 48  |\n| E   | 1  | 2022.12.07T00:00:00.005 | 71  |\n\n第二种写法：\n\n```\nt=latestKeyedTable(`sym`id,1:0,`sym`id`val,[SYMBOL,INT,INT])\ninsert into t values(`A`B`C`D`E,5 4 3 2 1,2022.12.07T00:00:00.001+0..4,52 64 25 48 71);\n```\n\n第三种写法：\n\n```\ntmp=table(sym, id, timeCol, val)\nt=latestKeyedTable(`sym`id, `timeCol, tmp);\n```\n\n例2. 更新键值表\n\n插入新记录，并且新记录中的主键值与表中主键值重复，根据时间列来确定保留哪条记录：\n\n```\ninsert into t values(`A`A`E,5 5 1, 2022.12.07T00:00:00.001 2022.12.07T00:00:00.007 2022.12.07T00:00:00.003, 44 66 28);\nt;\n```\n\n输出返回：\n\n| sym | id | timeCol                 | val |\n| --- | -- | ----------------------- | --- |\n| A   | 5  | 2022.12.07T00:00:00.007 | 66  |\n| B   | 4  | 2022.12.07T00:00:00.002 | 64  |\n| C   | 3  | 2022.12.07T00:00:00.003 | 25  |\n| D   | 2  | 2022.12.07T00:00:00.004 | 48  |\n| E   | 1  | 2022.12.07T00:00:00.005 | 71  |\n\n相关函数：[keyedTable](https://docs.dolphindb.cn/zh/funcs/k/keyedTable.html), [indexedTable](https://docs.dolphindb.cn/zh/funcs/i/indexedTable.html), [latestIndexedTable](https://docs.dolphindb.cn/zh/funcs/l/latestIndexedTable.html)\n"
    },
    "le": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/le.html",
        "signatures": [
            {
                "full": "le(X, Y)",
                "name": "le",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [le](https://docs.dolphindb.cn/zh/funcs/l/le.html)\n\n\n\n#### 语法\n\nle(X, Y) 或 X<=Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量、矩阵或集合。如果 *X* 或 *Y* 的其中一个是数据对、向量或矩阵，另一个必须是一个标量，或具有相同长度或维度的数据对、向量或矩阵。\n\n#### 详情\n\n如果 *X* 和 *Y* 都不是集合，返回逐个元素比较 *X*<=*Y* 的结果。\n\n如果 *X* 和 *Y* 都是集合，则检查 *X* 是否为 *Y* 的子集。\n\n#### 例子\n\n```\n1 2 3 <= 2;\n// output\n[true,true,false]\n\n1 2 3<=0 2 4;\n// output\n[false,true,true]\n\n2:3<=1:6;\n// output\n[false,true]\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 le 4;\n```\n\n| #0   | #1   | #2    |\n| ---- | ---- | ----- |\n| true | true | false |\n| true | true | false |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1<=m2;\n```\n\n| #0   | #1    | #2    |\n| ---- | ----- | ----- |\n| true | true  | false |\n| true | false | false |\n\n集合操作：如果 *X*<*Y*，则 *X* 是 *Y* 的子集。\n\n```\nx=set(4 6);\ny=set(4 6 8);\n\nx<=y;\n// output\ntrue\nx<=x;\n// output\ntue\n```\n"
    },
    "left": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/left.html",
        "signatures": [
            {
                "full": "left(X,n)",
                "name": "left",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [left](https://docs.dolphindb.cn/zh/funcs/l/left.html)\n\n\n\n#### 语法\n\nleft(X,n)\n\n#### 参数\n\n**X** 可以是字符串或字符串向量。\n\n**n** 必须是一个非负整数。\n\n#### 详情\n\n返回 *X* 左边 *n* 个字符。\n\n#### 例子\n\n```\nleft(\"I love this game!\", 6);\n// output\nI love\n```\n"
    },
    "lfill": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lfill.html",
        "signatures": [
            {
                "full": "lfill(obj)",
                "name": "lfill",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    }
                ]
            }
        ],
        "markdown": "### [lfill](https://docs.dolphindb.cn/zh/funcs/l/lfill.html)\n\n\n\n#### 语法\n\nlfill(obj)\n\n#### 参数\n\n**obj** 是数值型向量或只包含数值类型的表。\n\n#### 详情\n\n* 如果 *obj* 是向量，线性填充两个非空元素之间的 NULL值。\n\n* 如果 *obj* 是表，对于表中的每一列，线性填充两个非空元素之间的 NULL 值。\n\n`lfill` 不会改变向量的值，[lfill!](https://docs.dolphindb.cn/zh/funcs/l/lfill_.html) 会改变向量的值。\n\n#### 例子\n\n```\na= NULL 1.5 NULL NULL 4.5\na.lfill();\n// output\n[NULL,1.5,2.5,3.5,4.5]\n\nb=1 NULL NULL 6\nb.lfill();\n// output\n[1,3,4,6]\n\nt=table(1 NULL NULL 4 5 6 as id,2.1 2.2 NULL NULL 2.4 2.6 as val);\nselect * from lfill(t);\n```\n\n| id | val      |\n| -- | -------- |\n| 1  | 2.1      |\n| 2  | 2.2      |\n| 3  | 2.266667 |\n| 4  | 2.333333 |\n| 5  | 2.4      |\n| 6  | 2.6      |\n\n相关函数：[bfill](https://docs.dolphindb.cn/zh/funcs/b/bfill.html), [bfill!](https://docs.dolphindb.cn/zh/funcs/b/bfill_.html), [lfill!](https://docs.dolphindb.cn/zh/funcs/l/lfill_.html)\n"
    },
    "lfill!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lfill_.html",
        "signatures": [
            {
                "full": "lfill!(obj)",
                "name": "lfill!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    }
                ]
            }
        ],
        "markdown": "### [lfill!](https://docs.dolphindb.cn/zh/funcs/l/lfill_.html)\n\n\n\n#### 语法\n\nlfill!(obj)\n\n#### 参数\n\n**obj** 是数值型向量或只包含数值类型的表。\n\n#### 详情\n\n* 如果 *obj* 是向量，线性填充两个非空元素之间的 NULL 值。\n\n* 如果 *obj* 是表，对于表中的每一列，线性填充两个非空元素之间的 NULL 值。\n\n#### 例子\n\n```\na= NULL 1.5 NULL NULL 4.5\na.lfill!()\na;\n// output\n[NULL,1.5,2.5,3.5,4.5]\n\nb=1 NULL NULL 6\nb.lfill!()\nb;\n// output\n[1,3,4,6]\n\nt=table(1 NULL NULL 4 5 6 as id,2.1 2.2 NULL NULL 2.4 2.6 as val);\nlfill!(t);\nt;\n```\n\n| id | val      |\n| -- | -------- |\n| 1  | 2.1      |\n| 2  | 2.2      |\n| 3  | 2.266667 |\n| 4  | 2.333333 |\n| 5  | 2.4      |\n| 6  | 2.6      |\n\n相关函数：[bfill](https://docs.dolphindb.cn/zh/funcs/b/bfill.html), [bfill!](https://docs.dolphindb.cn/zh/funcs/b/bfill_.html), [lfill](https://docs.dolphindb.cn/zh/funcs/l/lfill.html)\n"
    },
    "license": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/license.html",
        "signatures": [
            {
                "full": "license([fileName], [pubKeyFile], [read=false])",
                "name": "license",
                "parameters": [
                    {
                        "full": "[fileName]",
                        "name": "fileName",
                        "optional": true
                    },
                    {
                        "full": "[pubKeyFile]",
                        "name": "pubKeyFile",
                        "optional": true
                    },
                    {
                        "full": "[read=false]",
                        "name": "read",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [license](https://docs.dolphindb.cn/zh/funcs/l/license.html)\n\n\n\n#### 语法\n\nlicense(\\[fileName], \\[pubKeyFile], \\[read=false])\n\n#### 详情\n\n显示 DolphinDB 的许可证信息。\n\n**Note:** 若不指定 *fileName*，则默认读取保存在内存中的 license 信息\n\n返回值说明：\n\n| 参数               | 含义                                                                            |\n| ---------------- | ----------------------------------------------------------------------------- |\n| authorization    | 授权的类型：trial（试用版）/test（测试版）/commercial（商业版）。                                   |\n| licenseType      | 许可证验证类型，有以下可选值：1：机器指纹绑定；2：在线验证；3：license server；0：其他方式                        |\n| maxMemoryPerNode | 每个节点的内存上限，单位为 GB。                                                             |\n| bindCores        | 进程绑定的 CPU 内核的编号（从0开始）。注意，仅当 bindCPU 为 true 时有效。                               |\n| maxCoresPerNode  | 每个节点允许最大 CPU 核数。                                                              |\n| clientName       | 客户名称。                                                                         |\n| port             | 为节点绑定的端口号。仅 License Server 和连接它的节点会返回此字段。                                     |\n| bindCPU          | 进程是否绑定 CPU。                                                                   |\n| expiration       | 许可证到期时间。                                                                      |\n| maxNodes         | 集群允许的最大节点数。                                                                   |\n| version          | server 的版本号。用户只能使用不高于 version 版本的 server。若为空，则对版本没有限制。                        |\n| modules          | 可用模块的编码。若为 13 则表示支持所有模块；若为 -1 则表示不支持任何模块。                                     |\n| moduleNames      | 与 *modules* 有关，返回具体的模块名。目前支持返回：orderbook, internalFunction, cep, gpu。社区版返回为空。 |\n| productKey       | 当前产品类型。目前支持返回：DOLPHIN, IOTBASIC, IOTPRO, SHARK, SWORDFISH。                    |\n\n#### 参数\n\n**fileName** 可选参数。需要指定的 license 文件的路径。\n\n**pubKeyFile** 可选参数。需要指定的公钥文件的路径。\n\n**read** 可选参数。布尔值，表示是否关闭对 license 文件的校检功能。默认值为 false，表示进行校检。\n\n#### 例子\n\n```\nlicense();\n```\n\n返回：\n\n```\nclientName->internal\nbindCPU->true\nmaxNodes->128\nmoduleNames-> orderbook internalFunction cep gpu\nproductKey->DOLPHIN\nversion->3.10\nmodules->15\nauthorization->trial\nmaxMemoryPerNode->512\nlicenseType->0\nbindCores->\nmaxCoresPerNode->128\nport->0\nexpiration->2024.09.30\n```\n"
    },
    "like": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/like.html",
        "signatures": [
            {
                "full": "like(X,Y)",
                "name": "like",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [like](https://docs.dolphindb.cn/zh/funcs/l/like.html)\n\n\n\n#### 语法\n\nlike(X,Y)\n\n#### 参数\n\n**X** 可以是字符串类型的标量/向量。\n\n**Y** 是一个字符串，通常包含通配符（例如 \"%\"）。\n\n#### 详情\n\n判断 *X* 中是否包含字符串 *Y*。比较操作是区分大小写的。\n\n#### 例子\n\n```\nlike(`ABCDEFG, `DE);\n// output\nfalse\n\nlike(`ABCDEFG, \"%DE%\");\n// output\ntrue\n\n\na=`IBM`ibm`MSFT`Goog`YHOO`ORCL;\nlike(a, \"%OO%\");\n// output\n[false,false,false,false,true,false]\na[like(a, \"%OO%\")];\n// output\n[\"YHOO\"]\n```\n\n`like` 可以搭配 `select` 使用，用于筛选字符串类型的列的范围：\n\n```\nt = table(`abb`aac`aaa as sym, 1.8 2.3 3.7 as price);\nselect * from t where sym like \"%aa%\";\n```\n\n| sym | price |\n| --- | ----- |\n| aac | 2.3   |\n| aaa | 3.7   |\n\n相关函数：[ilike](https://docs.dolphindb.cn/zh/funcs/i/ilike.html)\n"
    },
    "linearInterpolateFit": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/linearinterpolatefit.html",
        "signatures": [
            {
                "full": "linearInterpolateFit(X, Y, [fillValue], [sorted=false])",
                "name": "linearInterpolateFit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[fillValue]",
                        "name": "fillValue",
                        "optional": true
                    },
                    {
                        "full": "[sorted=false]",
                        "name": "sorted",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [linearInterpolateFit](https://docs.dolphindb.cn/zh/funcs/l/linearinterpolatefit.html)\n\n\n\n#### 语法\n\nlinearInterpolateFit(X, Y, \\[fillValue], \\[sorted=false])\n\n#### 详情\n\n为一组点集进行线性插值，支持内插（interpolate）和外插（extrapolate）两种模式。内插用于估计已知数据点之间的未知值，而外插则用于估计已知数据点范围之外的未知值。\n\n#### 参数\n\n**X**数值向量，表示用于插值的点的 x 坐标。注意：\n\n* X 的长度至少为 2，即至少需要两个已知数据点才能进行插值。\n\n* X中的值必须是唯一的且不可包含 NULL 值。\n\n**Y** 数值向量，表示用于插值的点的 y 坐标。注意：*Y* 和 *X* 的长度必须一致，且不包含 NULL 值。\n\n**fillValue** 可选参数，表示位于已知数据点范围之外的预测数据的赋值方式。支持以下两种方式：\n\n* 形如 `(below, above)` 的数值类型数据对，below 和 above 分别表示当预测数据小于 X 的最小值或大于 X 的最大值时的赋值。具体含义如下，Xmin 和 Xmax 分别表示输入参数 *X* 向量中的最小值和最大值。\n\n  * 当预测数据 Xnew < Xmin，将其赋值为 below；\n\n  * 当预测数据 Xnew > Xmax，将其赋值为 above。\n\n* 字符串 “extrapolate”，表示进行外插赋值，为默认值。\n\n**sorted** 可选参数，布尔值标量，表示输入参数 X 是否有序递增。\n\n* 如果为 true，则 *X* 必须是递增序列。\n\n* 如果为 false，函数内部会对 *X* 进行排序，并相应调整 *Y* 的顺序。默认为 false。\n\n#### 返回值\n\n返回一个字典，字典有以下成员：\n\n* modelName：字符串类型，表示模型名称，值为 “linearInterpolate”。\n\n* sortedX：Double 类型向量，表示对输入 *X* 进行升序排序后的向量。\n\n* sortedY：Double 类型向量，表示与 *sortedX* 所对应的 y 值。\n\n* fillValue：表示外插方式，即输入的 *fillValue* 参数值。\n\n* predict：模型的预测函数，`predict` 函数将返回在新 X 点处的线性插值结果。可通过 `model.predict(X)` 或 `predict(model, X)` 进行调用。其中：\n\n  * model：字典类型，即 `linearInterpolateFit` 的输出。\n\n  * X： 数值向量，表示需要求值的点的 x 坐标。\n\n#### 例子\n\n通过自定义函数 linspace 创建一组点集，对其进行线性插值。\n\n```\ndef linspace(start, end, num, endpoint=true){\n\tif(endpoint) return end$DOUBLE\\(num-1), start + end$DOUBLE\\(num-1)*0..(num-1)\n\telse return start + (end-start)$DOUBLE\\(num)*0..(num-1)\t\n}\nx = 0..9\ny = exp(-x/3.0)\nmodel = linearInterpolateFit(x, y, sorted=true)\n\n/*Output\nsortedX->[0.0,1.000000000000,2.000000000000,3.000000000000,4.000000000000,5.000000000000,6.000000000000,7.000000000000,8.000000000000,9.000000000000]\nmodelName->linearInterpolate\npredict->linearInterpolatePredict\nfillValue->extrapolate\nsortedY->[1.000000000000,0.716531310573,0.513417119032,0.367879441171,0.263597138115,0.188875602837,0.135335283236,0.096971967864,0.069483451222,0.049787068367]\n*/\n\n// 使用新 X 值进行预测  \nxnew = linspace(0,9,15,false)\nmodel.predict(xnew)\n\n//Output：[1,0.829918786344274,0.67590847226555,0.554039957340832,0.455202047888132,0.367879441171442,0.305310059338013,0.248652831060094,0.203819909893195,0.167459474997182,0.135335283236613,0.112317294013288,0.091474264536084,0.074981154551122,0.061604898080826]\n```\n"
    },
    "linearTimeTrend": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/linearTimeTrend.html",
        "signatures": [
            {
                "full": "linearTimeTrend(X, window)",
                "name": "linearTimeTrend",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [linearTimeTrend](https://docs.dolphindb.cn/zh/funcs/l/linearTimeTrend.html)\n\n\n\n#### 语法\n\nlinearTimeTrend(X, window)\n\nTA-lib 系列函数参数说明和窗口计算规则请参考: [TA-lib 系列](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 详情\n\n计算滑动线性回归，返回一个 tuple 类，包含两列，分别是 alpha 和 beta，对应 talib 中的 linearreg\\_intercept（线性回归截距）和 linearreg\\_slope（线性回归斜率指标）。\n\n#### 例子\n\n```\nx = 3 3 5 7 8 9 10 11 15 13 12 11 10\nprint linearTimeTrend(x,3)\n// output\n([,,2.666666666666666,3,5.166666666666667,7,8,9,9.5,12,14.833333333333333,13,12],[,,1,2,1.5,1,1,1,2.5,1,-1.5,-1,-1])\n```\n\n```\nn = 10\nt = table(09:00:00 + 1..n as time, rand(`A`B, n) as sym, rand(100.0, n) as val1, rand(1000..2000, n) as val2)\nselect time, sym, linearTimeTrend(val1, 3) as `alpha`beta from t\n```\n\n| time     | sym | alpha   | beta     |\n| -------- | --- | ------- | -------- |\n| 09:00:01 | B   |         |          |\n| 09:00:02 | A   |         |          |\n| 09:00:03 | A   | 85.0844 | -30.0688 |\n| 09:00:04 | B   | 49.3461 | 7.3621   |\n| 09:00:05 | B   | 30.4248 | 28.3589  |\n| 09:00:06 | A   | 83.106  | -7.7515  |\n| 09:00:07 | B   | 78.4412 | -17.7575 |\n| 09:00:08 | A   | 56.8575 | 4.4732   |\n| 09:00:09 | A   | 53.8492 | -6.0653  |\n| 09:00:10 | A   | 61.7888 | -4.5586  |\n"
    },
    "linprog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/linprog.html",
        "signatures": [
            {
                "full": "linprog(f, [A], [b], [Aeq], [beq], [lb], [ub], [method='simplex'])",
                "name": "linprog",
                "parameters": [
                    {
                        "full": "f",
                        "name": "f"
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[b]",
                        "name": "b",
                        "optional": true
                    },
                    {
                        "full": "[Aeq]",
                        "name": "Aeq",
                        "optional": true
                    },
                    {
                        "full": "[beq]",
                        "name": "beq",
                        "optional": true
                    },
                    {
                        "full": "[lb]",
                        "name": "lb",
                        "optional": true
                    },
                    {
                        "full": "[ub]",
                        "name": "ub",
                        "optional": true
                    },
                    {
                        "full": "[method='simplex']",
                        "name": "method",
                        "optional": true,
                        "default": "'simplex'"
                    }
                ]
            }
        ],
        "markdown": "### [linprog](https://docs.dolphindb.cn/zh/funcs/l/linprog.html)\n\n\n\n#### 语法\n\nlinprog(f, \\[A], \\[b], \\[Aeq], \\[beq], \\[lb], \\[ub], \\[method='simplex'])\n\n#### 详情\n\n求线性目标函数在约束条件下的最优解。具体模型如下：\n\n![linprog](https://docs.dolphindb.cn/zh/images/linprog.png)\n\n返回结果是具有两个元素的元组。第一个元素是目标函数的最小值，第二个元素是目标函数取最小值时，x的取值。\n\n#### 参数\n\n**f** 是线性规划中的一次项向量。\n\n**A** 是线性不等约束的系数矩阵。\n\n**b** 是线性不等约束的右端向量。\n\n**Aeq** 是线性等式约束的系数矩阵。\n\n**beq** 是线性等式约束的右端向量。\n\n**lb** 表示变量的下界。\n\n**ub** 表示变量的上界。\n\n**method** 是字符串，表示算法，目前支持 'simplex' 和 'interior-point'。推荐使用 simplex 算法，部分特殊场景下建议使用 interior-point 算法。\n\n#### linprog 函数的参数有以下要求：\n\n* *A* 和 *Aeq* 必须是列数相同的矩阵\n\n* *f*, *b* 和 *beq* 是向量\n\n* *lb* 和 *ub* 可以是标量，也可以是和x等长的向量。\n\n  * 若 *lb* 或 *ub* 是标量，则所有变量都受同一个下界或上界约束。若 *lb* 或 *ub* 为NULL，表示x无相应的下界或上界约束。\n\n  * 若 *lb* 或 *ub* 是向量，则x中的元素受 *lb* 或 *ub* 中相应位置的元素约束。若向量 *lb* 或 *ub* 中某元素为NULL，表示此位置的x元素无相应的下界或上界约束\n\n#### 例子\n\n例1. 求 x，y 满足以下约束条件时，目标函数 x+2y 的最小值。\n\n![linprog1](https://docs.dolphindb.cn/zh/images/linprog1.png)\n\n```\nf = [1, 2];\nA = [-1, -1]$1:2;\nb = [-2];\nub = 2;\nre = linprog(f, A, b, , , , ub);\n\nre[0];\n// output\n2\n\nre[1];\n// output\n[2,0]\n```\n\n下面详细解释如何获取上例中的 A, b 和 ub。不等式约束条件为 x+y>=2，而模型中的不等式约束条件的符号为<=，因此需要转换成 -x-y<=-2。因此，不等式约束条件的系数矩阵为 \\[-1,-1]$1:2，不等式约束条件的右端向量为-2。变量 x, y 的上界都是2，因此 ub 可用标量表示。\n\n例2. 求 x，y 满足以下约束条件时，目标函数 -3x1-2x2 的最小值。\n\n![linprog2](https://docs.dolphindb.cn/zh/images/linprog2.png)\n\n```\nf = [-3, -2];\nA = [2, 1, 1, 1]$2:2;\nb = [10, 8];\nub = [4, NULL];\nre = linprog(f, A, b, , , , ub);\n\nre[0];\n// output\n-18\n\nre[1];\n// output\n[2,6]\n```\n\n相关函数：[scs](https://docs.dolphindb.cn/zh/funcs/s/scs.html), [quadprog](https://docs.dolphindb.cn/zh/funcs/q/quadprog.html)\n"
    },
    "listRemotePlugins": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/listRemotePlugins.html",
        "signatures": [
            {
                "full": "listRemotePlugins([pluginName], [pluginServerAddr])",
                "name": "listRemotePlugins",
                "parameters": [
                    {
                        "full": "[pluginName]",
                        "name": "pluginName",
                        "optional": true
                    },
                    {
                        "full": "[pluginServerAddr]",
                        "name": "pluginServerAddr",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [listRemotePlugins](https://docs.dolphindb.cn/zh/funcs/l/listRemotePlugins.html)\n\n#### 语法\n\nlistRemotePlugins(\\[pluginName], \\[pluginServerAddr])\n\n#### 详情\n\n返回一个表，显示当前 DolphinDB 所支持的插件和其对应的版本信息。\n\n**Note:** 使用该命令获取的插件信息取决于：\n\n* DolphinDB server 版本\n* 操作系统\n\n如果不指定 pluginName，则返回所有插件；如果指定 pluginName，则返回指定插件；如果指定的插件不存在，则返回空。\n\n#### 参数\n\n**pluginName** 可选，STRING 类型，用于指定插件名称。\n\n**pluginServerAddr** 可选，STRING 类型，用于指定插件仓库的 HTTP 地址。如果不配置该参数，使用默认的 HTTP 地址：\"<http://plugins.dolphindb.cn/plugins\"。如果> DolphinDB 服务位于国外，建议填写 \"<http://plugins.dolphindb.com/plugins>\" 以提高查询速度。\n\n#### 例子\n\n* 列出插件仓库所有可用插件：\n\n  ```\n  listRemotePlugins()\n  ```\n\n  均会返回类似以下的插件列表：\n\n  | PluginName  | PluginVersion      |\n  | ----------- | ------------------ |\n  | hdf5        | *\\<PluginVersion>* |\n  | matchEngine | *\\<PluginVersion>* |\n  | mongodb     | *\\<PluginVersion>* |\n  | mqtt        | *\\<PluginVersion>* |\n  | mseed       | *\\<PluginVersion>* |\n  | mysql       | *\\<PluginVersion>* |\n  | nsq         | *\\<PluginVersion>* |\n  | odbc        | *\\<PluginVersion>* |\n  | opc         | *\\<PluginVersion>* |\n  | opcua       | *\\<PluginVersion>* |\n  | zip         | *\\<PluginVersion>* |\n\n  其中 *\\<PluginVersion>* 为插件的版本信息，例如：2.00.11。\n\n* 返回指定插件及其版本信息。例如，获取 MySQL 插件的版本信息：\n\n  ```\n  listRemotePlugins(\"mysql\")\n  ```\n\n  返回：\n\n  | PluginName | PluginVersion |\n  | :--------- | :------------ |\n  | mysql      | 2.00.11       |\n\n\n\n**Related information**\n\n[installPlugin](https://docs.dolphindb.cn/zh/funcs/i/installPlugin.html)\n\n[loadPlugin](https://docs.dolphindb.cn/zh/funcs/l/loadPlugin.html)\n"
    },
    "listTables": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/listTables.html",
        "signatures": [
            {
                "full": "listTables(dbUrl)",
                "name": "listTables",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    }
                ]
            }
        ],
        "markdown": "### [listTables](https://docs.dolphindb.cn/zh/funcs/l/listTables.html)\n\n\n\n#### 语法\n\nlistTables(dbUrl)\n\n#### 参数\n\n**dbUrl** 是一个字符串，表示分布式数据库的路径。\n\n#### 详情\n\n返回一个表对象，包含两列，分别为数据库中的表名和物理索引名。\n\n**Note:** 只有表级分区具有物理索引。\n\n#### 例子\n\n```\nlistTables(dbPath)\n```\n\n| tableName | physicalIndex |\n| --------- | ------------- |\n| pt1       | 1By           |\n| pt        | 1Bw           |\n"
    },
    "loadBackup": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadBackup.html",
        "signatures": [
            {
                "full": "loadBackup(backupDir, dbPath, partition, tableName)",
                "name": "loadBackup",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "partition",
                        "name": "partition"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [loadBackup](https://docs.dolphindb.cn/zh/funcs/l/loadBackup.html)\n\n\n\n#### 语法\n\nloadBackup(backupDir, dbPath, partition, tableName)\n\n#### 参数\n\n**backupDir** 是字符串，表示存放备份数据的目录。\n\n**dbPath** 是字符串，表示 DFS 数据库的路径，例如 `\"dfs://demo\"`。\n\n**partition** 是字符串，表示分区在数据库内的路径，例如 `\"/20190101/GOOG\"`。\n\n**Note:** 若使用 2.00.4 到 2.00.6 版本 server，对表级分区数据进行备份和恢复时，该参数必须指定路径到物理索引（可通过函数 [listTables](https://docs.dolphindb.cn/zh/funcs/l/listTables.html) 获取），例如分区 `\"/compoDB/20170807/0_50\"` 下表的物理索引为8，则 *partition* 需指定为 `\"/compoDB/20170807/0_50/8\"`。\n\n**tableName** 是字符串，表示分布式表的名称。\n\n#### 详情\n\n加载指定分布式表中某个分区的备份数据。该函数必须要用户登录后才能执行。\n\n请注意，目前该函数只支持加载 SQL 元代码（即 [backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html) 时指定 *sqlObj* 参数）备份的数据。\n\n#### 例子\n\n```\nloadBackup(\"/home/DolphinDB/backup\",\"dfs://valuedb\", \"/200001M\",\"pt\");\n```\n\n输出返回：\n\n| month    | x   |\n| -------- | --- |\n| 2000.01M | 1   |\n| 2000.01M | 205 |\n| 2000.01M | 409 |\n| 2000.01M | 613 |\n| 2000.01M | 817 |\n"
    },
    "loadDistributedInMemoryTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadDistributedInMemoryTable.html",
        "signatures": [
            {
                "full": "loadDistributedInMemoryTable(tableName)",
                "name": "loadDistributedInMemoryTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [loadDistributedInMemoryTable](https://docs.dolphindb.cn/zh/funcs/l/loadDistributedInMemoryTable.html)\n\n\n\n#### 语法\n\nloadDistributedInMemoryTable(tableName)\n\n#### 参数\n\n**tableName** 字符串标量，表示分布式共享内存表的名称。\n\n#### 详情\n\n返回分布式共享内存表的句柄。该函数只能在数据节点/计算节点上执行。\n\n#### 例子\n\n```\npt = createDistributedInMemoryTable(`dt, `time`id`value, `DATETIME`INT`LONG, HASH, [INT, 2],`id)\ntime = take(2021.08.20 00:00:00..2021.08.30 00:00:00, 40);\nid = 0..39;\nvalue = rand(100, 40);\ntmp = table(time, id, value);\n\npt = loadDistributedInMemoryTable(`dt)\npt.append!(tmp);\nselect * from pt;\n```\n\n相关函数：[dropDistributedInMemoryTable](https://docs.dolphindb.cn/zh/funcs/d/dropDistributedInMemoryTable.html), [createDistributedInMemoryTable](https://docs.dolphindb.cn/zh/funcs/c/createDistributedInMemoryTable.html)\n"
    },
    "loadIPCInMemoryTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadIPCInMemoryTable.html",
        "signatures": [
            {
                "full": "loadIPCInMemoryTable(tableName)",
                "name": "loadIPCInMemoryTable",
                "parameters": [
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [loadIPCInMemoryTable](https://docs.dolphindb.cn/zh/funcs/l/loadIPCInMemoryTable.html)\n\n\n\n#### 语法\n\nloadIPCInMemoryTable(tableName)\n\n#### 参数\n\n**tableName** 字符串，表示跨进程共享内存表的名称。\n\n#### 详情\n\n加载跨进程共享内存表，并返回该表的句柄。\n\n注意：此函数仅适用于 Linux 系统。\n\n#### 例子\n\n加载函数 `createIPCInMemoryTable` 例子中创建的表 ipc\\_table。\n\n```\nipc_t = loadIPCInMemoryTable(\"ipc_table\")\nipc_t\n// output\ntimestamp temperature\n```\n"
    },
    "loadModel": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadModel.html",
        "signatures": [
            {
                "full": "loadModel(file)",
                "name": "loadModel",
                "parameters": [
                    {
                        "full": "file",
                        "name": "file"
                    }
                ]
            }
        ],
        "markdown": "### [loadModel](https://docs.dolphindb.cn/zh/funcs/l/loadModel.html)\n\n\n\n#### 语法\n\nloadModel(file)\n\n#### 参数\n\n**file** 是模型所在的本地文件的路径。\n\n#### 详情\n\n把模型加载到内存中，以字典的形式返回模型。\n\n```\nx1 = rand(100.0, 100)\nx2 = rand(100.0, 100)\nb0 = 6\nb1 = 1\nb2 = -2\nerr = norm(0, 10, 100)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(x1, x2, y)\nmodel = randomForestRegressor(sqlDS(<select * from t>), `y, `x1`x2)\nsaveModel(model, \"/home/DolphinDB/Data/regressionModel.txt\");\n\nmodel = loadModel(\"/home/DolphinDB/Data/regressionModel.txt\")\nyhat = predict(model, t);\n```\n"
    },
    "loadModule": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadModule.html",
        "signatures": [
            {
                "full": "loadModule(name, [moduleDir])",
                "name": "loadModule",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[moduleDir]",
                        "name": "moduleDir",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [loadModule](https://docs.dolphindb.cn/zh/funcs/l/loadModule.html)\n\n\n\n#### 语法\n\nloadModule(name, \\[moduleDir])\n\n#### 参数\n\n**name** 是一个字符串，表示模块的名称。\n\n**moduleDir** 是一个字符串，表示模块 dos 文件或 dom 文件所在的目录。\n\n#### 详情\n\n将模块或插件中的函数加载成系统的内置函数。如果加载的模块依赖了其他模块，系统会一并加载其他模块。该函数必须要用户登录后才能执行。\n\n系统启动时，根据配置项 *moduleDir* 的设置，寻找并决定模块所在目录：\n\n* 配置项 *moduleDir* 设置为一个绝对目录，则该目录即为搜索模块所在的目录。\n\n* 配置项 *moduleDir* 设置为一个相对目录，系统会依次在 *HOMEDIR*，*WORKDIR* 和 *EXECDIR* 三个目录下搜索。如果找到了，就以该目录作为 *moduleDir*；如果搜索不到，就以 *\\<HOMEDIR>* + “/” + *\\<moduleDir>* 作为 modules 的绝对目录\n\n* 配置项 *moduleDir* 没有设置，搜索方式同相对目录。\n\n如果 *modules* 目录中包含同名的 dos 文件和 dom 文件，系统仅会加载 dom 文件。\n\n**Note:** 该函数只能在系统的初始化脚本（默认为 *dolphindb.dos* 文件）中使用。\n\n`loadModule` 函数与配置参数 *preloadModules* 的功能相同。\n\n#### 例子\n\n例1. 加载模块\n\n```\nloadModule(\"ta\");\n\nloadModule(\"system::log::fileLog\");\n```\n\n例2. 加载插件\n\n```\nloadModule(\"plugins::mysql\");\n\nloadModule(\"plugins::odbc\");\n```\n\n**Related information**\n\n[saveModule](https://docs.dolphindb.cn/zh/funcs/s/saveModule.html)\n"
    },
    "loadModuleFromScript": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadmodulefromscript.html",
        "signatures": [
            {
                "full": "loadModuleFromScript(moduleNamespace, moduleScript, [reload=false])",
                "name": "loadModuleFromScript",
                "parameters": [
                    {
                        "full": "moduleNamespace",
                        "name": "moduleNamespace"
                    },
                    {
                        "full": "moduleScript",
                        "name": "moduleScript"
                    },
                    {
                        "full": "[reload=false]",
                        "name": "reload",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [loadModuleFromScript](https://docs.dolphindb.cn/zh/funcs/l/loadmodulefromscript.html)\n\n#### 语法\n\nloadModuleFromScript(moduleNamespace, moduleScript, \\[reload=false])\n\n#### 参数\n\n**moduleNamespace**：字符串标量或向量，表示模块的命名空间。如果模块之间存在依赖，则需要输入全部模块的命名空间。\n\n**moduleScript**：字符串标量或向量，表示模块的脚本。\n\n**reload**：布尔标量，表示是否重新加载模块,默认值为 false。如果之前已加载同名模块，要使更新的 *moduleScript* 生效，必须将此参数设置为 true。\n\n#### 详情\n\n解析包含模块定义的字符串，并加载该模块。如果模块脚本中包含模块引用，则无需关注其依赖顺序，函数会自动解析。\n\n#### 例子\n\n```\nmoduleName = \"test\"\nmoduleScript = \"module test \\n def testFunc(x,y){ return x+y }\"\nloadModuleFromScript(moduleName,moduleScript)\ngo\ntest::testFunc(2,3)\n// output\n5\n```\n\n如果模块脚本中包含模块引用：\n\n```\nmoduleNames = [\"test2\",\"test1\"]\nmoduleScripts = [\n\"module test2\nuse test1\ndef func4(x,y){\n    return func1(x) + func2(y)\n}\n\",\n\"module test1\ndef func1(x){\n    return x+1\n}\ndef func2(x){\n    return x+2\n}\ndef func3(x){\n    print(func1(x)+func2(x))\n}\n\"\n]\nloadModuleFromScript(moduleNames,moduleScripts)\ngo\ntest1::func3(2)\n// output\n7\ntest2::func4(2,3)\n// output\n8\n```\n\n"
    },
    "loadMvccTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadMvccTable.html",
        "signatures": [
            {
                "full": "loadMvccTable(path, tableName)",
                "name": "loadMvccTable",
                "parameters": [
                    {
                        "full": "path",
                        "name": "path"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [loadMvccTable](https://docs.dolphindb.cn/zh/funcs/l/loadMvccTable.html)\n\n\n\n#### 语法\n\nloadMvccTable(path, tableName)\n\n#### 参数\n\n**path** 是一个字符串，表示绝对路径或相对路径。\n\n**tableName** 是一个字符串，表示表名。\n\n#### 详情\n\n把磁盘上可并发读写的表加载到内存中。\n\n#### 例子\n\n```\nn=5\nsyms=`IBM`C`MS`MSFT`JPM`ORCL`FB`GE\ntimestamp=09:30:00+rand(18000,n)\nsym=rand(syms,n)\nqty=100*(1+rand(100,n))\nprice=5.0+rand(100.0,n)\ntemp=table(timestamp,sym,qty,price)\nt1= mvccTable(1:0,`timestamp`sym`qty`price,[TIMESTAMP,SYMBOL,INT,DOUBLE],\"/home/DolphinDB/Data\",\"t1\")\nt1.append!(temp);\n\nloadMvccTable(\"/home/DolphinDB/Data\",\"t1\");\n```\n\n| timestamp               | sym  | qty  | price     |\n| ----------------------- | ---- | ---- | --------- |\n| 1970.01.01T00:00:39.091 | MSFT | 4500 | 99.808702 |\n| 1970.01.01T00:00:35.293 | FB   | 3600 | 26.644715 |\n| 1970.01.01T00:00:36.334 | MSFT | 3800 | 66.754334 |\n| 1970.01.01T00:00:40.362 | ORCL | 4800 | 15.480288 |\n| 1970.01.01T00:00:35.565 | MSFT | 1700 | 23.107408 |\n"
    },
    "loadNpy": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadNpy.html",
        "signatures": [
            {
                "full": "loadNpy(fileName)",
                "name": "loadNpy",
                "parameters": [
                    {
                        "full": "fileName",
                        "name": "fileName"
                    }
                ]
            }
        ],
        "markdown": "### [loadNpy](https://docs.dolphindb.cn/zh/funcs/l/loadNpy.html)\n\n\n\n#### 语法\n\nloadNpy(fileName)\n\n#### 参数\n\n**filename** 是字符串，表示 npy 文件的路径。\n\n#### 详情\n\n读取 Python Numpy 的 npy 格式二进制文件，并转化为 DolphinDB 的向量或矩阵。Numpy 对象中的 NaN 值会被转化为 DolphinDB 的 NULL 值。\n\n#### 例子\n\n在 Python 中导出 npy 格式文件：\n\n```\nimport numpy as np\nnp.save(\"intVec.npy\", np.array([5,6,1,3,4,8]))\nnp.save(\"doubleMat.npy\", np.array([[1.5,5.6,-7.87],[-1.0,3.4,4.5]]))\n```\n\n在 DolphinDB 中加载 npy 文件：\n\n```\nloadNpy(\"intVec.npy\");\n```\n\n输出返回：\\[5,6,1,3,4,8]\n\n```\nloadNpy(\"doubleMat.npy\");\n```\n\n输出返回：\n\n| #0  | #1  | #2    |\n| --- | --- | ----- |\n| 1.5 | 5.6 | -7.87 |\n| -1  | 3.4 | 4.5   |\n\n相关函数：[saveAsNpy](https://docs.dolphindb.cn/zh/funcs/s/saveAsNpy.html)\n"
    },
    "loadNpz": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadNpz.html",
        "signatures": [
            {
                "full": "loadNpz(fileName)",
                "name": "loadNpz",
                "parameters": [
                    {
                        "full": "fileName",
                        "name": "fileName"
                    }
                ]
            }
        ],
        "markdown": "### [loadNpz](https://docs.dolphindb.cn/zh/funcs/l/loadNpz.html)\n\n\n\n#### 语法\n\nloadNpz(fileName)\n\n#### 参数\n\n**filename** 是字符串，表示 npz 文件的路径。\n\n#### 详情\n\n读取 Python Numpy 的 npz 格式二进制文件，并转化为 DolphinDB 的对象。Numpy 对象中的 NaN 值会被转化为 DolphinDB 的 NULL 值。\n\nPython np.array 和 DolphinDB 对象对照表：\n\n支持转换的数据类型有：BOOL, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE, STRING（只支持一维）\n\n| numpy array | DolphinDB object |\n| ----------- | ---------------- |\n| 一维          | 向量               |\n| 二维          | 矩阵               |\n| 三维          | 元组。元组的每一个元素是一个矩阵 |\n\n#### 例子\n\n在 Python 中导出 npz 格式文件：\n\n```\nimport numpy as np\na = np.array([[[97, 98]]], dtype=np.int8)\na1 = np.array(['133', '211', '3dds', 'ddd4', 'e5', 'w6'])\nb1 = np.array([[0.7, 0.8, 9.2], [0, np.nan, np.nan], [1.5, 2.8, 0.2]])\nc1 = np.array([[[0.2, 3.3], [1.9, 4.3]], [[5, 6], [1, 2]]])\nnp.savez('my_path/array_save.npz', char=a, a1=a1, b1=b1, c1=c1)\n```\n\n在 DolphinDB 中加载 npz 文件：\n\n```\npath=\"my_path/array_save.npz\"\nloadNpz(path)\n// output\na1->[133,211,3dds,ddd4,e5,w6]\nchar->(#0  #1\n'a' 'b'\n)\nc1->(#0  #1\n0.2 3.3\n1.9 4.3\n,#0 #1\n5  6\n1  2\n)\nb1->\n#0  #1  #2\n0.7 0.8 9.2\n0\n1.5 2.8 0.2\n```\n\n相关函数：[loadNpy](https://docs.dolphindb.cn/zh/funcs/l/loadNpy.html)\n"
    },
    "loadPlugin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadPlugin.html",
        "signatures": [
            {
                "full": "loadPlugin(filepath)",
                "name": "loadPlugin",
                "parameters": [
                    {
                        "full": "filepath",
                        "name": "filepath"
                    }
                ]
            }
        ],
        "markdown": "### [loadPlugin](https://docs.dolphindb.cn/zh/funcs/l/loadPlugin.html)\n\n#### 语法\n\nloadPlugin(filepath)\n\n#### 参数\n\n**filepath** 是文本文件的绝对路径。例如：`/home/DolphinDB_Linux64_V2.00.10/server/plugins/mysql/PluginMySQL.txt`。\n\n自2.00.11版本起，可以将其指定为插件名（大小写敏感）。系统会根据插件名称和配置项 *pluginDir* 拼接出插件的加载路径。\n\n#### 详情\n\n加载 DolphinDB 插件。该函数必须要用户登录后才能执行。\n\n**Note:**\n\n* 在产品体验阶段，如果未自行创建用户或管理员账号，可以使用 DolphinDB 提供的初始管理员账号（admin）及密码（123456）。在生产环境中，务必使用具备中等以上安全强度的用户或管理员密码。\n\n* 加载前请确保有对应插件的使用权限。收费插件需要另行购买。\n\n来自 DolphinDB 插件市场的插件在使用 [installPlugin](https://docs.dolphindb.cn/zh/funcs/i/installPlugin.html) 命令安装后，会在`<server路径>/plugins/<插件名称>`路径下生成一个命名方式为 \"Plugin\" + \"插件名称\"的 txt 格式的插件描述文件和相关的二进制文件（Windows 版本下为 .dll，Linux 版本下为 .so）。例如，安装在 Windows 版本 DolphinDB server 2.00.10 的 odbc 插件描述文件存储于：\n\n```\n../DolphinDB_Win64_V2.00.10/server/plugins/odbc/PluginODBC.txt\n```\n\n该文件包含以下内容：\n\n```\nodbc,libPluginODBC.dll,2.00.10\nodbcQuery,query,system,2,5,0\nodbcConnect,connect,system,1,2,0\nodbcClose,close,system,1,1,0\nodbcExecute,execute,system,2,2,0\nodbcAppend,append,system,3,5,0\n```\n\n该文件格式如下：\n\n* 第一行：插件名称、lib 文件、版本号，用 “,” 分隔；\n* 其他行用于描述该插件提供的函数，依次包含以下信息：lib 文件中的某个函数的名称、对应的 DolphinDB 函数的名称、函数的类型（operator 表示运算符，system 表示系统函数）、函数所需的最小参数个数、函数所需的最大参数个数、是否为聚合函数（1 表示聚合函数，0 表示非聚合函数）、是否为序列函数（1表示序列函数，0表示非序列函数）。\n\n#### 例子\n\n**加载来自插件市场的插件**\n\n以在 Windows 操作系统上安装 MQTT 插件为例，加载方法有两种：\n\n* 使用插件描述文件的绝对路径加载插件：\n\n  ```\n  installPlugin(\"mqtt\") \n  loadPlugin(\"D:/TEST/DolphinDB_Win64_V2.00.10/server/plugins/mqtt/PluginMQTT.txt\")\n  ```\n\n  **Note:** 在 Windows 操作系统中使用绝对路径加载插件时，务必确保路径中使用\"/\"代替\"\\\\\"。\n\n* 或指定插件名称：\n\n  ```\n  installPlugin(\"mqtt\") \n  loadPlugin(\"mqtt\")\n  ```\n\n**加载自行编译的插件**\n\n以 DolphinDB Linux 版本的 odbc 插件为例，其描述文件 odbc.txt 内容如下：\n\n```\nodbc,libPluginODBC.so,2.00.10\nodbcQuery,query,system,2,5,0\nodbcConnect,connect,system,1,2,0\nodbcClose,close,system,1,1,0\nodbcExecute,execute,system,2,2,0\nodbcAppend,append,system,3,5,0\n\n```\n\nodbc 插件提供了 5 个函数：`query`, `connect`, `close`, `execute` 和 `append`，需要加载插件后才能使用。下面的例子介绍了如何加载 odbc 插件，并调用 odbc 插件提供的函数。\n\n```\nloadPlugin(\"/home/DolphinDB/server/plugins/odbc/odbc.txt\")\n//或者通过插件名进行加载\nloadPlugin(\"odbc\")\nuse odbc\nConnStr=\"Driver=MySQL;Data Source=odbc_test;Server=127.0.0.1;Uid=root;Pwd=123456;Database=odbc_test\"\nconn=connect(connStr)      // 创建 MySQL 连接\n\nt=query(conn,\"select * from test\")\nclose(conn)\n```\n\n\n\n**Related information**\n\n[installPlugin](https://docs.dolphindb.cn/zh/funcs/i/installPlugin.html)\n\n[listRemotePlugins](https://docs.dolphindb.cn/zh/funcs/l/listRemotePlugins.html)\n"
    },
    "loadRecord": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadRecord.html",
        "signatures": [
            {
                "full": "loadRecord(filename, schema, [skipBytes=0], [count])",
                "name": "loadRecord",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "schema",
                        "name": "schema"
                    },
                    {
                        "full": "[skipBytes=0]",
                        "name": "skipBytes",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[count]",
                        "name": "count",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [loadRecord](https://docs.dolphindb.cn/zh/funcs/l/loadRecord.html)\n\n\n\n#### 语法\n\nloadRecord(filename, schema, \\[skipBytes=0], \\[count])\n\n#### 参数\n\n**filename** 是一个字符串，表示文件路径。\n\n**schema** 是一个元组。元组中的每个向量表示一个列的名称、数据类型。如果该列是字符串，还需指定字符串长度。如果长度不足，需在最后补0达到指定长度。\n\n**skipBytes** 是一个非负整数，表示从文件头开始忽略的字节数。它是一个可选参数，默认值为0。\n\n**count** 是一个正整数，表示要加载的记录数。如果没有指定，表示加载所有记录。\n\n#### 详情\n\n将每个字段长度固定的行式二进制文件加载到内存中。\n\n#### 例子\n\n一个二进制文件 sample.bin，包含46个字段，内容如下：\n\n```\n0000000 3036 3131 3737 532e 0048 0000 0000 0000\n0000010 0000 0000 0000 0000 0000 0000 0000 0000\n0000020 16b6 0134 d160 0578 0000 0000 0000 0000\n0000030 0000 0000 3333 4137 0000 0000 0000 0000\n0000040 0000 0000 0000 0000 0000 0000 0000 0000\n0000050 0000 0000 0000 0000 0000 0000 00c8 0000\n0000060 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000080 0000 0000 3333 4137 0000 0000 0000 0000\n0000090 0000 0000 0000 0000 0000 0000 0000 0000\n00000a0 0000 0000 0000 0000 0000 0000 00c8 0000\n00000b0 0384 0000 0000 0000 0000 0000 0000 0000\n00000c0 0000 0000 0000 0000 0000 0000 0000 0000\n00000d0 0000 0000 3036 3131 3737 532e 0048 0000\n00000e0 0000 0000 0000 0000 0000 0000 0000 0000\n00000f0 0000 0000 16b6 0134 ea58 057b 0000 0000\n0000100 0000 0000 0000 0000 3333 4137 0000 0000\n0000110 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000130 00c8 0000 0000 0000 0000 0000 0000 0000\n0000140 0000 0000 0000 0000 0000 0000 0000 0000\n0000150 0000 0000 0000 0000 3333 4137 0000 0000\n0000160 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000180 00c8 0000 0b54 0000 0000 0000 0000 0000\n0000190 0000 0000 0000 0000 0000 0000 0000 0000\n00001a0 0000 0000 0000 0000 3036 3131 3737 532e\n00001b0 0048 0000 0000 0000 0000 0000 0000 0000\n00001c0 0000 0000 0000 0000 16b6 0134 82b0 057c\n00001d0 0000 0000 0000 0000 0000 0000 3333 4137\n00001e0 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000200\n```\n\n现将该文件导入到 DolphinDB。其中 code 列是字符串，在二进制文件中的长度是固定的，为32。\n\n```\nschema = [(\"code\", SYMBOL, 32),(\"date\", INT),(\"time\", INT),(\"last\", FLOAT),(\"volume\", INT),(\"value\", FLOAT),(\"ask1\", FLOAT),(\"ask2\", FLOAT),(\"ask3\", FLOAT),(\"ask4\", FLOAT),(\"ask5\", FLOAT),(\"ask6\", FLOAT),(\"ask7\", FLOAT),(\"ask8\", FLOAT),(\"ask9\", FLOAT),(\"ask10\", FLOAT),(\"ask_size1\", INT),(\"ask_size2\", INT),(\"ask_size3\", INT),(\"ask_size4\", INT),(\"ask_size5\", INT),(\"ask_size6\", INT),(\"ask_size7\", INT),(\"ask_size8\", INT),(\"ask_size9\", INT),(\"ask_size10\", INT),(\"bid1\", FLOAT),(\"bid2\", FLOAT),(\"bid3\", FLOAT),(\"bid4\", FLOAT),(\"bid5\", FLOAT),(\"bid6\", FLOAT),(\"bid7\", FLOAT),(\"bid8\", FLOAT),(\"bid9\", FLOAT),(\"bid10\", FLOAT),(\"bid_size1\", INT),(\"bid_size2\", INT),(\"bid_size3\", INT),(\"bid_size4\", INT),(\"bid_size5\", INT),(\"bid_size6\", INT),(\"bid_size7\", INT),(\"bid_size8\", INT),(\"bid_size9\", INT),(\"bid_size10\", INT)];\nt=loadRecord(\"/home/DolphinDB/sample.bin\",schema);\nselect code, date,time,last,volume,value,ask1,ask_size1,bid1,bid_size1 from t;\n```\n\n| code      | date     | time     | last | volume | value | ask1  | ask\\_size1 | bid1  | bid\\_size1 |\n| --------- | -------- | -------- | ---- | ------ | ----- | ----- | ---------- | ----- | ---------- |\n| 601177.SH | 20190902 | 91804000 | 0    | 0      | 0     | 11.45 | 200        | 11.45 | 200        |\n| 601177.SH | 20190902 | 92007000 | 0    | 0      | 0     | 11.45 | 200        | 11.45 | 200        |\n"
    },
    "loadTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadTable.html",
        "signatures": [
            {
                "full": "loadTable(database, tableName, [partitions], [memoryMode=false])",
                "name": "loadTable",
                "parameters": [
                    {
                        "full": "database",
                        "name": "database"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[partitions]",
                        "name": "partitions",
                        "optional": true
                    },
                    {
                        "full": "[memoryMode=false]",
                        "name": "memoryMode",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [loadTable](https://docs.dolphindb.cn/zh/funcs/l/loadTable.html)\n\n\n\n#### 语法\n\nloadTable(database, tableName, \\[partitions], \\[memoryMode=false])\n\n#### 参数\n\n**database** 字符串，表示数据库的路径，也可以是数据库句柄。可以是分布式数据库或本地磁盘数据库。\n\n**tableName** 字符串，表示表的名称，它需要使用反引号(\\`)或双引号。\n\n**partitions** 标量或向量，表示要加载的分区。注意，只有本地磁盘数据库支持该参数，分布式数据库不支持该参数。\n\n**memoryMode** 布尔值，表示是否把数据加载到内存。如果 *memoryMode* =false，表示只加载元数据到内存；如果 *memoryMode* =true， 表示将实际数据加载到内存。注意，只有本地磁盘数据库支持该参数，分布式数据库不支持该参数。对于分布式数据库，只将元数据加载到内存中。\n\n#### 详情\n\n将数据加载到内存中。\n\n* 对于分布式数据库，返回包含元数据的表对象。\n\n* 对于本地磁盘数据库，如果 *memoryMode* =false，返回包含元数据的表对象；如果 *memoryMode* =true，返回包含实际数据的内存分区表。\n\n#### 例子\n\n##### 例1. 分布式数据库\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt1=table(ID, date, x);\n\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID=database(, RANGE, 0 50 100);\ndb = database(\"dfs://compoDB\", COMPO, [dbDate, dbID]);\npt = db.createPartitionedTable(t1, `pt, `date`ID).append!(t1)\n\nt2=table(0..100 as ID,take(2017.08.07..2017.08.11,101) as date)\ndt = db.createTable(t2, `dt).append!(t2)\n```\n\n* 加载维度表：\n\n```\ntmp = loadTable(\"dfs://compoDB\", `dt)\nselect count(*) from tmp\n```\n\n| count |\n| ----- |\n| 101   |\n\n* 加载分区表：\n\n```\ntmp = loadTable(\"dfs://compoDB\", `pt)\nselect count(*) from tmp\n```\n\n| count   |\n| ------- |\n| 1000000 |\n\n* 对于分布式数据库，`loadTable` 函数不支持加载指定分区的数据。如果需要将某些分区的数据加载到内存中，可以在 SQL 语句中指定过滤条件。\n\n```\ntmp = loadTable(\"dfs://compoDB\", `pt)\nselect * from tmp where date=2017.08.07\n```\n\n对于内存的分区表，我们可以执行一些函数，如 [update!](https://docs.dolphindb.cn/zh/funcs/u/update_.html), [drop!](https://docs.dolphindb.cn/zh/funcs/d/dropColumns_.html), [rename!](https://docs.dolphindb.cn/zh/funcs/r/rename_.html), [sortBy!](https://docs.dolphindb.cn/zh/funcs/s/sortBy_.html)。\n"
    },
    "loadTableBySQL": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadTableBySQL.html",
        "signatures": [
            {
                "full": "loadTableBySQL(sql)",
                "name": "loadTableBySQL",
                "parameters": [
                    {
                        "full": "sql",
                        "name": "sql"
                    }
                ]
            }
        ],
        "markdown": "### [loadTableBySQL](https://docs.dolphindb.cn/zh/funcs/l/loadTableBySQL.html)\n\n\n\n#### 语法\n\nloadTableBySQL(sql)\n\n#### 参数\n\n**sql** 是表示 SQL 查询的元代码。它可以用 WHERE 子句来过滤分区或记录行，也可以用 SELECT 语句选择包括计算列在内的列，但不能包含 TOP 子句、GROUP BY 子句、 ORDER BY 子句、CONTEXT BY 子句和 LIMIT 子句。\n\n#### 详情\n\n把分区表中满足 SQL 查询的记录行加载到内存中。返回的是分区的内存表，其分区机制与分区表一致。\n\n#### 例子\n\n```\nn=1000000\nt=table(rand('A'..'Z',n) as sym, 2000.01.01+rand(365,n) as date, 10.0+rand(2.0,n) as price1, 100.0+rand(20.0,n) as price2, rand(10,n) as qty1, rand(100,n) as qty2)\n\ndb = database(\"dfs://tradeDB\", VALUE, 'A'..'Z')\ntrades=db.createPartitionedTable(t,`trades,`sym).append!(t)\n\nsample=select * from loadTableBySQL(<select * from trades where date between 2000.03.01 : 2000.05.01>)\nsample=select * from loadTableBySQL(<select sym, date, price1, qty1 from trades where date between 2000.03.01 : 2000.05.01>)\n\ndates = 2000.01.16 2000.02.14 2000.08.01\nst = sql(<select sym, date, price1, qty1>, trades, expr(<date>, in, dates))\nsample = select * from loadTableBySQL(st)\n\ncolNames =`sym`date`qty2`price2\nst= sql(sqlCol(colNames), trades)\nsample = select * from loadTableBySQL(st)\n```\n"
    },
    "loadText": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadText.html",
        "signatures": [
            {
                "full": "loadText(filename, [delimiter], [schema], [skipRows=0], [arrayDelimiter], [containHeader], [arrayMarker])",
                "name": "loadText",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    },
                    {
                        "full": "[schema]",
                        "name": "schema",
                        "optional": true
                    },
                    {
                        "full": "[skipRows=0]",
                        "name": "skipRows",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[arrayDelimiter]",
                        "name": "arrayDelimiter",
                        "optional": true
                    },
                    {
                        "full": "[containHeader]",
                        "name": "containHeader",
                        "optional": true
                    },
                    {
                        "full": "[arrayMarker]",
                        "name": "arrayMarker",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [loadText](https://docs.dolphindb.cn/zh/funcs/l/loadText.html)\n\n\n\n#### 语法\n\nloadText(filename, \\[delimiter], \\[schema], \\[skipRows=0], \\[arrayDelimiter], \\[containHeader], \\[arrayMarker])\n\n#### 参数\n\n**filename** 字符串，表示数据文件的路径。仅支持 CSV 格式的文件。若传入其他格式文件，则无法保证数据准确性。\n\n**delimiter** 字符串标量，表示数据文件中各列的分隔符。分隔符可以是一个或多个字符，默认是逗号（\",\"）。\n\n**schema** 表对象，用于指定各字段的数据类型。它可以包含以下四列（其中，name 和 type 这两列是必需的）\n\n| 列名     | 含义                                                    |\n| ------ | ----------------------------------------------------- |\n| name   | 字符串，表示列名                                              |\n| type   | 字符串，表示各列的数据类型。暂不支持 BLOB, COMPLEX, POINT, DURATION 类型。 |\n| format | 字符串，表示数据文件中日期或时间列的格式                                  |\n| col    | 整型，表示要加载的列的下标。该列的值必须是升序。                              |\n\n**Note:** 若 type 为时间类型，则源数据的时间类型格式需要和 DolphinDB 时间类型数据格式一致。若原始数据的时间戳和 DolphinDB 时间类型不兼容，建议导入时先指定为字符串类型，再通过 [temporalParse](https://docs.dolphindb.cn/zh/funcs/t/temporalParse.html) 函数进行转换。\n\n**skipRows** 0 到 1024 之间的整数，表示从文件头开始忽略的行数。它是一个可选参数。默认值为 0。\n\n**arrayDelimiter** 数据文件中数组向量列的分隔符。默认是逗号。由于不支持自动识别数组向量，必须同步修改 *schema* 的 type 列修为数组向量类型。\n\n**containHeader** 布尔值，表示数据文件是否包含标题行，默认为空。若不设置，则系统将会分析第一行数据并确定其是否为标题行。不同设置下，列名解析规则见详情描述。\n\n**arrayMarker** 包含两个字符的字符串或或 CHAR 类型数据对，两个字符分别表示数组向量左右边界的标识符。默认标识符为双引号（\"）。\n\n* 不能包含空格、Tab(`\\t`) 和换行符(`\\t`和`\\n`)。\n\n* 不能包含数字或字母。\n\n* 如果其中一个为双引号(\")，另一个也必须为双引号。\n\n* 如果标识符为 `'`，`\"` 或`\\` ，需视情况添加转义符。例如 `arrayMarker=\"\\\"\\\"\"`。\n\n* 如果 *delimiter*是单个字符，则 *arrayMarker*不能包含与其相同的字符。\n\n* 如果 *delimiter*是多个字符，则 *arrayMarker* 左边界不能与 *delimiter*的首个字符相同。\n\n#### 详情\n\n将数据文件加载到 DolphinDB 的内存表中。`loadText` 使用单个线程加载数据，如果需要使用多个线程并行加载数据，请使用 [ploadText](https://docs.dolphindb.cn/zh/funcs/p/ploadText.html) 函数。\n\n* 解析列名：\n\n  * 不指定 *containHeader* 时，导入文本文件时将以字符串格式读取第一行数据，并根据该数据解析列名。但需要注意，系统内部对第一行数据设置了读取上限，即不能超过 256 KB。解析时，如果文件中第一行的内容不包含以数字开头的数据，那么加载文件时系统会将第一行作为列名。如果文件第一行记录中某列记录以数字开头，那么加载文件时系统可能会使用col0, col1, ...等作为列名。\n\n  * 指定 *containHeader* = true 时，则系统将第一行数据视为标题行，并解析出列名。\n\n  * 指定 *containHeader* = false 时，则系统将添加列名 col0, col1, ... 。\n\n* 解析类型：\n\n  * 当 DolphinDB 加载数据文件时，会进行随机抽样，并基于样本决定每列的数据类型。这个方法不一定每次都能准确决定各列的数据类型。因此我们建议，在加载数据前，使用 [extractTextSchema](https://docs.dolphindb.cn/zh/funcs/e/extractTextSchema.html) 函数查看 DolphinDB 识别每列的数据类型。\n\n  * 当加载的数据文件中包含了表达时间、日期的数据时，满足分隔符要求的这部分数据（日期数据分隔符包含\"-\"、\"/\"和\".\"，时间数据分隔符为\":\"）会解析为相应的类型。例如，\"12:34:56\"解析为SECOND类型；\"23.04.10\"解析为DATE类型。对于不包含分隔符的数据，形如\"yyMMdd\"的数据同时满足0<=yy<=99，0<=MM<=12，1<=dd<=31，会被优先解析成DATE；形如\"yyyyMMdd\"的数据同时满足1900<=yyyy<=2100，0<=MM<=12，1<=dd<=31会被优先解析成DATE。\n\n  * 如果 DolphinDB 识别的数据类型不符合预期，可以在 schema 的 type 列中指定数据类型。对于日期列或时间列，如果 DolphinDB 识别的数据类型不符合预期，不仅需要在 schema 的 type 列指定时间类型，还需要在 format 列中指定数据文件中日期或时间的格式（用字符串表示），如 \"MM/dd/yyyy\"。如何表示日期和时间格式请参考 [ParsingandFormatofTemporalVariables](https://docs.dolphindb.cn/zh/progr/data_mani/format_temp_obj.html)。\n\n如果只需加载数据文件中的部分列，需要在 schema 的 col 列中指定要加载的列的下标。\n\n由于 DolphinDB 的字符串采用 UTF-8 编码，加载的文件必须是 UTF-8 编码。\n\n由于 DolphinDB 中列名仅可使用中文或英文字母、数字或下划线 (\\_)，且必须以中文或英文字母开头，若数据文件中的列名不符合要求，系统会依据以下规则自动调整列名：\n\n* 若数据中列名存在中文或英文字母、数字或下划线之外的字符，将其转换为下划线。\n\n* 若数据中列名第一个字符不是中文或英文字母，添加 \"c\" 作为该列名首字符。\n\n以下是数据文件中不合规列名以及自动转换的列名的例子：\n\n| 数据文件中列名 | 自动转换的列名   |\n| ------- | --------- |\n| 1\\_test | c1\\_test  |\n| test-a! | test\\_a\\_ |\n| \\[test] | c\\_test\\_ |\n\n**Note:** 从 2.00.10 版本开始，`loadText` 支持加载一条记录中包含多个换行符的数据文件。\n\n#### 例子\n\n首先，使用以下脚本生成模拟的数据文件：\n\n```\nn=10\nsym=rand(`AAPL`ORCL`MS`SUN,n)\npermno=take(10001,n)\ndate=rand(2019.06.01..2019.06.10,n)\nopen=rand(100.0,n)\nhigh=rand(200.0,n)\nclose=rand(200.0,n)\npre_close=rand(200.0,n)\nchange=rand(100.0,n)\nvol=rand(10000,n)\namount=rand(100000.0,n)\nt=table(sym,permno,date,open,high,close,pre_close,change,vol,amount)\nsaveText(t,\"/home/DolphinDB/Data/stock.csv\");\n```\n\n#### 例 1. 直接加载数据文件\n\n```\ntt=loadText(\"/home/DolphinDB/Data/stock.csv\");\n// output\ntt;\n```\n\n| sym  | permno | date       | open      | high       | close      | pre\\_close | change    | vol  | amount       |\n| ---- | ------ | ---------- | --------- | ---------- | ---------- | ---------- | --------- | ---- | ------------ |\n| MS   | 10001  | 2019.06.06 | 90.346594 | 80.530542  | 96.474428  | 146.305659 | 0.720236  | 1045 | 90494.568297 |\n| AAPL | 10001  | 2019.06.07 | 91.165315 | 8.482074   | 85.514922  | 16.259077  | 76.797829 | 7646 | 91623.485996 |\n| AAPL | 10001  | 2019.06.03 | 45.361885 | 14.077451  | 149.848419 | 89.110375  | 45.499145 | 9555 | 98171.601654 |\n| MS   | 10001  | 2019.06.04 | 8.98688   | 0.591778   | 155.54643  | 132.423187 | 69.95799  | 1202 | 3512.927634  |\n| MS   | 10001  | 2019.06.07 | 62.866173 | 33.465237  | 174.20712  | 102.695818 | 74.580523 | 3524 | 61943.64517  |\n| MS   | 10001  | 2019.06.09 | 32.819915 | 13.319577  | 136.729618 | 63.980405  | 60.66375  | 7078 | 85138.216568 |\n| MS   | 10001  | 2019.06.07 | 90.210866 | 22.728777  | 150.212291 | 59.454705  | 73.916303 | 5306 | 19883.845607 |\n| AAPL | 10001  | 2019.06.06 | 83.752686 | 71.3501    | 98.211979  | 145.60098  | 94.428343 | 8852 | 9236.020781  |\n| ORCL | 10001  | 2019.06.01 | 81.64719  | 129.702202 | 182.784373 | 117.575967 | 74.84595  | 2942 | 43394.871242 |\n| AAPL | 10001  | 2019.06.02 | 10.068382 | 80.875383  | 181.674585 | 138.783821 | 25.298267 | 1088 | 82981.043775 |\n\n```\nschema(tt).colDefs;\n```\n\n| name       | typeString | typeInt | comment |\n| ---------- | ---------- | ------- | ------- |\n| sym        | SYMBOL     | 17      |         |\n| permno     | INT        | 4       |         |\n| date       | DATE       | 6       |         |\n| open       | DOUBLE     | 16      |         |\n| high       | DOUBLE     | 16      |         |\n| close      | DOUBLE     | 16      |         |\n| pre\\_close | DOUBLE     | 16      |         |\n| change     | DOUBLE     | 16      |         |\n| vol        | INT        | 4       |         |\n| amount     | DOUBLE     | 16      |         |\n\n#### 例 2. 指定某列的数据类型来加载数据文件\n\n例如，我们想要把 permno 列的数据类型转换成 SYMBOL，可以用 [extractTextSchema](https://docs.dolphindb.cn/zh/funcs/e/extractTextSchema.html) 函数获取输入文件的结构，在导入数据前修改该列的数据类型，并指定 `loadText` 函数的 *schema* 参数。\n\n```\nschema=extractTextSchema(\"/home/DolphinDB/Data/stock.csv\");\nupdate schema set type=`SYMBOL where name=`permno;\ntt=loadText(\"/home/DolphinDB/Data/stock.csv\",,schema);\nschema(tt).colDefs;\n```\n\n| name       | typeString | typeInt | comment |\n| ---------- | ---------- | ------- | ------- |\n| sym        | SYMBOL     | 17      |         |\n| permno     | SYMBOL     | 17      |         |\n| date       | DATE       | 6       |         |\n| open       | DOUBLE     | 16      |         |\n| high       | DOUBLE     | 16      |         |\n| close      | DOUBLE     | 16      |         |\n| pre\\_close | DOUBLE     | 16      |         |\n| change     | DOUBLE     | 16      |         |\n| vol        | INT        | 4       |         |\n| amount     | DOUBLE     | 16      |         |\n\n用户也可以指定所有数据类型：\n\n```\nschematable=table(`sym`permno`date`open`high`close`pre_close`change`vol`amount as name,`SYMBOL`SYMBOL`DATE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`INT`DOUBLE as type)\ntt=loadText(\"/home/DolphinDB/Data/stock.csv\",,schematable)\nschema(tt).colDefs;\n```\n\n| name       | typeString | typeInt | comment |\n| ---------- | ---------- | ------- | ------- |\n| sym        | SYMBOL     | 17      |         |\n| permno     | SYMBOL     | 17      |         |\n| date       | DATE       | 6       |         |\n| open       | DOUBLE     | 16      |         |\n| high       | DOUBLE     | 16      |         |\n| close      | DOUBLE     | 16      |         |\n| pre\\_close | DOUBLE     | 16      |         |\n| change     | DOUBLE     | 16      |         |\n| vol        | INT        | 4       |         |\n| amount     | DOUBLE     | 16      |         |\n\n#### 例 3. 只加载部分列\n\n例如，只需加载 sym, date, open, high, close, vol, amount 这 7 列。注意，加载数据时，不能改变各列的先后顺序。如果需要调整列的顺序，可以将数据文件加载后，再使用`reorderColumns!`函数。\n\n```\nschema=extractTextSchema(\"/home/DolphinDB/Data/stock.csv\");\nschema=select * from schema where name in `sym`date`open`high`close`vol`amount\nschema[`col]=[0,2,3,4,5,8,9]\n\ntt=loadText(\"/home/DolphinDB/Data/stock.csv\",,schema);\ntt;\n```\n\n| sym  | date       | open      | high       | close      | vol  | amount       |\n| ---- | ---------- | --------- | ---------- | ---------- | ---- | ------------ |\n| SUN  | 2019.06.10 | 18.675316 | 72.754005  | 136.463909 | 1376 | 31371.319038 |\n| AAPL | 2019.06.05 | 42.098717 | 196.873587 | 41.513899  | 3632 | 9950.864129  |\n| ORCL | 2019.06.05 | 62.223474 | 197.099027 | 123.785675 | 3069 | 38035.800937 |\n| SUN  | 2019.06.03 | 0.18163   | 50.669866  | 4.652098   | 6213 | 1842.198893  |\n| SUN  | 2019.06.06 | 32.54134  | 67.012502  | 130.312294 | 4891 | 55744.156823 |\n| SUN  | 2019.06.07 | 56.899091 | 81.709825  | 61.786176  | 1133 | 69057.849515 |\n| AAPL | 2019.06.08 | 77.026838 | 38.504431  | 22.68496   | 3672 | 34420.187073 |\n| ORCL | 2019.06.07 | 62.752656 | 39.33621   | 48.483091  | 4382 | 41601.601639 |\n| AAPL | 2019.06.02 | 8.5487    | 17.623418  | 141.88325  | 8092 | 15449.159988 |\n| AAPL | 2019.06.02 | 26.178685 | 197.320455 | 110.52407  | 5541 | 14616.820449 |\n\n#### 例 4. 加载文件时，忽略数据文件的前 2 行。\n\n示例文件的第一行为列名，因此忽略前 2 行后，总的数据条数为 9。\n\n```\nre=loadText(filename=\"/home/DolphinDB/Data/stock.csv\",skipRows=2)\nselect count(*) from re;\n```\n\n| count |\n| ----- |\n| 9     |\n\n#### 例 5. 指定时间类型的格式来加载数据文件\n\n生成本例所需的数据文件：\n\n```\ntime=[\"20190623145457\",\"20190623155423\",\"20190623163025\"]\nsym=`AAPL`MS`IBM\nqty=2200 5400 8670\nprice=54.78 59.64 65.23\nt=table(time,sym,qty,price)\nsaveText(t,\"/home/DolphinDB/Data/t2.csv\");\n```\n\n加载数据前，使用 [extractTextSchema](https://docs.dolphindb.cn/zh/funcs/e/extractTextSchema.html) 函数获取该数据文件的结构：\n\n```\nextractTextSchema(\"/home/DolphinDB/Data/t2.csv\");\n```\n\n| name  | type   |\n| ----- | ------ |\n| time  | LONG   |\n| sym   | SYMBOL |\n| qty   | INT    |\n| price | DOUBLE |\n\n由于 time 列的时间格式与 DolphinDB 中的时间格式不同，如果直接加载该文件，time 列的数据将会被识别为长整型。为了能够正确加载该文件 time 列的数据，需要指定 time 列的数据类型为 DATETIME，并且指定该列的格式为 \"yyyyMMddHHmmss\"。\n\n```\nschema=extractTextSchema(\"/home/DolphinDB/Data/t2.csv\")\nupdate schema set type = \"DATETIME\" where name = \"time\"\nschema[`format]=[\"yyyyMMddHHmmss\",,,];\n\nloadText(\"/home/DolphinDB/Data/t2.csv\",,schema);\n```\n\n| time                | sym  | qty  | price |\n| ------------------- | ---- | ---- | ----- |\n| 2019.06.23T14:54:57 | AAPL | 2200 | 54.78 |\n| 2019.06.23T15:54:23 | MS   | 5400 | 59.64 |\n| 2019.06.23T16:30:25 | IBM  | 8670 | 65.23 |\n\n#### 例 6. 加载包含数组向量列的数据\n\n使用以下脚本模拟生成一个 csv 文本文件：\n\n```\nbid = array(DOUBLE[], 0, 20).append!([1.4799 1.479 1.4787, 1.4796 1.479 1.4784, 1.4791 1.479 1.4784])\nask = array(DOUBLE[], 0, 20).append!([1.4821 1.4825 1.4828, 1.4818 1.482 1.4821, 1.4814 1.4818 1.482])\nTradeDate = 2022.01.01 + 1..3\nSecurityID = rand(`APPL`AMZN`IBM, 3)\nt = table(SecurityID as `sid, TradeDate as `date, bid as `bid, ask as `ask)\nt;\nsaveText(t,filename=\"/home/DolphinDB/Data/t.csv\",delimiter=',',append=true)\n```\n\nsaveText在保存数组向量到 csv 文件时，把原数据中的`[ ]` 替换为了 `\" \"`，文件内容如下：\n\n```\nsid,date,bid,ask\nAPPL,2022.01.02,\"1.4799,1.479,1.4787\",\"1.4821,1.4825,1.4828\"\nIBM,2022.01.03,\"1.4796,1.479,1.4784\",\"1.4818,1.482,1.4821\"\nAPPL,2022.01.04,\"1.4791,1.479,1.4784\",\"1.4814,1.4818,1.482\"\n```\n\n然后调用 loadText 导入该文件：\n\n```\npath = \"/home/DolphinDB/Data/t.csv\"\nschema=extractTextSchema(path);\nupdate schema set type = \"DOUBLE[]\" where name=\"bid\" or name =\"ask\"\nt = loadText(path, schema=schema, arrayDelimiter=\",\")\nt;\n```\n\n| sid  | date       | bid                    | ask                     |\n| ---- | ---------- | ---------------------- | ----------------------- |\n| AMZN | 2022.01.02 | \\[1.4799,1.479,1.4787] | \\[1.4821,1.4825,1.4828] |\n| AMZN | 2022.01.03 | \\[1.4796,1.479,1.4784] | \\[1.4818,1.482,1.4821]  |\n| IBM  | 2022.01.04 | \\[1.4791,1.479,1.4784] | \\[1.4814,1.4818,1.482]  |\n\n通过 saveText 导出 csv 文件时，数组向量的边界标识默认为双引号（”），本例中 t.csv 的内容如下\n\n当数组向量的边界标识不为双引号时，可以通过设置参数 arrayMarker 导入，例如当 t.csv 的内容如下时\n\n```\nsid,date,bid,ask\nAPPL,2022.01.02,[1.4799,1.479,1.4787],[1.4821,1.4825,1.4828]\nIBM,2022.01.03,[1.4796,1.479,1.4784],[1.4818,1.482,1.4821]\nAPPL,2022.01.04,[1.4791,1.479,1.4784],[1.4814,1.4818,1.482]\n```\n\n通过以下脚本导入\n\n```\npath = \"/home/DolphinDB/Data/t.csv\"\nschema=extractTextSchema(path);\nupdate schema set type = \"DOUBLE[]\" where name=\"bid\" or name =\"ask\"\nt = loadText(path, schema=schema, arrayDelimiter=\",\",arrayMarker=\"[]\")\nt;\n```\n"
    },
    "loadTextEx": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loadTextEx.html",
        "signatures": [
            {
                "full": "loadTextEx(dbHandle, tableName, partitionColumns, filename, [delimiter], [schema], [skipRows=0], [transform], [sortColumns], [atomic=false], [arrayDelimiter], [containHeader], [arrayMarker])",
                "name": "loadTextEx",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "partitionColumns",
                        "name": "partitionColumns"
                    },
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    },
                    {
                        "full": "[schema]",
                        "name": "schema",
                        "optional": true
                    },
                    {
                        "full": "[skipRows=0]",
                        "name": "skipRows",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[transform]",
                        "name": "transform",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns]",
                        "name": "sortColumns",
                        "optional": true
                    },
                    {
                        "full": "[atomic=false]",
                        "name": "atomic",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[arrayDelimiter]",
                        "name": "arrayDelimiter",
                        "optional": true
                    },
                    {
                        "full": "[containHeader]",
                        "name": "containHeader",
                        "optional": true
                    },
                    {
                        "full": "[arrayMarker]",
                        "name": "arrayMarker",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [loadTextEx](https://docs.dolphindb.cn/zh/funcs/l/loadTextEx.html)\n\n\n\n#### 语法\n\nloadTextEx(dbHandle, tableName, partitionColumns, filename, \\[delimiter], \\[schema], \\[skipRows=0], \\[transform], \\[sortColumns], \\[atomic=false], \\[arrayDelimiter], \\[containHeader], \\[arrayMarker])\n\n#### 参数\n\n**dbHandle** 是数据库的句柄，可以是内存数据库或分布式数据库。\n\n**tableName** 是一个字符串，表示表的名称。\n\n**partitionColumns** 是字符串标量或向量，表示分区列。对于顺序分区类型的数据库，*partitionColumns* 为空字符串\"\"。对于组合分区类型的数据库，*partitionColumns* 是字符串向量。\n\n**filename** 是字符串，表示数据文件的路径。仅支持 CSV 格式的文件。若传入其他格式文件，则无法保证数据准确性。\n\n**delimiter** 字符串标量，表示数据文件中各列的分隔符。分隔符可以是一个或多个字符，默认是逗号（\",\"）。\n\n**schema** 是一个表，用于指定各列的数据类型。具体请参考 [loadText](https://docs.dolphindb.cn/zh/funcs/l/loadText.html) 的 *schema* 参数。\n\n**skipRows** 是0到1024之间的整数，表示从文件头开始忽略的行数。它是一个可选参数。默认值为0。\n\n**transform** 是一元函数，并且该函数接受的参数必须是一个表。\n\n**sortColumns** 字符串标量或向量，用于指定每一分区内的排序列，每次写入磁盘的数据在每一分区内将按 *sortColumns* 进行排序。系统默认 *sortColumns* （指定多列时） 最后一列为时间列，其余列字段作为排序的索引列，称作 sort key。每一分区内，同一个 sort key 组合值对应的数据将按时间列顺序连续存放在一起。查询时，若查询条件包含索引列，可以快速定位数据所在的数据块位置，提高查询性能。\n\n* 仅当 dbHandle 指示的数据库采用 “TSDB” 引擎（engine=”TSDB”）时，本参数才生效。\n* *sortColumns* 只能是 INTEGER, TEMPORAL, LITERAL 类别（除 BLOB） 或 DECIMAL 类型。\n  * 若 *sortColumns* 指定为多列，则 *sortColumns* 的最后一列必须为时间列，其余列为索引列，且索引列不能为为 TIME, TIMESTAMP, NANOTIME, NANOTIMESTAMP 类型。\n  * 若 *sortColumns* 仅指定一列，则该列作为 sort key，其类型不能为TIME, TIMESTAMP, NANOTIME, NANOTIMESTAMP。若 *sortColumns* 指定为一列时间列 （非分区列），且同时指定了 *sortKeyMappingFunction*，则查询的过滤条件中 *sortColumns* 只能与相同时间类型的值进行比较。\n* 频繁查询的字段适合设置为 *sortColumns*，且建议优先把查询频率高的字段作为 *sortColumns* 中位置靠前的列。\n* 为保证性能最优，建议每个分区内索引列的组合数（sort key）不超过1000个。\n* *sortColumns* 是每个分区内部 level file 内数据的排序依据，与其是否为分区字段无关。\n\n**atomic** 是一个布尔值，表示开启 Cache Engine 的情况下，是否保证文件加载的原子性。设置为 true，一个文件的加载过程视为一个完整的事务；设置为 false，加载一个文件的过程分为多个事务进行。\n\n**Note:** 如果要加载的文件超过 Cache Engine 大小，必须设置 *atomic* = false。否则，一个事务可能卡住（既不能提交，也不能回滚）。\n\n**arrayDelimiter** 是数据文件中数组向量列的分隔符。默认是逗号。由于不支持自动识别数组向量，必须同步修改 *schema* 的 type 列修为数组向量类型。\n\n**containHeader** 布尔值，表示数据文件是否包含标题行，默认为空。具体请参考 [loadText](https://docs.dolphindb.cn/zh/funcs/l/loadText.html) 的 *containHeader* 参数。\n\n**arrayMarker** 包含两个字符的字符串或或 CHAR 类型数据对，两个字符分别表示数组向量左右边界的标识符。默认标识符为双引号（\"）。\n\n* 不能包含空格、Tab(`\\t`) 和换行符(`\\t`和`\\n`)。\n\n* 不能包含数字或字母。\n\n* 如果其中一个为双引号(\")，另一个也必须为双引号。\n\n* 如果标识符为 `'`，`\"` 或`\\` ，需视情况添加转义符。例如 `arrayMarker=\"\\\"\\\"\"`。\n\n* 如果 *delimiter*是单个字符，则 *arrayMarker*不能包含与其相同的字符。\n\n* 如果 *delimiter*是多个字符，则 *arrayMarker* 左边界不能与 *delimiter*的首个字符相同。\n\n#### 详请\n\n将数据文件加载到数据库中。\n\n* 如果要将数据文件加载到分布式数据库中，必须指定 *tableName*，并且不能为空字符串。\n\n* 如果要将数据文件加载到内存数据库中，那么 *tableName* 为空字符串或者不指定 *tableName*。\n\n如果指定了 *transform* 参数，需要先创建分区表，再加载数据。系统会对数据文件中的数据执行 *transform* 参数指定的函数，再将得到的结果保存到数据库中。\n\n`loadTextEx` 函数与 [loadText](https://docs.dolphindb.cn/zh/funcs/l/loadText.html) 函数有很多共同之处，例如第一行数据是否判断为列名，如何确定各列的数据类型，列名的要求及自动调整等。细节请参见 [loadText](https://docs.dolphindb.cn/zh/funcs/l/loadText.html) 函数文档。\n\n#### 例子\n\n使用以下脚本生成模拟的数据文件：\n\n```\nn=10000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nvol=rand(1..10 join int(), n)\nt=table(ID, date, vol)\nsaveText(t, \"/home/DolphinDB/Data/t.txt\");\n```\n\n例. 把 t.txt 文件加载到范围分区类型的分布式数据库中，分区列为 ID。\n\n```\ndb = database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 51 101)\npt=loadTextEx(dbHandle=db,tableName=`pt, partitionColumns=`ID, filename=\"/home/DolphinDB/Data/t.txt\");\n```\n\n例. 将文本文件加载到使用 TSDB 存储引擎创建的分布式数据库中。\n\n```\ndb = database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 51 101, engine='TSDB')\npt=loadTextEx(dbHandle=db, tableName=`pt, partitionColumns=`ID, filename=\"/home/DolphinDB/Data/t.txt\", sortColumns=`ID`date);\n```\n\n例. 把 t.txt 文件加载到组合分区类型的分布式数据库中，分区列为 date 和 ID。\n\n```\ndbDate = database(directory=\"\", partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\ndbID=database(directory=\"\", partitionType=RANGE, partitionScheme=0 51 101)\ndb = database(directory=\"dfs://compoDB\", partitionType=COMPO, partitionScheme=[dbDate, dbID])\npt = loadTextEx(dbHandle=db,tableName=`pt, partitionColumns=`date`ID, filename=\"/home/DolphinDB/Data/t.txt\");\n```\n\n例. 把 t.txt 加载到值分区类型分内存数据库中，分区列为 date。\n\n```\ndb = database(directory=\"\", partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\npt = db.loadTextEx(tableName=\"\", partitionColumns=`date, filename=\"/home/DolphinDB/Data/t.txt\");\n\npt.sortBy!(`ID`x);\n```\n\n例. 示例文件的 vol 列包含空值，将空值填充为0后再加载到组合分区类型的分布式数据库中。\n\n```\ndbDate = database(directory=\"\", partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\ndbID=database(directory=\"\", partitionType=RANGE, partitionScheme=0 51 101)\ndb = database(directory=\"dfs://compoDB\", partitionType=COMPO, partitionScheme=[dbDate, dbID]);\n\npt=db.createPartitionedTable(table=t, tableName=`pt, partitionColumns=`date`ID)\npt=loadTextEx(dbHandle=db, tableName=`pt, partitionColumns=`date`ID, filename=\"/home/DolphinDB/Data/t.txt\", transform=nullFill!{,0});\n```\n\n例. 加载包含数组向量列的数据\n\n使用以下脚本模拟生成一个 csv 文本文件：\n\n```\nbid = array(DOUBLE[], 0, 20).append!([1.4799 1.479 1.4787, 1.4796 1.479 1.4784, 1.4791 1.479 1.4784])\nask = array(DOUBLE[], 0, 20).append!([1.4821 1.4825 1.4828, 1.4818 1.482 1.4821, 1.4814 1.4818 1.482])\nTradeDate = 2022.01.01 + 1..3\nSecurityID = rand(`APPL`AMZN`IBM, 3)\nt = table(SecurityID as `sid, TradeDate as `date, bid as `bid, ask as `ask)\nt;\nsaveText(t,filename=\"/home/DolphinDB/Data/t.csv\",delimiter=',',append=true)\n```\n\n然后调用 loadTextEx 导出该文件：\n\n```\ndb = database(directory=\"dfs://testDB\", partitionType=VALUE, partitionScheme=`APPL`AMZN`IBM)\npath = \"/home/DolphinDB/Data/t.csv\"\nschema = extractTextSchema(path);\nupdate schema set type = \"DOUBLE[]\" where name=\"bid\" or name =\"ask\"\nt = loadTextEx(dbHandle=db, tableName=`t, partitionColumns=`sid, filename=path, schema=schema, arrayDelimiter=\",\");\nselect * from t;\n```\n\n| sid  | date       | bid                    | ask                     |\n| ---- | ---------- | ---------------------- | ----------------------- |\n| APPL | 2022.01.02 | \\[1.4799,1.479,1.4787] | \\[1.4821,1.4825,1.4828] |\n| IBM  | 2022.01.03 | \\[1.4796,1.479,1.4784] | \\[1.4818,1.482,1.4821]  |\n| IBM  | 2022.01.04 | \\[1.4791,1.479,1.4784] | \\[1.4814,1.4818,1.482]  |\n"
    },
    "loc": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loc.html",
        "signatures": [
            {
                "full": "loc(obj, rowFilter, [colFilter], [view=false])",
                "name": "loc",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "rowFilter",
                        "name": "rowFilter"
                    },
                    {
                        "full": "[colFilter]",
                        "name": "colFilter",
                        "optional": true
                    },
                    {
                        "full": "[view=false]",
                        "name": "view",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [loc](https://docs.dolphindb.cn/zh/funcs/l/loc.html)\n\n\n\n#### 语法\n\nloc(obj, rowFilter, \\[colFilter], \\[view=false])\n\n#### 参数\n\n**obj** 矩阵对象，可以是普通矩阵、索引序列以及索引矩阵。\n\n**rowFilter**/**colFilter** 可以为以下类型：\n\n* 布尔向量，只有为 true 的行/列可以被保留。其长度必须和矩阵的行数/列数相等。\n\n* 与行/列标签【类型兼容】的标量，向量或数据对（表示范围，包含左、右边界）。\n\n**Note:**\n\n* 如果 rowFilter/colFilter 为数据对，则 obj 必须是索引序列或索引矩阵。\n\n* 类型兼容：INT, SHORT, LONG, CHAR 互相兼容， FLOAT 和 DOUBLE 类型互相兼容，SYMBOL 和 STRING 类型互相兼容。\n\n**view** 布尔值，默认值是 false，表示生成一个原矩阵的副本（深拷贝）。若为 true，只会生成原矩阵的一个视图（浅拷贝），若原数据发生改变，视图的数据也会相应变化。\n\n#### 详情\n\n通过标签或布尔向量获取矩阵指定的行和列的元素，返回一个原矩阵的副本/视图。\n\n#### 例子\n\n```\nm=rand(12, 3:4)\nm;\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 3    | 10   | 6    | 5    |\n| 4    | 11   | 6    | 0    |\n| 7    | 2    | 1    | 8    |\n\n```\na = m.loc(colFilter=[true, true, true, false], view=true)\nb = m.loc(colFilter=[true, true, true, false], view=false)\na;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 3    | 10   | 6    |\n| 4    | 11   | 6    |\n| 7    | 2    | 1    |\n\n```\nb;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 3    | 10   | 6    |\n| 4    | 11   | 6    |\n| 7    | 2    | 1    |\n\n```\n// 若原矩阵发生变化则视图也会改变，副本则不发生变化\nm[0,0] = -1\na;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| -1   | 10   | 6    |\n| 4    | 11   | 6    |\n| 7    | 2    | 1    |\n\n```\nb;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 3    | 10   | 6    |\n| 4    | 11   | 6    |\n| 7    | 2    | 1    |\n\n```\nm = rand(48, 6:8)\nm;\n```\n\n| col1 | col2 | col3 | col4 | col5 | col6 | col7 | col8 |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 27   | 31   | 47   | 21   | 12   | 43   | 22   | 11   |\n| 3    | 20   | 13   | 37   | 3    | 46   | 27   | 27   |\n| 13   | 5    | 14   | 11   | 26   | 42   | 4    | 18   |\n| 45   | 9    | 31   | 33   | 12   | 19   | 42   | 17   |\n| 2    | 19   | 30   | 25   | 36   | 27   | 21   | 6    |\n| 9    | 36   | 15   | 10   | 29   | 37   | 31   | 42   |\n\n```\n// 通过布尔值过滤\nm.loc(rowFilter=[true, true, false, false, true, false])\n```\n\n| col1 | col2 | col3 | col4 | col5 | col6 | col7 | col8 |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 27   | 31   | 47   | 21   | 12   | 43   | 22   | 11   |\n| 3    | 20   | 13   | 37   | 3    | 46   | 27   | 27   |\n| 2    | 19   | 30   | 25   | 36   | 27   | 21   | 6    |\n\n```\nm.loc(colFilter=[true, true, false, false, true, false, false, true])\n```\n\n| col1 | col2 | col3 | col4 |\n| ---- | ---- | ---- | ---- |\n| 27   | 31   | 12   | 11   |\n| 3    | 20   | 3    | 27   |\n| 13   | 5    | 26   | 18   |\n| 45   | 9    | 12   | 17   |\n| 2    | 19   | 36   | 6    |\n| 9    | 36   | 29   | 42   |\n\n```\n// 通过标签过滤\nm.rename!(`A`A`B`A`B`B, 2022.01.01 + 0..7)\nm;\n```\n\n| label | 2022.01.01 | 2022.01.02 | 2022.01.03 | 2022.01.04 | 2022.01.05 | 2022.01.06 | 2022.01.07 | 2022.01.08 |\n| ----- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |\n| A     | 27         | 31         | 47         | 21         | 12         | 43         | 22         | 11         |\n| A     | 3          | 20         | 13         | 37         | 3          | 46         | 27         | 27         |\n| B     | 13         | 5          | 14         | 11         | 26         | 42         | 4          | 18         |\n| A     | 45         | 9          | 31         | 33         | 12         | 19         | 42         | 17         |\n| B     | 2          | 19         | 30         | 25         | 36         | 27         | 21         | 6          |\n| B     | 9          | 36         | 15         | 10         | 29         | 37         | 31         | 42         |\n\n```\nm.loc(rowFilter=`A);\n```\n\n| label | 2022.01.01 | 2022.01.02 | 2022.01.03 | 2022.01.04 | 2022.01.05 | 2022.01.06 | 2022.01.07 | 2022.01.08 |\n| ----- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |\n| A     | 27         | 31         | 47         | 21         | 12         | 43         | 22         | 11         |\n| A     | 3          | 20         | 13         | 37         | 3          | 46         | 27         | 27         |\n| A     | 45         | 9          | 31         | 33         | 12         | 19         | 42         | 17         |\n\n```\nm.loc(colFilter=2022.01.02);\n```\n\n| label | 2022.01.02 |\n| ----- | ---------- |\n| A     | 31         |\n| A     | 20         |\n| B     | 5          |\n| A     | 9          |\n| B     | 19         |\n| B     | 36         |\n\n```\nm.loc(rowFilter=`B, colFilter=2022.01.03)\n```\n\n| label | 2022.01.03 |\n| ----- | ---------- |\n| B     | 14         |\n| B     | 30         |\n| B     | 15         |\n\n若 *rowFilter* / *colFilter* 是数据对，则 obj 必须是索引矩阵，可通过函数 [setIndexedMatrix!](https://docs.dolphindb.cn/zh/funcs/s/setIndexedMatrix_.html) 将一个带标签的矩阵设置为索引矩阵。\n\n```\nm = rand(30, 5:6).rename!(1..5, 2022.01.01 + 0..5)\nm.setIndexedMatrix!()\nm;\n```\n\n| label | 2022.01.01 | 2022.01.02 | 2022.01.03 | 2022.01.04 | 2022.01.05 | 2022.01.06 |\n| ----- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |\n| 1     | 5          | 27         | 26         | 18         | 29         | 3          |\n| 2     | 11         | 12         | 21         | 15         | 3          | 3          |\n| 3     | 1          | 23         | 29         | 17         | 7          | 18         |\n| 4     | 1          | 6          | 12         | 27         | 23         | 23         |\n| 5     | 15         | 7          | 3          | 19         | 4          | 8          |\n\n```\nm.loc(rowFilter=2:4, colFilter=2022.01.03:2022.01.06)\n```\n\n| label | 2022.01.03 | 2022.01.04 | 2022.01.05 | 2022.01.06 |\n| ----- | ---------- | ---------- | ---------- | ---------- |\n| 2     | 21         | 15         | 3          | 3          |\n| 3     | 29         | 17         | 7          | 18         |\n| 4     | 12         | 27         | 23         | 23         |\n\n相关函数：[at](https://docs.dolphindb.cn/zh/funcs/a/at.html)\n"
    },
    "localtime": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/localtime.html",
        "signatures": [
            {
                "full": "localtime(X)",
                "name": "localtime",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [localtime](https://docs.dolphindb.cn/zh/funcs/l/localtime.html)\n\n\n\n#### 语法\n\nlocaltime(X)\n\n#### 详情\n\n把零时区时间 *X* 转换成本地时间。\n\n#### 参数\n\n**X** 可以是 DATETIME, TIMESTAMP, NANOTIMESTAMP 类型的标量、向量或表，表示零时区时间。\n\n#### 例子\n\n以下例子在美国东部时区执行：\n\n```\nlocaltime(2018.01.22T15:20:26);\n// output\n2018.01.22T10:20:26\n\nlocaltime(2017.12.16T18:30:10.001);\n// output\n2017.12.16T13:30:10.001\n```\n"
    },
    "loess": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/loess.html",
        "signatures": [
            {
                "full": "loess(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false], [bandwidth=0.3], [robustnessIter=4], [accuracy=1e-12])",
                "name": "loess",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "resampleRule",
                        "name": "resampleRule"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    },
                    {
                        "full": "[outputX=false]",
                        "name": "outputX",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[bandwidth=0.3]",
                        "name": "bandwidth",
                        "optional": true,
                        "default": "0.3"
                    },
                    {
                        "full": "[robustnessIter=4]",
                        "name": "robustnessIter",
                        "optional": true,
                        "default": "4"
                    },
                    {
                        "full": "[accuracy=1e-12]",
                        "name": "accuracy",
                        "optional": true,
                        "default": "1e-12"
                    }
                ]
            }
        ],
        "markdown": "### [loess](https://docs.dolphindb.cn/zh/funcs/l/loess.html)\n\n\n\n#### 语法\n\nloess(X, Y, resampleRule, \\[closed='left'], \\[origin='start\\_day'], \\[outputX=false], \\[bandwidth=0.3], \\[robustnessIter=4], \\[accuracy=1e-12])\n\n#### 详情\n\n该函数根据 *resampleRule*, *closed*, *origin* 确定的采样规则，对 *X* 进行重采样操作。并根据重采样后的 *X*，对 *Y* 按照局部回归算法进行插值（Loess Interpolatiion）。\n\n若不指定 *outputX*，仅返回一个对 *Y* 插值后的向量。若指定 *outputX* = true，则返回一个 tuple，其第一个元素为 *X* 重采样后的向量，第二个元素为对 *Y* 插值后的向量。\n\n#### 参数\n\n**X** 严格递增的时间类型向量。\n\n**Y** 同 *X* 等长的数值型向量。\n\n**resampleRule** 一个字符串，可选值请参考 [resample](https://docs.dolphindb.cn/zh/funcs/r/resample.html) 的 *rule* 参数。\n\n**closed** 和 **origin** 同 [resample](https://docs.dolphindb.cn/zh/funcs/r/resample.html) 的 *closed* 和 *origin* 参数。\n\n**outputX** 布尔类型，表示是否输出 *X* 按照 *resampleRule*, *closed*, *origin* 重采样后的向量。默认值为 false。\n\n**bandwidth** 数值型标量，取值范围为(0,1]。对特定点进行 loess 拟合时，计算最小二乘回归时会考虑最接近当前点的这部分源点。\n\n**robustnessIter** 正整数，表示进行 loess 平滑处理时进行的鲁棒性迭代的次数。\n\n**accuracy** 一个大于0的数。若鲁棒性迭代过程中的中值残差小于此参数设置值，则停止迭代。\n\n#### 例子\n\n```\nloess([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min, bandwidth=1)\n\n// output\n[1,1.0521,1.104,1.1558,1.2072,1.2582,1.3086,1.3584,1.4074,1.4556,\n1.5027,1.5488,1.5937,1.6374,1.6795,1.7202,1.7593,1.7966,1.832,1.8655,\n1.897,1.9263,1.9533,1.9779,2,2.0195,2.0366,2.0513,2.0637,2.0739,\n2.082,2.0882,2.0926,2.0952,2.0962,2.0957,2.0938,2.0905,2.0861,2.0806,\n2.0741,2.0667,2.0586,2.0498，2.0405,2.0308,2.0207,2.0104,2]\n```\n"
    },
    "log": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/log.html",
        "signatures": [
            {
                "full": "log(X)",
                "name": "log",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [log](https://docs.dolphindb.cn/zh/funcs/l/log.html)\n\n\n\n#### 语法\n\nlog(X)\n\n#### 参数\n\n**X** 可以是标量、向量、数据对、矩阵或表。\n\n#### 详情\n\n求 *X* 的自然对数（以常数 e 为底）。\n\n#### 例子\n\n```\nlog(2.718283);\n```\n\n输出返回：1\n\n```\nlog(0 1 2 3);\n```\n\n输出返回：\\[,0,0.693147,1.098612]\n"
    },
    "log10": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/log10.html",
        "signatures": [
            {
                "full": "log10(X)",
                "name": "log10",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [log10](https://docs.dolphindb.cn/zh/funcs/l/log10.html)\n\n\n\n#### 语法\n\nlog10(X)\n\n#### 参数\n\n**X** 可以是标量、向量、数据对、矩阵或表。\n\n#### 详情\n\n求以10为底，*X* 的对数。\n\n#### 例子\n\n```\nlog10(100);\n// output\n2\n\nlog10(0 10 20 30 NULL);\n// output\n[,1,1.30103,1.477121,]\n\nlog10(1..4$2:2);\n```\n\n| #0      | #1       |\n| ------- | -------- |\n| 0       | 0.477121 |\n| 0.30103 | 0.60206  |\n"
    },
    "log1p": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/log1p.html",
        "signatures": [
            {
                "full": "log1p(X)",
                "name": "log1p",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [log1p](https://docs.dolphindb.cn/zh/funcs/l/log1p.html)\n\n\n\n#### 语法\n\nlog1p(X)\n\n#### 参数\n\n**X** 可以是标量、向量、数据对、矩阵或表。\n\n#### 详情\n\n返回 log(1+X) 的结果。\n\n#### 例子\n\n```\nlog1p(2);\n// output\n1.098612\n\nlog1p(2 4 6);\n// output\n[1.098612,1.609438,1.94591]\n\nlog1p(1..4$2:2);\n```\n\n| #0       | #1       |\n| -------- | -------- |\n| 0.693147 | 1.386294 |\n| 1.098612 | 1.609438 |\n"
    },
    "log2": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/log2.html",
        "signatures": [
            {
                "full": "log2(X)",
                "name": "log2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [log2](https://docs.dolphindb.cn/zh/funcs/l/log2.html)\n\n\n\n#### 语法\n\nlog2(X)\n\n#### 参数\n\n**X** 可以是标量、向量、数据对、矩阵或表。\n\n#### 详情\n\n求以2为底，*X* 的对数。\n\n#### 例子\n\n```\nlog2(4);\n// output\n2\n\nlog2(0 2 4 8 NULL);\n// output\n[,1,2,3,]\n\nlog2(1..4$2:2);\n```\n\n| #0 | #1       |\n| -- | -------- |\n| 0  | 1.584963 |\n| 1  | 2        |\n"
    },
    "login": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/login.html",
        "signatures": [
            {
                "full": "login(userId, password, [encrypted=false])",
                "name": "login",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    },
                    {
                        "full": "password",
                        "name": "password"
                    },
                    {
                        "full": "[encrypted=false]",
                        "name": "encrypted",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [login](https://docs.dolphindb.cn/zh/funcs/l/login.html)\n\n\n\n#### 语法\n\nlogin(userId, password, \\[encrypted=false])\n\n#### 参数\n\n**userId** 是表示用户名的字符串。它只能包含字母、数字和下划线，并且不能以数字开头。长度不能超过30个字符。\n\n**password** 是表示密码的字符串。它不能包含空格和控制字符。长度必须在8到20个字符之间。\n\n**encrypted** 是表示是否使用公钥对 *userId* 和 *password* 加密的布尔值。\n\n#### 详情\n\n用户可在控制节点或数据节点/计算节点上登录。\n\n从 2.00.10.10 开始，用户可以通过配置项 *enhancedSecurityVerification* 控制在登录时是否约束密码重试的次数。若不设置 *enhancedSecurityVerification*，则不约束；若设置 *enhancedSecurityVerification*=true，则当某个用户登录时，在1分钟内连续5次输入错误密码，系统会锁定这个用户的登录。10分钟后才允许该用户再次登录。\n\n#### 例子\n\n```\nlogin(\"JohnSmith\", \"Qb05078.\");\n```\n"
    },
    "logisticRegression": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/logisticRegression.html",
        "signatures": [
            {
                "full": "logisticRegression(ds, yColName, xColNames, [intercept=true], [initTheta], [tolerance=1e-3], [maxIter=500], [regularizationCoeff=1.0])",
                "name": "logisticRegression",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[initTheta]",
                        "name": "initTheta",
                        "optional": true
                    },
                    {
                        "full": "[tolerance=1e-3]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "1e-3"
                    },
                    {
                        "full": "[maxIter=500]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "500"
                    },
                    {
                        "full": "[regularizationCoeff=1.0]",
                        "name": "regularizationCoeff",
                        "optional": true,
                        "default": "1.0"
                    }
                ]
            }
        ],
        "markdown": "### [logisticRegression](https://docs.dolphindb.cn/zh/funcs/l/logisticRegression.html)\n\n\n\n#### 语法\n\nlogisticRegression(ds, yColName, xColNames, \\[intercept=true], \\[initTheta], \\[tolerance=1e-3], \\[maxIter=500], \\[regularizationCoeff=1.0])\n\n#### 参数\n\n**ds** 是数据源，通常是由 [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html) 生成。\n\n**yColName** 是字符串，表示数据源中作为因变量（所属分类）的列名。\n\n**xColNames** 是字符串标量或向量，表示数据源中作为自变量的列名。\n\n**intercept** 是布尔值，表示是否包含回归中的截距。默认值为True，系统会自动给自变量添加一列，该列的值全为1，用于生成截距。\n\n**initTheta** 是迭代的初始参数向量。默认是长度为 *xColNames.size()+intercept* 的零向量。\n\n**tolerance** 是迭代中止的边界差值 。如果在两次相邻迭代中，参数的对数似然函数的梯度的绝对值最大分量的差小于 *tolerance*，迭代中止。默认值是0.001。\n\n**maxIter** 是正整数，表示最大的迭代次数。当迭代次数达到 *maxIter* 时，迭代中止。默认值是500.\n\n**regularizationCoeff** 是正数，表示正则项系数。默认值是1.0。\n\n#### 详情\n\n计算数据源中 *xColNames* 和 *yColName* 逻辑回归的结果。返回结果是一个字典，包含以下 key：*iterations*, *modelName*, *coefficients*, *tolerance*, *logLikelihood*, *xColNames* 和 *intercept*。其中，*iterations* 是实际迭代的次数；*modelName* 是 “Logistic Regression”；*coefficients* 是向量，表示模型参数的估计值；*logLikelihood* 是最终的对数似然值。\n\n生成的模型可以作为 *predict* 函数的输入。\n\n#### 例子\n\n以下例子把两个不同中心的正态分布标记为两类，然后计算逻辑回归模型。\n\n```\nt = table(100:0, `y`x0`x1, [INT,DOUBLE,DOUBLE])\ny = take(0, 50)\nx0 = norm(-1.0, 1.0, 50)\nx1 = norm(-1.0, 1.0, 50)\ninsert into t values (y, x0, x1)\ny = take(1, 50)\nx0 = norm(1.0, 1.0, 50)\nx1 = norm(1.0, 1.0, 50)\ninsert into t values (y, x0, x1)\n\nmodel = logisticRegression(sqlDS(<select * from t>), `y, `x0`x1);\n\n// output\nmodelName->Logistic Regression\nlogLikelihood->-23.269132\nintercept->true\ncoefficients->[1.377971,1.914001,-0.305114]\nxColNames->[x0,x1]\niterations->7\ntolerance->0.001\n```\n\n把模型用于预测：\n\n```\npredict(model, t);\n```\n\n保存模型到磁盘：\n\n```\nsaveModel(model, \"C:/DolphinDB/data/logisticModel.txt\");\n```\n\n加载一个保存的模型：\n\n```\nloadModel(\"C:/DolphinDB/data/logisticModel.txt\");\n```\n"
    },
    "logout": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/logout.html",
        "signatures": [
            {
                "full": "logout([userId], [sessionOnly=true])",
                "name": "logout",
                "parameters": [
                    {
                        "full": "[userId]",
                        "name": "userId",
                        "optional": true
                    },
                    {
                        "full": "[sessionOnly=true]",
                        "name": "sessionOnly",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [logout](https://docs.dolphindb.cn/zh/funcs/l/logout.html)\n\n\n\n#### 语法\n\nlogout(\\[userId], \\[sessionOnly=true])\n\n#### 参数\n\n**userId** 是表示用户名的字符串。它只能包含字母、数字和下划线，并且不能以数字开头。长度不能超过30个字符。\n\n**sessionOnly** 是表示是否退出登录当前会话的布尔值。\n\n#### 详情\n\n该函数可以在控制节点/数据节点/计算节点上执行。\n\n如果没有指定 *userId*，用户自己退出登录。\n\n如果 *sessionOnly* 为true，用户只退出登录当前会话。\n\n如果 *sessionOnly* 为false，用户会退出登录当前会话、所有的数据节点/计算节点以及控制节点。\n\n管理员可以使其他用户退出登录。如果管理员使用户退出登录，用户会退出登录当前会话、所有的数据节点/计算节点以及控制节点。\n\n#### 例子\n\n```\nlogout();\n\nlogout(`TomFord);\n\nlogout(, false);\n```\n"
    },
    "long": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/long.html",
        "signatures": [
            {
                "full": "long(X)",
                "name": "long",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [long](https://docs.dolphindb.cn/zh/funcs/l/long.html)\n\n\n\n#### 语法\n\nlong(X)\n\n#### 详情\n\n将 *X* 的数据类型转换为 LONG。\n\n#### 参数\n\n**X** 可以是任意数据类型。\n\n#### 例子\n\n```\nx=long();\nx;\n```\n\n返回：null\n\n```\ntypestr x;\n```\n\n返回：LONG\n\n```\nlong(`10.9);\n```\n\n返回：10\n\n```\nlong(9223372036854775807l);\n```\n\n返回：9,223,372,036,854,775,807\n\n**Note:** LONG 数据类型的最大值是263-1 = 9,223,372,036,854,775,807。\n\n```\nlong(9223372036854775808l);\n```\n\n返回：9,223,372,036,854,775,807\n"
    },
    "lowDouble": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lowDouble.html",
        "signatures": [
            {
                "full": "lowDouble(X)",
                "name": "lowDouble",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [lowDouble](https://docs.dolphindb.cn/zh/funcs/l/lowDouble.html)\n\n\n\n#### 语法\n\nlowDouble(X)\n\n#### 参数\n\n**X** 是一个标量或向量，必须是16字节的数据类型。\n\n#### 详情\n\n返回值为 *X* 的低位8字节的数据，为 DOUBLE 类型。\n\n#### 例子\n\n```\nx=1 2 3 4\ny=4 3 2 1\npoints = point(x, y)\nx1 = lowDouble(points)\n```\n\n输出返回：\\[1,2,3,4]\n\n获取一个复数的实部（实数）：\n\n```\na=complex(2, 5)\nlowDouble(a)\n```\n\n输出返回：2\n"
    },
    "lower": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lower.html",
        "signatures": [
            {
                "full": "lower(X)",
                "name": "lower",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [lower](https://docs.dolphindb.cn/zh/funcs/l/lower.html)\n\n\n\n#### 语法\n\nlower(X)\n\n#### 参数\n\n**X** 可以是字符串标量或向量。\n\n#### 详情\n\n`lower` 函数把字符串或字符串列表中的所有字符转换为小写。\n\n#### 例子\n\n```\nx= `Ibm`C`AapL;\nx.lower();\n// output\n[\"ibm\",\"c\",\"aapl\"]\n\nlower(`Thl);\n// output\nthl\n```\n\n相关函数：[upper](https://docs.dolphindb.cn/zh/funcs/u/upper.html)\n"
    },
    "lowerBound": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lowerbound.html",
        "signatures": [
            {
                "full": "lowerBound(X,Y)",
                "name": "lowerBound",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [lowerBound](https://docs.dolphindb.cn/zh/funcs/l/lowerbound.html)\n\n#### 语法\n\nlowerBound(X,Y)\n\n#### 详情\n\n对于 *Y* 中的每个元素 y，该函数返回 *X* 中第一个不小于 y 的元素下标。如果没有找到，则返回 *X* 的长度。\n\n#### 参数\n\n**X** 递增的向量、索引序列、索引矩阵\n\n**Y** 标量、向量、数组向量、元组、矩阵、字典、表\n\n#### 例子\n\n在以下例子中，X 中的部分元素大于或等于 Y 中的部分元素：\n\n```\nX = [1,3,5];\nY = [5,6,7];\nZ = lowerBound(X,Y);\nZ\n// output: [2,3,3]\n\nindex = [2023.05.04, 2023.05.06, 2023.05.07, 2023.05.10]\ns = indexedSeries(index, 1..4)\ny=[2023.05.04, 2023.05.06, 2023.05.09]\n\nlowerBound(s,y)\n```\n\n| label      | #0 |\n| ---------- | -- |\n| 2023.05.04 | 1  |\n| 2023.05.06 | 2  |\n| 2023.05.09 | 4  |\n\n"
    },
    "lowLong": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lowlong.html",
        "signatures": [
            {
                "full": "lowLong(X)",
                "name": "lowLong",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [lowLong](https://docs.dolphindb.cn/zh/funcs/l/lowlong.html)\n\n\n\n#### 语法\n\nlowLong(X)\n\n#### 参数\n\n**X** 是一个标量、向量、表、数据对或者字典，且必须为16字节的数据类型（支持 UUID、IPADDR、INT128、COMPLEX、POINT）。\n\n#### 详情\n\n返回值为 *X* 的低位8字节的数据，为 LONG 类型。\n\n#### 例子\n\n```\nx =ipaddr(\"192.168.1.13\")\nx1 = lowLong(x)\nprint(x1)\n//output: 3232235789\n```\n\n```\nx=1 2 3 4\ny=4 3 2 1\npoints = point(x, y)\nx1 = lowLong(points)\n//output: [4607182418800017408,4611686018427387904,4613937818241073152,4616189618054758400]\n```\n\n**Related information**\n\n[highLong](https://docs.dolphindb.cn/zh/funcs/h/highlong.html)\n"
    },
    "lowRange": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lowRange.html",
        "signatures": [
            {
                "full": "lowRange(X)",
                "name": "lowRange",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [lowRange](https://docs.dolphindb.cn/zh/funcs/l/lowRange.html)\n\n\n\n#### 语法\n\nlowRange(X)\n\n#### 参数\n\n**X** 向量/元组/矩阵/表。\n\n#### 详情\n\n对于 *X* 中的每个元素 *Xi*，统计 *Xi* 左侧相邻且连续大于它的元素个数。\n\n该函数常用于统计一个序列的当前值是前多少周期（日或分钟等）内的最小值。例如某只股票创几日新低等。\n\n#### 例子\n\n```\nlowRange([13.5, 13.6, 13.4, 13.3, 13.5, 13.9, 13.1, 20.1, 20.2, 20.3])\n// output\n[0,0,2,3,0,0,6,0,0,0]\n\nm = matrix(1.5 2.6 3.2 1.4 2.5 2.2 3.7 2.0, 1.6 2.3 4.2 5.6 4.1 3.2 4.4 6.9)\nlowRange(m)\n```\n\n| #0 | #1 |\n| -- | -- |\n| 0  | 0  |\n| 0  | 0  |\n| 0  | 0  |\n| 3  | 0  |\n| 0  | 2  |\n| 1  | 3  |\n| 0  | 0  |\n| 3  | 0  |\n\n```\n// 模拟股票 A 8天的股价,使用 lowRange 计算股票 A 当日股价创几日新低\ntrades = table(take(`A, 8) as sym,  2022.01.01 + 1..8 as date, 39.70 39.72 39.80 39.78 39.83 39.92 40.00 40.03 as price)\nselect *, lowRange(price) from trades\n```\n\n| id | date       | price | lowRange\\_price |\n| -- | ---------- | ----- | --------------- |\n| A  | 2022.01.02 | 39.7  | 0               |\n| A  | 2022.01.03 | 39.72 | 0               |\n| A  | 2022.01.04 | 39.8  | 0               |\n| A  | 2022.01.05 | 39.78 | 1               |\n| A  | 2022.01.06 | 39.83 | 0               |\n| A  | 2022.01.07 | 39.92 | 0               |\n| A  | 2022.01.08 | 40    | 0               |\n| A  | 2022.01.09 | 40.03 | 0               |\n\n**Related information**\n\n[topRange](https://docs.dolphindb.cn/zh/funcs/t/topRange.html)\n"
    },
    "lpad": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lpad.html",
        "signatures": [
            {
                "full": "lpad(str, length, [pattern])",
                "name": "lpad",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "length",
                        "name": "length"
                    },
                    {
                        "full": "[pattern]",
                        "name": "pattern",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [lpad](https://docs.dolphindb.cn/zh/funcs/l/lpad.html)\n\n\n\n#### 语法\n\nlpad(str, length, \\[pattern])\n\n#### 参数\n\n**str** 可以是字符串或字符串向量。它表示目标字符串。\n\n**length** 是一个非负整数，表示填充之后的字符串长度。如果 *length* 小于 *str* 的长度，*lpad* 函数相当于 [left](https://docs.dolphindb.cn/zh/funcs/l/left.html) (str, length).\n\n**pattern** 是填充字符串。它是一个可选参数。如果 *pattern* 没有指定，则在 *str* 的左边填充空格。\n\n#### 详情\n\n在 *str* 的左边填充指定字符串。\n\n#### 例子\n\n```\nlpad(\"Hello\",2);\n// output\nHe\n\nlpad(`Hello, 10);\n// output\nHello\n\nlpad(`Hello, 12, `0);\n// output\n0000000Hello\n```\n"
    },
    "lshift": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lshift.html",
        "signatures": [
            {
                "full": "lshift(X, a)",
                "name": "lshift",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "a",
                        "name": "a"
                    }
                ]
            }
        ],
        "markdown": "### [lshift](https://docs.dolphindb.cn/zh/funcs/l/lshift.html)\n\n\n\n#### 语法\n\nlshift(X, a) 或 X<\\<a\n\n#### 参数\n\n**X** 可以是整数标量、数据对、向量、矩阵或表；\n\n**a** 是移动的位数。\n\n#### 详情\n\n`lshift` 是将 *X* 按二进制展开后整体往左移动 *a* 位数。右侧的位数用 0 填充。\n\n#### 例子\n\n```\nlshift(2, 10);\n// output\n2048\n\n1..10 << 1;\n// output\n[2,4,6,8,10,12,14,16,18,20]\n\n1..10 << 10;\n// output\n[1024,2048,3072,4096,5120,6144,7168,8192,9216,10240]\n\n1:10<<10;\n// output\n1024 : 10240\n```\n\n相关函数：[rshift](https://docs.dolphindb.cn/zh/funcs/r/rshift.html).\n"
    },
    "lt": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lt.html",
        "signatures": [
            {
                "full": "lt(X, Y)",
                "name": "lt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [lt](https://docs.dolphindb.cn/zh/funcs/l/lt.html)\n\n\n\n#### 语法\n\nlt(X, Y) 或 X\\<Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量、矩阵或集合。如果 *X* 或 *Y* 中的其中一个是数据对、向量或矩阵，另一个必须是一个标量，或具有相同长度或维度的数据对、向量或矩阵。\n\n#### 详情\n\n如果 *X* 和 *Y* 都不是集合，返回逐个元素比较 *X*<*Y* 的结果。\n\n如果 *X* 和 *Y* 都是集合，则检查 *X* 是否为 *Y* 的真子集。\n\n#### 例子\n\n```\n1 2 3 < 2;\n// output\n[1,0,0]\n\n1 2 3<0 2 4;\n// output\n[0,0,1]\n\n2:3<1:6;\n// output\n0 : 1\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 lt 4;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 0  |\n| 1  | 0  | 0  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1<m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 0  |\n| 1  | 0  | 0  |\n\n集合操作：如果 *X*<*Y*，则 *X* 是 *Y* 的真子集。\n\n```\nx=set(4 6);\nx;\n// output\nset(6,4)\ny=set(8 9 4 6);\ny;\n// output\nset(6,4,9,8)\n\nx<y;\n// output\n1\n\ny<x;\n// output\n0\n\nx<x;\n// output\n0\n# x is not a proper subset of x\n```\n"
    },
    "ltrim": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/ltrim.html",
        "signatures": [
            {
                "full": "ltrim(X)",
                "name": "ltrim",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ltrim](https://docs.dolphindb.cn/zh/funcs/l/ltrim.html)\n\n\n\n#### 语法\n\nltrim(X)\n\n#### 参数\n\n**X** 可以是一个字符串或字符串向量。\n\n#### 详情\n\n删除字符串或字符串向量的每个元素左边的空格。\n\n#### 例子\n\n```\nltrim(\"    I love this game!\");\n// output\nI love this game!\n```\n"
    },
    "lu": {
        "url": "https://docs.dolphindb.cn/zh/funcs/l/lu.html",
        "signatures": [
            {
                "full": "lu(obj, [permute=false])",
                "name": "lu",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[permute=false]",
                        "name": "permute",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [lu](https://docs.dolphindb.cn/zh/funcs/l/lu.html)\n\n\n\n#### 语法\n\nlu(obj, \\[permute=false])\n\n#### 参数\n\n**obj** 是一个不包含 NULL 值的矩阵。\n\n**permute** 是一个布尔值。默认值为 false。\n\n#### 详情\n\n实现矩阵的 LU 分解。\n\n如果 *permute* 为 false，返回三个矩阵，依次是 L, U, P，满足条件 *obj* = P' \\* L \\* U。P 是置换矩阵；L 是下三角矩阵，其对角线元素均为1；U 是上三角矩阵。\n\n如果 *permute* 为 true，返回两个矩阵，依次是 L,U，满足条件 *obj* = L \\* U。\n\n#### 例子\n\n```\nA = matrix([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]]);\n\nP, L, U = lu(A);\nP;\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n| 0  | 0  | 1  | 0  |\n| 0  | 0  | 0  | 1  |\n| 1  | 0  | 0  | 0  |\n| 0  | 1  | 0  | 0  |\n\n```\nL;\n```\n\n| #0    | #1   | #2       | #3 |\n| ----- | ---- | -------- | -- |\n| 1     | 0    | 0        | 0  |\n| 0.875 | 1    | 0        | 0  |\n| 0.25  | 0.72 | 1        | 0  |\n| 0.625 | 0.12 | 0.233871 | 1  |\n\n```\nU;\n```\n\n| #0 | #1   | #2   | #3       |\n| -- | ---- | ---- | -------- |\n| 8  | 2    | 6    | 4        |\n| 0  | 6.25 | 0.75 | 4.5      |\n| 0  | 0    | 4.96 | 0.76     |\n| 0  | 0    | 0    | 0.782258 |\n\n```\nL, U = lu(A, true);\nL;\n```\n\n| #0    | #1   | #2       | #3 |\n| ----- | ---- | -------- | -- |\n| 0.25  | 0.72 | 1        | 0  |\n| 0.625 | 0.12 | 0.233871 | 1  |\n| 1     | 0    | 0        | 0  |\n| 0.875 | 1    | 0        | 0  |\n\n```\nU;\n```\n\n| #0 | #1   | #2   | #3       |\n| -- | ---- | ---- | -------- |\n| 8  | 2    | 6    | 4        |\n| 0  | 6.25 | 0.75 | 4.5      |\n| 0  | 0    | 4.96 | 0.76     |\n| 0  | 0    | 0    | 0.782258 |\n"
    },
    "ma": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/ma.html",
        "signatures": [
            {
                "full": "ma(X, window, maType)",
                "name": "ma",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "maType",
                        "name": "maType"
                    }
                ]
            }
        ],
        "markdown": "### [ma](https://docs.dolphindb.cn/zh/funcs/m/ma.html)\n\n\n\n#### 语法\n\nma(X, window, maType)\n\nTA-lib 系列函数其他通用参数说明和窗口计算规则请参考：[TA-lib 系列](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 参数\n\n**maType** 计算平均线的方法。是一个0-8范围内的整数。各个整数分别表示：0= [sma](https://docs.dolphindb.cn/zh/funcs/s/sma.html) , 1= [ema](https://docs.dolphindb.cn/zh/funcs/e/ema.html) , 2= [wma](https://docs.dolphindb.cn/zh/funcs/w/wma.html) , 3= [dema](https://docs.dolphindb.cn/zh/funcs/d/dema.html) , 4= [tema](https://docs.dolphindb.cn/zh/funcs/t/tema.html) , 5= [trima](https://docs.dolphindb.cn/zh/funcs/t/trima.html) , 6= [kama](https://docs.dolphindb.cn/zh/funcs/k/kama.html) , 7=(mama), 8= [t3](https://docs.dolphindb.cn/zh/funcs/t/t3.html) 。\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的移动平均，计算公式由 *maType* 决定。\n"
    },
    "mad": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mad.html",
        "signatures": [
            {
                "full": "mad(X, [useMedian=false])",
                "name": "mad",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[useMedian=false]",
                        "name": "useMedian",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [mad](https://docs.dolphindb.cn/zh/funcs/m/mad.html)\n\n\n\n#### 语法\n\nmad(X, \\[useMedian=false])\n\n#### 参数\n\n**X** 是一个向量、矩阵或表。\n\n**useMedian** 是一个布尔值，默认值是 false，表示计算平均绝对离差（mean absolute deviation）。若为 true 则计算绝对中位差（median absolute deviation）。\n\n* 平均绝对离差：mean(abs(X - mean(X)))\n\n* 绝对中位差：med(abs(X - med(X)))\n\n#### 详情\n\n* 若 *X* 为向量，计算 *X* 的平均绝对离差或平均绝对中位差。\n\n* 若 *X* 为矩阵，计算在每列内部进行，返回一个向量。\n\n* 若 *X* 为表，计算在每列内部进行，返回一个表。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nmad([85, 90, 95, NULL]);\n// output\n3.333333333333333\n\nm=matrix(85 90 95, 185 190 195);\nm;\n```\n\n| #0 | #1  |\n| -- | --- |\n| 85 | 185 |\n| 90 | 190 |\n| 95 | 195 |\n\n```\nmad m;\n// output\n[3.333333333333333, 3.333333333333333]\n\nmad([0, 19.618568, 67.900707, 71.65218, 73.103952, 58.275308, 18.819054, 36.940571, 48.114366], false)\n// output\n22.204817\n```\n\n相关函数： [mmad](https://docs.dolphindb.cn/zh/funcs/m/mmad.html)\n"
    },
    "makeCall": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/makeCall.html",
        "signatures": [
            {
                "full": "makeCall(F, args...)",
                "name": "makeCall",
                "parameters": [
                    {
                        "full": "F",
                        "name": "F"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [makeCall](https://docs.dolphindb.cn/zh/funcs/m/makeCall.html)\n\n\n\n#### 语法\n\nmakeCall(F, args...)\n\n#### 参数\n\n**F** 是一个函数。\n\n**args** 是 *F* 需要的参数。\n\n#### 详情\n\n它使用指定参数调用一个函数并生成脚本。高阶函数 [call](https://docs.dolphindb.cn/zh/funcs/ho_funcs/call.html) 与 `makeCall` 的区别是，`makeCall` 不执行脚本。\n\n#### 例子\n\n在下列例子中，我们创建了 `generateReport` 函数。它能够以指定格式显示表的某些列。\n\n```\ndef generateReport(tbl, colNames, colFormat): sql(sqlColAlias(each(makeCall{format},sqlCol(colNames),colFormat),colNames), tbl).eval();\n\nt = table(1..100 as id, (1..100 + 2018.01.01) as date, rand(100.0, 100) as price, rand(10000, 100) as qty, rand(`A`B`C`D`E`F`G, 100) as city);\nt;\n```\n\n| id  | date       | price   | qty  | city |\n| --- | ---------- | ------- | ---- | ---- |\n| 1   | 2018.01.02 | 77.9896 | 375  | A    |\n| 2   | 2018.01.03 | 8.1332  | 7864 | F    |\n| 3   | 2018.01.04 | 56.7185 | 4912 | B    |\n| 4   | 2018.01.05 | 72.4173 | 534  | E    |\n| 5   | 2018.01.06 | 8.2019  | 31   | B    |\n| 6   | 2018.01.07 | 74.7275 | 4139 | A    |\n| 7   | 2018.01.08 | 7.5421  | 2725 | D    |\n| 8   | 2018.01.09 | 59.1689 | 3095 | C    |\n| 9   | 2018.01.10 | 55.8454 | 5443 | D    |\n| 10  | 2018.01.11 | 32.1285 | 6998 | G    |\n| ... |            |         |      |      |\n\n```\ngenerateReport(t, [\"id\", \"date\",\"price\",\"qty\"], [\"0\", \"MM/dd/yyyy\", \"0.00\", \"#,###\"]);\n```\n\n| id  | date       | price | qty   |\n| --- | ---------- | ----- | ----- |\n| 1   | 01/02/2018 | 77.99 | 375   |\n| 2   | 01/03/2018 | 8.13  | 7,864 |\n| 3   | 01/04/2018 | 56.72 | 4,912 |\n| 4   | 01/05/2018 | 72.42 | 534   |\n| 5   | 01/06/2018 | 8.20  | 31    |\n| 6   | 1/07/2018  | 74.73 | 4,139 |\n| 7   | 01/08/2018 | 7.54  | 2,725 |\n| 8   | 01/09/2018 | 59.17 | 3,095 |\n| 9   | 01/10/2018 | 55.85 | 5,443 |\n| 10  | 01/11/2018 | 32.13 | 6,988 |\n| ... |            |       |       |\n\n与之等效的 SQL 脚本是：\n\n```\ndef generateReportSQL(tbl, colNames, colFormat): sql(sqlColAlias(each(makeCall{format},sqlCol(colNames),colFormat),colNames), tbl)\ngenerateReportSQL(t, [\"id\", \"date\",\"price\",\"qty\"], [\"0\", \"MM/dd/yyyy\", \"0.00\", \"#,###\"]);\n// output\n< select format(id, \"0\") as id,format(date, \"MM/dd/yyyy\") as date,format(price, \"0.00\") as price,format(qty, \"#,###\") as qty from t >\n```\n"
    },
    "makeKey": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/makeKey.html",
        "signatures": [
            {
                "full": "makeKey(args...)",
                "name": "makeKey",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [makeKey](https://docs.dolphindb.cn/zh/funcs/m/makeKey.html)\n\n\n\n#### 语法\n\nmakeKey(args...)\n\n#### 参数\n\n**args** 是多个标量或长度相同的向量。\n\n#### 详情\n\n对于输入的多个 *args*，将它们的值组合为一个 BLOB 标量或向量。返回的结果可用作字典或集合的 key。相较于 `makeSortedKey`，`makeKey` 不会保存组合值的排序结果。\n\n#### 例子\n\n```\nmakeKey(`a1,`b1,`c1)\n// output\na1b1c1\n\nset(makeKey(1 2, 4 5))\n\nre=makeKey(`a1`a2, `_1`_2)\ndict(re,100 200)\n\n// output\na2_2->200\na1_1->100\n```\n\n相关函数：[makeSortedKey](https://docs.dolphindb.cn/zh/funcs/m/makeSortedKey.html)\n"
    },
    "makeSortedKey": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/makeSortedKey.html",
        "signatures": [
            {
                "full": "makeSortedKey(args...)",
                "name": "makeSortedKey",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [makeSortedKey](https://docs.dolphindb.cn/zh/funcs/m/makeSortedKey.html)\n\n\n\n#### 语法\n\nmakeSortedKey(args...)\n\n#### 参数\n\n**args** 是多个标量或长度相同的向量。\n\n#### 详情\n\n对于输入的多个 *args*，将它们的值组合为一个 BLOB 标量或向量。相较于 `makeKey`，`makeSortedKey` 内部会保存组合值的排序结果，但输出结果与 `makeKey` 相同。\n\n#### 例子\n\n```\nmakeSortedKey([`b,`a,`c], [`4,`2,`1])\n// output\n[\"b4\",\"a2\",\"c1\"]\n\nset(makeSortedKey(1 2, 4 5))\n```\n"
    },
    "makeUnifiedCall": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/makeUnifiedCall.html",
        "signatures": [
            {
                "full": "makeUnifiedCall(func, args)",
                "name": "makeUnifiedCall",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args",
                        "name": "args"
                    }
                ]
            }
        ],
        "markdown": "### [makeUnifiedCall](https://docs.dolphindb.cn/zh/funcs/m/makeUnifiedCall.html)\n\n\n\n#### 语法\n\nmakeUnifiedCall(func, args)\n\n#### 参数\n\n**func** 是一个函数。\n\n**args** 是一个 tuple, 由所调用函数的参数所构成。从版本 2.00.11.3 起，args 可以是一个元代码的标量，其代码是一个元组表达式。\n\n#### 详情\n\n它使用指定参数调用一个函数并生成脚本。 高阶函数 [unifiedCall](https://docs.dolphindb.cn/zh/funcs/ho_funcs/unifiedCall.html) 与 `makeUnifiedCall` 的区别是，`makeUnifiedCall` 不执行脚本。\n\n#### 例子\n\n```\nmc = makeUnifiedCall(matrix, (1 2 3, 4 5 6));\nmc;\n// output\n< matrix([1,2,3], [4,5,6]) >\nmc.eval();\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 4    |\n| 2    | 5    |\n| 3    | 6    |\n\n从版本2.00.11.3 起， args 支持传入一个元代码标量，其代码是一个元组表达式。\n\n通过下例的对比可以看到：\n\n* 当 args 是一个元组时，会将元组中变量的值传入，此时 a 的值为 < add(3, 5) >\n\n* 当 args 是一个元组表达式的元代码时，会将变量作为函数的参数，生成元代码，此时 b 的值为 < add(x, y) >\n\n```\nx=3\ny=5\na = makeUnifiedCall(add, (x,y)) // < add(3, 5) >\nb = makeUnifiedCall(add, <(x,y)>) // < add(x, y) >\n```\n\n因此，当 x 或 y 的值改变，b 的执行结果会将 x 和 y 的值动态传入，而 a 的执行结果不会随 x 和 y 的值变化\n\n```\nx = 6\na.eval() //计算 3+5\n```\n\n结果为 8 。\n\n```\nb.eval() // 计算 6+5\n```\n\n结果为 11 。\n\n下例中，函数 `makeUnifiedCall` 以 `sqlTuple` 生成的元组表达式的元代码为参数，调用自定义函数 f，其结果作为函数 sql 的参数 select ，从而生成元代码 c 。\n\n```\n// 自定义函数\nf = def (x,y)->(x-y)/(x+y)\n\n// 定义待查询的表\nt = table(1.0 2.0 3.0 as qty1, 1.0 3.0 7.0 as qty2)\n\n// 生成查询的元代码\nc = sql(select=makeUnifiedCall(f, sqlTuple(`qty1`qty2)), from=t)\n\n// 执行对应元代码\nc.eval()\n```\n\n| \\_qty1 |\n| ------ |\n| 0      |\n| -0.2   |\n| -0.4   |\n\n**Related information**\n\n[sqlTuple](https://docs.dolphindb.cn/zh/funcs/s/sqlTuple.html)\n"
    },
    "mannWhitneyUTest": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mannWhitneyUTest.html",
        "signatures": [
            {
                "full": "mannWhitneyUTest(X, Y, [correct=true])",
                "name": "mannWhitneyUTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[correct=true]",
                        "name": "correct",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [mannWhitneyUTest](https://docs.dolphindb.cn/zh/funcs/m/mannWhitneyUTest.html)\n\n\n\n#### 语法\n\nmannWhitneyUTest(X, Y, \\[correct=true])\n\n#### 参数\n\n**X** 是一个数值向量。\n\n**Y** 是一个数值向量。\n\n**correct** 是一个布尔值，表示在求 p 值时是否考虑连续性校正。默认值为 true。\n\n#### 详情\n\n对 *X* 和 *Y* 进行 Mann-Whitney U 检验。返回的结果是一个字典，包含以下 key：\n\n* stat：一张表，包含三种不同备择假设下的 p 值\n\n* correct：求 p 值时是否考虑连续性校正\n\n* method：字符串 \"Mann-Whitney U test\"\n\n* U：U统计量\n\n#### 例子\n\n```\nmannWhitneyUTest(5 1 4 3 5, 2 4 7 -1 0 4);\n\n// output\nstat->\n\nalternativeHypothesis                 pValue\n------------------------------------- --------\ntrue location shift is not equal to 0 0.518023\ntrue location shift is less than 0    0.259011\ntrue location shift is greater than 0 0.797036\n\ncorrect->true\nmethod->Mann-Whitney U test\nU->11\n```\n"
    },
    "manova": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/manova.html",
        "signatures": [
            {
                "full": "manova(X, group)",
                "name": "manova",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "group",
                        "name": "group"
                    }
                ]
            }
        ],
        "markdown": "### [manova](https://docs.dolphindb.cn/zh/funcs/m/manova.html)\n\n\n\n#### 语法\n\nmanova(X, group)\n\n#### 参数\n\n**X** 是一个矩阵或所有列均为数值的表。\n\n**group** 是一个与 *X* 中每一列长度相同的向量，表示分组。\n\n#### 详情\n\n对 *X* 进行多因素方差分析（MANOVA）。\n\n#### 例子\n\n```\na=29.6 24.3 1.5 20.2 2.6 44.5 2.4 20 9.5\nb=27.3 68.4 3.8 34.8 4.6 26.3 5.9 20 5.6\nc=50.8 60.2 1.0 30.1 2.1 27.9 2.3 20 8.8\ng=1 1 2 1 2 1 2 1 2\nt=table(a,b,c,g)\nmanova(select a,b,c from t, t.g);\n\n// output\ndfT->8\ndfB->1\ngnames->[1,2]\ngmdist->\n#0        #1\n--------- ---------\n0         16.458055\n16.458055 0\n\nmdist->[5.35501,5.171516,0.132336,1.335303,0.043425,5.384036,0.07295,2.844008,0.661416]\nchisq->[10.056959]\nB->\n#0          #1          #2\n----------- ----------- -----------\n1250.307556 1601.627111 1805.355556\n1601.627111 2051.662722 2312.636111\n1805.355556 2312.636111 2606.805556\n\nlambda->[0.160648]\nW->\n#0       #1        #2\n-------- --------- --------\n453.968  -151.966  16.31\n-151.966 1477.6995 1008.395\n16.31    1008.395  1182.63\n\nT->\n#0          #1          #2\n----------- ----------- -----------\n1704.275556 1449.661111 1821.665556\n1449.661111 3529.362222 3321.031111\n1821.665556 3321.031111 3789.435556\n\n\nchisqdf->[3]\nP->[0.018088]\ndfW->7\neigenval->[5.224779,2.757998E-16,-1.552556E-15]\neigenvec->\n#0       #1        #2\n-------- --------- ---------\n0.099362 0.08179   0.023313\n0.029973 -0.010892 0.107448\n0.023044 -0.046981 -0.111469\n\n\ncanon->\n#0        #1        #2\n--------- --------- ---------\n2.047837  -0.369203 -2.271294\n2.969714  -1.691977 0.973456\n-2.596193 -0.071875 0.09971\n0.861618  -0.247207 0.622822\n-2.437568 -0.042299 0.088698\n2.970655  1.936238  0.521256\n-2.413867 -0.082213 0.201424\n0.165404  0.372149  0.153761\n-1.567601 0.196387  -0.389832\n```\n"
    },
    "mask": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mask.html",
        "signatures": [
            {
                "full": "mask(X, Y)",
                "name": "mask",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [mask](https://docs.dolphindb.cn/zh/funcs/m/mask.html)\n\n\n\n#### 语法\n\nmask(X, Y)\n\n#### 参数\n\n**X** 是一个标量、向量或矩阵。\n\n**Y** 是一个布尔表达式。\n\n#### 详情\n\n对 *X* 中每个元素应用条件 *Y*。若结果为 false，保留该元素。若结果为 true，将其替换为 NULL。返回一个长度与 *X* 相同的对象。\n\n#### 例子\n\n```\nx=1..10\nmask(x, x>6);\n// output\n[1,2,3,4,5,6,,,,]\n\nm=matrix(1 2 3, 4 5 6, 7 8 9);\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 4  | 7  |\n| 2  | 5  | 8  |\n| 3  | 6  | 9  |\n\n```\nmask(m, m<6);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n|    |    | 7  |\n|    |    | 8  |\n|    | 6  | 9  |\n"
    },
    "matchAll": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matchall.html",
        "signatures": [
            {
                "full": "matchAll(textCol, terms)",
                "name": "matchAll",
                "parameters": [
                    {
                        "full": "textCol",
                        "name": "textCol"
                    },
                    {
                        "full": "terms",
                        "name": "terms"
                    }
                ]
            }
        ],
        "markdown": "### [matchAll](https://docs.dolphindb.cn/zh/funcs/m/matchall.html)\n\n\n\n#### 语法\n\nmatchAll(textCol, terms)\n\n#### 参数\n\n**textCol** 待查询的列，即 PKEY 存储引擎中设置了文本索引的列。\n\n**terms** STRING 类型标量，用于指定待查询的词。若需查询多个词，可将它们用空格分隔写入该字符串中。\n\n#### 详情\n\n该函数用于 SQL 语句的 WHERE 子句，针对 PKEY 存储引擎中设置文本索引的列进行文本匹配，返回符合所有指定匹配词的行。\n\n#### 例子\n\n```\n// 构造数据\nstringColumn = [\"There are some apples and oranges.\",\"Mike likes apples.\",\"Alice likes oranges.\",\"Mike gives Alice an apple.\",\"Alice gives Mike an orange.\",\"John likes peaches, so he does not give them to anyone.\",\"Mike, can you give me some apples?\",\"Alice, can you give me some oranges?\",\"Mike traded an orange for an apple with Alice.\"]\nt = table([1,1,1,2,2,2,3,3,3] as id1, [1,2,3,1,2,3,1,2,3] as id2, stringColumn as remark) \nif(existsDatabase(\"dfs://textDB\")) dropDatabase(\"dfs://textDB\")\ndb = database(directory=\"dfs://textDB\", partitionType=VALUE, partitionScheme=[1,2,3], engine=\"PKEY\")\npt = createPartitionedTable(dbHandle=db, table=t, tableName=\"pt\", partitionColumns=\"id1\",primaryKey=`id1`id2,indexes={\"remark\":\"textindex(parser=english, full=false, lowercase=true, stem=true)\"})\npt.tableInsert(t)\n\n// 匹配包含 apple 和 orange 的行\nselect * from pt where matchAll(textCol=remark,terms=\"apple orange\")\n```\n\n<table id=\"table_lxp_c5m_cdc\"><thead><tr><th>\n\nid1\n\n</th><th>\n\nid2\n\n</th><th>\n\nremark\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\n1\n\n</td><td>\n\nThere are some apples and oranges.\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n3\n\n</td><td>\n\nMike traded an orange for an apple with Alice.\n\n</td></tr></tbody>\n</table>\n"
    },
    "matchAny": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matchany.html",
        "signatures": [
            {
                "full": "matchAny(textCol, terms)",
                "name": "matchAny",
                "parameters": [
                    {
                        "full": "textCol",
                        "name": "textCol"
                    },
                    {
                        "full": "terms",
                        "name": "terms"
                    }
                ]
            }
        ],
        "markdown": "### [matchAny](https://docs.dolphindb.cn/zh/funcs/m/matchany.html)\n\n\n\n#### 语法\n\nmatchAny(textCol, terms)\n\n#### 参数\n\n**textCol** 待查询的列，即 PKEY 存储引擎中设置了文本索引的列。\n\n**terms** STRING 类型标量，用于指定待查询的词。若需查询多个词，可将它们用空格分隔写入该字符串中。\n\n#### 详情\n\n该函数用于 SQL 语句的 WHERE 子句，针对 PKEY 存储引擎中设置文本索引的列进行文本匹配，返回符合任一指定匹配词的行。\n\n#### 例子\n\n```\n// 构造数据\nstringColumn = [\"There are some apples and oranges.\",\"Mike likes apples.\",\"Alice likes oranges.\",\"Mike gives Alice an apple.\",\"Alice gives Mike an orange.\",\"John likes peaches, so he does not give them to anyone.\",\"Mike, can you give me some apples?\",\"Alice, can you give me some oranges?\",\"Mike traded an orange for an apple with Alice.\"]\nt = table([1,1,1,2,2,2,3,3,3] as id1, [1,2,3,1,2,3,1,2,3] as id2, stringColumn as remark) \nif(existsDatabase(\"dfs://textDB\")) dropDatabase(\"dfs://textDB\")\ndb = database(directory=\"dfs://textDB\", partitionType=VALUE, partitionScheme=[1,2,3], engine=\"PKEY\")\npt = createPartitionedTable(dbHandle=db, table=t, tableName=\"pt\", partitionColumns=\"id1\",primaryKey=`id1`id2,indexes={\"remark\":\"textindex(parser=english, full=false, lowercase=true, stem=true)\"})\npt.tableInsert(t)\n\n// 匹配包含 apple 或 orange 的行\nselect * from pt where matchAny(textCol=remark,terms=\"apple orange\")\n```\n\n<table id=\"table_xc3_qtm_cdc\"><thead><tr><th>\n\nid1\n\n</th><th>\n\nid2\n\n</th><th>\n\nremark\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\n1\n\n</td><td>\n\nThere are some apples and oranges.\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n2\n\n</td><td>\n\nMike likes apples.\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n3\n\n</td><td>\n\nAlice likes oranges.\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\nMike gives Alice an apple.\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n2\n\n</td><td>\n\nAlice gives Mike an orange.\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n1\n\n</td><td>\n\nMike, can you give me some apples?\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n2\n\n</td><td>\n\nAlice, can you give me some oranges?\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n3\n\n</td><td>\n\nMike traded an orange for an apple with Alice.\n\n</td></tr></tbody>\n</table>\n"
    },
    "matchPhrase": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matchphrase.html",
        "signatures": [
            {
                "full": "matchPhrase(textCol, phrase)",
                "name": "matchPhrase",
                "parameters": [
                    {
                        "full": "textCol",
                        "name": "textCol"
                    },
                    {
                        "full": "phrase",
                        "name": "phrase"
                    }
                ]
            }
        ],
        "markdown": "### [matchPhrase](https://docs.dolphindb.cn/zh/funcs/m/matchphrase.html)\n\n\n\n#### 语法\n\nmatchPhrase(textCol, phrase)\n\n#### 参数\n\n**textCol** 待查询的列，即 PKEY 存储引擎中设置了文本索引的列。\n\n**phrase**STRING 类型标量，用于指定待查询的短语。\n\n#### 详情\n\n该函数用于 SQL 语句的 WHERE 子句，针对 PKEY 存储引擎中设置文本索引的列进行文本匹配，返回包含指定短语的行。\n\n#### 例子\n\n```\n// 构造数据\nstringColumn = [\"There are some apples and oranges.\",\"Mike likes apples.\",\"Alice likes oranges.\",\"Mike gives Alice an apple.\",\"Alice gives Mike an orange.\",\"John likes peaches, so he does not give them to anyone.\",\"Mike, can you give me some apples?\",\"Alice, can you give me some oranges?\",\"Mike traded an orange for an apple with Alice.\"]\nt = table([1,1,1,2,2,2,3,3,3] as id1, [1,2,3,1,2,3,1,2,3] as id2, stringColumn as remark) \nif(existsDatabase(\"dfs://textDB\")) dropDatabase(\"dfs://textDB\")\ndb = database(directory=\"dfs://textDB\", partitionType=VALUE, partitionScheme=[1,2,3], engine=\"PKEY\")\npt = createPartitionedTable(dbHandle=db, table=t, tableName=\"pt\", partitionColumns=\"id1\",primaryKey=`id1`id2,indexes={\"remark\":\"textindex(parser=english, full=false, lowercase=true, stem=true)\"})\npt.tableInsert(t)\n\n// 匹配包含短语 give Mike 的行\nselect * from pt where matchPhrase(remark,\"give Mike\")\n```\n\n<table id=\"table_hnv_m5m_cdc\"><thead><tr><th>\n\nid1\n\n</th><th>\n\nid2\n\n</th><th>\n\nremark\n\n</th></tr></thead><tbody><tr><td>\n\n2\n\n</td><td>\n\n2\n\n</td><td>\n\nAlice gives Mike an orange\n\n</td></tr></tbody>\n</table>\n"
    },
    "matchPhraseInfix": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matchphraseinfix.html",
        "signatures": [
            {
                "full": "matchPhraseInfix(textCol, suffix, phrase, prefix)",
                "name": "matchPhraseInfix",
                "parameters": [
                    {
                        "full": "textCol",
                        "name": "textCol"
                    },
                    {
                        "full": "suffix",
                        "name": "suffix"
                    },
                    {
                        "full": "phrase",
                        "name": "phrase"
                    },
                    {
                        "full": "prefix",
                        "name": "prefix"
                    }
                ]
            }
        ],
        "markdown": "### [matchPhraseInfix](https://docs.dolphindb.cn/zh/funcs/m/matchphraseinfix.html)\n\n\n\n#### 语法\n\nmatchPhraseInfix(textCol, suffix, phrase, prefix)\n\n#### 参数\n\n**textCol** 待查询的列，即 PKEY 存储引擎中设置了文本索引的列。\n\n**suffix**STRING 类型标量，用于指定待查询的后缀。\n\n**phrase**STRING 类型标量，用于指定待查询的短语。\n\n**prefix**STRING 类型标量，用于指定待查询的前缀。\n\n#### 详情\n\n该函数用于 SQL 语句的 WHERE 子句，针对 PKEY 存储引擎中设置文本索引的列进行文本匹配，若包含特定短语，且短语前是某一特定后缀的单词，短语后是某一特定前缀的单词，则该行匹配成功。返回所有匹配成功的行。\n\n#### 例子\n\n```\n// 构造数据\nstringColumn = [\"There are some apples and oranges.\",\"Mike likes apples.\",\"Alice likes oranges.\",\"Mike gives Alice an apple.\",\"Alice gives Mike an orange.\",\"John likes peaches, so he does not give them to anyone.\",\"Mike, can you give me some apples?\",\"Alice, can you give me some oranges?\",\"Mike traded an orange for an apple with Alice.\"]\nt = table([1,1,1,2,2,2,3,3,3] as id1, [1,2,3,1,2,3,1,2,3] as id2, stringColumn as remark) \nif(existsDatabase(\"dfs://textDB\")) dropDatabase(\"dfs://textDB\")\ndb = database(directory=\"dfs://textDB\", partitionType=VALUE, partitionScheme=[1,2,3], engine=\"PKEY\")\npt = createPartitionedTable(dbHandle=db, table=t, tableName=\"pt\", partitionColumns=\"id1\",primaryKey=`id1`id2,indexes={\"remark\":\"textindex(parser=english, full=false, lowercase=true, stem=true)\"})\npt.tableInsert(t)\n\n// 匹配包含单词 give，且 give 前为 ke 后缀单词, 后为 al 前缀单词的行\nselect * from pt where matchPhraseInfix(remark,\"ke\",\"give\",\"al\")\n```\n\n<table id=\"table_ftg_zvm_cdc\"><thead><tr><th>\n\nid1\n\n</th><th>\n\nid2\n\n</th><th>\n\nremark\n\n</th></tr></thead><tbody><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\nMike gives Alice an apple.\n\n</td></tr></tbody>\n</table>\n"
    },
    "matchPhrasePrefix": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matchphraseprefix.html",
        "signatures": [
            {
                "full": "matchPhrasePrefix(textCol, phrase, prefix)",
                "name": "matchPhrasePrefix",
                "parameters": [
                    {
                        "full": "textCol",
                        "name": "textCol"
                    },
                    {
                        "full": "phrase",
                        "name": "phrase"
                    },
                    {
                        "full": "prefix",
                        "name": "prefix"
                    }
                ]
            }
        ],
        "markdown": "### [matchPhrasePrefix](https://docs.dolphindb.cn/zh/funcs/m/matchphraseprefix.html)\n\n\n\n#### 语法\n\nmatchPhrasePrefix(textCol, phrase, prefix)\n\n#### 参数\n\n**textCol** 待查询的列，即 PKEY 存储引擎中设置了文本索引的列。\n\n**phrase**STRING 类型标量，用于指定待查询的短语。\n\n**prefix**STRING 类型标量，用于指定待查询的前缀。\n\n#### 详情\n\n该函数用于 SQL 语句的 WHERE 子句，针对 PKEY 存储引擎中设置文本索引的列进行文本匹配，若包含特定短语，且短语后是某一特定前缀的单词，则该行匹配成功。返回所有匹配成功的行。\n\n#### 例子\n\n```\n// 构造数据\nstringColumn = [\"There are some apples and oranges.\",\"Mike likes apples.\",\"Alice likes oranges.\",\"Mike gives Alice an apple.\",\"Alice gives Mike an orange.\",\"John likes peaches, so he does not give them to anyone.\",\"Mike, can you give me some apples?\",\"Alice, can you give me some oranges?\",\"Mike traded an orange for an apple with Alice.\"]\nt = table([1,1,1,2,2,2,3,3,3] as id1, [1,2,3,1,2,3,1,2,3] as id2, stringColumn as remark) \nif(existsDatabase(\"dfs://textDB\")) dropDatabase(\"dfs://textDB\")\ndb = database(directory=\"dfs://textDB\", partitionType=VALUE, partitionScheme=[1,2,3], engine=\"PKEY\")\npt = createPartitionedTable(dbHandle=db, table=t, tableName=\"pt\", partitionColumns=\"id1\",primaryKey=`id1`id2,indexes={\"remark\":\"textindex(parser=english, full=false, lowercase=true, stem=true)\"})\npt.tableInsert(t)\n\n// 匹配包含单词 give，且 give 后为 mi 前缀单词的行\nselect * from pt where matchPhrasePrefix(remark,\"give\",\"mi\")\n```\n\n<table id=\"table_gnl_kvm_cdc\"><thead><tr><th>\n\nid1\n\n</th><th>\n\nid2\n\n</th><th>\n\nremark\n\n</th></tr></thead><tbody><tr><td>\n\n2\n\n</td><td>\n\n2\n\n</td><td>\n\nAlice gives Mike an orange.\n\n</td></tr></tbody>\n</table>\n"
    },
    "matchPhraseSuffix": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matchphrasesuffix.html",
        "signatures": [
            {
                "full": "matchPhraseSuffix(textCol, suffix, phrase)",
                "name": "matchPhraseSuffix",
                "parameters": [
                    {
                        "full": "textCol",
                        "name": "textCol"
                    },
                    {
                        "full": "suffix",
                        "name": "suffix"
                    },
                    {
                        "full": "phrase",
                        "name": "phrase"
                    }
                ]
            }
        ],
        "markdown": "### [matchPhraseSuffix](https://docs.dolphindb.cn/zh/funcs/m/matchphrasesuffix.html)\n\n\n\n#### 语法\n\nmatchPhraseSuffix(textCol, suffix, phrase)\n\n#### 参数\n\n**textCol** 待查询的列，即 PKEY 存储引擎中设置了文本索引的列。\n\n**suffix**STRING 类型标量，用于指定待查询的后缀。\n\n**phrase**STRING 类型标量，用于指定待查询的短语。\n\n#### 详情\n\n该函数用于 SQL 语句的 WHERE 子句，针对 PKEY 存储引擎中设置文本索引的列进行文本匹配，若包含特定短语，且短语前是某一特定后缀的单词，则该行匹配成功。返回所有匹配成功的行。\n\n#### 例子\n\n```\n// 构造数据\nstringColumn = [\"There are some apples and oranges.\",\"Mike likes apples.\",\"Alice likes oranges.\",\"Mike gives Alice an apple.\",\"Alice gives Mike an orange.\",\"John likes peaches, so he does not give them to anyone.\",\"Mike, can you give me some apples?\",\"Alice, can you give me some oranges?\",\"Mike traded an orange for an apple with Alice.\"]\nt = table([1,1,1,2,2,2,3,3,3] as id1, [1,2,3,1,2,3,1,2,3] as id2, stringColumn as remark) \nif(existsDatabase(\"dfs://textDB\")) dropDatabase(\"dfs://textDB\")\ndb = database(directory=\"dfs://textDB\", partitionType=VALUE, partitionScheme=[1,2,3], engine=\"PKEY\")\npt = createPartitionedTable(dbHandle=db, table=t, tableName=\"pt\", partitionColumns=\"id1\",primaryKey=`id1`id2,indexes={\"remark\":\"textindex(parser=english, full=false, lowercase=true, stem=true)\"})\npt.tableInsert(t)\n\n// 匹配包含单词 give，且 give 前为 ke 后缀单词的行\nselect * from pt where matchPhraseSuffix(remark,\"ke\",\"give\")\n```\n\n<table id=\"table_n3w_tvm_cdc\"><thead><tr><th>\n\nid1\n\n</th><th>\n\nid2\n\n</th><th>\n\nremark\n\n</th></tr></thead><tbody><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\nMike gives Alice an apple.\n\n</td></tr></tbody>\n</table>\n"
    },
    "matchPrefix": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matchprefix.html",
        "signatures": [
            {
                "full": "matchPrefix(textCol, prefix)",
                "name": "matchPrefix",
                "parameters": [
                    {
                        "full": "textCol",
                        "name": "textCol"
                    },
                    {
                        "full": "prefix",
                        "name": "prefix"
                    }
                ]
            }
        ],
        "markdown": "### [matchPrefix](https://docs.dolphindb.cn/zh/funcs/m/matchprefix.html)\n\n\n\n#### 语法\n\nmatchPrefix(textCol, prefix)\n\n#### 参数\n\n**textCol** 待查询的列，即 PKEY 存储引擎中设置了文本索引的列。\n\n**prefix**STRING 类型标量，用于指定待查询的前缀。\n\n#### 详情\n\n该函数用于 SQL 语句的 WHERE 子句，针对 PKEY 存储引擎中设置文本索引的列进行前缀匹配，返回包含指定前缀的行。\n\n#### 例子\n\n```\n// 构造数据\nstringColumn = [\"There are some apples and oranges.\",\"Mike likes apples.\",\"Alice likes oranges.\",\"Mike gives Alice an apple.\",\"Alice gives Mike an orange.\",\"John likes peaches, so he does not give them to anyone.\",\"Mike, can you give me some apples?\",\"Alice, can you give me some oranges?\",\"Mike traded an orange for an apple with Alice.\"]\nt = table([1,1,1,2,2,2,3,3,3] as id1, [1,2,3,1,2,3,1,2,3] as id2, stringColumn as remark) \nif(existsDatabase(\"dfs://textDB\")) dropDatabase(\"dfs://textDB\")\ndb = database(directory=\"dfs://textDB\", partitionType=VALUE, partitionScheme=[1,2,3], engine=\"PKEY\")\npt = createPartitionedTable(dbHandle=db, table=t, tableName=\"pt\", partitionColumns=\"id1\",primaryKey=`id1`id2,indexes={\"remark\":\"textindex(parser=english, full=false, lowercase=true, stem=true)\"})\npt.tableInsert(t)\n\n// 匹配包含前缀是 app 的单词的行\nselect * from pt where matchPrefix(remark,\"app\")\n```\n\n<table id=\"table_dlq_s5m_cdc\"><thead><tr><th>\n\nid1\n\n</th><th>\n\nid2\n\n</th><th>\n\nremark\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\n1\n\n</td><td>\n\nThere are some apples and oranges.\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n2\n\n</td><td>\n\nMike likes apples.\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\nMike gives Alice an apple.\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n1\n\n</td><td>\n\nMike, can you give me some apples?\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n3\n\n</td><td>\n\nMike traded an orange for an apple with Alice.\n\n</td></tr></tbody>\n</table>\n"
    },
    "matchPrefixSuffix": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matchprefixsuffix.html",
        "signatures": [
            {
                "full": "matchPrefixSuffix(textCol, prefix, suffix)",
                "name": "matchPrefixSuffix",
                "parameters": [
                    {
                        "full": "textCol",
                        "name": "textCol"
                    },
                    {
                        "full": "prefix",
                        "name": "prefix"
                    },
                    {
                        "full": "suffix",
                        "name": "suffix"
                    }
                ]
            }
        ],
        "markdown": "### [matchPrefixSuffix](https://docs.dolphindb.cn/zh/funcs/m/matchprefixsuffix.html)\n\n\n\n#### 语法\n\nmatchPrefixSuffix(textCol, prefix, suffix)\n\n#### 参数\n\n**textCol** 待查询的列，即 PKEY 存储引擎中设置了文本索引的列。\n\n**prefix**STRING 类型标量，用于指定待查询的前缀。\n\n**suffix**STRING 类型标量，用于指定待查询的后缀。\n\n#### 详情\n\n该函数用于 SQL 语句的 WHERE 子句，针对 PKEY 存储引擎中设置文本索引的列进行前缀和后缀匹配，检查是否有词同时满足前缀和后缀条件，并返回匹配成功的行。\n\n#### 例子\n\n```\n// 构造数据\nstringColumn = [\"There are some apples and oranges.\",\"Mike likes apples.\",\"Alice likes oranges.\",\"Mike gives Alice an apple.\",\"Alice gives Mike an orange.\",\"John likes peaches, so he does not give them to anyone.\",\"Mike, can you give me some apples?\",\"Alice, can you give me some oranges?\",\"Mike traded an orange for an apple with Alice.\"]\nt = table([1,1,1,2,2,2,3,3,3] as id1, [1,2,3,1,2,3,1,2,3] as id2, stringColumn as remark) \nif(existsDatabase(\"dfs://textDB\")) dropDatabase(\"dfs://textDB\")\ndb = database(directory=\"dfs://textDB\", partitionType=VALUE, partitionScheme=[1,2,3], engine=\"PKEY\")\npt = createPartitionedTable(dbHandle=db, table=t, tableName=\"pt\", partitionColumns=\"id1\",primaryKey=`id1`id2,indexes={\"remark\":\"textindex(parser=english, full=false, lowercase=true, stem=true)\"})\npt.tableInsert(t)\n\n// 匹配包含以 m 为前缀，ke 为后缀的单词的行\nselect * from pt where matchPrefixSuffix(remark,\"m\",\"ke\")\n```\n\n<table id=\"table_yyz_fvm_cdc\"><thead><tr><th>\n\nid1\n\n</th><th>\n\nid2\n\n</th><th>\n\nremark\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\n2\n\n</td><td>\n\nMike likes apples.\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\nMike gives Alice an apple.\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n2\n\n</td><td>\n\nAlice gives Mike an orange.\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n1\n\n</td><td>\n\nMike, can you give me some apples?\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n3\n\n</td><td>\n\nMike traded an orange for an apple with Alice.\n\n</td></tr></tbody>\n</table>\n"
    },
    "matchSpan": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matchspan.html",
        "signatures": [
            {
                "full": "matchSpan(textCol, span, slop)",
                "name": "matchSpan",
                "parameters": [
                    {
                        "full": "textCol",
                        "name": "textCol"
                    },
                    {
                        "full": "span",
                        "name": "span"
                    },
                    {
                        "full": "slop",
                        "name": "slop"
                    }
                ]
            }
        ],
        "markdown": "### [matchSpan](https://docs.dolphindb.cn/zh/funcs/m/matchspan.html)\n\n\n\n#### 语法\n\nmatchSpan(textCol, span, slop)\n\n#### 参数\n\n**textCol** 待查询的列，即 PKEY 存储引擎中设置了文本索引的列。\n\n**span**STRING 类型标量，用于指定待查询的短语。\n\n**slop**非负整数，表示用户输入的词距。匹配时，若短语前、后或短语中有不多于 *slop* 个其他词语，仍视作匹配成功。\n\n#### 详情\n\n该函数用于 SQL 语句的 WHERE 子句，针对 PKEY 存储引擎中设置文本索引的列进行文本匹配，返回包含指定短语的行。\n\n#### 例子\n\n```\n// 构造数据\nstringColumn = [\"There are some apples and oranges.\",\"Mike likes apples.\",\"Alice likes oranges.\",\"Mike gives Alice an apple.\",\"Alice gives Mike an orange.\",\"John likes peaches, so he does not give them to anyone.\",\"Mike, can you give me some apples?\",\"Alice, can you give me some oranges?\",\"Mike traded an orange for an apple with Alice.\"]\nt = table([1,1,1,2,2,2,3,3,3] as id1, [1,2,3,1,2,3,1,2,3] as id2, stringColumn as remark) \nif(existsDatabase(\"dfs://textDB\")) dropDatabase(\"dfs://textDB\")\ndb = database(directory=\"dfs://textDB\", partitionType=VALUE, partitionScheme=[1,2,3], engine=\"PKEY\")\npt = createPartitionedTable(dbHandle=db, table=t, tableName=\"pt\", partitionColumns=\"id1\",primaryKey=`id1`id2,indexes={\"remark\":\"textindex(parser=english, full=false, lowercase=true, stem=true)\"})\npt.tableInsert(t)\n\n// 匹配包含短语 mike apple 的行，且允许短语前后或内部有小于等于3个其他词汇（不包括停止词）\nselect * from pt where matchSpan(remark, \"mike apple\", 2)\n```\n\n<table id=\"table_cpb_fwm_cdc\"><thead><tr><th>\n\nid1\n\n</th><th>\n\nid2\n\n</th><th>\n\nremark\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\n2\n\n</td><td>\n\nMike likes apples.\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\nMike gives Alice an apple.\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n3\n\n</td><td>\n\nMike traded an orange for an apple with Alice.\n\n</td></tr></tbody>\n</table>\n"
    },
    "matchSuffix": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matchsuffix.html",
        "signatures": [
            {
                "full": "matchSuffix(textCol, suffix)",
                "name": "matchSuffix",
                "parameters": [
                    {
                        "full": "textCol",
                        "name": "textCol"
                    },
                    {
                        "full": "suffix",
                        "name": "suffix"
                    }
                ]
            }
        ],
        "markdown": "### [matchSuffix](https://docs.dolphindb.cn/zh/funcs/m/matchsuffix.html)\n\n\n\n#### 语法\n\nmatchSuffix(textCol, suffix)\n\n#### 参数\n\n**textCol** 待查询的列，即 PKEY 存储引擎中设置了文本索引的列。\n\n**suffix**STRING 类型标量，用于指定待查询的后缀。\n\n#### 详情\n\n该函数用于 SQL 语句的 WHERE 子句，针对 PKEY 存储引擎中设置文本索引的列进行后缀匹配，返回包含指定后缀的行。\n\n#### 例子\n\n```\n// 构造数据\nstringColumn = [\"There are some apples and oranges.\",\"Mike likes apples.\",\"Alice likes oranges.\",\"Mike gives Alice an apple.\",\"Alice gives Mike an orange.\",\"John likes peaches, so he does not give them to anyone.\",\"Mike, can you give me some apples?\",\"Alice, can you give me some oranges?\",\"Mike traded an orange for an apple with Alice.\"]\nt = table([1,1,1,2,2,2,3,3,3] as id1, [1,2,3,1,2,3,1,2,3] as id2, stringColumn as remark) \nif(existsDatabase(\"dfs://textDB\")) dropDatabase(\"dfs://textDB\")\ndb = database(directory=\"dfs://textDB\", partitionType=VALUE, partitionScheme=[1,2,3], engine=\"PKEY\")\npt = createPartitionedTable(dbHandle=db, table=t, tableName=\"pt\", partitionColumns=\"id1\",primaryKey=`id1`id2,indexes={\"remark\":\"textindex(parser=english, full=false, lowercase=true, stem=true)\"})\npt.tableInsert(t)\n\n// 匹配包含后缀是 ke 的单词的行\nselect * from pt where matchSuffix(remark,\"ke\")\n```\n\n<table id=\"table_t5m_1vm_cdc\"><thead><tr><th>\n\nid1\n\n</th><th>\n\nid2\n\n</th><th>\n\nremark\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\n2\n\n</td><td>\n\nMike likes apples.\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n3\n\n</td><td>\n\nAlice likes oranges.\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\nMike gives Alice an apple.\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n2\n\n</td><td>\n\nAlice gives Mike an orange.\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n3\n\n</td><td>\n\nJohn likes peaches, so he does not give them to anyone.\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n1\n\n</td><td>\n\nMike, can you give me some apples?\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n3\n\n</td><td>\n\nMike traded an orange for an apple with Alice.\n\n</td></tr></tbody>\n</table>\n"
    },
    "matchUnorderedSpan": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matchunorderedspan.html",
        "signatures": [
            {
                "full": "matchUnorderedSpan(textCol, span, slop)",
                "name": "matchUnorderedSpan",
                "parameters": [
                    {
                        "full": "textCol",
                        "name": "textCol"
                    },
                    {
                        "full": "span",
                        "name": "span"
                    },
                    {
                        "full": "slop",
                        "name": "slop"
                    }
                ]
            }
        ],
        "markdown": "### [matchUnorderedSpan](https://docs.dolphindb.cn/zh/funcs/m/matchunorderedspan.html)\n\n\n\n#### 语法\n\nmatchUnorderedSpan(textCol, span, slop)\n\n#### 参数\n\n**textCol** 待查询的列，即 PKEY 存储引擎中设置了文本索引的列。\n\n**span**STRING 类型标量，用于指定待查询的短语。\n\n**slop**非负整数，表示用户输入的词距。匹配时，若短语前、后或短语中有不多于 *slop* 个其他词语，仍视作匹配成功。\n\n#### 详情\n\n该函数用于 SQL 语句的 WHERE 子句，针对 PKEY 存储引擎中设置文本索引的列进行文本匹配，返回包含指定短语的行。不同于 matchSpan 的是，该函数在匹配时将忽略短语中单词的顺序。\n\n#### 例子\n\n```\n// 构造数据\nstringColumn = [\"There are some apples and oranges.\",\"Mike likes apples.\",\"Alice likes oranges.\",\"Mike gives Alice an apple.\",\"Alice gives Mike an orange.\",\"John likes peaches, so he does not give them to anyone.\",\"Mike, can you give me some apples?\",\"Alice, can you give me some oranges?\",\"Mike traded an orange for an apple with Alice.\"]\nt = table([1,1,1,2,2,2,3,3,3] as id1, [1,2,3,1,2,3,1,2,3] as id2, stringColumn as remark) \nif(existsDatabase(\"dfs://textDB\")) dropDatabase(\"dfs://textDB\")\ndb = database(directory=\"dfs://textDB\", partitionType=VALUE, partitionScheme=[1,2,3], engine=\"PKEY\")\npt = createPartitionedTable(dbHandle=db, table=t, tableName=\"pt\", partitionColumns=\"id1\",primaryKey=`id1`id2,indexes={\"remark\":\"textindex(parser=english, full=false, lowercase=true, stem=true)\"})\npt.tableInsert(t)\n\n// 匹配包含短语 mike apple 的行，忽略 mike 和 apple 的顺序，且允许短语前后或内部有小于等于2个其他词汇\nselect * from pt where matchUnorderedSpan(remark, \"apple mike\", 2)\n```\n\n<table id=\"table_lxq_4wm_cdc\"><thead><tr><th>\n\nid1\n\n</th><th>\n\nid2\n\n</th><th>\n\nremark\n\n</th></tr></thead><tbody><tr><td>\n\n1\n\n</td><td>\n\n2\n\n</td><td>\n\nMike likes apples.\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\n1\n\n</td><td>\n\nMike gives Alice an apple.\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\n3\n\n</td><td>\n\nMike traded an orange for an apple with Alice.\n\n</td></tr></tbody>\n</table>\n"
    },
    "matrix": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matrix.html",
        "signatures": [
            {
                "full": "matrix(X1, [X2], ...)",
                "name": "matrix",
                "parameters": [
                    {
                        "full": "X1",
                        "name": "X1"
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": "...",
                        "name": "..."
                    }
                ]
            },
            {
                "full": "matrix(dataType, rows, cols, [columnsCapacity], [defaultValue])",
                "name": "matrix",
                "parameters": [
                    {
                        "full": "dataType",
                        "name": "dataType"
                    },
                    {
                        "full": "rows",
                        "name": "rows"
                    },
                    {
                        "full": "cols",
                        "name": "cols"
                    },
                    {
                        "full": "[columnsCapacity]",
                        "name": "columnsCapacity",
                        "optional": true
                    },
                    {
                        "full": "[defaultValue]",
                        "name": "defaultValue",
                        "optional": true
                    }
                ]
            },
            {
                "full": "matrix(X)",
                "name": "matrix",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [matrix](https://docs.dolphindb.cn/zh/funcs/m/matrix.html)\n\n\n\n#### 语法\n\nmatrix(X1, \\[X2], ...)\n\n或\n\nmatrix(dataType, rows, cols, \\[columnsCapacity], \\[defaultValue])\n\n或\n\nmatrix(X)\n\n#### 参数\n\n* 第一种情况中，**X1**, **X2**, **...** 可以是混合类型，包括向量、矩阵、表（不能包含 SYMBOL 字段）、元组或它们的任意组合。\n\n* 第二种情况中：\n\n  **dataType** 是矩阵的数据类型，支持除 INT128、UUID、IPADDR、POINT 和 DURATION 外的其他数据类型。\n\n  **rows** 是行数。\n\n  **cols** 是列数。\n\n  **columnsCapacity** 是正整数，表示矩阵的容量，即新建该矩阵时，系统为该矩阵分配的内存（以列数为单位）。当列数超过 *capacity* 时，系统会自动扩充容量。系统首先会分配当前容量1.2\\~2倍的内存，然后复制数据到新的内存空间，最后释放原来的内存。\n\n  **defaultValue** 是矩阵的默认值。不指定默认值，对于整数或浮点数类型，矩阵中所有的元素都是 0，对于符号类型，所有元素都是 NULL。\n\n* 第三种情况下：**X** 是一个数组向量（arrayVector），且数组向量每个元素的长度必须相等。\n\n#### 详情\n\n返回一个矩阵。\n\n#### 例子\n\n```\nx=matrix(INT,3,2, ,1);\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 1  | 1  |\n| 1  | 1  |\n\n```\ny = matrix(DECIMAL32(3),2,3)\ny \n```\n\n| #0    | #1    | #2    |\n| ----- | ----- | ----- |\n| 0.000 | 0.000 | 0.000 |\n| 0.000 | 0.000 | 0.000 |\n\n```\ns=matrix(SYMBOL,2,2, ,`T);\ns;\n```\n\n| #0 | #1 |\n| -- | -- |\n| T  | T  |\n| T  | T  |\n\n```\nmatrix(table(1 2 3 as id, 4 5 6 as value));\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nmatrix([1 2 3, 4 5 6]);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nmatrix([1 2 3, 4 5 6], 7 8 9, table(0.5 0.6 0.7 as id), 1..9$3:3);\n```\n\n| #0 | #1 | #2 | #3  | #4 | #5 | #6 |\n| -- | -- | -- | --- | -- | -- | -- |\n| 1  | 4  | 7  | 0.5 | 1  | 4  | 7  |\n| 2  | 5  | 8  | 0.6 | 2  | 5  | 8  |\n| 3  | 6  | 9  | 0.7 | 3  | 6  | 9  |\n\n```\nmatrix(`AA`BB`CC,`DD`EE`FF)\n```\n\n输出为：\n\n| #0 | #1 |\n| -- | -- |\n| AA | DD |\n| BB | EE |\n| CC | FF |\n\n当表中含有 SYMBOL 字段时，通过 matrix 进行转换时会出现报错，如下例：\n\n```\nt = table(symbol([\"a\", \"b\"]) as sym, [1, 2] as val)\nmatrix(t)\n// output: matrix(t) => Failed to append a table object to a matrix.\n```\n\n将 SYMBOL 类型转换为 STRING 类型后，可以进行转换，见如下代码：\n\n```\nt = table(string([\"a\", \"b\"]) as sym, [1, 2] as val)\nmatrix(t)\n```\n\n<table id=\"table_dss_l4y_bdc\"><thead><tr><th align=\"left\" id=\"d264217e506\">\n\n\\#1\n\n</th><th align=\"left\" id=\"d264217e512\">\n\n\\#2\n\n</th></tr></thead><tbody><tr><td>\n\na\n\n</td><td>\n\n1\n\n</td></tr><tr><td>\n\nb\n\n</td><td>\n\n2\n\n</td></tr></tbody>\n</table>**Related information**  \n\n[array](https://docs.dolphindb.cn/zh/funcs/a/array.html)\n\n[dict](https://docs.dolphindb.cn/zh/funcs/d/dict.html)\n"
    },
    "matrixRank": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/matrixRank.html",
        "signatures": [
            {
                "full": "matrixRank(A, [tol])",
                "name": "matrixRank",
                "parameters": [
                    {
                        "full": "A",
                        "name": "A"
                    },
                    {
                        "full": "[tol]",
                        "name": "tol",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [matrixRank](https://docs.dolphindb.cn/zh/funcs/m/matrixRank.html)\n\n\n\n#### 语法\n\nmatrixRank(A, \\[tol])\n\n#### 参数\n\n**A**数值型矩阵，一维矩阵也可以用向量表示。\n\n**tol**数值型标量，小于 tol 的奇异值将被视为零，因此矩阵的秩为该矩阵大于 tol 的奇异值的个数。默认值为双精度浮点数的最小精度 DBL\\_EPSILON = 2.22044604925e-16。\n\n#### 详情\n\n计算矩阵的秩。\n\n#### 例子\n\n```\nm1 = matrix(1..4,1..4*2,3..6)\nmatrixRank(m1) \n// output：2\n```\n"
    },
    "mavg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mavg.html",
        "signatures": [
            {
                "full": "mavg(X, window|weights, [minPeriods])",
                "name": "mavg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window|weights",
                        "name": "window|weights"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mavg](https://docs.dolphindb.cn/zh/funcs/m/mavg.html)\n\n\n\n#### 语法\n\nmavg(X, window|weights, \\[minPeriods])\n\n参数说明和窗口计算规则请参考: [mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n若 *X* 为向量，则返回与 *X* 具有相同长度的向量。若第二个参数为:\n\n* *window*: 在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 元素的平均值。\n\n* *weights*：在长度为 size(*weights*)的滑动窗口中计算 *X* 的加权平均值，其中 size(*weights*) 的有效范围是\\[0, 1024]。*weights* 表示权重向量。结果前(size(*weights*) - 1)个元素为 NULL。此时 *minPeriods* 无效。\n\n若 *X* 为矩阵/表则在每一列进行计算, 返回相同维度的矩阵/表。\n\n#### 例子\n\n```\nX = 7 4 6 0 -5 32 9 8;\nY = 7 4 6 NULL -5 32 9 8;\nweight = 2 3 5\nmavg(X, 4);\n// output\n[,,,4.25,1.25,8.25,9,11]\n\nmavg(Y, 4);\n// output\n[,,,5.67,1.67,11,12,11]\n\nmavg(Y, weight);\n// output\n[,,5.6,5.2,-1.8571,18.125,13.1,13.1]\n```\n\n```\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(2020.01.06 2020.01.07 2020.01.09 2020.01.11 2020.01.12 2020.01.15, `col1`col2)\nm.setIndexedMatrix!()\nmavg(m, 3d) // 等价于 msum(m, 3)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.01.06 | 1    | 9    |\n| 2020.01.07 | 1    | 9    |\n| 2020.01.09 | 4    |      |\n| 2020.01.11 | 4    | 10   |\n| 2020.01.12 | 8    | 10   |\n| 2020.01.15 | 6    | 2    |\n\n```\nmavg(m, 1w)\n```\n\n| label      | col1   | col2 |\n| ---------- | ------ | ---- |\n| 2020.01.06 | 1      | 9    |\n| 2020.01.07 | 1      | 9    |\n| 2020.01.09 | 2.5    | 9    |\n| 2020.01.11 | 2.5    | 9.5  |\n| 2020.01.12 | 4.3333 | 9.5  |\n| 2020.01.15 | 6      | 6    |\n\n相关函数：[avg](https://docs.dolphindb.cn/zh/funcs/a/avg.html)\n"
    },
    "mavgTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mavgTopN.html",
        "signatures": [
            {
                "full": "mavgTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mavgTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mavgTopN](https://docs.dolphindb.cn/zh/funcs/m/mavgTopN.html)\n\n\n\n#### 语法\n\nmavgTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素计算平均值。\n\n#### 例子\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmavgTopN(X, S, 4, 2)\n// output\n[1,1.5,2,3.5,3.5,3.5,5]\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmavgTopN(X, S, 4, 2)\n// output\n[,1,2,2.5,2.5,2.5,3]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmavgTopN(X, S, 3, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n| 1   | 6   |\n| 1.5 | 6.5 |\n| 2   | 7   |\n| 2.5 | 7.5 |\n| 4   | 9   |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmavgTopN(X, S, 3, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n| 1   |     |\n| 1.5 | 7   |\n| 2   | 7.5 |\n| 2.5 | 7.5 |\n| 4   | 8.5 |\n\n某行情数据的数据表，包含四列：股票代码 code，交易日期 date，收盘价 close 和交易量 volume。\n\n```\nt = table(take(`IBM`APPL, 20) as code, 2020.01.01 + 1..20 as date, rand(100,20) + 20 as volume, rand(10,20) + 100.0 as close)\n```\n\n| code | date       | volume | close |\n| ---- | ---------- | ------ | ----- |\n| IBM  | 2020.01.02 | 114    | 107   |\n| APPL | 2020.01.03 | 66     | 106   |\n| IBM  | 2020.01.04 | 36     | 106   |\n| APPL | 2020.01.05 | 52     | 101   |\n| IBM  | 2020.01.06 | 28     | 100   |\n| APPL | 2020.01.07 | 55     | 108   |\n| IBM  | 2020.01.08 | 54     | 106   |\n| APPL | 2020.01.09 | 103    | 106   |\n| IBM  | 2020.01.10 | 94     | 104   |\n| APPL | 2020.01.11 | 82     | 102   |\n| IBM  | 2020.01.12 | 98     | 103   |\n| APPL | 2020.01.13 | 118    | 101   |\n| IBM  | 2020.01.14 | 61     | 105   |\n| APPL | 2020.01.15 | 43     | 105   |\n| IBM  | 2020.01.16 | 41     | 104   |\n| APPL | 2020.01.17 | 111    | 106   |\n| IBM  | 2020.01.18 | 119    | 103   |\n| APPL | 2020.01.19 | 24     | 107   |\n| IBM  | 2020.01.20 | 22     | 109   |\n| APPL | 2020.01.21 | 26     | 103   |\n\n计算每只股票窗口期内交易量最大的3条记录的的平均收盘价。\n\n```\nselect code, date, mavgTopN(close, volume, 5, 3, false) from t context by code\n```\n\n| code | date       | mavgTopN\\_close |\n| ---- | ---------- | --------------- |\n| APPL | 2020.01.03 | 106             |\n| APPL | 2020.01.05 | 103.5           |\n| APPL | 2020.01.07 | 105             |\n| APPL | 2020.01.09 | 106.6667        |\n| APPL | 2020.01.11 | 104.6667        |\n| APPL | 2020.01.13 | 103             |\n| APPL | 2020.01.15 | 103             |\n| APPL | 2020.01.17 | 104.3333        |\n| APPL | 2020.01.19 | 103             |\n| APPL | 2020.01.21 | 104             |\n| IBM  | 2020.01.02 | 107             |\n| IBM  | 2020.01.04 | 106.5           |\n| IBM  | 2020.01.06 | 104.3333        |\n| IBM  | 2020.01.08 | 106.3333        |\n| IBM  | 2020.01.10 | 105.6667        |\n| IBM  | 2020.01.12 | 104.3333        |\n| IBM  | 2020.01.14 | 104             |\n| IBM  | 2020.01.16 | 104             |\n| IBM  | 2020.01.18 | 103.3333        |\n| IBM  | 2020.01.20 | 103.6667        |\n\n相关函数：[mavg](https://docs.dolphindb.cn/zh/funcs/m/mavg.html)\n"
    },
    "max": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/max.html",
        "signatures": [
            {
                "full": "max(X, [Y])",
                "name": "max",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [max](https://docs.dolphindb.cn/zh/funcs/m/max.html)\n\n\n\n#### 语法\n\nmax(X, \\[Y])\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n**Y** 为可选参数，可以是标量或者是和 *X* 长度相同的向量或者矩阵。\n\n#### 详情\n\n对于只输入一个参数的情况，函数的返回值说明如下：\n\n* 若 *X* 是向量，返回 *X* 中所有元素的最大值。\n\n* 若 *X* 为矩阵，计算每列的最大值，返回一个向量。\n\n* 若 *X* 为表，计算每列的最大值，返回一个表。\n\n对于输入两个参数的情况，函数返回值说明如下：\n\n* 若 *Y* 是标量，则与 *X* 中所有元素进行比较，用较大值替换 *X* 中的元素并返回。\n\n* 若 *Y* 和 *X* 类型和长度一致，则将两者对应位置的元素进行比较，返回较大的结果。\n\n请注意，从 2.00.8 版本开始，`max` 处理时间类型数据的行为（之前版本统一转换为长整型）修改为：\n\n* 若 *X* 和 *Y* 是时间类型标量，系统会将时间类型统一为两者中较高精度对应的类型，再比较大小。\n\n* 若 *X* 或 *Y* 是向量、矩阵或表，则必须具有相同的时间类型。\n\n#### 例子\n\n```\nmax(1 2 3);\n// output\n3\n\nmax(7.8 9 5.4);\n// output\n9\n\n(5 8 2 7).max();\n// output\n8\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nmax(m);\n// output\n[3,6]\n```\n\n```\nmax(1 2 3, 2)\n// output\n2 2 3\n\nn = matrix(1 1 1, 5 5 5)\nn;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 1  | 5  |\n| 1  | 5  |\n\n```\nmax(m, n);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 2  | 5  |\n| 3  | 6  |\n\n`max` 可以搭配 select 使用, 返回某列的最大值：\n\n```\nt = table(`abb`aac`aaa as sym, 1.8 2.3 3.7 as price);\nselect max price from t;\n```\n\n| max\\_price |\n| ---------- |\n| 3.7        |\n\nmax 可以应用于字符串，返回字典序最大的字符串：\n\n```\nselect max sym from t;\n```\n\n| max\\_sym |\n| -------- |\n| abb      |\n\n相关函数：[mmax](https://docs.dolphindb.cn/zh/funcs/m/mmax.html)\n"
    },
    "maxDrawdown": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/maxdrawdown.html",
        "signatures": [
            {
                "full": "maxDrawdown(X, [ratio=true])",
                "name": "maxDrawdown",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ratio=true]",
                        "name": "ratio",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [maxDrawdown](https://docs.dolphindb.cn/zh/funcs/m/maxdrawdown.html)\n\n\n\n#### 语法\n\nmaxDrawdown(X, \\[ratio=true])\n\n聚合函数，别名 mdd。\n\n#### 详情\n\n计算传入向量数据的最大回撤（Maximum Drawdown，简称 MDD）或最大回撤率（Maximum Drawdown Rate）。返回一个与 X 数据类型相同的标量，表示 X 的最大回撤或最大回撤率。\n\n#### 参数\n\n**X** 数值向量，表示用于计算最大回撤的输入数据，一般指累积的收益或收益率。注意：不可为空。\n\n**ratio**布尔标量，表示是否返回最大回撤率。默认值为 true。\n\n* 若为 true，表示返回最大回撤率，即相对于峰值的最大下降百分比，计算公式为：\n\n  ![](https://docs.dolphindb.cn/zh/funcs/images/mdd1.png)\n\n* 若为 false，表示返回基于下降金额绝对值的最大回撤，计算公式为：\n\n  ![](https://docs.dolphindb.cn/zh/funcs/images/mdd2.png)\n\n注意：计算时将忽略空值。\n\n#### 例子\n\n假设有一个投资组合在一段时间内的累积收益变化如下（以天为单位）：\n\n<table id=\"table_h24_4zx_bdc\"><thead><tr><th align=\"left\">\n\n日期\n\n</th><th align=\"left\">\n\n累积收益\n\n</th></tr></thead><tbody><tr><td>\n\n2024-10-01\n\n</td><td>\n\n36\n\n</td></tr><tr><td>\n\n2024-10-02\n\n</td><td>\n\n96\n\n</td></tr><tr><td>\n\n2024-10-03\n\n</td><td>\n\n42\n\n</td></tr><tr><td>\n\n2024-10-04\n\n</td><td>\n\n100\n\n</td></tr><tr><td>\n\n2024-10-05\n\n</td><td>\n\n59\n\n</td></tr><tr><td>\n\n2024-10-06\n\n</td><td>\n\n86\n\n</td></tr><tr><td>\n\n2024-10-07\n\n</td><td>\n\n25\n\n</td></tr><tr><td>\n\n2024-10-08\n\n</td><td>\n\n72\n\n</td></tr></tbody>\n</table>使用 `maxDrawdown` 计算该数据的最大回撤率和最大回撤。\n\n```\nx = [36,96,42,100,59,86,25,64,72]\n\nmaxDrawdown(x)\n// Output: 0.75\nmaxDrawdown(x, false)\n// Output: 75\n```\n\n相关函数：[cummdd](https://docs.dolphindb.cn/zh/funcs/c/cummdd.html)\n"
    },
    "maxIgnoreNull": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/maxignorenull.html",
        "signatures": [
            {
                "full": "maxIgnoreNull(X, Y)",
                "name": "maxIgnoreNull",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [maxIgnoreNull](https://docs.dolphindb.cn/zh/funcs/m/maxignorenull.html)\n\n#### 语法\n\n```\nmaxIgnoreNull(X, Y)\n```\n\n#### 参数\n\n**X** 和 **Y** 是数值型、LITERAL 或 TEMPORAL 型的标量/数据对/向量/矩阵。\n\n#### 详情\n\n一个二元标量函数，返回两个数（*X* 和 *Y*）中的最大值。\n\n它与 `max` 作为二元标量函数区别在于对空值的处理：\n\n* `max`：当配置项 \\*nullAsMinValueForComparison=\\*true 时，空值被视为最小值进行比较；否则空值不参与比较，结果返回空值。\n\n* `maxIgnoreNull`：不受配置项 *nullAsMinValueForComparison* 的影响。返回 *X* 或 *Y* 中的非空值，或者如果两者都非空，返回最大值。\n\n#### 例子\n\n```\nmaxIgnoreNull(2,matrix(1  NULL 4,-1 4  0)) \n```\n\n| #0 | #1 |\n| -- | -- |\n| 2  | 2  |\n| 2  | 4  |\n| 4  | 2  |\n\n```\nmaxIgnoreNull(matrix(10 3 NULL, 1 7 4),matrix(1  NULL 4,-1 4  0))\n```\n\n| #0 | #1 |\n| -- | -- |\n| 10 | 1  |\n| 3  | 7  |\n| 4  | 4  |\n\n使用 `reduce` 结合 `maxIgNoreNull`，计算元组中存储的同形状矩阵每个位置的最小值，忽略空值。\n\n```\nn1 = matrix(1 1 1, 5 5 5)\nn2 = matrix(10 11 12, 0 NULL -5)\nn3 = matrix(-1 1 NULL, -3 0 10)\nreduce(maxIgnoreNull, [n1,n2,n3])\n```\n\n| #0 | #1 |\n| -- | -- |\n| 10 | 5  |\n| 11 | 5  |\n| 12 | 10 |\n\n相关函数：[max](https://docs.dolphindb.cn/zh/funcs/m/max.html), [minIgnoreNull](https://docs.dolphindb.cn/zh/funcs/m/minignorenull.html)\n\n"
    },
    "maxPositiveStreak": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/maxPositiveStreak.html",
        "signatures": [
            {
                "full": "maxPositiveStreak(X)",
                "name": "maxPositiveStreak",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [maxPositiveStreak](https://docs.dolphindb.cn/zh/funcs/m/maxPositiveStreak.html)\n\n\n\n#### 语法\n\nmaxPositiveStreak(X)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n#### 详情\n\n如果 *X* 是向量，返回 *X* 中连续的正数之和的最大值。\n\n如果 *X* 是矩阵，返回 *X* 中每列连续的正数之和的最大值。\n\nmaxPositiveStreak(X) = max(cumPositiveStreak(X))\n\n#### 例子\n\n```\nx=1 0 -1 1 2 2 2 1 0 -1 0 2;\ncumPositiveStreak x;\n// output\n[1,0,0,1,3,5,7,8,0,0,0,2]\nmaxPositiveStreak x;\n// output\n8\n\ny=x$6:2;\ny;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 2  |\n| 0  | 1  |\n| -1 | 0  |\n| 1  | -1 |\n| 2  | 0  |\n| 2  | 2  |\n\n```\ncumPositiveStreak(y);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 2  |\n| 0  | 3  |\n| 0  | 0  |\n| 1  | 0  |\n| 3  | 0  |\n| 5  | 2  |\n\n```\nmaxPositiveStreak(y);\n// output\n[5,3]\n```\n\n相关函数：[cumPositiveStreak](https://docs.dolphindb.cn/zh/funcs/c/cumPositiveStreak.html)\n"
    },
    "mbeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mbeta.html",
        "signatures": [
            {
                "full": "mbeta(Y, X, window, [minPeriods])",
                "name": "mbeta",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mbeta](https://docs.dolphindb.cn/zh/funcs/m/mbeta.html)\n\n\n\n#### 语法\n\nmbeta(Y, X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的移动窗口中，计算 *Y* 在 *X* 上的回归系数的最小二乘估计。\n\n#### 例子\n\n```\nx=0.011 0.006 -0.008 0.012 -0.016 -0.023 0.018\ny=0.016 0.009 -0.012 0.022 0.003 -0.056 0.002\nmbeta(y, x, 5);\n// output\n[,,,,0.818182,1.692379,1.188532]\n\nmbeta(y, x, 5, 3);\n// output\n[,,1.479381,1.594701,0.818182,1.692379,1.188532]\n```\n\n```\nx1 = indexedSeries(date(2020.06.05)+1..7, x)\ny1 = indexedSeries(date(2020.06.05)+1..7, y)\nmbeta(y1, x1, 5d);\n```\n\n| label      | col1   |\n| ---------- | ------ |\n| 2020.06.06 |        |\n| 2020.06.07 | 1.4    |\n| 2020.06.08 | 1.4794 |\n| 2020.06.09 | 1.5947 |\n| 2020.06.10 | 0.8182 |\n| 2020.06.11 | 1.6924 |\n| 2020.06.12 | 1.1885 |\n\n```\nmbeta(y1, x1, 1w);\n```\n\n| label      | col1   |\n| ---------- | ------ |\n| 2020.06.06 |        |\n| 2020.06.07 | 1.4    |\n| 2020.06.08 | 1.4794 |\n| 2020.06.09 | 1.5947 |\n| 2020.06.10 | 0.8182 |\n| 2020.06.11 | 1.6924 |\n| 2020.06.12 | 1.2659 |\n\n相关函数：[beta](https://docs.dolphindb.cn/zh/funcs/b/beta.html)\n"
    },
    "mbetaTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mbetaTopN.html",
        "signatures": [
            {
                "full": "mbetaTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mbetaTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mbetaTopN](https://docs.dolphindb.cn/zh/funcs/m/mbetaTopN.html)\n\n\n\n#### 语法\n\nmbetaTopN(X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，然后计算 *Y* 在 *X* 上的回归系数的最小二乘估计。\n\n#### 例子\n\n```\nx = NULL 3 8 4 0\ny = 2 3 1 7 3\ns = 5 NULL 8 9 4\nmbetaTopN(x, y, s, 3, 2)\n// output\n[ , , , -0.66, -4]\n\ns2=2021.01.01 2021.02.03 2021.01.23 2021.04.06 2021.12.29\nmbetaTopN(x, y, s2, 3, 2)\n// output\n[ , , , -2.5, -0.6667]\n\nx1 = matrix(x, 4 3 6 2 3)\ny1=matrix(3 7 9 3 2, y)\ns1=matrix(2 3 1 7 3, s)\n\nmbetaTopN(x, y1, s1, 3, 2)\n```\n\n| col1   | col2 |\n| ------ | ---- |\n|        |      |\n|        |      |\n|        |      |\n| 2.5    | -2.5 |\n| 1.1429 | -4   |\n\n```\nmbetaTopN(x1, y1, s, 3, 2)\n```\n\n| col1   | col2 |\n| ------ | ---- |\n|        |      |\n|        | -1   |\n|        | -1   |\n| 2.5    | -1.5 |\n| 1.1429 | -1.5 |\n\n```\nn = 3000\nids = 1..3000\ndates = take(2021.01.01..2021.10.01,n)\nprices = rand(1000,n)\nvals = rand(1000,n)\nt = table(ids as id,dates as date,prices as price,vals as val)\ndbName = \"dfs://test_mbetaTopN_2\"\nif(existsDatabase(dbName))dropDB(dbName)\ndb = database(dbName,VALUE,1..5000)\npt = db.createPartitionedTable(t,\"pt\",`id).append!(t)\nselect mbetaTopN(price, val, id, 10, 5, true) from pt where date>2021.05.01\n```\n\n相关函数：[mbeta](https://docs.dolphindb.cn/zh/funcs/m/mbeta.html)\n"
    },
    "mcorr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mcorr.html",
        "signatures": [
            {
                "full": "mcorr(X, Y, window, [minPeriods])",
                "name": "mcorr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mcorr](https://docs.dolphindb.cn/zh/funcs/m/mcorr.html)\n\n\n\n#### 语法\n\nmcorr(X, Y, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内，计算 *X* 和 *Y* 元素的相关性。\n\n#### 例子\n\n```\nx=1..8\ny=9 5 3 4 5 4 7 1\nmcorr(x,y,5);\n\n[,,,,-0.624038,0,0.834058,-0.29173]\n// output\n\nmcorr(x,y,5,3);\n// output\n[,,-0.981981,-0.834497,-0.624038,0,0.834058,-0.29173]\n\nx1 = indexedSeries(date(2020.06.05)+1..8, x)\ny1 = indexedSeries(date(2020.06.05)+1..6 join 2020.06.15 join 2020.06.16, y)\nmcorr(x1,y1,5d)\n```\n\n| label      | col1    |\n| ---------- | ------- |\n| 2020.06.06 |         |\n| 2020.06.07 | -1      |\n| 2020.06.08 | -0.982  |\n| 2020.06.09 | -0.8345 |\n| 2020.06.10 | -0.624  |\n| 2020.06.11 | 0       |\n| 2020.06.12 | 0.6325  |\n| 2020.06.13 | 0       |\n\n```\nmcorr(x1,y1,1w)\n```\n\n| label      | col1    |\n| ---------- | ------- |\n| 2020.06.06 |         |\n| 2020.06.07 | -1      |\n| 2020.06.08 | -0.982  |\n| 2020.06.09 | -0.8345 |\n| 2020.06.10 | -0.624  |\n| 2020.06.11 | -0.6116 |\n| 2020.06.12 | -0.6116 |\n| 2020.06.13 | 0       |\n\n相关函数：[corr](https://docs.dolphindb.cn/zh/funcs/c/corr.html), [mmin](https://docs.dolphindb.cn/zh/funcs/m/mmin.html), [mmax](https://docs.dolphindb.cn/zh/funcs/m/mmax.html), [mavg](https://docs.dolphindb.cn/zh/funcs/m/mavg.html), [msum](https://docs.dolphindb.cn/zh/funcs/m/msum.html), [mstd](https://docs.dolphindb.cn/zh/funcs/m/mstd.html), [mvar](https://docs.dolphindb.cn/zh/funcs/m/mvar.html)\n"
    },
    "mcorrTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mcorrTopN.html",
        "signatures": [
            {
                "full": "mcorrTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mcorrTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mcorrTopN](https://docs.dolphindb.cn/zh/funcs/m/mcorrTopN.html)\n\n\n\n#### 语法\n\nmcorrTopN(X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，然后计算 *Y* 和 *X* 的相关性。\n\n#### 例子\n\n```\na =  2 5 3 1 9\nb = 2 3 1 7 13\ns = 6 8 4 2 7\n\nmcorrTopN(a, b, s, 4, 3)\n// output\n[ , 1, 0.6547, -0.9333, 0.7206]\n\ns2=2021.01.01 2021.02.03 2021.01.23 2021.04.06 2021.12.29\nmcorrTopN(a, b, s2, 4, 3)\n// output\n[ , 1, 0.6547, 0.6547, -0.6547]\n\na1 = matrix(a, 4 3 6 2 3)\nb1=matrix(3 7 9 3 2, b)\ns1=matrix(2 3 1 7 3, s)\nmcorrTopN(a, b1, s1, 4, 3)\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n| 1       | 1       |\n| 0.5     | 0.6547  |\n| 0.5     | -0.9333 |\n| -0.9986 | 0.7206  |\n\n```\nmcorrTopN(a1, b1, s, 4, 3)\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n| 1       | -1      |\n| 0.5     | -0.982  |\n| 0.866   | -0.9333 |\n| -0.4018 | -0.7206 |\n\n```\nmcorrTopN(a1, b1, s1, 4, 3)\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n| 1       | -1      |\n| 0.5     | -0.982  |\n| 0.5     | -0.9333 |\n| -0.9986 | -0.7206 |\n\n```\nn = 3000\nids = 1..3000\ndates = take(2021.01.01..2021.10.01,n)\nprices = rand(1000,n)\nvals = rand(1000,n)\nt = table(ids as id,dates as date,prices as price,vals as val)\ndbName = \"dfs://test_mcorrTopN_2\"\nif(existsDatabase(dbName))dropDB(dbName)\ndb = database(dbName,VALUE,1..5000)\npt = db.createPartitionedTable(t,\"pt\",`id).append!(t)\nselect mcorrTopN(price, val, id, 10, 5, true) from pt where date>2021.05.01\n```\n\n相关函数：[mcorr](https://docs.dolphindb.cn/zh/funcs/m/mcorr.html)\n"
    },
    "mcount": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mcount.html",
        "signatures": [
            {
                "full": "mcount(X, window, [minPeriods=1])",
                "name": "mcount",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods=1]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [mcount](https://docs.dolphindb.cn/zh/funcs/m/mcount.html)\n\n\n\n#### 语法\n\nmcount(X, window, \\[minPeriods=1])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内统计 *X* 中的非 NULL 元素个数。\n\n#### 例子\n\n```\nx = 7 4 5 8 9;\n\nmcount(x, 3);\n// output: [1,2,3,3,3]\n\nmcount(x, 3, minPeriods=2);\n// output: [,2,3,3,3]\n\nx1 =1 2 3 NULL 5;\n\nmcount(x1, 3);\n// output: [1,2,3,2,2]\n\nmcount(x1, 3, minPeriods=3);\n// output: [,,3,,]\n\nm=matrix(1 2 NULL 4 5, 6 7 8 9 NULL);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 6  |\n| 2  | 7  |\n|    | 8  |\n| 4  | 9  |\n| 5  |    |\n\n```\nmcount(m,3);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 2  | 2  |\n| 2  | 3  |\n| 2  | 3  |\n| 2  | 2  |\n\n```\ns=indexedSeries(date(2020.05.26)+1..8, 3 4 9 NULL 4 6 NULL 8)\nmcount(s,4d)\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2020.05.27 | 1    |\n| 2020.05.28 | 2    |\n| 2020.05.29 | 3    |\n| 2020.05.30 | 3    |\n| 2020.05.31 | 3    |\n| 2020.06.01 | 3    |\n| 2020.06.02 | 2    |\n| 2020.06.03 | 3    |\n\n```\nmcount(s,1w)\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2020.05.27 | 1    |\n| 2020.05.28 | 2    |\n| 2020.05.29 | 3    |\n| 2020.05.30 | 3    |\n| 2020.05.31 | 4    |\n| 2020.06.01 | 5    |\n| 2020.06.02 | 5    |\n| 2020.06.03 | 5    |\n\n相关函数：[count](https://docs.dolphindb.cn/zh/funcs/c/count.html)\n"
    },
    "mcovar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mcovar.html",
        "signatures": [
            {
                "full": "mcovar(X, Y, window, [minPeriods])",
                "name": "mcovar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mcovar](https://docs.dolphindb.cn/zh/funcs/m/mcovar.html)\n\n\n\n#### 语法\n\nmcovar(X, Y, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内，计算 *X* 和 *Y* 元素的协方差。\n\n#### 例子\n\n```\nx=1..10;\ny=9 5 3 4 5 4 7 1 3 4;\nmcovar(x,y,5);\n// output\n[,,,,-2.25,0,2,-1,-1.75,-1]\n\nmcovar(x, y, 5, 3);\n// output\n[,,-3,-2.833333,-2.25,0,2,-1,-1.75,-1]\n\nx1 = indexedSeries(date(2020.06.05)+1..10, x)\ny1 = indexedSeries(date(2020.06.05)+1..10, y)\nmcovar(x1,y1,5d)\n```\n\n| label      | col1    |\n| ---------- | ------- |\n| 2020.06.06 |         |\n| 2020.06.07 | -2      |\n| 2020.06.08 | -3      |\n| 2020.06.09 | -2.8333 |\n| 2020.06.10 | -2.25   |\n| 2020.06.11 | 0       |\n| 2020.06.12 | 2       |\n| 2020.06.13 | -1      |\n| 2020.06.14 | -1.75   |\n| 2020.06.15 | -1      |\n\n```\nmcovar(x1,y1,1w)\n```\n\n| label      | col1    |\n| ---------- | ------- |\n| 2020.06.06 |         |\n| 2020.06.07 | -2      |\n| 2020.06.08 | -3      |\n| 2020.06.09 | -2.8333 |\n| 2020.06.10 | -2.25   |\n| 2020.06.11 | -2.4    |\n| 2020.06.12 | -1      |\n| 2020.06.13 | -0.6667 |\n| 2020.06.14 | -0.6667 |\n| 2020.06.15 | -1.6667 |\n\n相关函数：[covar](https://docs.dolphindb.cn/zh/funcs/c/covar.html)\n"
    },
    "mcovarTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mcovarTopN.html",
        "signatures": [
            {
                "full": "mcovarTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mcovarTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mcovarTopN](https://docs.dolphindb.cn/zh/funcs/m/mcovarTopN.html)\n\n\n\n#### 语法\n\nmcovarTopN(X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，然后计算 *Y* 和 *X* 的协方差。\n\n#### 例子\n\n```\nx = NULL 3 8 4 0\ny = 2 3 1 7 3\ns = 5 NULL 8 9 4\n\nmcovarTopN(x, y, s, 3, 2)\n// output\n[ , , , -12, -8]\n\ns2=2021.01.01 2021.02.03 2021.01.23 2021.04.06 2021.12.29\nmcovarTopN(x, y, s2, 3, 2)\n// output\n[ , , , -5, -12]\n\nx1 = matrix(x, 4 3 6 2 3)\ny1=matrix(3 7 9 3 2, y)\ns1=matrix(2 3 1 7 3, s)\n\nmcovarTopN(x, y1, s1, 3, 2)\n```\n\n| col1 | col2 |\n| ---- | ---- |\n|      |      |\n|      |      |\n|      |      |\n| 5    | -5   |\n| 28   | -8   |\n\n```\nmcovarTopN(x1, y1, s, 3, 2)\n```\n\n| col1 | col2 |\n| ---- | ---- |\n|      |      |\n|      | -0.5 |\n|      | -0.5 |\n| 5    | -3   |\n| 28   | -3   |\n\n```\nmcovarTopN(x1, y1, s1, 3, 2)\n```\n\n| col1 | col2 |\n| ---- | ---- |\n|      |      |\n|      | -0.5 |\n|      | -0.5 |\n| 5    | -3   |\n| 28   | -3   |\n\n```\nn = 3000\nids = 1..3000\ndates = take(2021.01.01..2021.10.01,n)\nprices = rand(1000,n)\nvals = rand(1000,n)\nt = table(ids as id,dates as date,prices as price,vals as val)\ndbName = \"dfs://test_mcovarTopN_2\"\nif(existsDatabase(dbName))dropDB(dbName)\ndb = database(dbName,VALUE,1..5000)\npt = db.createPartitionedTable(t,\"pt\",`id).append!(t)\nselect mcovarTopN(price, val, id, 10, 5, true) from pt where date>2021.05.01\n```\n\n相关函数：[mcovar](https://docs.dolphindb.cn/zh/funcs/m/mcovar.html)\n"
    },
    "md5": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/md5.html",
        "signatures": [
            {
                "full": "md5(X)",
                "name": "md5",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [md5](https://docs.dolphindb.cn/zh/funcs/m/md5.html)\n\n\n\n#### 语法\n\nmd5(X)\n\n#### 参数\n\n**X** 是一个字符串标量或向量。\n\n#### 详情\n\n根据 MD5 算法，对字符串进行哈希，生成 INT128 类型的数据。\n\n#### 例子\n\n```\na=md5(`e`f);\na;\n// output\n[e1671797c52e15f763380b45e841ec32,8fa14cdd754f91cc6554c9e71929cce7]\n\ntypestr(a);\n// output\nINT128\n```\n"
    },
    "mdd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mdd.html",
        "signatures": [
            {
                "full": "maxDrawdown(X, [ratio=true])",
                "name": "maxDrawdown",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ratio=true]",
                        "name": "ratio",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [mdd](https://docs.dolphindb.cn/zh/funcs/m/mdd.html)\n\n是 \\[maxDrawdown]\\(maxdrawdown.md) 的别名。\n\n\n以下是 `maxDrawdown` 函数的文档：\n### [maxDrawdown](https://docs.dolphindb.cn/zh/funcs/m/maxdrawdown.html)\n\n\n\n#### 语法\n\nmaxDrawdown(X, \\[ratio=true])\n\n聚合函数，别名 mdd。\n\n#### 详情\n\n计算传入向量数据的最大回撤（Maximum Drawdown，简称 MDD）或最大回撤率（Maximum Drawdown Rate）。返回一个与 X 数据类型相同的标量，表示 X 的最大回撤或最大回撤率。\n\n#### 参数\n\n**X** 数值向量，表示用于计算最大回撤的输入数据，一般指累积的收益或收益率。注意：不可为空。\n\n**ratio**布尔标量，表示是否返回最大回撤率。默认值为 true。\n\n* 若为 true，表示返回最大回撤率，即相对于峰值的最大下降百分比，计算公式为：\n\n  ![](https://docs.dolphindb.cn/zh/funcs/images/mdd1.png)\n\n* 若为 false，表示返回基于下降金额绝对值的最大回撤，计算公式为：\n\n  ![](https://docs.dolphindb.cn/zh/funcs/images/mdd2.png)\n\n注意：计算时将忽略空值。\n\n#### 例子\n\n假设有一个投资组合在一段时间内的累积收益变化如下（以天为单位）：\n\n<table id=\"table_h24_4zx_bdc\"><thead><tr><th align=\"left\">\n\n日期\n\n</th><th align=\"left\">\n\n累积收益\n\n</th></tr></thead><tbody><tr><td>\n\n2024-10-01\n\n</td><td>\n\n36\n\n</td></tr><tr><td>\n\n2024-10-02\n\n</td><td>\n\n96\n\n</td></tr><tr><td>\n\n2024-10-03\n\n</td><td>\n\n42\n\n</td></tr><tr><td>\n\n2024-10-04\n\n</td><td>\n\n100\n\n</td></tr><tr><td>\n\n2024-10-05\n\n</td><td>\n\n59\n\n</td></tr><tr><td>\n\n2024-10-06\n\n</td><td>\n\n86\n\n</td></tr><tr><td>\n\n2024-10-07\n\n</td><td>\n\n25\n\n</td></tr><tr><td>\n\n2024-10-08\n\n</td><td>\n\n72\n\n</td></tr></tbody>\n</table>使用 `maxDrawdown` 计算该数据的最大回撤率和最大回撤。\n\n```\nx = [36,96,42,100,59,86,25,64,72]\n\nmaxDrawdown(x)\n// Output: 0.75\nmaxDrawdown(x, false)\n// Output: 75\n```\n\n相关函数：[cummdd](https://docs.dolphindb.cn/zh/funcs/c/cummdd.html)\n"
    },
    "mean": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mean.html",
        "signatures": [
            {
                "full": "mean(X)",
                "name": "mean",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [mean](https://docs.dolphindb.cn/zh/funcs/m/mean.html)\n\n\n\n#### 语法\n\nmean(X)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量、矩阵或表。\n\n#### 详情\n\n若 *X* 为向量，计算 *X* 的平均值。\n\n若 *X* 为矩阵，计算每列的平均值，返回一个向量。\n\n若 *X* 为表，计算每列的平均值，返回一个表。\n\n该函数与 [avg](https://docs.dolphindb.cn/zh/funcs/a/avg.html) 函数完全相同。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nx=1 5 9;\nmean(x);\n// output\n5\n\nx=1 5 9 NULL;\nmean(x);\n// output\n5\n\navg(x);\n// output\n5\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nmean(m);\n// output\n[2,5]\n```\n\n相关的中心趋势函数：[mode](https://docs.dolphindb.cn/zh/funcs/m/mode.html), [med](https://docs.dolphindb.cn/zh/funcs/m/med.html)\n"
    },
    "med": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/med.html",
        "signatures": [
            {
                "full": "med(X)",
                "name": "med",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [med](https://docs.dolphindb.cn/zh/funcs/m/med.html)\n\n\n\n#### 语法\n\nmed(X)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n#### 详情\n\n如果 *X* 是向量，返回 *X* 中所有元素的中值。\n\n若 *X* 为矩阵，计算每列的中值，返回一个向量。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n无论 *X* 为何种数据类型，结果的数据类型为 DOUBLE。\n\n#### 例子\n\n```\nx=3 6 1 5 9;\nmed x;\n// output\n5\n\nm=matrix(1 2 10, 4 5 NULL);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 10 |    |\n\n```\nmed m;\n// output\n[2,4.5]\n```\n\n相关的中心趋势函数：[mean](https://docs.dolphindb.cn/zh/funcs/m/mean.html) 和 [mode](https://docs.dolphindb.cn/zh/funcs/m/mode.html)\n"
    },
    "mem": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mem.html",
        "signatures": [
            {
                "full": "mem([freeUnusedBlocks=false])",
                "name": "mem",
                "parameters": [
                    {
                        "full": "[freeUnusedBlocks=false]",
                        "name": "freeUnusedBlocks",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [mem](https://docs.dolphindb.cn/zh/funcs/m/mem.html)\n\n\n\n#### 语法\n\nmem(\\[freeUnusedBlocks=false])\n\n#### 参数\n\n**freeUnusedBlocks** 是一个布尔值，表示是否释放未使用的内存块。默认值为 false。\n\n#### 详情\n\n显示本地节点内存使用情况。\n\n结果中，allocatedBytes 为已分配内存；freeBytes 是可用内存。两者之差为已占用内存。\n\n如果 *freeUnusedBlocks* =true，系统将会释放未使用的内存块。\n\n#### 例子\n\n```\nundef all;\n\nt1=table(1 2 3 as a, `x`y`z as b, 10.8 7.6 3.5 as c)\nmem();\n\n// output\nfreeBytes->492904\nallocatedBytes->8454144\n\n\nx=bigarray(INT,100000,10000000)\nmem();\n\n// output\nfreeBytes->491056\nallocatedBytes->12648448\n\n\nundef all;\nmem();\n\n// output\nfreeBytes->4687936\nallocatedBytes->12648448\n```\n"
    },
    "member": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/member.html",
        "signatures": [
            {
                "full": "member(X, Y)",
                "name": "member",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [member](https://docs.dolphindb.cn/zh/funcs/m/member.html)\n\n\n\n#### 语法\n\nmember(X, Y) 或 X.Y\n\n#### 参数\n\n**X** 可以是表或字典。\n\n**Y** 是 *X* 的一个成员或属性。若使用 member(X, Y) 方式，*Y* 必须是字符串。\n\n#### 详情\n\n返回对象的指定成员/属性。\n\n#### 例子\n\n```\nx=1 2 3\ny=4 5 6\nt=table(x,y);\n\nt.x;\n// output\n[1,2,3]\nt.y;\n// output\n[4,5,6]\n\nt.rows();\n// output\n3\nt.cols();\n// output\n2\nt.size();\n// output\n3\n// 表的 size 定义为它的行数\n\nd = dict(1 2 3, 4 5 6);\nd;\n// output\n3->6\n1->4\n2->5\n\nd.2;\n// output\n5\n```\n"
    },
    "memberModify!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/membermodify.html",
        "signatures": [
            {
                "full": "memberModify!(obj, function, indices, parameters)",
                "name": "memberModify!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "function",
                        "name": "function"
                    },
                    {
                        "full": "indices",
                        "name": "indices"
                    },
                    {
                        "full": "parameters",
                        "name": "parameters"
                    }
                ]
            }
        ],
        "markdown": "### [memberModify!](https://docs.dolphindb.cn/zh/funcs/m/membermodify.html)\n\n\n\n#### 语法\n\nmemberModify!(obj, function, indices, parameters)\n\n#### 详情\n\n修改元组或 ANY 字典的成员对象，也可修改面向对象的编程（OOP）中的对象。\n\n#### 参数\n\n**obj** 一个元组或值为 ANY 类型的字典。\n\n**function**一个内置的系统函数，该函数的第一个参数是可修改的，列如 append!。\n\n**indices** 标量、向量或元组，表示指向一个或多个成员对象的索引或键值。\n\n* 若是一个元组，用于表示多维度索引。元组的长度表示索引的深度。\n\n* 若是一个向量，表示对多个成员进行修改。\n\n**parameters** *function* 除第一个参数外的其它参数。*parameters* 的维度必须与 *indices*, *func* 的参数个数匹配。\n\n#### 例子\n\n##### 例 1\n\n创建元组 a，修改其中的一个元素，可见前后对比。\n\n```\na = (1 2, 3 4 5)\nmemberModify!(a, append!, 0, 3 4)\na\n//output: a = (1 2 3 4, 3 4 5)\n```\n\n创建字典 d，修改其中的两个元素，可见前后对比。\n\n```\nd = dict(`A`B`C, (1 2, 3 4, 5 6))\nd\n/*output:\nA->[1,2]\nB->[3,4]\nC->[5,6]\n*/\n\nd.memberModify!(append!,`A`B, 3 4) \nd\n/*output:\nA->[1,2,3]\nB->[3,4,4]\nC->[5,6]\n */\n```\n\n创建元组 c，其包含基于表 t，字典 d 和一个向量。\n\n```\nt = table(1 2 3 as val1, 4 5 6 as val2)\nd = dict(`A`B`C, (1 2, 3 4, 5 6))\nc = (t, d, [1 2 3, 4 5 6])\nc\n/*output: \n(val1 val2\n---- ----\n1    4   \n2    5   \n3    6   \n,C->[5,6]\nA->[1,2]\nB->[3,4]\n,([1,2,3],[4,5,6]))\n*/\n```\n\n调用 `memberModify!` 对元组第 3 个元素 `[1 2 3, 4 5 6]` 的第 1 个元素 \\[1, 2, 3] 添加元素 4 和 5。要修改的对象需要用两个维度来指定，因此 indices 使用元组 (2, 0) 来表示。\n\n```\nc.memberModify!(append!, (2, 0), 4 5)\n/*output: \n(val1 val2\n---- ----\n1    4   \n2    5   \n3    6   \n,C->[5,6]\nA->[1,2]\nB->[3,4]\n,([1,2,3,4,5],[4,5,6]))\n*/\n```\n\n在该基础上，继续向元组的第 2 个元素（字典）的键值 B 指定的对象写入新数据 5 和 7。indices 仍然使用元组 （1，\\`B) 来表示。\n\n```\nc.memberModify!(append!, (1,`B), 5 7)\nc\n/*output: \n(val1 val2\n---- ----\n1    4   \n2    5   \n3    6   \n,C->[5,6]\nA->[1,2]\nB->[3,4,5,7]\n,([1,2,3,4,5],[4,5,6]))\n*/\n```\n\n##### 例 2\n\n约定名为 A 的类并进行实例化，使用 `memberModify!` 进行写入操作，打印向量 a 的数据，可得预期结果。\n\n```\nclass A {\n\ta :: INT VECTOR\n\tdef A() {\n\t\ta = []\n\t}\n}\n\nv = A()\nmemberModify!(v, append!, \"a\", 1)\nprint v.a \n//output: [1]\n\nmemberModify!(v, append!, \"a\", 11)\nprint v.a \n//output: [1,11]\n```\n"
    },
    "memSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/memSize.html",
        "signatures": [
            {
                "full": "memSize(obj)",
                "name": "memSize",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    }
                ]
            }
        ],
        "markdown": "### [memSize](https://docs.dolphindb.cn/zh/funcs/m/memSize.html)\n\n\n\n#### 语法\n\nmemSize(obj)\n\n#### 参数\n\n**obj** 一个对象。\n\n#### 详情\n\n返回本地对象或共享对象占用内存大小，单位为字节。\n\n#### 例子\n\n```\nn=100\nID=rand(100, n)\ndate=rand(2017.08.07..2017.08.11, n)\nx=rand(10.0, n)\nt=table(ID, date, x);\nshare t as tt\nmemSize(t)\n// output\n1952\nmemSize(tt)\n// output\n1952\nmemSize(t[`x])\n// output\n800\nmemSize(select avg(x) as avgx from t)\n// output\n280\n```\n\n相关函数：[objs](https://docs.dolphindb.cn/zh/funcs/o/objs.html)\n"
    },
    "merge": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/merge.html",
        "signatures": [
            {
                "full": "merge(left, right, [how='inner'])",
                "name": "merge",
                "parameters": [
                    {
                        "full": "left",
                        "name": "left"
                    },
                    {
                        "full": "right",
                        "name": "right"
                    },
                    {
                        "full": "[how='inner']",
                        "name": "how",
                        "optional": true,
                        "default": "'inner'"
                    }
                ]
            }
        ],
        "markdown": "### [merge](https://docs.dolphindb.cn/zh/funcs/m/merge.html)\n\n\n\n#### 语法\n\nmerge(left, right, \\[how='inner'])\n\n#### 参数\n\n**left** 与 **right** 均为索引序列，或均为索引矩阵。\n\n**how** 是字符串，表示如何对数据进行联结。可取值为 'inner', 'outer', 'left', 'right' 与 'asof'。默认值为 ‘inner’。\n\n#### 详情\n\n联结两个索引序列或两个索引矩阵。\n\n#### 例子\n\n```\na = indexedSeries(2012.01.01..2012.01.04, 1..4)\nb = indexedSeries([2012.01.01, 2012.01.03, 2012.01.05, 2012.01.06], 5..8)\nmerge(a, b);\n```\n\n|            | series1 | series2 |\n| ---------- | ------- | ------- |\n| 2012.01.01 | 1       | 5       |\n| 2012.01.03 | 3       | 6       |\n\n```\nmerge(a, b, 'left');\n```\n\n|            | series1 | series2 |\n| ---------- | ------- | ------- |\n| 2012.01.01 | 1       | 5       |\n| 2012.01.02 | 2       |         |\n| 2012.01.03 | 3       | 6       |\n| 2012.01.04 | 4       |         |\n\n```\nm1 = matrix([1.2, 7.8, 4.6, 5.1, 9.5], [0.15, 1.26, 0.45, 1.02, 0.33]).rename!([2012.01.01, 2015.02.01, 2015.03.01, 2015.04.01, 2015.05.01], `x1`x2).setIndexedMatrix!()\nm2 = matrix([1.0, 2.0, 3.0, 4.0], [0.14, 0.26, 0.35, 0.48]).rename!([2015.02.01, 2015.02.16, 2015.05.01, 2015.05.02], `y1`y2).setIndexedMatrix!()\nm = merge(m1, m2, 'asof');\n```\n\n|            | x1  | x2   | y1 | y2   |\n| ---------- | --- | ---- | -- | ---- |\n| 2012.01.01 | 1.2 | 0.15 |    |      |\n| 2015.02.01 | 7.8 | 1.26 | 1  | 0.14 |\n| 2015.03.01 | 4.6 | 0.45 | 2  | 0.26 |\n| 2015.04.01 | 5.1 | 1.02 | 2  | 0.26 |\n| 2015.05.01 | 9.5 | 0.33 | 3  | 0.35 |\n"
    },
    "mfirst": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mfirst.html",
        "signatures": [
            {
                "full": "mfirst(X, window, [minPeriods])",
                "name": "mfirst",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mfirst](https://docs.dolphindb.cn/zh/funcs/m/mfirst.html)\n\n\n\n#### 语法\n\nmfirst(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 的第一个元素。\n\n#### 例子\n\n```\nindex = second(08:20:00)+1..7\nx = 2 1 3 NULL 6 5 4\nx = index.indexedSeries(x)\nmfirst(x,3s)\n```\n\n| label    | col1 |\n| -------- | ---- |\n| 08:20:01 | 2    |\n| 08:20:02 | 2    |\n| 08:20:03 | 2    |\n| 08:20:04 | 1    |\n| 08:20:05 | 3    |\n| 08:20:06 |      |\n| 08:20:07 | 6    |\n\n```\nm = matrix(1 5 9 0 2, 9 10 2 NULL 2)\nm.rename!((date(2020.09.08)+1..3) join 2020.09.16 join 2020.09.26, `A`B)\nm.setIndexedMatrix!()\nmfirst(m, 3d)\n```\n\n| label      | A | B |\n| ---------- | - | - |\n| 2020.09.09 | 1 | 9 |\n| 2020.09.10 | 1 | 9 |\n| 2020.09.11 | 1 | 9 |\n| 2020.09.16 | 0 |   |\n| 2020.09.26 | 2 | 2 |\n\n```\nmfirst(m, 1w)\n```\n\n| label      | A | B  |\n| ---------- | - | -- |\n| 2020.09.09 | 1 | 9  |\n| 2020.09.10 | 1 | 9  |\n| 2020.09.11 | 1 | 9  |\n| 2020.09.16 | 5 | 10 |\n| 2020.09.26 | 2 | 2  |\n\n相关函数：[first](https://docs.dolphindb.cn/zh/funcs/f/first.html), [last](https://docs.dolphindb.cn/zh/funcs/l/last.html)\n"
    },
    "mfirstNot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mfirstnot.html",
        "signatures": [
            {
                "full": "mfirstNot(X, window, [k=NULL], [minPeriods=1])",
                "name": "mfirstNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[k=NULL]",
                        "name": "k",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[minPeriods=1]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [mfirstNot](https://docs.dolphindb.cn/zh/funcs/m/mfirstnot.html)\n\n\n\n#### 语法\n\nmfirstNot(X, window, \\[k=NULL], \\[minPeriods=1])\n\n部分通用参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 参数\n\n**k** 可选参数，是一个数值或字符串类型的标量，表示用于匹配的数据。\n\n#### 详情\n\n若 *X* 是向量：\n\n* 如果没有指定 *k*，计算给定长度（以元素个数或时间长度衡量）的滑动窗口内 *X* 中第一个不为 NULL 的元素。\n\n* 如果指定 *k*，计算给定长度（以元素个数或时间长度衡量）的滑动窗口内 *X* 中第一个不为 *k* 或 NULL 的元素。\n\n若 *X* 是矩阵或表，则在每列内进行上述计算。\n\n#### 例子\n\n例 1\n\n```\nX = NULL 2 NULL 4 5\nmfirstNot(X=X, window=2)\n// output: [,2,2,4,4]\n```\n\n例 2\n\n```\nx = matrix(1..5,2..6,3..7)\nmfirstNot(X=x, window=3, k=1, minPeriods=2)\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n|    |    |    |\n| 2  | 2  | 3  |\n| 2  | 2  | 3  |\n| 2  | 3  | 4  |\n| 3  | 4  | 5  |\n\n例 3\n\n```\nx=table([\"s1\", \"s2\", \"\", \"s4\", \"s5\"] as col1, [\"s1\", \"\", \"s3\", \"\", \"s5\"] as col2)\nmfirstNot(X=x, window=2)\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n| s1 | s1 |\n| s2 | s3 |\n| s4 | s3 |\n| s4 | s5 |\n\n例 4\n\n```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07, 2022.01.08, 2022.01.10, 2022.01.11]\nX = 1..8\nX1 = indexedSeries(T, X)\nmfirstNot(X=X1, window=3, k=1, minPeriods=1)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2022.01.01 |    |\n| 2022.01.02 | 2  |\n| 2022.01.03 | 2  |\n| 2022.01.06 | 4  |\n| 2022.01.07 | 4  |\n| 2022.01.08 | 4  |\n| 2022.01.10 | 6  |\n| 2022.01.11 | 7  |\n\n**Related information**\n\n[mlastNot](https://docs.dolphindb.cn/zh/funcs/m/mlastnot.html)\n"
    },
    "microsecond": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/microsecond.html",
        "signatures": [
            {
                "full": "microsecond(X)",
                "name": "microsecond",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [microsecond](https://docs.dolphindb.cn/zh/funcs/m/microsecond.html)\n\n\n\n#### 语法\n\nmicrosecond(X)\n\n#### 参数\n\n**X** 可以是 TIME, TIMESTAMP, NANOTIME 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n返回 *X* 中的微秒数。\n\n#### 例子\n\n```\nmicrosecond(13:30:10.008);\n// output\n8000\n\nmicrosecond([2012.12.03 01:22:01.999999000, 2012.12.03 01:22:01.000456000, 2012.12.03 01:25:08.000000234]);\n// output\n[999999,456,0]\n```\n\n相关函数：[dayOfYear](https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.cn/zh/funcs/m/millisecond.html), [nanosecond](https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html)\n"
    },
    "mifirstNot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mifirstNot.html",
        "signatures": [
            {
                "full": "mifirstNot(X, window, [minPeriods])",
                "name": "mifirstNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mifirstNot](https://docs.dolphindb.cn/zh/funcs/m/mifirstNot.html)\n\n#### 语法\n\nmifirstNot(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 的第一个非空元素的下标。\n\n#### 例子\n\n```\nv = NULL NULL 2 3 4 8 NULL 5 -2 3 -1 0 NULL\nmifirstNot(v, 3)\n// output: [,,2,1,0,0,0,0,1,0,0,0,0]\n\nm = matrix(NULL 1 2 3, 1 NULL 2 3, NULL NULL 3 4, 1 2 3 4)\nn = mifirstNot(m, 2)\nn\n```\n\n| #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- |\n|    |    |    |    |\n| 1  | 0  | -1 | 0  |\n| 0  | 1  | 1  | 0  |\n| 0  | 0  | 0  | 0  |\n\n```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07]\nX = NULL 2 NULL 4 5\nX1 = indexedSeries(T, X)\nmifirstNot(X1, 2, 1)\n```\n\n|            | #1 |\n| ---------- | -- |\n| 2022.01.01 | -1 |\n| 2022.01.02 | 1  |\n| 2022.01.03 | 0  |\n| 2022.01.06 | 0  |\n| 2022.01.07 | 0  |\n\n\n\n**Related information**\n\n[milastNot](https://docs.dolphindb.cn/zh/funcs/m/milastNot.html)\n\n[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n"
    },
    "migrate": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/migrate.html",
        "signatures": [
            {
                "full": "migrate(backupDir, [backupDBPath], [backupTableName], [newDBPath=backupDBPath], [newTableName=backupTableName])",
                "name": "migrate",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "[backupDBPath]",
                        "name": "backupDBPath",
                        "optional": true
                    },
                    {
                        "full": "[backupTableName]",
                        "name": "backupTableName",
                        "optional": true
                    },
                    {
                        "full": "[newDBPath=backupDBPath]",
                        "name": "newDBPath",
                        "optional": true,
                        "default": "backupDBPath"
                    },
                    {
                        "full": "[newTableName=backupTableName]",
                        "name": "newTableName",
                        "optional": true,
                        "default": "backupTableName"
                    }
                ]
            }
        ],
        "markdown": "### [migrate](https://docs.dolphindb.cn/zh/funcs/m/migrate.html)\n\n\n\n#### 语法\n\nmigrate(backupDir, \\[backupDBPath], \\[backupTableName], \\[newDBPath=backupDBPath], \\[newTableName=backupTableName])\n\n#### 参数\n\n**backupDir** 字符串，表示存放已备份数据的目录。\n\n**backupDBPath** 字符串，表示已备份的数据库的名称。\n\n**backupTableName** 字符串，表示已备份的表的名称。\n\n**newDBPath** 字符串，表示新数据库的名称。如果没有指定，默认值为 *backupDBPath*。 若指定该参数，则需要确保备份数据与 *newDBPath* 的引擎类型（engine）一致，且 partitionScheme（VALUE 除外）也保持一致。 当采用 VALUE 分区时，须保证备份数据中的分区方案是待恢复数据库的分区方案的子集。\n\n**newTableName** 字符串，表示新表的名称。如果没有指定，默认值为 *backupTableName*。\n\n#### 详情\n\n恢复数据库中已备份的数据。返回的结果是一个表，包含了每个表恢复数据的结果。该函数必须要用户登录后才能执行。\n\n**migrate 函数有以下三种用法**：\n\n* migrate(backupDir): 恢复该目录下所有数据库的备份数据。恢复后的数据库名称、表名称与原数据库、原表一致。\n\n* migrate(backupDir, backupDBPath): 恢复该目录下指定数据库的备份数据。恢复后的数据库名称、表名称与原数据库、原表一致。\n\n* migrate(backupDir, backupDBPath, backupTableName, \\[newDBPath], \\[newTableName]): 恢复该目录下指定数据库指定表的备份数据。如果没有指定 *newDBPath* 和 *newTableName*，恢复后的数据库名称、表名称与原数据库、原表一致。如果指定了 *newDBPath* 和 *newTableName*，恢复后的数据库名称为 *newDBPath*，表名为 *newTableName*。\n\n#### 例子\n\n创建两个示例数据库，并将它们备份到相同的目录中：\n\n```\nbackupDir=\"/home/DolphinDB/backup\"\n\nn = 1000000\nt1 = table(rand(2012.12.01..2012.12.10, n) as date, rand(`AAPL`IBM`GOOG`MSFT, n) as sym, rand(1000.0,n) as price)\nt2 = table(rand(2012.12.01..2012.12.10, n) as date, rand(`AAPL`IBM`GOOG`MSFT, n) as sym, rand(1000,n) as qty)\ndb1 = database(\"dfs://db1\", VALUE, 2012.12.01..2012.12.10)\ntrades1 = db1.createPartitionedTable(t1, `trades1, `date).append!(t1)\ntrades2 = db1.createPartitionedTable(t2, `trades2, `date).append!(t2)\n\nn = 1000000\nt1 = table(rand(2012.12.01..2012.12.10, n) as date, rand(`AAPL`IBM`GOOG`MSFT, n) as sym, rand(1000.0,n) as price)\nt2 = table(rand(2012.12.01..2012.12.10, n) as date, rand(`AAPL`IBM`GOOG`MSFT, n) as sym, rand(1000,n) as qty)\ndb1 = database(\"dfs://db2\", VALUE, `AAPL`IBM`GOOG`MSFT)\nquotes1 = db1.createPartitionedTable(t1, `quotes1, `sym).append!(t1)\nquotes2 = db1.createPartitionedTable(t2, `quotes2, `sym).append!(t2)\n\nbackup(backupDir, <select * from trades1>, true)\nbackup(backupDir, <select * from trades2>, true)\nbackup(backupDir, <select * from quotes1>, true)\nbackup(backupDir, <select * from quotes2>, true)\n```\n\n删除原来的数据库：\n\n```\ndropDatabase(\"dfs://db1\")\ndropDatabase(\"dfs://db2\")\n```\n\n例1. 恢复所有数据库的数据\n\n```\nmigrate(backupDir);\n```\n\n| dbName     | tableName | success | errorMsg |\n| ---------- | --------- | ------- | -------- |\n| dfs\\://db1 | trades1   | 1       |          |\n| dfs\\://db1 | trades2   | 1       |          |\n| dfs\\://db2 | quotes2   | 1       |          |\n| dfs\\://db2 | quotes1   | 1       |          |\n\n例2. 恢复数据库 `dfs://db1`中所有表的数据\n\n```\nmigrate(backupDir, \"dfs://db1\");\n```\n\n| dbName     | tableName | success | errorMsg |\n| ---------- | --------- | ------- | -------- |\n| dfs\\://db1 | trades1   | 1       |          |\n| dfs\\://db1 | trades2   | 1       |          |\n\n例3. 恢复数据库 `dfs://db1` 中表 trades1 的数据\n\n例3.1 不指定新数据库名称和表名称\n\n```\nmigrate(backupDir, \"dfs://db1\", \"trades1\");\n```\n\n| dbName     | tableName | success | errorMsg |\n| ---------- | --------- | ------- | -------- |\n| dfs\\://db1 | trades1   | 1       |          |\n\n例3.2 指定新数据库名称和表名称\n\n```\nmigrate(backupDir, \"dfs://db1\", \"trades1\", \"dfs://db3\", \"trades\");\n```\n\n| dbName     | tableName | success | errorMsg |\n| ---------- | --------- | ------- | -------- |\n| dfs\\://db1 | trades1   | 1       |          |\n\n```\nexec count(*) from loadTable(\"dfs://db3\", \"trades\")\n// output\n1000000\n```\n\n相关函数：[backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html), [backupDB](https://docs.dolphindb.cn/zh/funcs/b/backupDB.html), [backupTable](https://docs.dolphindb.cn/zh/funcs/b/backupTable.html), [restore](https://docs.dolphindb.cn/zh/funcs/r/restore.html), [restoreDB](https://docs.dolphindb.cn/zh/funcs/r/restoreDB.html), [restoreTable](https://docs.dolphindb.cn/zh/funcs/r/restoreTable.html)\n"
    },
    "milastNot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/milastNot.html",
        "signatures": [
            {
                "full": "milastNot(X, window, [minPeriods])",
                "name": "milastNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [milastNot](https://docs.dolphindb.cn/zh/funcs/m/milastNot.html)\n\n#### 语法\n\nmilastNot(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 的最后一个非空元素的下标。\n\n#### 例子\n\n```\nv = NULL NULL 2 3 4 8 NULL 5 -2 3 -1 0 NULL\nmilastNot(v, 3)\n// output: [,,2,2,2,2,1,2,2,2,2,2,1]\n\nm = matrix(1 2 3 NULL, 1 2 NULL 3, 1 3 NULL NULL, 1 2 3 4)\nmilastNot(m, 2)\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n|    |    |    |    |\n| 1  | 1  | 1  | 1  |\n| 1  | 0  | 0  | 1  |\n| 0  | 1  | -1 | 1  |\n\n```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07]\nX = NULL 2 NULL 4 5\nX1 = indexedSeries(T, X)\nmilastNot(X1, 2, 1)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2022.01.01 | -1 |\n| 2022.01.02 | 1  |\n| 2022.01.03 | 0  |\n| 2022.01.06 | 0  |\n| 2022.01.07 | 1  |\n\n\n\n**Related information**\n\n[mifirstNot](https://docs.dolphindb.cn/zh/funcs/m/mifirstNot.html)\n\n[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n"
    },
    "millisecond": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/millisecond.html",
        "signatures": [
            {
                "full": "millisecond(X)",
                "name": "millisecond",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [millisecond](https://docs.dolphindb.cn/zh/funcs/m/millisecond.html)\n\n\n\n#### 语法\n\nmillisecond(X)\n\n#### 参数\n\n**X** 可以是 TIME, TIMESTAMP, NANOTIME 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n返回 *X* 中的毫秒数。\n\n#### 例子\n\n```\nmillisecond(13:30:10.008);\n// output\n8\n\nmillisecond([2012.12.03 01:22:01.456120300, 2012.12.03 01:25:08.000234000]);\n// output\n[456,0]\n```\n\n相关函数：[dayOfYear](https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html), [microsecond](https://docs.dolphindb.cn/zh/funcs/m/microsecond.html), [nanosecond](https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html)\n"
    },
    "mimax": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mimax.html",
        "signatures": [
            {
                "full": "mimax(X, window, [minPeriods])",
                "name": "mimax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mimax](https://docs.dolphindb.cn/zh/funcs/m/mimax.html)\n\n\n\n#### 语法\n\nmimax(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 中最大元素的位置。如果窗口内存在多个相同的最大值，则返回左起第一个最大值的位置。与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nx = 1.2 2 NULL 6 -1 6\nmimax(x, 3);\n//output: [,,1,2,1,0]\n\nmimax(x, 3, 1);\n//output: [0,1,1,2,1,0]\n\nm=matrix(1 6 2 9 10 3, 9 10 2 6 6 6);\nm;\n```\n\n返回：\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 9  |\n| 6  | 10 |\n| 2  | 2  |\n| 9  | 6  |\n| 10 | 6  |\n| 3  | 6  |\n\n```\nmimax(m,3);\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 1  | 1  |\n| 2  | 0  |\n| 2  | 1  |\n| 1  | 0  |\n\n```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07, 2022.01.08, 2022.01.10, 2022.01.11]\nX = 1..8\nX1 = indexedSeries(T, X)\nmimax(X1,3)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2022.01.01 | 0  |\n| 2022.01.02 | 1  |\n| 2022.01.03 | 2  |\n| 2022.01.06 | 0  |\n| 2022.01.07 | 1  |\n| 2022.01.08 | 2  |\n| 2022.01.10 | 1  |\n| 2022.01.11 | 1  |\n\n```\nt= 2021.01.02 2021.01.05  2021.01.06  2021.01.09 2021.01.10 2021.01.12\nm=matrix(5 4 NULL -1 2 4, 3 2 8 1 0 5)\nm1=m.rename!(t, `a`b).setIndexedMatrix!()\nmimax(m1,3)\n```\n\n返回结果：\n\n|            | a | b |\n| ---------- | - | - |\n| 2021.01.02 | 0 | 0 |\n| 2021.01.05 | 0 | 0 |\n| 2021.01.06 | 0 | 1 |\n| 2021.01.09 | 0 | 0 |\n| 2021.01.10 | 1 | 0 |\n| 2021.01.12 | 1 | 1 |\n\n**Related information**\n\n[imax](https://docs.dolphindb.cn/zh/funcs/i/imax.html)\n\n[mimin](https://docs.dolphindb.cn/zh/funcs/m/mimin.html)\n\n[mimaxLast](https://docs.dolphindb.cn/zh/funcs/m/mimaxlast.html)\n"
    },
    "mimaxLast": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mimaxlast.html",
        "signatures": [
            {
                "full": "mimaxLast(X, window, [minPeriods])",
                "name": "mimaxLast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mimaxLast](https://docs.dolphindb.cn/zh/funcs/m/mimaxlast.html)\n\n\n\n#### 语法\n\nmimaxLast(X, window, \\[minPeriods])\n\n#### 参数\n\n参数说明和窗口计算规则请参考: [滑动窗口系列（m 系列）](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 中最大元素的位置。如果窗口内存在多个相同的最大值，则返回右起第一个最大值的位置。与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nx = 1.2 2 NULL -1 6 -1\nmimaxLast(x,3);\n// output: \n[,,1,0,2,1]\n\nm=matrix(3 2 4 4 2, 1 4 2 4 3);\nmimaxLast(m,3) \n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 2  | 1  |\n| 2  | 2  |\n| 1  | 1  |\n\n```\nt=table(3 3 2 as c1, 1 4 4 as c2)\nmimaxLast(t,3)\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 1  | 2  |\n\n```\nx = [NULL, 2, NULL, NULL, 3.2]\ndate = [0, 1, 3,  8, 9] + 2020.01.01\nX = indexedSeries(date, x) \nmimaxLast(X, 3d)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2020.01.01 | -1 |\n| 2020.01.02 | 1  |\n| 2020.01.04 | 0  |\n| 2020.01.09 | -1 |\n| 2020.01.10 | 1  |\n\n相关函数：[mimax](https://docs.dolphindb.cn/zh/funcs/m/mimax.html)\n"
    },
    "mimin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mimin.html",
        "signatures": [
            {
                "full": "mimin(X, window, [minPeriods])",
                "name": "mimin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mimin](https://docs.dolphindb.cn/zh/funcs/m/mimin.html)\n\n\n\n#### 语法\n\nmimin(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 中最小元素的位置。如果窗口内存在多个相同的最小值，则返回左起第一个最小值的位置。与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nx = 1.2 2 NULL 6 -1 -1\nmimin(x, 3);\n//output: [,,0,0,2,1]\n\nmimin(x, 3, 1);\n//output: [0,0,0,0,2,1]\n\nm=matrix(1 6 2 9 10 3, 9 10 2 6 6 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 9  |\n| 6  | 10 |\n| 2  | 2  |\n| 9  | 6  |\n| 10 | 6  |\n| 3  | 6  |\n\n```\nmimin(m,3);\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 0  | 2  |\n| 1  | 1  |\n| 0  | 0  |\n| 2  | 0  |\n\n```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07, 2022.01.08, 2022.01.10, 2022.01.11]\nX = 1..8\nX1 = indexedSeries(T, X)\nmimin(X1,3)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2022.01.01 | 0  |\n| 2022.01.02 | 0  |\n| 2022.01.03 | 0  |\n| 2022.01.06 | 0  |\n| 2022.01.07 | 0  |\n| 2022.01.08 | 0  |\n| 2022.01.10 | 0  |\n| 2022.01.11 | 0  |\n\n```\nt= 2021.01.02 2021.01.05  2021.01.06  2021.01.09 2021.01.10 2021.01.12\nm=matrix(5 4 NULL -1 2 4, 3 2 8 1 0 5)\nm1=m.rename!(t, `a`b).setIndexedMatrix!()\nmimin(m1,3)\n```\n\n|            | a | b |\n| ---------- | - | - |\n| 2021.01.02 | 0 | 0 |\n| 2021.01.05 | 0 | 0 |\n| 2021.01.06 | 0 | 0 |\n| 2021.01.09 | 0 | 0 |\n| 2021.01.10 | 0 | 1 |\n| 2021.01.12 | 0 | 0 |\n\n**Related information**\n\n[imin](https://docs.dolphindb.cn/zh/funcs/i/imin.html)\n\n[mimax](https://docs.dolphindb.cn/zh/funcs/m/mimax.html)\n\n[miminLast](https://docs.dolphindb.cn/zh/funcs/m/miminlast.html)\n"
    },
    "miminLast": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/miminlast.html",
        "signatures": [
            {
                "full": "miminLast(X, window, [minPeriods])",
                "name": "miminLast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [miminLast](https://docs.dolphindb.cn/zh/funcs/m/miminlast.html)\n\n\n\n#### 语法\n\nmiminLast(X, window, \\[minPeriods])\n\n#### 参数\n\n参数说明和窗口计算规则请参考: [滑动窗口系列（m 系列）](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量或时间长度）的滑动窗口内计算 *X* 中最小元素的位置。如果窗口内存在多个相同的最小值，则返回右起第一个最小值的位置。与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nx = 1.2 2 NULL -1 6 -1\nmiminLast(x,3)\n// output: [,,0,2,1,2]\n\nm=matrix(3 2 2 4 2, 1 4 2 1 3);\nmiminLast(m,3) \n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 2  | 0  |\n| 1  | 2  |\n| 2  | 1  |\n\n```\nt=table(3 2 2 as c1, 1 1 4 as c2)\nmiminLast(t,3)\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 2  | 1  |\n\n```\nx = [NULL, 2, NULL, NULL, 3.2]\ndate = [0, 1, 3,  8, 9] + 2020.01.01\nX = indexedSeries(date, x) \nmiminLast(X, 3d)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2020.01.01 | -1 |\n| 2020.01.02 | 1  |\n| 2020.01.04 | 0  |\n| 2020.01.09 | -1 |\n| 2020.01.10 | 1  |\n\n相关函数：[mimin](https://docs.dolphindb.cn/zh/funcs/m/mimin.html)\n"
    },
    "min": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/min.html",
        "signatures": [
            {
                "full": "min(X, [Y])",
                "name": "min",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [min](https://docs.dolphindb.cn/zh/funcs/m/min.html)\n\n\n\n#### 语法\n\nmin(X, \\[Y])\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n**Y** 为可选参数，可以是标量或者是和 *X* 长度相同的向量或者矩阵。\n\n#### 详情\n\n对于只输入一个参数的情况，比较时忽略 NULL 值。函数的返回值说明如下：\n\n* 若 *X* 为向量，返回 *X* 中所有元素的最小值。\n\n* 若 *X* 为矩阵，计算每列的最小值，返回一个向量。\n\n* 若 *X* 为表，计算每列的最小值，返回一个表。\n\n对于输入两个参数的情况，比较时不忽略 NULL 值。函数返回值说明如下：\n\n* 若 *Y* 是标量，则与 *X* 中所有元素进行比较，用较小值替换 *X* 中的元素并返回。\n\n* 若 *Y* 和 *X* 的类型长度一致，则将两者对应位置的元素进行比较，返回较小的结果。\n\n请注意，从 2.00.8 版本开始，min 处理时间类型数据的行为（之前版本统一转换为长整型）修改为：\n\n* 若 *X* 和 *Y* 是时间类型标量，系统会将时间类型统一为两者中较高精度对应的类型，再比较大小。\n\n* 若 *X* 或 *Y* 是向量、矩阵或表，则必须具有相同的时间类型。\n\n#### 例子\n\n```\nmin(1 2 3);\n// output\n1;\n\nmin(2.0 1.1 0.1 NULL);\n// output\n0.1\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nmin(m);\n// output\n[1,4]\n```\n\n```\nmin(1 2 3, 2)\n// output\n1 2 2\n\nn = matrix(1 1 1, 5 5 5)\nn;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 1  | 5  |\n| 1  | 5  |\n\n```\nmin(m, n);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 1  | 5  |\n| 1  | 5  |\n\n`min` 可以搭配 select 使用, 返回某列的最小值：\n\n```\nt = table(`abb`aac`aaa as sym, 1.8 2.3 3.7 as price);\nselect min price from t;\n```\n\n| min\\_price |\n| ---------- |\n| 1.8        |\n\n`min` 可以应用于字符串，返回字典序最小的字符串：\n\n```\nselect min sym from t;\n```\n\n| min\\_sym |\n| -------- |\n| aaa      |\n\n相关函数：[mmin](https://docs.dolphindb.cn/zh/funcs/m/mmin.html)\n"
    },
    "minIgnoreNull": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/minignorenull.html",
        "signatures": [
            {
                "full": "minIgnoreNull(X, Y)",
                "name": "minIgnoreNull",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [minIgnoreNull](https://docs.dolphindb.cn/zh/funcs/m/minignorenull.html)\n\n#### 语法\n\nminIgnoreNull(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是数值型、LITERAL 或 TEMPORAL 型的标量/数据对/向量/矩阵。\n\n#### 详情\n\n一个二元标量函数，返回两个数（*X* 和 *Y*）中的最小值。\n\n它与 `min` 作为二元标量函数区别在于对空值的处理：\n\n* `min`：当配置项 \\*nullAsMinValueForComparison=\\*true 时，空值被视为最小值进行比较；否则空值不参与比较，结果返回空值。\n\n* `minIgnoreNull`：不受配置项 *nullAsMinValueForComparison* 的影响。返回 *X* 或 *Y* 中的非空值，或者如果两者都非空，返回最小值。\n\n#### 例子\n\n```\nminIgnoreNull(2,matrix(1  NULL -4,-1 -4  0)) \n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | -1 |\n| 2  | -4 |\n| -4 | 0  |\n\n```\nminIgnoreNull(matrix(10 3 NULL, 1 7 4),matrix(1  NULL -4,-1 -4  0))\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | -1 |\n| 3  | -4 |\n| -4 | 0  |\n\n使用 `reduce` 结合 `minIgNoreNull`，计算元组中存储的同形状矩阵每个位置的最小值，忽略空值。\n\n```\nn1 = matrix(1 1 1, 5 5 5)\nn2 = matrix(10 11 12, 0 NULL -5)\nn3 = matrix(-1 1 NULL, -3 0 10)\nreduce(minIgnoreNull, [n1,n2,n3])\n```\n\n相关函数：[min](https://docs.dolphindb.cn/zh/funcs/m/min.html), [maxIgnoreNull](https://docs.dolphindb.cn/zh/funcs/m/maxignorenull.html)\n\n"
    },
    "minute": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/minute.html",
        "signatures": [
            {
                "full": "minute(X)",
                "name": "minute",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [minute](https://docs.dolphindb.cn/zh/funcs/m/minute.html)\n\n\n\n#### 语法\n\nminute(X)\n\n#### 详情\n\n返回对应的分钟数。\n\n#### 参数\n\n**X** 可以是整数标量或向量、时间标量或向量。\n\n#### 例子\n\n```\nminute();\n```\n\n返回：null\n\n```\nminute(1)\n```\n\n返回：00:01m\n\n```\nminute(now());\n```\n\n返回：16:02m\n\n**Related information**\n\n[second](https://docs.dolphindb.cn/zh/funcs/s/second.html)\n\n[month](https://docs.dolphindb.cn/zh/funcs/m/month.html)\n\n[date](https://docs.dolphindb.cn/zh/funcs/d/date.html)\n\n[year](https://docs.dolphindb.cn/zh/funcs/y/year.html)\n"
    },
    "minuteOfHour": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html",
        "signatures": [
            {
                "full": "minuteOfHour(X)",
                "name": "minuteOfHour",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [minuteOfHour](https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html)\n\n\n\n#### 语法\n\nminuteOfHour(X)\n\n#### 参数\n\n**X** 可以是 TIME, MINUTE, SECOND, DATETIME, TIMESTAMP, NANOTIME 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n返回 *X* 中的分钟数。\n\n#### 例子\n\n```\nminuteOfHour(12:32:00);\n// output\n32\n\nminuteOfHour([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n// output\n[30,35,36,2]\n```\n\n相关函数：[dayOfYear](https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html), [secondOfMinute](https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.cn/zh/funcs/m/millisecond.html), [microsecond](https://docs.dolphindb.cn/zh/funcs/m/microsecond.html), [nanosecond](https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html)\n"
    },
    "mkdir": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mkdir.html",
        "signatures": [
            {
                "full": "mkdir(directory)",
                "name": "mkdir",
                "parameters": [
                    {
                        "full": "directory",
                        "name": "directory"
                    }
                ]
            }
        ],
        "markdown": "### [mkdir](https://docs.dolphindb.cn/zh/funcs/m/mkdir.html)\n\n\n\n#### 语法\n\nmkdir(directory)\n\n#### 参数\n\n**directory** 为要创建的目录的名字。\n\n#### 详情\n\n创建一个目录。该函数必须要用户登录后才能执行。\n\n#### 例子\n\n```\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n\n```\nmkdir(\"/home/test/dir1\");\nmkdir(\"/home/test/dir2\");\nmkdir(\"/home/test/dir3\");\n// output\nThe directory [/home/test/dir3] already exists.\n```\n\n```\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| dir1     | 1     | 0        | 1496651628372 | 1496651628372 |\n| dir2     | 1     | 0        | 1496651645598 | 1496651645598 |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n"
    },
    "mkurtosis": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mkurtosis.html",
        "signatures": [
            {
                "full": "mkurtosis(X, window, [biased=true], [minPeriods])",
                "name": "mkurtosis",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mkurtosis](https://docs.dolphindb.cn/zh/funcs/m/mkurtosis.html)\n\n\n\n#### 语法\n\nmkurtosis(X, window, \\[biased=true], \\[minPeriods])\n\n部分通用参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否是有偏估计。默认值为 true，表示有偏估计。\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 的峰度。\n\n#### 例子\n\n```\nm=matrix(1 9 3 100 3 2 1 -100 9 10000, 1 2 3 4 5 6 7 8 9 100);\nm.mkurtosis(8);\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n|                   |                   |\n|                   |                   |\n|                   |                   |\n|                   |                   |\n|                   |                   |\n|                   |                   |\n| 3.989653641279048 | 1.761904761904762 |\n| 3.989840910744778 | 1.761904761904762 |\n| 6.140237905908072 | 6.101712240467206 |\n\n```\nm.rename!(date(2020.04.06)+1..10, `col1`col2)\nm.setIndexedMatrix!()\nmkurtosis(m, 8d)\n```\n\n| label      | col1   | col2   |\n| ---------- | ------ | ------ |\n| 2020.04.07 |        |        |\n| 2020.04.08 |        |        |\n| 2020.04.09 | 1.5    | 1.5    |\n| 2020.04.10 | 2.3195 | 1.64   |\n| 2020.04.11 | 3.2251 | 1.7    |\n| 2020.04.12 | 4.163  | 1.7314 |\n| 2020.04.13 | 5.1141 | 1.75   |\n| 2020.04.14 | 3.9897 | 1.7619 |\n| 2020.04.15 | 3.9898 | 1.7619 |\n| 2020.04.16 | 6.1402 | 6.1017 |\n\n```\nmkurtosis(m, 1w)\n```\n\n| label      | col1   | col2   |\n| ---------- | ------ | ------ |\n| 2020.04.07 |        |        |\n| 2020.04.08 |        |        |\n| 2020.04.09 | 1.5    | 1.5    |\n| 2020.04.10 | 2.3195 | 1.64   |\n| 2020.04.11 | 3.2251 | 1.7    |\n| 2020.04.12 | 4.163  | 1.7314 |\n| 2020.04.13 | 5.1141 | 1.75   |\n| 2020.04.14 | 3.4937 | 1.75   |\n| 2020.04.15 | 3.4937 | 1.75   |\n| 2020.04.16 | 5.1645 | 5.145  |\n\nDolphinDB 的 `kurtosis` 默认情况（当 *biased*=true 时）存在偏差，而 pandas 的 kurt 默认为无偏估计，且减去正态分布的峰值3。下面例子示意了使用滑动窗口时，两者的等价转换关系：\n\n```\npython\nm = [[1111,2], [323,9], [43,12], [51,32], [6,400]]\ndf = pandas.DataFrame(m)\ny = df.rolling(4).kurt()\n\ndolphindb\nm=matrix(1111 323 43 51 6, 2 9 12 32 400)\nm.mkurtosis(4, false)-3\n```\n\n| #0       | #1       |\n| -------- | -------- |\n|          |          |\n|          |          |\n|          |          |\n| 2.504252 | 2.366838 |\n| 3.675552 | 3.941262 |\n\n相关函数：[kurtosis](https://docs.dolphindb.cn/zh/funcs/k/kurtosis.html)\n"
    },
    "mkurtosisTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mkurtosisTopN.html",
        "signatures": [
            {
                "full": "mkurtosisTopN(X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "mkurtosisTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [mkurtosisTopN](https://docs.dolphindb.cn/zh/funcs/m/mkurtosisTopN.html)\n\n\n\n#### 语法\n\nmkurtosisTopN(X, S, window, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否是有偏估计。默认值为 true，表示有偏估计。\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素计算峰度。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmkurtosisTopN(X, S, 6, 4)\n// output\n[,,1.49,2.23,2.31,2.11,2.27]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\nmkurtosisTopN(X, S, 6, 4)\n```\n\n| col1   | col2   |\n| :----- | :----- |\n|        |        |\n|        |        |\n| 1.5    |        |\n| 1.5    | 1.5    |\n| 1.8457 | 1.5    |\n| 1.5734 | 1.8457 |\n| 1.8457 | 1.2215 |\n| 1.64   | 2      |\n| 1.64   | 1.64   |\n| 1.64   | 1.8457 |\n\n```\nsymbol = [\"A\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"B\",\"B\",\"A\",\"B\",\"A\",\"B\",\"B\",\"A\",\"B\",\"A\"]\ntime = temporalAdd(2023.07.05T09:30:00.000,[10,20,40,60,70,80,90,140,160,170,180,190,200,210,220,230,250,360,390,400],\"ms\")\nprice = [28.11,28.25,28.44,52.31,28.98,28.89,52.22,28.16,28.52,52.62,52.56,52.2,28.01,52.43,28.57,52.42,52.19,28.16,52.84,28.18]\nqty = [5000,400,3100,100,2400,3700,700,3700,4600,4700,3100,3300,3900,3500,3000,3000,4000,4700,2000,4400]\nBSFlag = [1,0,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0]\nt = table(time, symbol, price, qty, BSFlag)\nselect time,symbol,mkurtosisTopN(price, qty, 8, 5) as mskewTop5price from t context by symbol\n```\n\n| time                    | symbol | mskewTop5price |\n| ----------------------- | ------ | -------------- |\n| 2023.07.05T09:30:00.010 | A      |                |\n| 2023.07.05T09:30:00.020 | A      |                |\n| 2023.07.05T09:30:00.040 | A      | 1.5            |\n| 2023.07.05T09:30:00.070 | A      | 2.0147         |\n| 2023.07.05T09:30:00.080 | A      | 1.3355         |\n| 2023.07.05T09:30:00.140 | A      | 1.2976         |\n| 2023.07.05T09:30:00.160 | A      | 1.2976         |\n| 2023.07.05T09:30:00.200 | A      | 1.2976         |\n| 2023.07.05T09:30:00.220 | A      | 2.2021         |\n| 2023.07.05T09:30:00.360 | A      | 1.656          |\n| 2023.07.05T09:30:00.400 | A      | 1.351          |\n| 2023.07.05T09:30:00.060 | B      |                |\n| 2023.07.05T09:30:00.090 | B      |                |\n| 2023.07.05T09:30:00.170 | B      | 1.5            |\n| 2023.07.05T09:30:00.180 | B      | 1.1993         |\n| 2023.07.05T09:30:00.190 | B      | 1.289          |\n| 2023.07.05T09:30:00.210 | B      | 1.7383         |\n| 2023.07.05T09:30:00.230 | B      | 1.8183         |\n| 2023.07.05T09:30:00.250 | B      | 1.8183         |\n| 2023.07.05T09:30:00.390 | B      | 1.923          |\n\n相关函数：[mkurtosis](https://docs.dolphindb.cn/zh/funcs/m/mkurtosis.html)\n"
    },
    "mlast": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mlast.html",
        "signatures": [
            {
                "full": "mlast(X, window, [minPeriods])",
                "name": "mlast",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mlast](https://docs.dolphindb.cn/zh/funcs/m/mlast.html)\n\n\n\n#### 语法\n\nmlast(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 的最后一个元素。\n\n#### 例子\n\n```\nindex = second(08:20:00)+1..7\nx = 2 1 3 NULL 6 5 4\nx = index.indexedSeries(x)\nmlast(x,3s)\n```\n\n| label    | col1 |\n| -------- | ---- |\n| 08:20:01 | 2    |\n| 08:20:02 | 1    |\n| 08:20:03 | 3    |\n| 08:20:04 |      |\n| 08:20:05 | 6    |\n| 08:20:06 | 5    |\n| 08:20:07 | 4    |\n\n```\nm = matrix(1 5 9 0 2, 9 10 2 NULL 2)\nm.rename!((date(2020.09.08)+1..3) join 2020.09.16 join 2020.09.26, `A`B)\nm.setIndexedMatrix!()\nmlast(m, 3d)\n```\n\n| label      | A | B  |\n| ---------- | - | -- |\n| 2020.09.09 | 1 | 9  |\n| 2020.09.10 | 5 | 10 |\n| 2020.09.11 | 9 | 2  |\n| 2020.09.16 | 0 |    |\n| 2020.09.26 | 2 | 2  |\n\n```\nmlast(m, 1w)\n```\n\n| label      | A | B  |\n| ---------- | - | -- |\n| 2020.09.09 | 1 | 9  |\n| 2020.09.10 | 5 | 10 |\n| 2020.09.11 | 9 | 2  |\n| 2020.09.16 | 0 |    |\n| 2020.09.26 | 2 | 2  |\n\n相关函数：[last](https://docs.dolphindb.cn/zh/funcs/l/last.html), [first](https://docs.dolphindb.cn/zh/funcs/f/first.html)\n"
    },
    "mlastNot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mlastnot.html",
        "signatures": [
            {
                "full": "mlastNot(X, window, [k=NULL], [minPeriods=1])",
                "name": "mlastNot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[k=NULL]",
                        "name": "k",
                        "optional": true,
                        "default": "NULL"
                    },
                    {
                        "full": "[minPeriods=1]",
                        "name": "minPeriods",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [mlastNot](https://docs.dolphindb.cn/zh/funcs/m/mlastnot.html)\n\n\n\n#### 语法\n\nmlastNot(X, window, \\[k=NULL], \\[minPeriods=1])\n\n部分通用参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 参数\n\n**k** 可选参数，是一个数值或字符串类型的标量，表示用于匹配的数据。\n\n#### 详情\n\n若 *X* 是向量：\n\n* 如果没有指定 *k*，计算给定长度（以元素个数或时间长度衡量）的滑动窗口内 *X* 中第一个不为 NULL 的元素。\n\n* 如果指定 *k*，计算给定长度（以元素个数或时间长度衡量）的滑动窗口内 *X* 中第一个不为 *k* 或 NULL 的元素。\n\n若 *X* 是矩阵或表，则在每列内进行上述计算。\n\n#### 例子\n\n例 1\n\n```\nmlastNot(NULL 2 NULL 4 5, 2)\n// output: [,2,2,4,5]\n```\n\n例 2\n\n```\nmlastNot(X=matrix(1..5,2..6,3..7), window=2, k=4, minPeriods=2)\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n|    |    |    |\n| 2  | 3  | 3  |\n| 3  | 3  | 5  |\n| 3  | 5  | 6  |\n| 5  | 6  | 7  |\n\n例 3\n\n```\nx=table([\"s1\", \"s2\", \"\", \"s4\", \"s5\"] as col1, [\"s1\", \"\", \"s3\", \"\", \"s5\"] as col2)\nmlastNot(X=x, window=2)\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n| s2 | s1 |\n| s2 | s3 |\n| s4 | s3 |\n| s5 | s5 |\n\n例 4\n\n```\nT = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.06, 2022.01.07, 2022.01.08, 2022.01.10, 2022.01.11]\nX = 1..8\nX1 = indexedSeries(T, X)\nmlastNot(X=X1, window=3, k=1, minPeriods=1)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2022.01.01 |    |\n| 2022.01.02 | 2  |\n| 2022.01.03 | 3  |\n| 2022.01.06 | 4  |\n| 2022.01.07 | 5  |\n| 2022.01.08 | 6  |\n| 2022.01.10 | 7  |\n| 2022.01.11 | 8  |\n\n**Related information**\n\n[mfirstNot](https://docs.dolphindb.cn/zh/funcs/m/mfirstnot.html)\n"
    },
    "mLowRange": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mlowrange.html",
        "signatures": [
            {
                "full": "mLowRange(X, window, [minPeriods])",
                "name": "mLowRange",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mLowRange](https://docs.dolphindb.cn/zh/funcs/m/mlowrange.html)\n\n#### 语法\n\nmLowRange(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内，统计每个元素 Xi 左侧相邻且连续大于它的元素个数。NULL 被视为最小值。\n\n若 *X* 是矩阵，在每列内进行上述计算。\n\n#### 例子\n\n```\nx = [NULL, 3.1, NULL, 3.0, 2.9, 2.8, 3.1, NULL, 3.2]\nmLowRange(x, window=3) \n// output: [,,1,0,1,2,0,2,0]\n\nmLowRange(x, window=3, minPeriods=1) \n// output: [,0,1,0,1,2,0,2,0]\n\nmLowRange(x, window=3, minPeriods=2) \n// output: [,,,0,1,2,0,2,0]\n\ndate = [0, 1, 2, 3, 7, 8, 9, 10, 11] + 2020.01.01\nX = indexedSeries(date, x)\nmLowRange(X, 3d)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2020.01.01 |    |\n| 2020.01.02 | 0  |\n| 2020.01.03 | 1  |\n| 2020.01.04 | 0  |\n| 2020.01.08 | 0  |\n| 2020.01.09 | 1  |\n| 2020.01.10 | 0  |\n| 2020.01.11 | 2  |\n| 2020.01.12 | 0  |\n\n```\nm = matrix(1 2 3 NULL, 1 2 NULL 3, 1 3 NULL NULL, 1 2 3 4)\nmLowRange(m, 2)\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n|    |    |    |    |\n| 0  | 0  | 0  | 0  |\n| 0  | 1  | 1  | 0  |\n| 1  | 0  |    | 0  |\n\n"
    },
    "mmad": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mmad.html",
        "signatures": [
            {
                "full": "mmad(X, window, [useMedian=false], [minPeriods])",
                "name": "mmad",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[useMedian=false]",
                        "name": "useMedian",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mmad](https://docs.dolphindb.cn/zh/funcs/m/mmad.html)\n\n\n\n#### 语法\n\nmmad(X, window, \\[useMedian=false], \\[minPeriods])\n\n部分通用参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n**useMedian** 是一个布尔值，默认值是 false，表示计算平均绝对离差（mean absolute deviation）。若为 true 则计算绝对中位差（median absolute deviation）。\n\n* 平均绝对离差：mean(abs(X - mean(X)))\n\n* 绝对中位差：med(abs(X - med(X)))\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的平均绝对离差或绝对中位差。\n\n#### 例子\n\n```\nx = 7 4 6 0 -5 32;\nmmad(x, window=3);\n// output\n[,,1.111111111111111,2.222222222222222,3.777777777777777,15.333333333333333]\n\nmmad(x, window=3, useMedian=true)\n// output\n[,,1,2,3.666666666666666,12.333333333333333]\n\ny = NULL NULL 2 5 1 7 -3 0\nmmad(y, window=3, minPeriods=2);\n// output\n[,,,1.5,1.555555555555555,2.222222222222222,3.555555555555556,3.777777777777778]\n```\n\n```\nm=matrix(85 90 95, 185 190 195);\nm;\n```\n\n| #0 | #1  |\n| -- | --- |\n| 85 | 185 |\n| 90 | 190 |\n| 95 | 195 |\n\n```\nmmad(x, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n|     |     |\n| 2.5 | 2.5 |\n| 2.5 | 2.5 |\n\n相关函数： [mad](https://docs.dolphindb.cn/zh/funcs/m/mad.html)\n"
    },
    "mmax": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mmax.html",
        "signatures": [
            {
                "full": "mmax(X, window, [minPeriods])",
                "name": "mmax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mmax](https://docs.dolphindb.cn/zh/funcs/m/mmax.html)\n\n\n\n#### 语法\n\nmmax(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 元素的最大值。\n\n#### 例子\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmmax(X, 3);\n// output\n[,,3,7,7,7,6]\n\nmmax(Y, 3);\n// output\n[,,3,3,6,6,6]\n\nmmax(Y, 3, minPeriods=1);\n// output\n[2,2,3,3,6,6,6]\n```\n\n```\nm = matrix(1 5 9 0 2, 9 10 2 NULL 2)\nm.rename!(date(2020.09.08)+1..5, `A`B)\nm.setIndexedMatrix!()\nm.mmax(3d)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 1    | 9    |\n| 2020.09.10 | 5    | 10   |\n| 2020.09.11 | 9    | 10   |\n| 2020.09.12 | 9    | 10   |\n| 2020.09.13 | 9    | 2    |\n\n```\nm.mmax(1w)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 1    | 9    |\n| 2020.09.10 | 5    | 10   |\n| 2020.09.11 | 9    | 10   |\n| 2020.09.12 | 9    | 10   |\n| 2020.09.13 | 9    | 10   |\n\n相关函数：[max](https://docs.dolphindb.cn/zh/funcs/m/max.html)\n"
    },
    "mmaxPositiveStreak": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mmaxPositiveStreak.html",
        "signatures": [
            {
                "full": "mmaxPositiveStreak(X, window)",
                "name": "mmaxPositiveStreak",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [mmaxPositiveStreak](https://docs.dolphindb.cn/zh/funcs/m/mmaxPositiveStreak.html)\n\n\n\n#### 语法\n\nmmaxPositiveStreak(X, window)\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内统计 *X* 中连续正数之和的最大值。\n\n#### 例子\n\n```\nx = 1 -1 1 -2 10 3 3 9 0 6 5\nw = 5\nmmaxPositiveStreak(x, w)\n// output\n[,,,,10,13,16,25,25,15,12]\n\nx = 5 NULL 3 2 1 5 10 9 NULL 9 10 -1 NULL\nw = 5\nmmaxPositiveStreak(x, w)\n// output\n[,,,,6,11,21,27,25,24,19,19,19]\n\n// 搭配 signum 函数用于统计向量中出现的连续正数的最大个数\nmmaxPositiveStreak(signum(x), w)\n// output\n[,,,,3,4,5,5,4,3,2,2,2]\n```\n"
    },
    "mmed": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mmed.html",
        "signatures": [
            {
                "full": "mmed(X, window, [minPeriods])",
                "name": "mmed",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mmed](https://docs.dolphindb.cn/zh/funcs/m/mmed.html)\n\n\n\n#### 语法\n\nmmed(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 元素的中位数。\n\n#### 例子\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmmed(X, 3);\n// output\n[,,2,3,6,6,5]\n\nmmed(Y, 3);\n// output\n[,,2,2,4.5,5.5,5]\n\nmmed(Y, 3, minPeriods=1);\n// output\n[2,1.5,2,2,4.5,5.5,5]\n```\n\n```\nm = matrix(1 5 9 0 2, 9 10 2 NULL 2)\nm.rename!(date(2020.09.08)+1..5, `A`B)\nm.setIndexedMatrix!()\nm.mmed(3d)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 1    | 9    |\n| 2020.09.10 | 3    | 9.5  |\n| 2020.09.11 | 5    | 9    |\n| 2020.09.12 | 5    | 6    |\n| 2020.09.13 | 2    | 2    |\n\n```\nm.mmed(1w)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 1    | 9    |\n| 2020.09.10 | 3    | 9.5  |\n| 2020.09.11 | 5    | 9    |\n| 2020.09.12 | 3    | 9    |\n| 2020.09.13 | 2    | 5.5  |\n\n相关函数：[med](https://docs.dolphindb.cn/zh/funcs/m/med.html)\n"
    },
    "mmin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mmin.html",
        "signatures": [
            {
                "full": "mmin(X, window, [minPeriods])",
                "name": "mmin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mmin](https://docs.dolphindb.cn/zh/funcs/m/mmin.html)\n\n\n\n#### 语法\n\nmmin(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 元素的最小值。\n\n#### 例子\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmmin(X, 3);\n// output\n[,,1,1,3,5,4]\n\nmmin(Y, 3);\n// output\n[,,1,1,3,5,4]\n\nmmin(Y, 3, minPeriods=1);\n// output\n[2,1,1,1,3,5,4]\n```\n\n```\nm = matrix(1 5 9 0 2 8 -1 5, 9 10 2 NULL -1 10 2 3)\nm.rename!(date(2020.09.10)+1..8, `A`B)\nm.setIndexedMatrix!()\nm.mmin(3d)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.11 | 1    | 9    |\n| 2020.09.12 | 1    | 9    |\n| 2020.09.13 | 1    | 2    |\n| 2020.09.14 | 0    | 2    |\n| 2020.09.15 | 0    | (1)  |\n| 2020.09.16 | 0    | (1)  |\n| 2020.09.17 | (1)  | (1)  |\n| 2020.09.18 | (1)  | 2    |\n\n```\nm.mmin(1w)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.11 | 1    | 9    |\n| 2020.09.12 | 1    | 9    |\n| 2020.09.13 | 1    | 2    |\n| 2020.09.14 | 0    | 2    |\n| 2020.09.15 | 0    | (1)  |\n| 2020.09.16 | 0    | (1)  |\n| 2020.09.17 | (1)  | (1)  |\n| 2020.09.18 | (1)  | (1)  |\n\n相关函数：[min](https://docs.dolphindb.cn/zh/funcs/m/min.html)\n"
    },
    "mmse": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mmse.html",
        "signatures": [
            {
                "full": "mmse(Y, X, window, [minPeriods])",
                "name": "mmse",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mmse](https://docs.dolphindb.cn/zh/funcs/m/mmse.html)\n\n\n\n#### 语法\n\nmmse(Y, X, window, \\[minPeriods])\n\n#### 参数\n\n**Y** 是一个向量，表示因变量。\n\n**X** 是一个向量，表示自变量。\n\n**window** 是一个正整数，表示滑动窗口的长度。\n\n**minPeriods** 是一个正整数。如果一个滑动窗口中的非 NULL 值的数量小于 *minPeriods*，那么该窗口的结果为NULL。\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，将因变量 *Y* 与自变量 *X* 进行普通最小二乘回归的系数估计并计算均方误差。计算公式如下：\n\n![](https://docs.dolphindb.cn/zh/images/mmse.png)\n\n返回的结果是包含两个向量的元组，第一个向量是普通最小二乘回归的系数估计，第二个向量是均方误差。\n\n#### 例子\n\n```\nx=0.011 0.006 -0.008 0.012 -0.016 -0.023 0.018\ny=0.016 0.009 -0.012 0.022 0.003 -0.056 0.002;\n\nmmse(y, x, 5)[0];\n\n//output: [,,,,0.818182,1.692379,1.188532]\n\nmmse(y, x, 5)[1];\n\n//output: [,,,,0.000055,0.000231,0.000332]\n\nselect y, x, mmse(y,x,5,3) as `mbeta`mmse from table(x,y);\n```\n\n返回：\n\n| y      | x      | mbeta    | mmse        |\n| ------ | ------ | -------- | ----------- |\n| 0.016  | 0.011  |          |             |\n| 0.009  | 0.006  |          |             |\n| -0.012 | -0.008 | 1.479381 | 2.806415E-8 |\n| 0.022  | 0.012  | 1.594701 | 0.000003    |\n| 0.003  | -0.016 | 0.818182 | 0.000055    |\n| -0.056 | -0.023 | 1.692379 | 0.000231    |\n| 0.002  | 0.018  | 1.188532 | 0.000332    |\n"
    },
    "mod": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mod.html",
        "signatures": [
            {
                "full": "mod(X, Y)",
                "name": "mod",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [mod](https://docs.dolphindb.cn/zh/funcs/m/mod.html)\n\n\n\n#### 语法\n\nmod(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量或矩阵。如果 *X* 或 *Y* 的其中一个是数据对、向量或矩阵，另一个必须是具有相同长度或维度的数据对、向量或矩阵。\n\n#### 详情\n\n`mod` 表示取模运算。它返回 *X* 和 *Y* 逐个元素相除得到的余数。\n\n* 当 *Y* 是正整数时，结果总是非负的，例如，-10%3 的结果是 2；\n* 当 *Y* 是负整数时，结果总是非正的，例如，-10%-3 的结果是 -1。\n\n`mod` 函数常用于数据分组。比如，\\[5,4,3,3,5,6]%3 是 \\[2,1,0,0,2,0]，于是数据被分成了三组。\n\n#### 例子\n\n```\nx=1 2 3;\nx % 2;\n// output\n[1,0,1]\n\n2 % x;\n// output\n[0,0,2]\n\ny=4 5 6;\nx mod y;\n// output\n[1,2,3]\n\nmod(y, x);\n// output\n[0,1,0]\n\nm=1..6$2:3;\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm mod 3;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 0  | 2  |\n| 2  | 1  | 0  |\n\n```\nx=-1 2 3;\nx%-5;\n// output\n[-1,-3,-2]\n\n-1%5;\n// output\n4\n```\n"
    },
    "mode": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mode.html",
        "signatures": [
            {
                "full": "mode(X)",
                "name": "mode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [mode](https://docs.dolphindb.cn/zh/funcs/m/mode.html)\n\n\n\n#### 语法\n\nmode(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n若 *X* 为向量，计算 *X* 中出现次数最多的值。\n\n若 *X* 为矩阵/表，计算其每列中出现次数最多的值，返回一个向量/表。\n\n该函数通过 hash table 统计 *X* 中唯一值（key）出现的次数，当有多个次数最多的 key 时，返回 hash table 中的第一个 key。与所有其它聚合函数一致，该函数在计算时忽略 NULL 值。\n\n**Note:** 对于不同数据类型，该函数采用的 hash 算法不相同，因此输出结果可能不同。\n\n#### 例子\n\n```\nmode 2;\n// output\n2\n\nmode 1 3 3 3 4 5 5;\n// output\n3\n\nmode `test;\n// output\ntest\n\nm=matrix(1 1 2 2 2 3, 4 4 5 6 6 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 1  | 4  |\n| 2  | 5  |\n| 2  | 6  |\n| 2  | 6  |\n| 3  | 6  |\n\n```\nmode m;\n// output\n[2,6]\n```\n\n相关的中心趋势函数：[mean](https://docs.dolphindb.cn/zh/funcs/m/mean.html) 和 [med](https://docs.dolphindb.cn/zh/funcs/m/med.html)\n"
    },
    "month": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/month.html",
        "signatures": [
            {
                "full": "month(X)",
                "name": "month",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [month](https://docs.dolphindb.cn/zh/funcs/m/month.html)\n\n\n\n#### 语法\n\nmonth(X)\n\n#### 详情\n\n返回对应的月份。\n\n#### 参数\n\n**X** 可以是时间标量或向量。\n\n#### 例子\n\n```\nmonth();\n```\n\n返回：null\n\n```\nmonth(`2012.12);\n```\n\n返回：2012.12M\n\n```\nmonth(2012.12.23);  // 把一个 DATE 类型的数据转换成 MONTH 类型。\n```\n\n返回：2012.12M\n\n```\nmonth(now());  // 把一个 TIMESTAMP 类型的数据转换成 MONTH 类型。\n```\n\n返回：2024.02M\n\n**Related information**\n\n[second](https://docs.dolphindb.cn/zh/funcs/s/second.html)\n\n[minute](https://docs.dolphindb.cn/zh/funcs/m/minute.html)\n\n[hour](https://docs.dolphindb.cn/zh/funcs/h/hour.html)\n\n[date](https://docs.dolphindb.cn/zh/funcs/d/date.html)\n\n[year](https://docs.dolphindb.cn/zh/funcs/y/year.html)\n"
    },
    "monthBegin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/monthBegin.html",
        "signatures": [
            {
                "full": "monthBegin(X, [offset], [n=1])",
                "name": "monthBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [monthBegin](https://docs.dolphindb.cn/zh/funcs/m/monthBegin.html)\n\n\n\n#### 语法\n\nmonthBegin(X, \\[offset], \\[n=1])\n\n别名：monthStart\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量、向量或表。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在月份的第一天。\n\n如果指定了 *offset*，表示从 *offset* 开始，结果每隔 *n* 月更新一次。注意，只有当 *n* > 1 时，*offset* 才会生效。\n\n#### 例子\n\n```\nmonthBegin(2016.12.06);\n// output\n2016.12.01\n\ndate=2016.04.12 2016.04.25 2016.05.12 2016.06.28 2016.07.10 2016.07.18 2016.08.02 2016.08.16 2016.09.26 2016.09.30\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by monthBegin(date,2016.01.01,2);\n```\n\n| monthBegin\\_date | avg\\_price | sum\\_qty |\n| ---------------- | ---------- | -------- |\n| 2016.03.01       | 39.53      | 4100     |\n| 2016.05.01       | 29.77      | 5300     |\n| 2016.07.01       | 112.82     | 16000    |\n| 2016.09.01       | 51.835     | 13300    |\n\n相关函数：[monthEnd](https://docs.dolphindb.cn/zh/funcs/m/monthEnd.html), [businessMonthBegin](https://docs.dolphindb.cn/zh/funcs/b/businessMonthBegin.html), [businessMonthEnd](https://docs.dolphindb.cn/zh/funcs/b/businessMonthEnd.html), [semiMonthBegin](https://docs.dolphindb.cn/zh/funcs/s/semiMonthBegin.html), [semiMonthEnd](https://docs.dolphindb.cn/zh/funcs/s/semiMonthEnd.html)\n"
    },
    "monthEnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/monthEnd.html",
        "signatures": [
            {
                "full": "monthEnd(X, [offset], [n=1])",
                "name": "monthEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [monthEnd](https://docs.dolphindb.cn/zh/funcs/m/monthEnd.html)\n\n\n\n#### 语法\n\nmonthEnd(X, \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量、向量或表。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在月份的最后一天。\n\n如果指定了 *offset*，表示从 *offset* 开始，结果每隔 *n* 月更新一次。注意，只有当 *n* > 1 时，*offset* 才会生效。\n\n#### 例子\n\n```\nmonthEnd(2016.12.06);\n// output\n2016.12.31\n\ndate=2016.04.12 2016.04.25 2016.05.12 2016.06.28 2016.07.10 2016.07.18 2016.08.02 2016.08.16 2016.09.26 2016.09.30\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by monthEnd(date,2016.01.01,2);\n```\n\n| monthEnd\\_date | avg\\_price | sum\\_qty |\n| -------------- | ---------- | -------- |\n| 2016.05.31     | 36.193333  | 6200     |\n| 2016.07.31     | 126.74     | 15400    |\n| 2016.09.30     | 51.1875    | 17100    |\n\n相关函数：[monthBegin](https://docs.dolphindb.cn/zh/funcs/m/monthBegin.html), [businessMonthBegin](https://docs.dolphindb.cn/zh/funcs/b/businessMonthBegin.html), [businessMonthEnd](https://docs.dolphindb.cn/zh/funcs/b/businessMonthEnd.html), [semiMonthBegin](https://docs.dolphindb.cn/zh/funcs/s/semiMonthBegin.html), [semiMonthEnd](https://docs.dolphindb.cn/zh/funcs/s/semiMonthEnd.html)\n"
    },
    "monthOfYear": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html",
        "signatures": [
            {
                "full": "monthOfYear(X)",
                "name": "monthOfYear",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [monthOfYear](https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html)\n\n\n\n#### 语法\n\nmonthOfYear(X)\n\n#### 参数\n\n**X** 可以是 DATE, MONTH, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量、向量或表。\n\n#### 详情\n\n返回 *X* 中的月份。\n\n#### 例子\n\n```\nmonthOfYear(2012.07.02);\n// output\n7\n\nmonthOfYear([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n// output\n[6,10,1,4]\n```\n\n相关函数：[dayOfYear](https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html), [weekOfYear](https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.cn/zh/funcs/m/millisecond.html), [microsecond](https://docs.dolphindb.cn/zh/funcs/m/microsecond.html), [nanosecond](https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html)\n"
    },
    "move": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/move.html",
        "signatures": [
            {
                "full": "move(X, steps)",
                "name": "move",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "steps",
                        "name": "steps"
                    }
                ]
            }
        ],
        "markdown": "### [move](https://docs.dolphindb.cn/zh/funcs/m/move.html)\n\n\n\n#### 语法\n\nmove(X, steps)\n\n#### 参数\n\n**X** 可以是向量、矩阵或表；\n\n**steps** 是一个整数或一个 [duration](https://docs.dolphindb.cn/zh/funcs/d/duration.html)，表示移动多少位置或多少时间。\n\n* 如果 *steps* 为正数，*X* 向右移动 *steps* 个位置；\n\n* 如果 *steps* 为负数，*X* 向左移动 *steps* 个位置；\n\n* 如果 *steps* 为 0，不改变 *X* 的位置；\n\n* 如果 *steps* 为 DURATION，对应的 *X* 必须是行索引为时间类型的索引矩阵或者索引序列。\n\n#### 详情\n\n`move` 是 [prev](https://docs.dolphindb.cn/zh/funcs/p/prev.html) 和 [next](https://docs.dolphindb.cn/zh/funcs/n/next.html) 的通用形式。\n\n#### 例子\n\n```\nx=3 9 5 1 4 9;\nmove(x,3);\n// output\n[,,,3,9,5]\n\nmove(x,-2);\n// output\n[5,1,4,9,,]\n\nindex = (second(08:20:00)+1..4) join 08:21:01 join 08:21:02\nx = index.indexedSeries(x)\nmove(x,3s)\n```\n\n| label    | col1 |\n| -------- | ---- |\n| 08:20:01 |      |\n| 08:20:02 |      |\n| 08:20:03 |      |\n| 08:20:04 | 3    |\n| 08:21:01 | 1    |\n| 08:21:02 | 1    |\n\n```\nmove(x,1m)\n```\n\n| label    | col1 |\n| -------- | ---- |\n| 08:20:01 |      |\n| 08:20:02 |      |\n| 08:20:03 |      |\n| 08:20:04 |      |\n| 08:21:01 | 3    |\n| 08:21:02 | 9    |\n"
    },
    "moveChunksAcrossVolume": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/moveChunksAcrossVolume.html",
        "signatures": [
            {
                "full": "moveChunksAcrossVolume(srcPath, destPath, chunkIds, [isDelSrc=true])",
                "name": "moveChunksAcrossVolume",
                "parameters": [
                    {
                        "full": "srcPath",
                        "name": "srcPath"
                    },
                    {
                        "full": "destPath",
                        "name": "destPath"
                    },
                    {
                        "full": "chunkIds",
                        "name": "chunkIds"
                    },
                    {
                        "full": "[isDelSrc=true]",
                        "name": "isDelSrc",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [moveChunksAcrossVolume](https://docs.dolphindb.cn/zh/funcs/m/moveChunksAcrossVolume.html)\n\n**Note:** 此函数将于近期版本中废弃，推荐使用函数 [moveReplicas](https://docs.dolphindb.cn/zh/funcs/m/moveReplicas.html) 实现相关功能。\n\n\n\n#### 语法\n\nmoveChunksAcrossVolume(srcPath, destPath, chunkIds, \\[isDelSrc=true])\n\n#### 参数\n\n**srcPath** 是一个字符串，格式如：`\"volumeA/CHUNKS\"`。表示源 chunks 的路径。\n\n**destPath** 是一个字符串，格式如：`\"volumeB/CHUNKS\"`。表示要转移到的目的 chunks 的路径。\n\n**chunkIds** 是一个字符串或者字符串向量。表示需要移动的 chunks 的 id 值。\n\n**isDelSrc** 布尔值，默认为 true。表示拷贝后是否删除源 chunks。\n\n**Note:** *srcPath*、 *destPath* 和 *chunkIds* 可以通过 [getChunksMeta](https://docs.dolphindb.cn/zh/funcs/g/getChunksMeta.html) 获取。\n\n#### 详情\n\n将一个磁盘卷 chunks 文件转移至指定的路径。 *isDelSrc* = true 时，源路径下的 chunks 被成功转移后，将被删除；否则，仍被保留。如果转移失败，保留源路径下的所有 chunks，清空目标路径下已经拷贝完成的文件。\n\n注意：\n\n* 只能在同一个节点下进行 chunks 文件的转移。\n\n* 进行该操作前，需要停止写入，保证所有事务都已完成，并将所有缓冲区的数据刷入磁盘。\n\n* 配置项 *volumes* 必须包含 *srcPath* 和 *destPath* 指定路径所在的磁盘卷，且该配置已经生效（修改配置项后重启使其生效）。\n\n* *destPath* 指定的 chunks 目录必须为空目录。\n\n**首发版本**：2.00.4\n"
    },
    "moveHotDataToColdVolume": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/moveHotDataToColdVolume.html",
        "signatures": [
            {
                "full": "moveHotDataToColdVolume([checkRange=240])",
                "name": "moveHotDataToColdVolume",
                "parameters": [
                    {
                        "full": "[checkRange=240]",
                        "name": "checkRange",
                        "optional": true,
                        "default": "240"
                    }
                ]
            }
        ],
        "markdown": "### [moveHotDataToColdVolume](https://docs.dolphindb.cn/zh/funcs/m/moveHotDataToColdVolume.html)\n\n\n\n#### 语法\n\nmoveHotDataToColdVolume(\\[checkRange=240])\n\n#### 参数\n\n**checkRange** 整数，单位为小时，默认值为 10 天，即 240 小时。用于设置需迁移至 *coldVolumes* 的数据的时间范围。设置后，时间范围在 \\[当前时间 - *hoursToColdVolumes* - *checkRange*, 当前时间 - *hoursToColdVolumes*) 内的数据将会被迁移至 *coldVolumes*。\n\n#### 详情\n\n强制触发将用户指定范围的数据转存至 *coldVolumes*。\n\n**Note:**\n\n* 该命令仅对当前节点有效。集群环境中，可通过 `pnodeRun` 调用该函数，使其在其它节点生效。\n\n* 该命令设置的转存策略与 [setRetentionPolicy](https://docs.dolphindb.cn/zh/funcs/s/setRetentionPolicy.html) 设置的转存策略的有区别，详情请参考 [TieredStorage](https://docs.dolphindb.cn/zh/db_distr_comp/db/tiered_storage.html)。\n"
    },
    "moveReplicas": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/moveReplicas.html",
        "signatures": [
            {
                "full": "moveReplicas(srcNode, destNode, chunkId, [destVolumes])",
                "name": "moveReplicas",
                "parameters": [
                    {
                        "full": "srcNode",
                        "name": "srcNode"
                    },
                    {
                        "full": "destNode",
                        "name": "destNode"
                    },
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    },
                    {
                        "full": "[destVolumes]",
                        "name": "destVolumes",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [moveReplicas](https://docs.dolphindb.cn/zh/funcs/m/moveReplicas.html)\n\n\n\n#### 语法\n\nmoveReplicas(srcNode, destNode, chunkId, \\[destVolumes])\n\n#### 参数\n\n**srcNode** 字符串，表示源节点的别名。\n\n**destNode** 字符串，表示目标节点的别名。\n\n**chunkId** 字符串/UUID 标量或向量，表示 chunk 的 ID。\n\n**destVolumes** 字符串标量或向量，表示移动到目的节点的具体目录，此目录必须来自配置文件中 volumes 指定的目录。如果为向量，则优先移动到向量中位次靠前的目录下。\n\n#### 详情\n\n通过该函数将源节点上的一个或多个 chunk 的副本移动到目标节点。如果目标节点上已经存在该 chunk，那么系统将放弃本次操作。\n\n该命令只能由管理员在控制节点上执行。\n\n通过 [getRecoveryTaskStatus](https://docs.dolphindb.cn/zh/funcs/g/getRecoveryTaskStatus.html) 函数可以查看任务状态。\n\n#### 例子\n\n把 \"node1\" 上所有 chunk 的副本移动到 \"node2\"的指定目录。\n\n```\nchunkIds=exec chunkId from pnodeRun(getChunksMeta) where node=\"node1\"\nmoveReplicas(\"node1\",\"node2\",chunkIds,\"/ddb/server/clusterDemo/data/node2/storage\");\n```\n"
    },
    "movingTopNIndex": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/movingTopNIndex.html",
        "signatures": [
            {
                "full": "movingTopNIndex(X, window, top, [ascending=true], [fixed=false], [tiesMethod='oldest'])",
                "name": "movingTopNIndex",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[fixed=false]",
                        "name": "fixed",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [movingTopNIndex](https://docs.dolphindb.cn/zh/funcs/m/movingTopNIndex.html)\n\n\n\n#### 语法\n\nmovingTopNIndex(X, window, top, \\[ascending=true], \\[fixed=false], \\[tiesMethod='oldest'])\n\n#### 参数\n\n**X** 是一个数值型/时间类型的向量。注意：从 2.00.10 版本开始，*X* 中的空值不参与排序。\n\n**window** 必须是不小于2的正整数，表示窗口长度。\n\n**top** 是一个大于1，小于等于 *window* 的整数。\n\n**ascending** 是一个布尔值，表示窗口内值的排序方式。true 表示升序，false 表示降序。\n\n**fixed** 是一个布尔值。表示输出的数组向量每行的长度是否固定为 *top*。默认值为 false。设置为 true 时所有窗口的长度相同，前( *top* - 1)个窗口内缺少的索引用 NULL 填充。\n\n**tiesMethod** 字符串。在滑动窗口内对 X 进行排序后，如果有多个具有相同值的元素无法全部进入前 *top*，可以通过该参数来指定选择元素的方式。可选值为：\n\n* 'oldest'：从最早进入窗口的元素开始选取，直至达到 *top* 个。\n\n* 'latest'：从最晚进入窗口的元素开始向前选取，直至达到 *top* 个。\n\n#### 详情\n\n返回一个数组向量，表示 *X* 在每一个滑动窗口内按照指定顺序排序后的前 *top* 个元素所对应的索引。\n\n**首发版本**：2.00.4\n\n#### 例子\n\n```\nS = 2 5 6 1 2 4 5 6 9 0\n\nm1 = movingTopNIndex(X=S, window=4, top=2, ascending=true, fixed=true)\nm1;\n// output\n[[,0],[0,1],[0,1],[3,0],[3,4],[3,4],[3,4],[4,5],[5,6],[9,6]]\n\nm2 = movingTopNIndex(X=S, window=4, top=2, ascending=false, fixed=true)\nm2;\n// output\n[[,0],[1,0],[2,1],[2,1],[2,1],[2,5],[6,5],[7,6],[8,7],[8,7]]\n\nm3 = movingTopNIndex(X=S, window=4, top=2, ascending=true, fixed=false)\nprint m3;\n// output\n[[0],[0,1],[0,1],[3,0],[3,4],[3,4],[3,4],[4,5],[5,6],[9,6]]\n\nS[m1[0]]\n// output\n[,2,2,1,1,1,1,2,4,0]\n\nS[m3[0]]\n// output\n[2,2,2,1,1,1,1,2,4,0]\n\nX = [5, 8, 1, 9, 7, 3, 1, NULL, 0, 8, 7, 7]\nmovingTopNIndex(X=X, window=4, top=2, ascending=true, fixed=true)\n// 2.00.10 之前的版本，X 中的空值也参与排序，结果是：\n[[00i,0],[0,1],[2,0],[2,0],[2,4],[2,5],[6,5],[7,6],[7,8],[7,8],[7,8],[8,10]]\n\n// 2.00.10 及之后版本，X 中的空值会被忽略，结果是：\n[[00i,0],[0,1],[2,0],[2,0],[2,4],[2,5],[6,5],[6,5],[8,6],[8,6],[8,10],[8,10]]\n\nX = [2, 1, 4, 3, 4, 3, 4]\n\n// 第6个滑动窗口中，X 排序后是 1 2 3 3 4 4，只取前3个排名，根据 tiesMethod 的设置值来选取哪个3被选取\n\n// tiesMethod 未指定，则取默认值 'oldest'，即选取第一次出现的3，其对应 X 中的索引是3\nmovingTopNIndex(X,6,3)\n\n// output\n[[0],[1,0],[1,0,2],[1,0,3],[1,0,3],[1,0,3],[1,3,5]]]\n\n\n// tiesMethod = 'latest'，即选最后一次出现的3，其对应 X 中的索引是5\nmovingTopNIndex(X,6,3,tiesMethod=\"latest\")\n\n// output\n[[0],[1,0],[1,0,2],[1,0,3],[1,0,3],[1,0,5],[1,3,5]]\n```\n"
    },
    "movingWindowData": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/movingWindowData.html",
        "signatures": [
            {
                "full": "movingWindowData(X, window, [fixed=false])",
                "name": "movingWindowData",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[fixed=false]",
                        "name": "fixed",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [movingWindowData](https://docs.dolphindb.cn/zh/funcs/m/movingWindowData.html)\n\n\n\n#### 语法\n\nmovingWindowData(X, window, \\[fixed=false])\n\n#### 参数\n\n**X** 是一个向量。\n\n**window** 必须是不小于 2 的正整数，表示以元素个数衡量的窗口的长度。\n\n**fixed** 是一个布尔值，表示输出的数组向量中每行元素的长度是否为 *window*。默认值为 false，直接输出窗口内的元素。设置为 true，前 (*window* - 1)个窗口内缺少的元素用 NULL 填充。\n\n#### 详情\n\n返回一个数组向量，其每行元素表示 *X* 每个滑动窗口的元素。\n\n#### 例子\n\n```\n\nS = -1 3 -4 0 5 10 9 7\nm = movingWindowData(X=S,window=3);\nm;\n// output\n[[-1],[-1,3],[-1,3,-4],[3,-4,0],[-4,0,5],[0,5,10],[5,10,9],[10,9,7]]\n\nmi = movingWindowData(X=S,window=3,fixed=true);\nmi;\n// output\n[[00i,00i,-1],[00i,-1,3],[-1,3,-4],[3,-4,0],[-4,0,5],[0,5,10],[5,10,9],[10,9,7]]\n    \n// 获取每个窗口第一个元素的值\nm[0]\n[-1,-1,-1,3,-4,0,5,10]\n\nmi[0]\n// output\n[,,-1,3,-4,0,5,10]\n\n\n// 在响应式引擎中获取长度为 5 的滑动窗口的数据\nn = 100\nDateTime = 2023.01.01T09:00:00 + rand(10000, n).sort!()\nSecurityID = take(`600021`600022`600023`600024`600025, n)\nPrice = 1.0 + rand(1.0, n) \nt = table(1:0, `DateTime`SecurityID`Price, [TIMESTAMP, SYMBOL, DOUBLE])\ntableInsert(t, DateTime, SecurityID, Price)\noutput = table(100:0, `SecurityID`DateTime`PriceNew, [SYMBOL, DATETIME, DOUBLE[]])\n\nengine = createReactiveStateEngine(name=\"rseEngine\", metrics=[<DateTime>, <movingWindowData(Price,5)>], dummyTable=t, outputTable=output, keyColumn=`SecurityID, keepOrder=true)\nengine.append!(t)\ndropStreamEngine(`rseEngine)\n```\n"
    },
    "movingWindowIndex": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/movingWindowIndex.html",
        "signatures": [
            {
                "full": "movingWindowIndex(X, window, [fixed=false])",
                "name": "movingWindowIndex",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[fixed=false]",
                        "name": "fixed",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [movingWindowIndex](https://docs.dolphindb.cn/zh/funcs/m/movingWindowIndex.html)\n\n\n\n#### 语法\n\nmovingWindowIndex(X, window, \\[fixed=false])\n\n#### 参数\n\n**X** 是一个向量。\n\n**window** 必须是不小于2的正整数，表示窗口长度。\n\n**fixed** 是一个布尔值。表示输出的数组向量每行的长度是否固定为 *window*。默认值为 false。设置为 true 时 表示所有窗口的长度相同，前 (*window* - 1)个窗口内缺少的索引用 NULL 填充。\n\n#### 详情\n\n返回一个数组向量，表示 *X* 在每一个窗口内的元素所对应的索引。\n\n**首发版本**：2.00.4\n\n#### 例子\n\n```\nS = 1 2 3 4 5 6 7 8 9 0;\nm = movingWindowIndex(X=S,window=3);\nm;\n// output\n[[0],[0,1],[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9]]\n\nmi = movingWindowIndex(X=S,window=3,fixed=true);\nmi;\n// output\n[[,,0],[,0,1],[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9]]\n\n// 获取每个窗口第一个元素的值\nS[m[0]]\n// output\n[1,1,1,2,3,4,5,6,7,8]\n\nS[mi[0]]\n// output\n[,,1,2,3,4,5,6,7,8]\n```\n"
    },
    "mpercentile": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mpercentile.html",
        "signatures": [
            {
                "full": "mpercentile(X, percent, window, [interpolation='linear'], [minPeriods])",
                "name": "mpercentile",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "percent",
                        "name": "percent"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mpercentile](https://docs.dolphindb.cn/zh/funcs/m/mpercentile.html)\n\n\n\n#### 语法\n\nmpercentile(X, percent, window, \\[interpolation='linear'], \\[minPeriods])\n\n部分通用参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 参数\n\n**percent** 是0到100之间的整数或小数。\n\n**interpolation** 是一个字符串，表示当选中的分位点位于在 *X* 的第 i 和第 i+1 个元素之间时，采用的插值方法。它具有以下取值：\n\n* 'linear'：![linear](https://docs.dolphindb.cn/zh/images/linear.png)，其中，![fraction](https://docs.dolphindb.cn/zh/images/fraction.png)\n\n* 'lower'：![lower](https://docs.dolphindb.cn/zh/images/lower.png)\n\n* 'higher'：![higher](https://docs.dolphindb.cn/zh/images/higher.png)\n\n* 'nearest'：![lower](https://docs.dolphindb.cn/zh/images/lower.png)和![higher](https://docs.dolphindb.cn/zh/images/higher.png)之中最接近分位点的数据\n\n* 'midpoint'：![midpoint](https://docs.dolphindb.cn/zh/images/midpoint.png)\n\n如果没有指定 *interpolation*，默认采用 'linear'。\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 元素在其对应窗口内的百分位数。\n\n#### 例子\n\n```\nx=2 1 3 7 6 5 4;\nmpercentile(x, percent=50, window=3);\n// output\n[,,2,3,6,6,5]\n\nmpercentile(x, percent=25, window=3, interpolation=\"lower\");\n// output\n[,,1,1,3,5,4]\n\nmpercentile(x, percent=75, window=3, interpolation=\"higher\")\n// output\n[,,3,7,7,7,6]\n\nmpercentile(x, percent=5, window=3, interpolation=\"nearest\")\n// output\n[,,1,1,3,5,4]\n\nmpercentile(x, percent=15, window=3, interpolation=\"midpoint\")\n// output\n[,,1.5,2,4.5,5.5,4.5]\n\nmpercentile(x, percent=50, window=3, interpolation=\"linear\", minPeriods=1);\n// output\n[2,1.5,2,3,6,6,5]\n\nm=matrix(2 1 3 7 6 5 4, 1..7);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 2  | 1  |\n| 1  | 2  |\n| 3  | 3  |\n| 7  | 4  |\n| 6  | 5  |\n| 5  | 6  |\n| 4  | 7  |\n\n```\nmpercentile(m, percent=50, window=3, interpolation=\"linear\", minPeriods=1);\n```\n\n| #0  | #1  |\n| --- | --- |\n| 2   | 1   |\n| 1.5 | 1.5 |\n| 2   | 2   |\n| 3   | 3   |\n| 6   | 4   |\n| 6   | 5   |\n| 5   | 6   |\n\n```\nm.rename!(date(2020.09.08)+1..7, `A`B)\nm.setIndexedMatrix!()\nmpercentile(m, percent=50, window=3d, interpolation=\"linear\", minPeriods=1);\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 2    | 1    |\n| 2020.09.10 | 1.5  | 1.5  |\n| 2020.09.11 | 2    | 2    |\n| 2020.09.12 | 3    | 3    |\n| 2020.09.13 | 6    | 4    |\n| 2020.09.14 | 6    | 5    |\n| 2020.09.15 | 5    | 6    |\n\n```\nmpercentile(m, percent=50, window=1w, interpolation=\"linear\", minPeriods=1);\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.09.09 | 2    | 1    |\n| 2020.09.10 | 1.5  | 1.5  |\n| 2020.09.11 | 2    | 2    |\n| 2020.09.12 | 2.5  | 2.5  |\n| 2020.09.13 | 3    | 3    |\n| 2020.09.14 | 4    | 3.5  |\n| 2020.09.15 | 4    | 4    |\n\n相关函数：[percentile](https://docs.dolphindb.cn/zh/funcs/p/percentile.html)\n"
    },
    "mpercentileTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mpercentiletopn.html",
        "signatures": [
            {
                "full": "mpercentileTopN(X, S, percent, window, top, [interpolation], [ascending], [tiesMethod='oldest'])",
                "name": "mpercentileTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "percent",
                        "name": "percent"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[interpolation]",
                        "name": "interpolation",
                        "optional": true
                    },
                    {
                        "full": "[ascending]",
                        "name": "ascending",
                        "optional": true
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mpercentileTopN](https://docs.dolphindb.cn/zh/funcs/m/mpercentiletopn.html)\n\n\n\n#### 语法\n\nmpercentileTopN(X, S, percent, window, top, \\[interpolation], \\[ascending], \\[tiesMethod='oldest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 参数\n\n**percent** 是 0 到 100之间的数，表示计算的百分位数。\n\n**interpolation** 是一个字符串，表示当选中的分位点位于在 *X* 的第 i 和第 i+1 个元素之间时，采用的插值方法。它具有以下取值，默认值为 'linear'：\n\n* ‘linear’：Xi+ ( Xi+1 - Xi ) \\* fraction，其中 fraction 为![](https://docs.dolphindb.cn/zh/images/fraction.png)\n\n* 'lower'：Xi\n\n* 'higher’：Xi+1\n\n* 'nearest'： Xi+1 和 Xi之中最接近分位点的数据\n\n* 'midpoint'：（Xi+1 + Xi)/2\n\n#### 详情\n\n* 若 *X*是向量，在长度为 *window*的滑动窗口内，根据 *ascending*指定的排序方式将 *X* 在窗口内的元素按照*S*进行稳定排序，取其前*top*个元素计算对应的 *percent*百分位数。\n\n* 若 *X*是矩阵或表，在每列内进行上述计算，返回同样数据类型和数据维度的结果。\n\n#### 例子\n\n```\nx =  [2,,8,0,4,,6,3,5,7] \ns = [,1,8,7,9,6,5,0,4,3]\nmpercentileTopN(x, s, percent=25, window=6, top=3, interpolation=\"lower\")\n// output：[,,8,0,0,0,6,3,3,3]\n\n\nmpercentileTopN(x, s, percent=75, window=6, top=3, interpolation=\"higher\")\n// output：[,,8,8,8,0,6,6,6,7]\n\n\nmpercentileTopN(x, s, percent=5, window=6, top=3, interpolation=\"nearest\")\n// output：[,,8,0,0,0,6,3,3,3]\n\n\nmpercentileTopN(x, s, percent=15, window=6, top=3, interpolation=\"midpoint\")\n// output：[,,8,4,4,0,6,4.5,4,4]\n\n\nmpercentileTopN(x, s, percent=50, window=6, top=3, interpolation=\"linear\")\n// output：[,,8,4,4,0,6,4.5,5,5]\n\nX = [2.0, , 8.0, 0.0, 4.0, , 6.0, 3.0, 5.0, 7.0]\nS = [, 1, 8, 7, 9, 2, 1, 0, 1, 1]\nmpercentileTopN(X, S, percent=25, window=6, top=3, ascending=true, \n  interpolation=\"lower\", tiesMethod=\"oldest\");\n// output: [, , 8.0, 0.0, 0.0, 0.0, 6.0, 3.0, 3.0, 3.0]\n```\n\n下图以 mpercentileTopN(x, s, percent=50, window=6, top=3, interpolation=\"midpoint\"); 为例，展示函数的计算过程。\n\n其中用蓝框包围的部分为从当前滑动窗口中选取的 *S* 的元素，虚线框上方为 *top* 选出的数据，红色箭头表示计算出的结果值。\n\n![](https://docs.dolphindb.cn/zh/images/mpercentiletopn.png)\n\n```\nx = [8,,1,6,9,2,0,,5,3,2,,8,0,4,,6,3,5,7]$10:2\ns = [,1,8,7,9,6,5,0,4,3]\nmpercentileTopN(x, s, percent=15, window=6, top=3, interpolation=\"midpoint\")\n```\n\n结果为：\n\n<table id=\"table_xkt_ql5_x1c\"><tbody><tr><td>\n\n**#0**\n\n</td><td>\n\n**#1**\n\n</td></tr><tr><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n8\n\n</td></tr><tr><td>\n\n3.5\n\n</td><td>\n\n4\n\n</td></tr><tr><td>\n\n3.5\n\n</td><td>\n\n4\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\n0\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n6\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n4.5\n\n</td></tr><tr><td>\n\n2.5\n\n</td><td>\n\n4\n\n</td></tr><tr><td>\n\n4\n\n</td><td>\n\n4\n\n</td></tr></tbody>\n</table>\n"
    },
    "mprod": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mprod.html",
        "signatures": [
            {
                "full": "mprod(X, window, [minPeriods])",
                "name": "mprod",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mprod](https://docs.dolphindb.cn/zh/funcs/m/mprod.html)\n\n\n\n#### 语法\n\nmprod(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 元素的乘积。\n\n#### 例子\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmprod(X, 3);\n// output\n[,,6,21,126,210,120]\n\nmprod(Y, 3);\n// output\n[,,6,3,18,30,120]\n\nmprod(Y, 3, minPeriods=1);\n// output\n[2,2,6,3,18,30,120]\n```\n\n```\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmprod(m, 3d)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.04.07 | 1    | 9    |\n| 2020.04.08 | 1    | 9    |\n| 2020.04.09 | 4    | 9    |\n| 2020.04.10 | 4    | 10   |\n| 2020.04.11 | 32   | 10   |\n| 2020.04.12 | 48   | 20   |\n\n```\nmprod(m, 1w)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.04.07 | 1    | 9    |\n| 2020.04.08 | 1    | 9    |\n| 2020.04.09 | 4    | 9    |\n| 2020.04.10 | 4    | 90   |\n| 2020.04.11 | 32   | 90   |\n| 2020.04.12 | 192  | 180  |\n\n相关函数：[prod](https://docs.dolphindb.cn/zh/funcs/p/prod.html)\n"
    },
    "mr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mr.html",
        "signatures": [
            {
                "full": "mr(ds, mapFunc, [reduceFunc], [finalFunc], [parallel=true])",
                "name": "mr",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "mapFunc",
                        "name": "mapFunc"
                    },
                    {
                        "full": "[reduceFunc]",
                        "name": "reduceFunc",
                        "optional": true
                    },
                    {
                        "full": "[finalFunc]",
                        "name": "finalFunc",
                        "optional": true
                    },
                    {
                        "full": "[parallel=true]",
                        "name": "parallel",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [mr](https://docs.dolphindb.cn/zh/funcs/m/mr.html)\n\n\n\n#### 语法\n\nmr(ds, mapFunc, \\[reduceFunc], \\[finalFunc], \\[parallel=true])\n\n#### 参数\n\n**ds** 数据源列表。该参数必选，且必须是元组，元组的每个元素都是数据源对象。即使只有一个数据源，我们仍然需要一个元组来包装数据源。\n\n**mapFunc** map 函数。它只接受一个参数，即相应数据源的物化数据实体。如果希望 map 函数接受除了物化数据源之外更多的参数，可以使用 [部分应用](https://docs.dolphindb.cn/zh/progr/partial_app.html) 将多参数函数转换为一个参数的函数。map 函数调用的次数是数据源的数量。map 函数返回一个常规对象（标量，对，数组，矩阵，表，集合或字典）或一个元组（包含多个常规对象）。\n\n**reduceFunc** 二元 reduce 函数组合了两个 map 函数调用结果。在大多数情况下，reduce 函数是不重要的。一个例子是加法函数，reduce 函数是可选的。如果没有指定 reduce 函数，则系统将所有单独的 map 调用结果返回到最终函数。\n\n**finalFunc** final 函数，只接受一个参数。该函数的输入是最后一个 reduce 函数的输出。如果未指定，系统将返回所有 map 函数调用结果。\n\n**parallel** 指示是否在本地并行执行 map 函数的可选布尔标志。默认值为 true，即启用并行计算。当可用内存有限和每个 map 调用需要大量的内存时，我们可以禁用并行计算以防止内存不足问题。我们也可能要禁用并行选项以确保线程安全。例如，如果多个线程同时写入同一个文件，则可能会发生错误。\n\n#### 详情\n\nMap-Reduce 函数是 DolphinDB 通用分布式计算框架的核心功能。\n\n#### 例子\n\n以下是分布式线性回归的示例。X 是自变量的矩阵，y 是因变量。X 和 y 存储在多个数据源中。为了估计最小二乘参数，我们需要计算 X T X 和 X T y 。我们可以从每个数据源计算 (X T X, X T y) 的元组，然后将所有数据源的结果相加，以获得整个数据集的 X T X 和 X \\<sup>T\\</sup> y。\n\n```\ndef myOLSMap(table, yColName, xColNames, intercept){\n  if(intercept)\n      x = matrix(take(1.0, table.rows()), table[xColNames])\n  else\n      x = matrix(table[xColNames])\n  xt = x.transpose();\n  return xt.dot(x), xt.dot(table[yColName])\n}\n\ndef myOLSFinal(result){\n  xtx = result[0]\n  xty = result[1]\n  return xtx.inv().dot(xty)[0]\n}\n\ndef myOLSEx(ds, yColName, xColNames, intercept){\n  return mr(ds, myOLSMap{, yColName, xColNames, intercept}, +, myOLSFinal)\n}\n```\n\n在上面的例子中，我们定义了 map 函数和 final 函数。实践中，我们也可为数据源定义转换函数。这些功能仅需在本地实例中定义，用户不需要编译它们或将其部署到远程实例。DolphinDB 的分布式计算框架可以为最终用户快速处理这些复杂的问题。\n\n作为经常使用的分析工具，分布式最小二乘线性回归已经在我们的核心库中实现。内置版本([olsEx](https://docs.dolphindb.cn/zh/funcs/o/olsEx.html))提供更多功能。\n"
    },
    "mrank": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mrank.html",
        "signatures": [
            {
                "full": "mrank(X, ascending, window, [ignoreNA=true], [tiesMethod='min'], [percent=false], [minPeriods])",
                "name": "mrank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "ascending",
                        "name": "ascending"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='min']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'min'"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mrank](https://docs.dolphindb.cn/zh/funcs/m/mrank.html)\n\n\n\n#### 语法\n\nmrank(X, ascending, window, \\[ignoreNA=true], \\[tiesMethod='min'], \\[percent=false], \\[minPeriods])\n\n部分通用参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 参数\n\n**ascending** 是一个布尔值，表示是否按升序排序。默认值是 true。\n\n**ignoreNA** 是一个布尔值，表示是否忽略 NULL 值。true 表示忽略 NULL 值（默认值），false 表示 NULL 值参与排名，此时 NULL 值为最小值。\n\n**tiesMethod** 是一个字符串，表示窗口内若存在重复值时，排名如何选取。'min' 表示取最小排名，'max' 表示取最大排名，'average' 表示取排名的均值。\n\n**percent** 是一个布尔值，表示是否以百分比形式显示返回的排名，默认值为 false。\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 元素在其对应窗口内的排名。\n\n#### 例子\n\n```\nX = 3 2 4 4 4 NULL 1\n\nmrank(X, ascending=false, window=3, ignoreNA=true);\n// output: [,,0,0,0,,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=true, minPeriods=2);\n// output: [,1,0,0,0,,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='max');\n// output: [,,0,1,2,2,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='max', minPeriods=2);\n// output: [,1,0,1,2,2,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='min');\n// output: [,,0,0,0,2,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='min', minPeriods=3);\n// output: [,,0,0,0,,]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='average');\n// output: [,,0,0.5,1,2,1]\n\nmrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='average', minPeriods=2);\n// output: [,1,0,0.5,1,2,1]\n```\n\n```\nm=matrix(1 2 5 3 4, 5 4 1 2 3);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 2  | 4  |\n| 5  | 1  |\n| 3  | 2  |\n| 4  | 3  |\n\n```\nmrank(m, true, 3);\n```\n\n| #0 | #1 |\n| -- | -- |\n|    |    |\n|    |    |\n| 2  | 0  |\n| 1  | 1  |\n| 1  | 2  |\n\n```\nmrank(m, true, 3, percent=true);\n```\n\n| col1   | col2   |\n| ------ | ------ |\n|        |        |\n|        |        |\n| 1      | 0.3333 |\n| 0.6667 | 0.6667 |\n| 0.6667 | 1      |\n\n```\nm=matrix([1 4 2 4 5 7 4 3 2 5])\nm.rename!(2020.01.01..2020.01.10, [`A])\nm.setIndexedMatrix!()\nmrank(m,window=3d,percent = 1)\n```\n\n| label      | A      |\n| ---------- | ------ |\n| 2020.01.01 | 1      |\n| 2020.01.02 | 1      |\n| 2020.01.03 | 0.6667 |\n| 2020.01.04 | 0.6667 |\n| 2020.01.05 | 1      |\n| 2020.01.06 | 1      |\n| 2020.01.07 | 0.3333 |\n| 2020.01.08 | 0.3333 |\n| 2020.01.09 | 0.3333 |\n| 2020.01.10 | 1      |\n\n```\nmrank(m, window=1w, percent = 1)\n```\n\n| label      | A      |\n| ---------- | ------ |\n| 2020.01.01 | 1      |\n| 2020.01.02 | 1      |\n| 2020.01.03 | 0.6667 |\n| 2020.01.04 | 0.75   |\n| 2020.01.05 | 1      |\n| 2020.01.06 | 1      |\n| 2020.01.07 | 0.4286 |\n| 2020.01.08 | 0.2857 |\n| 2020.01.09 | 0.1429 |\n| 2020.01.10 | 0.7143 |\n\n相关函数：[rank](https://docs.dolphindb.cn/zh/funcs/r/rank.html)\n"
    },
    "mskew": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mskew.html",
        "signatures": [
            {
                "full": "mskew(X, window, [biased=true], [minPeriods])",
                "name": "mskew",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mskew](https://docs.dolphindb.cn/zh/funcs/m/mskew.html)\n\n\n\n#### 语法\n\nmskew(X, window, \\[biased=true], \\[minPeriods])\n\n部分通用参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否是有偏估计。默认值为 true，表示有偏估计。\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 的斜度。\n\n#### 例子\n\n```\nmskew(1 2 3 10 100 4 3, 3);\n// output\n[,,0,0.665469,0.693810, 0.697217,0.706851]\n```\n\n```\nm=matrix(1 6 2 9 4 5 100, 100 11 12 18 23 21 10);\nm;\n```\n\n| #0  | #1  |\n| --- | --- |\n| 1   | 100 |\n| 6   | 11  |\n| 2   | 12  |\n| 9   | 18  |\n| 4   | 23  |\n| 5   | 21  |\n| 100 | 10  |\n\n```\nmskew(m,3);\n```\n\n| #0                 | #1                 |\n| ------------------ | ------------------ |\n|                    |                    |\n|                    |                    |\n| 0.595170064139498  | 0.706802122668126  |\n| -0.172800544078651 | 0.65201211704403   |\n| 0.470330460336986  | -0.110780117654834 |\n| 0.595170064139498  | -0.239063146929565 |\n| 0.706845142811354  | -0.642723256123865 |\n\n```\nm.rename!(date(2020.04.06)+1..7, `col1`col2)\nm.setIndexedMatrix!()\nmskew(m, 3d)\n```\n\n| label      | col1    | col2    |\n| ---------- | ------- | ------- |\n| 2020.04.07 |         |         |\n| 2020.04.08 | 0       | 0       |\n| 2020.04.09 | 0.5952  | 0.7068  |\n| 2020.04.10 | -0.1728 | 0.652   |\n| 2020.04.11 | 0.4703  | -0.1108 |\n| 2020.04.12 | 0.5952  | -0.2391 |\n| 2020.04.13 | 0.7068  | -0.6427 |\n\n```\nmskew(m, 1w)\n```\n\n| label      | col1   | col2   |\n| ---------- | ------ | ------ |\n| 2020.04.07 |        |        |\n| 2020.04.08 | 0      | 0      |\n| 2020.04.09 | 0.5952 | 0.7068 |\n| 2020.04.10 | 0.2743 | 1.1373 |\n| 2020.04.11 | 0.4079 | 1.4398 |\n| 2020.04.12 | 0.3298 | 1.7107 |\n| 2020.04.13 | 2.0188 | 1.9363 |\n\n相关函数：[skew](https://docs.dolphindb.cn/zh/funcs/s/skew.html)\n"
    },
    "mskewTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mskewTopN.html",
        "signatures": [
            {
                "full": "mskewTopN(X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "mskewTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [mskewTopN](https://docs.dolphindb.cn/zh/funcs/m/mskewTopN.html)\n\n\n\n#### 语法\n\nmskewTopN(X, S, window, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否是有偏估计。默认值为 true，表示有偏估计。\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素计算斜度。\n\n返回值：DOUBLE 类型。\n\n#### 例子\n\n```\nX=1 2 3 10 100 4 3\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmskewTopN(X, S, 6, 4)\n// output\n[,0,0,1.01,1.13,0.79,1.08]\n\nX = matrix(1..10, 11..20)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\nmskewTopN(X, S, 6, 4)\n```\n\n| col1    | col2    |\n| :------ | :------ |\n|         |         |\n| 0       |         |\n| 0       | 0       |\n| 0       | 0       |\n| 0.4347  | 0       |\n| -0.278  | 0.4347  |\n| -0.4347 | 0       |\n| 0       | -0.6872 |\n| 0       | 0       |\n| 0       | 0.4347  |\n\n```\nsymbol = [\"A\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"B\",\"B\",\"A\",\"B\",\"A\",\"B\",\"B\",\"A\",\"B\",\"A\"]\ntime = temporalAdd(2023.07.03T09:30:00.000,[10,20,40,60,70,80,90,140,160,170,180,190,200,210,220,230,250,360,390,400],\"ms\")\nprice = [28.11,28.25,28.44,52.31,28.98,28.89,52.22,28.16,28.52,52.62,52.56,52.2,28.01,52.43,28.57,52.42,52.19,28.16,52.84,28.18]\nqty = [1900,3300,100,3000,3500,800,3400,4400,3900,4600,2200,2100,2300,4100,400,300,3100,2500,1000,2700]\nBSFlag = [1,0,1,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1]\nt = table(time, symbol, price, qty, BSFlag)\nselect time,symbol,BSFlag,mskewTopN(price, qty, 8, 5) as mskewTop5Price from t context by symbol,BSFlag\n```\n\n| time                    | symbol | BSFlag | mskewTop5Price |\n| ----------------------- | ------ | ------ | -------------- |\n| 2023.07.03T09:30:00.020 | A      | 0      |                |\n| 2023.07.03T09:30:00.070 | A      | 0      | 0              |\n| 2023.07.03T09:30:00.080 | A      | 0      | -0.6667        |\n| 2023.07.03T09:30:00.140 | A      | 0      | 0              |\n| 2023.07.03T09:30:00.160 | A      | 0      | 0.0904         |\n| 2023.07.03T09:30:00.200 | A      | 0      | -0.0986        |\n| 2023.07.03T09:30:00.220 | A      | 0      | -0.1794        |\n| 2023.07.03T09:30:00.010 | A      | 1      |                |\n| 2023.07.03T09:30:00.040 | A      | 1      | 0              |\n| 2023.07.03T09:30:00.360 | A      | 1      | 0.6448         |\n| 2023.07.03T09:30:00.400 | A      | 1      | 1.0153         |\n| 2023.07.03T09:30:00.170 | B      | 0      |                |\n| 2023.07.03T09:30:00.180 | B      | 0      | 0              |\n| 2023.07.03T09:30:00.230 | B      | 0      | -0.4451        |\n| 2023.07.03T09:30:00.060 | B      | 1      |                |\n| 2023.07.03T09:30:00.090 | B      | 1      | 0              |\n| 2023.07.03T09:30:00.190 | B      | 1      | 0.6156         |\n| 2023.07.03T09:30:00.210 | B      | 1      | 0.5605         |\n| 2023.07.03T09:30:00.250 | B      | 1      | 0.8565         |\n| 2023.07.03T09:30:00.390 | B      | 1      | 1.3966         |\n\n相关函数：[mskew](https://docs.dolphindb.cn/zh/funcs/m/mskew.html)\n"
    },
    "mslr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mslr.html",
        "signatures": [
            {
                "full": "mslr(Y, X, window, [minPeriods])",
                "name": "mslr",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mslr](https://docs.dolphindb.cn/zh/funcs/m/mslr.html)\n\n\n\n#### 语法\n\nmslr(Y, X, window, \\[minPeriods])\n\n#### 参数\n\n**Y** 是一个向量，表示因变量。\n\n**X** 是一个向量，表示自变量。\n\n**window** 是一个正整数，表示滑动窗口的长度。\n\n**minPeriods** 是一个正整数。如果一个滑动窗口中的非 NULL 值的数量小于 *minPeriods*，那么该窗口的结果为NULL。\n\n#### 详情\n\n在长度为 *window* 的滑动窗口中，将因变量 *Y* 与自变量 *X* 进行普通最小二乘回归。返回一个元组，其中第一个元素为截距，第二个元素为斜率。\n\n* 如果没有指定 *minPeriods*，结果的前 (*window* - 1) 个元素为NULL；\n* 如果指定了 *minPeriods*，结果的前 (*minPeriods* - 1) 个元素为NULL。\n\n#### 例子\n\n```\nY=1 4 3 9 5 4\nX=12 31 29 88 67 76\nmslr(Y,X,4);\n\n//output: ([,,,0.177052,0.712557,0.15],[,,,0.101824,0.084418,0.078462])\n```\n"
    },
    "mstd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mstd.html",
        "signatures": [
            {
                "full": "mstd(X, window, [minPeriods])",
                "name": "mstd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mstd](https://docs.dolphindb.cn/zh/funcs/m/mstd.html)\n\n\n\n#### 语法\n\nmstd(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 的样本标准差。\n\n#### 例子\n\n```\nmstd(1 2 5 4 3, 3);\n// output: \n[,,2.081666,1.527525,1]\n\nmstd(1 2 5 4 3, 3, 2);\n// output: \n[,0.707107,2.081666,1.527525,1]\n```\n\n```\nm=matrix(1 6 2 9 4 5, 11 12 18 23 21 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 11 |\n| 6  | 12 |\n| 2  | 18 |\n| 9  | 23 |\n| 4  | 21 |\n| 5  | 10 |\n\n```\nmstd(m,3);\n```\n\n<table id=\"table_sng_5hn_ryb\"><thead><tr><th align=\"left\">\n\n\\#0\n\n</th><th align=\"left\">\n\n\\#1\n\n</th></tr></thead><tbody><tr><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td></tr><tr><td align=\"left\">\n\n</td><td align=\"left\">\n\n</td></tr><tr><td align=\"left\">\n\n2.645751311064591\n\n</td><td align=\"left\">\n\n3.78593889720018\n\n</td></tr><tr><td align=\"left\">\n\n3.511884584284247\n\n</td><td align=\"left\">\n\n5.507570547286101\n\n</td></tr><tr><td align=\"left\">\n\n3.605551275463989\n\n</td><td align=\"left\">\n\n2.516611478423591\n\n</td></tr><tr><td align=\"left\">\n\n2.645751311064591\n\n</td><td align=\"left\">\n\n7\n\n</td></tr></tbody>\n</table>```\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmstd(m,4d)\n```\n\n| label      | col1   | col2   |\n| ---------- | ------ | ------ |\n| 2020.04.07 |        |        |\n| 2020.04.08 |        |        |\n| 2020.04.09 | 2.1213 |        |\n| 2020.04.10 | 2.1213 | 0.7071 |\n| 2020.04.11 | 2.8284 |        |\n| 2020.04.12 | 2      | 5.6569 |\n\n```\nmstd(m,1w)\n```\n\n| label      | col1   | col2   |\n| ---------- | ------ | ------ |\n| 2020.04.07 |        |        |\n| 2020.04.08 |        |        |\n| 2020.04.09 | 2.1213 |        |\n| 2020.04.10 | 2.1213 | 0.7071 |\n| 2020.04.11 | 3.5119 | 0.7071 |\n| 2020.04.12 | 2.9861 | 4.3589 |\n\n相关函数：[mmin](https://docs.dolphindb.cn/zh/funcs/m/mmin.html), [mmax](https://docs.dolphindb.cn/zh/funcs/m/mmax.html), [mavg](https://docs.dolphindb.cn/zh/funcs/m/mavg.html), [msum](https://docs.dolphindb.cn/zh/funcs/m/msum.html), [mvar](https://docs.dolphindb.cn/zh/funcs/m/mvar.html)\n"
    },
    "mstdp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mstdp.html",
        "signatures": [
            {
                "full": "mstdp(X, window, [minPeriods])",
                "name": "mstdp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mstdp](https://docs.dolphindb.cn/zh/funcs/m/mstdp.html)\n\n\n\n#### 语法\n\nmstdp(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 的总体标准差。\n\n#### 例子\n\n```\nmstdp(1 2 5 4 3, 3);\n// output\n[,,1.699673171197595,1.247219128924647,0.816496580927726]\n\nmstdp(1 2 5 4 3, 3, 2);\n// output\n[,0.5,1.699673171197595,1.247219128924647,0.816496580927726]\n\nm=matrix(1 6 2 9 4 5, 11 12 18 23 21 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 11 |\n| 6  | 12 |\n| 2  | 18 |\n| 9  | 23 |\n| 4  | 21 |\n| 5  | 10 |\n\n```\nmstdp(m,3);\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n|                   |                   |\n| 2.160246899469287 | 3.091206165165233 |\n| 2.867441755680875 | 4.496912521077346 |\n| 2.943920288775949 | 2.054804667656331 |\n| 2.160246899469287 | 5.715476066494082 |\n\n```\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmstdp(m,4d)\n```\n\n| label      | col1  | col2 |\n| ---------- | ----- | ---- |\n| 2020.04.07 | 0     | 0    |\n| 2020.04.08 | 0     | 0    |\n| 2020.04.09 | 1.5   | 0    |\n| 2020.04.10 | 1.5   | 0.5  |\n| 2020.04.11 | 2     | 0    |\n| 2020.04.12 | 1.633 | 4    |\n\n```\nmstdp(m,1w)\n```\n\n| label      | col1   | col2  |\n| ---------- | ------ | ----- |\n| 2020.04.07 | 0      | 0     |\n| 2020.04.08 | 0      | 0     |\n| 2020.04.09 | 1.5    | 0     |\n| 2020.04.10 | 1.5    | 0.5   |\n| 2020.04.11 | 2.8674 | 0.5   |\n| 2020.04.12 | 2.586  | 3.559 |\n\n相关函数：[mstd](https://docs.dolphindb.cn/zh/funcs/m/mstd.html)\n"
    },
    "mstdpTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mstdpTopN.html",
        "signatures": [
            {
                "full": "mstdpTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mstdpTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mstdpTopN](https://docs.dolphindb.cn/zh/funcs/m/mstdpTopN.html)\n\n\n\n#### 语法\n\nmstdpTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素计算总体标准差。\n\n#### 例子\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmstdpTopN(X, S, 4, 2)\n// output\n[0,0.5,1,0.5,0.5,0.5,1]\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmstdpTopN(X, S, 4, 2)\n// output\n[,0,0,0.5,0.5,0.5,0]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmstdpTopN(X, S, 3, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n| 0   | 0   |\n| 0.5 | 0.5 |\n| 1   | 1   |\n| 0.5 | 0.5 |\n| 1   | 1   |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmstdpTopN(X, S, 3, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n| 0   |     |\n| 0.5 | 0   |\n| 1   | 0.5 |\n| 0.5 | 0.5 |\n| 1   | 0.5 |\n\n相关函数：[mstdp](https://docs.dolphindb.cn/zh/funcs/m/mstdp.html)\n"
    },
    "mstdTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mstdTopN.html",
        "signatures": [
            {
                "full": "mstdTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mstdTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mstdTopN](https://docs.dolphindb.cn/zh/funcs/m/mstdTopN.html)\n\n\n\n#### 语法\n\nmstdTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素计算样本标准差。\n\n#### 例子\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmstdTopN(X, S, 4, 2)\n// output\n[,0.707106781186548,1.414213562373095,0.707106781186548,0.707106781186548,0.707106781186548,1.414213562373095]\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmstdTopN(X, S, 4, 2)\n// output\n[,,,0.707106781186548,0.707106781186548,0.707106781186548,]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmstdTopN(X, S, 3, 2)\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n| 0.707106781186548 | 0.707106781186548 |\n| 1.414213562373095 | 1.414213562373095 |\n| 0.707106781186548 | 0.707106781186548 |\n| 1.414213562373095 | 1.414213562373095 |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmstdTopN(X, S, 3, 2)\n```\n\n| #0     | #1     |\n| ------ | ------ |\n|        |        |\n| 0.7071 |        |\n| 1.4142 | 0.7071 |\n| 0.7071 | 0.7071 |\n| 1.4142 | 0.7071 |\n\n相关函数：[mstd](https://docs.dolphindb.cn/zh/funcs/m/mstd.html)\n"
    },
    "msum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/msum.html",
        "signatures": [
            {
                "full": "msum(X, window, [minPeriods])",
                "name": "msum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [msum](https://docs.dolphindb.cn/zh/funcs/m/msum.html)\n\n\n\n#### 语法\n\nmsum(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 的元素和。\n\n#### 例子\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmsum(X, 3);\n// output\n[,,6,11,16,18,15]\n\nmsum(Y, 3);\n// output\n[,,6,4,9,11,15]\n\nmsum(Y, 3, minPeriods=1);\n// output\n[2,3,6,4,9,11,15]\n```\n\n```\nm = matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmsum(m, 3d) // 等价于 msum(m, 3)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.04.07 | 1    | 9    |\n| 2020.04.08 | 1    | 9    |\n| 2020.04.09 | 5    | 9    |\n| 2020.04.10 | 4    | 10   |\n| 2020.04.11 | 12   | 10   |\n| 2020.04.12 | 14   | 12   |\n\n```\nmsum(m, 1w)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.04.07 | 1    | 9    |\n| 2020.04.08 | 1    | 9    |\n| 2020.04.09 | 5    | 9    |\n| 2020.04.10 | 5    | 19   |\n| 2020.04.11 | 13   | 19   |\n| 2020.04.12 | 19   | 21   |\n\n相关函数：[sum](https://docs.dolphindb.cn/zh/funcs/s/sum.html)\n"
    },
    "msum2": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/msum2.html",
        "signatures": [
            {
                "full": "msum2(X, window, [minPeriods])",
                "name": "msum2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [msum2](https://docs.dolphindb.cn/zh/funcs/m/msum2.html)\n\n\n\n#### 语法\n\nmsum2(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 元素的平方和。请注意，该函数的返回值是 DOUBLE 类型。\n\n#### 例子\n\n```\nX = 2 1 3 7 6 5 4\nY = 2 1 3 NULL 6 5 4\n\nmsum2(X, 3)\n// output\n[,,14,59,94,110,77]\n\nmsum2(Y, 3)\n// output\n[,,14,10,45,61,77]\n\nmsum2(Y, 3, minPeriods=1)\n// output\n[4,5,14,10,45,61,77]\n\nm = matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2021.08.16)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmsum2(m, 3d)  // 等价于 msum2(m, 3)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2021.08.17 | 1    | 81   |\n| 2021.08.18 | 1    | 81   |\n| 2021.08.19 | 17   | 81   |\n| 2021.08.20 | 16   | 100  |\n| 2021.08.21 | 80   | 100  |\n| 2021.08.22 | 100  | 104  |\n\n相关函数：[sum2](https://docs.dolphindb.cn/zh/funcs/s/sum2.html)\n"
    },
    "msumTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/msumTopN.html",
        "signatures": [
            {
                "full": "msumTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "msumTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [msumTopN](https://docs.dolphindb.cn/zh/funcs/m/msumTopN.html)\n\n\n\n#### 语法\n\nmsumTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素进行求和计算。\n\n#### 例子\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmsumTopN(X, S, 4, 2)\n// output\n[1,3,4,7,7,7,10]\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmsumTopN(X, S, 4, 2)\n// output\n[,1,2,5,5,5,3]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmsumTopN(X, S, 3, 2)\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 6  |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n| 8  | 18 |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmsumTopN(X, S, 3, 2)\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n| 3  | 7  |\n| 4  | 15 |\n| 5  | 15 |\n| 8  | 17 |\n\n某行情数据的数据表，包含四列：股票代码 code，交易日期 date，收盘价 close 和交易量 volume。\n\n```\nt = table(take(`IBM`APPL, 20) as code, 2020.01.01 + 1..20 as date, rand(100,20) + 20 as volume, rand(10,20) + 100.0 as close)\n```\n\n| code | date       | volume | close |\n| ---- | ---------- | ------ | ----- |\n| IBM  | 2020.01.02 | 50     | 107   |\n| APPL | 2020.01.03 | 55     | 100   |\n| IBM  | 2020.01.04 | 75     | 100   |\n| APPL | 2020.01.05 | 84     | 108   |\n| IBM  | 2020.01.06 | 46     | 103   |\n| APPL | 2020.01.07 | 100    | 101   |\n| IBM  | 2020.01.08 | 96     | 100   |\n| APPL | 2020.01.09 | 84     | 102   |\n| IBM  | 2020.01.10 | 60     | 107   |\n| APPL | 2020.01.11 | 40     | 103   |\n| IBM  | 2020.01.12 | 92     | 105   |\n| APPL | 2020.01.13 | 61     | 106   |\n| IBM  | 2020.01.14 | 86     | 107   |\n| APPL | 2020.01.15 | 41     | 102   |\n| IBM  | 2020.01.16 | 85     | 103   |\n| APPL | 2020.01.17 | 72     | 105   |\n| IBM  | 2020.01.18 | 46     | 108   |\n| APPL | 2020.01.19 | 25     | 100   |\n| IBM  | 2020.01.20 | 114    | 102   |\n| APPL | 2020.01.21 | 50     | 104   |\n\n对每只股票计算窗口期内交易量最大的3条记录的收盘价之和。\n\n```\nselect code, date, msumTopN(close, volume, 5, 3, false) from t context by code\n```\n\n| code | date       | msumTopN\\_close |\n| ---- | ---------- | --------------- |\n| APPL | 2020.01.03 | 100             |\n| APPL | 2020.01.05 | 208             |\n| APPL | 2020.01.07 | 309             |\n| APPL | 2020.01.09 | 311             |\n| APPL | 2020.01.11 | 311             |\n| APPL | 2020.01.13 | 311             |\n| APPL | 2020.01.15 | 309             |\n| APPL | 2020.01.17 | 313             |\n| APPL | 2020.01.19 | 313             |\n| APPL | 2020.01.21 | 315             |\n| IBM  | 2020.01.02 | 107             |\n| IBM  | 2020.01.04 | 207             |\n| IBM  | 2020.01.06 | 310             |\n| IBM  | 2020.01.08 | 307             |\n| IBM  | 2020.01.10 | 307             |\n| IBM  | 2020.01.12 | 305             |\n| IBM  | 2020.01.14 | 312             |\n| IBM  | 2020.01.16 | 312             |\n| IBM  | 2020.01.18 | 315             |\n| IBM  | 2020.01.20 | 314             |\n\n相关函数：[msum](https://docs.dolphindb.cn/zh/funcs/m/msum.html)\n"
    },
    "mTopRange": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mtoprange.html",
        "signatures": [
            {
                "full": "mTopRange(X, window, [minPeriods])",
                "name": "mTopRange",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mTopRange](https://docs.dolphindb.cn/zh/funcs/m/mtoprange.html)\n\n#### 语法\n\nmTopRange(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内，统计每个元素 Xi 左侧相邻且连续小于它的元素个数。NULL 被视为最小值。\n\n若 *X* 是矩阵，在每列内进行上述计算。\n\n#### 例子\n\n```\nx = [NULL, 3.1, NULL, 3.0, 2.9, 2.8, 3.1, NULL, 3.2]\nmTopRange(x, window=3)\n// output: [,,0,1,0,0,2,0,2]\n\nmTopRange(x, window=3, minPeriods=1)\n// output: [,1,0,1,0,0,2,0,2]\n\nx = [NULL, NULL, NULL, NULL, NULL, 2, NULL, NULL, 3.2]\ndate = [0, 1, 2, 3, 7, 8, 9, 10, 11] + 2020.01.01\nX = indexedSeries(date, x) \nmTopRange(X, 3d)\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2020.01.01 |    |\n| 2020.01.02 |    |\n| 2020.01.03 |    |\n| 2020.01.04 |    |\n| 2020.01.08 |    |\n| 2020.01.09 | 1  |\n| 2020.01.10 | 0  |\n| 2020.01.11 | 0  |\n| 2020.01.12 | 2  |\n\n```\nm = matrix(1 2 3 NULL, 1 2 NULL 3, 1 3 NULL NULL, 1 2 3 4)\nmTopRange(m, 2)\n```\n\n| #0 | #1 | #2 | #3 |\n| -- | -- | -- | -- |\n|    |    |    |    |\n| 1  | 1  | 1  | 1  |\n| 1  | 0  | 0  | 1  |\n| 0  | 1  |    | 1  |\n\n"
    },
    "mul": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mul.html",
        "signatures": [
            {
                "full": "mul(X, Y)",
                "name": "mul",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [mul](https://docs.dolphindb.cn/zh/funcs/m/mul.html)\n\n\n\n#### 语法\n\nmul(X, Y) 或 X\\*Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量或矩阵。如果 *X* 和 *Y* 的其中一个是数据对、向量或矩阵，另一个必须是标量或具有相同长度或维度的数据对、向量或矩阵。\n\n#### 详情\n\n逐个元素地返回 *X* 和 *Y* 的乘积。\n\n#### 例子\n\n```\n1:2*3;\n// output\n3 : 6\n\n1:2*3:4;\n// output\n3 : 8\n\nx=1 2 3;\nx * 2;\n// output\n[2,4,6]\n\ny=4 5 6;\nx * y;\n// output\n[4,10,18]\n```\n\n```\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1*2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 2  | 6  | 10 |\n| 4  | 8  | 12 |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1*m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 12 | 10 |\n| 10 | 12 | 6  |\n"
    },
    "multinomialNB": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/multinomialNB.html",
        "signatures": [
            {
                "full": "multinomialNB(Y, X, [varSmoothing=1.0])",
                "name": "multinomialNB",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[varSmoothing=1.0]",
                        "name": "varSmoothing",
                        "optional": true,
                        "default": "1.0"
                    }
                ]
            }
        ],
        "markdown": "### [multinomialNB](https://docs.dolphindb.cn/zh/funcs/m/multinomialNB.html)\n\n\n\n#### 语法\n\nmultinomialNB(Y, X, \\[varSmoothing=1.0])\n\n#### 参数\n\n**Y** 是一个长度与 *X* 的行数相等的向量，表示 *X* 中每个样本对应的标签。\n\n**X** 是一个表，表示训练集。表中每一行表示一个样本，每一列表示一个特征。\n\n**varSmoothing** 是0到1之间的浮点数，表示平滑系数。\n\n#### 详情\n\n使用多项式朴素贝叶斯（Multinomial Naive Bayes）算法对数据进行分类训练。返回的结果是一个字典，包含以下key：\n\n* modelName：模型名称，为字符串 \"MultinomialNB\"\n\n* model：multinomialNB 的内部模型\n\n* varSmoothing：训练时使用的平滑系数\n\n#### 例子\n\n本例所用数据集 iris.data 可从 <https://archive.ics.uci.edu/ml/datasets/iris> 下载。\n\n```\nDATA_DIR = \"C:/DolphinDB/Data\"\nt = loadText(DATA_DIR+\"/iris.data\")\nt.rename!(`col0`col1`col2`col3`col4, `sepalLength`sepalWidth`petalLength`petalWidth`class)\nt[`classType] = take(0, t.size())\nupdate t set classType = 1 where class = \"Iris-versicolor\"\nupdate t set classType = 2 where class = \"Iris-virginica\"\n\ntraining = select sepalLength, sepalWidth, petalLength, petalWidth from t\nlabels = t.classType\n\nmodel = multinomialNB(labels, training);\n\npredict(model, training);\n```\n"
    },
    "multiTableRepartitionDS": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/multiTableRepartitionDS.html",
        "signatures": [
            {
                "full": "multiTableRepartitionDS(query, [column], [partitionType], [partitionScheme], [local=true])",
                "name": "multiTableRepartitionDS",
                "parameters": [
                    {
                        "full": "query",
                        "name": "query"
                    },
                    {
                        "full": "[column]",
                        "name": "column",
                        "optional": true
                    },
                    {
                        "full": "[partitionType]",
                        "name": "partitionType",
                        "optional": true
                    },
                    {
                        "full": "[partitionScheme]",
                        "name": "partitionScheme",
                        "optional": true
                    },
                    {
                        "full": "[local=true]",
                        "name": "local",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [multiTableRepartitionDS](https://docs.dolphindb.cn/zh/funcs/m/multiTableRepartitionDS.html)\n\n\n\n#### 语法\n\nmultiTableRepartitionDS(query, \\[column], \\[partitionType], \\[partitionScheme], \\[local=true])\n\n#### 参数\n\n**query** 是一个元组，其中每个元素都是 SQL 查询的元代码，并且每个 SQL 查询表示的数据表结构（包括列名和各列的数据类型）必须完全相同。\n\n**column** 是一个字符串，表示 *query* 中的一个列名。*repartitionDS* 函数会根据该列划分数据源。\n\n**partitionType** 表示分区类型，它的取值可以是 RANGE 或 VALUE。\n\n**partitionScheme** 是一个向量，表示分区方案。\n\n**local** 是一个布尔值，表示是否将数据源获取到当前节点进行计算。默认值为 true。\n\n#### 详情\n\n使用相同的分区类型和分区方案对多个表重新划分数据源。该函数会返回一个元组，包含一组数据源。\n\n如果没有指定 *column*, *partitionType* 和 *partitionScheme*，该函数将根据各表原来的分区类型和分区方案划分数据源。相当于 *query* 中的每个元代码应用到 [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html) 函数，再将结果合并。\n\n#### 例子\n\n```\nn=100000\ndate=rand(2019.06.01..2019.06.05,n)\nsym=rand(`AAPL`MSFT`GOOG,n)\nprice=rand(1000.0,n)\nt1=table(date,sym,price)\ndb=database(\"dfs://value\",VALUE,2019.06.01..2019.06.05)\ndb.createPartitionedTable(t1,`pt1,`date).append!(t1);\n\nn=100000\ndate=rand(2019.06.01..2019.06.05,n)\nsym=rand(`AAPL`MSFT`GOOG,n)\nprice=rand(1000.0,n)\nqty=rand(500,n)\nt2=table(date,sym,price,qty)\ndb1=database(\"\",VALUE,2019.06.01..2019.06.05)\ndb2=database(\"\",VALUE,`AAPL`MSFT`GOOG)\ndb=database(\"dfs://compo\",COMPO,[db1,db2])\ndb.createPartitionedTable(t2,`pt2,`date`sym).append!(t2);\n\npt1=loadTable(\"dfs://value\",\"pt1\")\npt2=loadTable(\"dfs://compo\",\"pt2\");\n```\n\n例1. 根据原有的分区方案划分数据源，不指定 *column*, *partitionType*和 *partitionScheme*\n\n```\nds=multiTableRepartitionDS([<select * from pt1>,<select date,sym,price from pt2>]);\n// output\n(DataSource< select [7] * from pt1 [partition = /value/20190601] >,DataSource< select [7] * from pt1 [partition = /value/20190602] >, ...... ,DataSource< select [7] date,sym,price from pt2 [partition = /compo/20190605/GOOG] >,DataSource< select [7] date,sym,price from pt2 [partition = /compo/20190605/MSFT] >)\n```\n\n例2. 根据股票代码的值划分数据源\n\n```\nds=multiTableRepartitionDS([<select * from pt1>,<select date,sym,price from pt2>],`sym,VALUE,`AAPL`MSFT`GOOG);\n// output\n(DataSource< select [4] * from pt1 where sym == \"AAPL\" >,DataSource< select [4] * from pt1 where sym == \"MSFT\" >,DataSource< select [4] * from pt1 where sym == \"GOOG\" >,DataSource< select [4] date,sym,price from pt2 where sym == \"AAPL\" >,DataSource< select [4] date,sym,price from pt2 where sym == \"MSFT\" >,DataSource< select [4] date,sym,price from pt2 where sym == \"GOOG\" >)\n```\n\n例3. 根据日期范围划分数据源\n\n```\nds=multiTableRepartitionDS([<select * from pt1>,<select date,sym,price from pt2>],`date,RANGE,2019.06.01 2019.06.03 2019.06.05);\n// output\n(DataSource< select [4] * from pt1 where date >= 2019.06.01,date < 2019.06.03 >,DataSource< select [4] * from pt1 where date >= 2019.06.03,date < 2019.06.05 >,DataSource< select [4] date,sym,price from pt2 where date >= 2019.06.01,date < 2019.06.03 >,DataSource< select [4] date,sym,price from pt2 where date >= 2019.06.03,date < 2019.06.05 >)\n```\n\n相关函数：[repartitionDS](https://docs.dolphindb.cn/zh/funcs/r/repartitionDS.html)\n"
    },
    "mutualInfo": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mutualInfo.html",
        "signatures": [
            {
                "full": "mutualInfo(X, Y)",
                "name": "mutualInfo",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [mutualInfo](https://docs.dolphindb.cn/zh/funcs/m/mutualInfo.html)\n\n\n\n#### 语法\n\nmutualInfo(X, Y)\n\n别名：infoGain\n\n#### 参数\n\n**X** 是一个标量、向量或矩阵。\n\n**Y** 是一个标量、向量或矩阵。\n\n*X* 和 *Y* 支持 Integral 和 symbol 类型。\n\n#### 详情\n\n计算 *X* 和 *Y* 的互信息。\n\nDolphinDB 使用以下公式计算互信息：\n\n![img](https://docs.dolphindb.cn/zh/images/mutualinfo.png)\n\n若 *X* 或 *Y* 是矩阵，计算每列的互信息，返回一个向量。\n\n**Note:** 该公式计算时使用自然对数，若需要 *base* 为2或者10，直接以结果除以 log 2 或 log 10 即可。\n\n#### 例子\n\n```\na = [NULL,4,NULL,NULL,-82,97,NULL,56,5,-92]\nb = [NULL,53,NULL,18,97,-4,-73,NULL,NULL,24]\nmutualInfo(a, b)\n// output\n2.302585\n\n// 计算表中两列数据的互信息\nt=table(take(1..10,10000000) as id, rand(10,10000000) as x, rand(10,10000000) as y);\nmutualInfo(t.x, t.y)\n// output\n0.000004\n\nm1 = 1..12$3:4\nm2 = 1..3\nmutualInfo(m1, m2)\n// output\n[1.0986,1.0986,1.0986,1.0986]\n```\n\n如果 *X* 是矩阵，*Y* 可以是标量、向量或者是与 *X* 行数相同的矩阵。返回结果是与 *X* 列数相同的向量。\n\n```\nm1 = 1..12$3:4\nm2 = 1..3\nmutualInfo(m1, m2)\n// output\n[1.0986,1.0986,1.0986,1.0986]\n```\n"
    },
    "mvar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mvar.html",
        "signatures": [
            {
                "full": "mvar(X, window, [minPeriods])",
                "name": "mvar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mvar](https://docs.dolphindb.cn/zh/funcs/m/mvar.html)\n\n\n\n#### 语法\n\nmvar(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 的样本方差。\n\n#### 例子\n\n```\nmvar(1..6, 5);\n// output\n[,,,,2.5,2.5]\n\nmvar(1..6, 5, 2);\n// output\n[,0.5,1,1.666667,2.5,2.5]\n```\n\n```\nm=matrix(1 6 2 9 4 5, 11 12 18 23 21 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 11 |\n| 6  | 12 |\n| 2  | 18 |\n| 9  | 23 |\n| 4  | 21 |\n| 5  | 10 |\n\n```\nmvar(m,3);\n```\n\n| #0                 | #1                 |\n| ------------------ | ------------------ |\n|                    |                    |\n|                    |                    |\n| 7                  | 14.333333333333314 |\n| 12.333333333333335 | 30.333333333333314 |\n| 13                 | 6.333333333333372  |\n| 7                  | 49                 |\n\n```\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmvar(m,4d)\n```\n\n| label      | col1 | col2 |\n| ---------- | ---- | ---- |\n| 2020.04.07 |      |      |\n| 2020.04.08 |      |      |\n| 2020.04.09 | 4.5  |      |\n| 2020.04.10 | 4.5  | 0.5  |\n| 2020.04.11 | 8    |      |\n| 2020.04.12 | 4    | 32   |\n\n```\nmvar(m,1w)\n```\n\n| label      | col1    | col2 |\n| ---------- | ------- | ---- |\n| 2020.04.07 |         |      |\n| 2020.04.08 |         |      |\n| 2020.04.09 | 4.5     |      |\n| 2020.04.10 | 4.5     | 0.5  |\n| 2020.04.11 | 12.3333 | 0.5  |\n| 2020.04.12 | 8.9167  | 19   |\n\n**Related information**\n\n[var](https://docs.dolphindb.cn/zh/funcs/v/var.html)\n"
    },
    "mvarp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mvarp.html",
        "signatures": [
            {
                "full": "mvarp(X, window, [minPeriods])",
                "name": "mvarp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mvarp](https://docs.dolphindb.cn/zh/funcs/m/mvarp.html)\n\n\n\n#### 语法\n\nmvarp(X, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内计算 *X* 的总体方差。\n\n#### 例子\n\n```\nmvarp(1..6, 5);\n// output\n[,,,,2,2]\n\nmvarp(1..6, 5, 2);\n// output\n[,0.25,0.666666666666667,1.25,2,2]\n\nm=matrix(1 6 2 9 4 5, 11 12 18 23 21 10);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 11 |\n| 6  | 12 |\n| 2  | 18 |\n| 9  | 23 |\n| 4  | 21 |\n| 5  | 10 |\n\n```\nmvarp(m,3);\n```\n\n| #0                | #1                 |\n| ----------------- | ------------------ |\n|                   |                    |\n|                   |                    |\n| 4.666666666666667 | 9.555555555555542  |\n| 8.222222222222223 | 20.22222222222221  |\n| 8.666666666666666 | 4.222222222222248  |\n| 4.666666666666667 | 32.666666666666664 |\n\n```\nm=matrix(1 NULL 4 NULL 8 6 , 9 NULL NULL 10 NULL 2)\nm.rename!(date(2020.04.06)+1..6, `col1`col2)\nm.setIndexedMatrix!()\nmvarp(m,4d)\n```\n\n| label      | col1   | col2 |\n| ---------- | ------ | ---- |\n| 2020.04.07 | 0      | 0    |\n| 2020.04.08 | 0      | 0    |\n| 2020.04.09 | 2.25   | 0    |\n| 2020.04.10 | 2.25   | 0.25 |\n| 2020.04.11 | 4      | 0    |\n| 2020.04.12 | 2.6667 | 16   |\n\n```\nmvarp(m,1w)\n```\n\n| label      | col1   | col2    |\n| ---------- | ------ | ------- |\n| 2020.04.07 | 0      | 0       |\n| 2020.04.08 | 0      | 0       |\n| 2020.04.09 | 2.25   | 0       |\n| 2020.04.10 | 2.25   | 0.25    |\n| 2020.04.11 | 8.2222 | 0.25    |\n| 2020.04.12 | 6.6875 | 12.6667 |\n\n相关函数：[varp](https://docs.dolphindb.cn/zh/funcs/v/varp.html)\n"
    },
    "mvarpTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mvarpTopN.html",
        "signatures": [
            {
                "full": "mvarpTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mvarpTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mvarpTopN](https://docs.dolphindb.cn/zh/funcs/m/mvarpTopN.html)\n\n\n\n#### 语法\n\nmvarpTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素计算总体方差。\n\n#### 例子\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmvarpTopN(X, S, 4, 2)\n// output\n[0,0.25,1,0.25,0.25,0.25,1]\n\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmvarpTopN(X, S, 4, 2)\n// output\n[,0,0,0.25,0.25,0.25,0]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmvarpTopN(X, S, 3, 2)\n```\n\n| #0   | #1   |\n| ---- | ---- |\n| 0    | 0    |\n| 0.25 | 0.25 |\n| 1    | 1    |\n| 0.25 | 0.25 |\n| 1    | 1    |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmvarpTopN(X, S, 3, 2)\n```\n\n| #0   | #1   |\n| ---- | ---- |\n| 0    |      |\n| 0.25 | 0    |\n| 1    | 0.25 |\n| 0.25 | 0.25 |\n| 1    | 0.25 |\n\n相关函数：[mvarp](https://docs.dolphindb.cn/zh/funcs/m/mvarp.html)\n"
    },
    "mvarTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mvarTopN.html",
        "signatures": [
            {
                "full": "mvarTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mvarTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mvarTopN](https://docs.dolphindb.cn/zh/funcs/m/mvarTopN.html)\n\n\n\n#### 语法\n\nmvarTopN(X, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素计算样本方差。\n\n#### 例子\n\n```\nX = 1..7\nS = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\nmvarTopN(X, S, 4, 2)\n// output\n[,0.5,2,0.5,0.5,0.5,2]\n\nX = NULL 1 2 3 4 NULL 5\nS = 3 5 1 1 5 2 4\nmvarTopN(X, S, 4, 2)\n// output\n[,,,0.5,0.5,0.5,]\n\nX = matrix(1..5, 6..10)\nS = 2022.01.01 2022.02.03 2022.01.23 2022.04.06 2021.12.29\nmvarTopN(X, S, 3, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n|     |     |\n| 0.5 | 0.5 |\n| 2   | 2   |\n| 0.5 | 0.5 |\n| 2   | 2   |\n\n```\nX = matrix(1..5, 6..10)\nS = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29,NULL 2022.02.03 2022.01.23 2022.04.06 NULL)\nmvarTopN(X, S, 3, 2)\n```\n\n| #0  | #1  |\n| --- | --- |\n|     |     |\n| 0.5 | 0.5 |\n| 2   | 2   |\n| 0.5 | 0.5 |\n| 2   | 2   |\n\n相关函数：[mvar](https://docs.dolphindb.cn/zh/funcs/m/mvar.html)\n"
    },
    "mvccTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mvccTable.html",
        "signatures": [
            {
                "full": "mvccTable(X, [X1], [X2], .....)",
                "name": "mvccTable",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "mvccTable(capacity:size, colNames, colTypes, [path], [tableName], [defaultValues], [allowNull])",
                "name": "mvccTable",
                "parameters": [
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    },
                    {
                        "full": "[path]",
                        "name": "path",
                        "optional": true
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    },
                    {
                        "full": "[defaultValues]",
                        "name": "defaultValues",
                        "optional": true
                    },
                    {
                        "full": "[allowNull]",
                        "name": "allowNull",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mvccTable](https://docs.dolphindb.cn/zh/funcs/m/mvccTable.html)\n\n\n\n#### 语法\n\nmvccTable(X, \\[X1], \\[X2], .....)\n\n或\n\nmvccTable(capacity:size, colNames, colTypes, \\[path], \\[tableName], \\[defaultValues], \\[allowNull])\n\n#### 参数\n\n对于第一种用法，**X**, **X1**, **X2** ...是向量。\n\n对于第二种用法：\n\n**capacity** 是正整数，表示表的容量，即建表时系统为该表分配的内存（以记录数为单位）。当记录数超过 *capacity* 时，系统会自动扩充容量。系统首先会分配当前容量1.2\\~2倍的内存，然后复制数据到新的内存空间，最后释放原来的内存。对于规模较大的表，扩容时的内存占用会很高。因此，建议创建内存表时预先分配一个合理的容量。\n\n**size** 是正整数，表示该表新建时的行数。若 *size*=0，创建一个空表；若 *size*>0，则新建表中记录的初始值由 *defaultValues* 决定。\n\n**colNames** 是字符串向量，表示列名。\n\n**colTypes** 是向量，表示列的数据类型。\n\n**path** 是一个字符串，表示保存表的路径。只能指定磁盘路径，不支持指定为分布式数据库路径。\n\n**tableName** 是一个字符串，表示保存到磁盘上的表名。\n\n**defaultValues** 是与 *colNames* 等长的元组，表示建表时各列的默认值。若不指定，则：\n\n* BOOL 类型默认值为 false；\n\n* 数值类型、时间类型、IPADDR、COMPLEX、POINT 的默认值为 0；\n\n* Literal, INT128 类型的默认为 NULL。\n\n**allowNull** 是与 *colNames* 等长的布尔类型向量，表示是否允许各列包含空值。默认值为 true，允许包含空值。\n\n#### 详情\n\n创建一个多版本并发控制的表（MVCC 表）。我们可以对该表进行并发读写。多版本并发控制的表适用于频繁读写但很少更新和删除记录的场景。\n\n如果指定了 *path* 和 *tableName* 参数，会把表持久化到硬盘上。通过 [loadMvccTable](https://docs.dolphindb.cn/zh/funcs/l/loadMvccTable.html) 函数，可以把磁盘上的表加载到内存中。\n\n**Note:**\n\n* 不支持对 MVCC 表进行以下操作：addColumn、reorderColumns!、upsert!、drop、erase!。\n\n* 当 *size*=0 时，即使对某列设置 *allowNull*=false，也可以成功创建空表，但不能向该列追加空值。\n\n#### 例子\n\n例1：介绍两种创建 MVCC 表的方法\n\n第一种用法：\n\n```\nid=`XOM`GS`AAPL\nx=102.1 33.4 73.6\nmvccTable(id, x);\n```\n\n| id   | x     |\n| ---- | ----- |\n| XOM  | 102.1 |\n| GS   | 33.4  |\n| AAPL | 73.6  |\n\n第二种用法：\n\n```\nmvccTable(200:10, `name`id`value, [STRING,INT,DOUBLE],\"/home/DolphinDB/Data\",\"t1\");\n```\n\n| name | id | value |\n| ---- | -- | ----- |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n\n`\"/home/DolphinDB/Data\"` 目录下会有一个名为 \"t1\" 文件夹、t1.tbl 文件和 t1.sym 文件。如果需要删除磁盘上的表，需要把这三个文件都删除。\n\n例2：创建分区 MVCC 内存表：\n\n```\nn=200000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\ntrades_mvcc1 = mvccTable(n:0, colNames, colTypes)\ntrades_mvcc2 = mvccTable(n:0, colNames, colTypes)\ndb=database(, VALUE, `A`D)\ntrades = createPartitionedTable(db,table=[trades_mvcc1, trades_mvcc2], tableName=\"\", partitionColumns=`sym)\n```\n\n在 2.00.10.4 版本之前，只支持对分区 MVCC 内存表的子表进行更新、插入和删除操作：\n\n```\ninsert into trades_mvcc1 values(09:30:00.001,`A,100,56.5)\ninsert into trades_mvcc2 values(09:30:01.001,`D,100,15.5)\n\ninsert into trades values(09:30:00.001,`D,100,26.5)\n// 报错：Can't append data to a segmented table that contains external partitions.\n\nselect * from trades;\n```\n\n| time         | sym | qty | price |\n| :----------- | :-- | :-- | :---- |\n| 09:30:00.001 | A   | 100 | 56.5  |\n| 09:30:01.001 | D   | 100 | 15.5  |\n\n2.00.10.4 版本开始支持直接对分区 MVCC 内存表进行更新、插入和删除操作：\n\n```\ninsert into trades values(09:30:00.001,`D,100,26.5)\nselect * from trades;\n```\n\n| time         | sym | qty | price |\n| :----------- | :-- | :-- | :---- |\n| 09:30:00.001 | A   | 100 | 56.5  |\n| 09:30:01.001 | D   | 100 | 15.5  |\n| 09:30:01.001 | D   | 100 | 26.5  |\n\n```\ndelete from trades where sym=`A\nselect * from trades;\n```\n\n| time         | sym | qty | price |\n| :----------- | :-- | :-- | :---- |\n| 09:30:01.001 | D   | 100 | 15.5  |\n| 09:30:01.001 | D   | 100 | 26.5  |\n\n```\nupdate trades set price=price*10 where sym=`D\nselect * from trades;\n```\n\n| time         | sym | qty | price |\n| :----------- | :-- | :-- | :---- |\n| 09:30:01.001 | D   | 100 | 155   |\n| 09:30:01.001 | D   | 100 | 265   |\n\n需要注意的是，直接向子表插入数据时，系统不会校验向子表插入的数据是否与该表匹配。如果插入了不匹配的数据，会导致分区 MVCC 内存表的数据混乱。 因此，为了确保数据的准确性，建议用户直接对分区 MVCC 内存表进行操作，而不要操作子表。\n"
    },
    "mwavg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mwavg.html",
        "signatures": [
            {
                "full": "mwavg(X, Y, window, [minPeriods])",
                "name": "mwavg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mwavg](https://docs.dolphindb.cn/zh/funcs/m/mwavg.html)\n\n\n\n#### 语法\n\nmwavg(X, Y, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内，以 *Y* 为权重（权重会自动缩放，使其元素之和为1），计算 *X* 元素的加权平均。\n\n**Note:** 与 `mavg` 以 size(*weight*) 长度的窗口进行滑动窗口计算不同，`mwavg` 的权重 *Y* 必须和 *X* 具有相同的长度。\n\n#### 例子\n\n```\nprice=2.1 2.2 2.3 2.5 2.6 2.8 2.7 2.5;\nvolume=10 20 10 40 10 40 10 20;\nmwavg(price, volume, 4);\n// output\n[,,,2.35,2.4125,2.61,2.65,2.6875]\n\nmwavg(price, volume, 4, 2);\n// output\n[,2.166667,2.2,2.35,2.4125,2.61,2.65,2.6875]\n```\n\n```\nprice1 = indexedSeries(date(2020.06.05)+1..8, price)\nvolume1 = indexedSeries(date(2020.06.05)+1..8, volume)\nmwavg(price1,volume1, 4d)\n```\n\n| label      | col1   |\n| ---------- | ------ |\n| 2020.06.06 | 2.1    |\n| 2020.06.07 | 2.1667 |\n| 2020.06.08 | 2.2    |\n| 2020.06.09 | 2.35   |\n| 2020.06.10 | 2.4125 |\n| 2020.06.11 | 2.61   |\n| 2020.06.12 | 2.65   |\n| 2020.06.13 | 2.6875 |\n\n```\nmwavg(price1,volume1, 1w)\n```\n\n| label      | col1   |\n| ---------- | ------ |\n| 2020.06.06 | 2.1    |\n| 2020.06.07 | 2.1667 |\n| 2020.06.08 | 2.2    |\n| 2020.06.09 | 2.35   |\n| 2020.06.10 | 2.3788 |\n| 2020.06.11 | 2.5077 |\n| 2020.06.12 | 2.5214 |\n| 2020.06.13 | 2.5467 |\n\n相关函数：[wavg](https://docs.dolphindb.cn/zh/funcs/w/wavg.html), [mavg](https://docs.dolphindb.cn/zh/funcs/m/mavg.html)\n"
    },
    "mwsum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mwsum.html",
        "signatures": [
            {
                "full": "mwsum(X, Y, window, [minPeriods])",
                "name": "mwsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[minPeriods]",
                        "name": "minPeriods",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [mwsum](https://docs.dolphindb.cn/zh/funcs/m/mwsum.html)\n\n\n\n#### 语法\n\nmwsum(X, Y, window, \\[minPeriods])\n\n参数说明和窗口计算规则请参考：[mFunctions](https://docs.dolphindb.cn/zh/funcs/themes/mFunctions.html)\n\n#### 详情\n\n在给定长度（以元素个数或时间长度衡量）的滑动窗口内，计算 *X* 和 *Y* 元素的内积。\n\n#### 例子\n\n```\nX = 2 1 3 7 6 5 4\nX1 = 2 1 3 NULL 6 5 4\nY = 1 0.5 1 1 2 2.1 2\n\nmwsum(X, Y, 3);\n// output\n[,,5.5,10.5,22,29.5,30.5]\n\nmwsum(X1, Y, 3)\n// output\n[,,5.5,3.5,15,22.5,30.5]\n\nmwsum(X1, Y, 3, minPeriods=1)\n// output\n[2,2.5,5.5,3.5,15,22.5,30.5]\n```\n\n```\nX = 1..10;\nY = 9 5 3 4 5 4 7 1 3 4;\nX1 = indexedSeries(date(2020.06.05)+1..10, X)\nY1 = indexedSeries(date(2020.06.05)+1..10, Y)\nmwsum(X1, Y1, 5d)\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2020.06.06 | 9    |\n| 2020.06.07 | 19   |\n| 2020.06.08 | 28   |\n| 2020.06.09 | 44   |\n| 2020.06.10 | 69   |\n| 2020.06.11 | 84   |\n| 2020.06.12 | 123  |\n| 2020.06.13 | 122  |\n| 2020.06.14 | 133  |\n| 2020.06.15 | 148  |\n\n```\nmwsum(X1, Y1, 1w)\n```\n\n| label      | col1 |\n| ---------- | ---- |\n| 2020.06.06 | 9    |\n| 2020.06.07 | 19   |\n| 2020.06.08 | 28   |\n| 2020.06.09 | 44   |\n| 2020.06.10 | 69   |\n| 2020.06.11 | 93   |\n| 2020.06.12 | 142  |\n| 2020.06.13 | 141  |\n| 2020.06.14 | 158  |\n| 2020.06.15 | 189  |\n\n相关函数：[wsum](https://docs.dolphindb.cn/zh/funcs/w/wsum.html), [msum](https://docs.dolphindb.cn/zh/funcs/m/msum.html)\n"
    },
    "mwsumTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/m/mwsumTopN.html",
        "signatures": [
            {
                "full": "mwsumTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
                "name": "mwsumTopN",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='oldest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'oldest'"
                    }
                ]
            }
        ],
        "markdown": "### [mwsumTopN](https://docs.dolphindb.cn/zh/funcs/m/mwsumTopN.html)\n\n\n\n#### 语法\n\nmwsumTopN(X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='oldest'])\n\n参数说明和窗口计算规则请参考：[mTopN](https://docs.dolphindb.cn/zh/funcs/themes/TopN.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，然后计算 *Y* 和 *X* 的内积。\n\n#### 例子\n\n```\nx = NULL 3 8 4 0 7 4\ny = 2 3 1 7 3 6 1\ns = 5 NULL 8 9 9 4 4\n\nmwsumTopN(x, y, s, 4, 3)\n// output\n[,,8,36,36,78,74]\n\ns2=2021.01.01 2021.02.03 2021.01.23 2021.04.06 2021.12.29 2021.04.16 2021.10.29\nmwsumTopN(x, y, s2, 3, 2)\n// output\n[ , 9, 8, 17, 36, 70, 46]\n\nx1 = matrix(x, 4 3 6 2 3 1 3)\ny1=matrix(3 7 9 3 2 4 6, y)\ns1=matrix(2 3 1 7 3 NULL 1, s)\n\nmwsumTopN(x1,y1,s1,4,3)\n```\n\n| #1 | #2 |\n| -- | -- |\n|    | 8  |\n| 21 | 8  |\n| 93 | 14 |\n| 93 | 28 |\n| 93 | 29 |\n| 84 | 26 |\n| 36 | 23 |\n\n```\nmwsumTopN(x1, y1, s, 4, 3)\n```\n\n| #1  | #2 |\n| --- | -- |\n|     | 8  |\n|     | 8  |\n| 72  | 14 |\n| 84  | 28 |\n| 84  | 29 |\n| 112 | 26 |\n| 64  | 23 |\n\n```\nn = 3000\nids = 1..3000\ndates = take(2021.01.01..2021.10.01,n)\nprices = rand(1000,n)\nvals = rand(1000,n)\nt = table(ids as id,dates as date,prices as price,vals as val)\ndbName = \"dfs://test_mwsumTopN_2\"\nif(existsDatabase(dbName))dropDB(dbName)\ndb = database(dbName,VALUE,1..5000)\npt = db.createPartitionedTable(t,\"pt\",`id).append!(t)\nselect mwsumTopN(price, val, id, 10, 5, true) from pt where date>2021.05.01\n```\n\n相关函数：[mwsum](https://docs.dolphindb.cn/zh/funcs/m/mwsum.html)\n"
    },
    "nanInfFill": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/nanInfFill.html",
        "signatures": [
            {
                "full": "nanInfFill(X,Y)",
                "name": "nanInfFill",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [nanInfFill](https://docs.dolphindb.cn/zh/funcs/n/nanInfFill.html)\n\n\n\n#### 语法\n\nnanInfFill(X,Y)\n\n#### 参数\n\n**X** 是除集合外任一数据形式的浮点数。\n\n**Y** 是一个浮点数。\n\n#### 详情\n\n在 DolphinDB 中，浮点数中出现的 NaN 和 Inf 值自动替换为空值。而在外部数据导入或计算过程中，可能出现极端场景，导致上述两个特殊值的引入。该函数用于替换这两个特殊值。\n\n可使用指定 *Y* 值对 *X* 中存在的 NaN 或 Inf 值进行替换。\n\n**Note:** 当 *X* 为字典时，该函数仅对 value 值进行替换。s\n\n#### 例子\n\n```\nx = [float(`inf), 2, 3, float(`nan), 5, 6, 7]\nnanInfFill (x, 2.2)\nx = matrix(1..3, [float(`inf), float(`nan), 1.0])\nnanInfFill(x, 1.2)\n```\n\n相关函数：[isNanInf](https://docs.dolphindb.cn/zh/funcs/i/isNanInf.html), [countNanInf](https://docs.dolphindb.cn/zh/funcs/c/countNanInf.html)\n"
    },
    "nanosecond": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html",
        "signatures": [
            {
                "full": "nanosecond(X)",
                "name": "nanosecond",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [nanosecond](https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html)\n\n\n\n#### 语法\n\nnanosecond(X)\n\n#### 参数\n\n**X** 可以是 TIME, TIMESTAMP, NANOTIME 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n返回 *X* 中的纳秒数。\n\n#### 例子\n\n```\nnanosecond(13:30:10.008);\n// output\n8000000\n\nnanosecond([2012.12.03 01:22:01.999999999, 2012.12.03 01:25:08.000000234]);\n// output\n[999999999,234]\n```\n\n相关函数：[dayOfYear](https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.cn/zh/funcs/m/millisecond.html), [microsecond](https://docs.dolphindb.cn/zh/funcs/m/microsecond.html)\n"
    },
    "nanotime": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/nanotime.html",
        "signatures": [
            {
                "full": "nanotime(X)",
                "name": "nanotime",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [nanotime](https://docs.dolphindb.cn/zh/funcs/n/nanotime.html)\n\n\n\n#### 语法\n\nnanotime(X)\n\n#### 详情\n\n返回相应的纳秒。返回值类型是 NANOTIME，时间类型的变量。\n\n#### 参数\n\n**X** 可以是整型标量或向量、时间标量或向量。\n\n#### 例子\n\n```\nnanotime(1000000000);\n```\n\n返回：00:00:01.000000000\n\n```\nnanotime(12:06:09 13:08:01);\n```\n\n返回：\\[12:06:09.000000000,13:08:01.000000000]\n\n```\nnanotime(2012.12.03 01:22:01.123456789);\n```\n\n返回：01:22:01.123456789\n\n```\nnanotime('13:30:10.008007006');\n```\n\n返回：13:30:10.008007006\n\n**Related information**\n\n[nanotimestamp](https://docs.dolphindb.cn/zh/funcs/n/nanotimestamp.html)\n"
    },
    "nanotimestamp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/nanotimestamp.html",
        "signatures": [
            {
                "full": "nanotimestamp(X)",
                "name": "nanotimestamp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [nanotimestamp](https://docs.dolphindb.cn/zh/funcs/n/nanotimestamp.html)\n\n\n\n#### 语法\n\nnanotimestamp(X)\n\n#### 参数\n\n**X** 可以是整型标量或向量、时间标量或向量。\n\n#### 详情\n\n返回由日期和精确到纳秒的时间组成的时间戳。返回值类型是 NANOTIMESTAMP，时间类型变量。如果参数 *X* 不是日期和时间，则返回值是 1970.01.01 00:00:00.000000000 + *X* 纳秒的时间戳。\n\n**Note:** 自 2.00.12 版本起，支持转换 MONTH 类型的数据。\n\n#### 例子\n\n```\nnanotimestamp(1);\n```\n\n返回：1970.01.01 00:00:00.000000001\n\n```\nnanotimestamp(1000000000);\n```\n\n返回：1970.01.01 00:00:01.000000000\n\n```\nnanotimestamp(2012.12.03 12:06:09 2012.12.03 13:08:01);\n```\n\n返回：\\[2012.12.03 12:06:09.000000000,2012.12.03 13:08:01.000000000]\n\n```\nnanotimestamp(2012.12.03 01:22:01.123456789);\n```\n\n返回：2012.12.03 01:22:01.123456789\n\n```\nnanotimestamp('2012.12.03 13:30:10.008007006');\n```\n\n返回：2012.12.03 13:30:10.008007006\n\n```\nnanotimestamp(now());\n```\n\n返回：2024.02.22 16:14:28.627000000\n\n```\nnanotimestamp(2012.01M)\n```\n\n返回：2012.01.01T00:00:00.000000000\n\n**Related information**\n\n[nanotime](https://docs.dolphindb.cn/zh/funcs/n/nanotime.html)\n"
    },
    "ne": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/ne.html",
        "signatures": [
            {
                "full": "ne(X, Y)",
                "name": "ne",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ne](https://docs.dolphindb.cn/zh/funcs/n/ne.html)\n\n\n\n#### 语法\n\nne(X, Y) 或 X!=Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量、矩阵或集合。如果 *X* 和 *Y* 的其中一个是数据对、向量或矩阵，另一个必须是标量或具有相同长度或维度的数据对、向量或矩阵。\n\n#### 详情\n\n如果 *X* 和 *Y* 都不是集合，逐个元素地比较 *X* 和 *Y*，如果不相等则返回1。\n\n如果 *X* 和 *Y* 都是集合，检查 *X* 和 *Y* 是不是同一个集合。是则返回0，不是则返回1。\n\n#### 例子\n\n```\n1 2 3 != 2;\n// output\n[1,0,1]\n\n1 2 3 ne 0 2 4;\n// output\n[1,0,1]\n\n1:2 != 1:6;\n// output\n0 : 1\n```\n\n```\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm1 != 4\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 1  | 0  | 1  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1 ne m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 1  | 1  | 1  |\n\n集合操作：如果 X!=Y 则 X 和 Y 不是同一个集合。\n\n```\nx=set(4 6);\ny=set(4 6 8);\n\nx!=y;\n// output\n1\n\nx!=x;\n// output\n0\n```\n"
    },
    "neg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/neg.html",
        "signatures": [
            {
                "full": "neg(X)",
                "name": "neg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [neg](https://docs.dolphindb.cn/zh/funcs/n/neg.html)\n\n\n\n#### 语法\n\nneg(X) 或 neg X\n\n#### 参数\n\n**X** 可以是标量、数据对、向量或矩阵。\n\n#### 详情\n\n返回 *X* 的相反数。\n\nneg 函数和运算符 - 在大部分场景下可以相互替代，但仍然存在一些区别：\n\n* neg 与括号结合时，被当作函数处理，具有最高优先级；\n* neg 不与括号结合时，则优先级较低，会先运算 neg 右边的表达式，再运算 neg。例如：neg 3 + 5，结果为 -8。\n* 运算符 \"-\" 则总是按照运算符优先级执行。例如：-3 + 5，结果为 2。\n\n#### 例子\n\n```\nx=1:2;\n-x;\n// output\n-1 : -2\n```\n\n```\nx=1 0 1;\n-x;\n// output\n[-1,0,-1]\n```\n\n```\nm=1 1 1 0 0 0 $ 2:3;\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 0  |\n| 1  | 0  | 0  |\n\n```\n-m\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| -1 | -1 | 0  |\n| -1 | 0  | 0  |\n"
    },
    "neville": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/neville.html",
        "signatures": [
            {
                "full": "neville(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false])",
                "name": "neville",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "resampleRule",
                        "name": "resampleRule"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    },
                    {
                        "full": "[outputX=false]",
                        "name": "outputX",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [neville](https://docs.dolphindb.cn/zh/funcs/n/neville.html)\n\n\n\n#### 语法\n\nneville(X, Y, resampleRule, \\[closed='left'], \\[origin='start\\_day'], \\[outputX=false])\n\n#### 详情\n\n该函数根据 *resampleRule*, *closed*, *origin* 确定的采样规则，对 *X* 进行重采样操作。并根据重采样后的 *X*，对 *Y* 进行 neville 插值（Neville Interpolation）。\n\n若不指定 *outputX*，仅返回一个对 *Y* 插值后的向量。若指定 *outputX* = true，则返回一个 tuple，其第一个元素为 *X* 重采样后的向量，第二个元素为对 *Y* 插值后的向量。\n\n#### 参数\n\n**X** 严格递增的时间类型向量。\n\n**Y** 同 *X* 等长的数值型向量。\n\n**resampleRule** 一个字符串，可选值请参考 [resample](https://docs.dolphindb.cn/zh/funcs/r/resample.html) 的 *rule* 参数。\n\n**closed** 和 **origin** 同 [resample](https://docs.dolphindb.cn/zh/funcs/r/resample.html) 的 *closed* 和 *origin* 参数。\n\n**outputX** 布尔类型，表示是否输出 *X* 按照 *resampleRule*, *closed*, *origin* 重采样后的向量。默认值为 false。\n\n#### 例子\n\n```\nneville([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min);\n```\n\n输出返回：\\[1,1.0217,1.0451,1.0703,1.0972,1.1259,1.1562,1.1884,1.2222,1.2578, 1.2951,1.3342,1.375,1.4175,1.4618,1.5078,1.5556,1.605,1.6562,1.7092, 1.7639,1.8203,1.8785,1.9384,2,2.0634,2.1285,2.1953,2.2639,2.3342, 2.4062,2.48,2.5556,2.6328,2.7118,2.7925,2.875,2.9592,3.0451,3.1328, 3.2222,3.3134,3.4062,3.5009,3.5972,3.6953,3.7951,3.8967,4]\n"
    },
    "next": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/next.html",
        "signatures": [
            {
                "full": "next(X)",
                "name": "next",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [next](https://docs.dolphindb.cn/zh/funcs/n/next.html)\n\n\n\n#### 语法\n\nnext(X)\n\n#### 参数\n\n**X** 是一个向量。\n\n#### 详情\n\n将向量左移动一个位置，原来左侧元素。参见相关函数：[prev](https://docs.dolphindb.cn/zh/funcs/p/prev.html) 和 [move](https://docs.dolphindb.cn/zh/funcs/m/move.html).\n\n#### 例子\n\n```\nx = 1..5;\nx;\n```\n\n输出：\\[1,2,3,4,5]\n\n```\nnext(x);\n```\n\n输出返回：\\[2,3,4,5,]\n"
    },
    "nextState": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/nextState.html",
        "signatures": [
            {
                "full": "nextState(X)",
                "name": "nextState",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [nextState](https://docs.dolphindb.cn/zh/funcs/n/nextState.html)\n\n\n\n#### 语法\n\nnextState(X)\n\n#### 参数\n\n**X** 时间类型，布尔类型或者数值型的向量/矩阵。\n\n#### 详情\n\n*X* 中连续且相同的元素标记为同一状态，空值无状态。每个元素的状态等于其元素值。对于 *X* 中的每一个元素，返回当前状态的下一个状态。若当前元素为空，则返回下一个邻近状态。\n\n*X* 是矩阵时，则在矩阵每一列进行上述计算。\n\n#### 例子\n\n```\nX = [1, 2.2, NULL, 2.2, 2.3, 1, 1.2]\nnext(X)\n// output\n[2.2,,2.2,2.3,1,1.2,]\n\nnextState(X)\n// output\n[2.2,2.2,2.2,2.3,1,1.2,]\n\nX = matrix([1.0, 1.1, 1.0, 0.9], [NULL, 1.3, 2.5, 5.5], [5.5, 4.2, 1.6, 1.8])\nnextState(X)\n```\n\n| #0  | #1  | #2  |\n| --- | --- | --- |\n| 1.1 | 1.3 | 4.2 |\n| 1   | 2.5 | 1.6 |\n| 0.9 | 5.5 | 1.8 |\n|     |     |     |\n\n相关函数： [prevState](https://docs.dolphindb.cn/zh/funcs/p/prevState.html)\n"
    },
    "norm": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/norm.html",
        "signatures": [
            {
                "full": "norm(mean, std, count)",
                "name": "norm",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "std",
                        "name": "std"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [norm](https://docs.dolphindb.cn/zh/funcs/n/norm.html)\n\n\n\n#### 语法\n\nnorm(mean, std, count)\n\n#### 参数\n\n**mean** 数值型标量，表示正态分布的期望值。\n\n**std** 数值型标量，表示正态分布的标准差。\n\n**count** 整型标量或数据对。若为标量，表示输出向量的长度；若为数据对，表示输出矩阵的维度。\n\n#### 详情\n\n返回一个长度（维度）为 *count* 的向量（矩阵），服从期望值为 *mean*，标准差为 *std* 的正态分布。\n\n#### 例子\n\n```\nnorm(2.0,0.1,3);\n// output\n[2.026602,1.988621,2.101107]\n\nmean norm(3,1,10000);\n// output\n3.007866\n\n\nstd norm(10000);\n// output\n0.995806\n\n// 生成随机矩阵\nnorm(0, 1, 3:2)\n```\n\n| col1     | col2     |\n| -------- | -------- |\n| (0.5399) | (0.8475) |\n| (1.0029) | 1.811    |\n| (0.0485) | (0.4339) |\n"
    },
    "normal": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/normal.html",
        "signatures": [
            {
                "full": "norm(mean, std, count)",
                "name": "norm",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "std",
                        "name": "std"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [normal](https://docs.dolphindb.cn/zh/funcs/n/normal.html)\n\n是 [norm](https://docs.dolphindb.cn/zh/funcs/n/norm.html) 的别名。\n\n\n以下是 `norm` 函数的文档：\n### [norm](https://docs.dolphindb.cn/zh/funcs/n/norm.html)\n\n\n\n#### 语法\n\nnorm(mean, std, count)\n\n#### 参数\n\n**mean** 数值型标量，表示正态分布的期望值。\n\n**std** 数值型标量，表示正态分布的标准差。\n\n**count** 整型标量或数据对。若为标量，表示输出向量的长度；若为数据对，表示输出矩阵的维度。\n\n#### 详情\n\n返回一个长度（维度）为 *count* 的向量（矩阵），服从期望值为 *mean*，标准差为 *std* 的正态分布。\n\n#### 例子\n\n```\nnorm(2.0,0.1,3);\n// output\n[2.026602,1.988621,2.101107]\n\nmean norm(3,1,10000);\n// output\n3.007866\n\n\nstd norm(10000);\n// output\n0.995806\n\n// 生成随机矩阵\nnorm(0, 1, 3:2)\n```\n\n| col1     | col2     |\n| -------- | -------- |\n| (0.5399) | (0.8475) |\n| (1.0029) | 1.811    |\n| (0.0485) | (0.4339) |\n"
    },
    "not": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/not.html",
        "signatures": [
            {
                "full": "not(X)",
                "name": "not",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [not](https://docs.dolphindb.cn/zh/funcs/n/not.html)\n\n\n\n#### 语法\n\nnot(X) 或 !(X)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量或矩阵。\n\n#### 详情\n\n返回对 *X* 应用 NOT 的值。返回值是 0, 1 或 NULL。 0 的 NOT 值是 1；NULL 的 NOT 值仍是 NULL；所有其他值的 NOT 值是 0。\n\nnot 函数和运算符 ! 在大部分场景下可以相互替代，但仍然存在一些区别：\n\n* not 与括号结合时，被当作函数处理，具有最高优先级；\n* not 不与括号结合时，则优先级较低，会先运算 not 右边的表达式，再运算 not。例如：not false and false 等价于 not(false and false)，结果为 true。\n* 运算符 \"!\" 则总是按照运算符优先级执行。例如：！false and false 等价于 (!false) and false，结果为 false。\n\n#### 例子\n\n```\n!1.5;\n// output\n0\n```\n\n```\nnot 0;\n// output\n1\n```\n\n```\nx=1 0 2;\nnot x;\n// output\n[0,1,0]\n```\n\n```\nm=1 1 1 1 1 0 0 0 0 0$2:5;\nm;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 1  | 1  | 0  | 0  |\n| 1  | 1  | 0  | 0  | 0  |\n\n```\nnot m;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 0  | 0  | 0  | 1  | 1  |\n| 0  | 0  | 1  | 1  | 1  |\n\n```\n(1).not();\n// output\n0\n```\n\n```\n(!NULL)==NULL;\n// output\n1\n```\n\n**Related information**\n\n[and](https://docs.dolphindb.cn/zh/funcs/a/and.html)\n\n[or](https://docs.dolphindb.cn/zh/funcs/o/or.html)\n"
    },
    "now": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/now.html",
        "signatures": [
            {
                "full": "now([nanoSecond=false])",
                "name": "now",
                "parameters": [
                    {
                        "full": "[nanoSecond=false]",
                        "name": "nanoSecond",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [now](https://docs.dolphindb.cn/zh/funcs/n/now.html)\n\n\n\n#### 语法\n\nnow(\\[nanoSecond=false])\n\n#### 参数\n\n**nanoSecond** 是布尔值，表示是否精确到纳秒。它是可选参数，默认值为 false，表示精确到毫秒。\n\n#### 详情\n\n返回当前的时间戳。\n\n#### 例子\n\n```\nnow();\n// output\n2016.05.12T19:32:49.613\n\nnow(true);\n// output\n2016.05.12T19:32:49.614243000\n```\n"
    },
    "ns": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/ns.html",
        "signatures": [
            {
                "full": "ns(maturity, yield, [method='nm'], [maxIter], [bounds], [initialGuess], [seed])",
                "name": "ns",
                "parameters": [
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "yield",
                        "name": "yield"
                    },
                    {
                        "full": "[method='nm']",
                        "name": "method",
                        "optional": true,
                        "default": "'nm'"
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[bounds]",
                        "name": "bounds",
                        "optional": true
                    },
                    {
                        "full": "[initialGuess]",
                        "name": "initialGuess",
                        "optional": true
                    },
                    {
                        "full": "[seed]",
                        "name": "seed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ns](https://docs.dolphindb.cn/zh/funcs/n/ns.html)\n\n\n\n#### 语法\n\nns(maturity, yield, \\[method='nm'], \\[maxIter], \\[bounds], \\[initialGuess], \\[seed])\n\n#### 语法\n\n使用 NS 模型和指定的优化方法，拟合债券的收益率曲线。\n\n返回一个字典，详见 [nss](https://docs.dolphindb.cn/zh/funcs/n/nss.html)。\n\n#### 语法\n\n**initialGuess** 可选参数，数值向量，表示使函数最优化的参数的初始猜测。长度为 4，每个值分别表示 β0, β1, β2, λ 的初始猜测，默认值为 \\[0.01, 0.01, 0.01, 1.0]。\n\n其余参数详见 [nss](https://docs.dolphindb.cn/zh/funcs/n/nss.html)。\n\n#### 语法\n\n传入指定的模型名称与参数，使用 bfgs 优化方法，拟合债券的收益率曲线。\n\n```\nmaturity = [1,2,3,4,5,8,10,15,20,25,30]\nyield = [0.0039,0.0061,NULL,NULL,0.0166,NULL,0.0258,NULL,NULL,0.0332,NULL]\nmodel = ns(maturity, yield, method='bfgs');\nmodel;\n/*Output\nmodelName->ns\nparams->[0.037907009765789,-0.032345632006991,-0.048221596538028,1.48711064869407]\nfminResult->xopt->[0.037907009765789,-0.032345632006991,-0.048221596538028,1.48711064869407]\nfopt->7.682740281926149E-8\ngopt->[0.000007050477817,-0.000001557728067,8.217072418048589E-7,-7.435919702203364E-8]\niterations->29\nHinv->#0                  #1                    #2                   #3                   \n------------------- --------------------- -------------------- ---------------------\n1.046957491287936   -2.422265785994416    4.016547235964936    174.575362711334378  \n-2.422265785994413  20.767722224747515    -55.516118469836506  -1160.911707217612729\n4.016547235964929   -55.516118469836506   162.441840532431541  3127.297987855009978 \n174.575362711334378 -1160.911707217613638 3127.297987855011797 72743.950482441126951\n\nwarnFlag->0\nfcalls->165\ngcalls->33\n\npredict->nssPredict\n*/\n```\n\n若更换优化算法为 nm，返回值将发生变化。\n\n```\nmodel = ns(maturity, yield, method='nm');\nmodel;\n/*Output\nmodelName->ns\nmodelName->ns\nparams->[-0.017297505365068,0.016544815374471,0.142682692134247,14.720778706012911]\nfminResult->xopt->[-0.017297505365068,0.016544815374471,0.142682692134247,14.720778706012911]\nfopt->0.000001443427918\niterations->446\nfcalls->740\nwarnFlag->0\n\npredict->nssPredict\n*/\n```\n\n**相关函数**：[nss](https://docs.dolphindb.cn/zh/funcs/n/nss.html)\n"
    },
    "nss": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/nss.html",
        "signatures": [
            {
                "full": "nss(maturity, yield, [method='nm'], [maxIter], [bounds], [initialGuess], [seed])",
                "name": "nss",
                "parameters": [
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "yield",
                        "name": "yield"
                    },
                    {
                        "full": "[method='nm']",
                        "name": "method",
                        "optional": true,
                        "default": "'nm'"
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[bounds]",
                        "name": "bounds",
                        "optional": true
                    },
                    {
                        "full": "[initialGuess]",
                        "name": "initialGuess",
                        "optional": true
                    },
                    {
                        "full": "[seed]",
                        "name": "seed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [nss](https://docs.dolphindb.cn/zh/funcs/n/nss.html)\n\n\n\n#### 语法\n\nnss(maturity, yield, \\[method='nm'], \\[maxIter], \\[bounds], \\[initialGuess], \\[seed])\n\n#### 详情\n\n使用 NSS 模型和指定的优化方法，拟合债券的收益率曲线。\n\n#### 参数\n\n**maturity**值大于等于 0 的数值型向量，表示历史债券的到期时间，单位是年。\n\n**yield**与 *maturity*等长的数值型向量，表示历史债券的收益率。\n\n**method**可选参数，字符串类型，表示在拟合过程中使用的最优化算法，可选值为：\n\n* “nm“：表示使用 Nelder-Mead 单纯形算法，默认值；\n\n* “bfgs“：表示使用 bfgs 算法；\n\n* “lbfgs“ ：表示使用 lbfgs 算法；\n\n* 'slsqp'：表示顺序最小二乘编程方法(SLSQP)算法；\n\n* 'de'：表示差分进化(Differential Evolution)算法。\n\n**maxIter** 可选参数，整型标量或向量，表示拟合过程中优化算法的最大迭代次数。\n\n**bounds** 可选参数，数值类型矩阵，形状为(N,2)，其中 N 为需要优化的参数数量。每一行的两个值（min, max）定义了对应参数的边界。注意：*bounds* 参数只在 *method*取值'lbfgs'、'slsqp'或者'de'时生效。\n\n**initialGuess** 可选参数，数值向量，表示使函数最优化的参数的初始猜测。长度为 6，每个值分别表示 β0, β1, β2, β3, λ0, λ1 的初始猜测，默认值为 \\[0.01, 0.01, 0.01, 0.01, 1.0, 1.0]。\n\n**seed** 可选参数，整数标量，表示差分进化算法中使用的随机数种子，仅在 *method*='de' 时生效。若 *method*='de' 且不指定 *seed*，则采用非确定性的随机数生成器。*seed* 参数用于确保结果的可复现性。\n\n#### 返回值\n\n返回一个字典，包含以下键值对：\n\n* modelName：字符串类型，表示模型名称；\n\n* params：数值向量，表示拟合后的模型参数。对于NS模型来说，长度为4，包含；对于NSS模型来说，长度为6，包含 。\n\n* fminResult：字典类型，表示 method 对应的最优化算法的优化结果，对于不同的 method，有不同输出。\n\n  * “nm“：详情见 fmin 文档。\n\n  * “bfgs“：详情见 fminBFGS 文档。\n\n  * “lbfgs“：详情见 fminLBFGSB 文档。\n\n  * “slsqp“：详情见 fminSLSQP 文档。\n\n  * “de“：详情见 differentialEvolution 文档。\n\n* predict：模型的预测函数。其使用方法为 `model.predict(T)`，T 表示需要预测的以年为单位的到期时间。\n\n#### 例子\n\n传入指定的模型名称与参数，使用 bfgs 优化方法，拟合债券的收益率曲线。\n\n```\nmaturity = [1,2,3,4,5,8,10,15,20,25,30]\nyield = [0.0039,0.0061,NULL,NULL,0.0166,NULL,0.0258,NULL,NULL,0.0332,NULL]\nmodel = nss(maturity, yield, method='bfgs');\nmodel;\n\n/*Output\nmodelName->nss\nparams->[0.036140551464406,-0.017389058792285,-0.039552798745696,-0.039554933812457,1.001838685848857,1.000930288743548]\nfminResult->xopt->[0.036140551464406,-0.017389058792285,-0.039552798745696,-0.039554933812457,1.001838685848857,1.000930288743548]\nfopt->0.000003185056025\ngopt->[4.415407204305666E-7,8.382398277717584E-7,-2.683916591195157E-7,-4.651950860079524E-7,-0.000008569511408,-0.000008564345961]\niterations->10\nHinv->#0                 #1                 #2                 #3                 #4                 #5                \n------------------ ------------------ ------------------ ------------------ ------------------ ------------------\n0.492426526437359  0.696702464055202  -1.643864246164442 -1.644086017367336 0.08871259052824   0.037055616913674 \n0.696702464055203  9.022078200827937  -9.027640937693616 -9.027654505585944 0.659730122918773  0.302144825834614 \n-1.643864246164441 -9.027640937693616 12.179963755936533 11.180865226841653 -0.737531568671335 -0.323934330889313\n-1.644086017367337 -9.027654505585944 11.180865226841657 12.181767428775573 -0.737537584440894 -0.32392102429678 \n0.08871259052824   0.659730122918772  -0.737531568671335 -0.737537584440894 1.053013492023418  0.024560701245749 \n0.037055616913674  0.302144825834614  -0.323934330889313 -0.32392102429678  0.024560701245749  1.011692492570688 \n\nwarnFlag->0\nfcalls->84\ngcalls->12\n\npredict->nssPredict\n*/\n```\n\n若更换优化算法为 nm，返回值将发生变化。\n\n```\nmodel = ns(maturity, yield, method='nm');\nmodel;\n/*Output\nmodelName->nss\nparams->[0.038184469794996,-0.048575389082029,-0.022287414169806,0.047523360012739,1.873046195772644,0.161159907274023]\nfminResult->xopt->[0.038184469794996,-0.048575389082029,-0.022287414169806,0.047523360012739,1.873046195772644,0.161159907274023]\nfopt->5.456415848001168E-9\niterations->541\nfcalls->860\nwarnFlag->0\n\npredict->nssPredict\n*/\n```\n\n相关函数：[nsspredict](https://docs.dolphindb.cn/zh/funcs/n/nsspredict.html)\n"
    },
    "nsspredict": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/nsspredict.html",
        "signatures": [
            {
                "full": "nssPredict(model, maturity)",
                "name": "nssPredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    }
                ]
            }
        ],
        "markdown": "### [nsspredict](https://docs.dolphindb.cn/zh/funcs/n/nsspredict.html)\n\n\n\n#### 语法\n\nnssPredict(model, maturity)\n\n#### 参数\n\n**model**字典类型，表示 Nelson-Siegel（NS） 模型或 Nelson-Siegel-Svensson（NSS）模型。字典中应至少包含 *modelName*和 *params*两个成员：\n\n* modelName 字符串类型，必须为 “ns” 或 “nss” 。\n\n* params 数值型向量，表示模型的参数：\n\n  * 对于 NS 模型，向量长度为 4，依次为 β0, β1, β2, λ 。\n\n  * 对于 NSS 模型，向量长度为 6，依次为 β0, β1, β2, β3, λ0, λ1。\n\n**maturity**值大于 0 的数值型向量，表示历史债券的到期时间，单位是年。\n\n#### 详情\n\n根据指定的 NS 模型或 NSS 模型，预测债券的收益率。\n\n#### 例子\n\n```\nmodel = dict(STRING, ANY)\nmodel[`modelName] = `nss\nmodel[`params] = [0.038184469794996,-0.048575389082029,-0.022287414169806,0.047523360012739,1.873046195772644,0.161159907274023]\nmaturity = [3,1]\nnssPredict(model, maturity)\n//output: [0.009904201306,0.003891991292041]\n```\n\n相关函数：[nss](https://docs.dolphindb.cn/zh/funcs/n/nss.html)\n"
    },
    "nullFill": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/nullFill.html",
        "signatures": [
            {
                "full": "nullFill(X, Y)",
                "name": "nullFill",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [nullFill](https://docs.dolphindb.cn/zh/funcs/n/nullFill.html)\n\n\n\n#### 语法\n\nnullFill(X, Y)\n\n#### 参数\n\n**X** 可以是向量、矩阵或表。\n\n**Y** 可以是一个标量，也可以是与 *X* 长度相同的向量或矩阵。\n\n#### 详情\n\n如果 *X* 是一个向量或矩阵：\n\n* 如果 *Y* 是标量，使用 *Y* 填充 *X* 中的 NULL 值。\n\n* 如果 *Y* 是一个与 *X* 等长的向量或矩阵，使用 *Y* 中与 *X* 的 NULL 值对应位置的元素替换 *X* 中的 NULL 值。\n\n如果 *X* 是一个表，那么 *Y* 只能是一个标量，使用 *Y* 填充表中的 NULL 值。注意，填充 NULL 值时，系统会尝试将 *Y* 进行类型转换。如果 *Y* 不能转换为表中某列的类型，系统会抛出异常。\n\n`nullFill` 不改变输入对象的值；`nullFill!` 会改变输入对象的值。\n\n#### 例子\n\n例1.向量\n\n```\nx=1 NULL NULL 6 NULL 7;\nnullFill(x,0);\n// output\n[1,0,0,6,0,7]\n\ny=1..6\nnullFill(x,y);\n// output\n[1,2,3,6,5,7]\n```\n\n在 SQL 语句中对表中的一列使用 `nullFill` 函数：\n\n```\nID=take(1,6) join take(2,6)\ndate=take(2018.01.01..2018.01.06, 12)\nx=3.2 5.2 NULL 7.4 NULL NULL NULL NULL 8 NULL NULL 11\nt=table(ID, date, x)\nt;\n```\n\n| ID | date       | x   |\n| -- | ---------- | --- |\n| 1  | 2018.01.01 | 3.2 |\n| 1  | 2018.01.02 | 5.2 |\n| 1  | 2018.01.03 |     |\n| 1  | 2018.01.04 | 7.4 |\n| 1  | 2018.01.05 |     |\n| 1  | 2018.01.06 |     |\n| 2  | 2018.01.01 |     |\n| 2  | 2018.01.02 |     |\n| 2  | 2018.01.03 | 8   |\n| 2  | 2018.01.04 |     |\n| 2  | 2018.01.05 |     |\n| 2  | 2018.01.06 | 11  |\n\n```\nupdate t set x=x.nullFill(avg(x)) context by id;\nt;\n```\n\n| ID | date       | x        |\n| -- | ---------- | -------- |\n| 1  | 2018.01.01 | 3.2      |\n| 1  | 2018.01.02 | 5.2      |\n| 1  | 2018.01.03 | 5.266667 |\n| 1  | 2018.01.04 | 7.4      |\n| 1  | 2018.01.05 | 5.266667 |\n| 1  | 2018.01.06 | 5.266667 |\n| 2  | 2018.01.01 | 9.5      |\n| 2  | 2018.01.02 | 9.5      |\n| 2  | 2018.01.03 | 8        |\n| 2  | 2018.01.04 | 9.5      |\n| 2  | 2018.01.05 | 9.5      |\n| 2  | 2018.01.06 | 11       |\n\n例2.矩阵\n\n```\nx=1 NULL 2 NULL 3 4 $ 3:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n|    | 3  |\n| 2  | 4  |\n\n```\nx.nullFill(0);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 0  |\n| 0  | 3  |\n| 2  | 4  |\n\n例3.表\n\n```\nt=table(1..6 as id, 2.1 2.2 NULL NULL 2.4 2.6 as x, 4.3 NULL 3.6 6.7 8.8 NULL as y);\nnullFill(t, -999999);\n```\n\n| id | x       | y       |\n| -- | ------- | ------- |\n| 1  | 2.1     | 4.3     |\n| 2  | 2.2     | -999999 |\n| 3  | -999999 | 3.6     |\n| 4  | -999999 | 6.7     |\n| 5  | 2.4     | 8.8     |\n| 6  | 2.6     | -999999 |\n\n相关函数：[isNull](https://docs.dolphindb.cn/zh/funcs/i/isNull.html), [hasNull](https://docs.dolphindb.cn/zh/funcs/h/hasNull.html), [bfill](https://docs.dolphindb.cn/zh/funcs/b/bfill.html), [ffill](https://docs.dolphindb.cn/zh/funcs/f/ffill.html), [lfill](https://docs.dolphindb.cn/zh/funcs/l/lfill.html)\n"
    },
    "nullFill!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/nullFill_.html",
        "signatures": [
            {
                "full": "nullFill(X, Y)",
                "name": "nullFill",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [nullFill!](https://docs.dolphindb.cn/zh/funcs/n/nullFill_.html)\n\n是 [nullFill](https://docs.dolphindb.cn/zh/funcs/n/nullFill.html) 的别名。\n\nnullFill! 是  函数原地修改版本，它会改变输入对象的值。\n\n\n以下是 `nullFill` 函数的文档：\n### [nullFill](https://docs.dolphindb.cn/zh/funcs/n/nullFill.html)\n\n\n\n#### 语法\n\nnullFill(X, Y)\n\n#### 参数\n\n**X** 可以是向量、矩阵或表。\n\n**Y** 可以是一个标量，也可以是与 *X* 长度相同的向量或矩阵。\n\n#### 详情\n\n如果 *X* 是一个向量或矩阵：\n\n* 如果 *Y* 是标量，使用 *Y* 填充 *X* 中的 NULL 值。\n\n* 如果 *Y* 是一个与 *X* 等长的向量或矩阵，使用 *Y* 中与 *X* 的 NULL 值对应位置的元素替换 *X* 中的 NULL 值。\n\n如果 *X* 是一个表，那么 *Y* 只能是一个标量，使用 *Y* 填充表中的 NULL 值。注意，填充 NULL 值时，系统会尝试将 *Y* 进行类型转换。如果 *Y* 不能转换为表中某列的类型，系统会抛出异常。\n\n`nullFill` 不改变输入对象的值；`nullFill!` 会改变输入对象的值。\n\n#### 例子\n\n例1.向量\n\n```\nx=1 NULL NULL 6 NULL 7;\nnullFill(x,0);\n// output\n[1,0,0,6,0,7]\n\ny=1..6\nnullFill(x,y);\n// output\n[1,2,3,6,5,7]\n```\n\n在 SQL 语句中对表中的一列使用 `nullFill` 函数：\n\n```\nID=take(1,6) join take(2,6)\ndate=take(2018.01.01..2018.01.06, 12)\nx=3.2 5.2 NULL 7.4 NULL NULL NULL NULL 8 NULL NULL 11\nt=table(ID, date, x)\nt;\n```\n\n| ID | date       | x   |\n| -- | ---------- | --- |\n| 1  | 2018.01.01 | 3.2 |\n| 1  | 2018.01.02 | 5.2 |\n| 1  | 2018.01.03 |     |\n| 1  | 2018.01.04 | 7.4 |\n| 1  | 2018.01.05 |     |\n| 1  | 2018.01.06 |     |\n| 2  | 2018.01.01 |     |\n| 2  | 2018.01.02 |     |\n| 2  | 2018.01.03 | 8   |\n| 2  | 2018.01.04 |     |\n| 2  | 2018.01.05 |     |\n| 2  | 2018.01.06 | 11  |\n\n```\nupdate t set x=x.nullFill(avg(x)) context by id;\nt;\n```\n\n| ID | date       | x        |\n| -- | ---------- | -------- |\n| 1  | 2018.01.01 | 3.2      |\n| 1  | 2018.01.02 | 5.2      |\n| 1  | 2018.01.03 | 5.266667 |\n| 1  | 2018.01.04 | 7.4      |\n| 1  | 2018.01.05 | 5.266667 |\n| 1  | 2018.01.06 | 5.266667 |\n| 2  | 2018.01.01 | 9.5      |\n| 2  | 2018.01.02 | 9.5      |\n| 2  | 2018.01.03 | 8        |\n| 2  | 2018.01.04 | 9.5      |\n| 2  | 2018.01.05 | 9.5      |\n| 2  | 2018.01.06 | 11       |\n\n例2.矩阵\n\n```\nx=1 NULL 2 NULL 3 4 $ 3:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  |    |\n|    | 3  |\n| 2  | 4  |\n\n```\nx.nullFill(0);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 0  |\n| 0  | 3  |\n| 2  | 4  |\n\n例3.表\n\n```\nt=table(1..6 as id, 2.1 2.2 NULL NULL 2.4 2.6 as x, 4.3 NULL 3.6 6.7 8.8 NULL as y);\nnullFill(t, -999999);\n```\n\n| id | x       | y       |\n| -- | ------- | ------- |\n| 1  | 2.1     | 4.3     |\n| 2  | 2.2     | -999999 |\n| 3  | -999999 | 3.6     |\n| 4  | -999999 | 6.7     |\n| 5  | 2.4     | 8.8     |\n| 6  | 2.6     | -999999 |\n\n相关函数：[isNull](https://docs.dolphindb.cn/zh/funcs/i/isNull.html), [hasNull](https://docs.dolphindb.cn/zh/funcs/h/hasNull.html), [bfill](https://docs.dolphindb.cn/zh/funcs/b/bfill.html), [ffill](https://docs.dolphindb.cn/zh/funcs/f/ffill.html), [lfill](https://docs.dolphindb.cn/zh/funcs/l/lfill.html)\n"
    },
    "nunique": {
        "url": "https://docs.dolphindb.cn/zh/funcs/n/nunique.html",
        "signatures": [
            {
                "full": "nunique(X, [ignoreNull=false])",
                "name": "nunique",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ignoreNull=false]",
                        "name": "ignoreNull",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [nunique](https://docs.dolphindb.cn/zh/funcs/n/nunique.html)\n\n\n\n#### 语法\n\nnunique(X, \\[ignoreNull=false])\n\n#### 参数\n\n**X** 是一个向量/数组向量，或包含多个等长向量的元组。\n\n**ignoreNull** 是一个布尔值，表示是否忽略 *X*中 NULL 值。若指定 *ignoreNull*=true，则统计唯一值时将不考虑 NULL 值；否则将会统计 NULL 值。默认值为 false。请注意，当 *X* 是元组或数组向量时，不可指定 *ignoreNull*=true。\n\n#### 详情\n\n*X* 是向量/数组向量时，计算 *X* 中唯一值的数量。\n\n*X* 是元组时，其内每个向量位于相同位置的元素组成一个 key，计算唯一 key 的数量。\n\n#### 例子\n\n```\nv = [1,3,1,-6,NULL,2,NULL,1];\nnunique(v);\n// output: 5\n\n//指定 ignorNull = true，统计唯一值时将不考虑 NULL 值\nnunique(v,true);\n// output: 4\n\na = array\\(INT\\[\\], 0, 10\\).append!\\(\\[1 2 3, 3 5, 6 8 8, 9 10\\]\\)\nnunique\\(a\\)\n// output: 8\n```\n\n```\nt=table(1 2 4 8 4 2 7 1 as id, 10 20 40 80 40 20 70 10 as val);\nselect nunique([id,val]) from t;\n```\n\n| nunique |\n| ------- |\n| 5       |\n\n```\ndbName = \"dfs://testdb\"\nif(existsDatabase(dbName)){\n   dropDatabase(dbName)\n}\n\ndb=database(\"dfs://testdb\", VALUE, 2012.01.11..2012.01.29)\n\nn=100\nt=table(take(2012.01.11..2012.01.29, n) as date, symbol(take(\"A\"+string(21..60), n)) as sym, take(100, n) as val)\n\npt=db.createPartitionedTable(t, `pt, `date).append!(t)\nselect nunique(date) from pt group by sym\n```\n"
    },
    "oauthLogin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/o/oauthlogin.html",
        "signatures": [
            {
                "full": "oauthLogin(oauthType, params)",
                "name": "oauthLogin",
                "parameters": [
                    {
                        "full": "oauthType",
                        "name": "oauthType"
                    },
                    {
                        "full": "params",
                        "name": "params"
                    }
                ]
            }
        ],
        "markdown": "### [oauthLogin](https://docs.dolphindb.cn/zh/funcs/o/oauthlogin.html)\n\n\n\n#### 语法\n\noauthLogin(oauthType, params)\n\n#### 详情\n\n目前 DolphinDB 已支持三种 OAuth 鉴权方式：Authentication Code（授权码模式，支持 Web）、Implicit（隐式授权模式，支持 Web）、Client Credentials（客户端凭证模式，支持 API）。该函数将根据传入的鉴权方式和鉴权参数向指定的授权服务器发送登录请求，最后返回字符串类型的 token 和用户信息。\n\n#### 参数\n\n**oauthType** 字符串标量，用来指定 OAuth 的鉴权方式。可选值如下：\n\n* 'authentication code'\n\n* 'implicit'\n\n* 'client credentials'\n\n**params** 一个字典，用来指定鉴权参数。\n\n* 若 *oauthType* 为 authentication code，则 *params* 传入{ code: string }。\n\n* 若 *oauthType* 为 implicit，则 *params* 传入{ token\\_type: string, access\\_token: string, expires\\_in?: string }。\n\n* 若 *oauthType* 为 client credentials，则 *params* 传入{ … }。\n\n#### 例子\n\n指定鉴权方式为 authentication code，同时指定对应参数，最后实现单点登录。\n\n```\noauthLogin(\"authorization\n              code\",{\"code\":\"9d823075cb151201925a\"})\n```\n\n相关信息：[单点登录](https://docs.dolphindb.cn/zh/tutorials/oauth.html)\n"
    },
    "objByName": {
        "url": "https://docs.dolphindb.cn/zh/funcs/o/objByName.html",
        "signatures": [
            {
                "full": "objByName(name, [sharedVar])",
                "name": "objByName",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[sharedVar]",
                        "name": "sharedVar",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [objByName](https://docs.dolphindb.cn/zh/funcs/o/objByName.html)\n\n\n\n#### 语法\n\nobjByName(name, \\[sharedVar])\n\n#### 参数\n\n**name** 是一个字符串，表示表名。\n\n**sharedVar** 是一个布尔值。\n\n#### 详情\n\nDolphinDB 在执行脚本之前先解析脚本。解析脚本的过程是检查变量是否在本地定义。如果没有在本地定义，则抛出异常。\n\n假设我们在本地定义一个函数，然后在远程节点上执行。这个函数会查询共享表。但是，共享表在远程节点上而不在本地节点上。如果在函数的 SQL 语句中直接调用表名，系统将不能解析脚本。\n\n为了解决这个问题，系统函数 `objByName` 在执行时会根据名称返回对象。\n\n如果没有指定 *sharedVar* 参数，系统首先搜索会话中的局部变量，再搜索共享变量。如果 *sharedVar* 为true，表示只搜索共享变量。如果 *sharedVar* 为false，表示只搜索局部变量。\n\n#### 例子\n\n假设在本地节点上有一个表 EarningsDates，它包含两列：Ticker 和 date。主机名为localhost 服务器的 8081 端口上的远程节点有一个表 USPrices。它包含所有美国股票的每日价格。我们想要从远程节点取得 EarningsDates 表中所有股票在公布收益后一周的价格。\n\n在远程节点，导入数据文件创建表 USPrices，然后在所有节点间共享。\n\n```\nUSPrices = loadText(\"c:/DolphinDB/Data/USPrices.csv\")\nshare USPrices as sharedUSPrices;\n```\n\n在本地节点，创建表 EarningsDates，然后把表和脚本发送到远程节点。执行完成后，结果会发送回本地节点。\n\n```\nEarningsDates=table(`XOM`AAPL`IBM as TICKER, 2006.10.26 2006.10.19 2006.10.17 as date)\ndef loadDailyPrice(data){\n   dateDict = dict(data.TICKER, data.date)\n   return select date, TICKER, PRC from objByName(\"sharedUSPrices\") where dateDict[TICKER]<date<=dateDict[TICKER]+7\n}\nconn = xdb(\"localhost\",8081)\nprices = conn(loadDailyPrice, EarningsDates);\n\nprices;\n```\n\n| date       | TICKER | PRC   |\n| ---------- | ------ | ----- |\n| 2006.10.27 | XOM    | 71.46 |\n| 2006.10.30 | XOM    | 70.84 |\n| 2006.10.31 | XOM    | 71.42 |\n| 2006.11.01 | XOM    | 71.06 |\n| 2006.11.02 | XOM    | 71.19 |\n| 2006.10.18 | IBM    | 89.82 |\n| 2006.10.19 | IBM    | 89.86 |\n| 2006.10.20 | IBM    | 90.48 |\n| 2006.10.23 | IBM    | 91.56 |\n| 2006.10.24 | IBM    | 91.49 |\n| 2006.10.20 | AAPL   | 79.95 |\n| 2006.10.23 | AAPL   | 81.46 |\n| 2006.10.24 | AAPL   | 81.05 |\n| 2006.10.25 | AAPL   | 81.68 |\n| 2006.10.26 | AAPL   | 82.19 |\n"
    },
    "objectChecksum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/o/objectChecksum.html",
        "signatures": [
            {
                "full": "objectChecksum(vector, [prev])",
                "name": "objectChecksum",
                "parameters": [
                    {
                        "full": "vector",
                        "name": "vector"
                    },
                    {
                        "full": "[prev]",
                        "name": "prev",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [objectChecksum](https://docs.dolphindb.cn/zh/funcs/o/objectChecksum.html)\n\n\n\n#### 语法\n\nobjectChecksum(vector, \\[prev])\n\n#### 参数\n\n**vector** 向量。用于进行校验和（checksum）计算。\n\n**prev** 整数。当 *vector* 过长时，可以通过指定 *prev* 分段迭代求完整的校验和，*prev* 表示迭代时前一段数据的校验和。\n\n#### 详情\n\n计算向量的校验和，返回一个整数。通常用于校验数据的完整性。\n\n#### 例子\n\n```\nprint objectChecksum(take(`A`B`C, 10))\n// output\n-268298654\n\nprint objectChecksum(2.3 6.5 7.8)\n// output\n-430996932\n\n// 分段计算校验和\nprint objectChecksum(1..15)\n// output\n-1877567753\n\nt0 = objectChecksum(1..5)\nt1 = objectChecksum(6..10, t0)\nt2 = objectChecksum(11..15, t1)\nprint t2\n// output\n-1877567753\n```\n"
    },
    "objs": {
        "url": "https://docs.dolphindb.cn/zh/funcs/o/objs.html",
        "signatures": [
            {
                "full": "objs([shared=false])",
                "name": "objs",
                "parameters": [
                    {
                        "full": "[shared=false]",
                        "name": "shared",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [objs](https://docs.dolphindb.cn/zh/funcs/o/objs.html)\n\n\n\n#### 语法\n\nobjs(\\[shared=false])\n\n#### 参数\n\n**shared** 布尔值，默认为 false。\n\n* false：返回当前会话中所有变量的信息；\n\n* true：返回当前会话中所有变量的信息以及所有会话共享的变量信息；\n\n#### 详情\n\n用于获取内存中缓存的各变量的内存占用情况等信息。返回一个表，它具有以下几列：\n\n* name: 变量名。\n\n* type: 变量的数据类型。\n\n* form: 变量的数据形式。\n\n* rows:\n\n  * 若 form 为向量/字典/集合，则返回所有元素（包含 NULL）的个数\n\n  * 若 form 为矩阵/表，则返回它们的行数\n\n* columns:\n\n  * 若 form 为向量/字典/集合，则返回 1\n\n  * 若 form 为矩阵/表，则返回它们的列数\n\n* bytes: 变量占用的内存大小，单位为字节\n\n* shared: 是否为共享变量\n\n* extra: 分布式表的逻辑路径，格式为 `\"dfs://dbName/tableName\"`\n\n* owner：共享变量的创建者。只有设置 shared=true 时才会显示该字段。对于本地变量，此字段值为空。\n\n注意，该函数不返回函数定义。我们应该用 defs 检查函数定义，或通过 [memSize](https://docs.dolphindb.cn/zh/funcs/m/memSize.html) 查看函数定义的内存占用。\n\n#### 例子\n\n```\n// 创建分布式数据库\nif(existsDatabase(\"dfs://listdb\")){\n        dropDatabase(\"dfs://listdb\")\n}\nn=1000000\nticker = rand(`MSFT`GOOG`FB`ORCL`IBM,n);\nticker[0..5]\nx=rand(1.0, n)\nt=table(ticker, x)\ndb=database(directory=\"dfs://listdb\", partitionType=HASH, partitionScheme=[STRING, 5])\npt=db.createPartitionedTable(t, `pt, `ticker)\npt.append!(t)\n\n// 共享内存表\ntime = take(2021.08.20 00:00:00..2021.08.30 00:00:00, 40);\nid = 0..39;\nvalue = rand(100, 40);\ntmp = table(time, id, value);\nshare tmp as st\n\n// 创建 set\ns = set([1,2,3,4,5])\n\n// 创建 dict\nx=1 2 3\ny=4.5 7.8 4.3\nz=dict(x,y);\n\n// 创建 matrix\nm = matrix(1 2 3, 4 5 6)\n\n// 创建 pair\np = 1:2\n```\n\n```\nobjs(true)\n```\n\n| name   | type     | form       | rows      | columns | bytes      | shared | extra            | owner |\n| ------ | -------- | ---------- | --------- | ------- | ---------- | ------ | ---------------- | ----- |\n| n      | INT      | SCALAR     | 1         | 1       | 16         | false  |                  |       |\n| ticker | SYMBOL   | VECTOR     | 1,000,000 | 1       | 4,000,000  | false  |                  |       |\n| x      | INT      | VECTOR     | 3         | 1       | 12         | false  |                  |       |\n| t      | BASIC    | TABLE      | 1,000,000 | 2       | 12,000,312 | false  |                  |       |\n| db     | HANDLE   | SCALAR     | 1         | 1       | 24         | false  |                  |       |\n| pt     | ALIAS    | TABLE      | 0         | 2       | 12,000,000 | false  | dfs\\://listdb/pt |       |\n| time   | DATETIME | VECTOR     | 40        | 1       | 160        | false  |                  |       |\n| id     | INT      | VECTOR     | 40        | 1       | 160        | false  |                  |       |\n| value  | INT      | VECTOR     | 40        | 1       | 160        | false  |                  |       |\n| tmp    | BASIC    | TABLE      | 40        | 3       | 832        | false  |                  |       |\n| s      | INT      | SET        | 5         | 1       | 28         | false  |                  |       |\n| y      | DOUBLE   | VECTOR     | 3         | 1       | 24         | false  |                  |       |\n| z      | DOUBLE   | DICTIONARY | 3         | 1       | 199        | false  |                  |       |\n| m      | INT      | MATRIX     | 3         | 2       | 24         | false  |                  |       |\n| p      | INT      | PAIR       | 2         | 1       | 8          | false  |                  |       |\n| st     | BASIC    | TABLE      | 40        | 3       | 832        | true   |                  | admin |\n"
    },
    "ols": {
        "url": "https://docs.dolphindb.cn/zh/funcs/o/ols.html",
        "signatures": [
            {
                "full": "ols(Y, X, [intercept=true], [mode=0], [method=\"default\"], [usePinv=true])",
                "name": "ols",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[method=\"default\"]",
                        "name": "method",
                        "optional": true,
                        "default": "\"default\""
                    },
                    {
                        "full": "[usePinv=true]",
                        "name": "usePinv",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [ols](https://docs.dolphindb.cn/zh/funcs/o/ols.html)\n\n\n\n#### 语法\n\nols(Y, X, \\[intercept=true], \\[mode=0], \\[method=\"default\"], \\[usePinv=true])\n\n#### 参数\n\n**Y** 是因变量；**X** 是自变量。\n\n**Y** 是一个向量；**X** 是一个向量、元组、矩阵或表。当 *X* 是矩阵时，如果行数等于 *Y* 的长度，*X* 的每一列都是一个因子；如果行数不等于 *Y* 的长度，并且如果列数等于 *Y* 的长度，*X* 的每一行都是一个因子。\n\n**intercept** 是一个布尔变量，表示是否包含回归中的截距。默认值是 true。当它为 true 时，系统自动给 *X* 添加一列 \"1\" 以生成截距。\n\n**mode** 是一个整数，默认值为 0，可取以下 3 个值\n\n* 0：输出一个系数估计向量\n\n* 1：输出一个具有系数估计，标准差，t 统计量和 p 值的表\n\n* 2：输出一个具有 ANOVA（方差分析）、RegressionStat（回归统计）、Cofficient（系数)）和 Residual（残差)）的字典，具体含义见下表：\n\n键 ANOVA 对应值：\n\n| Source of Variance | 自由度（Degree of freedom） | 平方和（Sum of Square） | 均方差（Mean of square） | F统计量          | Significance  |\n| ------------------ | ---------------------- | ------------------ | ------------------- | ------------- | ------------- |\n| Regression（回归）     | 变量个数（p）                | 回归平方和（SSR）         | 回归均方差（MSR=SSR/R）    | MSR 对 MSE 的比值 | 显著性，即统计出的 P 值 |\n| Residual（残差）       | 残差自由度（n-p-1）           | 残差平方和（SSE）         | 残差均方差（MSE=MSE/E）    |               |               |\n| Total              | 样本自由度                  |                    |                     |               |               |\n| 不包括常数项（n-1）        | 总离差平方和（SST）            |                    |                     |               |               |\n\n键 RegressionStat 对应值：\n\n| item         | 统计值                                                              |\n| ------------ | ---------------------------------------------------------------- |\n| R2           | R 决定系数，描述回归曲线对真实数据点拟合程度的统计量。范围在 \\[0,1]之间，越接近1 ，说明对y的解释能力越强，拟合越好。 |\n| AdjustedR2   | 经自由度修正后的决定系数，通过样本数量与模型数量对 R-squared 进行修正。                        |\n| StdError     | 回归残差标准误差，残差经自由度修正后的标准差。                                          |\n| Observations | 观察样本个数。                                                          |\n\n键 Coefficient 对应值：\n\n| 元素       | 说明               |\n| -------- | ---------------- |\n| factor   | 自变量名称            |\n| beta     | 回归系数估计值          |\n| stdError | 回归系数标准误差。        |\n| tstat    | T统计值，衡量系数的统计显著性。 |\n\n键 Residual 对应每一个预测值和实际值之间的残差。\n\n**method**是一个字符串，表示求解最小二乘问题采用的方法。\n\n* 默认值为“default”，表示采用构造系数矩阵和逆矩阵的方式求解；\n\n* 设置为“svd”，采用奇异值分解的方式。\n\n**usePinv**一个布尔值，表示计算过程中求矩阵的逆时，是否求矩阵的伪逆。\n\n* 默认值为 true，表示求矩阵的伪逆，奇异矩阵必须指定为 true。\n\n* 若为 false，表示求矩阵的逆，只适用于非奇异矩阵。\n\n#### 详情\n\n返回对 *X* 和 *Y* 计算普通最小二乘回归的结果。需要注意的是，该函数会将 *X* 和 *Y* 中的空值替换为0后进行计算。\n\n#### 例子\n\n```\nx1=1 3 5 7 11 16 23\nx2=2 8 11 34 56 54 100\ny=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\n\nols(y, x1);\n// output\n[-9.912821,3.378632]\n\nols(y, (x1,x2));\n// output\n[-9.494813,2.806426,0.13147]\n```\n\n```\nols(y, (x1,x2), 1, 1);\n```\n\n| factor    | beta      | stdError | tstat     | pvalue   |\n| --------- | --------- | -------- | --------- | -------- |\n| intercept | -9.494813 | 5.233168 | -1.814353 | 0.143818 |\n| x1        | 2.806426  | 1.830782 | 1.532911  | 0.20007  |\n| x2        | 0.13147   | 0.409081 | 0.321379  | 0.764015 |\n\n```\nols(y, (x1,x2), 1, 2);\n// output\nCoefficient->\nfactor    beta      stdError tstat     pvalue\n--------- --------- -------- --------- --------\nintercept -9.494813 5.233168 -1.814353 0.143818\nx1        2.806426  1.830782 1.532911  0.20007\nx2        0.13147   0.409081 0.321379  0.764015\n\nResidual->[6.525447,4.223774,-0.383487,-5.820153,-6.638199,-6.907387,9.000005]\nRegressionStat->\nitem         statistics\n------------ ----------\nR2           0.940241\nAdjustedR2   0.910361\nStdError     8.173444\nObservations 7\n\nANOVA->\nBreakdown  DF SS          MS          F         Significance\n---------- -- ----------- ----------- --------- ------------\nRegression 2  4204.416396 2102.208198 31.467739 0.003571\nResidual   4  267.220747  66.805187\nTotal      6  4471.637143\n```\n\n```\nx=matrix(1 4 8 2 3, 1 4 2 3 8, 1 5 1 1 5);\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 1  | 1  |\n| 4  | 4  | 5  |\n| 8  | 2  | 1  |\n| 2  | 3  | 1  |\n| 3  | 8  | 5  |\n\n```\nols(1..5, x);\n// output\n[1.156537,0.105505,0.91055,-0.697821]\n\nols(1..5, x.transpose());\n// output\n[1.156537,0.105505,0.91055,-0.697821]\n// 系统会调整因变量和自变量的维数，以便进行回归\n```\n\n```\nx = table([13.9782,13.4688,13.4336,12.9642,12.7905,13.4771,13.0423,12.6588,13.8933,13.9006] as col0, [195.3904,181.4090,180.4627,168.0723,163.5973,181.6342,170.1017,160.2477,193.0241,193.2270] as col1, [2731.2089,2443.3656,2424.2715,2178.9356,2092.4947,2447.9167,2218.5185,2028.5594,2681.7456,2685.9754] as col2)\ny = [-0.4002,-0.8004,-0.2002,-1.0002,-0.2001,-0.5001,-0.2501,0.0000,0.0000,0.0000]\n\nols(y, x, true, 0, \"default\")\n[2.968166,13.023638,-2.016390,0.076485]\n\nols(y, x, true, 0, \"svd\")\n[3266.457957,-722.195120,53.157806,-1.302769]\n```\n\n```\nx1=1 1 1\nx2=2 2 2\ny = 1 1 1\nols(y, (x1, x2))\n// output：[0.16666666666666669\t0.16666666666666669\t0.33333333333333326]\nols(y, (x1, x2), usePinv=false) \n// ERR: The input matrix is singular and cannot be inverted.\n```\n\n由于在求解过程中，参与求逆的矩阵是奇异的，因此 usePinv=false 时报错。\n"
    },
    "olsEx": {
        "url": "https://docs.dolphindb.cn/zh/funcs/o/olsEx.html",
        "signatures": [
            {
                "full": "olsEx(ds, Y, X, [intercept=true], [mode=0])",
                "name": "olsEx",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [olsEx](https://docs.dolphindb.cn/zh/funcs/o/olsEx.html)\n\n\n\n#### 语法\n\nolsEx(ds, Y, X, \\[intercept=true], \\[mode=0])\n\n#### 参数\n\n**ds** 是存储在元组中的数据源集合。它通常是由 [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html) 函数生成。\n\n**Y** 是一个字符串，表示 *ds* 表中因变量的列名。\n\n**X** 是字符串标量或向量，表示 *ds* 表中自变量的列名。\n\n**intercept** 是一个布尔变量，指示是否包含回归中的截距。默认值是 true。当它为 true 时，系统自动给 *X* 添加一列 \"1\" 以生成截距。\n\n**mode** 是一个整数，默认值为 0，取以下 3 个值之一\n\n* 0：输出一个系数估计向量\n\n* 1：输出一个具有系数估计，标准差，t统计量和p值的表\n\n* 2：输出一个具有 ANOVA（方差分析）、RegressionStat（回归统计）和 Cofficient（系数）的字典，具体含义见下表：\n\n键 ANOVA 对应值：\n\n| Source of Variance | 自由度（Degree of freedom） | 平方和（Sum of Square） | 均方差（Mean of square） | F 统计量         | Significance |\n| ------------------ | ---------------------- | ------------------ | ------------------- | ------------- | ------------ |\n| Regression（回归）     | 变量个数（p）                | 回归平方和（SSR）         | 回归均方差（MSR=SSR/R）    | MSR 对 MSE 的比值 | 显著性，即统计出的P值  |\n| Residual（残差）       | 残差自由度（n-p-1）           | 残差平方和（SSE）         | 残差均方差（MSE=MSE/E）    |               |              |\n| Total              | 样本自由度                  |                    |                     |               |              |\n| 不包括常数项（n-1）        | 总离差平方和（SST）            |                    |                     |               |              |\n\n键RegressionStat对应值：\n\n| item         | 统计值                                                              |\n| ------------ | ---------------------------------------------------------------- |\n| R2           | R 决定系数，描述回归曲线对真实数据点拟合程度的统计量。范围在 \\[0,1]之间，越接近1 ，说明对y的解释能力越强，拟合越好。 |\n| AdjustedR2   | 经自由度修正后的决定系数，通过样本数量与模型数量对 R-squared 进行修正。                        |\n| StdError     | 回归残差标准误差，残差经自由度修正后的标准差。                                          |\n| Observations | 观察样本个数。                                                          |\n\n键Coefficient对应值：\n\n| 元素       | 说明                           |\n| -------- | ---------------------------- |\n| factor   | 自变量名称                        |\n| beta     | 回归系数估计值                      |\n| stdError | 回归系数标准误差。标准差越大，回归系数的估计值越不靠谱。 |\n| tstat    | T 统计值，衡量系数的统计显著性。            |\n\n#### 详情\n\n返回对 *X* 和 *Y* 计算普通最小二乘回归的结果。*X* 和 *Y* 是分布式表中的列。\n\n**Note:**\n\n* 该函数会将 *X* 和 *Y* 中的空值替换为0后进行计算。\n\n* 因为`olsEX` 不支持输出残差，可以通过 [residual](https://docs.dolphindb.cn/zh/funcs/r/residual.html) 获取残差。\n\n#### 例子\n\n```\nn=10000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nvol=rand(1..10 join int(), n)\nprice=rand(100,n)\nt=table(ID, date, vol,price)\nsaveText(t, \"/home/DolphinDB/Data/t.txt\");\nif(existsDatabase(\"dfs://rangedb\")){\n  dropDatabase(\"dfs://rangedb\")\n}\ndb = database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 51 101)\nUSPrices=loadTextEx(dbHandle=db,tableName=`USPrices, partitionColumns=`ID, filename=\"/home/DolphinDB/Data/t.txt\");\n\nds=sqlDS(<select vol as VS, price as SBA from USPrices where vol>5>)\nrs=olsEx(ds, `VS, `SBA, true, 2)\nrs;\n\n// output\nRegressionStat->\nitem         statistics\n------------ ----------\nR2           0.000848\nAdjustedR2   0.000628\nStdError     1.404645\nObservations 4535\n\nANOVA->\nBreakdown  DF   SS          MS       F        Significance\n---------- ---- ----------- -------- -------- ------------\nRegression 1    7.592565    7.592565 3.848178 0.049861\nResidual   4533 8943.739298 1.973029\nTotal      4534 8951.331863\n\nCoefficient->\nfactor    beta     stdError tstat      pvalue\n--------- -------- -------- ---------- --------\nintercept 7.953084 0.04185  190.039423 0\nSBA       0.001422 0.000725 1.961677   0.049861\n```\n"
    },
    "oneHot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/o/oneHot.html",
        "signatures": [
            {
                "full": "oneHot(obj, encodingColumns)",
                "name": "oneHot",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "encodingColumns",
                        "name": "encodingColumns"
                    }
                ]
            }
        ],
        "markdown": "### [oneHot](https://docs.dolphindb.cn/zh/funcs/o/oneHot.html)\n\n\n\n#### 语法\n\noneHot(obj, encodingColumns)\n\n#### 参数\n\n**obj** 是一个内存表。\n\n**encodingColumns** 是一个字符串或者字符串向量，指定用于编码的列名。\n\n#### 详情\n\n对指定的列进行独热编码（one-hot），返回编码后的表，列的顺序为编码列，非编码列。其中，编码列的列名格式为：原字段名\\_值。\n\n#### 例子\n\n```\nt = table( take(`Tom`Lily`Jim, 10) as name, take(true false, 10) as gender, take(21..23,10) as age);\noneHot(t, `name`gender);\n```\n\n输出返回：\n\n| name\\_Tom | name\\_Lily | name\\_Jim | gender\\_1 | gender\\_0 | age |\n| --------- | ---------- | --------- | --------- | --------- | --- |\n| 1         | 0          | 0         | 1         | 0         | 21  |\n| 0         | 1          | 0         | 0         | 1         | 22  |\n| 0         | 0          | 1         | 1         | 0         | 23  |\n| 1         | 0          | 0         | 0         | 1         | 21  |\n| 0         | 1          | 0         | 1         | 0         | 22  |\n| 0         | 0          | 1         | 0         | 1         | 23  |\n| 1         | 0          | 0         | 1         | 0         | 21  |\n| 0         | 1          | 0         | 0         | 1         | 22  |\n| 0         | 0          | 1         | 1         | 0         | 23  |\n| 1         | 0          | 0         | 0         | 1         | 21  |\n"
    },
    "or": {
        "url": "https://docs.dolphindb.cn/zh/funcs/o/or.html",
        "signatures": [
            {
                "full": "or(X, Y)",
                "name": "or",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [or](https://docs.dolphindb.cn/zh/funcs/o/or.html)\n\n\n\n#### 语法\n\nor(X, Y) 或 X||Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量或矩阵。\n\n#### 详情\n\n按元素逐个返回 *X* 逻辑或 `(OR)Y`的结果。\n\n注意：若 `or` 或 `||` 的操作数包含 NULL 时，|| 返回的对应结果为 NULL，而 `or` 针对不同 server 版本，返回的结果不同。\n\n* 对于小于 2.00.9.4 的版本，`or` 返回的对应结果为 NULL。\n\n* 对于 2.00.9.4 及以上版本，`or` 返回的结果由配置项 *logicOrIgnoreNull* 控制，见下表：\n\n| 操作数  | 操作数  | 返回值（*logicOrIgnoreNull*= true 时） | 返回值（*logicOrIgnoreNull*= false 时） |\n| ---- | ---- | -------------------------------- | --------------------------------- |\n| 非零   | NULL | true                             | NULL                              |\n| 零    | NULL | true                             | NULL                              |\n| NULL | NULL | true                             | NULL                              |\n\n#### 例子\n\n```\n1 || 0;\n```\n\n输出返回：true\n\n```\nx=1 0 1;\nx || 0;\n```\n\n输出返回：\\[true,false,true]\n\n```\ny=0 1 0;\nx or y;\n```\n\n输出返回：\\[true,true,true]\n\n```\nt=table(1..3 as id, 4..6 as value);\nt;\n```\n\n输出返回：\n\n| id | value |\n| -- | ----- |\n| 1  | 4     |\n| 2  | 5     |\n| 3  | 6     |\n\n```\nselect id, value from t where id=2 or id=3;\n```\n\n输出返回：\n\n| id | value |\n| -- | ----- |\n| 2  | 5     |\n| 3  | 6     |\n\n相关函数：[and](https://docs.dolphindb.cn/zh/funcs/a/and.html), [not](https://docs.dolphindb.cn/zh/funcs/n/not.html)\n"
    },
    "osqp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/o/osqp.html",
        "signatures": [
            {
                "full": "osqp(q, [P], [A], [lb], [ub])",
                "name": "osqp",
                "parameters": [
                    {
                        "full": "q",
                        "name": "q"
                    },
                    {
                        "full": "[P]",
                        "name": "P",
                        "optional": true
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[lb]",
                        "name": "lb",
                        "optional": true
                    },
                    {
                        "full": "[ub]",
                        "name": "ub",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [osqp](https://docs.dolphindb.cn/zh/funcs/o/osqp.html)\n\n#### 语法\n\nosqp(q, \\[P], \\[A], \\[lb], \\[ub])\n\n#### 详情\n\n求二元目标函数在线性约束条件下的最优解。具体模型如下：\n\n![](https://docs.dolphindb.cn/zh/images/osqp.png)\n\n返回一个元组：\n\n* 第一个元素是字符串，表示求解状态：\n  * solved ：已解决\n  * solved inaccurate：已解决，但结果不精准\n  * primal infeasible：原问题无可行解\n  * dual infeasible：对偶问题无可行解\n  * maximum iterations reached：达到最大迭代次数\n  * run time limit reached：运行超时\n  * problem non convex：问题非凸\n  * interrupted：求解被中断\n  * unsolved：未解决\n* 第二个元素是数值型向量，表示目标函数取到最小值时的数值解。\n\n#### 参数\n\n* **q** 是目标函数一次项向量。\n* **P** 是目标函数的二次项矩阵，且必须是半正定矩阵。\n* **A** 是不等式约束的系数矩阵。\n* **lb** 是不等式约束的左端向量。\n* **ub** 是不等式约束的右端向量。\n\n**Note:**\n\n* *A*、*lb*、*ub* 必须同时指定或同时省略。\n* *lb* 和 *ub* 可以包含空值（NULL）,但其长度必须和A的行数匹配。 *ub/lb* 为空值时，视为正/负无穷，在计算时对应值为 ±1030。\n\n#### 例子\n\n```\nP = matrix(4e-2 6e-3 -4e-3 0.0, 6e-3 1e-2 0.0 0.0, -4e-3 0.0 2.5e-3 0.0, 0.0 0.0 0.0 0.0)\nq = [-2, -4, 2, 3]\nA = [1,3,3,-2,2,-1,1,-4,1,2,-1,-5,1,1,1,1]$4:4\nl = [,,,1.0]\nu = [3.0,2.0,-1.0,1.0]\nres = osqp(q, P, newA, l, u)\nprint(res)\n```\n\n返回：(\"solved\",\\[-64.364818313795097,368.910318139716082,-548.041799338347459,244.496302999333039])\n\n"
    },
    "pack": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pack.html",
        "signatures": [
            {
                "full": "pack(format, args...)",
                "name": "pack",
                "parameters": [
                    {
                        "full": "format",
                        "name": "format"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [pack](https://docs.dolphindb.cn/zh/funcs/p/pack.html)\n\n\n\n#### 语法\n\npack(format, args...)\n\n#### 参数\n\n**format** 格式字符串，用于指定数据格式。指定方式参见附录。关于格式字符串的说明：\n\n* 格式字符之前可以带有整数表示重复计数。 例如，格式字符串 '4h' 的含义与 'hhhh' 完全相同。\n* 格式之间的空白字符会被忽略；但是计数及其格式字符中不可有空白字符。\n* 对于 's' 格式字符，计数会被解析为字节的长度，而不是重复计数；例如，'10s' 表示一个 10 字节的字节串，而 '10c' 表示 10 个字符。 若未给出计数，则默认值为1。字节串会被适当地截断或填充空字节以符合要求。\n\n**args...** 表示需要进行打包的数据。参数个数与 *format* 的长度一致。每个参数的类型与对应位置的 *format* 类型一致。\n\n#### 详情\n\n将数据按照 *format* 指定的格式打包成二进制字节流。返回一个 bytes 对象，包含 *args* 数据按照格式字符串 *format* 打包后的值。\n\n#### 例子\n\n```\nres = pack(\"N\",1);\nres1 = unpack(\"N\", res);\nprint(res1)\n// output\n(1)\n\nres = pack(\"iii\", 1, 2, 3)\nres1 = unpack(\"iii\",  res);\nprint(res1)\n// output\n(1,2,3)\n\nres = pack(\"x\",NULL)\nres = unpack(\"x\",pack(\"x\",NULL))\ntypestr(res[0])\n// output\nVOID\n\nres = pack(\"3si\", `123, 3)\nres1 = unpack(\"3si\",  res);\nprint(res1)\n// output\n(\"123\",3)\n```\n\n#### 附录\n\n格式和类型的对应关系见格式字符与类型部分内容。\n\n默认情况下，C 类型以本机格式和字节顺序表示，在必要时通过跳过填充字节进行正确对齐（根据 C 编译器使用的规则）。\n\n格式字符串的第一个字符可用于指示打包数据的字节顺序，大小和对齐方式，见首字符字节顺序，大小和对齐方式部分内容。 如果第一个字符不是其中之一，则按 '@' 处理。\n\n相关函数：[unpack](https://docs.dolphindb.cn/zh/funcs/u/unpack.html)\n"
    },
    "pair": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pair.html",
        "signatures": [
            {
                "full": "pair(a, b)",
                "name": "pair",
                "parameters": [
                    {
                        "full": "a",
                        "name": "a"
                    },
                    {
                        "full": "b",
                        "name": "b"
                    }
                ]
            }
        ],
        "markdown": "### [pair](https://docs.dolphindb.cn/zh/funcs/p/pair.html)\n\n\n\n#### 语法\n\npair(a, b) 或 a:b\n\n#### 参数\n\n**a** 和 **b** 必须是标量。\n\n#### 详情\n\n返回一个数据对。\n\n#### 例子\n\n```\n1:3+1;\n// output\n2:4\n\n1:3<0:6;\n// output\n0 : 1\n```\n"
    },
    "panel": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/panel.html",
        "signatures": [
            {
                "full": "panel(row, col, metrics, [rowLabel], [colLabel], [parallel=false])",
                "name": "panel",
                "parameters": [
                    {
                        "full": "row",
                        "name": "row"
                    },
                    {
                        "full": "col",
                        "name": "col"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "[rowLabel]",
                        "name": "rowLabel",
                        "optional": true
                    },
                    {
                        "full": "[colLabel]",
                        "name": "colLabel",
                        "optional": true
                    },
                    {
                        "full": "[parallel=false]",
                        "name": "parallel",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [panel](https://docs.dolphindb.cn/zh/funcs/p/panel.html)\n\n\n\n#### 语法\n\npanel(row, col, metrics, \\[rowLabel], \\[colLabel], \\[parallel=false])\n\n#### 参数\n\n**row** 是一个向量，其中每个元素对应结果矩阵中的一行。\n\n**col** 是一个向量，其中每个元素对应结果矩阵中的一列。\n\n**metrics** 是一个或多个指标列。每个指标列产生一个矩阵。\n\n**rowLabel** 是一个向量，为结果矩阵的行标签。必须升序排列，而且没有重复值。结果中仅包括 *rowLabel* 中指定的行。\n\n**colLabel** 是一个向量，为结果矩阵的列标签。必须升序排列，而且没有重复值。结果中仅包括 *colLabel* 中指定的列。\n\n**parallel** 是一个布尔值，表示是否并行计算。默认值为 false。\n\n#### 详情\n\n将指标列按给定行与列维度进行透视操作，生成一个或多个矩阵。每一个矩阵对应一个指标列（metrics）。\n\n`panel` 函数同 [pivotBy](https://docs.dolphindb.cn/zh/progr/sql/pivotBy.html) 语句类似，将数据表中的数据按照两个维度重新排列。两者的不同之处在于，SQL 中，exec... pivot by... 只能指定一个指标列， 生成一个矩阵，而 `panel` 函数可以指定一个或多个指标列，生成一个或多个矩阵。\n\n#### 例子\n\n```\nt = table(1 1 2 2 2 3 3 as id, 2020.09.01 + 1 3 1 2 3 2 3 as date, 1..7 as value);\nt;\n```\n\n| id | date       | value |\n| -- | ---------- | ----- |\n| 1  | 2020.09.02 | 1     |\n| 1  | 2020.09.04 | 2     |\n| 2  | 2020.09.02 | 3     |\n| 2  | 2020.09.03 | 4     |\n| 2  | 2020.09.04 | 5     |\n| 3  | 2020.09.03 | 6     |\n| 3  | 2020.09.04 | 7     |\n\n`panel` 面板数据生成的表中，指定的 *row* 和 *col* 会自动按升序排序。\n\n```\npanel(t.date, t.id, t.value);\n```\n\n|            | 1 | 2 | 3 |\n| ---------- | - | - | - |\n| 2020.09.02 | 1 | 3 |   |\n| 2020.09.03 |   | 4 | 6 |\n| 2020.09.04 | 2 | 5 | 7 |\n\n```\npanel(t.date, t.id, t.value, 2020.09.02 2020.09.03, 1 2);\n```\n\n|            | 1 | 2 |\n| ---------- | - | - |\n| 2020.09.02 | 1 | 3 |\n| 2020.09.03 |   | 4 |\n\n```\npanel(t.date, t.id, [t.value, t.value>0], 2020.09.02 2020.09.03, 1 2);\n```\n\n|            | 1 | 2 |\n| ---------- | - | - |\n| 2020.09.02 | 1 | 3 |\n| 2020.09.03 |   | 4 |\n\n|            | 1 | 2 |\n| ---------- | - | - |\n| 2020.09.02 | 1 | 1 |\n| 2020.09.03 |   | 1 |\n\n利用`panel` 生成的矩阵，计算每只股票的累积最大股价。\n\n```\nsyms = \"sym\"+string(1..2)\ndates = 2021.12.07..2021.12.11\nt = table(loop(take{, size(syms)}, dates).flatten() as trade_date,  take(syms, size(syms)*size(dates)) as code, rand(1000, (size(syms)*size(dates))) as volume)\nvolume = panel(t.trade_date, t.code, t.volume, dates)\ncummax(volume)\n```\n"
    },
    "parseExpr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/parseExpr.html",
        "signatures": [
            {
                "full": "parseExpr(X, [varDict], [modules], [overloadedOperators])",
                "name": "parseExpr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[varDict]",
                        "name": "varDict",
                        "optional": true
                    },
                    {
                        "full": "[modules]",
                        "name": "modules",
                        "optional": true
                    },
                    {
                        "full": "[overloadedOperators]",
                        "name": "overloadedOperators",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [parseExpr](https://docs.dolphindb.cn/zh/funcs/p/parseExpr.html)\n\n\n\n#### 语法\n\nparseExpr(X, \\[varDict], \\[modules], \\[overloadedOperators])\n\n#### 参数\n\n**X** 是一个字符串标量或向量。\n\n**varDict** 为可选参数，是一个字典。如果指定了该参数，使用 [eval](https://docs.dolphindb.cn/zh/funcs/e/eval.html) 函数解析时，表达式中的变量会被解析成字典的 key，其值即为字典中该 key 所对应的 value。\n\n**modules** 为可选参数，是字符串或字符串数组，表示需要加载的模块名称。\n\n**overloadedOperators** 为可选参数，是一个字典。将运算符号映射为一个函数。key 必须是一个字符串标量，value 必须是一个二元函数。\n\n#### 详情\n\n把字符串转换为元代码。使用 [eval](https://docs.dolphindb.cn/zh/funcs/e/eval.html) 函数可以执行 `parseExpr` 函数生成的元代码。\n\n#### 例子\n\n```\na=parseExpr(\"1+2\")\na;\n// output\n< 1 + 2 >\n\ntypestr(a);\n// output\nCODE\n\na.eval();\n// output\n3\n```\n\n将 JSON 字符串解析为字典\n\n```\njson1 = '{\"f2\":10.71,\"f12\":\"000001\"},{\"f2\":7.24,\"f12\":\"000002\"}'\nparseExpr(json1).eval()\n\n/*\noutput:\nf2->10.71\nf12->000001\n*/\n```\n\n```\nt=table(1 2 3 4 as id, 5 6 7 8 as value, `IBM`MSFT`IBM`GOOG as name);\nparseExpr(\"select * from t where name='IBM'\").eval();\n```\n\n| id | value | name |\n| -- | ----- | ---- |\n| 1  | 3     | IBM  |\n| 3  | 7     | IBM  |\n\n`parseExpr` 函数解析变量时，首先搜索会话中的局部变量，再搜索共享变量，但不会搜索函数体内定义的局部变量。\n\n如下例所示，用户自定义函数 myfunc 后欲取得数据表 t3 中 ID 列1到5对应的行：\n\n```\ndef myfunc(){\n  t3 = table(1..100 as id)\n  return parseExpr(\"select * from t3 where id in 1..5\").eval()\n}\n\nmyfunc()\n```\n\n产生如下错误信息：\n\n```\nmyfunc() => myfunc: return ::evaluate(parseExpr(\"select * from t3 where id in 1..5\")) => Can't find the object with name t3\n```\n\n解决此问题可以使用 [sql](https://docs.dolphindb.cn/zh/funcs/s/sql.html) 函数动态生成 SQL 语句，如下所示：\n\n```\ndef myfunc(){\nt3 = table(1..100 as id)\nreturn sql(sqlCol(\"*\"), t3, <id in 1..5>).eval()\n}\nmyfunc();\n```\n\n| id |\n| -- |\n| 1  |\n| 2  |\n| 3  |\n| 4  |\n| 5  |\n\n表达式中的变量和值通过字典形式传入，为 dict 的 key 赋值等价于为变量赋值。\n\n```\nd = dict(`a`b`c, (1, 2, 3))\nparseExpr(\"a + b*c\", d).eval()\n// output\n7\nd[`a] = 5;\nparseExpr(\"a + b*c\", d).eval()\n// output\n11\n```\n\n下例解释表达式中使用函数的处理方式，因 dict 中未存储变量 first，first 解析时直接当作函数来处理。\n\n```\nindex = [2000.01.01, 2000.01.31, 2000.02.15, 2000.02.20, 2000.03.12, 2000.04.16, 2000.05.06, 2000.08.30]\ns = indexedSeries(index, 1..8)\nd1 =  dict(STRING, ANY)\nd1[\"S\"] = s\nparseExpr(\"resample(S, `M, first)\", d1).eval()\n```\n\n在 modules 目录下的 test 模块内定义了一个 add 函数，调用模块中的函数，同时通过 overloadedOperators 参数，将二元运算符”+”映射为一个新的函数。代码执行时，运算符”+”将按照新函数进行计算。\n\n```\nparseExpr(\"test::add(1,2)+2\", modules=\"test\", overloadedOperators={\"+\": def(a, b){return a - b}}).eval()\n// output\n1\n```\n\n相关函数：[expr](https://docs.dolphindb.cn/zh/funcs/e/expr.html), [eval](https://docs.dolphindb.cn/zh/funcs/e/eval.html)\n"
    },
    "parseInt": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/parseInt.html",
        "signatures": [
            {
                "full": "parseInteger(X, type, [radix=10])",
                "name": "parseInteger",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "type",
                        "name": "type"
                    },
                    {
                        "full": "[radix=10]",
                        "name": "radix",
                        "optional": true,
                        "default": "10"
                    }
                ]
            }
        ],
        "markdown": "### [parseInt](https://docs.dolphindb.cn/zh/funcs/p/parseInt.html)\n\n是 [parseInteger](https://docs.dolphindb.cn/zh/funcs/p/parseInteger.html) 的别名。\n\n\n以下是 `parseInteger` 函数的文档：\n### [parseInteger](https://docs.dolphindb.cn/zh/funcs/p/parseInteger.html)\n\n\n\n#### 语法\n\nparseInteger(X, type, \\[radix=10])\n\n别名：parseInt\n\n#### 参数\n\n**X** 表示待转换的字符串，支持标量、矩阵、向量和数据对。\n\n**type** 表示转换后的类型，支持 CHAR/SHORT/INT/LONG。\n\n**radix** 表示基数，可选参数，有效范围为\\[2, 16]，默认为 10。如 *radix* 为2，那么 *X* 的“合法字符”就指{“0”, “1”}；*radix* 为11，那么”合法字符”就指\\[0, 9]和 A/a（不区分大小写）。特别的，如果 *radix* 为16，那么前导的”0x”或”0X”不会被认为非法字符。\n\n#### 详情\n\n按照不同进制把字符串转换为指定的整数类型。该函数从 *X* 的第一个字符开始转换，直到遇到第一个非法字符，即返回此前的转换结果。当 X 为集合时，将输出相同类型的集合。\n\n注意：\n\n* 转换时会忽略前导空格和前导 0。\n\n* 不支持转换小数，'.'字符属于非法字符。\n\n* 如果（忽略前导空格后）字符串为空，则返回 NULL。\n\n* 如果在遇到非法字符前没有遇到过合法字符，函数将抛出异常。\n\n* 前导空格后的第一个字符可以为'+'/'-'以表示正/负语义，其余位置上的'+'/'-'为非法字符。\n\n#### 例子\n\n以下给出几个简单示例。\n\n```\nparseInteger([\" \", \"000\", \"012\", \" 12\",\"12a\", \"1a2\",\"+12a\", \"-12\"], INT)\n//output: [ , 0, 12, 12, 12, 1, 12, -12]\n\nparseInteger(\"a12\", INT)\n//Error: 'Invalid string to parse.'\n\nparseInteger([\"012\", \" 12\",\"12a\", \"1a2\",\"1A2\", \"-1A2\"], INT, 11)\n//output: [13, 13, 153, 233, 233, -233]\n\nparseInteger([\"0x16\", \"0X16\"], INT)//output:[0, 0]\n\nparseInteger([\"0x16\", \"0X16\"], INT, 16)//output:[22, 22]\n\nparseInteger( \"9\" , INT, 8)\n//Error: 'Invalid string to parse.'\n```\n"
    },
    "parseInteger": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/parseInteger.html",
        "signatures": [
            {
                "full": "parseInteger(X, type, [radix=10])",
                "name": "parseInteger",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "type",
                        "name": "type"
                    },
                    {
                        "full": "[radix=10]",
                        "name": "radix",
                        "optional": true,
                        "default": "10"
                    }
                ]
            }
        ],
        "markdown": "### [parseInteger](https://docs.dolphindb.cn/zh/funcs/p/parseInteger.html)\n\n\n\n#### 语法\n\nparseInteger(X, type, \\[radix=10])\n\n别名：parseInt\n\n#### 参数\n\n**X** 表示待转换的字符串，支持标量、矩阵、向量和数据对。\n\n**type** 表示转换后的类型，支持 CHAR/SHORT/INT/LONG。\n\n**radix** 表示基数，可选参数，有效范围为\\[2, 16]，默认为 10。如 *radix* 为2，那么 *X* 的“合法字符”就指{“0”, “1”}；*radix* 为11，那么”合法字符”就指\\[0, 9]和 A/a（不区分大小写）。特别的，如果 *radix* 为16，那么前导的”0x”或”0X”不会被认为非法字符。\n\n#### 详情\n\n按照不同进制把字符串转换为指定的整数类型。该函数从 *X* 的第一个字符开始转换，直到遇到第一个非法字符，即返回此前的转换结果。当 X 为集合时，将输出相同类型的集合。\n\n注意：\n\n* 转换时会忽略前导空格和前导 0。\n\n* 不支持转换小数，'.'字符属于非法字符。\n\n* 如果（忽略前导空格后）字符串为空，则返回 NULL。\n\n* 如果在遇到非法字符前没有遇到过合法字符，函数将抛出异常。\n\n* 前导空格后的第一个字符可以为'+'/'-'以表示正/负语义，其余位置上的'+'/'-'为非法字符。\n\n#### 例子\n\n以下给出几个简单示例。\n\n```\nparseInteger([\" \", \"000\", \"012\", \" 12\",\"12a\", \"1a2\",\"+12a\", \"-12\"], INT)\n//output: [ , 0, 12, 12, 12, 1, 12, -12]\n\nparseInteger(\"a12\", INT)\n//Error: 'Invalid string to parse.'\n\nparseInteger([\"012\", \" 12\",\"12a\", \"1a2\",\"1A2\", \"-1A2\"], INT, 11)\n//output: [13, 13, 153, 233, 233, -233]\n\nparseInteger([\"0x16\", \"0X16\"], INT)//output:[0, 0]\n\nparseInteger([\"0x16\", \"0X16\"], INT, 16)//output:[22, 22]\n\nparseInteger( \"9\" , INT, 8)\n//Error: 'Invalid string to parse.'\n```\n"
    },
    "parseJsonTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/parsejsontable.html",
        "signatures": [
            {
                "full": "parseJsonTable(json, [schema], [keyCaseSensitive=true])",
                "name": "parseJsonTable",
                "parameters": [
                    {
                        "full": "json",
                        "name": "json"
                    },
                    {
                        "full": "[schema]",
                        "name": "schema",
                        "optional": true
                    },
                    {
                        "full": "[keyCaseSensitive=true]",
                        "name": "keyCaseSensitive",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [parseJsonTable](https://docs.dolphindb.cn/zh/funcs/p/parsejsontable.html)\n\n#### 语法\n\nparseJsonTable(json, \\[schema], \\[keyCaseSensitive=true])\n\n#### 参数\n\n**json** 包含 JSON 对象的字符串标量或向量。当 *json* 是字符串标量时，可以包含1个或多个 JSON 对象。暂不支持 JSON 数组和递归 JSON 对象。\n\n**schema** 可选参数，表对象，用于指定各字段的数据类型。它可以包含以下列（必须包含 name 和 type 列）：\n\n<table id=\"table_wdv_5bs_xyb\"><thead><tr><th>\n\n列名\n\n</th><th>\n\n含义\n\n</th></tr></thead><tbody><tr><td>\n\nname\n\n</td><td>\n\n字符串，表示列名\n\n</td></tr><tr><td>\n\ntype\n\n</td><td>\n\n字符串，表示各列的数据类型。\n\n</td></tr><tr><td>\n\nformat\n\n</td><td>\n\n字符串，表示数据文件中日期或时间列的格式\n\n</td></tr></tbody>\n</table>如果不指定 *schema*，则函数将前10个 JSON 对象，自动解析表结构。\n\n**keyCaseSensitive** 可选参数，表示 key 的名称是否大小写敏感。true（默认值）表示大小写敏感，false 表示大小写不敏感。\n\n#### 详情\n\n将 JSON 对象解析为内存表。\n\n* 当 *json* 是包含多个 JSON 对象的字符串时，每个对象都将转换为表的一行数据；例如，`{\"ID\":10, \"NAME\":\"Riquelme\",\"Club\":\"Boca Juniors\"}`；\n* 当 *json* 是字符串向量时，向量中每个 json 元素转换为表的一行数据。例如，\\[json1, json2, json3]。\n* 当以上两种条件中的 json 包含空值时，即 {}，在转换后的表中，该空值所在行的位置相应留空。\n\n#### 例子\n\n```\njson1='{\"ID\":1, \"NAME\":\"cc\"}{\"NAME\":\"dd\"}'\nparseJsonTable(json1)\n```\n\n返回：\n\n| ID | NAME |\n| -- | ---- |\n| 1  | cc   |\n|    | dd   |\n\n```\njson2 = '{\"col_test\":\"20190522150407\"}'\nschemaTB = table([\"col_test\"] as name, [\"DATETIME\"] as type, [\"yyyyMMddHHmmss\"] as format)\nparseJsonTable(json2, schemaTB)\n\n```\n\n返回：\n\n| col\\_test           |\n| ------------------- |\n| 2019.05.22T15:04:07 |\n\n当 *json*是包含两个 JSON 对象的字符串时：\n\n```\njson3='{\"ID\":11, \"NAME\":\"dd\"}'\nschemaTB1 = table([\"ID\", \"NAME\", \"col_test\"] as name, [\"INT\", \"STRING\", \"DATETIME\"] as type, [,,\"yyyyMMddHHmmss\"] as format)\nparseJsonTable(concat([json2,json3]),schemaTB1)\n```\n\n返回：\n\n| ID | NAME | col\\_test           |\n| -- | ---- | ------------------- |\n|    |      | 2019.05.22T15:04:07 |\n| 11 | dd   |                     |\n\n当 *json* 是字符串向量时：\n\n```\nparseJsonTable([json2,json3],schemaTB1)\n```\n\n返回：\n\n| ID | NAME | col\\_test           |\n| -- | ---- | ------------------- |\n|    |      | 2019.05.22T15:04:07 |\n| 11 | dd   |                     |\n\n下例中定义了一个有三行数据的 json 对象 home，第三行数据为空（{}）。在第四行中，`parseJsonTable` 按照第三行中 *schemaLiga* 中定义的 *schema* 转换为名为 formation 的内存表。\n\n```\nhome = ['{\"Num\":10, \"Name\":\"Ronaldo\",\"Goal\":\"3\",\"MatchDay\":\"20120322\"}','{\"Num\":3, \"Name\":\"Carlos\",\"Goal\":\"1\",\"MatchDay\":\"20120322\"}','{}'];\nschemaLiga = table([\"Num\",\"Name\",\"Goal\",\"MatchDay\"] as name, [\"INT\",\"STRING\",\"INT\",\"DATE\"] as type, [,,,\"yyyyMMdd\"] as format);\nformation = parseJsonTable(home,schemaLiga);\nformation;\n```\n\n返回：\n\n| Num | Name    | Goal | MatchDay   |\n| --- | ------- | ---- | ---------- |\n| 10  | Ronaldo | 3    | 2012.03.22 |\n| 3   | Carlos  | 1    | 2012.03.22 |\n|     |         |      |            |\n\n打印结果显示，原属于 json 对象 home 的第三行显示为空。\n\n"
    },
    "partial": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/partial.html",
        "signatures": [
            {
                "full": "partial(func, args...)",
                "name": "partial",
                "parameters": [
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [partial](https://docs.dolphindb.cn/zh/funcs/p/partial.html)\n\n\n\n#### 语法\n\npartial(func, args...)\n\n#### 参数\n\n**func** 是 DolphinDB 中的函数。\n\n**args...** 是函数的参数。\n\n#### 详情\n\n创建一个部分应用。\n\n#### 例子\n\n```\npartial(add,1)(2);\n// output\n3\n\ndef f(a,b):a pow b\ng=partial(f, 2)\ng(3);\n// output\n8\n```\n"
    },
    "pca": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pca.html",
        "signatures": [
            {
                "full": "pca(ds, [colNames], [k], [normalize], [maxIter], [svdSolver], [randomState])",
                "name": "pca",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "[colNames]",
                        "name": "colNames",
                        "optional": true
                    },
                    {
                        "full": "[k]",
                        "name": "k",
                        "optional": true
                    },
                    {
                        "full": "[normalize]",
                        "name": "normalize",
                        "optional": true
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[svdSolver]",
                        "name": "svdSolver",
                        "optional": true
                    },
                    {
                        "full": "[randomState]",
                        "name": "randomState",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [pca](https://docs.dolphindb.cn/zh/funcs/p/pca.html)\n\n\n\n#### 语法\n\npca(ds, \\[colNames], \\[k], \\[normalize], \\[maxIter], \\[svdSolver], \\[randomState])\n\n#### 参数\n\n**ds** 是一个或多个数据源，通常由 [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html) 函数生成。\n\n**colNames** 是字符串向量，表示数据源中的列名。默认值是数据源中所有列的列名。\n\n**k** 是一个正整数，表示需要计算的主成分的个数。默认值是数据源中的列数。\n\n**normalize** 是一个布尔值，表示是否将数据减去均值再除以标准差。默认值为 false。\n\n**maxIter** 是一个正整数，表示参数 *svdSolver* =randomized 时的迭代次数。若未指定，当 *k* <0.1\\*cols 时，*maxIter* = 7，否则 *maxIter* = 4。这里 cols 表示数据源中的列数。\n\n**svdSolver** 是一个字符串，表示如何对数据源进行 svd 运算。它的取值可以是 \"full\", \"randomized\" 或 \"auto\"。*svdSolver* = \"full\" 适合 *k* 值与数据源的列数相近的情况；*svdSolver* = \"randomized\" 适合 *k* 值与数据源的列数相差较大的情况。默认值为 \"auto\"，此时系统会自动判断使用 \"full\" 还是 \"randomized\"。\n\n**randomState** 是一个整数，表示随机数种子，仅在参数 *svdSolver* =\"randomized\" 时起作用，默认为 int(time(now()))。\n\n#### 详情\n\n对数据源中指定列中的数据进行主成分分析。返回的结果是一个字典，包含以下键：\n\n* components：对应长度为 size( *colNames* )\\**k* 的主成分分析矩阵。\n* explainedVarianceRatio：对应长度为 *k* 的向量，包含前 *k* 个主成分分别解释的方差权重。\n* singularValues：对应长度为 *k* 的向量，包含主成分方差(协方差矩阵特征值)。\n\n#### 例子\n\n```\nx = [7,1,1,0,5,2]\ny = [0.7, 0.9, 0.01, 0.8, 0.09, 0.23]\nt=table(x, y)\nds = sqlDS(<select * from t>);\n\npca(ds);\n\n// output\ncomponents->\n#0        #1\n--------- ---------\n-0.999883 0.015306\n-0.015306 -0.999883\nexplainedVarianceRatio->[0.980301,0.019699]\nsingularValues->[6.110802,0.866243]\n```\n"
    },
    "pdfChiSquare": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pdfChiSquare.html",
        "signatures": [
            {
                "full": "pdfChiSquare(df, X)",
                "name": "pdfChiSquare",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [pdfChiSquare](https://docs.dolphindb.cn/zh/funcs/p/pdfChiSquare.html)\n\n\n\n#### 语法\n\npdfChiSquare(df, X)\n\n#### 参数\n\n**df**数值型标量，代表自由度参数。\n\n**X**数值型标量或向量，代表要计算概率密度的点。\n\n#### 详情\n\n计算指定卡方分布在 X 处的概率密度。\n\n其功能和用法同 scipy.stats.chi2.pdf 。\n\n#### 例子\n\n```\npdfChiSquare(df=3, X=[1,2,3])\n// output: [0.241970724519143, 0.207553748710297, 0.154180329803769]\n```\n"
    },
    "pdfF": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pdfF.html",
        "signatures": [
            {
                "full": "pdfF(numeratorDF, denominatorDF, X)",
                "name": "pdfF",
                "parameters": [
                    {
                        "full": "numeratorDF",
                        "name": "numeratorDF"
                    },
                    {
                        "full": "denominatorDF",
                        "name": "denominatorDF"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [pdfF](https://docs.dolphindb.cn/zh/funcs/p/pdfF.html)\n\n\n\n#### 语法\n\npdfF(numeratorDF, denominatorDF, X)\n\n#### 参数\n\n**numeratorDF**数值型标量，代表分子自由度。\n\n**denominatorDF**数值型标量，代表分母自由度。\n\n**X**数值型标量或向量，代表要计算概率密度的点。\n\n#### 详情\n\n计算指定 F 分布在 X 处的概率密度。\n\n其功能和用法同 scipy.stats.f.pdf 。\n\n#### 例子\n\n```\npdfF(numeratorDF=2, denominatorDF=19, X=[1,2,3])\n// output: [0.34963122778983, 0.134514942963846, 0.056045754350634]\n```\n"
    },
    "pdfNormal": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pdfNormal.html",
        "signatures": [
            {
                "full": "pdfNormal(mean, stdev, X)",
                "name": "pdfNormal",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "stdev",
                        "name": "stdev"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [pdfNormal](https://docs.dolphindb.cn/zh/funcs/p/pdfNormal.html)\n\n\n\n#### 语法\n\npdfNormal(mean, stdev, X)\n\n#### 参数\n\n**mean**数值型标量，代表正态分布的均值。\n\n**stdev**数值型标量，代表正态分布的标准差。\n\n**X**数值型标量或向量，代表要计算概率密度的点。\n\n#### 详情\n\n计算指定正态分布在 X 处的概率密度。\n\n其功能和用法同 scipy.stats.norm.pdf 。\n\n#### 例子\n\n计算标准正态分布在 X=1 处的概率密度值\n\n```\npdfNormal(mean=0, stdev=1, X=1)\n// output:0.24197072451914337\n```\n\n计算均值为1，方差为 1.5 的正态分布在 X 为 1, 2, 3 处的概率密度值\n\n```\npdfNormal(mean=1, stdev=1.5, X=[1,2,3])\n// output:[0.265961520267622,0.212965337014901,0.109340049783996]\n```\n"
    },
    "percentChange": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/percentChange.html",
        "signatures": [
            {
                "full": "percentChange(X,[n])",
                "name": "percentChange",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[n]",
                        "name": "n",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [percentChange](https://docs.dolphindb.cn/zh/funcs/p/percentChange.html)\n\n\n\n#### 语法\n\npercentChange(X,\\[n])\n\n#### 参数\n\n**X** 是一个向量或矩阵。\n\nn 为可选参数，整型，用于指定计算 X 中两个元素值变化百分比时的元素间隔数，默认值为 1。\n\n* 在不指定 n 值时，percentChange 计算相邻元素值的变化百分比；\n\n* 当 n 为大于 1 的整数时，例如，当 X = 3 4 6 9，n = 2 时，计算 X 中 6 和 3 之间、9 和 4 之间的值变化百分比，得到的结果为：\\[,,1,1.25]，即 100% 和 125%。\n\n* 当 n 为负整数时，例如， X = 3 4 6 9，n = -2 时，计算 X 中 3 和 6 之间、4 和 9 之间的值变化百分比，得到的结果为：\\[-0.5, -0.5555555555555556,,]。\n\n#### 详情\n\n计算两个元素之间的值变化比例。即，对于 *X* 中的每一个元素，计算 (Xi/ Xi-n) - 1。\n\n若 *X* 是矩阵，在每列内进行上述计算，返回一个与 *X* 维度相同的矩阵。\n\n#### 例子\n\n```\npercentChange([1,2,3]);\n//output： [,1,0.5]\n\n```\n\n```\npercentChange(85 90 95);\n//output：[,0.058824,0.055556]\n```\n\n```\nm=matrix(100 105 109 112 108 116, 200 212 208 199 206 210);\nm\n```\n\n返回：\n\n| #0  | #1  |\n| --- | --- |\n| 100 | 200 |\n| 105 | 212 |\n| 109 | 208 |\n| 112 | 199 |\n| 108 | 206 |\n| 116 | 210 |\n\n```\npercentChange(m);\n```\n\n返回：\n\n| #0                 | #1                 |\n| ------------------ | ------------------ |\n|                    |                    |\n| 0.05               | 0.06               |\n| 0.038095238095238  | -0.018867924528302 |\n| 0.027522935779817  | -0.043269230769231 |\n| -0.035714285714286 | 0.035175879396985  |\n| 0.074074074074074  | 0.019417475728155  |\n\n以下例子中，X 是一个从 1 到 10 递增的向量。n = 3，即 1 和 4 比较，2 和 5 比较， 3 和 6 比较，以此类推。\n\n```\nX = 1..10;\nn = 3;\nr = percentChange(X,n);\nprint r;\n//output: [,,,3,1.5,1,0.75,0.6,0.5,0.428571428571429]\n```\n\n以下例子中，X 是一个矩阵。\n\n```\nm=matrix(1 3 2 NULL 6 9 3, 0 8 NULL 7 6 2 8);\nn = 3;\nresult = percentChange(m,n);\nresult;\n```\n\n返回：\n\n<table id=\"table_am1_r15_x1c\"><tbody><tr><td>\n\n0\n\n</td><td>\n\n1\n\n</td></tr><tr><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n-0.25\n\n</td></tr><tr><td>\n\n3.5\n\n</td><td>\n\n</td></tr><tr><td>\n\n</td><td>\n\n0.14285714285714285\n\n</td></tr></tbody>\n</table>当 n 为负整数时，\n\n```\nx = 3 4 6 9\nn = -2\nr2= percentChange(x,n)\nr2\n```\n\n返回：\n\n<table id=\"table_epg_t15_x1c\"><tbody><tr><td>\n\n0\n\n</td><td>\n\n1\n\n</td><td>\n\n2\n\n</td><td>\n\n3\n\n</td></tr><tr><td>\n\n-0.5\n\n</td><td>\n\n-0.5555555555555556\n\n</td><td>\n\n</td><td>\n\n</td></tr></tbody>\n</table>\n"
    },
    "percentile": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/percentile.html",
        "signatures": [
            {
                "full": "percentile(X, percent, [interpolation='linear'])",
                "name": "percentile",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "percent",
                        "name": "percent"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    }
                ]
            }
        ],
        "markdown": "### [percentile](https://docs.dolphindb.cn/zh/funcs/p/percentile.html)\n\n\n\n#### 语法\n\npercentile(X, percent, \\[interpolation='linear'])\n\n#### 参数\n\n**X** 是一个向量、矩阵或表。\n\n**percent** 是 0 到 100 之间的整数或小数。\n\n**interpolation** 是一个字符串，表示当选中的分位点位于在 *X* 的第 i 和第 i+1 个元素之间时，采用的插值方法。它具有以下取值：\n\n* 'linear': ![](https://docs.dolphindb.cn/zh/images/linear.png), 其中 ![](https://docs.dolphindb.cn/zh/images/fraction.png)\n\n* 'lower': ![](https://docs.dolphindb.cn/zh/images/xi.png)\n\n* 'higher': ![higher](https://docs.dolphindb.cn/zh/images/higher.png)\n\n* 'nearest': ![](https://docs.dolphindb.cn/zh/images/xi.png)和 ![](https://docs.dolphindb.cn/zh/images/higher.png)之中最接近分位点的数据\n\n* 'midpoint': ![](https://docs.dolphindb.cn/zh/images/midpoint.png)\n\n如果没有指定 *interpolation*，默认采用 'linear'。\n\n#### 详情\n\n若 *X* 是一个向量，计算其指定的百分位数。与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n若 *X* 为矩阵，计算每列的指定的百分位数，返回一个向量。\n\n若 *X* 为表，计算每列的指定的百分位数，返回一个表。\n\n#### 例子\n\n```\na=[6, 47, 49, 15, 42, 41, 7, 39, 43, 40, 36];\n\npercentile(a,50);\n// output\n40\n\npercentile(a,54);\n// output\n40.4\n\npercentile(a,25,\"lower\");\n// output\n15\n\npercentile(a,75,\"higher\");\n// output\n43\n\npercentile(a,5,\"midpoint\");\n// output\n6.5\n\npercentile(a,5,\"nearest\");\n// output\n6\n```\n\n```\nm=matrix(1 2 5 3 4, 5 4 1 2 3);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 5  |\n| 2  | 4  |\n| 5  | 1  |\n| 3  | 2  |\n| 4  | 3  |\n\n```\npercentile(m, 75);\n[4,4]\n```\n"
    },
    "percentileRank": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/percentileRank.html",
        "signatures": [
            {
                "full": "percentileRank(X, score, [method='excel'])",
                "name": "percentileRank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "score",
                        "name": "score"
                    },
                    {
                        "full": "[method='excel']",
                        "name": "method",
                        "optional": true,
                        "default": "'excel'"
                    }
                ]
            }
        ],
        "markdown": "### [percentileRank](https://docs.dolphindb.cn/zh/funcs/p/percentileRank.html)\n\n\n\n#### 语法\n\npercentileRank(X, score, \\[method='excel'])\n\n#### 参数\n\n**X** 是一个数值型向量、矩阵或表。若为矩阵，每列计算百分位，输出一个向量。若为表，每列计算百分位，输出一个表。\n\n**score** 是一个数值型标量，表示需要得到其排位的值。\n\n**method** 是一个字符串，表示计算百分位的方法，包含以下取值，默认值为 \"excel\"：\n\n* \"excel\"：小于 *score* 的元素个数占不等于 *score* 的元素个数的百分比；若 *score* 不在 *X* 中，其百分位计算公式为：\n\n![](https://docs.dolphindb.cn/zh/images/pscore.png)\n\n其中，![xi](https://docs.dolphindb.cn/zh/images/xi.png) 和 ![xp1](https://docs.dolphindb.cn/zh/images/xp1.png) 为数据集X中的紧邻score的前、后两个数值， ![pi](https://docs.dolphindb.cn/zh/images/pi.png)和 ![pi1](https://docs.dolphindb.cn/zh/images/pi1.png)分别为![xi](https://docs.dolphindb.cn/zh/images/xi.png) 和![xp1](https://docs.dolphindb.cn/zh/images/xp1.png)的百分位。\n\n* \"rank\"：小于等于 *score* 的元素个数占元素总数的百分比。当有多个值相等的 *score* 时，取它们百分位的平均值；\n\n* \"strict\"：严格小于 *score* 的元素个数占元素总数的百分比；\n\n* \"weak\"：小于等于 *score* 的元素个数占元素总数的百分比；\n\n* \"mean\"：\"strict\" 和 \"weak\" 的平均值。\n\n#### 详情\n\n计算一个数值在数值向量中的百分位数（0\\~100）。计算时忽略 NULL 值。\n\n#### 例子\n\n```\na = 2 3 4 4 5;\npercentileRank(a, 4);\n// output: 66.666667\npercentileRank(a, 3);\n// output: 25\npercentileRank(a, 4, \"rank\");\n// output: 70\npercentileRank(a,4,\"weak\");\n// output: 80\npercentileRank(a,5,\"strict\");\n// output: 40\npercentileRank(a,5,\"mean\");\n// output: 60\n\npercentileRank(1 5 8, 6, \"excel\")\n// output: 66.666667\n```\n"
    },
    "piecewiseLinFit": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/piecewiselinfit.html",
        "signatures": [
            {
                "full": "piecewiseLinFit(X, Y, numSegments, [XC], [YC], [bounds], [lapackDriver='gelsd'], [degree=1], [weights], [method='de'], [maxIter], [initialGuess], [seed])",
                "name": "piecewiseLinFit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "numSegments",
                        "name": "numSegments"
                    },
                    {
                        "full": "[XC]",
                        "name": "XC",
                        "optional": true
                    },
                    {
                        "full": "[YC]",
                        "name": "YC",
                        "optional": true
                    },
                    {
                        "full": "[bounds]",
                        "name": "bounds",
                        "optional": true
                    },
                    {
                        "full": "[lapackDriver='gelsd']",
                        "name": "lapackDriver",
                        "optional": true,
                        "default": "'gelsd'"
                    },
                    {
                        "full": "[degree=1]",
                        "name": "degree",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[weights]",
                        "name": "weights",
                        "optional": true
                    },
                    {
                        "full": "[method='de']",
                        "name": "method",
                        "optional": true,
                        "default": "'de'"
                    },
                    {
                        "full": "[maxIter]",
                        "name": "maxIter",
                        "optional": true
                    },
                    {
                        "full": "[initialGuess]",
                        "name": "initialGuess",
                        "optional": true
                    },
                    {
                        "full": "[seed]",
                        "name": "seed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [piecewiseLinFit](https://docs.dolphindb.cn/zh/funcs/p/piecewiselinfit.html)\n\n\n\n#### 语法\n\npiecewiseLinFit(X, Y, numSegments, \\[XC], \\[YC], \\[bounds], \\[lapackDriver='gelsd'], \\[degree=1], \\[weights], \\[method='de'], \\[maxIter], \\[initialGuess], \\[seed])\n\n#### 详情\n\n通过给定数据点集和给定线段数，拟合一个连续的分段线性回归函数；并使用差分进化算法通过最小化平方误差之和，找到给定数量的线段断点的最优位置。\n\n注意：由于差分进化算法的随机性，本函数每次运行结果会略有区别。\n\n#### 参数\n\n**X** 数值向量，表示数据点的 x 坐标值。仅在 *method*='de' 时生效。注意：不可传入 NULL 值。\n\n**Y** 数值向量，表示数据点的 y 坐标值。仅在 *method*='de' 时生效。注意：不可传入 NULL 值。\n\n**numSegments** 正整数，表示用于拟合的线段数量。\n\n**XC** 可选参数，数值向量，表示分段线性函数将被强制通过的数据点的 x 位置。\n\n**YC** 可选参数，数值向量，表示分段线性函数将被强制通过的数据点的 y 位置。\n\n**bounds** 可选参数，数值矩阵，表示在优化中每个断点位置的边界。形状为(numSegments - 1, 2)，每一行为对应断点的边界。\n\n**lapackDriver** 可选参数，字符串标量，表示使用具体的某个 LAPACK 程序来求解最小二乘问题。可选值为'gelsd', 'gelsy' 和 'gelss'。\n\n**degree** 可选参数，非负整数标量，表示要使用的多项式的阶数。degree=1 表示使用线性模型；degree=0 表示使用常数模型。\n\n**weights**可选参数，数值向量，表示加权最小二乘法中的权重。单个权重通常是每个数据点标准偏差的倒数，即 *weights\\[i]* 为第 i 个数据点标准差的倒数。注意：不可传入 NULL 值。\n\n**method** 可选参数，字符串标量，表示在拟合过程中使用的最优化算法。可选值为：\n\n* “nm“：表示使用 Nelder-Mead 单纯形算法。\n\n* “bfgs“：表示使用 bfgs 算法。\n\n* “lbfgs“ ：表示使用 lbfgs 算法。\n\n* 'slsqp'：表示顺序最小二乘编程方法（SLSQP）算法。\n\n* 'de'：表示差分进化(Differential Evolution)算法，默认值。\n\n**maxIter** 可选参数，整型标量或向量，表示拟合过程中优化算法的最大迭代次数。\n\n**initialGuess** 可选参数，数值向量，表示分段断点位置的初始猜测，长度为 *numSegments* - 1。\n\n**seed** 可选参数，整数标量，表示差分进化算法中使用的随机数种子，仅在 *method*='de' 或 *initialGuess* 为空时生效。若 *method*='de' 或 *initialGuess* 为空，且不指定 *seed*，则采用非确定性的随机数生成器。*seed* 参数用于确保结果的可复现性。\n\n#### 返回值\n\n返回一个字典，字典有以下成员：\n\n* breaks：浮点数向量，表示模型拟合后得到的线段断点位置。\n\n* beta：浮点数向量，表示模型拟合后的参数值。\n\n* xData：浮点数向量，表示输入的数据点的 x 坐标值。\n\n* yData：浮点数向量，表示输入的数据点的 y 坐标值。\n\n* XC：浮点数向量，表示分段线性函数将被强制通过的数据点的 x 位置。\n\n* YC：浮点数向量，表示分段线性函数将被强制通过的数据点的 y 位置。\n\n* weights：浮点数向量，表示加权最小二乘法中的权重。\n\n* degree：整数标量，表示要使用的多项式的阶数。\n\n* lapackDriver：字符串标量，表示使用的具体 LAPACK 程序来求解最小二乘问题。\n\n* numParameters：整数标量，表示模型的参数数量。\n\n* predict：模型的预测函数。其使用方法为 `model.predict(X, [beta], [breaks])`，详情见 [pwlfPredict](https://docs.dolphindb.cn/zh/funcs/p/pwlfpredict.html)。\n\n* modelName：表示模型类型，值为字符串”Piecewise Linear Regression”。\n\n#### 例子\n\n本例自定义条件，传入参数 *X*, *Y*, *numSegments*，拟合一个连续的分段线性回归函数，并找到 3 个线段断点的最优位置。\n\n```\ndef linspace(start, end, num, endpoint=true){\n\tif(endpoint) return end$DOUBLE\\(num-1), start + end$DOUBLE\\(num-1)*0..(num-1)\n\telse return start + end$DOUBLE\\(num-1)*0..(num-1)\t\n}\nX = linspace(0.0, 1.0, 10)[1]\nY = [0.41703981, 0.80028691, 0.12593987, 0.58373723, 0.77572962, 0.41156172, 0.72300284, 0.32559528, 0.21812564, 0.41776427]\nmodel = piecewiseLinFit(X, Y, 3)\nmodel;\n\n/* Output:\nbreaks->[0.0,0.258454644769,0.366954310101,1.000000000000]\nnumParameters->4\ndegree->1\nxData->[0.0,0.111111111111,0.222222222222,0.333333333333,0.444444444444,0.555555555555,0.666666666666,0.777777777777,0.888888888888,1.000000000000]\npredict->pwlfPredict\nyData->[0.417039810000,0.800286910000,0.125939870000,0.583737230000,0.775729620000,0.411561720000,0.723002840000,0.325595280000,0.218125640000,0.417764270000]\nyC->\nxC->\nweights->\nbeta->[0.593305500750,-1.309949743583,5.703647584013,-5.105351630664]\nlapackDriver->gelsd\n*/\n```\n\n承接上例，`piecewiseLinFit` 也可结合函数 `pwlfPredict` 使用。如下自定义参数，使用拟合后的连续分段线性回归模型来对输入的数据点进行预测。\n\n```\nxHat = linspace(0.0, 1.0, 20)[1]\nmodel.predict(xHat)\n\n/* Output:\n[0.593305499919518 0.524360777381737 0.455416054843957 0.386471332306177 0.317526609768396 0.368043438179296 0.529813781212159 0.691584124245021 0.69295837868457  0.655502915538459 0.618047452392347 0.580591989246236 0.543136526100125 0.505681062954014 0.468225599807903 0.430770136661792 0.393314673515681 0.35585921036957  0.318403747223459 0.280948284077348]\n*/\n```\n\n相关函数：[pwlfPredict](https://docs.dolphindb.cn/zh/funcs/p/pwlfpredict.html)\n"
    },
    "pinverse": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pinverse.html",
        "signatures": [
            {
                "full": "pinverse(X)",
                "name": "pinverse",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [pinverse](https://docs.dolphindb.cn/zh/funcs/p/pinverse.html)\n\n#### 语法\n\npinverse(X)\n\n别名：pinv\n\n#### 详情\n\n计算矩阵 *X* 的伪逆矩阵。\n\n返回值：双精度浮点矩阵（FAST DOUBLE MATRIX）\n\n#### 参数\n\n`X` 是一个矩阵。\n\n#### 例子\n\n```\nx=1..42:2;\nx.pinverse()\n```\n\n<table id=\"table_wgt_2sz_x1c\"><thead><tr><th>\n\ncol1\n\n</th><th>\n\ncol2\n\n</th></tr></thead><tbody><tr><td>\n\n-2\n\n</td><td>\n\n1.5\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\n-0.5\n\n</td></tr></tbody>\n</table>```\ny=1..82:4\ny.pinverse(); \n```\n\n<table id=\"table_hjm_hsz_x1c\"><thead><tr><th>\n\ncol1\n\n</th><th>\n\ncol2\n\n</th></tr></thead><tbody><tr><td>\n\n-1\n\n</td><td>\n\n0.85\n\n</td></tr><tr><td>\n\n-0.5\n\n</td><td>\n\n0.45\n\n</td></tr><tr><td>\n\n0\n\n</td><td>\n\n0.05\n\n</td></tr><tr><td>\n\n0.5\n\n</td><td>\n\n-0.35\n\n</td></tr></tbody>\n</table>```\ns1 = indexedSeries(2012.01.01..2012.01.04, [10, 20, 30, 40])\npinv(s1)\n```\n\n<table id=\"table_alv_jsz_x1c\"><thead><tr><th>\n\ncol1\n\n</th><th>\n\ncol2\n\n</th><th>\n\ncol3\n\n</th><th>\n\ncol4\n\n</th></tr></thead><tbody><tr><td>\n\n0.0033\n\n</td><td>\n\n0.0067\n\n</td><td>\n\n0.01\n\n</td><td>\n\n0.0133\n\n</td></tr></tbody>\n</table>```\nm=matrix(1..10, 11..20)\nm.rename!(2020.01.01..2020.01.10, `A`B);\nm.setIndexedMatrix!()\npinv(m)\n```\n\n<table id=\"table_hh5_lsz_x1c\"><thead><tr><th>\n\ncol1\n\n</th><th>\n\ncol2\n\n</th><th>\n\ncol3\n\n</th><th>\n\ncol4\n\n</th><th>\n\ncol5\n\n</th><th>\n\ncol6\n\n</th><th>\n\ncol7\n\n</th><th>\n\ncol8\n\n</th><th>\n\ncol9\n\n</th><th>\n\ncol10\n\n</th></tr></thead><tbody><tr><td>\n\n-0.0945\n\n</td><td>\n\n-0.0758\n\n</td><td>\n\n-0.057\n\n</td><td>\n\n-0.0382\n\n</td><td>\n\n-0.0194\n\n</td><td>\n\n-0.0006\n\n</td><td>\n\n0.0182\n\n</td><td>\n\n0.037\n\n</td><td>\n\n0.0558\n\n</td><td>\n\n0.0745\n\n</td></tr><tr><td>\n\n0.04\n\n</td><td>\n\n0.0333\n\n</td><td>\n\n0.0267\n\n</td><td>\n\n0.02\n\n</td><td>\n\n0.0133\n\n</td><td>\n\n0.0067\n\n</td><td>\n\n0\n\n</td><td>\n\n-0.0067\n\n</td><td>\n\n-0.0133\n\n</td><td>\n\n-0.02\n\n</td></tr></tbody>\n</table>当矩阵非满秩时，使用计算逆矩阵（inverse）会报错，此时可以计算伪逆矩阵（pinverse ）。\n\n```\nx=1 2 3 1 2 3$2:3\ninverse(x) //报错 The argument of 'inverse' must be a square matrix.\npinverse(x)\n```\n\n| col1    | col2    |\n| ------- | ------- |\n| -0.1067 | 0.2267  |\n| 0.4133  | -0.2533 |\n| -0.0667 | 0.2667  |\n\n相关函数：[inverse](https://docs.dolphindb.cn/zh/funcs/i/inverse.html)\n\n"
    },
    "pipeline": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pipeline.html",
        "signatures": [
            {
                "full": "pipeline(initTasks, followers, [queueDepth=2])",
                "name": "pipeline",
                "parameters": [
                    {
                        "full": "initTasks",
                        "name": "initTasks"
                    },
                    {
                        "full": "followers",
                        "name": "followers"
                    },
                    {
                        "full": "[queueDepth=2]",
                        "name": "queueDepth",
                        "optional": true,
                        "default": "2"
                    }
                ]
            }
        ],
        "markdown": "### [pipeline](https://docs.dolphindb.cn/zh/funcs/p/pipeline.html)\n\n\n\n#### 语法\n\npipeline(initTasks, followers, \\[queueDepth=2])\n\n#### 参数\n\n**initTasks** 是所有任务初始步骤的集合，其中每个任务都是由无参数的函数表示。例如，我们有10个任务，那么 *initTasks* 是一个包含10个无参数函数的元组。\n\n**followers** 是一元函数的集合，每个函数代表初始步骤之后的一个步骤。如果一个任务有 N 个步骤，*followers* 具有N-1个一元函数。*followers* 的输出是下一个 *followers* 的输入。最后一个 *followers* 有可能返回一个对象。任务的初始步骤是在主线程（接受任务的线程）中执行的，剩下的步骤在单独的线程中执行。如果 `pipeline` 函数用于执行 N 个步骤的任务，系统会创建 N-1 个线程并且这些线程会在工作完成后销毁。\n\n**queueDepth** 是队列的最大长度。每个步骤的中间结果保存在队列中，用于下一个步骤。若队列满了，执行会中止，直到下一个步骤使用了队列中的数据。队列的长度越长，下一个步骤的等待时间越短。但是，长的队列会占用更多内存。*queueDepth* 的默认值是2。\n\n#### 详情\n\n通过多线程优化符合如下条件的任务：\n\n(1) 可分解为多个子任务。\n\n(2) 每个子任务包含多个步骤。\n\n(3) 第i个子任务的第 k 个步骤必须在第i个子任务的第 k-1 个步骤以及第 i-1 个子任务的第 k 个步骤完成后才能执行。\n\n如果最后一个步骤返回一个对象，`pipeline` 函数返回一个元组，否则不返回任何内容。\n\n#### 例子\n\n下例中，需要把分区表 stockData 转换成一个 csv 文件。该表包含了2008年到2018年的数据，超过了系统的可用内存，因此不能把整个表加载到内存后，再转换成 csv 文件。可把任务分为多个子任务，每个子任务包含两个步骤：加载一个月的数据到内存，然后将这些数据存储到 csv 文件中。每个月的数据存储到 csv 文件中时，必须保证该月数据已加载到内存，并且上个月的数据已经存储到 csv 文件中。\n\n```\nv = 2000.01M..2018.12M\ndef loadData(m){\nreturn select * from loadTable(\"dfs://stockDB\", \"stockData\") where TradingTime between datetime(date(m)) : datetime(date(m+1))\n}\n\ndef saveData(tb){\ntb.saveText(\"/hdd/hdd0/data/stockData.csv\",',', true)\n}\n\npipeline(each(partial{loadData}, v),saveData);\n```\n"
    },
    "ploadText": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/ploadText.html",
        "signatures": [
            {
                "full": "ploadText(filename, [delimiter], [schema], [skipRows=0], [arrayDelimiter], [containHeader], [arrayMarker])",
                "name": "ploadText",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    },
                    {
                        "full": "[schema]",
                        "name": "schema",
                        "optional": true
                    },
                    {
                        "full": "[skipRows=0]",
                        "name": "skipRows",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[arrayDelimiter]",
                        "name": "arrayDelimiter",
                        "optional": true
                    },
                    {
                        "full": "[containHeader]",
                        "name": "containHeader",
                        "optional": true
                    },
                    {
                        "full": "[arrayMarker]",
                        "name": "arrayMarker",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ploadText](https://docs.dolphindb.cn/zh/funcs/p/ploadText.html)\n\n\n\n#### 语法\n\nploadText(filename, \\[delimiter], \\[schema], \\[skipRows=0], \\[arrayDelimiter], \\[containHeader], \\[arrayMarker])\n\n#### 参数\n\n参数与 [loadText](https://docs.dolphindb.cn/zh/funcs/l/loadText.html) 相同。\n\n#### 详情\n\n将数据文件并行加载到内存中。当文件大于 16MB 时，`ploadText` 返回一个顺序分区的内存表；否则返回一个普通内存表。\n\n**Note:**\n\n* `ploadText` 返回的分区表数据均匀分配到各个分区，且每个分区中的数据量介于8MB与16MB之间。\n\n* 与 [loadText](https://docs.dolphindb.cn/zh/funcs/l/loadText.html) 函数相比，进行并行加载时，`ploadText` 速度更快。\n\n* * 从 2.00.10 版本开始，`loadText` 支持加载一条记录中包含多个换行符的数据文件。\n\n#### 例子\n\n```\nn=1000000\ntimestamp=09:30:00+rand(18000,n)\nID=rand(100,n)\nqty=100*(1+rand(100,n))\nprice=5.0+rand(100.0,n)\nt1 = table(timestamp,ID,qty,price)\nsaveText(t1, \"C:/DolphinDB/Data/t1.txt\");\n\ntimer tt1=loadText(\"C:/DolphinDB/Data/t1.txt\");\n// output\nTime elapsed: 437.236 ms\n\ntimer tt2=ploadText(\"C:/DolphinDB/Data/t1.txt\");\n// output\nTime elapsed: 241.126 ms\n\ntypestr(tt2);\n// output\nSEGMENTED IN-MEMORY TABLE\n```\n\n更多例子请参考 [loadText](https://docs.dolphindb.cn/zh/funcs/l/loadText.html)。\n"
    },
    "plot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/plot.html",
        "signatures": [
            {
                "full": "plot(data, [labels], [title], [chartType=LINE], [stacking=false], [extras])",
                "name": "plot",
                "parameters": [
                    {
                        "full": "data",
                        "name": "data"
                    },
                    {
                        "full": "[labels]",
                        "name": "labels",
                        "optional": true
                    },
                    {
                        "full": "[title]",
                        "name": "title",
                        "optional": true
                    },
                    {
                        "full": "[chartType=LINE]",
                        "name": "chartType",
                        "optional": true,
                        "default": "LINE"
                    },
                    {
                        "full": "[stacking=false]",
                        "name": "stacking",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[extras]",
                        "name": "extras",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [plot](https://docs.dolphindb.cn/zh/funcs/p/plot.html)\n\n\n\n#### 语法\n\nplot(data, \\[labels], \\[title], \\[chartType=LINE], \\[stacking=false], \\[extras])\n\n#### 详情\n\n生成图表对象的系统函数。当我们在 IDE 中使用绘图功能时，GUI 将生成图表对象。\n\n#### 参数\n\n**data** 可以是向量，元组，矩阵或表。\n\n如果输入数据是一个向量，它会产生一个单一的系列图，而向量名称就是系列名称。\n\n如果输入数据是元组，则元组的每个元素被视为一个系列。元组的元素必须都是相同长度的向量。向量的名称是系列名称。\n\n如果输入数据是一个矩阵，则矩阵的每一列都是一个系列，矩阵的列标签是系列名称。如果矩阵具有行标签，则它们将被用作数据点标签。\n\n如果输入数据是一个表，那么表的每一列都是一个系列，列名是系列名。\n\n**labels** 是每个数据点的标签。所有系列的图表共享相同的数据标签。如果输入是矩阵，则可以将矩阵的行标签设置为数据点标签。否则，必须在此指定数据点标签。\n\n**title** 可以是字符串标量或字符串向量。如果标题是标量，则是图表标题; 如果是矢量，矢量的第一个元素是图表标题，第二个是X轴标题，第三个是Y轴标题。\n\n**chartType** 表示图表类型，默认值是线性图（LINE）。其他类型还有饼图（PIE），柱形图（COLUMN），条形图（BAR），面积图（AREA）和散点图（SCATTER）。\n\n**stacking** 表示图表是否堆叠。当 *chartType* 设置为LINE、BAR 或 AREA 时，该参数才有效。\n\n**extras** 为可选参数，用于扩展 `plot` 函数的属性。*extras* 必须是字典，其 key 必须是字符串类型。\n\n**Note:**\n\n* 目前仅支持 multiYAxes 属性：{multiYAxes: true}。设置为 true 表示支持多个 Y 轴，设置为 false 表示共享一个 Y 轴。若需要使用 extras 添加新的属性名称和类型，请联系我们进行报备。\n\n* *chartType*=LINE 时，必须设置该参数的 multiYAxes 属性。\n\n#### 例子\n\nExample 1：表\n\n```\nx=0.1*(1..100)\ny=0.1*(100..1)\nt=table(x,y)\nplot(t,extras={multiYAxes: true})\n```\n\n![](https://docs.dolphindb.cn/zh/images/plot01.png)\n\n上面的图也可以用 `plot(t[`x`y],extras={multiYAxes:true})` 生成。\n\nExample 2：矩阵\n\n```\nplot([sin,cos](x),x,\"cos and sin curve\",extras={multiYAxes: false})\n```\n\n![](https://docs.dolphindb.cn/zh/images/plot02.png)\n\n请注意，把函数名作为系列名称，并且指定了数据标志和图的标题。\n\nExample 3：向量\n\n```\nplot(cumsum(x) as cumsumX, 2012.10.01+1..100, \"cumulative sum of x\")\n```\n\n![](https://docs.dolphindb.cn/zh/images/plot03.png)\n\ncumsumX 被用作系列名称。\n\nExample 4：元组\n\n```\nplot([1..10 as x, 10..1 as y], 1..10, extras={multiYAxes: false})\n```\n\n![](https://docs.dolphindb.cn/zh/images/plot04.png)\n\nx 和 y 被用作系列名称。\n\nExample 5：条形图\n\n```\nplot(1..5 as value, `IBM`MSFT`GOOG`XOM`C, `rank, BAR)\n```\n\n![](https://docs.dolphindb.cn/zh/images/plot05.png)\n\nExample 6：柱形图\n\n```\nplot(99 128 196 210 312 as sales, `IBM`MSFT`GOOG`XOM`C, `sales, COLUMN)\n```\n\n![](https://docs.dolphindb.cn/zh/images/plot06.png)\n\nExample 7：饼状图\n\n```\nplot(99 128 196 210 312 as sales, `IBM`MSFT`GOOG`XOM`C, `sales, PIE)\n```\n\n![](https://docs.dolphindb.cn/zh/images/plot07.png)\n\nExample 8：散点图\n\n```\nx=rand(1.0, 1000);\ny=x+norm(0.0, 0.2, 1000);\nplot(x, y, ,SCATTER)\n```\n\n![](https://docs.dolphindb.cn/zh/images/plot08.png)\n\nExample 9：设置 {multiYAxes : true}, y1, y2 和 y3 分别对应不同的Y轴\n\n```\nt = table(1 2 3 4 5 as y1, 1200 1300 1400 1500 1600 as y2, 100 300 500 800 900 as y3, 10 20 30 40 50 as date)\nplot([t.y1, t.y2,t.y3], t.date, , LINE, ,  {multiYAxes : true})\n```\n\n![](https://docs.dolphindb.cn/zh/images/plot09.png)\n"
    },
    "plotHist": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/plotHist.html",
        "signatures": [
            {
                "full": "plotHist(data, [binNum], [range], [title])",
                "name": "plotHist",
                "parameters": [
                    {
                        "full": "data",
                        "name": "data"
                    },
                    {
                        "full": "[binNum]",
                        "name": "binNum",
                        "optional": true
                    },
                    {
                        "full": "[range]",
                        "name": "range",
                        "optional": true
                    },
                    {
                        "full": "[title]",
                        "name": "title",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [plotHist](https://docs.dolphindb.cn/zh/funcs/p/plotHist.html)\n\n\n\n#### 语法\n\nplotHist(data, \\[binNum], \\[range], \\[title])\n\n#### 参数\n\n**data** 可以是向量，矩阵或表列。\n\n**binNum** 是柱状图显示的柱数。\n\n**range** 是表示柱状图的数据范围的数据对。\n\n**title** 是图表的标题。\n\n#### 详情\n\n生成柱状图图表对象的系统函数。\n\n#### 例子\n\n```\nx=norm(0.0, 1.0, 10000);\nplotHist(x, 10)\n```\n\n![plothist1](https://docs.dolphindb.cn/zh/images/plotHist01.png)\n\n```\nplotHist(x, 10, -2:2)\n```\n\n![plothist2](https://docs.dolphindb.cn/zh/images/plotHist02.png)\n"
    },
    "pnodeRun": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pnodeRun.html",
        "signatures": [
            {
                "full": "pnodeRun(function, [nodes], [addNodeAlias=true])",
                "name": "pnodeRun",
                "parameters": [
                    {
                        "full": "function",
                        "name": "function"
                    },
                    {
                        "full": "[nodes]",
                        "name": "nodes",
                        "optional": true
                    },
                    {
                        "full": "[addNodeAlias=true]",
                        "name": "addNodeAlias",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [pnodeRun](https://docs.dolphindb.cn/zh/funcs/p/pnodeRun.html)\n\n\n\n#### 语法\n\npnodeRun(function, \\[nodes], \\[addNodeAlias=true])\n\n#### 参数\n\n**function** 调用的本地函数（不能使用引号）。它可以是一个没有定义参数的函数，或者是没有参数的封装了初始函数和参数的部分应用。它可以是内置函数或用户自定义函数。\n\n**nodes** 可选参数，字符串标量或向量，表示节点的别名。\n\n**addNodeAlias** 是否在结果中加入节点的别名，默认值是 true。如果返回的结果已经包含节点的别名，可设置为false。\n\n#### 详情\n\n在集群指定节点或所有数据节点/计算节点上并行调用本地函数，然后合并结果。\n\n* 当指定 *nodes* 参数时，在指定的节点上调用本地函数。\n\n* 当未指定*nodes* 参数时：若在指定了计算组的计算节点上执行该函数时，仅会在同组内的所有计算节点上调用本地函数；否则，在集群中所有的数据节点、未指定计算组的计算节点上调用本地函数。\n\n#### 例子\n\n例1. 函数 getChunksMeta 不指定参数。\n\n```\npnodeRun(getChunksMeta,,false);\n```\n\n| site      | chunkId                              | path                                                                      | dfsPath              | type | flag | size | version | state | versionList              |\n| --------- | ------------------------------------ | ------------------------------------------------------------------------- | -------------------- | ---- | ---- | ---- | ------- | ----- | ------------------------ |\n| local8848 | bd13090e-7177-01a7-4ac4-840e1b977dcf | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190605/GOOG | /compo/20190605/GOOG | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6729; # |\n| local8848 | b4935730-6372-b2a1-4f24-6c323037e576 | e:data/CHUNKS/compo/20190605/AAPL                                         | /compo/20190605/AAPL | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6613; # |\n| local8848 | f8ee72c9-dad3-f49e-430e-5ddb3c61ae18 | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190604/MSFT | /compo/20190604/MSFT | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6664; # |\n| local8848 | 08e26b5a-dfac-799f-4979-0dd3902eae6e | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190604/GOOG | /compo/20190604/GOOG | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6635; # |\n| local8848 | f9e53a3d-af3e-018d-4bfa-a2b4980f3561 | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190604/AAPL | /compo/20190604/AAPL | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6783; # |\n| local8848 | 417e49e9-5c61-cf9e-4b21-4b35f8e57273 | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190601/MSFT | /compo/20190601/MSFT | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6602; # |\n| local8848 | 3ee64942-1d72-bea7-4bc1-f720132d9288 | D:130DolphinDB\\_Win64\\_Vserverlocal8848storage/CHUNKS/compo/20190602/AAPL | /compo/20190602/AAPL | 1    | 0    | 0    | 1       | 0     | cid : 40,pt2=>40:6749; # |\n\n例2. 在下例中，函数 sum 和参数1..10被封装成了部分应用 sum{1..10}。\n\n```\npnodeRun(sum{1..10}, `nodeA`nodeB);\n```\n\n| Node       | Value |\n| ---------- | ----- |\n| DFS\\_NODE2 | 55    |\n| DFS\\_NODE3 | 55    |\n\n例3. `pnodeRun` 对于集群管理非常方便。例如，在一个集群中有4个节点：\"DFS\\_NODE1\", \"DFS\\_NODE2\", \"DFS\\_NODE3\" 和 \"DFS\\_NODE4\"。在每个节点上执行以下脚本：\n\n```\ndef jobDemo(n){\n  s = 0\n  for (x in 1 : n) {\n      s += sum(sin rand(1.0, 100000000)-0.5)\n      print(\"iteration \" + x + \" \" + s)\n  }\n  return s\n};\n\nsubmitJob(\"jobDemo1\",\"job demo\", jobDemo, 10);\nsubmitJob(\"jobDemo2\",\"job demo\", jobDemo, 10);\nsubmitJob(\"jobDemo3\",\"job demo\", jobDemo, 10);\n```\n\n查看集群中每个节点最近完成的两个批处理作业的状态：\n\n```\npnodeRun(getRecentJobs{2});\n```\n\n| Node       | UserID | JobID    | JobDesc  | ReceivedTime            | StartTime               | EndTime                 | ErrorMsg |\n| ---------- | ------ | -------- | -------- | ----------------------- | ----------------------- | ----------------------- | -------- |\n| DFS\\_NODE1 | root   | jobDemo2 | job demo | 2017.11.16T13:04:38.841 | 2017.11.16T13:04:38.841 | 2017.11.16T13:04:51.660 |          |\n| DFS\\_NODE1 | root   | jobDemo3 | job demo | 2017.11.16T13:04:38.841 | 2017.11.16T13:04:38.843 | 2017.11.16T13:04:51.447 |          |\n| DFS\\_NODE2 | root   | jobDemo2 | job demo | 2017.11.16T13:04:56.431 | 2017.11.16T13:04:56.432 | 2017.11.16T13:05:11.992 |          |\n| DFS\\_NODE2 | root   | jobDemo3 | job demo | 2017.11.16T13:04:56.432 | 2017.11.16T13:04:56.434 | 2017.11.16T13:05:11.670 |          |\n| DFS\\_NODE3 | root   | jobDemo2 | job demo | 2017.11.16T13:05:08.418 | 2017.11.16T13:05:08.419 | 2017.11.16T13:05:29.176 |          |\n| DFS\\_NODE3 | root   | jobDemo3 | job demo | 2017.11.16T13:05:08.419 | 2017.11.16T13:05:08.421 | 2017.11.16T13:05:29.435 |          |\n| DFS\\_NODE4 | root   | jobDemo2 | job demo | 2017.11.16T13:05:16.324 | 2017.11.16T13:05:16.325 | 2017.11.16T13:05:34.729 |          |\n| DFS\\_NODE4 | root   | jobDemo3 | job demo | 2017.11.16T13:05:16.325 | 2017.11.16T13:05:16.328 | 2017.11.16T13:05:34.716 |          |\n\n```\npnodeRun(getRecentJobs{2}, `DFS_NODE3`DFS_NODE4);\n```\n\n| Node       | UserID | JobID    | JobDesc  | ReceivedTime            | StartTime               | EndTime                 | ErrorMsg |\n| ---------- | ------ | -------- | -------- | ----------------------- | ----------------------- | ----------------------- | -------- |\n| DFS\\_NODE3 | root   | jobDemo2 | job demo | 2017.11.16T13:05:08.418 | 2017.11.16T13:05:08.419 | 2017.11.16T13:05:29.176 |          |\n| DFS\\_NODE3 | root   | jobDemo3 | job demo | 2017.11.16T13:05:08.419 | 2017.11.16T13:05:08.421 | 2017.11.16T13:05:29.435 |          |\n| DFS\\_NODE4 | root   | jobDemo2 | job demo | 2017.11.16T13:05:16.324 | 2017.11.16T13:05:16.325 | 2017.11.16T13:05:34.729 |          |\n| DFS\\_NODE4 | root   | jobDemo3 | job demo | 2017.11.16T13:05:16.325 | 2017.11.16T13:05:16.328 | 2017.11.16T13:05:34.716 |          |\n\n`pnodeRun` 合并多个节点的结果时遵循以下规则：\n\n(1) 如果 function 返回一个标量：\n\n返回一个表，它具有两列：节点别名和函数结果。\n\n紧接上面的例子：\n\n```\npnodeRun(getJobReturn{`jobDemo1});\n```\n\n| Node       | Value         |\n| ---------- | ------------- |\n| DFS\\_NODE3 | 2,123.5508    |\n| DFS\\_NODE2 | (42,883.5404) |\n| DFS\\_NODE1 | 3,337.4107    |\n| DFS\\_NODE4 | (2,267.3681)  |\n\n(2) 如果 function 返回一个向量：\n\n返回一个矩阵。矩阵中的每一列是函数在节点上返回的结果。矩阵的列标签是节点。\n\n(3) 如果 function 返回键-值形式的字典：\n\n返回一个表，每行代表函数在一个节点上的结果。\n\n(4) 如果 function 返回一个表：\n\n返回一个表，它是多个节点上的表的合并。\n\n(5) 如果 function 是一个命令（该命令不返回任何内容）：\n\n不返回任何内容。\n\n(6) 对于其他情况：\n\n返回一个字典。键是节点别名，值是函数的返回内容。\n"
    },
    "point": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/point.html",
        "signatures": [
            {
                "full": "point(X, Y)",
                "name": "point",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [point](https://docs.dolphindb.cn/zh/funcs/p/point.html)\n\n\n\n#### 语法\n\npoint(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是数值型的标量、数据对、向量或矩阵，支持的数据类型为 INTEGRAL 类（COMPRESSED、INT128 除外）和 FLOATING 类。\n\n#### 详情\n\n生成一个 POINT 类型的数据，用来存储坐标系中点的位置。\n\nPOINT 类型数据长度为16字节，其中低8位的数据存储于 *X* 中，高8位的数据存储于 *Y* 中。\n\n#### 例子\n\n```\npoint(117.60972, 24.118418)\n// output:\n(117.60972, 24.118418)\n\npoint(1..5,6..10)\n// output:\n[(1, 6),(2, 7),(3, 8),(4, 9),(5, 10)]\n```\n"
    },
    "poly1d": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/poly1d.html",
        "signatures": [
            {
                "full": "polyPredict(model, X)",
                "name": "polyPredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [poly1d](https://docs.dolphindb.cn/zh/funcs/p/poly1d.html)\n\n是 \\[polyPredict]\\(polyPredict.md)的别名。\n\n\n以下是 `polyPredict` 函数的文档：\n### [polyPredict](https://docs.dolphindb.cn/zh/funcs/p/polyPredict.html)\n\n\n\n#### 语法\n\npolyPredict(model, X)\n\n别名：poly1d\n\n#### 详情\n\n利用给定的多项式系数 *z* 和自变量 *x*，计算因变量的值，返回一个和 *x* 等长的数值型向量。\n\n#### 参数\n\n**model** 数值型向量，表示多项式系数，以升幂排列，不能包含空值。\n\n**x** 数值型标量或向量，表示自变量数据点，不能包含空值。\n\n#### 例子\n\n#### 例子\n\n一个 3 次多项式 `2x^3 + 3x^2 + 4x + 5`，它的系数按升幂排序的向量是\\[5,4,3,2]：\n\n```\nmodel = [5,4,3,2]\nx = [2.0,5.0,3.0,3.0,4.0,5.0]\ny = poly1d(model,x)\ny\n//output: [41,350,98,98,197,350]\n```\n\n使用上述代码中的 model 和 y，通过 `polyFit` 函数可以计算出 3 次多项式的系数（按升幂排序）。\n\n```\npolyFit(x,y,3)\n//output:[5,4,3,2]\n```\n"
    },
    "polyFit": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/polyfit.html",
        "signatures": [
            {
                "full": "polyFit(X, Y, n)",
                "name": "polyFit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [polyFit](https://docs.dolphindb.cn/zh/funcs/p/polyfit.html)\n\n#### 语法\n\npolyFit(X, Y, n)\n\n#### 详情\n\n使用最小二乘法基于给定的数据点 *X* 和 *Y*，计算 n 次多项式的最佳拟合系数，并返回一个按升幂排列的系数向量。\n\n#### 参数\n\n**X** 数值型向量，表示自变量数据点，不能包含空值。\n\n**Y** 与 *X*等长的数值型向量，表示因变量数据点，不能包含空值。\n\n**n** 非负整型标量，表示拟合多项式的次数。\n\n#### 例子\n\n```\nx = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\ny = [0.0, 0.8, 0.9, 0.1, -0.8, -1.0]\nz = polyFit(x, y, 3)\nz\n\n[-0.0397,1.6931,-0.8135,0.087]\n```\n\n\n\n**Related information**\n\n[poly1d](https://docs.dolphindb.cn/zh/funcs/p/poly1d.html)\n"
    },
    "polynomial": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/polynomial.html",
        "signatures": [
            {
                "full": "polynomial(X, coeffs)",
                "name": "polynomial",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "coeffs",
                        "name": "coeffs"
                    }
                ]
            }
        ],
        "markdown": "### [polynomial](https://docs.dolphindb.cn/zh/funcs/p/polynomial.html)\n\n\n\n#### 语法\n\npolynomial(X, coeffs)\n\n#### 参数\n\n**X** 可以是标量或向量。\n\n**coeffs** 是表示多项式系数向量。\n\n#### 详情\n\n返回一个和 *X* 相同长度的向量。对于每个 *X* 中的元素，用多项式系数计算一个值。\n\n#### 例子\n\n计算![](https://docs.dolphindb.cn/zh/images/polynomial.png)，*X* 的取值是 1..10。\n\n```\npolynomial(1..10, 1 2 3);\n// output\n[6,17,34,57,86,121,162,209,262,321]\n```\n"
    },
    "polyPredict": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/polyPredict.html",
        "signatures": [
            {
                "full": "polyPredict(model, X)",
                "name": "polyPredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [polyPredict](https://docs.dolphindb.cn/zh/funcs/p/polyPredict.html)\n\n\n\n#### 语法\n\npolyPredict(model, X)\n\n别名：poly1d\n\n#### 详情\n\n利用给定的多项式系数 *z* 和自变量 *x*，计算因变量的值，返回一个和 *x* 等长的数值型向量。\n\n#### 参数\n\n**model** 数值型向量，表示多项式系数，以升幂排列，不能包含空值。\n\n**x** 数值型标量或向量，表示自变量数据点，不能包含空值。\n\n#### 例子\n\n#### 例子\n\n一个 3 次多项式 `2x^3 + 3x^2 + 4x + 5`，它的系数按升幂排序的向量是\\[5,4,3,2]：\n\n```\nmodel = [5,4,3,2]\nx = [2.0,5.0,3.0,3.0,4.0,5.0]\ny = poly1d(model,x)\ny\n//output: [41,350,98,98,197,350]\n```\n\n使用上述代码中的 model 和 y，通过 `polyFit` 函数可以计算出 3 次多项式的系数（按升幂排序）。\n\n```\npolyFit(x,y,3)\n//output:[5,4,3,2]\n```\n"
    },
    "pop!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pop_.html",
        "signatures": [
            {
                "full": "pop!(X)",
                "name": "pop!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [pop!](https://docs.dolphindb.cn/zh/funcs/p/pop_.html)\n\n\n\n#### 语法\n\npop!(X)\n\n#### 参数\n\n**X** 是一个向量。\n\n#### 详情\n\n移除 *X* 中的最后一个元素，并将它返回。\n\n#### 例子\n\n```\nx = 1 2 3;\npop!(x);\n// output\n3\n\nx;\n// output\n[1,2]\n```\n"
    },
    "pow": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pow.html",
        "signatures": [
            {
                "full": "pow(X, Y)",
                "name": "pow",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [pow](https://docs.dolphindb.cn/zh/funcs/p/pow.html)\n\n#### 语法\n\npow(X, Y)\n\n#### 详情\n\n返回以 *X* 中的元素为底，以 *Y* 中元素为指数计算得到的值。当 *X* 和 *Y* 为整数时，结果仍然是 DOUBLE 类型。\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、向量或矩阵。\n\n#### 例子\n\n```\nx=1 2 3;\npow(x,3);\n//output:[1,8,27]\n\npow(3,x);\n//output:[3,9,27]\n\ny=4.5 5.5 6.5;\npow(x,y);\n//output:[1,45.254834,1262.665039]\n\npow(y,x);\n//output: [4.5,30.25,274.625]\n```\n\n```\nm=1..10$2:5;\nm;\n```\n\n返回：\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  |\n| 2  | 4  | 6  | 8  | 10 |\n\n```\ntypestr(pow(3,4));\n//output: DOUBLE\n```\n\n"
    },
    "power": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/power.html",
        "signatures": [
            {
                "full": "power(X, Y)",
                "name": "power",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [power](https://docs.dolphindb.cn/zh/funcs/p/power.html)\n\n#### 语法\n\npower(X, Y)\n\n别名：pow\n\n\n\n**Related information**\n\n[pow](https://docs.dolphindb.cn/zh/funcs/p/pow.html)\n"
    },
    "predict": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/predict.html",
        "signatures": [
            {
                "full": "predict(model, X)",
                "name": "predict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [predict](https://docs.dolphindb.cn/zh/funcs/p/predict.html)\n\n\n\n#### 语法\n\npredict(model, X)\n\n#### 参数\n\n**model** 是用于预测的模型，一般是字典，由 [randomForestClassifier](https://docs.dolphindb.cn/zh/funcs/r/randomForestClassifier.html), [randomForestRegressor](https://docs.dolphindb.cn/zh/funcs/r/randomForestRegressor.html) 等机器学习函数生成。\n\n**X** 是用于预测的表，表的结构必须和用于训练 *model* 的表相同。\n\n#### 详情\n\n用特定的模型对数据进行预测。返回结果是向量，元素的个数和 *X* 的行数相同，每个元素对应一行的预测值。\n\n#### 例子\n\n以下例子是将 `randomForestRegressor` 生成的模型用于预测。\n\n```\nx1 = rand(100.0, 100)\nx2 = rand(100.0, 100)\nb0 = 6\nb1 = 1\nb2 = -2\nerr = norm(0, 10, 100)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(x1, x2, y)\nmodel = randomForestRegressor(sqlDS(<select * from t>), `y, `x1`x2)\nyhat = predict(model, t);\n// output\n[-93.733842,2.213932,5.39619,-47.817339,-38.655786,-75.772237,-45.817417,43.412841,-87.333214,-51.275368,32.41792,-45.797275,-152.075001,-83.423919,-21.154954,-65.734012,58.088571,-30.00795,-149.71085,-18.699006,-82.023643,-140.455355,-43.629218,65.832865,-79.411508,-65.625276,-17.466925,-43.469005,44.639384,31.686378...]\n\nplot(y, yhat, ,SCATTER);\n```\n\n![predict](https://docs.dolphindb.cn/zh/images/predict01.png)\n"
    },
    "prev": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/prev.html",
        "signatures": [
            {
                "full": "prev(X)",
                "name": "prev",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [prev](https://docs.dolphindb.cn/zh/funcs/p/prev.html)\n\n\n\n#### 语法\n\nprev(X)\n\n#### 参数\n\n**X** 是一个向量。\n\n#### 详情\n\n将向量向右移动一个位置。[next](https://docs.dolphindb.cn/zh/funcs/n/next.html) 函数将向量向左移动一个位置。类似功能还有函数：[move](https://docs.dolphindb.cn/zh/funcs/m/move.html)。\n\n#### 例子\n\n```\nx=3 9 5 1 4;\nprev(x);\n```\n\n输出返回：\\[,3,9,5,1]\n"
    },
    "prevState": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/prevState.html",
        "signatures": [
            {
                "full": "prevState(X)",
                "name": "prevState",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [prevState](https://docs.dolphindb.cn/zh/funcs/p/prevState.html)\n\n\n\n#### 语法\n\nprevState(X)\n\n#### 参数\n\n**X** 时间类型，布尔类型或者数值型的向量/矩阵。\n\n#### 详情\n\n*X* 中连续且相同的元素标记为同一状态，空值无状态。每个元素的状态等于其元素值。对于 *X* 中的每一个元素，返回当前状态的上一个状态。若当前元素为空，则返回上一个邻近状态。\n\n*X* 是矩阵时，则在矩阵每一列进行上述计算。\n\n#### 例子\n\n```\nX = [1, 2.2, NULL, 2.2, 2.3, 1, 1.2]\nprev(X)\n// output\n[,1,2.2,,2.2,2.3,1]\n\nprevState(X)\n// output\n[,1,2.2,2.2,2.2,2.3,1]\n\nX = matrix([1.0, 1.1, 1.0, 0.9], [NULL, 1.3, 2.5, 5.5], [5.5, 4.2, 1.6, 1.8])\nprevState(X)\n```\n\n| #0  | #1  | #2  |\n| --- | --- | --- |\n|     |     |     |\n| 1   |     | 5.5 |\n| 1.1 | 1.3 | 4.2 |\n| 1   | 2.5 | 1.6 |\n\n相关函数： [nextState](https://docs.dolphindb.cn/zh/funcs/n/nextState.html)\n"
    },
    "print": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/print.html",
        "signatures": [
            {
                "full": "print(X)",
                "name": "print",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [print](https://docs.dolphindb.cn/zh/funcs/p/print.html)\n\n\n\n#### 语法\n\nprint(X)\n\n#### 参数\n\n**X** 可以是任意数据。\n\n#### 详情\n\n打印结果和变量的内容。\n\n#### 例子\n\n```\nx=rand(10000,10);\nprint x;\n```\n\n输出返回：\\[9786,9501,8116,1266,1719,789,8162,3113,2740,6323]\n"
    },
    "prod": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/prod.html",
        "signatures": [
            {
                "full": "prod(X)",
                "name": "prod",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [prod](https://docs.dolphindb.cn/zh/funcs/p/prod.html)\n\n\n\n#### 语法\n\nprod(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n* 若 *X* 为向量，返回 *X* 中所有元素的乘积。\n\n* 若 *X* 为矩阵，计算每列中所有元素的乘积，返回一个向量。\n\n* 若 *X* 为表，计算每列中所有元素的乘积，返回一个表。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nprod(1 2 NULL 3);\n// output\n6\n```\n\n```\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nprod(m);\n// output\n[6,120]\n```\n"
    },
    "purgeCacheEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/purgeCacheEngine.html",
        "signatures": [
            {
                "full": "flushOLAPCache()",
                "name": "flushOLAPCache",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [purgeCacheEngine](https://docs.dolphindb.cn/zh/funcs/p/purgeCacheEngine.html)\n\n是 [flushOLAPCache](https://docs.dolphindb.cn/zh/funcs/f/flushOLAPCache.html) 的别名。\n\n\n以下是 `flushOLAPCache` 函数的文档：\n### [flushOLAPCache](https://docs.dolphindb.cn/zh/funcs/f/flushOLAPCache.html)\n\n\n\n#### 语法\n\nflushOLAPCache()\n\n#### 参数\n\n无\n\n#### 详情\n\n将 OLAP 引擎缓冲区里已经完成的事务强制写入数据库。请注意，使用该函数前，需配置 *OLAPCacheEngineSize* 和 *dataSync* = 1。\n"
    },
    "push!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/push_.html",
        "signatures": [
            {
                "full": "append!(obj, newData)",
                "name": "append!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "newData",
                        "name": "newData"
                    }
                ]
            }
        ],
        "markdown": "### [push!](https://docs.dolphindb.cn/zh/funcs/p/push_.html)\n\n是 [append!](https://docs.dolphindb.cn/zh/funcs/a/append!.html) 的别名。\n\n\n以下是 `append!` 函数的文档：\n### [append!](https://docs.dolphindb.cn/zh/funcs/a/append!.html)\n\n\n\n#### 语法\n\nappend!(obj, newData)\n\n别名：push!\n\n#### 详情\n\n将 *newData* 中的数据追加到 *obj*。在 DolphinDB 中，函数中的感叹号(!)表示直接修改数据本身（就地操作）。\n\n**Note:**\n\n1. 该函数不会检查两表中各列列名与顺序，只要两表中对应位置的列的数据类型一致，即可执行。如果两表中各列顺序有差别，该操作不会自动对齐各列。所以，对数据表进行 `append!` 操作时，请检查两表中各列列名与顺序，以免出错。绝大部分情况下两表中各列列名与顺序应当完全一致。\n2. 请注意：若数据库为分区，且分区列为字符串类型，则追加的分区列数据不能包含空格， “/t”。\n\n#### 参数\n\n**obj** 必须是本地变量：向量、元组、矩阵、表或集合。\n\n**newData** 可以是标量、向量、元组、表或集合。\n\n* 如果 *obj* 是向量，则 *newData* 必须是标量或向量、或元素类型与 *obj* 中元素类型一致的元组。结果是比 *obj* 更长的向量。\n* 如果 *obj* 是元组，则 *newData* 必须是标量、向量或元组。若 *newData* 为向量，则作为整体追加到元组；若 *newData* 为元组，当配置项 *appendTupleAsAWhole*=true 时，作为整体追加，*appendTupleAsAWhole*=wrong 时，将 *newData* 的每一个元素依次追加。\n* 如果 *obj* 是矩阵，则 *newData* 必须是长度为 *obj* 行数倍数的向量。结果是新的矩阵，行数和 *obj* 相同，具有更多的列数。\n* 如果 *obj* 是表，则 *newData* 必须是一个列数和 *obj* 相同的表。结果是和 *obj* 具有相同列数和列名的表，但行数比 *obj* 多。\n* 如果 *newData* 和 *obj* 的数据类型不同，`append!` 函数会尝试将 *newData* 转换为 *obj* 的数据类型。如果无法转换，将返回一个错误信息。\n\n#### 例子\n\n```\nx = 1 2 3\nx.append!(4)\nx\n// output\n[1,2,3,4]\nappend!(x, 5 6)\nx\n// output\n[1,2,3,4,5,6]\nx.append!(7.2)\nx\n// output\n[1,2,3,4,5,6,7]\n// 7.2 的数据类型从 DOUBLE 转化为 INT，所以值变为7\nx.append!(`XOM)\n// output\nIncompatible type. Expected: INT, Actual: STRING\n\nx=array(INT, 0, 10)\n// x 是一个空的向量\nx\n// output\n[]\nx.append!(1)\nx\n// output\n[]\nx=array(SYMBOL, 0, 100)\nappend!(x, `TEST)\nx\n// output\n[\"TEST\"]\n\nx=1..6$3:2\nx\n```\n\n| 0 | 1 |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\nx.append!(7..12)\nx\n```\n\n| 0 | 1 | 2 | 3  |\n| - | - | - | -- |\n| 1 | 4 | 7 | 10 |\n| 2 | 5 | 8 | 11 |\n| 3 | 6 | 9 | 12 |\n\n```\nx=set(1 2 3 4)\nx.append!(6)\n// output\nx\nset(6,1,2,3,4)\n\nt1=table(1 2 3 as x, 4 5 6 as y)\nt2=table(1.1 2.2 3.3 as a, 4.4 5.5 6.6 as b)\nt1.append!(t2)\nt1\n```\n\n| x | y |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n| 1 | 4 |\n| 2 | 6 |\n| 3 | 7 |\n\n使用 `append!` 把数据添加到分布式表。下面的例子需要在集群中执行。相关配置可参考：[功能配置](https://docs.dolphindb.cn/zh/db_distr_comp/cfg/function_configuration.html)。\n\n```\nn=1000000\nt=table(rand(`IBM`MS`APPL`AMZN,n) as symbol, rand(10.0, n) as value)\ndb = database(\"dfs://rangedb_tradedata\", RANGE, `A`F`M`S`ZZZZ)\nTrades = db.createPartitionedTable(t, \"Trades\", \"symbol\")\n```\n\n上面的脚本根据表 t 的结构创建了空表 Trades。接着，把表 t 的数据追加到表 Trades 中。\n\n```\nTrades.append!(t)\nselect count(*) from Trades;\n\n// output\n1000000\n```\n\n把其他表的数据追加到表 Trades 中。\n\n```\nn=500000\nt1=table(rand(`FB`GE`MSFT,n) as symbol, rand(100.0, n) as value)\nTrades.append!(t1)\nselect count(*) from Trades\n\n// output\n1500000\n```\n\n配置项 *appendTupleAsAWhole* 的不同设置值将影响追加元组的行为。\n\n```\nx = (1,\"X\")\ny = (2,\"Y\")\nx.append!(y)\nprint(x)\n// 配置参数 appendTupleAsAWhole=true 时\n(1,\"X\",(2,\"Y\"))\n// 配置参数 appendTupleAsAWhole=false 时\n(1,\"X\",2,\"Y\")\n```\n"
    },
    "pwlfPredict": {
        "url": "https://docs.dolphindb.cn/zh/funcs/p/pwlfpredict.html",
        "signatures": [
            {
                "full": "pwlfPredict(model, X, [beta], [breaks])",
                "name": "pwlfPredict",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[beta]",
                        "name": "beta",
                        "optional": true
                    },
                    {
                        "full": "[breaks]",
                        "name": "breaks",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [pwlfPredict](https://docs.dolphindb.cn/zh/funcs/p/pwlfpredict.html)\n\n\n\n#### 语法\n\npwlfPredict(model, X, \\[beta], \\[breaks])\n\n#### 详情\n\n本函数须结合函数 [piecewiseLinFit](https://docs.dolphindb.cn/zh/funcs/p/piecewiselinfit.html) 共同使用，即使用 `piecewiseLinFit` 拟合后的连续分段线性回归模型来对输入的数据点进行预测。\n\n#### 参数\n\n**model** 字典类型，由 `piecewiseLinFit` 函数返回的分段线性回归模型。\n\n**X** 数值向量，表示需要预测的数据点的 x 坐标。注意：不可传入 NULL 值。\n\n**beta** 可选参数，数值向量，表示分段线性回归模型的参数。注意：不可传入 NULL 值。\n\n**breaks** 可选参数，数值向量，表示每段线段终点处的 x 坐标，每段线段的终点又被称为每段线段的断点。注意：不可传入 NULL 值。\n\n#### 返回值\n\n浮点数向量，表示模型的预测值。\n\n#### 例子\n\n本例先自定义参数条件，使用 `piecewiseLinFit` 拟合生成连续分段线性回归模型；再传入预测的数据点的 x 坐标 `xHat`，最后使用 `pwlfPredict` 计算模型的预测值。\n\n```\ndef linspace(start, end, num, endpoint=true){\n\tif(endpoint) return end$DOUBLE\\(num-1), start + end$DOUBLE\\(num-1)*0..(num-1)\n\telse return start + end$DOUBLE\\(num-1)*0..(num-1)\t\n}\nX = linspace(0.0, 1.0, 10)[1]\nY = [0.41703981, 0.80028691, 0.12593987, 0.58373723, 0.77572962, 0.41156172, 0.72300284, 0.32559528, 0.21812564, 0.41776427]\nmodel = piecewiseLinFit(X, Y, 3)\nxHat = linspace(0.0, 1.0, 20)[1]\npwlfPredict(model, xHat)\n/*\noutput:\n[0.593305499919518 0.524360777381737 0.455416054843957 0.386471332306177 0.317526609768396 0.368043438179296 0.529813781212159 0.691584124245021 0.69295837868457  0.655502915538459 0.618047452392347 0.580591989246236 0.543136526100125 0.505681062954014 0.468225599807903 0.430770136661792 0.393314673515681 0.35585921036957  0.318403747223459 0.280948284077348]\n*/\n```\n\n相关函数：[piecewiseLinFit](https://docs.dolphindb.cn/zh/funcs/p/piecewiselinfit.html)\n"
    },
    "qclp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/q/qclp.html",
        "signatures": [
            {
                "full": "qclp(r, V, k, [A], [b], [Aeq], [beq], [x0], [c], [eps], [alpha])",
                "name": "qclp",
                "parameters": [
                    {
                        "full": "r",
                        "name": "r"
                    },
                    {
                        "full": "V",
                        "name": "V"
                    },
                    {
                        "full": "k",
                        "name": "k"
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[b]",
                        "name": "b",
                        "optional": true
                    },
                    {
                        "full": "[Aeq]",
                        "name": "Aeq",
                        "optional": true
                    },
                    {
                        "full": "[beq]",
                        "name": "beq",
                        "optional": true
                    },
                    {
                        "full": "[x0]",
                        "name": "x0",
                        "optional": true
                    },
                    {
                        "full": "[c]",
                        "name": "c",
                        "optional": true
                    },
                    {
                        "full": "[eps]",
                        "name": "eps",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [qclp](https://docs.dolphindb.cn/zh/funcs/q/qclp.html)\n\n\n\n#### 语法\n\nqclp(r, V, k, \\[A], \\[b], \\[Aeq], \\[beq], \\[x0], \\[c], \\[eps], \\[alpha])\n\n#### 参数\n\n**V**，**A** 和 **Aeq** 是列数相同的矩阵。\n\n**r**，**b** 和 **beq** 是向量。\n\n**k** 是一个正标量。\n\n**x0** 向量绝对值不等式约束的系数向量。\n\n**c** 一个非负数字，表示绝对值不等式约束的右侧常量系数。\n\n**eps** 正浮点数，表示求解的精度。默认值为1e-6，范围为 \\[1e-4, 1e-9]。通过减小该参数值以获得更高精度的解。如果该参数设置值超过规定范围，则会自动调整为默认值。\n\n**alpha** 正浮点数，表示松弛参数。默认值为1.5，范围为 (0, 2)。通过增加 alpha 的值来加快求解速度。如果该参数设置值超过规定范围，则会自动调整为默认值。\n\n#### 详情\n\n用一个线性目标函数和一组包含二次约束的约束条件求解下列优化问题。\n\n![image](https://docs.dolphindb.cn/zh/images/qclp.png)\n\n结果是一个包含2个元素的元组。第一个元素是目标函数的最小值。第二个元素是目标函数的最小时的x值。\n\n#### 例子\n\n根据每只股票的预期收益与收益率协方差矩阵，以及如下限制 (1) 投资组合的收益率波动率不超过11% (2) 每只股票的权重在10%到50%之间，以决定最优投资组合。\n\n```\nr = 0.18 0.25 0.36\nV= 0.0225 -0.003 -0.01125 -0.003 0.04 0.025 -0.01125 0.025 0.0625 $ 3:3\nk = pow(0.11, 2)\nA = (eye(3) join (-1*eye(3))).transpose()\nb = 0.5 0.5 0.5 -0.1 -0.1 -0.1\nAeq = (1 1 1)$1:3\nbeq = [1]\n\nx = qclp(-r, V, k, A, b, Aeq, beq);\n\nx[1];\n//Output: [0.5,0.1763,0.3237]\n```\n\n在上例的基础上，添加绝对值约束：| x1 - 0.35| + | x2 - 0.35 | + | x3 - 0.35 | ≤ 0.3：\n\n```\nx0 = [0.35, 0.35, 0.35];\nc = 0.3;\ny = qclp(-r, V, k, A, b, Aeq, beq, x0, c);\n\ny[1]\n//Output: [0.475,0.248,0.277]\n```\n"
    },
    "qr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/q/qr.html",
        "signatures": [
            {
                "full": "qr(obj, [mode='full'], [pivoting=false])",
                "name": "qr",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[mode='full']",
                        "name": "mode",
                        "optional": true,
                        "default": "'full'"
                    },
                    {
                        "full": "[pivoting=false]",
                        "name": "pivoting",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [qr](https://docs.dolphindb.cn/zh/funcs/q/qr.html)\n\n\n\n#### 语法\n\nqr(obj, \\[mode='full'], \\[pivoting=false])\n\n#### 参数\n\n**obj** 是一个矩阵。\n\n**mode** 是一个字符串，表示返回信息的类型。它的取值可以是 \"full\", \"economic\", \"raw\" 或 \"r\"。默认值是 \"full\"。\n\n**pivoting** 是一个布尔值，表示是否返回置换矩阵的秩显，默认值为 false。\n\n#### 详情\n\n计算矩阵的 QR（正交三角）分解，将矩阵分解成一个标准正交矩阵 Q 与上三角形矩阵 R。若输入矩阵为 A，结果满足 A=Q\\*R。\n\n假设 A 的行数为 m，列数为 n：\n\n* 若 *mode*=\"full\"，返回矩阵 Q 与 R，形状分别为 m\\*m 和 m\\*n。\n\n* 若 *mode*=\"economic\"，返回矩阵 Q 与 R，形状分别为 m\\*k 和 k\\*n，其中 k=min(m,n)。\n\n* 若 *mode*=\"r\"，仅返回矩阵 R，形状为 m\\*n。\n\n* 若 *pivoting*=true，返回结果还包含一个与输入矩阵列数相同长度的向量 P。P 为置换矩阵的秩显，表示置换矩阵中1所在列的位置。\n\n#### 例子\n\n```\nA = matrix([2,5,7,5], [5,2,5,4], [8,2,6,4]);\n\nQ,R = qr(A);\nQ;\n```\n\n| #0        | #1        | #2        | #3        |\n| --------- | --------- | --------- | --------- |\n| -0.197066 | 0.903357  | 0.300275  | 0.234404  |\n| -0.492665 | -0.418267 | 0.459245  | 0.609449  |\n| -0.68973  | -0.02475  | 0.170745  | -0.703211 |\n| -0.492665 | 0.091573  | -0.818398 | 0.281284  |\n\n```\nR;\n```\n\n| #0         | #1       | #2        |\n| ---------- | -------- | --------- |\n| -10.148892 | -7.38997 | -8.670898 |\n| 0          | 3.922799 | 6.608121  |\n| 0          | 0        | 1.071571  |\n| 0          | 0        | 0         |\n\n```\nQ,R=qr(A,mode='economic');\nQ;\n```\n\n| #0        | #1        | #2        |\n| --------- | --------- | --------- |\n| -0.197066 | 0.903357  | 0.300275  |\n| -0.492665 | -0.418267 | 0.459245  |\n| -0.68973  | -0.02475  | 0.170745  |\n| -0.492665 | 0.091573  | -0.818398 |\n\n```\nR;\n```\n\n| #0         | #1       | #2        |\n| ---------- | -------- | --------- |\n| -10.148892 | -7.38997 | -8.670898 |\n| 0          | 3.922799 | 6.608121  |\n| 0          | 0        | 1.071571  |\n\n```\nQ,T,R=qr(A,mode='raw');\nR;\n```\n\n| #0         | #1       | #2        |\n| ---------- | -------- | --------- |\n| -10.148892 | -7.38997 | -8.670898 |\n| 0.41156    | 3.922799 | 6.608121  |\n| 0.576184   | 0.3046   | 1.071571  |\n| 0.41156    | 0.156539 | 0.900419  |\n\n```\nT;\n// output\n[1.197066,1.790053,1.104512]\n\nR\n```\n\n| #0         | #1       | #2        |\n| ---------- | -------- | --------- |\n| -10.148892 | -7.38997 | -8.670898 |\n| 0          | 3.922799 | 6.608121  |\n| 0          | 0        | 1.071571  |\n\n```\nQ,T,R,P = qr(A,mode='raw',pivoting=true);\nQ;\n```\n\n| #0         | #1        | #2        |\n| ---------- | --------- | --------- |\n| -10.954451 | -8.033264 | -8.215838 |\n| 0.105516   | -6.20215  | -1.45111  |\n| 0.316548   | 0.37699   | -0.627918 |\n| 0.211032   | 0.284188  | 0.936372  |\n\n```\nT;\n// output\n[1.730297,1.635478,1.065648]\n\nR\n```\n\n| #0         | #1        | #2        |\n| ---------- | --------- | --------- |\n| -10.954451 | -8.033264 | -8.215838 |\n| 0          | -6.20215  | -1.45111  |\n| 0          | 0         | -0.627918 |\n\n```\nP;\n// output\n[2,0,1]\n```\n"
    },
    "quadprog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/q/quadprog.html",
        "signatures": [
            {
                "full": "quadprog(H, f, [A], [b], [Aeq], [beq])",
                "name": "quadprog",
                "parameters": [
                    {
                        "full": "H",
                        "name": "H"
                    },
                    {
                        "full": "f",
                        "name": "f"
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[b]",
                        "name": "b",
                        "optional": true
                    },
                    {
                        "full": "[Aeq]",
                        "name": "Aeq",
                        "optional": true
                    },
                    {
                        "full": "[beq]",
                        "name": "beq",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [quadprog](https://docs.dolphindb.cn/zh/funcs/q/quadprog.html)\n\n\n\n#### 语法\n\nquadprog(H, f, \\[A], \\[b], \\[Aeq], \\[beq])\n\n#### 参数\n\n**H** 是二次规划中的二次项矩阵，且必须是对称正定矩阵。\n\n**f** 是二次项规划中的一次项向量。\n\n**A** 是线性不等约束的系数矩阵。\n\n**b** 是线性不等约束的右端向量。\n\n**Aeq** 是线性等式约束的系数矩阵。\n\n**beq** 是线性等式约束的右端向量。\n\n*H*, *A* 和 *Aeq* 必须是列数相同的矩阵。\n\n*f*, *b* 和 *beq* 是向量。\n\n#### 详情\n\n求二元目标函数在线性约束条件下的最优解。具体模型如下：\n\n![image](https://docs.dolphindb.cn/zh/images/quadprog.png)\n\n返回结果是具有两个元素的元组。第一个元素是目标函数的最小值，第二个元素是目标函数取最小值时，x的取值。\n\n#### 例子\n\n求以下目标函数的最小值。\n\n![image](https://docs.dolphindb.cn/zh/images/quadprog1.png)\n\n例1：没有约束条件\n\n```\nH=matrix([2 -2,-2 6])\nf=[-5,4]\nx=quadprog(H,f);\n\nx[0];\n// output\n-6.375\n\nx[1];\n// output\n[2.75,0.25]\n```\n\n例2：添加不等式约束条件：\n\n![image](https://docs.dolphindb.cn/zh/images/quadprog2.png)\n\n```\nH=matrix([2 -2,-2 6])\nf=[-5,4]\nA=matrix([1 -1 6, 1 3 1])\nb=[10, 8, 5]\nx=quadprog(H,f,A,b);\n\nx[0];\n// output\n-4.092975\n\nx[1];\n// output\n[0.904959, -0.429752]\n```\n\n例3：添加不等式约束条件和等式约束条件：\n\n![image](https://docs.dolphindb.cn/zh/images/quadprog3.png)\n\n```\nH=matrix([2 -2,-2 6])\nf=[-5,4]\nA=matrix([1 -1 6, 1 3 1])\nb=[10, 8, 5]\nAeq=matrix([1],[2])\nbeq=[1]\nx=quadprog(H,f,A,b,Aeq,beq);\n\nx[0];\n// output\n-3.181818\n\nx[1];\n// output\n[0.818182,0.090909]\n```\n\n目标函数在没有约束条件的情况下，最优解的值最小。约束条件越多，最优解的值越大。\n\n相关函数：[linprog](https://docs.dolphindb.cn/zh/funcs/l/linprog.html), [scs](https://docs.dolphindb.cn/zh/funcs/s/scs.html)\n"
    },
    "quantile": {
        "url": "https://docs.dolphindb.cn/zh/funcs/q/quantile.html",
        "signatures": [
            {
                "full": "quantile(X, q, [interpolation='linear'])",
                "name": "quantile",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "q",
                        "name": "q"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    }
                ]
            }
        ],
        "markdown": "### [quantile](https://docs.dolphindb.cn/zh/funcs/q/quantile.html)\n\n\n\n#### 语法\n\nquantile(X, q, \\[interpolation='linear'])\n\n#### 参数\n\n**X** 是一个数值型向量、矩阵或表。\n\n**q** 是0到1之间的浮点数。\n\n**interpolation** 是一个字符串，表示当选中的分位点位于 i 和 j 之间时，采用的插值方法。它具有以下取值：\n\n* 'linear': i+(j-1)\\*fraction, fraction 是 size(X)\\*q 的小数部分\n\n* 'lower':i\n\n* 'higher': j\n\n* 'nearest': i 和 j 之中最接近分位点的数据\n\n* 'midpoint': (i+j)/2\n\n如果没有指定 *interpolation*，默认采用 'linear'。\n\n#### 详情\n\n计算 *X* 的分位数。\n\n#### 例子\n\n```\na=[6, 47, 49, 15, 42, 41, 7, 39, 43, 40, 36];\nquantile(a,0.25);\n// output\n25.5\n\nquantile(a,0.5);\n// output\n40\n\nquantile(a,0.75);\n// output\n42.5\n\nquantile(a,0.75, 'lower');\n// output\n42\n```\n\n相关函数：[quantileSeries](https://docs.dolphindb.cn/zh/funcs/q/quantileSeries.html)\n"
    },
    "quantileSeries": {
        "url": "https://docs.dolphindb.cn/zh/funcs/q/quantileSeries.html",
        "signatures": [
            {
                "full": "quantileSeries(X, q, [interpolation='linear'])",
                "name": "quantileSeries",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "q",
                        "name": "q"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    }
                ]
            }
        ],
        "markdown": "### [quantileSeries](https://docs.dolphindb.cn/zh/funcs/q/quantileSeries.html)\n\n\n\n#### 语法\n\nquantileSeries(X, q, \\[interpolation='linear'])\n\n#### 参数\n\n**X** 是一个数值型向量。\n\n**q** 是0到1之间的浮点型标量或向量。\n\n**interpolation** 是一个字符串，表示当选中的分位点位于 i 和 j 之间时，采用的插值方法。它具有以下取值：\n\n* 'linear': i+(j-1)\\*fraction, fraction 是 size(X)\\*q 的小数部分\n\n* 'lower':i\n\n* 'higher': j\n\n* 'nearest': i 和 j 之中最接近分位点的数据\n\n* 'midpoint': (i+j)/2\n\n如果没有指定 *interpolation*，默认采用 'linear'。\n\n#### 详情\n\n计算 *X* 的分位数。\n\n#### 例子\n\n```\na=[6, 47, 49, 15, 42, 41, 7, 39, 43, 40, 36];\nquantileSeries(a,[0.25,0.5,0.75]);\n// output\n[25.5,40,42.5]\n\nquantileSeries(a,[0.25,0.5,0.75], 'higher');\n// output\n[36,40,43]\n```\n\n相关函数：[quantile](https://docs.dolphindb.cn/zh/funcs/q/quantile.html)\n"
    },
    "quarterBegin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/q/quarterBegin.html",
        "signatures": [
            {
                "full": "quarterBegin(X, [startingMonth=1], [offset], [n=1])",
                "name": "quarterBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [quarterBegin](https://docs.dolphindb.cn/zh/funcs/q/quarterBegin.html)\n\n\n\n#### 语法\n\nquarterBegin(X, \\[startingMonth=1], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**startingMonth** 是1到12之间的整数，表示一年的起始月份。默认值是1。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在季度的第一天。每季度包含的月份由参数 *startingMonth* 决定。\n\n如果指定了 *offset*，表示从 *offset*开始，结果每隔n个季度更新一次。注意，只有当 *n* >1时，*offset* 才会生效。\n\n#### 例子\n\n```\nquarterBegin(2012.06.12);\n// output\n2012.04.01\n\nquarterBegin(2012.06.13 10:10:10.008,5);\n// output\n2012.05.01\n\ndate=2016.01.12 2016.02.25 2016.05.12 2016.06.28 2016.07.10 2016.08.18 2016.09.02 2016.10.16 2016.11.26 2016.12.30\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by quarterBegin(date,1,2016.01.01,2)\n```\n\n| quarterBegin\\_date | avg\\_price | sum\\_qty |\n| ------------------ | ---------- | -------- |\n| 2016.01.01         | 34.65      | 9400     |\n| 2016.07.01         | 92.491667  | 29300    |\n\n相关函数：[quarterEnd](https://docs.dolphindb.cn/zh/funcs/q/quarterEnd.html), [businessQuarterBegin](https://docs.dolphindb.cn/zh/funcs/b/businessQuarterBegin.html), [businessQuarterEnd](https://docs.dolphindb.cn/zh/funcs/b/businessQuarterEnd.html)\n"
    },
    "quarterEnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/q/quarterEnd.html",
        "signatures": [
            {
                "full": "quarterEnd(X, [endingMonth=12], [offset], [n=1])",
                "name": "quarterEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[endingMonth=12]",
                        "name": "endingMonth",
                        "optional": true,
                        "default": "12"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [quarterEnd](https://docs.dolphindb.cn/zh/funcs/q/quarterEnd.html)\n\n\n\n#### 语法\n\nquarterEnd(X, \\[endingMonth=12], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**endingMonth** 是1到12之间的整数，表示一年的结束月份。默认值是12。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在季度的最后一天。每季度包含的月份由参数 *endingMonth* 决定。\n\n如果指定了 *offset*，表示从 *offset*开始，结果每隔n个季度更新一次。注意，只有当 *n* >1时，*offset* 才会生效。\n\n#### 例子\n\n```\nquarterEnd(2012.06.12);\n// output\n2012.06.30\n\nquarterEnd(2012.06.13 10:10:10.008,5);\n// output\n2012.08.31\n\ndate=2016.01.12 2016.02.25 2016.05.12 2016.06.28 2016.07.10 2016.08.18 2016.09.02 2016.10.16 2016.11.26 2016.12.30\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by quarterEnd(date,12,2016.01.01,2)\n```\n\n| quarterEnd\\_date | avg\\_price | sum\\_qty |\n| ---------------- | ---------- | -------- |\n| 2016.03.31       | 39.53      | 4100     |\n| 2016.09.30       | 92.1       | 18800    |\n| 2017.03.31       | 51.33      | 15800    |\n\n相关函数：[quarterBegin](https://docs.dolphindb.cn/zh/funcs/q/quarterBegin.html), [businessQuarterBegin](https://docs.dolphindb.cn/zh/funcs/b/businessQuarterBegin.html), [businessQuarterEnd](https://docs.dolphindb.cn/zh/funcs/b/businessQuarterEnd.html)\n"
    },
    "quarterOfYear": {
        "url": "https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html",
        "signatures": [
            {
                "full": "quarterOfYear(X)",
                "name": "quarterOfYear",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [quarterOfYear](https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html)\n\n\n\n#### 语法\n\nquarterOfYear(X)\n\n#### 参数\n\n**X** 可以是 DATE, MONTH, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n计算X在当年的第几个季度。返回的结果是整型。\n\n#### 例子\n\n```\nquarterOfYear(2012.07.02);\n// output\n3\n\nquarterOfYear([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n// output\n[2,4,1,2]\n```\n\n相关函数：[dayOfYear](https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html), [monthOfYear](https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.cn/zh/funcs/m/millisecond.html), [microsecond](https://docs.dolphindb.cn/zh/funcs/m/microsecond.html), [nanosecond](https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html)\n"
    },
    "rad2deg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rad2deg.html",
        "signatures": [
            {
                "full": "rad2deg(X)",
                "name": "rad2deg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rad2deg](https://docs.dolphindb.cn/zh/funcs/r/rad2deg.html)\n\n\n\n#### 语法\n\nrad2deg(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n将 *X* 的角单位从弧度转换为度。\n\n#### 例子\n\n```\nrad2deg(pi);\n// output\n180\n```\n\n相关函数：[deg2rad](https://docs.dolphindb.cn/zh/funcs/d/deg2rad.html)\n"
    },
    "rand": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rand.html",
        "signatures": [
            {
                "full": "rand(X, count)",
                "name": "rand",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [rand](https://docs.dolphindb.cn/zh/funcs/r/rand.html)\n\n\n\n#### 语法\n\nrand(X, count)\n\n#### 参数\n\n**X** 标量或向量；\n\n**count** INT 型标量或数据对。若为标量，表示输出向量的长度；若为数据对，表示输出矩阵的维度。\n\n#### 详情\n\n返回一个随机向量/随机矩阵。\n\n* 如果 *X* 是标量，则 *X* 必须大于 0 且为数值类型，生成的随机数服从 \\[0, X) 下的均匀分布。\n\n* 如果 *X* 是向量，`rand` 函数返回从 *X* 中随机选取元素所得的向量。\n\n#### 例子\n\n```\n// 生成 20 个小于 10 的随机非负整数\nrand(10, 20);\n// output：[9,9,8,1,1,0,8,3,2,6,4,6,9,6,8,9,3,2,1,5]\n\n// 生成 10 个 小于 9.8 的随机非负浮点数\nrand(9.8, 10);\n// output：[3.653754,1.750518,0.055747,5.219222,2.473778,6.337576,7.797493,1.392241,0.149499,5.697612]\n\n// 生成 3 个随机从向量 x 中选取的值\nx=3 5 4 6 9;\nrand(x, 3);\n// output：[9,3,6]\n\n// 生成一个小于10的 2*2 的随机矩阵\nrand(10.0, 2:2)\n```\n\n| col1   | col2   |\n| ------ | ------ |\n| 0.8233 | 1.0052 |\n| 7.1127 | 9.7578 |\n\n```\n12:35:06 + rand(100, 10);\n//output：[12:35:44,12:35:16,12:35:50,12:35:44,12:35:46,12:35:09,12:35:50,12:36:35,12:35:09,12:36:44]\n\nx=`IBM`C`AAPL`BABA;\nrand(x, 10);\n// output：[\"IBM\",\"BABA\",\"C\",\"AAPL\",\"IBM\",\"C\",\"BABA\",\"AAPL\",\"BABA\",\"BABA\"]\n\nrand(x,2:3)\n```\n\n<table id=\"table_kxp_bz5_x1c\"><tbody><tr><td>\n\n\\#0\n\n</td><td>\n\n\\#1\n\n</td><td>\n\n\\#2\n\n</td></tr><tr><td>\n\nBABA\n\n</td><td>\n\nAAPL\n\n</td><td>\n\nBABA\n\n</td></tr><tr><td>\n\nC\n\n</td><td>\n\nAAPL\n\n</td><td>\n\nAAPL\n\n</td></tr></tbody>\n</table>\n"
    },
    "randBeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randBeta.html",
        "signatures": [
            {
                "full": "randBeta(alpha, beta, count)",
                "name": "randBeta",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randBeta](https://docs.dolphindb.cn/zh/funcs/r/randBeta.html)\n\n\n\n#### 语法\n\nrandBeta(alpha, beta, count)\n\n#### 参数\n\n形状参数 **alpha** 和 **bata** 都是正数。\n\n**count** 是正整数，表示生成随机数的个数。\n\n#### 详情\n\n生成指定个数的 Beta 分布随机数。\n\n#### 例子\n\n```\nrandBeta(2.31, 0.627, 2);\n// output\n[0.781246, 0.951372]\n```\n"
    },
    "randBinomial": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randBinomial.html",
        "signatures": [
            {
                "full": "randBinomial(trials, p, count)",
                "name": "randBinomial",
                "parameters": [
                    {
                        "full": "trials",
                        "name": "trials"
                    },
                    {
                        "full": "p",
                        "name": "p"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randBinomial](https://docs.dolphindb.cn/zh/funcs/r/randBinomial.html)\n\n\n\n#### 语法\n\nrandBinomial(trials, p, count)\n\n#### 参数\n\n**trials** 是正整数。\n\n**p** 是0到1之间的浮点数。\n\n**trials** 和 **p** 是形状参数。\n\n**count** 是正整数，表示生成的随机数个数。\n\n#### 详情\n\n生成指定个数的二项分布随机数。\n\n#### 例子\n\n```\nrandBinomial(2, 0.627, 2);\n// output\n[1, 1]\n```\n"
    },
    "randChiSquare": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randChiSquare.html",
        "signatures": [
            {
                "full": "randChiSquare(df, count)",
                "name": "randChiSquare",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randChiSquare](https://docs.dolphindb.cn/zh/funcs/r/randChiSquare.html)\n\n\n\n#### 语法\n\nrandChiSquare(df, count)\n\n#### 参数\n\n**df** 是正数，表示卡方分布的自由度。\n\n**count** 是正整数，表示生成的随机数个数。\n\n#### 详情\n\n生成指定个数的卡方分布随机数。\n\n#### 例子\n\n```\nrandChiSquare(2.31, 2);\n// output\n[2.78303, 2.868523]\n```\n"
    },
    "randDiscrete": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randDiscrete.html",
        "signatures": [
            {
                "full": "randDiscrete(v, p, count)",
                "name": "randDiscrete",
                "parameters": [
                    {
                        "full": "v",
                        "name": "v"
                    },
                    {
                        "full": "p",
                        "name": "p"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randDiscrete](https://docs.dolphindb.cn/zh/funcs/r/randDiscrete.html)\n\n\n\n#### 语法\n\nrandDiscrete(v, p, count)\n\n#### 参数\n\n**v** 向量或元组，表示样本数据。\n\n**p** 与 *v* 等长的浮点型向量，其每个元素必须是正数，对应 *v* 中采样元素的概率分布。系统会自动将 *p* 的元素归一化。\n\n**count** 正整数，表示输出的随机向量的长度。\n\n#### 详情\n\n根据给定的分布概率 *p*，生成向量 *v* 的随机样本。生成样本的长度由 *count* 指定。\n\n#### 例子\n\n```\nrandDiscrete(1..5, [0.1, 0.1, 0.2, 0.2, 0.4], 10)\n// output\n[2,3,5,2,5,5,2,1,1,2]\n\n// 若概率和不为1，系统会自动归一化\nrandDiscrete(1..5, [0.1, 0.2, 0.3, 0.4, 0.5], 5)\n// output\n[5,1,2,3,5]\n\nrandDiscrete(`A`B`C`E`F, [0.1, 0.2, 0.3, 0.4, 0.5], 5)\n// output\n[\"C\",\"E\",\"B\",\"C\",\"F\"]\n\n// 输入元组，对元组中的每个元素进行采样\nrandDiscrete([[1,2], [2,3,4], 'S', 'abc'], [0.3, 0.3, 0.2, 0.1], 10)\n// output\n('S',[2,3,4],[1,2],[2,3,4],[1,2],'S','S',[2,3,4],[2,3,4],[2,3,4])\n\n// 输入数组向量，对其中的每个向量进行采样\na = array\\(INT\\[\\], 0, 10\\).append!\\(\\[1 2 3, 4 5,6 7 8, 9 NULL\\]\\)\nrandDiscrete\\(a, \\[0.1, 0.2, 0.3, 0.4\\], 10\\)\n// output\n\\[\\[9,00i\\],\\[9,00i\\],\\[9,00i\\],\\[4,5\\],\\[9,00i\\],\\[1,2,3\\],\\[9,00i\\],\\[6,7,8\\],\\[9,00i\\],\\[9,00i\\]\\]\n```\n"
    },
    "randExp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randExp.html",
        "signatures": [
            {
                "full": "randExp(mean, count)",
                "name": "randExp",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randExp](https://docs.dolphindb.cn/zh/funcs/r/randExp.html)\n\n\n\n#### 语法\n\nrandExp(mean, count)\n\n#### 参数\n\n**mean** 是指数分布的均值。\n\n**count** 是正整数，表示生成的随机数个数。\n\n#### 详情\n\n生成指定个数的指数分布随机数。\n\n#### 例子\n\n```\nrandExp(2.31, 2);\n// output\n[0.732791, 0.732791]\n```\n"
    },
    "randF": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randF.html",
        "signatures": [
            {
                "full": "randF(numeratorDF, denominatorDF, count)",
                "name": "randF",
                "parameters": [
                    {
                        "full": "numeratorDF",
                        "name": "numeratorDF"
                    },
                    {
                        "full": "denominatorDF",
                        "name": "denominatorDF"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randF](https://docs.dolphindb.cn/zh/funcs/r/randF.html)\n\n\n\n#### 语法\n\nrandF(numeratorDF, denominatorDF, count)\n\n#### 参数\n\n**numeratorDF** 和 **denominatorDF** 都是正数，表示 F 分布的自由度。\n\n**count** 是正整数，表示生成的随机数个数。\n\n#### 详情\n\n生成指定个数的 F 分布随机数。\n\n#### 例子\n\n```\nrandF(2.31, 0.671, 2);\n// output\n[0.41508, 0.642609]\n```\n"
    },
    "randGamma": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randGamma.html",
        "signatures": [
            {
                "full": "randGamma(shape, scale, count)",
                "name": "randGamma",
                "parameters": [
                    {
                        "full": "shape",
                        "name": "shape"
                    },
                    {
                        "full": "scale",
                        "name": "scale"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randGamma](https://docs.dolphindb.cn/zh/funcs/r/randGamma.html)\n\n\n\n#### 语法\n\nrandGamma(shape, scale, count)\n\n#### 参数\n\n形状参数 **shape** 是正数。\n\n形状参数 **scale** 是正数。\n\n**count** 是正整数，表示生成的随机数个数。\n\n#### 详情\n\n生成指定个数的 Gamma 分布随机数。\n\n#### 例子\n\n```\nrandGamma(2.31, 0.671, 2);\n// output\n[0.784424, 0.716934]\n```\n"
    },
    "randLogistic": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randLogistic.html",
        "signatures": [
            {
                "full": "randLogistic(mean, s, count)",
                "name": "randLogistic",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "s",
                        "name": "s"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randLogistic](https://docs.dolphindb.cn/zh/funcs/r/randLogistic.html)\n\n\n\n#### 语法\n\nrandLogistic(mean, s, count)\n\n#### 参数\n\n**mean** Logistic 分布的均值。\n\n**s** 是Logistic 分布的尺度参数。\n\n**count** 是正整数，表示生成的随机数个数。\n\n#### 详情\n\n生成指定个数的 Logistic 分布随机数。\n\n#### 例子\n\n```\nrandLogistic(2.31, 0.671, 2);\n// output\n[2.465462, 2.577171]\n```\n"
    },
    "randMultivariateNormal": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randMultivariateNormal.html",
        "signatures": [
            {
                "full": "randMultivariateNormal(mean, covar, count, [sampleAsRow=true])",
                "name": "randMultivariateNormal",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "covar",
                        "name": "covar"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    },
                    {
                        "full": "[sampleAsRow=true]",
                        "name": "sampleAsRow",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [randMultivariateNormal](https://docs.dolphindb.cn/zh/funcs/r/randMultivariateNormal.html)\n\n\n\n#### 语法\n\nrandMultivariateNormal(mean, covar, count, \\[sampleAsRow=true])\n\n别名：multivariateNormal\n\n#### 参数\n\n**mean** 是一个数组，表示多元正太分布的均值。\n\n**covar** 是一个正定矩阵，表示多元正太分布的协方差。\n\n**count** 是一个正整数，表示样本长度。\n\n**sampleAsRow** 是一个布尔值。默认值为 true，表示输出矩阵的一行是一个样本。如果 *sampleAsRow* 为 false，表示输出矩阵的一列是一个样本。\n\n#### 详情\n\n生成服从多元正态分布的随机数。返回的结果是一个矩阵。\n\n#### 例子\n\n```\nmultivariateNormal([2, 3], [1.0, 1.5, 1.5, 3.0]$2:2, 5);\n```\n\n输出返回：\n\n| #0        | #1        |\n| --------- | --------- |\n| -0.02395  | -0.844505 |\n| -0.630637 | 0.098955  |\n| 3.001908  | 4.831809  |\n| 0.791095  | 2.01402   |\n| 1.708191  | 2.41748   |\n\n```\nmultivariateNormal([2, 3], [1.0, 1.5, 1.5, 3.0]$2:2, 5, false);\n```\n\n输出返回：\n\n| #0       | #1       | #2        | #3        | #4       |\n| -------- | -------- | --------- | --------- | -------- |\n| 0.435419 | 0.138209 | -0.046187 | -1.201421 | 0.069719 |\n| 0.40163  | 0.034553 | -0.337324 | -1.008628 | 0.822161 |\n"
    },
    "randNormal": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randNormal.html",
        "signatures": [
            {
                "full": "randNormal(mean, stdev, count)",
                "name": "randNormal",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "stdev",
                        "name": "stdev"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randNormal](https://docs.dolphindb.cn/zh/funcs/r/randNormal.html)\n\n\n\n#### 语法\n\nrandNormal(mean, stdev, count)\n\n#### 参数\n\n**mean** 是正态分布的均值。\n\n**stdev** 是正态分布的标准差。\n\n**count** 是正整数，表示生成的随机数个数。\n\n#### 详情\n\n生成指定个数的正态分布随机数。\n\n#### 例子\n\n```\nrandNormal(2.31, 0.671, 2);\n// output\n[2.805524, 2.148019]\n```\n"
    },
    "randomForestClassifier": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randomForestClassifier.html",
        "signatures": [
            {
                "full": "randomForestClassifier(ds, yColName, xColNames, numClasses, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=32], [minImpurityDecrease=0.0], [numJobs=-1], [randomSeed])",
                "name": "randomForestClassifier",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "numClasses",
                        "name": "numClasses"
                    },
                    {
                        "full": "[maxFeatures=0]",
                        "name": "maxFeatures",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[numTrees=10]",
                        "name": "numTrees",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[numBins=32]",
                        "name": "numBins",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[maxDepth=32]",
                        "name": "maxDepth",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[minImpurityDecrease=0.0]",
                        "name": "minImpurityDecrease",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[numJobs=-1]",
                        "name": "numJobs",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [randomForestClassifier](https://docs.dolphindb.cn/zh/funcs/r/randomForestClassifier.html)\n\n\n\n#### 语法\n\nrandomForestClassifier(ds, yColName, xColNames, numClasses, \\[maxFeatures=0], \\[numTrees=10], \\[numBins=32], \\[maxDepth=32], \\[minImpurityDecrease=0.0], \\[numJobs=-1], \\[randomSeed])\n\n#### 参数\n\n**ds** 是数据源，通常用sqlDS函数生成。\n\n**yColName** 是字符串，表示数据源中作为因变量（所属分类）的列名。\n\n**xColNames** 是字符串标量或向量，表示数据源中作为自变量的列名。\n\n**numClasses** 是正整数，表示分类数目。y 列的取值必须是\\[0, numClasses)之间的整数。\n\n**maxFeatures** 是一个整数或浮点数，表示一次分裂节点选取的特征个数或比例。默认值是0。\n\n* 如果 *maxFeatures* 为正整数，则在一次分裂时选取 *maxFeatures* 个特征。\n\n* 如果 *maxFeatures* =0，则在一次分裂时选取 sqrt(特征列数量) 个特征。\n\n* 如果 *maxFeatures* 是一个0和1之间的浮点数，则在一次分裂时选取 int(特征列数量\\**maxFeatures*) 个特征。\n\n**numTrees** 是正整数，表示森林中树的个数。默认值为10。\n\n**numBins** 是正整数，表示离散化连续特征时的桶数。默认值为32。增加 *numBins* 会使算法考虑更多的分裂结点的决策值，产生更好的分裂结果，但也会提高计算量和通讯量。\n\n**maxDepth** 是正整数，表示树的最大深度。默认值为32。\n\n**minImpurityDecrease** 是浮点数，如果分裂产生的基尼指数纯度减少值大于或等于这个值，结点会继续分裂。\n\n**numJobs** 是一个整数，表示训练时使用的任务数。它是可选参数，默认值为-1，表示训练时使用所有的线程。如果 *numJobs* 小于-1，假如设置的 localExecutor 参数为 n，产生的任务数为 (n+2+numJobs)。实际执行过程中，最多会产生 min(numTrees, n+1)个任务。如果 *ds* 中有数据源位于远程节点，该参数不起作用，只产生一个任务。\n\n**randomSeed** 是随机数生成器使用的种子。\n\n#### 详情\n\n计算指定数据源中 *yColName* 和 *xColNames* 随机森林分类。返回结果是字典，包含以下 key：numClasses, minImpurityDecrease, maxDepth, numBins, numTress, maxFeatures, model, modelName, xColNames。其中 model 是一个元组，保存了训练生成的树；modelName 为 “Random Forest Classifier”。\n\n生成的模型可以作为 `predict` 函数的输入\n\n#### 例子\n\n用模拟数据训练一个随机森林回归模型\n\n```\nt = table(100:0, `cls`x0`x1, [INT,DOUBLE,DOUBLE])\ncls = take(0, 50)\nx0 = norm(-1.0, 1.0, 50)\nx1 = norm(-1.0, 1.0, 50)\ninsert into t values (cls, x0, x1)\ncls = take(1, 50)\nx0 = norm(1.0, 1.0, 50)\nx1 = norm(1.0, 1.0, 50)\ninsert into t values (cls, x0, x1)\n\nmodel = randomForestClassifier(sqlDS(<select * from t>), `cls, `x0`x1, 2);\n```\n\n把模型用于预测\n\n```\npredict(model, t)\n```\n\n加载一个保存的模型\n\n```\nloadModel(\"C:/DolphinDB/data/classifierModel.bin\")\n```\n\n相关函数：[adaBoostRegressor](https://docs.dolphindb.cn/zh/funcs/a/adaBoostRegressor.html), [adaBoostClassifier](https://docs.dolphindb.cn/zh/funcs/a/adaBoostClassifier.html), [randomForestRegressor](https://docs.dolphindb.cn/zh/funcs/r/randomForestRegressor.html)\n"
    },
    "randomForestRegressor": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randomForestRegressor.html",
        "signatures": [
            {
                "full": "randomForestRegressor(ds, yColName, xColNames, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=32], [minImpurityDecrease=0.0], [numJobs=-1], [randomSeed])",
                "name": "randomForestRegressor",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[maxFeatures=0]",
                        "name": "maxFeatures",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[numTrees=10]",
                        "name": "numTrees",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[numBins=32]",
                        "name": "numBins",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[maxDepth=32]",
                        "name": "maxDepth",
                        "optional": true,
                        "default": "32"
                    },
                    {
                        "full": "[minImpurityDecrease=0.0]",
                        "name": "minImpurityDecrease",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[numJobs=-1]",
                        "name": "numJobs",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[randomSeed]",
                        "name": "randomSeed",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [randomForestRegressor](https://docs.dolphindb.cn/zh/funcs/r/randomForestRegressor.html)\n\n\n\n#### 语法\n\nrandomForestRegressor(ds, yColName, xColNames, \\[maxFeatures=0], \\[numTrees=10], \\[numBins=32], \\[maxDepth=32], \\[minImpurityDecrease=0.0], \\[numJobs=-1], \\[randomSeed])\n\n#### 参数\n\n**ds** 是数据源，通常用 `sqlDS` 函数生成。\n\n**yColName** 是字符串，表示数据源中作为因变量的列名\n\n**xColNames** 是字符串标量或向量，表示数据源中作为自变量的列名。\n\n**maxFeatures** 是一个整数或浮点数，表示一次分裂节点选取的特征个数或比例。默认值是0。\n\n* 如果 *maxFeatures* 为正整数，则在一次分裂时选取 *maxFeatures* 个特征。\n\n* 如果 *maxFeatures* =0，则在一次分裂时选取 sqrt(特征列数量) 个特征。\n\n* 如果 *maxFeatures* 是一个0和1之间的浮点数，则在一次分裂时选取 int(特征列数量\\*maxFeatures) 个特征\n\n**numTrees** 是正整数，表示森林中树的个数。默认值为10。\n\n**numBins** 是正整数，表示离散化连续特征时的桶数。默认值为32。增加 *numBins* 会使算法考虑更多的分裂结点的决策值，产生更好的分裂结果，但也会提高计算量和通讯量。\n\n**maxDepth** 是正整数，表示树的最大深度。默认值为32。\n\n**minImpurityDecrease** 是浮点数，如果分裂产生的纯度减少值大于或等于这个值，结点会继续分裂。纯度用方差来计算。默认值是0。\n\n**numJobs** 是一个整数，表示训练时使用的任务数。它是可选参数，默认值为-1，表示训练时使用所有的线程。如果 *numJobs* 小于-1，假如设置的 localExecutor 参数为 n，产生的任务数为 (n+2+numJobs)。实际执行过程中，最多会产生 min(numTrees, n+1) 个任务。如果 *ds* 中有数据源位于远程节点，该参数不起作用，只产生一个任务。\n\n**randomSeed** 是随机数生成器使用的种子。\n\n#### 详情\n\n计算指定数据源中 *yColName* 和 *xColNames* 随机森林分类。返回结果是字典，包含以下 key：minImpurityDecrease, maxDepth, numBins, numTress, maxFeatures, model, modelName, xColNames。其中 model 是一个元组，保存了训练生成的树；modelName 为 “Random Forest Regressor”。\n\n生成的模型可以作为 `predict` 函数的输入。\n\n#### 例子\n\n用模拟数据训练一个随机森林回归模型\n\n```\nx1 = rand(100.0, 100)\nx2 = rand(100.0, 100)\nb0 = 6\nb1 = 1\nb2 = -2\nerr = norm(0, 10, 100)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(x1, x2, y)\nmodel = randomForestRegressor(sqlDS(<select * from t>), `y, `x1`x2)\nyhat=predict(model, t);\n\nplot(y, yhat, ,SCATTER);\n```\n\n保存模型到磁盘\n\n```\nsaveModel(model, \"C:/DolphinDB/Data/regressionModel.bin\")\n```\n\n加载一个保存的模型\n\n```\nloadModel(\"C:/DolphinDB/Data/regressionModel.bin\")\n```\n\n相关函数：[adaBoostClassifier](https://docs.dolphindb.cn/zh/funcs/a/adaBoostClassifier.html),[randomForestClassifier](https://docs.dolphindb.cn/zh/funcs/r/randomForestClassifier.html)\n"
    },
    "randPoisson": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randPoisson.html",
        "signatures": [
            {
                "full": "randPoisson(mean, count)",
                "name": "randPoisson",
                "parameters": [
                    {
                        "full": "mean",
                        "name": "mean"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randPoisson](https://docs.dolphindb.cn/zh/funcs/r/randPoisson.html)\n\n\n\n#### 语法\n\nrandPoisson(mean, count)\n\n#### 参数\n\n**mean** 是泊松分布的均值。\n\n**count** 是正整数，表示生成的随机数个数。\n\n#### 详情\n\n生成指定个数的泊松分布随机数。\n\n#### 例子\n\n```\nrandPoisson(2.31, 2);\n// output\n[7, 2]\n```\n"
    },
    "randStudent": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randStudent.html",
        "signatures": [
            {
                "full": "randStudent(df, count)",
                "name": "randStudent",
                "parameters": [
                    {
                        "full": "df",
                        "name": "df"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randStudent](https://docs.dolphindb.cn/zh/funcs/r/randStudent.html)\n\n\n\n#### 语法\n\nrandStudent(df, count)\n\n#### 参数\n\n**df** 是正数，表示t分布的自由度。\n\n**count** 是正整数，表示生成的随机数个数。\n\n#### 详情\n\n生成指定个数的 t 分布随机数。\n\n#### 例子\n\n```\nrandStudent(2.31, 2);\n\n// output\n[-0.543993, 0.375804]\n```\n"
    },
    "randUniform": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randUniform.html",
        "signatures": [
            {
                "full": "randUniform(lower, upper, count)",
                "name": "randUniform",
                "parameters": [
                    {
                        "full": "lower",
                        "name": "lower"
                    },
                    {
                        "full": "upper",
                        "name": "upper"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randUniform](https://docs.dolphindb.cn/zh/funcs/r/randUniform.html)\n\n\n\n#### 语法\n\nrandUniform(lower, upper, count)\n\n#### 参数\n\n**lower** 和 **upper** 是数值型标量，表示连续均匀分布的下限和上限。\n\n**count** 是正整数，表示生成的随机数个数。\n\n#### 详情\n\n生成指定个数的均匀分布随机数。\n\n#### 例子\n\n```\nrandUniform(0.61, 2.31, 2);\n\n// output\n[2.064851, 2.263172]\n```\n"
    },
    "randWeibull": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/randWeibull.html",
        "signatures": [
            {
                "full": "randWeibull(alpha, beta, count)",
                "name": "randWeibull",
                "parameters": [
                    {
                        "full": "alpha",
                        "name": "alpha"
                    },
                    {
                        "full": "beta",
                        "name": "beta"
                    },
                    {
                        "full": "count",
                        "name": "count"
                    }
                ]
            }
        ],
        "markdown": "### [randWeibull](https://docs.dolphindb.cn/zh/funcs/r/randWeibull.html)\n\n\n\n#### 语法\n\nrandWeibull(alpha, beta, count)\n\n#### 参数\n\n形状参数 **alpha** 和 **beta** 都是正数。\n\n**count** 是正整数，表示生成的随机数个数。\n\n#### 详情\n\n生成指定个数的 Weibull 分布随机数。\n\n#### 例子\n\n```\nrandWeibull(2.31,0.61, 2);\n\n// output\n[0.524197, 0.51402]\n```\n"
    },
    "rank": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rank.html",
        "signatures": [
            {
                "full": "rank(X, [ascending=true], [groupNum], [ignoreNA=true], [tiesMethod='min'], [percent=false], [precision])",
                "name": "rank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[groupNum]",
                        "name": "groupNum",
                        "optional": true
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='min']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'min'"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[precision]",
                        "name": "precision",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rank](https://docs.dolphindb.cn/zh/funcs/r/rank.html)\n\n#### 语法\n\nrank(X, \\[ascending=true], \\[groupNum], \\[ignoreNA=true], \\[tiesMethod='min'], \\[percent=false], \\[precision])\n\n#### 参数\n\n**X** 是一个向量、矩阵或表。\n\n**ascending** 是一个布尔值，表示是否按升序排序。默认值是 true。\n\n**groupNum** 是一个正整数，指定该参数后，元素将分成指定数量的组，按组进行排序。\n\n**ignoreNA** 是一个布尔值，表示是否忽略 NULL 值，默认值为 true。false 表示 NULL 作为最小值参与排名。\n\n**tiesMethod** 是一个字符串，表示如何对具有相同值的元素进行排名。\n\n* 'min' 表示取最小排名。\n\n* 'max' 表示取最大排名。\n\n* 'average' 表示取排名的均值。\n\n* 'first' 表示按照原数据的顺序排名。\n\n**percent** 是一个布尔值，表示是否以百分比形式显示返回的排名。\n\n**precision** 是一个 \\[1, 15] 范围内的整数，用于设置参与排序的值的精度。若两个值之差的绝对值小于等于 10^(-precision) ，则认为两值相等。\n\n**Note:** 指定 *precision* 参数后，*X* 只能是数值型对象。且 *tiesMethod* 不能指定为 'first'。\n\n#### 详情\n\n基于 *ascending* 指定的排序顺序，返回 *X* 中每个元素的排名（从0开始排序）。\n\n* 若 *X* 是向量，返回一个与*X*等长的向量：\n  * 如果指定了 *groupNum*，则将排序后的 *X* 分成 *groupNum* 个组。返回 *X* 中每个元素对应的组编号（从0开始编号）。\n\n    **Note:**\n\n    * 若 *X*不能被均分，则前 mod(size(X), groupNum) 组将多存放一个元素。例如 *X* 的元素个数为6，*groupNum* = 4，排名后的第1和2个元素属于组0，第3和4个元素属于组1，第5个和第6个元素分别属于组2和组3。\n    * 若 *X* 中相同元素分别属于不同的组，则所有相同元素返回最小的组号。\n  * 如果 *ignoreNA* = true，则 NULL 值不参与排序，结果中 NULL 值的排名为空。\n\n* 若 *X* 是矩阵或表，在每列内进行上述计算，返回一个与 *X* 维度相同的矩阵或表。\n\n#### 例子\n\n```\nrank(45 16 32 21);\n// output\n[3,0,2,1]\n\nrank(45 16 32 21, false);\n// output\n[0,3,1,2]\n\nrank(9 1 6 1 3 3);\n// output\n[5,0,4,0,2,2]\n// 两个相同的元素有相同的排名\n\nrank(X=9 5 4 8 1 3 6 2 7, groupNum=3);\n// output\n[2,1,1,2,0,0,1,0,2]\n\nrank(X=9 5 4 8 1 3 6 2 7, groupNum=6)\n// output\n[5,2,1,4,0,1,2,0,3]\n\nrank(X=9 5 4 8 1 3 6 2 7, ascending=false, groupNum=3);\n// output\n[0,1,1,0,2,2,1,2,0]\n\nrank(X=1 2 2 3, tiesMethod='min');\n// output\n[0,1,1,3]\n\nrank(X=1 2 2 3, tiesMethod='average');\n// output\n[0,1.5,1.5,3]\n\nrank(X=1 2 2 3, tiesMethod='first');\n// output\n[0,1,2,3]\n\nrank(1 NULL NULL 3);\n// output\n[0,,,1]\n\nrank(X=1 NULL NULL 3, ignoreNA=false);\n// output\n[2,0,0,3]\n\nt=table(1 1 1 2 2 2 2 as id, 3 5 4 6 2 7 1 as x)\nt\n```\n\n| id | x |\n| -- | - |\n| 1  | 3 |\n| 1  | 5 |\n| 1  | 4 |\n| 2  | 6 |\n| 2  | 2 |\n| 2  | 7 |\n| 2  | 1 |\n\n```\nselect *, rank(x) from t context by id;\n```\n\n| id | x | rank\\_x |\n| -- | - | ------- |\n| 1  | 3 | 0       |\n| 1  | 5 | 2       |\n| 1  | 4 | 1       |\n| 2  | 6 | 2       |\n| 2  | 2 | 1       |\n| 2  | 7 | 3       |\n| 2  | 1 | 0       |\n\n"
    },
    "ratio": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/ratio.html",
        "signatures": [
            {
                "full": "ratio(X, Y)",
                "name": "ratio",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [ratio](https://docs.dolphindb.cn/zh/funcs/r/ratio.html)\n\n#### 语法\n\nratio(X, Y)\n\n或\n\nX\\Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量或矩阵。\n\n如果 *X* 或 *Y* 的其中一个是数据对、向量或矩阵，另一个必须是具有相同长度的数据对、向量或矩阵。\n\n#### 详情\n\n逐个元素地返回 *X* 和 *Y* 的比例。ratio函数总是返回浮点数。如果 *X* 和 *Y* 都是 integer/long 类型，`ratio` 把它们转换为浮点数，并执行除法。 这和除法运算符 [div](https://docs.dolphindb.cn/zh/funcs/d/div.html) (/)不同，除法运算符不把 integer/long 类型转换成浮点数。另一个不同点是，当 *X* 参数是整数时，该函数的 *Y* 参数可以是负整数。\n\n#### 例子\n\n```\n9\\2:5;\n// output\n4.5 : 1.8\n11:25\\3:4;\n// output\n3.666667 : 6.25\n\nx=1 2 3;\nx \\ 2;\n// output\n[0.5,1,1.5]\n2 \\ x;\n// output\n[2,1,0.666667]\n\ny=4 5 6;\n x \\ y;\n// output\n[0.25,0.4,0.5]\ny \\ x;\n// output\n[4,2.5,2]\n\nm1=1..6$2:3;\nm1\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\n m1\\2;\n```\n\n| #0  | #1  | #2  |\n| --- | --- | --- |\n| 0.5 | 1.5 | 2.5 |\n| 1   | 2   | 3   |\n\n```\nm2=6..1$2:3;\nm2\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1\\m2;\n```\n\n| #0       | #1       | #2  |\n| -------- | -------- | --- |\n| 0.166667 | 0.75     | 2.5 |\n| 0.4      | 1.333333 | 6   |\n\n```\n-7\\5;\n// output\n-1.4\nx=-1 2 3;\nx\\-5;\n// output\n[0.2,-0.4,-0.6]\n```\n\n"
    },
    "ratios": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/ratios.html",
        "signatures": [
            {
                "full": "ratios(X)",
                "name": "ratios",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ratios](https://docs.dolphindb.cn/zh/funcs/r/ratios.html)\n\n#### 语法\n\nratios(X)\n\n#### 参数\n\n**X** 是一个向量或矩阵。\n\n#### 详情\n\n若 *X* 是向量，返回 X(n)\\X(n-1) 的值。返回结果的第一个元素是 NULL。\n\n若 *X* 是矩阵，在每列内进行上述计算，返回一个与 *X* 维度相同的矩阵。\n\n#### 例子\n\n```\nx=3 12 0 -5 32;\nratios x;\n// output\n[,4,0,,-6.4]\n\nx=2 3 6 NULL 28 7;\nratios x;\n// output\n[,1.5,2,,,0.25]\n\nm=matrix(100 105 109 112 108 116, 200 212 208 199 206 210);\nm;\n```\n\n| #0  | #1  |\n| --- | --- |\n| 100 | 200 |\n| 105 | 212 |\n| 109 | 208 |\n| 112 | 199 |\n| 108 | 206 |\n| 116 | 210 |\n\n```\nratios(m);\n```\n\n| #0                | #1                |\n| ----------------- | ----------------- |\n|                   |                   |\n| 1.05              | 1.06              |\n| 1.038095238095238 | 0.981132075471698 |\n| 1.027522935779817 | 0.956730769230769 |\n| 0.964285714285714 | 1.035175879396985 |\n| 1.074074074074074 | 1.019417475728155 |\n\n"
    },
    "rdp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rdp.html",
        "signatures": [
            {
                "full": "rdp(pointList, epsilon)",
                "name": "rdp",
                "parameters": [
                    {
                        "full": "pointList",
                        "name": "pointList"
                    },
                    {
                        "full": "epsilon",
                        "name": "epsilon"
                    }
                ]
            }
        ],
        "markdown": "### [rdp](https://docs.dolphindb.cn/zh/funcs/r/rdp.html)\n\n\n\n#### 语法\n\nrdp(pointList, epsilon)\n\n#### 参数\n\n**pointList** 是一个 POINT 类型向量，且不能包含空元素。\n\n**epsilon** 是一个非负的 DOUBLE 类型的标量，表示压缩阈值。\n\n#### 详情\n\n使用 RDP(Ramer-Douglas-Peucker) 矢量压缩算法对 POINT 类型向量进行压缩。\n\n#### 例子\n\n```\npt = point(1 2 3 4, 1 2 3 4)\nrdp(pt, 0.1)\n// output\n[(1.0, 1.0), (4.0, 4.0)]\n​\npt = point(1 2 3 4, 1 3 3 4)\nrdp(pt, 0.1)\n// output\n[(1.0, 1.0), (2.0, 3.0), (3.0, 3.0), (4.0, 4.0)]\n\ntemp = array(POINT,0)\nn=90000\nx_data = rand(10.0,n)\ny_data = rand(10.0,n)\nindex=0\ndo{\ntemp.append!(point(x_data[index], y_data[index]))\nindex += 1\n}while(index<n)\ns=rdp(temp, 0.8)\nprint(s.size())\n// output\n82002\nprint(temp.size())\n// output\n90000\n```\n"
    },
    "readBytes": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/readBytes.html",
        "signatures": [
            {
                "full": "readBytes(fileHandle, sizeInByte)",
                "name": "readBytes",
                "parameters": [
                    {
                        "full": "fileHandle",
                        "name": "fileHandle"
                    },
                    {
                        "full": "sizeInByte",
                        "name": "sizeInByte"
                    }
                ]
            }
        ],
        "markdown": "### [readBytes](https://docs.dolphindb.cn/zh/funcs/r/readBytes.html)\n\n\n\n#### 语法\n\nreadBytes(fileHandle, sizeInByte)\n\n#### 参数\n\n**fileHandle** 是文件句柄。\n\n**sizeInByte** 是整数，用于指定读取的字节数。\n\n#### 详情\n\n从句柄中读取给定数目的字节。如果文件到达结尾，或发生了 IO 错误，将抛出一个 IOException；否则返回一个包含了给定数目字节的缓冲区。因此，必须在调用函数之前知道要读取的确切的字节数。\n\n#### 例子\n\n```\n// 定义一个文件复制函数\ndef fileCopy(source, target){\ns = file(source)\nlen = s.seek(0,TAIL)\ns.seek(0,HEAD)\nt = file(target,\"w\")\nif(len==0) return\ndo{\n  buf = s.readBytes(min(len,1024))\n  t.writeBytes(buf)\n  len -= buf.size()\n}while(len)\n};\nfileCopy(\"test.txt\",\"testcopy.txt\");\n```\n"
    },
    "readLine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/readLine.html",
        "signatures": [
            {
                "full": "readLine(handle)",
                "name": "readLine",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    }
                ]
            }
        ],
        "markdown": "### [readLine](https://docs.dolphindb.cn/zh/funcs/r/readLine.html)\n\n\n\n#### 语法\n\nreadLine(handle)\n\n#### 参数\n\n**handle** 是文件句柄。\n\n#### 详情\n\n从给定的文件中读取一行。返回的行不包括换行符。如果文件结束，函数会返回一个 NULL 对象，可以用 [isNull](https://docs.dolphindb.cn/zh/funcs/i/isNull.html) 函数测试。\n\n#### 例子\n\n```\nx=`IBM`MSFT`GOOG`YHOO`ORCL;\neachRight(writeLine, file(\"test.txt\",\"w\"), x);\n\n// output\n[1,1,1,1,1]\n\nfin = file(\"test.txt\")\ndo{\nx=fin.readLine()\nif(x.isNull()) break\nprint x\n}while(true);\n\n// output\nIBM\nMSFT\nGOOG\nYHOO\nORCL\n```\n"
    },
    "readLines": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/readLines.html",
        "signatures": [
            {
                "full": "readLines(handle, [length=1024])",
                "name": "readLines",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "[length=1024]",
                        "name": "length",
                        "optional": true,
                        "default": "1024"
                    }
                ]
            }
        ],
        "markdown": "### [readLines](https://docs.dolphindb.cn/zh/funcs/r/readLines.html)\n\n\n\n#### 语法\n\nreadLines(handle, \\[length=1024])\n\n#### 参数\n\n**handle** 是文件句柄。\n\n**length** 是从文件中读取的行数。默认的读取行数是1024。\n\n#### 详情\n\n从文件中读取指定行数。如果到达文件尾部或者已经读取指定行数后，函数将返回。\n\n#### 例子\n\n```\n timer(10){\n x=rand(`IBM`MSFT`GOOG`YHOO`ORCL,10240)\n eachRight(writeLine, file(\"test.txt\",\"w\"),x)\n fin = file(\"test.txt\")\n do{\n    y=fin.readLine()\n } while(!y.isVoid())\n fin.close()\n };\n// output\nTime elapsed: 277.548 ms ms\n\n timer(10){\n x=rand(`IBM`MSFT`GOOG`YHOO`ORCL,10240)\n file(\"test.txt\",\"w\").writeLines(x)\n fin = file(\"test.txt\")\n do{\n    y=fin.readLines(1024)\n } while(y.size()==1024)\n  fin.close()\n };\n// output\nTime elapsed: 28.003 ms\n```\n"
    },
    "readLines!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/readLines_.html",
        "signatures": [
            {
                "full": "readLines!(handle, holder, [offset=0], [length=1])",
                "name": "readLines!",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "holder",
                        "name": "holder"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length=1]",
                        "name": "length",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [readLines!](https://docs.dolphindb.cn/zh/funcs/r/readLines_.html)\n\n\n\n#### 语法\n\nreadLines!(handle, holder, \\[offset=0], \\[length=1])\n\n#### 参数\n\n**handle** 是文件句柄。\n\n**holder** 是用于保存读取的数据的变量。\n\n**offset** 表示数据保存至holder的起始位置。\n\n**length** 是从文件中读取的行数。\n\n#### 详情\n\n从句柄中读取给定数量的字符串，并从指定位置开始，把读取结果保存至 *holder* 表示的变量中。函数返回实际读取的行数。\n\n[readLines](https://docs.dolphindb.cn/zh/funcs/r/readLines.html) 函数的每次调用都创建了一个字符串向量并返回。创建字符串向量需要一定的时间开销，所以如果在重复执行函数调用时，能重用相同的向量作为缓冲区的话，可以节约时间。 `readLines!`函数接受已存在的缓冲区作为数据容器。\n\n下述的两个例子读取相同数量的数据 100 次，结果显示：`readLines!` 函数比 `readLines` 函数更快。\n\n#### 例子\n\n```\n timer(100){\n fin = file(\"test.txt\")\n do{ y=fin.readLines(1024) } while(y.size()==1024)\n fin.close()\n };\n// output\nTime elapsed: 79.511 ms\n\n timer(100){\n fin = file(\"test.txt\")\n y=array(STRING,1024)\n do{ lines = fin.readLines!(y,0,1024) } while(lines==1024)\n fin.close()\n };\n\n// output\nTime elapsed: 56.034 ms\n```\n"
    },
    "readObject": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/readObject.html",
        "signatures": [
            {
                "full": "readObject(handle)",
                "name": "readObject",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    }
                ]
            }
        ],
        "markdown": "### [readObject](https://docs.dolphindb.cn/zh/funcs/r/readObject.html)\n\n\n\n#### 语法\n\nreadObject(handle)\n\n#### 参数\n\n**handle** 是文件句柄。\n\n#### 详情\n\n可以将所有的数据类型读取到句柄中，包括标量、向量、矩阵、集合、字典和表。该函数必须要用户登录后才能执行。\n\n#### 例子\n\n```\na1=10.5\na2=1..10\na3=cross(*,1..5,1..10)\na4=set(`IBM`MSFT`GOOG`YHOO)\na5=dict(a4.keys(),125.6 53.2 702.3 39.7)\na6=table(1 2 3 as id, `Jenny`Tom`Jack as name)\na7=(1 2 3, \"hello world!\", 25.6)\n\nfout=file(\"test.bin\",\"w\")\nfout.writeObject(a1)\nfout.writeObject(a2)\nfout.writeObject(a3)\nfout.writeObject(a4)\nfout.writeObject(a5)\nfout.writeObject(a6)\nfout.writeObject(a7)\nfout.close();\n```\n\n上述的脚本把 7 个不同类型的对象写到一个文件中。下述的脚本将这 7 个对象从文件中读取出来，并为每个对象打印一个简短的描述。\n\n```\nfin = file(\"test.bin\")\nfor(i in 0:7) print typestr fin.readObject()\nfin.close();\n\n// output\nDOUBLE\nFAST INT VECTOR\nINT MATRIX\nSTRING SET\nSTRING->DOUBLE Dictionary\nTABLE\nANY VECTOR\n```\n"
    },
    "readRecord!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/readRecord_.html",
        "signatures": [
            {
                "full": "readRecord!(handle, holder, [offset=0], [length])",
                "name": "readRecord!",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "holder",
                        "name": "holder"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [readRecord!](https://docs.dolphindb.cn/zh/funcs/r/readRecord_.html)\n\n\n\n#### 语法\n\nreadRecord!(handle, holder, \\[offset=0], \\[length])\n\n#### 参数\n\n**handle** 是文件句柄。\n\n**holder** 是用于保存读取的数据的变量。\n\n**offset** 表示数据保存至 *holder* 的起始位置。\n\n**length** 是从文件中读取的行数。\n\n#### 详情\n\n`readRecord!` 函数将二进制文件转换为 DolphinDB 数据对象。DolphinDB 也提供了 [writeRecord](https://docs.dolphindb.cn/zh/funcs/w/writeRecord.html) 函数，用于将 DolphinDB 数据对象转换为二进制文件，以供其它程序使用。 二进制文件基于行，且每行包含的记录有相同的数据类型和固定的长度。例如，如果一个二进制文件包含了 5 个数据域，分别具有下述数据类型（长度）：char(1), boolean(1), short(2), int(4), long(8), 和 double(8)， 那么 `readRecord!` 函数将把每行视为 24 个字节。类似地，`writeRecord` 函数把 DolphinDB 对象（例如表或元组）转换为具有上述格式的二进制文件。\n\n#### 例子\n\n```\n// 创建一个文件句柄，用于读取记录。二进制文件 a.bin 包含了 1000 条记录。\nf=file(\"c:/DB/a.bin\")\nt=table(1000:0, `PERMNO`PRC`VOL`SHROUT, `int`double`int`double)\nf.readRecord!(t);\n// output\n1000\n\n// 类似地，我们可以将一个二进制文件读入一个 DolphinDB 元组对象\nf=file(\"c:/DB/a.bin\")\nt=loop(array, [int, double, int, double], 0, 500)\n// 创建具有 4 个数组元素的元组 t。每一个数组的长度是 500\n f.readRecord!(t, 0, 500);\n// 读取前 500 行\n// output\n500\n```\n"
    },
    "read!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/read_.html",
        "signatures": [
            {
                "full": "read!(handle, holder, [offset=0], [length=1])",
                "name": "read!",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "holder",
                        "name": "holder"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length=1]",
                        "name": "length",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [read!](https://docs.dolphindb.cn/zh/funcs/r/read_.html)\n\n\n\n#### 语法\n\nread!(handle, holder, \\[offset=0], \\[length=1])\n\n#### 参数\n\n**handle** 是文件句柄。\n\n**holder** 是用于保存读取的数据的变量。\n\n**offset** 表示数据保存至 *holder* 的起始位置。\n\n**length** 是读取的数据点数量。\n\n#### 详情\n\n从文件句柄中读取指定数目的数据点，并从指定位置开始，把读取结果保存至 *holder* 表示的变量中。读入的数据和 *holder* 具有相同的数据类型。函数将返回实际读入的数据点的个数。\n\n[readBytes](https://docs.dolphindb.cn/zh/funcs/r/readBytes.html) 函数总是返回一个新的 CHAR 向量。创建一个新的向量缓冲区时会花费一定时间。为了提高性能，可以创建一个缓冲区，并重复利用。`read!`函数就是使用这样的方式提高速度。\n\n使用 `read!` 的另一个好处是，用户不需要知道确切的读取字节数。函数在文件到达结尾时返回，并给出读取的字节数。如果返回的字节数小于预期，表明文件已经到达结尾。\n\n#### 例子\n\n```\n// 用 read! 和 write 函数定义一个复制函数\n\ndef fileCopy(source, target){\ns = file(source)\nt = file(target,\"w\")\nbuf = array(CHAR,1024)\ndo{\n  numByte = s.read!(buf,0,1024)\n  t.write(buf,0, numByte)\n}while(numByte==1024)\n}\nfileCopy(\"test.txt\",\"testcopy.txt\");\n```\n"
    },
    "rebalanceChunksAmongDataNodes": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rebalanceChunksAmongDataNodes.html",
        "signatures": [
            {
                "full": "rebalanceChunksAmongDataNodes([exec = false], [updatedBeforeDays = 7.0])",
                "name": "rebalanceChunksAmongDataNodes",
                "parameters": [
                    {
                        "full": "[exec = false]",
                        "name": "[exec = false]"
                    },
                    {
                        "full": "[updatedBeforeDays = 7.0]",
                        "name": "[updatedBeforeDays = 7.0]"
                    }
                ]
            }
        ],
        "markdown": "### [rebalanceChunksAmongDataNodes](https://docs.dolphindb.cn/zh/funcs/r/rebalanceChunksAmongDataNodes.html)\n\n\n\n#### 语法\n\nrebalanceChunksAmongDataNodes(\\[exec = false], \\[updatedBeforeDays = 7.0])\n\n#### 参数\n\n**exec** 布尔值，表示是否进行数据平衡。默认值为 false，表示输出数据平衡的执行计划，并不执行数据迁移。若设置为 true，则系统会执行数据迁移。\n\n**updatedBeforeDays** 非负浮点数，用于确定可以进行平衡的数据的时间范围，默认值是7，单位是天。表示数据块（chunk）的最后一次写入或更新（修改）时间发生在7天前时，才会进行平衡。\n\n#### 详情\n\n在集群中的所有磁盘间平衡数据，以保证集群达到最佳性能。在集群中增加节点、磁盘后，或者在磁盘负载过高时，通常需要执行此操作。只能由管理员在控制节点上执行。\n\n返回一个表，包含以下列：\n\n| 列名         | 含义          |\n| ---------- | ----------- |\n| srcNode    | 源节点的别名      |\n| chunkId    | chunk 的唯一标识 |\n| destNode   | 目标节点的别名     |\n| destVolume | 目标磁盘卷的路径    |\n\n调用该函数后，可以在控制节点上执行 [getRecoveryTaskStatus](https://docs.dolphindb.cn/zh/funcs/g/getRecoveryTaskStatus.html) 查看任务执行的状态。\n\n调用该函数后，系统会打印 INFO 级别的日志，输出每个磁盘的原始使用率以及平衡后的使用率。日志内容的格式如下：\n\n```\n[rebalance] Expected change of disk usage rate is 原本占有率->搬运后占有率\n[rebalance] Change of disk usage rate in 磁盘所在IP@磁盘fsid(1/磁盘数) is 原本占有率->搬运后占有率\n[rebalance] Change of disk usage rate in 磁盘所在IP@磁盘fsid(2/磁盘数) is 原本占有率->搬运后占有率\n...\n```\n\n#### 例子\n\n```\nrebalanceChunksAmongDataNodes()\n```\n\n| srcNode | chunkId                              | destNode | destVolume              |\n| ------- | ------------------------------------ | -------- | ----------------------- |\n| node1   | 99279094-ca12-3b87-48b6-520cbb986f39 | node2    | /home/xxx/node2/storage |\n| node1   | 45f612b8-42f5-aebd-4cef-e522b6ae1fc8 | node2    | /home/xxx/node2/storage |\n"
    },
    "rebalanceChunksWithinDataNode": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rebalanceChunksWithinDataNode.html",
        "signatures": [
            {
                "full": "rebalanceChunksWithinDataNode(nodeAlias, [exec=false], [updatedBeforeDays = 7.0])",
                "name": "rebalanceChunksWithinDataNode",
                "parameters": [
                    {
                        "full": "nodeAlias",
                        "name": "nodeAlias"
                    },
                    {
                        "full": "[exec=false]",
                        "name": "exec",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[updatedBeforeDays = 7.0]",
                        "name": "[updatedBeforeDays = 7.0]"
                    }
                ]
            }
        ],
        "markdown": "### [rebalanceChunksWithinDataNode](https://docs.dolphindb.cn/zh/funcs/r/rebalanceChunksWithinDataNode.html)\n\n\n\n#### 语法\n\nrebalanceChunksWithinDataNode(nodeAlias, \\[exec=false], \\[updatedBeforeDays = 7.0])\n\n#### 参数\n\n**nodeAlias** 字符串，表示数据节点的别名。\n\n**exec** 布尔值，表示是否在节点内进行数据平衡。默认值为 false，输出数据平衡的执行计划，并不执行数据迁移。若设置为 true，则系统会执行数据迁移。\n\n**updatedBeforeDays** 非负浮点数，用于确定可以进行平衡的数据的时间范围，默认值是7，单位是天。表示数据块（chunk）的最后一次写入或更新（修改）时间发生在7天前时，才会进行平衡。\n\n#### 详情\n\n一个节点内部增加磁盘卷后，需要调整现有磁盘卷上的数据量，使各个磁盘卷上的数据量达到平衡。该函数用于平衡一个数据节点内各磁盘卷间的数据，返回一个表，显示各磁盘卷间数据平衡计划。 若 *exec* 为 true，则进行数据平衡；若 *exec* 为 false，则不进行数据平衡。它只能在集群环境下由管理员在控制节点上执行。\n\n返回结果包含以下列：\n\n| 列名         | 含义          |\n| ---------- | ----------- |\n| chunkId    | chunk 的唯一标识 |\n| srcVolume  | 源磁盘卷        |\n| destVolume | 目标磁盘卷       |\n\n调用该函数进行数据平衡后，可以在控制节点上执行 [getRecoveryTaskStatus](https://docs.dolphindb.cn/zh/funcs/g/getRecoveryTaskStatus.html) 查看任务执行的状态。\n\n**Note:** 自 2.00.12 版本起，rebalanceChunksWithinDataNode 支持单节点模式。\n\n调用该函数后，系统会打印 INFO 级别的日志，输出每个磁盘的原始使用率以及平衡后的使用率。日志内容的格式如下：\n\n```\n[rebalance] Change of disk usage rate () expect: 原本占有率 -> 搬运后占有率\n[rebalance] Change of disk usage rate (1 / 磁盘数) 磁盘所在IP@磁盘fsid: 原本占有率 -> 搬运后占有率\n[rebalance] Change of disk usage rate (2 / 磁盘数) 磁盘所在IP@磁盘fsid: 原本占有率 -> 搬运后占有率\n...\n```\n\n#### 例子\n\n```\nrebalanceChunksWithinDataNode(\"node1\")\n```\n\n| ChunkId                              | srcVolume         | destVolume        |\n| ------------------------------------ | ----------------- | ----------------- |\n| 82c6eb6c-36ee-b1b6-4a86-ca24d9faaa25 | /hdd/hdd1/volumes | /hdd/hdd2/volumes |\n"
    },
    "reciprocal": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/reciprocal.html",
        "signatures": [
            {
                "full": "reciprocal(X)",
                "name": "reciprocal",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [reciprocal](https://docs.dolphindb.cn/zh/funcs/r/reciprocal.html)\n\n\n\n#### 语法\n\nreciprocal(X)\n\n#### 参数\n\n**X** 可以是数值型标量、向量或矩阵。\n\n#### 详情\n\n返回 *X* 的倒数。返回结果为 DOUBLE 类型。\n\n#### 例子\n\n```\nreciprocal(10);\n// output\n0.1\n\nreciprocal(1 2 4 8);\n// output\n[1,0.5,0.25,0.125]\n\nreciprocal(1 2 4 8$2:2);\n```\n\n| #0  | #1    |\n| --- | ----- |\n| 1   | 0.25  |\n| 0.5 | 0.125 |\n"
    },
    "refCount": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/refCount.html",
        "signatures": [
            {
                "full": "refCount(varname)",
                "name": "refCount",
                "parameters": [
                    {
                        "full": "varname",
                        "name": "varname"
                    }
                ]
            }
        ],
        "markdown": "### [refCount](https://docs.dolphindb.cn/zh/funcs/r/refCount.html)\n\n\n\n#### 语法\n\nrefCount(varname)\n\n#### 参数\n\n**varname** 是一个字符串，表示变量名称。\n\n#### 详情\n\n计算某个对象被引用的数量。\n\n#### 例子\n\n```\ndb=database(\"\",VALUE,1 2 3)\nrefCount(`db);\n// output\n1\n\ndb1=db\ndb2=db\nrefCount(`db);\n// output\n3\n```\n"
    },
    "regexCount": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/regexCount.html",
        "signatures": [
            {
                "full": "regexCount(str, pattern, [offset=0])",
                "name": "regexCount",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [regexCount](https://docs.dolphindb.cn/zh/funcs/r/regexCount.html)\n\n\n\n#### 语法\n\nregexCount(str, pattern, \\[offset=0])\n\n#### 参数\n\n**str** 是一个字符串或字符串向量。\n\n**pattern** 是一个字符串，表示搜索的模式字符串（[正则表达式](https://docs.dolphindb.cn/zh/progr/objs/expr.html)）。模式字符串可以包含字面量字符、元字符或两者的组合。\n\n**offset** 是一个非负整数，默认值为0。它是一个可选参数，表示从 *str* 的第 *offset* 个位置开始搜索。*str* 的第一个位置为0。\n\n#### 详情\n\n从 *str* 的第 *offset* 个位置开始搜索，返回与 *pattern* 匹配的字符串在 *str* 中出现的次数。\n\n#### 例子\n\n```\nregexCount(\"1231hsdU777_ DW#122ddd\", \"[0-9]+\");\n// output\n3\n\nregexCount(\"1231hsdU777_ DW#122ddd\", \"[0-9]+$\");\n// output\n0\n\nregexCount(\"1231hsdU777_ DW#122ddd\", \"^[0-9]+\");\n// output\n1\n\nregexCount(\"abc234 ff456\", \"[a-z]\", 3);\n// output\n2\n```\n"
    },
    "regexFind": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/regexFind.html",
        "signatures": [
            {
                "full": "regexFind(str, pattern, [offset])",
                "name": "regexFind",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [regexFind](https://docs.dolphindb.cn/zh/funcs/r/regexFind.html)\n\n\n\n#### 语法\n\nregexFind(str, pattern, \\[offset])\n\n#### 参数\n\n**str** 是一个字符串或字符串向量。\n\n**pattern** 是一个字符串，表示搜索的模式字符串（[正则表达式](https://docs.dolphindb.cn/zh/progr/objs/expr.html)）。模式字符串可以包含字面量字符、元字符或两者的组合。\n\n**offset** 是一个非负整数，默认值为0。它是一个可选参数，表示从 *str* 的第 *offset* 个位置开始搜索。*str* 的第一个位置为0。\n\n#### 详情\n\n从 *str* 的第 *offset* 个位置开始搜索与 *pattern* 匹配的字符串，如果在 *str* 中找到匹配字符串，则返回 *str* 中第一个匹配字符串的位置；如果没有找到，则返回-1。\n\n#### 例子\n\n```\nregexFind(\"1231hsdU777_ DW#122ddd\", \"[a-z]+\");\n// output\n4\n\nregexFind(\"1231hsdU777_ DW#122ddd\", \"[0-9]+\");\n// output\n0\n\nregexFind(\"1231hsdU777_ DW#122ddd\", \"[0-9]+\", 4);\n// output\n8\n```\n\n相关函数：[regexFindStr](https://docs.dolphindb.cn/zh/funcs/r/regexfindstr.html)\n"
    },
    "regexFindStr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/regexfindstr.html",
        "signatures": [
            {
                "full": "regexFindStr(str, pattern, [onlyFirst=true], [offset])",
                "name": "regexFindStr",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    },
                    {
                        "full": "[onlyFirst=true]",
                        "name": "onlyFirst",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [regexFindStr](https://docs.dolphindb.cn/zh/funcs/r/regexfindstr.html)\n\n#### 语法\n\nregexFindStr(str, pattern, \\[onlyFirst=true], \\[offset])\n\n#### 详情\n\n不同于 `regexFind` 返回满足条件的字符串位置，`regexFindStr` 从第 *offset* 个位置开始搜索，返回 *str* 中满足正则表达式 *pattern* 的字符串：\n\n* 当*str*为标量，且 *onlyFirst*为 true 时，若存在满足条件的子字符串，则返回一个字符串标量，否则返回一个空的字符串。\n\n* 当 *str*为标量，且 *onlyFirst*为 false 时，若存在满足条件的子字符串，则返回一个字符串向量，其元素为所有满足条件的子串。\n\n* 当 *str*为向量，且 *onlyFirst*为 true 时，返回一个字符串向量，其中每个元素都是 *str*中对应位置元素中第一个匹配正则表达式的子字符串。\n\n* 当 *str*为向量，且 *onlyFirst*为 false 时，返回一个元组，其中每个元素都是 *str*对应位置元素中所有匹配正则表达式的子字符串的向量。\n\n**Note:** 该函数新增于 2.00.11.1版本。\n\n#### 参数\n\n**str** 字符串或字符串向量，表示待搜索的对象。\n\n**pattern** 字符串，表示搜索的模式字符串（正则表达式）。模式字符串可以包含字面量字符、元字符或两者的组合。\n\n**onlyFirst** 布尔标量，表示是否只返回与正则表达式匹配的第一个子字符串：\n\n* 默认值为 true，此时针对 str 中的每一个字符串，仅返回第一个满足正则表达式的子字符串；\n\n* 设置为 false 时，针对 str 中的每一个字符串，返回所有满足正则表达式的非重叠匹配的子字符串。\n\n**offset** 非负整数，表示从 *str* 的第 *offset* 个位置开始搜索。默认值为0，即 *str* 的第一个位置。\n\n#### 例子\n\n*str* 为标量，且 *onlyFirst* 为 true 时：\n\n```\nregexFindStr('234AA(2)BBB S&P', '([A|B|C|+|-]*)', true)\n```\n\n返回：AA\n\n*str* 为标量，且 *onlyFirst* 为 *false* 时：\n\n```\nregexFindStr('234AA(2)BBB S&P', '([A|B|C|+|-]*)', false)\n```\n\n返回：\\[\"AA\",\"BBB\"]\n\n*str* 为向量，且 *onlyFirst* 为 true 时：\n\n```\nregexFindStr(['234AA(2)BBBS&P', '234AA(2)BBBS&P'], '([A|B|C|+|-]*)', true)\n```\n\n返回：\\[\"AA\",\"AA\"]\n\n*str* 为向量，且 *onlyFirst* 为 false 时：\n\n```\nregexFindStr(['234AA(2)BBBS&P', '234AA(2)BBBS&P'], '([A|B|C|+|-]*)', false)\n```\n\n返回：(\\[\"AA\",\"BBB\"],\\[\"AA\",\"BBB\"])\n\n\n\n**Related information**\n\n[regexFind](https://docs.dolphindb.cn/zh/funcs/r/regexFind.html)\n"
    },
    "regexReplace": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/regexReplace.html",
        "signatures": [
            {
                "full": "regexReplace(str, pattern, replacement, [offset])",
                "name": "regexReplace",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    },
                    {
                        "full": "replacement",
                        "name": "replacement"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [regexReplace](https://docs.dolphindb.cn/zh/funcs/r/regexReplace.html)\n\n\n\n#### 语法\n\nregexReplace(str, pattern, replacement, \\[offset])\n\n#### 参数\n\n**str** 是一个字符串或字符串向量。\n\n**pattern** 是一个字符串，表示搜索的模式字符串（[正则表达式](https://docs.dolphindb.cn/zh/progr/objs/expr.html)）。模式字符串可以包含字面量字符、元字符或两者的组合。\n\n**replacement** 是字符串标量，表示替换的字符串。\n\n**offset** 是一个非负整数，默认值为0。它是一个可选参数，表示从 *str* 的第 *offset* 个位置开始搜索。*str* 的第一个位置为0。\n\n#### 详情\n\n从 *str* 的第 *offset* 个位置开始搜索与 *pattern* 匹配的字符串，如果找到匹配字符串，则把匹配字符串替换成 *replacement*，然后返回替换后的字符串。\n\n#### 例子\n\n```\nregexReplace(\"abc234 ff456\", \"[a-z]\", \"z\");\n// output\nzzz234 zz456\n\nregexReplace(\"abc234 ff456\", \"[a-z]+\", \"zzz\");\n// output\nzzz234 zzz456\n\nregexReplace(\"abc234 ff456\", \"[0-9]+\", \"zzz\");\n// output\nabczzz ffzzz\n```\n"
    },
    "registerSnapshotEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/registerSnapshotEngine.html",
        "signatures": [
            {
                "full": "registerSnapshotEngine(dbName, tableName, keyColumnName, [dedupColumnName])",
                "name": "registerSnapshotEngine",
                "parameters": [
                    {
                        "full": "dbName",
                        "name": "dbName"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "keyColumnName",
                        "name": "keyColumnName"
                    },
                    {
                        "full": "[dedupColumnName]",
                        "name": "dedupColumnName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [registerSnapshotEngine](https://docs.dolphindb.cn/zh/funcs/r/registerSnapshotEngine.html)\n\n\n\n#### 语法\n\nregisterSnapshotEngine(dbName, tableName, keyColumnName, \\[dedupColumnName])\n\n#### 参数\n\n**dbName** 是一个字符串，表示分布式数据库的名称。\n\n**tableName** 是一个字符串，表示分布式表的名称。\n\n**keyColumnName** 是一个字符串，表示分组列的名称。\n\n**dedupColumnName**是一个字符串，引擎会在分组内根据该列对数据进行倒序排序，并保留排序后的第一条数据作为唯一记录。如果在集群中省略此参数，保留结果可能是随机的。\n\n#### 详情\n\n为分布式表注册一个快照引擎。快照引擎将分布式表按照 *keyColumnName* 指定的列分组，获取每个组的最新记录。注册快照引擎后，我们可以通过 select \\[HINT\\_SNAPSHOT] \\* from loadTable(dbName,tableName) 来获取每个分组的最新记录。\n\n使用 [unregisterSnapshotEngine](https://docs.dolphindb.cn/zh/funcs/u/unregisterSnapshotEngine.html) 函数可以取消注册快照引擎。\n\n**Note:**\n\n* 该功能目前不支持在包含计算节点的集群模式下运行。\n* 一个分布式表只能注册一个快照引擎。\n* 系统重启后，需要重新注册快照引擎。集群模式下，任一数据节点重启，整个集群都需要重新注册快照引擎，即先调用 [unregisterSnapshotEngine](https://docs.dolphindb.cn/zh/funcs/u/unregisterSnapshotEngine.html) 函数清空其他节点的 Snapshot 信息，再调用 `registerSnapshotEngine` 函数重新注册。\n\n#### 例子\n\n创建分布式表：\n\n```\ndb1=database(\"\",VALUE,2018.09.01..2018.09.30)\ndb2=database(\"\",VALUE,`AAPL`MSFT`MS`C)\ndb=database(\"dfs://compoDB\",COMPO,[db1,db2])\nt=table(1:0,`date`sym`val,[DATE,SYMBOL,DOUBLE])\npt=db.createPartitionedTable(t,`pt,`date`sym);\n```\n\n注册快照引擎来获取分布式表 pt 中每个股票代码对应的最新记录。\n\n```\nregisterSnapshotEngine(\"dfs://compoDB\",\"pt\",\"sym\");\n```\n\n写入数据，获取每个股票代码对应的最新记录。本例使用的是随机生成的数据，因此执行的结果有可能会与本例的结果不同。\n\n```\ndef writeData(batch){\n    pt=loadTable(\"dfs://compoDB\",\"pt\")\n    tmp=table(batch:0,`date`sym`val,[DATE,SYMBOL,DOUBLE])\n    dates=take(2018.09.01..2018.09.30,batch)\n    syms=take(`AAPL`MSFT`MS`C,batch)\n    vals=rand(100.0,batch)\n    insert into tmp values(dates,syms,vals)\n    pt.append!(tmp)\n}\n\nwriteData(1000);\n\nselect [HINT_SNAPSHOT] * from loadTable(\"dfs://compoDB\",\"pt\");\n```\n\n| date       | sym  | val       |\n| ---------- | ---- | --------- |\n| 2018.09.29 | AAPL | 24.945753 |\n| 2018.09.29 | MS   | 14.034453 |\n| 2018.09.30 | C    | 3.89175   |\n| 2018.09.30 | MSFT | 17.720025 |\n\n```\nwriteData(1000);\nselect [HINT_SNAPSHOT] * from loadTable(\"dfs://compoDB\",\"pt\");\n```\n\n| date       | sym  | val       |\n| ---------- | ---- | --------- |\n| 2018.09.29 | AAPL | 86.296883 |\n| 2018.09.29 | MS   | 48.17885  |\n| 2018.09.30 | C    | 83.7821   |\n| 2018.09.30 | MSFT | 44.415456 |\n\n上例如果在集群中执行，在不同节点查询的结果可能会不同。为避免这种情况，可以设置参数 *dedupColumnName*为 *\"date\"*，实现组内按照 date 列排序后保留最近一条。\n\n```\nunregisterSnapshotEngine(dbName=\"dfs://compoDB\", tableName=\"pt\")\nregisterSnapshotEngine(dbName=\"dfs://compoDB\", tableName=\"pt\",keyColumnName=\"sym\", dedupColumnName=\"date\");\nwriteData(1000);\n\n// 以下查询在不同节点执行将获得相同结果\nselect [HINT_SNAPSHOT] * from loadTable(\"dfs://compoDB\",\"pt\");\n```\n"
    },
    "regroup": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/regroup.html",
        "signatures": [
            {
                "full": "regroup(X, label, func, [byRow=true])",
                "name": "regroup",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "label",
                        "name": "label"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "[byRow=true]",
                        "name": "byRow",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [regroup](https://docs.dolphindb.cn/zh/funcs/r/regroup.html)\n\n\n\n#### 语法\n\nregroup(X, label, func, \\[byRow=true])\n\n#### 参数\n\n**X** 矩阵。\n\n**label** 向量，表示用于分组计算的标签。当 *byRow* = true 时，*label* 的长度必须与矩阵行数相等，否则与矩阵列数相等。\n\n**func** 单目聚合函数，可以是用户自定义聚合函数，也可以是内置函数。对具有相同标签的分组应用该函数进行聚合。\n\n**byRow** 布尔值，默认值 true，表示按行聚合。若为 false，则表示按列聚合。\n\n#### 详情\n\n按给定的行/列标签对矩阵进行分组聚合的操作。\n\n数据表的分组聚合可以通过 SQL 的 group by 语句实现。而通过 `regroup` 函数，可以实现矩阵的分组聚合操作。\n\n注意：建议参数 *func* 优先指定为系统内置的聚合函数，因为系统内部对内置函数进行了优化处理。（参考下例 2）\n\n#### 例子\n\n例1：按行/列标签分组聚合\n\n```\nm = rand(20, 4:5)\nm;\n```\n\n| col1 | col2 | col3 | col4 | col5 |\n| ---- | ---- | ---- | ---- | ---- |\n| 11   | 6    | 6    | 10   | 4    |\n| 6    | 7    | 5    | 2    | 16   |\n| 2    | 16   | 14   | 19   | 9    |\n| 17   | 6    | 13   | 10   | 2    |\n\n```\n# 按照列标签重组\nlabel = `A`A`B`A`B\nregroup(X=m, label=label, func=firstNot, byRow=false)\n```\n\n| A  | B  |\n| -- | -- |\n| 11 | 6  |\n| 6  | 5  |\n| 2  | 14 |\n| 17 | 13 |\n\n```\n# 按照行标签重组\nlabel = 1 2 1 2\nregroup(X=m, label=label, func=firstNot, byRow=true)\n```\n\n| label | col1 | col2 | col3 | col4 | col5 |\n| ----- | ---- | ---- | ---- | ---- | ---- |\n| 1     | 11   | 6    | 6    | 10   | 4    |\n| 2     | 6    | 7    | 5    | 2    | 16   |\n\n例2：内置函数和用户自定函数的性能对比\n\n```\nm = rand(1000.0, 10000)$100:100\ndefg my_avg(v):avg(v)\n\ntimer(1000) regroup(m, take(1 2 3 4 5, 100), avg)\n// output\nTime elapsed: 176.175 ms\n\ntimer(1000) regroup(m, take(1 2 3 4 5, 100), my_avg)\n// output\nTime elapsed: 1062.553 ms\n```\n\n例3：对面板数据进行分钟聚合\n\n```\nn=1000\ntimestamp = 09:00:00 + rand(10000, n).sort!()\nid = take(`st1`st2`st3, n)\nvol = 100 + rand(10.0, n)\nvt = table(timestamp, id, vol)\nm = exec vol from vt pivot by timestamp, id\nregroup(m, minute(m.rowNames()), avg)\n```\n"
    },
    "remoteRun": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/remoteRun.html",
        "signatures": [
            {
                "full": "remoteRun(conn, script, args)",
                "name": "remoteRun",
                "parameters": [
                    {
                        "full": "conn",
                        "name": "conn"
                    },
                    {
                        "full": "script",
                        "name": "script"
                    },
                    {
                        "full": "args",
                        "name": "args"
                    }
                ]
            }
        ],
        "markdown": "### [remoteRun](https://docs.dolphindb.cn/zh/funcs/r/remoteRun.html)\n\n\n\n#### 语法\n\nremoteRun(conn, script, args)\n\n#### 参数\n\n**conn** 是远程数据库的连接句柄。\n\n**script** 是要执行的脚本或函数名。\n\n**args** 可选的可变长度参数。如果 *script* 是函数名，*args* 是函数的参数。\n\n#### 详情\n\n将脚本或函数传输到远程数据库执行。\n\n#### 例子\n\n第一种用法：在远程节点上执行脚本。\n\n```\nconn =  xdb(\"localhost\",81);\nremoteRun(conn, \"x=rand(1.0,10000000); y=x pow 2; avg y\");\n```\n\n输出返回：0.333254\n\n第二种用法：\n\n* 如果 functionName 加了单引号，双引号或者反引号，那么表示在远程节点上调用函数。函数是定义在远程节点上，但是参数由本地节点传过去。\n\n  ```\n  h=xdb(\"localhost\",80);\n  x=remoteRun(h, \"sum\",1..100);\n  x;\n  ```\n\n  输出返回：5050\n\n* 如果 functionName 没有加单引号，双引号或者反引号，那么表示调用的函数定义在本地节点上。参数也是由本地节点传过去。\n\n  假设在本地节点，我们有一个表 EarningsDates，该表有两列：股票代码和日期。表中3个股票中的每一个，都有2006年第三季度公布盈利的日期。在远程节点有一个表 USPrices，节点的名字为 localhost，端口号为8081。它包含所有美国股票的每日股票价格。我们希望从远程节点获得在宣布收益后的一周内所有 EarningsDates 表中股票的价格。 在远程节点，我们导入数据文件创建表 USPrices，然后将其共享为名叫 sharedUSPrices 的表。\n\n  ```\n  USPrices = loadText(\"c:/DolphinDB/Data/USPrices.csv\");\n  share USPrices as USPrices;\n  ```\n\n  当我们创建到远程节点的连接时，远程节点将为此连接创建一个新的会话。此新会话与远程节点上的其他会话完全隔离。这对于开发来说很方便，因为开发人员不必担心名称冲突。 然而，有时候我们也希望在同一节点上的多个会话之间共享数据。这时我们可以使用函数 [share](https://docs.dolphindb.cn/zh/progr/statements/share.html) 来共享对象。目前只能在 DolphinDB 中共享表。 在本地节点上，我们创建 EarningsDates 表，然后用脚本将其传输到远程节点。在执行完毕后，结果被返回到本地节点。\n\n  ```\n  EarningsDates=table(`XOM`AAPL`IBM as TICKER, 2006.10.26 2006.10.19 2006.10.17 as date)\n  def loadDailyPrice(data){\n      dateDict = dict(data.TICKER, data.date)\n      return select date, TICKER, PRC from objByName(\"sharedUSPrices\") where dateDict[TICKER]<date<=dateDict[TICKER]+7\n  }\n  conn = xdb(\"localhost\",8081)\n  prices = conn.remoteRun(loadDailyPrice, EarningsDates);\n  prices;\n  ```\n\n  输出返回：\n\n  | date       | TICKER | PRC   |\n  | ---------- | ------ | ----- |\n  | 2006.10.27 | XOM    | 71.46 |\n  | 2006.10.30 | XOM    | 70.84 |\n  | 2006.10.31 | XOM    | 71.42 |\n  | 2006.11.01 | XOM    | 71.06 |\n  | 2006.11.02 | XOM    | 71.19 |\n  | 2006.10.18 | IBM    | 89.82 |\n  | 2006.10.19 | IBM    | 89.86 |\n  | 2006.10.20 | IBM    | 90.48 |\n  | 2006.10.23 | IBM    | 91.56 |\n  | 2006.10.24 | IBM    | 91.49 |\n  | 2006.10.20 | AAPL   | 79.95 |\n  | 2006.10.23 | AAPL   | 81.46 |\n  | 2006.10.24 | AAPL   | 81.05 |\n  | 2006.10.25 | AAPL   | 81.68 |\n  | 2006.10.26 | AAPL   | 82.19 |\n\n相关函数：[remoteRunCompatible](https://docs.dolphindb.cn/zh/funcs/r/remoteruncompatible.html)\n"
    },
    "remoteRunCompatible": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/remoteruncompatible.html",
        "signatures": [
            {
                "full": "remoteRunCompatible(conn, script, args)",
                "name": "remoteRunCompatible",
                "parameters": [
                    {
                        "full": "conn",
                        "name": "conn"
                    },
                    {
                        "full": "script",
                        "name": "script"
                    },
                    {
                        "full": "args",
                        "name": "args"
                    }
                ]
            }
        ],
        "markdown": "### [remoteRunCompatible](https://docs.dolphindb.cn/zh/funcs/r/remoteruncompatible.html)\n\n\n\n#### 语法\n\nremoteRunCompatible(conn, script, args)\n\n##### 参数\n\n**conn** 是远程数据库的连接句柄。\n\n**script** 是要执行的脚本或函数名。\n\n**args** 可选的可变长度参数。如果 *script* 是函数名，*args* 是函数的参数。\n\n#### 详情\n\n将脚本或函数传输到远程数据库执行。\n\nremoteRunCompatible 与 remoteRun 的区别在于：\n\n* remoteRunCompatible 对本地和远程数据库的版本没有限制。\n\n* remoteRun 在本地数据库为 3.00 版本时，不支持远程数据库的版本低于3.00。\n\n#### 例子\n\n第一种用法：*script* 是脚本，则表示在远程节点上执行脚本。\n\n```\nconn =\n              xdb(host=\"localhost\",port=8848,userId=\"admin\",password=123456);\n            remoteRunCompatible(conn, \"avg(1..100)\");\n```\n\n结果为 50.5。\n\n第二种用法：*script* 是函数名\n\n* 如果 script 加了单引号，双引号或者反引号，那么表示在远程节点上调用函数。函数是定义在远程节点上，但是参数由本地节点传过去。\n\n在远程节点增加函数视图 myAvg\n\n`def myAvg(x){ return avg(x)+2 } addFunctionView(myAvg)`\n\n连接远程节点调用视图\n\n```\nconn =  xdb(\"localhost\",8848,`admin,`123456);\n            remoteRunCompatible(conn, \"myAvg\", 1..100);\n```\n\n结果为 52.5。\n\n* 如果 script 不加单引号，双引号或者反引号，那么表示调用的函数定义在本地节点上。参数也是由本地节点传过去。\n\n在本地节点定义同名函数 myAvg\n\n`def myAvg(x){ return avg(x)+1 }`\n\n在远程节点执行此函数\n\n```\nconn =  xdb(\"localhost\",8848,`admin,`123456);\n            remoteRunCompatible(conn, myAvg, 1..100);\n```\n\n结果为 51.5。\n\n相关函数：[remoteRun](https://docs.dolphindb.cn/zh/funcs/r/remoteRun.html)\n"
    },
    "remoteRunWithCompression": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/remoteRunWithCompression.html",
        "signatures": [
            {
                "full": "remoteRunWithCompression(conn, script, args)",
                "name": "remoteRunWithCompression",
                "parameters": [
                    {
                        "full": "conn",
                        "name": "conn"
                    },
                    {
                        "full": "script",
                        "name": "script"
                    },
                    {
                        "full": "args",
                        "name": "args"
                    }
                ]
            }
        ],
        "markdown": "### [remoteRunWithCompression](https://docs.dolphindb.cn/zh/funcs/r/remoteRunWithCompression.html)\n\n\n\n#### 语法\n\nremoteRunWithCompression(conn, script, args)\n\n#### 详情\n\n和 [remoteRun](https://docs.dolphindb.cn/zh/funcs/r/remoteRun.html) 功能和用法基本一致，唯一不同的是 `remoteRunWithCompression` 在传输时对脚本中大于 1024 行的表数据进行了压缩。\n\n#### 参数\n\n**conn** 是远程数据库的连接句柄。\n\n**script** 是要执行的脚本或函数名。\n\n**args** 可选参数，如果 *script* 是函数名，*args* 是函数的参数。\n"
    },
    "removeHead!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/removeHead_.html",
        "signatures": [
            {
                "full": "removeHead!(obj, n)",
                "name": "removeHead!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [removeHead!](https://docs.dolphindb.cn/zh/funcs/r/removeHead_.html)\n\n\n\n#### 语法\n\nremoveHead!(obj, n)\n\n#### 参数\n\n**obj** 是一个向量。\n\n**n** 是一个正整数，表示要删除的位于向量头部的元素的个数。\n\n#### 详情\n\n删除向量 *obj* 的前 *n* 个元素。\n\n#### 例子\n\n```\nx=11..20;\nx.removeHead!(3);\n// output\n[14,15,16,17,18,19,20]\n```\n"
    },
    "removeNode": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/removenode.html",
        "signatures": [
            {
                "full": "removeNode(alias, [force=false])",
                "name": "removeNode",
                "parameters": [
                    {
                        "full": "alias",
                        "name": "alias"
                    },
                    {
                        "full": "[force=false]",
                        "name": "force",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [removeNode](https://docs.dolphindb.cn/zh/funcs/r/removenode.html)\n\n\n\n#### 语法\n\nremoveNode(alias, \\[force=false])\n\n#### 详情\n\n删除集群中名为 *alias* 的计算节点。仅限 admin 用户调用。\n\n此函数仅适用于 Linux 版本的 server。\n\n#### 参数\n\n**alias** STRING 类型的标量或向量，代表需要删除的计算节点的别名。\n\n**force** BOOL 类型的标量，表示是否强制删除节点：\n\n* 当值为 false（默认值）时 ，表示不强制删除，即仅当节点处于关闭状态时才会删除。\n\n* 当值为 true 时，表示强制删除，如果节点尚未关闭，则集群将会先关闭目标节点，然后再删除。此操作可能导致该节点正在进行的计算任务终止。\n\n#### 例子\n\n删除别名为 \"cnode1\" 的计算节点，删除前需要手动关闭该节点。\n\n```\nremoveNode(alias=\"cnode1\")\n```\n\n强制删除别名为 \"cnode2\", \"cnode3\" 的计算节点。\n\n```\nremoveNode(alias=`cnode2`cnode3, force=true)\n```\n"
    },
    "removeTail!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/removeTail_.html",
        "signatures": [
            {
                "full": "removeTail!(obj, n)",
                "name": "removeTail!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [removeTail!](https://docs.dolphindb.cn/zh/funcs/r/removeTail_.html)\n\n\n\n#### 语法\n\nremoveTail!(obj, n)\n\n#### 参数\n\n**obj** 是一个向量。\n\n**n** 是一个正整数，表示要删除的位于向量尾部的元素的个数。\n\n#### 详情\n\n删除向量 *obj* 的后 *n* 个元素。\n\n#### 例子\n\n```\nx=11..20;\nx.removeTail!(3);\n// output\n[11,12,13,14,15,16,17]\n```\n"
    },
    "removeTopicOffset": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/removeTopicOffset.html",
        "signatures": [
            {
                "full": "removeTopicOffset(topic)",
                "name": "removeTopicOffset",
                "parameters": [
                    {
                        "full": "topic",
                        "name": "topic"
                    }
                ]
            }
        ],
        "markdown": "### [removeTopicOffset](https://docs.dolphindb.cn/zh/funcs/r/removeTopicOffset.html)\n\n\n\n#### 语法\n\nremoveTopicOffset(topic)\n\n#### 参数\n\n**topic** 是 [subscribeTable](https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html) 函数返回的订阅主题。\n\n#### 详情\n\n删除给定订阅主题（topic）的持久化保存的最新一条已经处理订阅数据的偏移量（在 [subscribeTable](https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html) 函数中通过指定 *persistOffset* 参数为 true 获得）。\n"
    },
    "renameCatalog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/renameCatalog.html",
        "signatures": [
            {
                "full": "renameCatalog(oldCatalog, newCatalog)",
                "name": "renameCatalog",
                "parameters": [
                    {
                        "full": "oldCatalog",
                        "name": "oldCatalog"
                    },
                    {
                        "full": "newCatalog",
                        "name": "newCatalog"
                    }
                ]
            }
        ],
        "markdown": "### [renameCatalog](https://docs.dolphindb.cn/zh/funcs/r/renameCatalog.html)\n\n\n\n#### 语法\n\nrenameCatalog(oldCatalog, newCatalog)\n\n#### 参数\n\n**oldCatalog** 字符串标量，表示要修改的 catalog 的原名称。\n\n**newCatalog** 字符串标量，表示要修改的 catalog 的新名称。\n\n#### 详情\n\n重命名 catalog。\n\n#### 例子\n\n```\nrenameCatalog(\"catalog1\", \"catalog2\")\n```\n"
    },
    "renameSchema": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/renameSchema.html",
        "signatures": [
            {
                "full": "renameSchema(catalog, oldSchema, newSchema)",
                "name": "renameSchema",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    },
                    {
                        "full": "oldSchema",
                        "name": "oldSchema"
                    },
                    {
                        "full": "newSchema",
                        "name": "newSchema"
                    }
                ]
            }
        ],
        "markdown": "### [renameSchema](https://docs.dolphindb.cn/zh/funcs/r/renameSchema.html)\n\n\n\n#### 语法\n\nrenameSchema(catalog, oldSchema, newSchema)\n\n#### 参数\n\n**catalog** 字符串标量，表示 catalog 的名称。\n\n**oldSchema** 字符串标量，表示要修改的 schema 的原名称。\n\n**newSchema** 字符串标量，表示要修改的 schema 的新名称。\n\n#### 详情\n\n重命名 schema。\n\n#### 例子\n\n```\nrenameSchema(\"catalog1\", \"schema1\", \"schema2\")\n```\n"
    },
    "renameTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/renameTable.html",
        "signatures": [
            {
                "full": "renameTable(dbHandle, tableName, newTableName)",
                "name": "renameTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "newTableName",
                        "name": "newTableName"
                    }
                ]
            }
        ],
        "markdown": "### [renameTable](https://docs.dolphindb.cn/zh/funcs/r/renameTable.html)\n\n\n\n#### 语法\n\nrenameTable(dbHandle, tableName, newTableName)\n\n#### 参数\n\n**dbHandle** 是一个DFS数据库句柄。\n\n**tableName** 是一个字符串，表示要改名的数据表名称。该表既可为分布式表，亦可为维度表。\n\n**newTableName** 是一个字符串，表示要改名后的数据表名称。\n\n#### 详情\n\n将给定分布式数据库内数据表改名。\n\n#### 例子\n\n```\nn=1000000\nID=rand(10, n)\nx=rand(1.0, n)\nt=table(ID, x)\ndb=database(\"dfs://hashdb101\", HASH,  [INT, 2]);\npt = db.createPartitionedTable(t, `pt, `ID)\npt.append!(t)\nrenameTable(db, `pt, `pt1)\nselect count(x) from loadTable(db, `pt1);\n```\n\n输出返回： 1000000\n"
    },
    "rename!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rename_.html",
        "signatures": [
            {
                "full": "rename!(X, Y, [Z])",
                "name": "rename!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "[Z]",
                        "name": "Z",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rename!](https://docs.dolphindb.cn/zh/funcs/r/rename_.html)\n\n\n\n#### 语法\n\nrename!(X, Y, \\[Z])\n\n#### 参数\n\n**X** 可以是向量、矩阵、索引矩阵、非共享内存表或分布式表（仅支持 OLAP 引擎）。\n\n* 当 *X* 是向量时，*Y* 是表示标签的字符串。\n\n* 当 *X* 是矩阵、索引矩阵时，如果 *Z* 没有指定，则 *Y* 是列标签；如果 *Z* 指定了，*Y* 是行标签，而 *Z* 是列标签。列标签和行标签的长度分别需要等于 *X* 的列数和行数。*Y* 和 *Z* 可以是任意数据类型。\n\n* 当 *X* 是非共享内存表时，*Y* 和 *Z* 是字符串标量或向量。如果 *Z* 没有指定，则 *Y* 从左到右是新的列名，用户应该确保新的列名的数量小于或等于表中列的总数；如果 *Z* 指定了，则 *Y* 是旧的列名，*Z* 是对应的新的列名。\n\n* 当 *X* 是分布式表时，必须指定 *Y* 和 *Z* 且只能是字符串标量。其中 *Y* 表示指定的旧列名，*Z* 是对应的新列名。分布式表不支持批量修改列名。\n\n#### 详情\n\n* 对于向量，赋予其一个新标签。\n\n* 对于矩阵、索引矩阵，给列（和行）添加标签。\n\n* 对于表，替换表的列名。\n\n#### 例子\n\n```\nk = 3 6 9;\nk.rename!(`rk);\n// output\n[3, 6, 9]\n\n// 用函数 stat 获取统计信息是一种查看名字的方法\nstat k;\n// output\nMedian->6\nAvg->6\nMin->3\nStdev->3\nCount->3\nSize->3\nName->rk        // k 的新标签\nMax->9\n```\n\n```\nm1 = 1..9$3:3;\nm1\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 4  | 7  |\n| 2  | 5  | 8  |\n| 3  | 6  | 9  |\n\n```\nm1.rename!(`col1`col2`col3);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 7    |\n| 2    | 5    | 8    |\n| 3    | 6    | 9    |\n\n```\nm1.rename!(1 2 3, `c1`c2`c3);\n```\n\n|   | c1 | c2 | c3 |\n| - | -- | -- | -- |\n| 1 | 1  | 4  | 7  |\n| 2 | 2  | 5  | 8  |\n| 3 | 3  | 6  | 9  |\n\n```\nm1 join k;\n// 注意新的矩阵使用 k 的标签作为它的列标签。\n```\n\n|   | c1 | c2 | c3 | rk |\n| - | -- | -- | -- | -- |\n| 1 | 1  | 4  | 7  | 3  |\n| 2 | 2  | 5  | 8  | 6  |\n| 3 | 3  | 6  | 9  | 9  |\n\n```\nt1=table(1..3 as x, 4..6 as y, 7..9 as z);\nt1\n```\n\n| x | y | z |\n| - | - | - |\n| 1 | 4 | 7 |\n| 2 | 5 | 8 |\n| 3 | 6 | 9 |\n\n```\nt1.rename!(`a`b);\n```\n\n| a | b | z |\n| - | - | - |\n| 1 | 4 | 7 |\n| 2 | 5 | 8 |\n| 3 | 6 | 9 |\n\n```\nt1.rename!(`aa`bb`cc);\n```\n\n| aa | bb | cc |\n| -- | -- | -- |\n| 1  | 4  | 7  |\n| 2  | 5  | 8  |\n| 3  | 6  | 9  |\n\n```\nt1.rename!(`bb`cc, `y`z);\n```\n\n| aa | y | z |\n| -- | - | - |\n| 1  | 4 | 7 |\n| 2  | 5 | 8 |\n| 3  | 6 | 9 |\n\n```\nt1=table(1..3 as x, 4..6 as y, 7..9 as z, k);\nt1\n// 注意表使用了 k 的标签作为它的列名\n```\n\n| x | y | z | rk |\n| - | - | - | -- |\n| 1 | 4 | 7 | 3  |\n| 2 | 5 | 8 | 6  |\n| 3 | 6 | 9 | 9  |\n\n创建一个索引矩阵。\n\n```\nm = matrix(1..5, 11..15)\nm.rename!(2020.01.01..2020.01.05, `A`B)\nm1 = m.setIndexedMatrix!();\n```\n\n|            | A | B  |\n| ---------- | - | -- |\n| 2020.01.01 | 1 | 11 |\n| 2020.01.02 | 2 | 12 |\n| 2020.01.03 | 3 | 13 |\n| 2020.01.04 | 4 | 14 |\n| 2020.01.05 | 5 | 15 |\n\n修改其行、列标签。\n\n```\nm1.rename!( \"a\" + string(1..5), `A1`A2)\n```\n\n若向量不遵循严格递增或包含重复值，则会报错。\n\n```\nm1.rename!( \"a\" + string(4 6 2 1 3), `A1`A2)\nm1.rename!( \"a\"\"a\"\"a\"\"a\"\"a\", `A1`A2)\n//Error: The label of an indexed matrix or series must be in strict ascending order.\n```\n"
    },
    "reorderColumns!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/reorderColumns_.html",
        "signatures": [
            {
                "full": "reorderColumns!(table, reorderedColNames)",
                "name": "reorderColumns!",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "reorderedColNames",
                        "name": "reorderedColNames"
                    }
                ]
            }
        ],
        "markdown": "### [reorderColumns!](https://docs.dolphindb.cn/zh/funcs/r/reorderColumns_.html)\n\n\n\n#### 语法\n\nreorderColumns!(table, reorderedColNames)\n\n#### 参数\n\n**table** 是一个没有被共享的内存表。\n\n**reorderedColNames** 是一个字符串向量，表示调整顺序后的列名。此参数中只需写出表中发生顺序改变的列以及所有在其之前的列名。例如，将表中第3列于第6列的位置对换，则此参数只需写出前6列的列名。\n\n#### 详情\n\n调整表中各列的顺序。该命令直接在原有的表中修改，不会产生新的表。\n\n#### 例子\n\n```\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nt = table(timestamp, sym, qty, price);\nt;\n```\n\n| timestamp | sym | qty  | price  |\n| --------- | --- | ---- | ------ |\n| 09:34:07  | C   | 2200 | 49.6   |\n| 09:36:42  | MS  | 1900 | 29.46  |\n| 09:36:51  | MS  | 2100 | 29.52  |\n| 09:36:59  | MS  | 3200 | 30.02  |\n| 09:32:47  | IBM | 6800 | 174.97 |\n| 09:35:26  | IBM | 5400 | 175.23 |\n| 09:34:16  | C   | 1300 | 50.76  |\n| 09:34:26  | C   | 2500 | 50.32  |\n| 09:38:12  | C   | 8800 | 51.29  |\n\n```\nreorderColumns!(t,`sym`timestamp`price`qty)\nt;\n```\n\n| sym | timestamp | price  | qty  |\n| --- | --------- | ------ | ---- |\n| C   | 09:34:07  | 49.6   | 2200 |\n| MS  | 09:36:42  | 29.46  | 1900 |\n| MS  | 09:36:51  | 29.52  | 2100 |\n| MS  | 09:36:59  | 30.02  | 3200 |\n| IBM | 09:32:47  | 174.97 | 6800 |\n| IBM | 09:35:26  | 175.23 | 5400 |\n| C   | 09:34:16  | 50.76  | 1300 |\n| C   | 09:34:26  | 50.32  | 2500 |\n| C   | 09:38:12  | 51.29  | 8800 |\n\n```\nreorderColumns!(t,`timestamp`sym);\nt;\n```\n\n| timestamp | sym | price  | qty  |\n| --------- | --- | ------ | ---- |\n| 09:34:07  | C   | 49.6   | 2200 |\n| 09:36:42  | MS  | 29.46  | 1900 |\n| 09:36:51  | MS  | 29.52  | 2100 |\n| 09:36:59  | MS  | 30.02  | 3200 |\n| 09:32:47  | IBM | 174.97 | 6800 |\n| 09:35:26  | IBM | 175.23 | 5400 |\n| 09:34:16  | C   | 50.76  | 1300 |\n| 09:34:26  | C   | 50.32  | 2500 |\n| 09:38:12  | C   | 51.29  | 8800 |\n"
    },
    "repartitionDS": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/repartitionDS.html",
        "signatures": [
            {
                "full": "repartitionDS(query, [column], [partitionType], [partitionScheme], [local=true])",
                "name": "repartitionDS",
                "parameters": [
                    {
                        "full": "query",
                        "name": "query"
                    },
                    {
                        "full": "[column]",
                        "name": "column",
                        "optional": true
                    },
                    {
                        "full": "[partitionType]",
                        "name": "partitionType",
                        "optional": true
                    },
                    {
                        "full": "[partitionScheme]",
                        "name": "partitionScheme",
                        "optional": true
                    },
                    {
                        "full": "[local=true]",
                        "name": "local",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [repartitionDS](https://docs.dolphindb.cn/zh/funcs/r/repartitionDS.html)\n\n\n\n#### 语法\n\nrepartitionDS(query, \\[column], \\[partitionType], \\[partitionScheme], \\[local=true])\n\n#### 参数\n\n**query** 是一个 SQL 查询的元代码，或一个元组，其中每个元素都是 SQL 查询的元代码。\n\n**column** 是一个字符串，表示 *query* 中的一个列名。`repartitionDS` 函数会根据该列划分数据源。\n\n**partitionType** 表示分区类型，它的取值可以是 RANGE, VALUE 或 HASH。\n\n**partitionScheme** 是一个向量，表示分区方案。\n\n**local** 可选参数，布尔值，表示是否将数据源获取到当前节点进行计算。默认值为 true。\n\n#### 详情\n\n使用新的分区类型和分区方案重新划分数据源。该函数会返回一个元组，包含一组数据源。\n\n* 如果 *query* 是一个 SQL 查询的元代码，必须指定 *column* 参数。对于 COMPO 分区类型的表，可以不指定 *partitionType* 和 *partitionScheme* 参数，`repartitionDS` 函数会根据 *column* 列原始的分区类型和分区方案划分数据源。\n\n* 如果 *query* 是包含多个 SQL 查询元代码的元组，无需指定 *column*、*partitionType* 和 *partitionScheme* 参数，`repartitionDS` 函数会返回一个和 *query* 长度相同的元组，每个元素都是 *query* 中的元代码对应的数据源。\n\n* 当 *local* 设置为 true 时：将数据源获取到执行该函数的节点上。\n\n* 当 *local* 设置为 false 时：如果在指定了计算组的计算节点上执行该函数时，仅将数据源获取到同组内的所有计算节点上；否则将数据源获取到集群中所有数据节点、未指定计算组的计算节点上。\n\n#### 例子\n\n创建分布式数据库和表：\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\n\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID = database(, RANGE, 0 50 100)\ndb = database(\"dfs://compoDB\", COMPO, [dbDate, dbID])\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n```\n\n例1：*query*是一个 SQL 查询的元代码，指定了 *partitionType* 和 *partitionScheme*。\n\n```\nrepartitionDS(<select * from pt>,`date,RANGE,2017.08.07 2017.08.09 2017.08.11);\n\n// output\n[DataSource< select [4] * from pt where date >= 2017.08.07,date < 2017.08.09 >,DataSource< select [4] * from pt where date >= 2017.08.09,date < 2017.08.11 >]\n```\n\n例2：*query*是一个 SQL 查询的元代码，没有指定 *partitionType*和 *partitionScheme*。\n\n```\nrepartitionDS(<select * from pt>,`ID)\n\n// output\n[DataSource< select [4] * from pt [partition = */0_50] >,DataSource< select [4] * from pt [partition = */50_100] >]\n```\n\n例3：*query* 是包含多个 SQL 查询元代码的元组。\n\n```\nrepartitionDS([<select * from pt where id between 0:50>,<select * from pt where id between 51:100>]);\n\n// output\n[DataSource< select [4] * from pt where id between 0 : 50 >,DataSource< select [4] * from pt where id between 51 : 100 >]\n```\n"
    },
    "repeat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/repeat.html",
        "signatures": [
            {
                "full": "repeat(X, n)",
                "name": "repeat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [repeat](https://docs.dolphindb.cn/zh/funcs/r/repeat.html)\n\n\n\n#### 语法\n\nrepeat(X, n)\n\n#### 参数\n\n**X** 是一个字符串或字符串向量。\n\n**n** 是一个非负整数，表示重复的次数。\n\n#### 详情\n\n返回 *X* 重复 *n* 次后的字符串。\n\n#### 例子\n\n```\nrepeat(`FB, 3);\n// output\nFBFBFB\nrepeat(`AB`CD,2);\n// output\n[\"ABAB\",\"CDCD\"]\n```\n"
    },
    "replace": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/replace.html",
        "signatures": [
            {
                "full": "replace(X, oldValue, newValue)",
                "name": "replace",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "oldValue",
                        "name": "oldValue"
                    },
                    {
                        "full": "newValue",
                        "name": "newValue"
                    }
                ]
            }
        ],
        "markdown": "### [replace](https://docs.dolphindb.cn/zh/funcs/r/replace.html)\n\n\n\n#### 语法\n\nreplace(X, oldValue, newValue)\n\n#### 参数\n\n**X** 可以是向量、矩阵。\n\n**oldValue** 是将被替换的值。\n\n**noewValue** 是新的值。\n\n#### 详情\n\n返回将 *oldValue* 替换成 *newValue* 后的向量或矩阵。`replace!` 是 `replace` 的原地改变版本。\n\n#### 例子\n\n```\nx=1 1 3;\nx=x.replace(1,2);\nx\n// output\n[2,2,3];\n\nm=1..4$2:2;\nm\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\nm=m.replace(2,1);\nm\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 1  | 4  |\n\n```\nm.replace!(1,6);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 6  | 4  |\n"
    },
    "replaceColumn!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/replaceColumn_.html",
        "signatures": [
            {
                "full": "replaceColumn!(table, colName, newCol)",
                "name": "replaceColumn!",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "colName",
                        "name": "colName"
                    },
                    {
                        "full": "newCol",
                        "name": "newCol"
                    }
                ]
            }
        ],
        "markdown": "### [replaceColumn!](https://docs.dolphindb.cn/zh/funcs/r/replaceColumn_.html)\n\n\n\n#### 语法\n\nreplaceColumn!(table, colName, newCol)\n\n#### 参数\n\n**table** 非共享内存表或分布式表（仅支持 OLAP 引擎）。\n\n**colName** 字符串，表示要替换列的列名。当 *table* 是内存表时，*colName* 也可以是字符串向量，表示多列的列名。\n\n**newCol** 表示用于替换的列值。当 *colName*为标量时，*newCol*是一个长度与 *table* 行数相同的向量；当 *colName* 为向量时，*newCol* 是一个元组，其元素个数与 *colName* 一致，且每一个元素是一个长度与 *table* 行数相同的向量。\n\n#### 详情\n\n使用向量替换 *table* 中指定列。替换后，指定列的数据类型与向量的数据类型一致。当 *table* 是内存表时，支持替换多列（请注意该操作目前不保证原子性，即在遇到一些系统错误时可能出现部分列替换失败的情况）。\n\n`replaceColumn!` 与 SQL 中的 [update](https://docs.dolphindb.cn/zh/progr/sql/update.html) 语句的区别在于，前者可以修改列的值或数据类型，而后者只能修改列的值。\n\n#### 例子\n\n```\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nt = table(timestamp, sym, qty, price)\nschema(t).colDefs;\n```\n\n输出返回：\n\n| name      | typeString | typeInt | extra | comment |\n| --------- | ---------- | ------- | ----- | ------- |\n| timestamp | SECOND     | 10      |       |         |\n| sym       | STRING     | 18      |       |         |\n| qty       | INT        | 4       |       |         |\n| price     | DOUBLE     | 16      |       |         |\n\n把 sym 列的数据类型修改为 SYMBOL 类型：\n\n```\nsyms=symbol(exec sym from t)\nreplaceColumn!(t,`sym,syms);\nschema(t).colDefs;\n```\n\n输出返回：\n\n| name      | typeString | typeInt | extra | comment |\n| --------- | ---------- | ------- | ----- | ------- |\n| timestamp | SECOND     | 10      |       |         |\n| sym       | SYMBOL     | 17      |       |         |\n| qty       | INT        | 4       |       |         |\n| price     | DOUBLE     | 16      |       |         |\n\n对 price 列和 timestamp 列进行替换：\n\n```\nnewPrice =round(t.qty)\nnewTimestamp = minute(t.timestamp)\nreplaceColumn!(t, `price`timestamp, (newPrice,newTimestamp))\nschema(t).colDefs;\n```\n\n输出返回：\n\n| name      | typeString | typeInt | extra | comment |\n| --------- | ---------- | ------- | ----- | ------- |\n| timestamp | MINUTE     | 9       |       |         |\n| sym       | SYMBOL     | 17      |       |         |\n| qty       | INT        | 4       |       |         |\n| price     | INT        | 4       |       |         |\n\n```\nlogin(\"admin\",\"123456\")\nif(existsDatabase(\"dfs://replaceColumn\")){\n  dropDatabase(\"dfs://replaceColumn\")\n}\nn=10\nmonth=take(2012.06.13..2012.06.13, n);\nx=rand(1.0, n);\nt=table(month, x);\ndb=database(\"dfs://replaceColumn\", VALUE, 2012.06.13..2012.06.23)\npt = db.createPartitionedTable(t, `pt, `month);\npt.append!(t);\nschema(pt).colDefs\n```\n\n输出返回：\n\n| name  | typeString | typeInt | extra | comment |\n| ----- | ---------- | ------- | ----- | ------- |\n| month | DATE       | 6       |       |         |\n| x     | DOUBLE     | 16      |       |         |\n\n```\nnewCols=int(exec x from loadTable(\"dfs://replaceColumn\",`pt))\nreplaceColumn!(loadTable(\"dfs://replaceColumn\",`pt), `x, newCols)\nschema(pt).colDefs\n```\n\n输出返回：\n\n| name  | typeString | typeInt | extra | comment |\n| ----- | ---------- | ------- | ----- | ------- |\n| month | DATE       | 6       |       |         |\n| x     | INT        | 4       |       |         |\n"
    },
    "replace!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/replace_.html",
        "signatures": [
            {
                "full": "replace(X, oldValue, newValue)",
                "name": "replace",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "oldValue",
                        "name": "oldValue"
                    },
                    {
                        "full": "newValue",
                        "name": "newValue"
                    }
                ]
            }
        ],
        "markdown": "### [replace!](https://docs.dolphindb.cn/zh/funcs/r/replace_.html)\n\n是 [replace](https://docs.dolphindb.cn/zh/funcs/r/replace.html) 的别名。\n\n\n以下是 `replace` 函数的文档：\n### [replace](https://docs.dolphindb.cn/zh/funcs/r/replace.html)\n\n\n\n#### 语法\n\nreplace(X, oldValue, newValue)\n\n#### 参数\n\n**X** 可以是向量、矩阵。\n\n**oldValue** 是将被替换的值。\n\n**noewValue** 是新的值。\n\n#### 详情\n\n返回将 *oldValue* 替换成 *newValue* 后的向量或矩阵。`replace!` 是 `replace` 的原地改变版本。\n\n#### 例子\n\n```\nx=1 1 3;\nx=x.replace(1,2);\nx\n// output\n[2,2,3];\n\nm=1..4$2:2;\nm\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\nm=m.replace(2,1);\nm\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 1  | 4  |\n\n```\nm.replace!(1,6);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 6  | 3  |\n| 6  | 4  |\n"
    },
    "replay": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/replay.html",
        "signatures": [
            {
                "full": "replay(inputTables, outputTables, [dateColumn], [timeColumn], [replayRate], [absoluteRate=true], [parallelLevel=1], [sortColumns], [preciseRate=false])",
                "name": "replay",
                "parameters": [
                    {
                        "full": "inputTables",
                        "name": "inputTables"
                    },
                    {
                        "full": "outputTables",
                        "name": "outputTables"
                    },
                    {
                        "full": "[dateColumn]",
                        "name": "dateColumn",
                        "optional": true
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[replayRate]",
                        "name": "replayRate",
                        "optional": true
                    },
                    {
                        "full": "[absoluteRate=true]",
                        "name": "absoluteRate",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[parallelLevel=1]",
                        "name": "parallelLevel",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[sortColumns]",
                        "name": "sortColumns",
                        "optional": true
                    },
                    {
                        "full": "[preciseRate=false]",
                        "name": "preciseRate",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [replay](https://docs.dolphindb.cn/zh/funcs/r/replay.html)\n\n\n\n#### 语法\n\nreplay(inputTables, outputTables, \\[dateColumn], \\[timeColumn], \\[replayRate], \\[absoluteRate=true], \\[parallelLevel=1], \\[sortColumns], \\[preciseRate=false])\n\n#### 详情\n\n根据指定的回放模式，按时间顺序将一个或多个数据表或数据源列表（由 [replayDS](https://docs.dolphindb.cn/zh/funcs/r/replayDS.html) 函数的返回值）的数据回放到数据表，以模拟实时数据写入，通常用于高频策略回测场景。\n\n##### 回放形式\n\n根据输入表到输出表的映射（mapping），`replay` 支持 1 对 1，N 对 N，N 对 1 三种回放形式。\n\n相比于N对N回放，N个1对1的各个回放相互独立。当 *inputTables* 指定为数据源列表时，N对N 回放形式可以确保所有回放的第一个数据源回放完，再开始回放第二个数据源。\n\n相比于N对N回放无法保证所有表的数据在全局上的时间顺序，N对1回放形式可以确保不同表的数据写入目标表的顺序与时间字段的先后顺序严格一致。\n\n##### 回放模式\n\n根据回放速度的不同设定，`replay` 提供以下四种回放模式：\n\n* 指定每秒回放记录数：如果 *replayRate* 为正整数，且 *absoluteRate* 为 true，则回放的速率基于记录数计算，系统按照每秒 *replayRate* 条记录进行回放。\n\n* 指定时间跨度回放加速倍数：如果 *replayRate* 为正整数，并且 *absoluteRate* 为 false，则根据输入表数据的时间跨度加速 *replayRate* 倍回放。注意，每秒回放的记录数是相同的。\n\n* 全速回放：如果 *replayRate* 未指定或者为负，无论 *absoluteRate* 为 false 还是 true，系统都将以最快的速率进行回放。\n\n* 精确速度回放：如果 *replayRate* 为正整数，且 *preciseRate*为 true，则数据完全按照事件时间进行倍速回放。系统根据两条相邻数据的时间间隔加速 *replayRate* 倍依次回放每条数据。例如，*replayRate*为 2 时，原本时间戳相差 t 毫秒 的相邻两条数据，会尽量以 t/2 毫秒的时间间隔依次回放。\n\n##### 回放过程\n\n1. 数据加载（仅当输入表是数据源列表时）。\n\n   从磁盘加载数据源到内存时，用户可以指定 *parallelLevel* 参数并行加载数据，以提升性能。数据加载和数据回放异步进行。\n\n2. 分批回放。\n\n   每批回放的记录数和回放耗时受回放模式和系统性能影响。\n\n   | 回放模式                           | 每批数据包含的记录数                                                                                                                              | 取数据的方式                                                | 回放耗时              |\n   | ------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------- | ----------------- |\n   | 按指定记录数回放（数据总数为 s）              | *replayRate* 条数据请注意：此模式下每秒回放一批数据。若输入表是数据源列表（即从磁盘加载）时，回放速度亦受磁盘IO性能制约。若一秒内加载的数据量小于 *replayRate*，则将已加载的数据作为一个批次进行回放。                       | 1 对 1：从单表取一批数据。N 对 1 / N 对 N：根据数据的时间戳顺序，从 N 张表中取一批数据。 | 约为 s/replayRate 秒 |\n   | 按时间跨度加速回放(数据时间跨度为 n 秒，数据总数为 s) | replayRate\\*s/n 条数据（若不足 1 条，则取 1 条）请注意：此模式下每秒回放一批数据。若输入表是数据源列表（即从磁盘加载）时，回放速度亦受磁盘IO性能制约。若一秒内加载的数据量小于 replayRate\\*s/n，则将已加载的数据作为一个批次进行回放。 | 1 对 1：从单表取一批数据。N 对 1 / N 对 N：根据数据的时间戳顺序，从 N 张表中取一批数据。 | 约为 n/replayRate 秒 |\n   | 全速回放                           | 每次回放时系统已加载的所有数据                                                                                                                         | 1 对 1：同上。N 对 1：同上。N 对 N：逐一回放各输入表，每次从单表取一批数据。          | 取决于系统性能           |\n\n   **Note:** 上表的回放耗时计算方法适用于评估同构回放的耗时，异构回放的耗时会略高于同构回放。\n\n   回放过程中，系统会先从内存按批取出数据并回放。`replay` 只保证同一批次数据的回放结果是有序的。因此，在调用 `replay` 函数前，请将输入表按照指定的时间列（由参数 *dateColumn* 和 *timeColumn* 决定）排序。\n\n3. 数据写入。\n\n   **Note:** 目前系统仅支持单线程写入输出表。\n\n4. 终止回放：可使用 [cancelJob](https://docs.dolphindb.cn/zh/funcs/c/cancelJob.html) 和 [cancelConsoleJob](https://docs.dolphindb.cn/zh/funcs/c/cancelConsoleJob.html) 命令。\n\n   **Note:**\n\n   * 2.00.5 版本前，N 对 1 回放要求输入表结构必须相同，称为同构回放。自 2.00.5 版本起，N 对 1 回放开始支持输入结构不同的表，称为异构回放。由于异构回放到输出表的记录均被序列化存储，无法直接读取，需要通过 [streamFilter](https://docs.dolphindb.cn/zh/funcs/s/streamFilter.html) 进行数据过滤和分发，详情请参考 [streamFilter](https://docs.dolphindb.cn/zh/funcs/s/streamFilter.html)。\n\n   * 2.00.9 版本后，若 N 对 1 回放的输入表为多个数据源列表，会自动按照时间戳排序后回放。在该版本前，系统每次仅加载多个列表相同索引位置的数据源排序后回放，不保证全局的有序性。\n\n#### 参数\n\n根据回放形式的不同， **inputTables** 的数据形式也有所不同：\n\n* 1 对 1 回放时，*inputTables* 是一个未分区的表或数据源列表。\n\n* N 对 1 同构回放或 N 对 N 回放时，*inputTables* 是多个未分区的表或数据源列表构成的元组。\n\n* N 对 1 异构回放时，*inputTables* 是一个字典。字典的 key 可以是任意数据类型，表示输入表或数据源列表的唯一标识，value 是一个表对象或数据源列表。\n\n根据回放形式的不同， **outputTables** 的数据形式也有所不同：\n\n* 1 对 1 回放或 N 对 1 同构回放时，*outputTables*\\_是一个表对象（未分区的内存表/流数据表）或表示共享表名的字符串，必须与输入表的 schema 相同。\n\n* N 对 N 回放，*outputTables* 是多个表对象（未分区的内存表/流数据表）或表示共享表名的字符串构成的元组，且它的长度必须与 *inputTables* 相同。输出表和输入表一一对应，且 schema 必须相同。\n\n* N 对 1 异构回放时 *outputTables* 是 一个表对象（未分区的内存表/流数据表），至少包含三列：\n\n其中：\n\n* 第一列为 *dateColumn* 和 *timeColumn* 指定的回放时间的时间戳；\n\n* 第二列为 SYMBOL 或 STRING 类型，对应 *inputTables* 字典的 key；\n\n* 第三列为 BLOB 类型，用于存储被回放的每条记录序列化后的结果。\n\n此外，可输出各输入表的公共列（列名和类型一致的列）。\n\n**dateColumn** 和 **timeColumn** 为时间列的列名，至少指定其中一个参数。根据回放形式的不同，*dateColumn* 和 *timeColumn* 的取值有所区别：\n\n* 1 对 1 回放或 N 对 1 同构回放: 输入表与输出表的时间列列名必须相同，指定为字符串标量；\n\n* N 对 N 回放：输入表时间列的列名相同，指定为字符串标量；输入表时间列的列名不同，指定为字符串向量；\n\n* N 对 1 异构回放：输入表时间列的列名相同，指定为字符串标量；输入表时间列的列名不同，指定为字典，其中 key 为输入表的唯一标识符，value 是对应表时间列的列名。\n\n只指定 *dateColumn* 或 *timeColumn* 中的一个参数，或者 *dateColumn* 和 *timeColumn* 指定为同一列时，对指定的时间列的类型没有限制。\n\n若指定 *dateColumn* 和 *timeColumn* 为不同列，*dateColumn* 必须是 DATE 类型，*timeColumn* 只能是 SECOND, TIME 或 NANOTIME 类型。\n\n**replayRate** 整数，和参数 *absoluteRate* 共同决定了回放的速率。\n\n**absoluteRate** 布尔值。默认值为 true，表示系统每秒按 *replayRate* 指定的记录数回放。若为 false，表示依照数据的时间跨度加速 *replayRate* 倍回放。\n\n**parallelLevel** 正整数，表示从数据源加载数据到内存的工作线程数量，默认值为 1。如果 *inputTables* 不是数据源，无需指定该参数。\n\n**sortColumns** 字符串标量或者长度为2的向量。相同回放时间戳的数据将根据该参数指定的字段进行排序。仅异构回放支持该参数。\n\n**Note:** 该参数可以指定 *inputTables* 的非公共列。若某个输入表不存在指定的非公共列，则填充空值且将其前置。\n\n**preciseRate** 布尔值。默认值为 false，表示不开启精确速度回放。若指定为 true，则系统根据相邻记录的时间戳，以 *replayRate* 指定的倍数精确回放。\n\n#### 例子\n\n##### 一对一回放\n\n以下为按不同回放模式进行一对一回放的例子\n\n```\nn=1000\nsym = take(`IBM,n)\ntimestamp= take(temporalAdd(2012.12.06T09:30:12.000,1..500,'s'),n)\nvolume = rand(100,n)\ntrades=table(sym,timestamp,volume)\ntrades.sortBy!(`timestamp)\nshare streamTable(100:0,`sym`timestamp`volume,[SYMBOL,TIMESTAMP,INT]) as st\n```\n\n* 每秒回放100条数据：\n\n  ```\n  timer replay(inputTables=trades, outputTables=st, dateColumn=`timestamp, \n      timeColumn=`timestamp,replayRate=100, absoluteRate=true);\n   Time elapsed: 10001.195 ms\n  ```\n\n  表 trades 中一共有1000条数据，每秒回放100条耗时大约10秒。\n\n* 加速100倍时间回放：\n\n  ```\n  timer replay(inputTables=trades,outputTables=st,dateColumn=`timestamp,\n      timeColumn=`timestamp,replayRate=100,absoluteRate=false);\n    Time elapsed: 5001.909 ms\n  ```\n\n  表 trades 中的最大时间与最小时间相差500秒，加速 100 倍时间回放耗时大约5秒。\n\n* 以最快的速率回放：\n\n  ```\n  timer replay(inputTables=trades,outputTables=st,dateColumn=`timestamp,\n      timeColumn=`timestamp);\n    Time elapsed: 0.974 ms\n  ```\n\n* 精确速度回放：\n\n  ```\n  timer replay(inputTables=trades,outputTables=st,dateColumn=`timestamp,\n      timeColumn=`timestamp,replayRate=100,absoluteRate=false, preciseRate=true);\n    Time elapsed: 4991.177 ms\n  ```\n\n  表 trades 中，以相邻两条记录时间戳的 100 倍速度回放，回放时间大约 4.99 秒。\n\n##### N 对 N 回放\n\n以下为将多个数据源列表回放到多个输出表中的例子。\n\n以下脚本将两个数据源回放到连接引擎，进行 asof join 计算。\n\n```\nn=50000\nsym = rand(symbol(`IBM`APPL`MSFT`GOOG`GS),n)\ndate=take(2012.06.12..2012.06.16,n)\ntime=rand(13:00:00.000..16:59:59.999,n)\nvolume = rand(100,n)\nt1=table(sym,date,time,volume).sortBy!([`date, `time])\n\nsym = rand(symbol(`IBM`APPL`MSFT`GOOG`GS),n)\ndate=take(2012.06.12..2012.06.16,n)\ntime=rand(13:00:00.000..16:59:59.999,n)\nprice = 100 + rand(10.0,n)\nt2=table(sym,date,time,price).sortBy!([`date, `time])\n\nif(existsDatabase(\"dfs://test_stock\")){\ndropDatabase(\"dfs://test_stock\")\n}\ndb=database(\"dfs://test_stock\",VALUE,2012.06.12..2012.06.16)\npt1=db.createPartitionedTable(t1,`pt1,`date).append!(t1)\npt2=db.createPartitionedTable(t2,`pt2,`date).append!(t2)\n\nleft = table(100:0,`sym`dt`volume,[SYMBOL,TIMESTAMP,INT]) \nright = table(100:0,`sym`dt`price,[SYMBOL,TIMESTAMP,DOUBLE]) \n\nopt=table(100:0, `dt`sym`volume`price`total, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE])\najEngine=createAsofJoinEngine(name=\"ajEngine\", leftTable=left, rightTable=right, \n    outputTable=opt, metrics=<[volume, price, volume*price]>, \n    matchingColumn=`sym, timeColumn=`dt, useSystemTime=false, delayedTime=1)\n\nds1=replayDS(sqlObj=<select sym, concatDateTime(date, time) as dt, volume from pt1>,\n    dateColumn=`date, timeColumn=`time,\n    timeRepartitionSchema=[13:00:00.000, 14:00:00.000, 15:00:00.000, 16:00:00.000, 17:00:00.000])\nds2=replayDS(sqlObj=<select sym, concatDateTime(date, time) as dt, price from pt2>,\n    dateColumn=`date, timeColumn=`time,\n    timeRepartitionSchema=[13:00:00.000, 14:00:00.000, 15:00:00.000, 16:00:00.000, 17:00:00.000])\n\nreplay(inputTables=[ds1,ds2], outputTables=[getLeftStream(ajEngine), \n    getRightStream(ajEngine)], dateColumn=`dt);   \n\nselect count(*) from opt\n```\n\n返回：50000\n\n##### 异构回放\n\n异构回放中，回放的输出表通常注入 streamFilter 引擎，进一步过滤分发处理。\n\n```\nn=1000\nsym = take(`IBM`GS,n)\nmyDate=take(2021.01.02..2021.01.06, n).sort!()\nmyTime=take(09:30:00..15:59:59,n)\nvol =  array(INT[], 0, 10)\nfor(i in 0:n){vol.append!([rand(100,3)])}\nt=table(sym,myDate,myTime,vol)\n\nsym = take(`IBM`GS,n)\ndate=take(2021.01.02..2021.01.06, n).sort!()\ntime=take(09:30:00..15:59:59,n)\nvol =  array(INT[], 0, 10)\nfor(i in 0:n){vol.append!([rand(100,3)])}\nprice =  array(DOUBLE[], 0, 10)\nfor(i in 0:n){price.append!([rand(10.0,3)])}\nt1=table(sym, date,time,vol,price)\n\n\nif(existsDatabase(\"dfs://test_stock1\")){\n  dropDatabase(\"dfs://test_stock1\")\n}\ndb1=database(\"\",RANGE, 2021.01.02..2021.01.07)\ndb2=database(\"\",VALUE,`IBM`GS)\ndb=database(\"dfs://test_stock1\",COMPO,[db1, db2], engine=\"TSDB\")\norders=db.createPartitionedTable(t,`orders,`myDate`sym, sortColumns=`sym`myDate`myTime)\norders.append!(t);\ntrades=db.createPartitionedTable(t1,`trades,`date`sym, sortColumns=`sym`date`time)\ntrades.append!(t1);\n// 获取数据源\nds = replayDS(sqlObj=<select * from loadTable(db, `orders)>, dateColumn=`myDate, timeColumn=`myTime)\nds.size();\nds1 = replayDS(sqlObj=<select * from loadTable(db, `trades)>, dateColumn=`date, timeColumn=`time)\nds1.size();\n\ninput_dict  = dict([\"msg1\", \"msg2\"], [ds, ds1])\ndate_dict = dict([\"msg1\", \"msg2\"], [`myDate, `date])\ntime_dict = dict([\"msg1\", \"msg2\"], [`myTime, `time])\n// replay 的输出表，被订阅输入 streamFilter\nshare streamTable(100:0,`timestamp`sym`blob`vol, [DATETIME,SYMBOL, BLOB, INT[]]) as opt\n\nfilterOrder=table(100:0, `sym`date`time`volume, [SYMBOL, DATE, SECOND, INT[]])\nfilterTrades=table(100:0, `sym`date`time`volume`price, [SYMBOL, DATE, SECOND, INT[], DOUBLE[]])\n// 定义 streamFilter 输入表\nshare streamTable(100:0,`timestamp`sym`blob`vol, [DATETIME,SYMBOL, BLOB, INT[]]) as streamFilter_input\n// streamFilter 对接收的数据进行处理，分别分发到表 filterOrder 和 filterTrades\nfilter1=dict(STRING,ANY)\nfilter1['condition']=`msg1\nfilter1['handler']=filterOrder\n\nfilter2=dict(STRING,ANY)\nfilter2['condition']=`msg2\nfilter2['handler']=filterTrades\nschema=dict([\"msg1\",\"msg2\"], [filterOrder, filterTrades])\nstEngine=streamFilter(name=`streamFilter, dummyTable=streamFilter_input, \n    filter=[filter1,filter2], msgSchema=schema)\nsubscribeTable(tableName=\"opt\", actionName=\"sub1\", offset=0, handler=stEngine, msgAsTable=true)\n\nreplay(inputTables=input_dict, outputTables=opt, dateColumn = date_dict, \n    timeColumn=time_dict,  replayRate=100, absoluteRate=false);\n\nselect count(*) from filterOrder\n```\n\n返回：1000\n\n```\nselect count(*) from filterTrades\n```\n\n返回：1000\n\n**Related information**\n\n[replayDS](https://docs.dolphindb.cn/zh/funcs/r/replayDS.html)\n"
    },
    "replayDS": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/replayDS.html",
        "signatures": [
            {
                "full": "replayDS(sqlObj, [dateColumn], [timeColumn], [timeRepartitionSchema])",
                "name": "replayDS",
                "parameters": [
                    {
                        "full": "sqlObj",
                        "name": "sqlObj"
                    },
                    {
                        "full": "[dateColumn]",
                        "name": "dateColumn",
                        "optional": true
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[timeRepartitionSchema]",
                        "name": "timeRepartitionSchema",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [replayDS](https://docs.dolphindb.cn/zh/funcs/r/replayDS.html)\n\n\n\n#### 语法\n\nreplayDS(sqlObj, \\[dateColumn], \\[timeColumn], \\[timeRepartitionSchema])\n\n#### 详情\n\n将一个 SQL 表达式，根据时间维度划分为多个数据源，作为 `replay` 函数的输入，逐一进行回放。时间维度既可以为 DFS 表的时间列的分区粒度，也可以是基于该分区粒度的进一步的划分（由参数 *timeColumn* 与 *timeRepartitionSchema* 决定）。返回一个由数据源列表（类型为 ANY VECTOR）。\n\n若要回放 DFS 表中的数据，只能使用 `replayDS` 函数配合 `replay` 函数进行。\n\n#### 参数\n\n**sqlObj** 表示 SQL 查询的元代码。SQL 查询的表对象是 DFS 表，且至少有一个分区列为时间类型。\n\n**dateColumn** 列必须为 SQL 查询的表对象的时间类型列，一般为 DATE 类型，亦可为 MONTH 类型或其它时间类型。作为数据的排序依据。*dateColumn* 列必须为表的分区列之一，系统将根据 *dateColumn* 列的分区粒度划分数据源，如 dateColumn 列按天进行分区，则数据源也按天进行划分。\n\n**timeColumn** 列必须为 SQL 查询的表对象的时间列，作为数据的排序依据。若 *dateColumn* 为 DATE 类型时，可以指定 *timeColumn* 为 SECOND, TIME 或 NANOTIME 类型的列作为第二排序列。此外，配合 *timeRepartitionSchema* 参数，*timeColumn* 列也可以作为数据源划分依据。\n\n**Note:**\n\n* *dateColumn* 和 *timeColumn* 暂不支持 DATEHOUR 类型的时间列。\n* 如果没有指定 *dateColumn*，原数据表的第一列将会作为 *dateColumn*。\n\n**timeRepartitionSchema** 时间类型的向量。如果指定了 *timeColumn*，*timeRepartitionSchema* 可用于划分更小粒度的数据源。如果 *timeRepartitionSchema* 为 \\[t1, t2, t3]，均为 TIME 类型，则会将每天的数据进一步划分为 4 个数据源：\\[00:00:00.000,t1), \\[t1,t2), \\[t2,t3) 和 \\[t3,23:59:59.999)。\n\n#### 例子\n\n在以下例子中：\n\n1. 创建变量 n。\n2. 创建一个包含 `IBM` 和 `GS` 的 join 表 sym，并重复该表内容。\n3. 创建一个包含 2021.01.04 到 2021.01.06 的日期序列 date，并对其排序，用于模拟交易日。\n4. 创建一个包含 09:30:00 到 15:59:59 的时间序列 time 用于模拟交易时间。\n5. 创建一个包含随机数（范围在 0 到 100 之间）的交易量序列 volume。\n6. 创建一个名为 t 的表，包含符号、日期、时间和交易量这四个字段。\n7. 如果名为 \"dfs\\://test\\_stock\" 的数据库存在，则删除该数据库。\n8. 创建两个不同类型的数据库 db1 和 db2，分别为 RANGE 类型和 VALUE 类型，并将它们组合到 \"dfs\\://test\\_stock\" 中。\n9. 在数据库中创建一个分区表 trades，按 date 和 sym 分区。\n10. 向 trades 表追加 t 表的内容。\n11. 创建一个 replayDS 对象，从 trades 表中加载数据，并按日期维度和时间维度划分这些数据形成数据源列表 ds。\n12. 输出 ds 的大小。\n\n```\nn=int(60*60*6.5)\nsym = take(take(`IBM,n).join(take(`GS,n)), n*2*3)\ndate=take(2021.01.04..2021.01.06, n*2*3).sort!()\ntime=take(09:30:00..15:59:59,n*2*3)\nvolume = rand(100, n*2*3)\nt=table(sym,date,time,volume)\nif(existsDatabase(\"dfs://test_stock\")){\ndropDatabase(\"dfs://test_stock\")\n}\ndb1=database(\"\",RANGE, 2021.01.04..2021.01.07)\ndb2=database(\"\",VALUE,`IBM`GS)\ndb=database(\"dfs://test_stock\",COMPO,[db1, db2])\ntrades=db.createPartitionedTable(t,`trades,`date`sym)\ntrades.append!(t);\nds = replayDS(sqlObj=<select * from loadTable(db, `trades)>, dateColumn=`date, timeColumn=`time)\nds.size();\n```\n\n返回：3。\n\n接着，从数据库中加载名为 trades 表的所有数据，指定 *timeRepartitionSchema* 为 `[11:30:00, 14:00:00]`，按照指定的时间范围对每日数据进行重分区，重新计算数据源列表的大小：\n\n```\nds = replayDS(sqlObj=<select * from loadTable(db, `trades)>, dateColumn=`date, timeColumn=`time, timeRepartitionSchema=[11:30:00, 14:00:00])\nds.size();\n```\n\n指定时间区间 `[11:30:00, 14:00:00]` 后，每天的数据被划分为三个更小的部分 \\[09:30:00, 11:30:00)、\\[11:30:00, 14:00:00] 和 \\[14:00, 15:59:59]。\n\n因此，返回：9。\n\n**Related information**\n\n[replay](https://docs.dolphindb.cn/zh/funcs/r/replay.html)\n"
    },
    "repmat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/repmat.html",
        "signatures": [
            {
                "full": "repmat(X, rowRep, colRep)",
                "name": "repmat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "rowRep",
                        "name": "rowRep"
                    },
                    {
                        "full": "colRep",
                        "name": "colRep"
                    }
                ]
            }
        ],
        "markdown": "### [repmat](https://docs.dolphindb.cn/zh/funcs/r/repmat.html)\n\n\n\n#### 语法\n\nrepmat(X, rowRep, colRep)\n\n#### 参数\n\n**X** 是一个矩阵。\n\n**rowRep** 与 **colRep** 均为正整数。\n\n#### 详情\n\n将矩阵 *X* 竖向重复 *rowRep* 次，横向重复 *colRep* 次，产生一个新的矩阵。\n\n#### 例子\n\n```\nx=matrix(1 2 3, 4 5 6);\n```\n\n输出返回：\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nrepmat(x, 2, 3);\n```\n\n输出返回：\n\n| #0 | #1 | #2 | #3 | #4 | #5 |\n| -- | -- | -- | -- | -- | -- |\n| 1  | 4  | 1  | 4  | 1  | 4  |\n| 2  | 5  | 2  | 5  | 2  | 5  |\n| 3  | 6  | 3  | 6  | 3  | 6  |\n| 1  | 4  | 1  | 4  | 1  | 4  |\n| 2  | 5  | 2  | 5  | 2  | 5  |\n| 3  | 6  | 3  | 6  | 3  | 6  |\n"
    },
    "resample": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/resample.html",
        "signatures": [
            {
                "full": "resample(X, rule, func, [closed], [label], [origin='start_day'])",
                "name": "resample",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "rule",
                        "name": "rule"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    },
                    {
                        "full": "[label]",
                        "name": "label",
                        "optional": true
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    }
                ]
            }
        ],
        "markdown": "### [resample](https://docs.dolphindb.cn/zh/funcs/r/resample.html)\n\n\n\n#### 语法\n\nresample(X, rule, func, \\[closed], \\[label], \\[origin='start\\_day'])\n\n#### 详情\n\n依照指定时间频率（或交易日历），对给定数据使用给定函数。注意，*rule* 指定为交易日历标识时，对于非交易日的数据，将并入上一个交易日计算。\n\n#### 参数\n\n**X** 是一个带有行标签的矩阵或序列（indexed series）。行标签要求为时间类型，不得含有空值，且必须保持递增。\n\n**rule** 是一个字符串，可取以下值：\n\n| rule 参数取值 | 对应 DolphinDB 函数      |\n| --------- | -------------------- |\n| \"B\"       | businessDay          |\n| \"W\"       | weekEnd              |\n| \"WOM\"     | weekOfMonth          |\n| \"LWOM\"    | lastWeekOfMonth      |\n| \"M\"       | monthEnd             |\n| \"MS\"      | monthBegin           |\n| \"BM\"      | businessMonthEnd     |\n| \"BMS\"     | businessMonthBegin   |\n| \"SM\"      | semiMonthEnd         |\n| \"SMS\"     | semiMonthBegin       |\n| \"Q\"       | quarterEnd           |\n| \"QS\"      | quarterBegin         |\n| \"BQ\"      | businessQuarterEnd   |\n| \"BQS\"     | businessQuarterBegin |\n| \"REQ\"     | fy5253Quarter        |\n| \"A\"       | yearEnd              |\n| \"AS\"      | yearBegin            |\n| \"BA\"      | businessYearEnd      |\n| \"BAS\"     | businessYearBegin    |\n| \"RE\"      | fy5253               |\n| \"D\"       | date                 |\n| \"H\"       | hourOfDay            |\n| \"U\"       | microsecond          |\n| \"L\"       | millisecond          |\n| \"min\"     | minuteOfHour         |\n| \"N\"       | nanosecond           |\n| \"S\"       | secondOfMinute       |\n\n上述字符串亦可配合使用数字（必须为正整数），例如 \"2M\" 表示频率为每两个月月末。此外，*rule* 也可以是交易日历标识（国外交易所的 ISO Code、国内交易所简称或自定义交易日历名称），以便基于交易日历进行计算。交易日历也可以配合使用数字，表示多个交易日，此时只能指定由4个大写字母组成的交易日历标识。例如：“2XSHG”，表示上海证券交易所每两个交易日。\n\n**func** 一个聚合函数。\n\n**closed** 字符串，表示分组区间哪一个边界是闭合的。\n\n* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，*closed* 的默认取值为 'right' ，否则，*closed* 的默认取值为 'left'。\n\n* *origin* 取 'end' 或者 'end\\_day' 时，*closed* 的默认值为 'right'。\n\n**label** 字符串，表示将分组区间的哪一个边界作为 *label* 输出。\n\n* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，*label* 的默认取值为 'right' ，否则，*label* 的默认取值为 'left'。\n\n* *origin* 取 'end' 或者 'end\\_day' 时，*label* 的默认值为 'right'。\n\n**origin** 字符串或与 *X* 具有相同时间类型的标量，表示基于时间戳调整分组。*origin* 的取值为 'epoch', start', 'start\\_day', 'end', 'end\\_day' 或自定义的时间对象，默认值为 'start\\_day'。\n\n* 'epoch'：分组起始点为1970-01-01。\n\n* 'start'：分组起始点为时间序列的第一个值。\n\n* 'start\\_day'：分组起始点是时间序列的第一个值对应日期的午夜零点。\n\n* 'end'：分组起始点是时间序列的最后一个时间戳。\n\n* 'end\\_day'：分组起始点是时间序列的最后一个时间戳对应日期的午夜24点（即下一日的零点）。\n\n#### 例子\n\n```\nindex = [2000.01.01, 2000.01.31, 2000.02.15, 2000.02.20, 2000.03.12, 2000.04.16, 2000.05.06, 2000.08.30]\ns = indexedSeries(index, 1..8)\ns.resample(\"M\", sum);\n```\n\n|            | col1 |\n| ---------- | ---- |\n| 2000.01.31 | 3    |\n| 2000.02.29 | 7    |\n| 2000.03.31 | 5    |\n| 2000.04.30 | 6    |\n| 2000.05.31 | 7    |\n| 2000.06.30 |      |\n| 2000.07.31 |      |\n| 2000.08.31 | 8    |\n\n```\ns.resample(\"2M\", last);\n```\n\n|            | col1 |\n| ---------- | ---- |\n| 2000.01.31 | 2    |\n| 2000.03.31 | 5    |\n| 2000.05.31 | 7    |\n| 2000.07.31 |      |\n| 2000.09.30 | 8    |\n\n```\nindex = temporalAdd(2022.01.01 00:00:00,1..8,`m)\ns = indexedSeries(index, 1..8)\ns.resample(rule=`3min, func=sum);\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.01.01T00:00:00 | 3    |\n| 2022.01.01T00:03:00 | 12   |\n| 2022.01.01T00:06:00 | 21   |\n\n```\ns.resample(rule=`3min, func=sum, closed=`right);\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.01.01T00:00:00 | 6    |\n| 2022.01.01T00:03:00 | 15   |\n| 2022.01.01T00:06:00 | 15   |\n\n```\ns.resample(rule=`3min, func=sum, closed=`left,origin=`end);\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.01.01T00:02:00 | 1    |\n| 2022.01.01T00:05:00 | 9    |\n| 2022.01.01T00:08:00 | 18   |\n| 2022.01.01T00:11:00 | 8    |\n\n```\ns.resample(rule=`3min, func=sum,origin=2022.10.01 00:00:10)\n```\n\n| label               | col1 |\n| ------------------- | ---- |\n| 2022.01.01T00:00:10 | 6    |\n| 2022.01.01T00:03:10 | 15   |\n| 2022.01.01T00:06:10 | 15   |\n\n```\nm = matrix(1..5, 1..5)\nindex = temporalAdd(2000.01.01, [1, 1, 2, 2, 3], \"d\")\nm.rename!(index, `A`B);\nm.resample(rule=`D, func=sum);\n```\n\n| label      | A | B |\n| ---------- | - | - |\n| 2000.01.02 | 3 | 3 |\n| 2000.01.03 | 7 | 7 |\n| 2000.01.04 | 5 | 5 |\n\n**Related information**\n\n[spline](https://docs.dolphindb.cn/zh/funcs/s/spline.html)\n\n[neville](https://docs.dolphindb.cn/zh/funcs/n/neville.html)\n\n[dividedDifference](https://docs.dolphindb.cn/zh/funcs/d/dividedDifference.html)\n\n[loess](https://docs.dolphindb.cn/zh/funcs/l/loess.html)\n"
    },
    "resetDBDirMeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/resetDBDirMeta.html",
        "signatures": [
            {
                "full": "resetDBDirMeta(dbDir)",
                "name": "resetDBDirMeta",
                "parameters": [
                    {
                        "full": "dbDir",
                        "name": "dbDir"
                    }
                ]
            }
        ],
        "markdown": "### [resetDBDirMeta](https://docs.dolphindb.cn/zh/funcs/r/resetDBDirMeta.html)\n\n\n\n#### 语法\n\nresetDBDirMeta(dbDir)\n\n#### 参数\n\n**dbDir** 是一个字符串，格式如：\"volumeB/DATABASE\"。表示 DATABASE 将要转移到的目的路径。\n\n#### 详情\n\n跨磁盘卷转移元数据时, 由于元数据中包含了 DATABASE 存储路径相关的信息，所以转移元数据前，必须调用 `resetDBDirMeta` 修改元数据中 DATABASE 存储的路径为目的路径。该命令只能在数据节点上执行。\n\n请注意：\n\n1. 只能在同一个数据节点上进行跨磁盘卷转移元数据的操作。\n\n2. 进行该操作前，需要停止写入，保证所有事务都已完成，并将所有缓冲区的数据刷入磁盘。\n\n假设将 metalog 目录 从 volumeA 转移至 volumeB，完整过程如下：\n\n1. 执行命令 resetDBDirMeta('volumeB/DATABASE') 后关闭 server。\n\n2. 手动拷贝 volumeA 下的目录 CHUNK\\_METADATA, DATABASE, IOTRAN\\_TYPE 和 LOG 到 volumeB。\n\n3. 删除 volumeA 下的目录 CHUNK\\_METADATA，DATABASE，IOTRAN\\_TYPE 和 LOG。\n\n4. 修改配置 *chunkMetaDir* = volumeB/CHUNK\\_METADATA 后启动 server。\n\n**首发版本**：2.00.4\n"
    },
    "resetDfsRebalanceConcurrency": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/resetDfsRebalanceConcurrency.html",
        "signatures": [
            {
                "full": "resetDfsRebalanceConcurrency(newConcurrecyNum)",
                "name": "resetDfsRebalanceConcurrency",
                "parameters": [
                    {
                        "full": "newConcurrecyNum",
                        "name": "newConcurrecyNum"
                    }
                ]
            }
        ],
        "markdown": "### [resetDfsRebalanceConcurrency](https://docs.dolphindb.cn/zh/funcs/r/resetDfsRebalanceConcurrency.html)\n\n\n\n#### 语法\n\nresetDfsRebalanceConcurrency(newConcurrecyNum)\n\n#### 参数\n\n**newConcurrecyNum** 正整数，代表再平衡任务的并发数上限。\n\n#### 详情\n\n在线修改当前节点再平衡任务的最大并发数。此函数只能由管理员在控制节点调用。\n\n注意：此函数修改的配置值将在系统重启后失效。若需使配置值永久生效，请编辑配置文件中的 dfsRebalanceConcurrency 参数。默认情况下，该参数值为集群中控制节点、数据节点和计算节点的节点数之和的两倍。\n\n#### 例子\n\n```\nresetDfsRebalanceConcurrency(2)\n```\n\n相关函数：[getDfsRebalanceConcurrency](https://docs.dolphindb.cn/zh/funcs/g/getDfsRebalanceConcurrency.html)\n"
    },
    "resetDfsRecoveryConcurrency": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/resetDfsRecoveryConcurrency.html",
        "signatures": [
            {
                "full": "resetDfsRecoveryConcurrency(newConcurrecyNum)",
                "name": "resetDfsRecoveryConcurrency",
                "parameters": [
                    {
                        "full": "newConcurrecyNum",
                        "name": "newConcurrecyNum"
                    }
                ]
            }
        ],
        "markdown": "### [resetDfsRecoveryConcurrency](https://docs.dolphindb.cn/zh/funcs/r/resetDfsRecoveryConcurrency.html)\n\n\n\n#### 语法\n\nresetDfsRecoveryConcurrency(newConcurrecyNum)\n\n#### 参数\n\n**newConcurrecyNum** 正整数，代表分区恢复任务的并发数上限。\n\n#### 详情\n\n在线修改当前节点分区恢复任务的最大并发数。此函数只能由管理员在控制节点调用。\n\n注意：此函数修改的配置值将在系统重启后失效。若需使配置值永久生效，请编辑配置文件中的 dfsRecoveryConcurrency参数。默认情况下，该参数值为集群中控制节点、数据节点和计算节点的节点数之和的两倍。\n\n#### 例子\n\n```\nresetDfsRecoveryConcurrency(2)\n```\n\n相关函数：[getDfsRecoveryConcurrency](https://docs.dolphindb.cn/zh/funcs/g/getDfsRecoveryConcurrency.html)\n"
    },
    "resetPwd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/resetPwd.html",
        "signatures": [
            {
                "full": "resetPwd(userId, newPwd)",
                "name": "resetPwd",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    },
                    {
                        "full": "newPwd",
                        "name": "newPwd"
                    }
                ]
            }
        ],
        "markdown": "### [resetPwd](https://docs.dolphindb.cn/zh/funcs/r/resetPwd.html)\n\n\n\n#### 语法\n\nresetPwd(userId, newPwd)\n\n#### 参数\n\n**userId** 表示用户名的字符串。\n\n**newPwd** 表示用户新密码的字符串。它不能包含空格或控制字符。\n\n从 2.00.10.10 开始，用户可以通过配置项 *enhancedSecurityVerification* 控制是否对 *newPwd* 进行复杂性校验。若不设置 *enhancedSecurityVerification*，则不校验；若设置 *enhancedSecurityVerification*=true，则要求新密码必须满足以下条件：\n\n* 字符个数为8\\~20\n\n* 至少包含一个大写字母\n\n* 至少包含以下字符之一：!\"#$%&'()\\*+,-./:;<=>?@\\[]^\\_\\`{|}\\~。\n\n#### 详情\n\n重置用户的密码。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n```\nresetPwd(\"AlexEdwards\", \"T51pm363.\");\n```\n"
    },
    "resetRecoveryWorkerNum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/resetRecoveryWorkerNum.html",
        "signatures": [
            {
                "full": "resetRecoveryWorkerNum(newWorkerNum)",
                "name": "resetRecoveryWorkerNum",
                "parameters": [
                    {
                        "full": "newWorkerNum",
                        "name": "newWorkerNum"
                    }
                ]
            }
        ],
        "markdown": "### [resetRecoveryWorkerNum](https://docs.dolphindb.cn/zh/funcs/r/resetRecoveryWorkerNum.html)\n\n\n\n#### 语法\n\nresetRecoveryWorkerNum(newWorkerNum)\n\n#### 参数\n\n**newWorkerNum** 正整数，指定用于 chunk 恢复的工作线程数。\n\n#### 详情\n\n在线修改当前节点用于 chunk 恢复的工作线程数。该命令只能由管理员在数据节点执行。\n\n请注意，此命令修改的配置值在系统重启后将失效。若需要配置值永久生效，请更改配置文件中的 *recoveryWorkers* （默认值是 1）。\n\n#### 例子\n\n```\nresetRecoveryWorkerNum(2)\n```\n\n相关函数：[getRecoveryWorkerNum](https://docs.dolphindb.cn/zh/funcs/g/getRecoveryWorkerNum.html)\n"
    },
    "reshape": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/reshape.html",
        "signatures": [
            {
                "full": "reshape(obj, [dim])",
                "name": "reshape",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[dim]",
                        "name": "dim",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [reshape](https://docs.dolphindb.cn/zh/funcs/r/reshape.html)\n\n\n\n#### 语法\n\nreshape(obj, \\[dim])\n\n#### 参数\n\n**obj** 是一个向量或矩阵。\n\n**dim** 是一个数据对，表示返回结果的行数和列数。它是一个可选参数。\n\n#### 详情\n\n返回一个改变形状后的矩阵。如果没有指定 *dim*，则将 *obj* 重组为一个向量。\n\n#### 例子\n\n```\nx=1..6;\nx=x.reshape(3:2);\nx\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nx=x.reshape(2:3);\nx\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 1  | 4  | 6  |\n\n```\nx=x.reshape(6:1)\nx\n```\n\n| #0 |\n| -- |\n| 1  |\n| 2  |\n| 3  |\n| 4  |\n| 5  |\n| 6  |\n\n```\nx.reshape()\n// output\n[1,2,3,4,5,6]    // 将 x 重组为一个向量\n```\n"
    },
    "residual": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/residual.html",
        "signatures": [
            {
                "full": "residual(Y,X,params,[intercept=true])",
                "name": "residual",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "params",
                        "name": "params"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [residual](https://docs.dolphindb.cn/zh/funcs/r/residual.html)\n\n\n\n#### 语法\n\nresidual(Y,X,params,\\[intercept=true])\n\n#### 参数\n\n**Y** 是因变量；**X** 是自变量。\n\n**Y** 是一个向量；**X** 是一个矩阵、表或元组。当 *X* 是矩阵时，如果行数等于 *Y* 的长度，*X* 的每一列都是一个因子；如果行数不等于 *Y* 的长度，并且如果列数等于 *Y* 的长度，*X* 的每一行都是一个因子。\n\n**params** 表示回归模型的系数。\n\n**intercept** 是一个布尔变量，表示是否包含回归中的截距。默认值是 true。当它为 true 时，系统自动给 *X* 添加一列 \"1\" 以生成截距。\n\n#### 详情\n\n返回对 *X* 和 *Y* 计算最小二乘回归结果的残差。\n\n**Note:** 对于内存表，[ols](https://docs.dolphindb.cn/zh/funcs/o/ols.html) 和 [wls](https://docs.dolphindb.cn/zh/funcs/w/wls.html) 设置 *mode*=2，即可获得残差。对于分布式表，只能通过此函数计算残差。\n\n#### 例子\n\n例1\n\n```\nx1=1 3 5 7 11 16 23\nx2=2 8 11 34 56 54 100\ny=0.1 4.2 5.6 8.8 22.1 35.6 77.2\n\nparams=ols(y, x1);\nresidual(y,x1,params)\n// output\n[6.634188034188036,3.976923076923078,-1.380341880341881,-4.937606837606838,-5.152136752136756,-8.545299145299146,9.404273504273504]\n\nparams1=ols(y, (x1,x2),false);\nresidual(y,(x1,x2),params1,false)\n// output\n[-1.941530853763632,-2.556479729553295,-4.923597852949359,-11.809587658969416,-11.098921251860737,-4.0152525111045,13.183836820351686]\n\nx=matrix(1 4 8 2 3, 1 4 2 3 8, 1 5 1 1 5);\np1=ols(1..5, x);\nresidual(1..5, x,p1);\n// output\n[-0.474770642201834,0.268348623853214,-0.123853211009174,0.598623853211011,-0.268348623853205]\n```\n\n例2\n\n```\nx1 = 10 20 30 40 50\nx2 = 5 15 25 35 45\nx3 = 3 6 9 12 15\nfactor0 = 10.7 22.2 29.6 43.4 48.9\n\nt = table(x1, x2, x3, factor0)\n\nx = `x + string(1..3) \nresidual = makeCall(member, makeCall(ols, sqlCol(`factor0), makeUnifiedCall(matrix, sqlCol(x)), 1, 2), \"Residual\")\nsql(residual, t).eval()\n```\n\n| member |\n| ------ |\n| -0.74  |\n| 1      |\n| -1.36  |\n| 2.68   |\n| -1.58  |\n"
    },
    "restore": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/restore.html",
        "signatures": [
            {
                "full": "restore(backupDir, dbPath, tableName, partition, [force=false], [outputTable], [parallel=false], [snapshot=false])",
                "name": "restore",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "partition",
                        "name": "partition"
                    },
                    {
                        "full": "[force=false]",
                        "name": "force",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[outputTable]",
                        "name": "outputTable",
                        "optional": true
                    },
                    {
                        "full": "[parallel=false]",
                        "name": "parallel",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[snapshot=false]",
                        "name": "snapshot",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [restore](https://docs.dolphindb.cn/zh/funcs/r/restore.html)\n\n\n\n#### 语法\n\nrestore(backupDir, dbPath, tableName, partition, \\[force=false], \\[outputTable], \\[parallel=false], \\[snapshot=false])\n\n#### 参数\n\n**backupDir** 字符串，表示存放备份数据的目录。\n\n**dbPath** 字符串，表示已备份的分布式数据库的路径。\n\n**tableName** 字符串，表示已备份的表的名称。\n\n**partition** 字符串，表示要恢复的分区的相对路径。分区路径可以包含通配符(\"%\"和\"?\"), \"?\"表示单个字符，\"%\"表示0，1或多个字符。\n\n* 若仅恢复某个分区，输入分区的相对路径或者\"%/\"+”分区名称”。举例：要恢复 \"dfs\\://compoDB\" 下的分区 ”20170810/50\\_100”，输入 \"/compoDB/20170807/0\\_50\" 或者 \"%/20170807/0\\_50\"。 请注意：若使用 2.00.4 \\~ 2.00.6 版本 server，对表级分区数据进行备份和恢复时，该参数必须指定路径到物理索引（可通过函数 [listTables](https://docs.dolphindb.cn/zh/funcs/l/listTables.html) 获取），例如分区 \"/compoDB/20170807/0\\_50\" 下表的物理索引为8，则 *partition* 需指定为 \"/compoDB/20170807/0\\_50/8\"。\n\n* 若需要恢复所有分区，直接输入\"%\"。但需注意，采用此方法可能会导致当前数据表的数据丢失。举例说明：若当前表有10个分区，备份只包含2个分区，若使用%恢复数据，则可能导致表中其他8个分区的数据丢失。\n\n**force** 布尔值，表示是否强制恢复。默认值为 false，表示只有元数据与备份数据元数据不一致的分区，才会恢复。\n\n**outputTable** 分布式表句柄，该表的结构必须与要恢复的表结构一致。如果没有指定 *outputTable*，恢复后的数据会存放到原表；如果指定了 *outputTable*，恢复后的数据会存放到该表中，而原数据表保持不变。\n\n**parallel** 布尔值，表示是否对一个数据表下不同分区进行并行恢复。默认值为 false。\n\n**snapshot** 仅在参数 *partition* = \"%\" 时有效。表示进行非首次恢复时，对于待恢复的数据库，若某些表或分区不在备份数据中，是否同步将数据库中对应的表/分区删除。 若设置为 true，则数据库将同步删除多余的表/分区；若设置为 false（默认值），则数据库不会删除多余的表/分区。\n\n请注意：若 server 版本号低于3.00.1，则 *snapshot* 的默认值是 true，用户需要根据需求合理设置 *snapshot* 参数。\n\n#### 详情\n\n恢复指定分区的数据。返回一个字符串向量，包含恢复的分区的路径。该函数必须要用户登录后才能执行。\n\n#### 注意事项\n\n* 恢复通过 SQL 元代码（即 [backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html) 指定 *sqlObj* 参数）备份的文件时，不能指定 *snapshot*，否则会报错。\n\n* 指定 *outputTable* 时，恢复通过 SQL 元代码备份的文件，系统会在 *outputTable* 中直接追加（append）备份数据；而恢复通过拷贝方式（即 `backup` 指定 *dbPath* 参数）备份的文件时，系统只覆盖 *outputTable* 中数据不一致的分区。若不指定 *outputTable*，则数据恢复至原表，恢复方式相同。\n\n* 恢复时需要确保备份数据与待恢复数据库的引擎类型（engine）一致，且 *partitionScheme*（VALUE 除外）也保持一致。当采用 VALUE 分区时，须保证备份数据中的分区方案是待恢复数据库的分区方案的子集。例如：备份文件的分区方案是 database(\"dfs\\://xxx\", VALUE, 2017.08.07..2017.08.11)， 则待恢复数据库的 VALUE 分区范围必须不小于 2017.08.07..2017.08.11。\n\n#### 例子\n\n创建一个组合分区的数据库 dfs\\://compoDB：\n\n```\nn=1000000\nID=rand(100, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x);\n\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID=database(, RANGE, 0 50 100);\ndb = database(\"dfs://compoDB\", COMPO, [dbDate, dbID]);\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n```\n\n备份表 pt 的所有数据：\n\n```\nbackup(\"/home/DolphinDB/backup\",<select * from loadTable(\"dfs://compoDB\",\"pt\")>,true);\n// output\n10\n```\n\n例1. 恢复所有数据到原表。\n\n```\nrestore(\"/home/DolphinDB/backup\",\"dfs://compoDB\",\"pt\",\"%\",true);\n// output\n[\"dfs://compoDB/20170807/0_50/6F\",\"dfs://compoDB/20170807/50_100/6F\",\"dfs://compoDB/20170808/0_50/6F\",\"dfs://compoDB/20170808/50_100/6F\",\"dfs://compoDB/20170809/0_50/6F\",\"dfs://compoDB/20170809/50_100/6F\",\"dfs://compoDB/20170810/0_50/6F\",\"dfs://compoDB/20170810/50_100/6F\",\"dfs://compoDB/20170811/0_50/6F\",\"dfs://compoDB/20170811/50_100/6F\"]\n```\n\n例2. 恢复日期为2017.08.10的数据。\n\n```\nrestore(\"/home/DolphinDB/backup\",\"dfs://compoDB\",\"pt\",\"%20170810%\",true)\n// output\n[\"dfs://compoDB/20170810/0_50/6F\",\"dfs://compoDB/20170810/50_100/6F\"]\n```\n\n例3. 在数据库 dfs\\://compoDB 中创建一个与表 pt 结构相同的表 temp，把 pt 的数据恢复到表 temp。请注意，采用此方法可能导致表中数据丢失。\n\n```\ntemp=db.createPartitionedTable(t, `pt, `date`ID);\n\nrestore(\"/home/DolphinDB/backup\",\"dfs://compoDB\",\"pt\",\"%\",true,temp);\n// output\n[\"dfs://compoDB/20170807/0_50/6F\",\"dfs://compoDB/20170807/50_100/6F\",\"dfs://compoDB/20170808/0_50/6F\",\"dfs://compoDB/20170808/50_100/6F\",\"dfs://compoDB/20170809/0_50/6F\",\"dfs://compoDB/20170809/50_100/6F\",\"dfs://compoDB/20170810/0_50/6F\",\"dfs://compoDB/20170810/50_100/6F\",\"dfs://compoDB/20170811/0_50/6F\",\"dfs://compoDB/20170811/50_100/6F\"]\n\nselect count(*) from temp;\n```\n\n| count   |\n| ------- |\n| 1000000 |\n\n相关函数：[restoreDB](https://docs.dolphindb.cn/zh/funcs/r/restoreDB.html), [restoreTable](https://docs.dolphindb.cn/zh/funcs/r/restoreTable.html), [migrate](https://docs.dolphindb.cn/zh/funcs/m/migrate.html), [backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html)\n"
    },
    "restoreDB": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/restoreDB.html",
        "signatures": [
            {
                "full": "restoreDB(backupDir, dbPath, [newDBPath])",
                "name": "restoreDB",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "[newDBPath]",
                        "name": "newDBPath",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [restoreDB](https://docs.dolphindb.cn/zh/funcs/r/restoreDB.html)\n\n#### 语法\n\nrestoreDB(backupDir, dbPath, \\[newDBPath])\n\n#### 参数\n\n**backupDir** 字符串，表示存放备份数据的目录\n\n**dbPath** 字符串，表示已备份的分布式数据库的路径\n\n**newDBPath** 字符串，表示新数据库的名称。如果没有指定，默认值为 *dbPath*。\n\n#### 详情\n\n恢复备份的数据到数据库。返回包含数据库名称和表名称的表，每一行为完成恢复的数据库及表名称。\n\n该函数与 [migrate](https://docs.dolphindb.cn/zh/funcs/m/migrate.html) 类似，都可恢复整个数据库下的所有表，区别见表相关内容。\n\n**Note:**\n\n* 该函数仅支持恢复以拷贝文件方式（即 [backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html) 时指定 *dbPath* 参数）进行的备份。\n* 恢复时需要确保备份数据与待恢复数据库的引擎类型（engine）一致，且 *partitionScheme*（VALUE 除外）也保持一致。 当采用 VALUE 分区时，须保证备份数据中的分区方案是待恢复数据库的分区方案的子集。例如：备份文件的分区方案是 database(\"dfs\\://xxx\", VALUE, 2017.08.07..2017.08.11)， 则待恢复数据库的 VALUE 分区范围必须不小于 2017.08.07..2017.08.11。\n\n#### 例子\n\n```\ndbName = \"dfs://compoDB2\"\nn=1000\nID=rand(\"a\"+string(1..10), n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10, n)\nt=table(ID, date, x)\ndb1 = database(, VALUE, 2017.08.07..2017.08.11)\ndb2 = database(, HASH,[INT, 20])\nif(existsDatabase(dbName)){\n     dropDatabase(dbName)\n}\ndb = database(dbName, COMPO,[ db1,db2])\n\n// 创建2个表\npt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\npt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\nbackupDB(backupDir, dbName)\n\nrestoreDB(backupDir, dbName)\n```\n\n| dbName          | tableName |\n| --------------- | --------- |\n| dfs\\://compoDB2 | pt1       |\n| dfs\\://compoDB2 | pt2       |\n\n相关函数：[restore](https://docs.dolphindb.cn/zh/funcs/r/restore.html), [restoreTable](https://docs.dolphindb.cn/zh/funcs/r/restoreTable.html), [migrate](https://docs.dolphindb.cn/zh/funcs/m/migrate.html), [backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html), [backupDB](https://docs.dolphindb.cn/zh/funcs/b/backupDB.html), [backupTable](https://docs.dolphindb.cn/zh/funcs/b/backupTable.html)\n\n"
    },
    "restoreDislocatedTablet": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/restoreDislocatedTablet.html",
        "signatures": [
            {
                "full": "restoreDislocatedTablet()",
                "name": "restoreDislocatedTablet",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [restoreDislocatedTablet](https://docs.dolphindb.cn/zh/funcs/r/restoreDislocatedTablet.html)\n\n\n\n#### 语法\n\nrestoreDislocatedTablet()\n\n#### 参数\n\n无\n\n#### 详情\n\n当配置分区粒度为表级分区时（详见 [StandaloneMode](https://docs.dolphindb.cn/zh/db_distr_comp/cfg/standalone.html) *enableChunkGranularityConfig* 参数），同一个分区的所有表将分布在相同的节点下。当调用函数 [rebalanceChunksAmongDataNodes](https://docs.dolphindb.cn/zh/funcs/r/rebalanceChunksAmongDataNodes.html) 进行数据平衡时，若出现节点宕机或离线，可能出现同一个分区里部分表的数据转移成功，部分表的数据转移失败的情况，即同一个分区下的不同表会分布在不同的节点。该函数可以修复此问题，将同一个分区里的表转移到同一个节点下。\n\n返回一个表，包含以下列：\n\n| 列名       | 含义          |\n| -------- | ----------- |\n| chunkId  | chunk 的唯一标识 |\n| srcNode  | 源节点的别名      |\n| destNode | 目标节点的别名     |\n\n**Note:** 该函数必须在控制节点下运行。\n\n调用该函数后，可以在进行数据平衡的数据节点上执行 [getRecoveryTaskStatus](https://docs.dolphindb.cn/zh/funcs/g/getRecoveryTaskStatus.html) 查看任务执行的状态。\n\n#### 例子\n\n```\nrestoreDislocatedTablet()\n```\n\n| ChunkId                              | srcNode | destNode |\n| ------------------------------------ | ------- | -------- |\n| 99279094-ca12-3b87-48b6-520cbb986f39 | node1   | node2    |\n| 45f612b8-42f5-aebd-4cef-e522b6ae1fc8 | node1   | node2    |\n"
    },
    "restoreSettings": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/restoresettings.html",
        "signatures": [
            {
                "full": "restoreSettings(fileName, [overwrite=false])",
                "name": "restoreSettings",
                "parameters": [
                    {
                        "full": "fileName",
                        "name": "fileName"
                    },
                    {
                        "full": "[overwrite=false]",
                        "name": "overwrite",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [restoreSettings](https://docs.dolphindb.cn/zh/funcs/r/restoresettings.html)\n\n\n\n#### 语法\n\nrestoreSettings(fileName, \\[overwrite=false])\n\n#### 参数\n\n**fileName**STRING 类型标量，指定备份文件的路径，可以为绝对路径或相对于 \\<HomeDir> 的相对路径。\n\n**overwrite**BOOL 类型标量，表示是否将当前数据库系统的用户、用户权限和函数视图更新为与备份文件完全一致：\n\n* false：默认值，表示在恢复过程中仅添加备份文件中存在但当前系统中不存在的用户及其权限、函数视图。对于当前系统已存在的用户和函数视图，不会做任何修改。\n\n* true：表示将当前系统的用户、用户权限和函数视图设置为与备份文件完全一致，即删除当前系统中不存在于备份文件中的用户和函数视图，并添加备份文件中保存的用户及其权限、函数视图。\n\n#### 详情\n\n此函数只能由管理员在控制节点执行，将备份文件中保存的用户、用户权限和函数视图恢复到当前集群。\n\n备份文件由函数 [backupSettings](https://docs.dolphindb.cn/zh/funcs/b/backupsettings.html) 生成，与之搭配可以在数据库迁移时实现用户、用户权限及函数视图的迁移。\n\n函数返回一个向量，依次列出已成功恢复的用户名和函数视图名称。\n\n#### 例子\n\n下例以用户及权限为例，函数视图规则与之类似。\n\n当前集群有用户 A 和 B，备份文件中保存了用户 A，C 。\n\n```\n// 集群中A、B及其权限不变，增加用户C及其权限\nrestoreSettings(fileName=\"/home/ddb/backup/permission.back\", overwrite=false)\n// 集群中A的权限更新为与备份文件一致，删除用户B，增加用户C及其权限\nrestoreSettings(fileName=\"/home/ddb/backup/permission.back\", overwrite=true)\n```\n\n相关函数： [backupSettings](https://docs.dolphindb.cn/zh/funcs/b/backupsettings.html)\n"
    },
    "restoreTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/restoreTable.html",
        "signatures": [
            {
                "full": "restoreTable(backupDir, dbPath, tableName, [newDBPath], [newTableName])",
                "name": "restoreTable",
                "parameters": [
                    {
                        "full": "backupDir",
                        "name": "backupDir"
                    },
                    {
                        "full": "dbPath",
                        "name": "dbPath"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[newDBPath]",
                        "name": "newDBPath",
                        "optional": true
                    },
                    {
                        "full": "[newTableName]",
                        "name": "newTableName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [restoreTable](https://docs.dolphindb.cn/zh/funcs/r/restoreTable.html)\n\n\n\n#### 语法\n\nrestoreTable(backupDir, dbPath, tableName, \\[newDBPath], \\[newTableName])\n\n#### 参数\n\n**backupDir** 字符串，表示存放备份数据的目录。\n\n**dbPath** 字符串，表示已备份的分布式数据库的路径。\n\n**tableName** 字符串，表示表名。\n\n**newDBPath** 字符串，表示新数据库的名称。如果没有指定，默认值为 *dbPath*。\n\n**newTableName** 字符串，表示新表的名称。如果没有指定，默认值为 *tableName*。\n\n#### 详情\n\n恢复备份的表到数据库。返回一个表，包含数据库名称和表名称。调用该函数可以简化代码，方便用户一次性恢复数据库的一张表。\n\n该函数与 [migrate](https://docs.dolphindb.cn/zh/funcs/m/migrate.html) 类似，都可恢复整个数据库下的整个表，区别见表相关内容。\n\n注意事项：\n\n该函数仅支持恢复以拷贝文件方式（即 [backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html) 时指定 *dbPath* 参数）进行的备份。\n\n恢复时需要确保备份数据与待恢复数据库的引擎类型（engine）一致，且 *partitionScheme*（VALUE 除外）也保持一致。 当采用 VALUE 分区时，须保证备份数据中的分区方案是待恢复数据库的分区方案的子集。例如：备份文件的分区方案是 database(\"dfs\\://xxx\", VALUE, 2017.08.07..2017.08.11)， 则待恢复数据库的 VALUE 分区范围必须不小于 2017.08.07..2017.08.11。\n\n#### 例子\n\n```\ndbName = \"dfs://compoDB2\"\nn=1000\nID=rand(\"a\"+string(1..10), n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10, n)\nt=table(ID, date, x)\ndb1 = database(, VALUE, 2017.08.07..2017.08.11)\ndb2 = database(, HASH,[INT, 20])\nif(existsDatabase(dbName)){\n     dropDatabase(dbName)\n}\ndb = database(dbName, COMPO,[ db1,db2])\n\n// 创建2个表\npt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\npt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\nbackupDB(backupDir, dbName)\n\nrestoreTable(backupDir,\"dfs://compoDB2\",`pt1)\n```\n\n输出返回：\n\n| dbName          | tableName |\n| --------------- | --------- |\n| dfs\\://compoDB2 | pt1       |\n\n相关函数：[restore](https://docs.dolphindb.cn/zh/funcs/r/restore.html), [restoreDB](https://docs.dolphindb.cn/zh/funcs/r/restoreDB.html), [migrate](https://docs.dolphindb.cn/zh/funcs/m/migrate.html), [backup](https://docs.dolphindb.cn/zh/funcs/b/backup.html), [backupDB](https://docs.dolphindb.cn/zh/funcs/b/backupDB.html), [backupTable](https://docs.dolphindb.cn/zh/funcs/b/backupTable.html)\n"
    },
    "resumeRecovery": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/resumeRecovery.html",
        "signatures": [
            {
                "full": "resumeRecovery()",
                "name": "resumeRecovery",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [resumeRecovery](https://docs.dolphindb.cn/zh/funcs/r/resumeRecovery.html)\n\n\n\n#### 语法\n\nresumeRecovery()\n\n#### 参数\n\n无\n\n#### 详情\n\n用于重启节点恢复的进程。调用该命令后，会继续恢复 \"Waiting\" 状态的数据。该函数只能由管理员在控制节点上调用。\n\n**Note:**\n\n启用高可用集群时，需要在 raft 组内每个节点执行该命令。\n\n相关命令： [suspendRecovery](https://docs.dolphindb.cn/zh/funcs/s/suspendRecovery.html)\n"
    },
    "reverse": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/reverse.html",
        "signatures": [
            {
                "full": "reverse(X)",
                "name": "reverse",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [reverse](https://docs.dolphindb.cn/zh/funcs/r/reverse.html)\n\n\n\n#### 语法\n\nreverse(X)\n\n#### 参数\n\n**X** 可以是向量、矩阵。\n\n#### 详情\n\n返回一个新的向量或矩阵，它和原有向量或矩阵的元素顺序相反\n\n#### 例子\n\n```\nreverse `hello `world;\n// output\n[world,hello]\n\n(1..6).reverse();\n// output\n[6,5,4,3,2,1]\nx=1..6$2:3;\nx\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nreverse(x);\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n"
    },
    "revoke": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/revoke.html",
        "signatures": [
            {
                "full": "revoke(id, accessType, [objs])",
                "name": "revoke",
                "parameters": [
                    {
                        "full": "id",
                        "name": "id"
                    },
                    {
                        "full": "accessType",
                        "name": "accessType"
                    },
                    {
                        "full": "[objs]",
                        "name": "objs",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [revoke](https://docs.dolphindb.cn/zh/funcs/r/revoke.html)\n\n\n\n#### 语法\n\nrevoke(id, accessType, \\[objs])\n\n#### 参数\n\n**userId** | **groupId** 是表示用户名或组名的字符串。\n\n**accessType** 是权限类型。\n\n**objs** 标量或向量，表示权限类型的应用对象。\n\n**Note:** 注：当 *accessType* 指定为 COMPUTE\\_GROUP\\_EXEC 时，*objs* 必须为对应的计算组名，或 \\*（表示所有计算组）。\n\n*accessType* 和 *objs* 的取值请参照 [用户权限管理](https://docs.dolphindb.cn/zh/tutorials/ACL_and_Security.html) 权限类型表。\n\n#### 详情\n\n`revoke` 函数执行以下操作：\n\n（1）撤销某个用户或某个组的之前被赋予或禁止的权限。\n\n（2）撤销 `grant` 给某个用户的内存约束，包含：查询返回结果的内存上限（指定 *accessType* = QUERY\\_RESULT\\_MEM\\_LIMIT）和发送的批量子查询占用的内存上限（指定 *accessType* = TASK\\_GROUP\\_MEM\\_LIMIT）。撤销后，将恢复为系统的默认值。\n\n管理员可以通过该命令撤销用户所有权限（*accessType*），但普通用户在拥有相关的 OWNER 权限后，只能通过该命令撤销以下权限：TABLE\\_READ, TABLE\\_WRITE, TABLE\\_INSERT, TABLE\\_UPDATE, TABLE\\_DELETE, DB\\_READ, DB\\_WRITE, DB\\_INSERT, DB\\_UPDATE, DB\\_DELETE, DBOBJ\\_DELETE, DBOBJ\\_CREATE 和 VIEW\\_EXEC。\n\n**Note:** 该函数只能由管理员在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n撤销组 \"production\" 的所有成员读取所有数据库表的权限：\n\n```\nrevoke(`production, TABLE_READ, \"*\")\n```\n\n撤销组 \"research\" 的所有成员读写表 dfs\\://db1/t1 的权限：\n\n```\nrevoke(`research, TABLE_WRITE, \"dfs://db1/t1\")\n```\n\n撤销组 \"research\" 的所有成员在数据库 dfs\\://db1 和 dfs\\://db2 创建表的权限：\n\n```\nrevoke(\"research\", DBOBJ_CREATE, [\"dfs://db1\",\"dfs://db2\"])\n```\n\n撤销用户 \"AlexSmith\" 创建和删除数据库的权限：\n\n```\nrevoke(\"AlexSmith\", DB_MANAGE)\n```\n\n撤销用户 \"AlexSmith\" 执行脚本的权限：\n\n```\nrevoke(\"AlexSmith\", SCRIPT_EXEC)\n```\n\n撤销用户 \"AlexSmith\" 测试脚本的权限：\n\n```\nrevoke(\"AlexSmith\", TEST_EXEC)\n```\n"
    },
    "ridge": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/ridge.html",
        "signatures": [
            {
                "full": "ridge(ds, yColName, xColNames, [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [solver='svd'], [swColName])",
                "name": "ridge",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alpha=1.0]",
                        "name": "alpha",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[solver='svd']",
                        "name": "solver",
                        "optional": true,
                        "default": "'svd'"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ridge](https://docs.dolphindb.cn/zh/funcs/r/ridge.html)\n\n#### 语法\n\nridge(ds, yColName, xColNames, \\[alpha=1.0], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[solver='svd'], \\[swColName])\n\n#### 详情\n\n进行 ridge 回归估计。\n\n最小化以下目标函数：\n\n![](https://docs.dolphindb.cn/zh/images/ridge.png)\n\n#### 参数\n\n**ds** 是一个内存表或通常用 [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html) 函数生成的数据源。\n\n**yColName** 是字符串，表示数据源中因变量的列名。\n\n**xColNames** 是字符串标量或向量，表示数据源中自变量的列名。\n\n**alpha** 是浮点数，表示乘以 L1 范数惩罚项的系数。默认值是1.0。\n\n**intercept** 是布尔值，表示是否回归模型包含截距。默认值为true。\n\n**normalize** 是布尔值。默认值为 false。若设为 true，则所有自变量均会进行如下标准化：减去平均值，然后除以 L2 范数。若 *intercept* 为 false，该参数会被忽略。\n\n**maxIter** 是正整数，表示最大迭代次数。默认值是1000。\n\n**tolerance** 是浮点数，表示迭代中止的边界差值。默认值是0.0001。\n\n**solver** 是字符串，表示回归算法模型。可取值 'svd' 或 'cholesky'。若ds为多个数据源，则 *solver* 必须为 'cholesky'。\n\n**swColName** 字符串，表示列名，必须为 *ds* 中存在的列名。如果未指定该参数，则所有样本的权重都默认为1；如果指定该参数，则将指定的列作为样本的权重。\n\n#### 例子\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288]\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599]\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219]\nt = table(y, x0, x1);\n\nridge(t, `y, `x0`x1);\n```\n\n如果 t 是一个 DFS 表，则应使用数据源作为输入：\n\n```\nridge(sqlDS(<select * from t>), `y, `x0`x1);\n```\n\n"
    },
    "ridgeBasic": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/ridgeBasic.html",
        "signatures": [
            {
                "full": "ridgeBasic(Y, X, [mode=0], [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [solver='svd'], [swColName])",
                "name": "ridgeBasic",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[alpha=1.0]",
                        "name": "alpha",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[solver='svd']",
                        "name": "solver",
                        "optional": true,
                        "default": "'svd'"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ridgeBasic](https://docs.dolphindb.cn/zh/funcs/r/ridgeBasic.html)\n\n#### 语法\n\nridgeBasic(Y, X, \\[mode=0], \\[alpha=1.0], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[solver='svd'], \\[swColName])\n\n#### 详情\n\n进行 ridge 回归估计。\n\n最小化以下目标函数：\n\n![](https://docs.dolphindb.cn/zh/images/ridge.png)\n\n#### 参数\n\n`Y` 数值类型的向量，表示因变量。\n\n`X` 数值类型的向量/元组/矩阵/表，表示自变量。\n\n* 当 *X* 是向量/元组时，其长度必须等于 Y 的长度。\n\n* 当 *X* 是矩阵/表时，其行数必须等于 Y 的长度。\n\n`mode` 一个整数，可取以下 3 个值\n\n* 0（默认值）: 输出一个系数估计向量\n\n* 1: 输出一个具有系数估计，标准差，t 统计量和 p 值的表\n\n* 2: 输出一个具有 ANOVA(方差分析)、RegressionStat(回归统计)、Cofficient(系数) 和 Residual(残差) 的字典，具体含义见下表：\n\n键 ANOVA 对应值：\n\n<table id=\"table_txw_vpc_zzb\"><thead><tr><th>\n\nSource of Variance\n\n</th><th>\n\n自由度(Degree of freedom)\n\n</th><th>\n\n平方和(Sum of Square)\n\n</th><th>\n\n均方差(Mean of square)\n\n</th><th>\n\nF统计量\n\n</th><th>\n\nSignificance\n\n</th></tr></thead><tbody><tr><td>\n\nRegression(回归)\n\n</td><td>\n\n变量个数(p)\n\n</td><td>\n\n回归平方和(SSR)\n\n</td><td>\n\n回归均方差(MSR=SSR/R)\n\n</td><td>\n\nMSR对MSE的比值\n\n</td><td>\n\n显著性，即统计出的P值\n\n</td></tr><tr><td>\n\nResidual(残差)\n\n</td><td>\n\n残差自由度(n-p-1)\n\n</td><td>\n\n残差平方和(SSE)\n\n</td><td>\n\n残差均方差(MSE=MSE/E)\n\n</td><td>\n\n</td><td>\n\n</td></tr><tr><td>\n\nTotal\n\n</td><td>\n\n样本自由度， 不包括常数项(n-1)\n\n</td><td>\n\n总离差平方和(SST)\n\n</td><td>\n\n</td><td>\n\n</td><td>\n\n</td></tr></tbody>\n</table>键 RegressionStat 对应值：\n\n<table id=\"table_hcq_xpc_zzb\"><thead><tr><th>\n\nitem\n\n</th><th>\n\n统计值\n\n</th></tr></thead><tbody><tr><td>\n\nR2\n\n</td><td>\n\nR决定系数，描述回归曲线对真实数据点拟合程度的统计量。范围在 \\[0,1]之间，越接近1 ，说明对y的解释能力越强，拟合越好。\n\n</td></tr><tr><td>\n\nAdjustedR2\n\n</td><td>\n\n经自由度修正后的决定系数，通过样本数量与模型数量对 R-squared 进行修正。\n\n</td></tr><tr><td>\n\nStdError\n\n</td><td>\n\n回归残差标准误差，残差经自由度修正后的标准差。\n\n</td></tr><tr><td>\n\nObservations\n\n</td><td>\n\n观察样本个数。\n\n</td></tr></tbody>\n</table>键 Coefficient 对应值：\n\n<table id=\"table_cvz_ypc_zzb\"><thead><tr><th>\n\n元素\n\n</th><th>\n\n说明\n\n</th></tr></thead><tbody><tr><td>\n\nfactor\n\n</td><td>\n\n自变量名称\n\n</td></tr><tr><td>\n\nbeta\n\n</td><td>\n\n回归系数估计值\n\n</td></tr><tr><td>\n\nstdError\n\n</td><td>\n\n回归系数标准误差。\n\n</td></tr><tr><td>\n\ntstat\n\n</td><td>\n\nT统计值，衡量系数的统计显著性。\n\n</td></tr></tbody>\n</table>键 Residual 对应每一个预测值和实际值之间的残差。\n\n`alpha` 一个浮点数，表示乘以L1范数惩罚项的系数。默认值是1.0。\n\n`intercept` 布尔值，表示是否包含回归中的截距。默认值为 true，此时系统自动给 *X* 添加一列 “1” 以生成截距。\n\n`normalize` 布尔值，默认值为 false。若设为 true，则所有自变量均会进行如下标准化：减去平均值，然后除以L2范数。若 intercept 为 false，该参数会被忽略。\n\n`maxIter` 一个正整数，表示最大迭代次数。默认值是1000。\n\n`tolerance` 一个浮点数，表示迭代中止的边界差值。默认值是0.0001。\n\n`solve` 字符串，表示回归算法模型。可取值 ‘svd’ 或 ‘cholesky’。若 ds 为多个数据源，则 solver 必须为 ’cholesky’。\n\n`swColName` 字符串，表示列名，必须为 X 中存在的列名。如果未指定该参数，则所有样本的权重都默认为1；如果指定该参数，则将指定的列作为自变量的权重。\n\n"
    },
    "ridgeCV": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/ridgeCV.html",
        "signatures": [
            {
                "full": "ridgeCV(ds, yColName, xColNames, [alphas=[0.01,0.1,1.0]], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [solver='svd'], [swColName])",
                "name": "ridgeCV",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "yColName",
                        "name": "yColName"
                    },
                    {
                        "full": "xColNames",
                        "name": "xColNames"
                    },
                    {
                        "full": "[alphas=[0.01",
                        "name": "[alphas=[0.01"
                    },
                    {
                        "full": "0.1",
                        "name": "0.1"
                    },
                    {
                        "full": "1.0]]",
                        "name": "1.0]]"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[normalize=false]",
                        "name": "normalize",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[maxIter=1000]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[tolerance=0.0001]",
                        "name": "tolerance",
                        "optional": true,
                        "default": "0.0001"
                    },
                    {
                        "full": "[solver='svd']",
                        "name": "solver",
                        "optional": true,
                        "default": "'svd'"
                    },
                    {
                        "full": "[swColName]",
                        "name": "swColName",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [ridgeCV](https://docs.dolphindb.cn/zh/funcs/r/ridgeCV.html)\n\n#### 语法\n\nridgeCV(ds, yColName, xColNames, \\[alphas=\\[0.01,0.1,1.0]], \\[intercept=true], \\[normalize=false], \\[maxIter=1000], \\[tolerance=0.0001], \\[solver='svd'], \\[swColName])\n\n#### 详情\n\n使用五折交叉验证法进行岭回归（ridge）估计，输出最优参数对应的岭回归模型。结果为一个字典，包含以下 key：\n\n* modelName：模型名称，ridgeCV 方法对应的模型名为 \"ridgeCV\"。\n\n* coefficients：模型的回归系数。\n\n* intercept：截距。\n\n* xColNames：数据源中自变量的列名。\n\n* predict：用于预测的函数。\n\n* alpha：交叉验证选择的惩罚量。\n\n![](https://docs.dolphindb.cn/zh/images/ridge.png)\n\n#### 参数\n\n**alphas** 是浮点型标量或向量，表示乘以L1范数惩罚项的系数。默认值是 \\[0.01, 0.1, 1.0]。\n\n**Note:** 除 *alphas* 参数外，其它参数都和 ridge 的参数相同，参数描述可参考 [ridge](https://docs.dolphindb.cn/zh/funcs/r/ridge.html)。这里仅说明 *alphas* 参数。\n\n#### 例子\n\n```\ny = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288]\nx0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599]\nx1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219]\nt = table(y, x0, x1);\n\nridgeCV(t, `y, `x0`x1);\n```\n\n返回如下：\n\n```\ncoefficients->[94.3410,14.2523]\npredict->coordinateDescentPredict\nmodelName->ridgeCV\nxColNames->[x0,x1]\nintercept->0.1063\nalpha->0.0100\n```\n\n"
    },
    "right": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/right.html",
        "signatures": [
            {
                "full": "right(X, n)",
                "name": "right",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [right](https://docs.dolphindb.cn/zh/funcs/r/right.html)\n\n\n\n#### 语法\n\nright(X, n)\n\n#### 参数\n\n**X** 是一个字符串或字符串向量。\n\n**n** 必须是一个非负整数。\n\n#### 详情\n\n返回 *X* 右边 *n* 个字符。\n\n#### 例子\n\n```\nright(\"I love this game!\", 6);\n```\n\n输出返回：game!\n"
    },
    "rm": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rm.html",
        "signatures": [
            {
                "full": "rm(filename)",
                "name": "rm",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    }
                ]
            }
        ],
        "markdown": "### [rm](https://docs.dolphindb.cn/zh/funcs/r/rm.html)\n\n\n\n#### 语法\n\nrm(filename)\n\n#### 参数\n\n**filename** 是要删除的文件的名称。\n\n#### 详情\n\n删除一个文件。该命令必须要用户登录后才能执行。\n\n#### 例子\n\n```\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| abc.txt  | 0     | 15       | 1496650187443 | 1496647459999 |\n| dir1     | 1     | 0        | 1496650004836 | 1496650004836 |\n| dir2     | 1     | 0        | 1496650002210 | 1496650002210 |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n\n```\nrm(\"/home/test/abc.txt\");       // delete file abc.txt\n\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| dir1     | 1     | 0        | 1496650004836 | 1496650004836 |\n| dir2     | 1     | 0        | 1496650002210 | 1496650002210 |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n"
    },
    "rmdir": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rmdir.html",
        "signatures": [
            {
                "full": "rmdir(directory, [recursive=false], [keepRootDir=false])",
                "name": "rmdir",
                "parameters": [
                    {
                        "full": "directory",
                        "name": "directory"
                    },
                    {
                        "full": "[recursive=false]",
                        "name": "recursive",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keepRootDir=false]",
                        "name": "keepRootDir",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [rmdir](https://docs.dolphindb.cn/zh/funcs/r/rmdir.html)\n\n#### 语法\n\nrmdir(directory, \\[recursive=false], \\[keepRootDir=false])\n\n#### 参数\n\n**directory** 必备参数，用于指定要删除的文件夹名称。如果该目录不为空，则通过设定 *recursive* 的值为 true 可以删除所有子目录和文件\n\n**recursive** 布尔值，可选参数，用于是否删除所有指定文件夹所有子目录及其中文件。默认值为 false。\n\n**keepRootDir** 布尔值，可选参数，用于指定是否保留根目录。默认值为 false。当设置为 true 时，仅删除子目录和文件，而不会删除根目录。\n\n**Note:** 若设置 *keepRootDir*=true，则必须设置 *recursive*=true。\n\n#### 详情\n\n删除目录。默认情况下，要删除的目录必须为空。如果目录不为空仍然要删除它时，请设置 *recursive* 的值为true。\n\n**Note:** 该命令在用户登录后才能执行。\n\n#### 例子\n\n```\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| dir1     | 1     | 0        | 1496650004836 | 1496650004836 |\n| dir2     | 1     | 0        | 1496650002210 | 1496650002210 |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n\n```\n// delete a directory. dir1 is empty, dir2 is not empty.\nrmdir(\"/home/test/dir1\");\nrmdir(\"/home/test/dir2\");\n// output\nFailed to remove directory [/home/test/dir2] with error code 145\n\n// Delete a directory recursively\nrmdir(\"/home/test/dir2\", true);\n\nfiles(\"/home/test\");\n```\n\n| filename | isDir | fileSize | lastAccessed  | lastModified  |\n| -------- | ----- | -------- | ------------- | ------------- |\n| dir3     | 1     | 0        | 1496649999597 | 1496649999597 |\n\n"
    },
    "rollingPanel": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rollingPanel.html",
        "signatures": [
            {
                "full": "rollingPanel(X, window, [groupingCol])",
                "name": "rollingPanel",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[groupingCol]",
                        "name": "groupingCol",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rollingPanel](https://docs.dolphindb.cn/zh/funcs/r/rollingPanel.html)\n\n\n\n#### 语法\n\nrollingPanel(X, window, \\[groupingCol])\n\n#### 参数\n\n**X** 是一个数据表。\n\n**window** 是一个正整数，表示窗口长度。\n\n**groupingCol** 是一个字符串标量或向量，表示数据表 *X* 中的某个或某些列。\n\n#### 详情\n\n滚动截取数据表 *X* 中固定数量的行，产生一个新的数据表。若 *groupingCol* 指定，分组进行上述操作。\n\n结果中 panelNumber 列为每次截取的数据的编号，从0开始。\n\n#### 例子\n\n```\nt=table(1 1 1 1 1 2 2 2 2 2 as id, 1..10 as x);\nrollingPanel(t, 3, `id);\n```\n\n| id | x  | panelNumber |\n| -- | -- | ----------- |\n| 1  | 1  | 0           |\n| 1  | 2  | 0           |\n| 1  | 3  | 0           |\n| 1  | 2  | 1           |\n| 1  | 3  | 1           |\n| 1  | 4  | 1           |\n| 1  | 3  | 2           |\n| 1  | 4  | 2           |\n| 1  | 5  | 2           |\n| 2  | 6  | 3           |\n| 2  | 7  | 3           |\n| 2  | 8  | 3           |\n| 2  | 7  | 4           |\n| 2  | 8  | 4           |\n| 2  | 9  | 4           |\n| 2  | 8  | 5           |\n| 2  | 9  | 5           |\n| 2  | 10 | 5           |\n"
    },
    "round": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/round.html",
        "signatures": [
            {
                "full": "round(X, [precision])",
                "name": "round",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[precision]",
                        "name": "precision",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [round](https://docs.dolphindb.cn/zh/funcs/r/round.html)\n\n\n\n#### 语法\n\nround(X, \\[precision])\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n**precision** 是 0 到 10 的整数，表示保留小数点后几位。默认值是 0。\n\n#### 详情\n\n`round` 函数按照指定小数位数对 *X* 进行四舍五入运算。\n\n[floor](https://docs.dolphindb.cn/zh/funcs/f/floor.html) 和 [ceil](https://docs.dolphindb.cn/zh/funcs/c/ceil.html) 函数分别将一个实数映射到不大于 *X* 的最大整数和不小于 *X* 的最小整数。\n\n#### 例子\n\n```\nround 2.1;\n//output: 2\n\nround 2.9;\n//output: 3\n\nround -2.1;\n//output: -2\n\nround(2.154,2);\n//output: 2.15\n\nround(2.156,2);\n//output: 2.16\n\nceil 2.1;\n//output: 3\n\nceil 2.9;\n//output: 3\n\nceil -2.1;\n//output: -2\n\nfloor 2.1;\n//output: 2\n\nfloor 2.9;\n//output: 2\n\nfloor -2.1;\n//output: -3\n\nm = 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9 10$2:5;\nm;\n```\n\n返回：\n\n| #0  | #1  | #2  | #3  | #4  |\n| --- | --- | --- | --- | --- |\n| 1.1 | 3.3 | 5.5 | 7.7 | 9.9 |\n| 2.2 | 4.4 | 6.6 | 8.8 | 10  |\n\n```\nround m;\n```\n\n返回：\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 6  | 8  | 10 |\n| 2  | 4  | 7  | 9  | 10 |\n"
    },
    "row": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/row.html",
        "signatures": [
            {
                "full": "row(obj,index)",
                "name": "row",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "index",
                        "name": "index"
                    }
                ]
            }
        ],
        "markdown": "### [row](https://docs.dolphindb.cn/zh/funcs/r/row.html)\n\n#### 语法\n\nrow(obj,index)\n\n#### 参数\n\n**obj** 可以是向量、矩阵或表\n\n**index** 是一个整数标量或数据对。\n\n#### 详情\n\n返回向量、矩阵或表的一行。参见相关函数：[col](https://docs.dolphindb.cn/zh/funcs/c/col.html)。\n\n#### 例子\n\n```\nx=matrix(1 2 3, 4 5 6);\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nrow(x,1);\n// output\n[2,5]\n\nrow(x,0);\n// output\n[1,4]\n\nx.row(2);\n// output\n[3,6]\n\na=table(1..3 as x,`IBM`C`AAPL as y);\na\n```\n\n| x | y    |\n| - | ---- |\n| 1 | IBM  |\n| 2 | C    |\n| 3 | AAPL |\n\n```\nrow(a,1);\n// output\ny->C\nx->2\n```\n\n"
    },
    "rowAlign": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowAlign.html",
        "signatures": [
            {
                "full": "rowAlign(left, right, how)",
                "name": "rowAlign",
                "parameters": [
                    {
                        "full": "left",
                        "name": "left"
                    },
                    {
                        "full": "right",
                        "name": "right"
                    },
                    {
                        "full": "how",
                        "name": "how"
                    }
                ]
            }
        ],
        "markdown": "### [rowAlign](https://docs.dolphindb.cn/zh/funcs/r/rowAlign.html)\n\n#### 语法\n\nrowAlign(left, right, how)\n\n#### 参数\n\n**left/right**是数组向量或列式元组。\n\n**Note:**\n\n* *left* 和 *right* 的长度和类型必须相同，但它们对应的每行向量的个数可以相同或不同。例如：*left* 的长度是3，其第一行向量的长度是5，则 *right* 的长度必须是3，其每一行向量的长度可以是5或者其它值。\n\n* 必须保证 *left*/*right* 中每行向量的数据严格有序排列。\n\n**how** 字符串，用于指定数据对齐的方式。设置值不同，会影响 *left* 和 *right* 对齐的数据范围。可选值为：\n\n| how(不区分大小写) | 含义                                                            | 对齐后的最大值                    | 对齐后的最小值                    |\n| ----------- | ------------------------------------------------------------- | -------------------------- | -------------------------- |\n| \"bid\"       | 表示 left/right 为多档买方报价数据，其数据严格降序排列。此时，仅将有效档位内的数据进行对齐。          | max(max(left), max(right)) | max(min(left), min(right)) |\n| \"allBid\"    | 表示 left/right 为多档买方报价数据，其数据严格降序排列。此时，将 left 和 right 所有数据进行对齐。 | max(max(left), max(right)) | min(min(left), min(right)  |\n| \"ask\"       | 表示 left/right 为多档卖方报价数据，其数据严格升序排列。此时，仅将有效档位内的数据进行对齐。          | min(max(left), max(right)) | min(min(left), min(right)) |\n| ”allAsk“    | 表示 left/right 为多档卖方报价数据，其数据严格升序排列。此时，将 left 和 right 所有数据进行对齐。 | max(max(left), max(right)) | min(min(left), min(right)  |\n\n#### 详情\n\n对 *left* 和 *right* 中的每一行向量，根据其元素值进行对齐。返回一个长度为 2 的元组，分别表示对齐后的数据在原向量中的索引。若 *left/right* 中不存在数据与 *right/left* 的元素值相等，则返回 -1。\n\n该函数主要应用于金融场景下对多档买卖报价进行价格对齐，*left* 是某个时刻的买价/卖价，而 *right* 则是上一时刻的买价/卖价。通常结合 `rowAt` 函数，按行取出索引对应的元素。\n\n注意：若 *left/right* 是列式元组，则返回的元组内的元素也是列式元组。\n\n下图演示某行的 *left* 和 *right* 对齐的过程。图中标注出对齐方式为 “bid“ 和 “allBid“ ，”ask” 和 “allAsk“ 时的区别（ 蓝色背景是以 “bid“ 或 “ask“ 对齐时，超出有效档位的数据）。\n\n通过 `rowAt` 函数可以按行取出对应索引的元素。\n\n* *how* = \"bid\" 或 \"allBid\" 时，bid 中某行数据的对齐过程如下图所示：\n\n  ![rowAlign1](https://docs.dolphindb.cn/zh/images/rowAlign_1.png)\n\n* *how* = \"ask\" 或 \"allAsk\" 时，ask 中某行数据的对齐过程如下图所示：\n\n  ![rowAlign2](https://docs.dolphindb.cn/zh/images/rowAlign_2.png)\n\n#### 例子\n\n```\nleft = array(DOUBLE[], 0, 5).append!([9.01 9.00 8.99 8.98 8.97, 9.00 8.98 8.97 8.96 8.95, 8.99 8.97 8.95 8.93 8.91])\nright = array(DOUBLE[], 0, 5).append!([9.02 9.01 9.00 8.99 8.98, 9.01 9.00 8.99 8.98 8.97, 9.00 8.98 8.97 8.96 8.95])\nleftIndex, rightIndex = rowAlign(left, right, \"bid\")\nleftIndex\n//output:[[-1,0,1,2,3],[-1,0,-1,1,2],[-1,0,-1,1,-1,2]]\nleft.rowAt(leftIndex)\n//output:[[,9.01,9.00,8.99,8.98],[,9,,8.99,8.97],[,8.99,,8.97,,8.95]]\n\nrightIndex\n//output:[[0,1,2,3,4],[0,1,2,3,4],[0,-1,1,2,3,4]]\nright.rowAt(rightIndex)\n//output:[[9.02,9.01,9.00,8.99,8.98],[9.01,9.00,8.99,8.98,8.97],[9.00,,8.98,8.97,8.96,8.95]]\n\n// 输出 left 与 right 数据对齐后的买方报价\nleft.rowAt(leftIndex).nullFill(right.rowAt(rightIndex))\n//output:[[9.02,9.01,9,8.99,8.98],[9.01,9.00,8.99,8.98,8.97],[9.00,8.99,8.98,8.97,8.96,8.95]]\n\n// 假定 bid 对应的 qty 如下\n leftBidQty = array(INT[], 0, 5).append!([10 5 15 20 13, 12 15 20 21 18, 7 8 9 9 10])\n rightBidQty = array(INT[], 0, 5).append!([8 12 10 12 8, 10 5 15 18 13, 12 15 20 21 19])\n\n// 计算 left 和 right 五档报价对应委托量的变化\nleftBidQty.rowAt(leftIndex).nullFill(0) - rightBidQty.rowAt(rightIndex).nullFill(0)\n//output:[[-8,-2,-5,3,12],[-10,7,-15,-3,7],[-12,7,-15,-12,-21,-10]]\n\nleftIndex, rightIndex = rowAlign(left, right, \"allBid\")\nleftIndex\n//output:[[-1,0,1,2],[-1,-1,0,1,2],[-1,0,-1,1,2]]\n\nrightIndex\n//output:[[0,1,2,-1],[0,1,2,-1,-1],[0,-1,1,2,-1]]\n\nleft = array(DOUBLE[], 0, 3).append!([8.99 9.00 9.01, 8.97 8.99 9.00, 8.95 8.97 8.99])\nright = array(DOUBLE[], 0, 3).append!([9.00 9.01 9.02, 8.99 9.00 9.01, 8.97 8.98 9.00])\nleftIndex, rightIndex = rowAlign(left, right, \"ask\")\nleftIndex\n//output:[[0,1,2],[0,1,2],[0,1,-1,2]]\n\nrightIndex\n//output:[[-1,0,1],[-1,0,1],[-1,0,1,-1]]\n\nleftIndex, rightIndex = rowAlign(left, right, \"allAsk\")\nleftIndex\n//output:[[0,1,2,-1],[0,1,2,-1],[0,1,-1,2,-1]]\n\nrightIndex\n//output:[[-1,0,1,2],[-1,0,1,2],[-1,0,1,-1,2]]\n\nsym = `st1`st2`st3\nleft = [[3.1,2.5,2.8], [3.1,3.3], [3.2,2.9,3.3]]\nleft.setColumnarTuple!()\nright = [[3.1,2.5,2.8], [3.1,3.3], [3.2,2.9,3.3]]\nright.setColumnarTuple!()\nrowAlign(left, right, \"bid\")\n//output:[([0,1,2],[0,1],[0,1,2]), ([0,1,2],[0,1],[0,1,2])]\n```\n\n"
    },
    "rowAnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowAnd.html",
        "signatures": [
            {
                "full": "rowAnd(args...)",
                "name": "rowAnd",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowAnd](https://docs.dolphindb.cn/zh/funcs/r/rowAnd.html)\n\n\n\n#### 语法\n\nrowAnd(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行逻辑与操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([true false false, true true true, true true true])\nrowAnd(m);\n// output\n[1,0,0]\n\nt1=table(false true true true false as x, false true false true true as y)\nrowAnd(t1);\n// output\n[0,1,0,1,0]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\n// output\n\nselect *  from t where rowAnd(price1>30, price2>50);\n```\n\n| sym  | price1 | price2 |\n| ---- | ------ | ------ |\n| AAPL | 49.6   | 175.23 |\n| IBM  | 30.02  | 51.29  |\n\n相关函数：[and](https://docs.dolphindb.cn/zh/funcs/a/and.html)\n"
    },
    "rowAt": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowAt.html",
        "signatures": [
            {
                "full": "rowAt(X, [Y])",
                "name": "rowAt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rowAt](https://docs.dolphindb.cn/zh/funcs/r/rowAt.html)\n\n\n\n#### 语法\n\nrowAt(X, \\[Y])\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 参数\n\n**X** 矩阵、数组向量或列式元组。\n\n**Y** 整型向量、布尔型矩阵、整型或布尔型数组向量或列式元组。\n\n#### 详情\n\n逐行取出 *X* 中对应索引的元素，返回一个与 *Y* 长度相同的向量。若索引无对应元素或索引超出 *X* 的有效索引范围，则返回空值。\n\n* 若 *Y* 是整型向量，*Y* 的每个元素表示 *X* 每行的列索引，逐行取出 *X* 中对应索引的元素，返回一个与 *Y* 长度相同的向量。若索引无对应元素或索引超出 *X* 的有效索引范围，则返回空值。\n\n* 若 *Y* 是布尔类型的矩阵或数组向量（或列式元组），则取出 *X* 对应于 *Y* 中 true 值的元素，返回一个与 *Y* 行数相同的数组向量。若 *Y* 中某一行的所有元素值都是 false，则该行返回空值。其中，当 Y 是布尔类型矩阵时，X 只能是矩阵。\n\n* 若 *Y* 是整型数组向量（或列式元组），*Y* 的每个元素表示 *X* 每行的列索引，逐行取出 *X* 中对应索引的元素，返回一个与 *Y* 维度相同的数组向量（或列式元组）。若索引无对应元素或索引超出 *X* 的有效索引范围，则返回空值。\n\n* 若 *Y* 不指定，*X* 必须是布尔类型的矩阵或数组向量（或列式元组）。该函数逐行取出 *X* 中元素值是 true 的索引。返回一个整型数组向量（或列式元组），其行数和 *X* 的行数相同。若 *X* 中某一行的所有元素值都是空值或 false，则该行返回空值。\n\n#### 例子\n\n```\nm = matrix(3.1 4.5 2.2, 4.2 4.3 5.1, 6.2 7.1 2.2, 1.8 6.1 5.3, 7.1 8.4 3.5)\nindex = 4 0 2\nrowAt(m, index)\n// output\n[7.1,4.5,2.2]\n\ntrades = table(10:0,`time`sym`p1`p2`p3`p4`p5`vol1`vol2`vol3`vol4`vol5,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,INT,INT,INT,INT,INT])\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 200, 180, 180, 220, 200)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.1, 32.8, 33.2, 34.3, 32.3, 150, 280, 190, 100, 220)\ninsert into trades values(2022.01.01T09:00:00, `A, 31.2, 32.6, 33.6, 35.3, 34.5, 220, 160, 130, 100, 110)\ninsert into trades values(2022.01.01T09:00:00, `A, 30.2, 32.5, 33.6, 35.3, 34.1, 200, 180, 150, 140, 120)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 180, 160, 160, 180, 200)\nselect rowAt(matrix(p1, p2, p3, p4, p5), rowImin(vol1, vol2, vol3, vol4, vol5)) as price1, rowAt(matrix(p1, p2, p3, p4, p5), rowImax(vol1, vol2, vol3, vol4, vol5)) as price2 from trades\n```\n\n| price1 | price2 |\n| :----- | :----- |\n| 33.8   | 33.3   |\n| 34.3   | 32.8   |\n| 35.3   | 31.2   |\n| 34.1   | 30.2   |\n| 33.8   | 33.1   |\n\n```\nindex = array\\(INT\\[\\], 0, 10\\).append!\\(\\[0 1, 2 4, 3 4 5\\]\\)\nrowAt\\(m, index\\)\n// output\n\\[\\[3.1,4.2\\],\\[7.1,8.4\\],\\[5.3,3.5,\\]\\]\n\nx = array\\(DOUBLE\\[\\], 0, 10\\).append!\\(\\[3.3 3.6 3.8, 3.7 3.4 3.5, 3.4 3.4 3.5\\]\\)\nindex = array\\(INT\\[\\], 0, 10\\).append!\\(\\[0 1, 2, 0 2\\]\\)\nrowAt\\(x, index\\)\n// output\n\\[\\[3.3,3.6\\],\\[3.5\\],\\[3.4,3.5\\]\\]\n```\n\n2.00.10.2 及以上版本，当 *X* 是布尔类型矩阵或数组向量时，*Y* 可以不指定，此时 `rowAt` 返回每行中 true 元素的索引。\n\n```\nm = matrix(true false false, false true false, true true false)\nR=rowAt(m)\nR\n// output\n[[0,2],[1,2],]\ntypestr(R)\n// output\nFAST INT[] VECTOR\n\nm = matrix(3.1 4.5 2.2, 2.2 4.3 5.1, 1.2 7.1 2.2, 1.8 6.1 5.3, 1 4 3)\nrowAt(m, m>4)\n// output\n[,[4.5,4.3,7.1,6.1],[5.1,5.3]]\n\nx = array(DOUBLE[], 0, 10).append!([3.3 3.6 3.8, 3.7 3.4 3.5, 3.4 3.4 3.5])\nrowAt(x, x>3.5)\n// output\n[[3.6,3.8],[3.7],]\n```\n\n对列式元组与数组向量应用 `rowAt`：\n\n```\nx = ([1, 2, 3], [4, 5, 6]).setColumnarTuple!()\ny = fixedLengthArrayVector([1, 4], [2, 5], [3, 6])\n\nrowAt(x, x > 1)\n// output\n([2,3],[4,5,6])\n\nrowAt(y, y>1)\n// output\n[[2,3],[4,5,6]]\n```\n\n**Related information**\n\n[at](https://docs.dolphindb.cn/zh/funcs/a/at.html)\n"
    },
    "rowAvg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowAvg.html",
        "signatures": [
            {
                "full": "rowAvg(args...)",
                "name": "rowAvg",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowAvg](https://docs.dolphindb.cn/zh/funcs/r/rowAvg.html)\n\n\n\n#### 语法\n\nrowAvg(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行元素求平均操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowAvg(m);\n// output\n[3.633333,3.133333,3.7]\n\nt1=table(1..5 as x, 6..10 as y)\nt2=table(5..1 as a, 10..6 as b);\nrowAvg(t1);\n// output\n[3.5,4.5,5.5,6.5,7.5]\n\nrowAvg(t1[`x], t2, take(1, 5));\n// output\n[4.25,4,3.75,3.5,3.25]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect sym,rowAvg(price1,price2) as avg from t;\n```\n\n| sym  | price1  |\n| ---- | ------- |\n| AAPL | 112.415 |\n| MS   | 40.11   |\n| IBM  | 39.92   |\n| IBM  | 40.655  |\n| C    | 100.6   |\n\n相关函数：[avg](https://docs.dolphindb.cn/zh/funcs/a/avg.html)\n"
    },
    "rowBeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowBeta.html",
        "signatures": [
            {
                "full": "rowBeta(Y, X)",
                "name": "rowBeta",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowBeta](https://docs.dolphindb.cn/zh/funcs/r/rowBeta.html)\n\n\n\n#### 语法\n\nrowBeta(Y, X)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行计算 *Y* 在 *X* 上的回归系数的最小二乘估计，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm1=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nm2=matrix(49.6 NULL 29.52, 50.32 51.29 26.23, NULL 74.97 23.75)\nrowBeta(m1, m2)\n// output\n[-4.1667,-0.1182, -1.3374]\n\nm3=matrix(8 NULL 10, 8 NULL 4, 14 NULL NULL)\nrowBeta(m3, m2)\n// output\n[0, , 1.8237]\n\na= 110 112.3 44 98\nb= 57.9 39 75 90\nc= 55 64 37 78\nx=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[a, b, c\\]\\)\ny=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[b, a, c\\]\\)\nrowBeta\\(x, y\\)\n// output\n\\[0.6783, 1 , -0.3202, 1\\]\n```\n\n相关函数：[beta](https://docs.dolphindb.cn/zh/funcs/b/beta.html)\n"
    },
    "rowCorr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowCorr.html",
        "signatures": [
            {
                "full": "rowCorr(X, Y)",
                "name": "rowCorr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowCorr](https://docs.dolphindb.cn/zh/funcs/r/rowCorr.html)\n\n\n\n#### 语法\n\nrowCorr(X, Y)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行计算 *X* 和 *Y* 之间的相关性，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm1=matrix(2 -1 4, 8 3 2, 9 0 1)\nm2=matrix(8 11 10, 8 17 4, 14 6 4)\nrowCorr(m1, m2)\n// output\n[0.61, 0.7559, 0.9449]\n\nm3=matrix(8 NULL 10, 8 NULL 4, 14 NULL NULL)\nrowCorr(m1, m3)\n// output\n[0.61, , 1]\n\na=array\\(DOUBLE\\[\\], 0, 10\\).append!\\(\\[1 2 3, 4 NULL 5, 6 7 8, NULL 3 10\\]\\);\nb=array\\(DOUBLE\\[\\], 0, 10\\).append!\\(\\[\\[1.3,1.2, 4\\], \\[1.0,1.4, 2\\], \\[1.1, 1.4, 3\\],\\[1, 4, 7\\]\\]\\);\n\nrowBeta\\(a, b\\)\n// output\n\\[0.535, 1 , 0.9105, 2.3333\\]\n```\n\n相关函数：[corr](https://docs.dolphindb.cn/zh/funcs/c/corr.html)\n"
    },
    "rowCount": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowCount.html",
        "signatures": [
            {
                "full": "rowCount(args...)",
                "name": "rowCount",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowCount](https://docs.dolphindb.cn/zh/funcs/r/rowCount.html)\n\n\n\n#### 语法\n\nrowCount(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行非空值的统计操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]);\nrowCount(m);\n// output\n[3,3,2]\n\nt1=table(1 NULL 3 NULL 5 as x, 6..10 as y);\nt2=table(5 NULL 3 NULL 1 as a, 10..6 as b);\nrowCount(t1);\n// output\n[2,1,2,1,2]\n\nrowCount(t1[`x], t2, 1 NULL 2 NULL NULL);\n// output\n[4,1,4,1,3]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, [49.6, NULL, 29.52, NULL, 174.97] as price1, [175.23, NULL, 50.32, 51.29, 26.23] as price2);\nselect sym,rowCount(price1,price2) as count from t;\n```\n\n| sym  | count |\n| ---- | ----- |\n| AAPL | 2     |\n| MS   | 0     |\n| IBM  | 2     |\n| IBM  | 1     |\n| C    | 2     |\n\n相关函数：[rowSize](https://docs.dolphindb.cn/zh/funcs/r/rowSize.html), [count](https://docs.dolphindb.cn/zh/funcs/c/count.html)\n"
    },
    "rowCovar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowCovar.html",
        "signatures": [
            {
                "full": "rowCovar(X, Y)",
                "name": "rowCovar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowCovar](https://docs.dolphindb.cn/zh/funcs/r/rowCovar.html)\n\n\n\n#### 语法\n\nrowCovar(X, Y)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行计算 *X* 和 *Y* 之间的协方差，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm1=matrix(2 8 9 12, 9 14 11 8,-3 NULL NULL 9)\nm2=matrix(11.2 3 5 9, 7 -10 8 5,17 12 18 9)\nrowCovar(m1, m2)\n// output\n[-29.7333, -39, 3, 3.3333]\n\na= 110 112.3 44 98\nb= 57.9 39 75 90\nc= 55 64 37 78\nx=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[a, b, c\\]\\)\ny=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[b, a, c\\]\\)\n\nrowCovar\\(x, y\\)\n// output\n\\[-327.9475, -327.9475, 295\\]\n```\n\n```\n// 定义一个随机数据集x\n\nx = rand(1.0, 1000000)\n\n// 自定义了一个聚合函数，窗口长度为5，滑动计算窗口内 x 和它排序后数据的协方差\ntimer moving(defg(x):covar(x, sort(x)), x, 5)\n// output\n1928.888 ms\n\n// movingWindowIndex 滑动选取 x 的5个元素的索引，movingTopNIndex 滑动选取 x 的5个元素排序后的索引。通过 rowCovar 函数计算\ntimer rowCovar(x[movingWindowIndex(x, 5)], x[movingTopNIndex(x, 5, 5)])\n// output\n232.407 ms\n```\n\n相关函数：[covar](https://docs.dolphindb.cn/zh/funcs/c/covar.html)\n"
    },
    "rowCummax": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowCummax.html",
        "signatures": [
            {
                "full": "rowCummax(X)",
                "name": "rowCummax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowCummax](https://docs.dolphindb.cn/zh/funcs/r/rowCummax.html)\n\n\n\n#### 语法\n\nrowCummax(X)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行计算 *X* 元素的累积最大值。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowCummax(m)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 4.5  | 4.5  | 4.9  |\n| 2.6  | 4.8  | 4.8  |\n| 1.5  | 5.9  | 5.9  |\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowCummax(a)\n// output\n[[1,2,3],[4,5],[6,7,8]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowCummax(tp)\n// output\n[[1.3,2.5,2.5],[4.1,5.3,6.2]]\n```\n"
    },
    "rowCummin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowCummin.html",
        "signatures": [
            {
                "full": "rowCummax(X)",
                "name": "rowCummax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowCummin](https://docs.dolphindb.cn/zh/funcs/r/rowCummin.html)\n\n\n\n#### 语法\n\nrowCummax(X)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行计算 *X* 元素的累积最小值。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowCummin(m)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 4.5  | 1.5  | 1.5  |\n| 2.6  | 2.6  | 2    |\n| 1.5  | 1.5  | 1.5  |\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowCummin(a)\n// output\n[[1,1,1],[4,4],[6,6,6]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowCummin(tp)\n// output\n[[1.3,1.3,1.3],[4.1,4.1,4.1]]\n```\n"
    },
    "rowCumprod": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowCumprod.html",
        "signatures": [
            {
                "full": "rowCumprod(X)",
                "name": "rowCumprod",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowCumprod](https://docs.dolphindb.cn/zh/funcs/r/rowCumprod.html)\n\n\n\n#### 语法\n\nrowCumprod(X)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行计算 *X* 元素的累积乘积。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowCumprod(m)\n```\n\n| col1 | col2  | col3   |\n| ---- | ----- | ------ |\n| 4.5  | 6.75  | 33.075 |\n| 2.6  | 12.48 | 24.96  |\n| 1.5  | 8.85  | 8.85   |\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowCumprod(a)\n// output\n[[1,3,6],[4,9],[6,13,21]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowCumprod(tp)\n// output\n[[1.3,3.25,7.475],[4.1,21.73,134.726]]\n```\n"
    },
    "rowCumsum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowCumsum.html",
        "signatures": [
            {
                "full": "rowCumsum(X)",
                "name": "rowCumsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowCumsum](https://docs.dolphindb.cn/zh/funcs/r/rowCumsum.html)\n\n\n\n#### 语法\n\nrowCumsum(X)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行计算 *X* 中元素的累计和。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowCumsum(m)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 4.5  | 6    | 10.9 |\n| 2.6  | 7.4  | 9.4  |\n| 1.5  | 7.4  | 7.4  |\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowCumsum(a)\n// output\n[[1,3,6],[4,9],[6,13,21]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowCumsum(tp)\n// output\n[[1.3,3.8,6.1],[4.1,9.4,15.6]]\n```\n"
    },
    "rowCumwsum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowCumwsum.html",
        "signatures": [
            {
                "full": "rowCumwsum(X, Y)",
                "name": "rowCumwsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowCumwsum](https://docs.dolphindb.cn/zh/funcs/r/rowCumwsum.html)\n\n\n\n#### 语法\n\nrowCumwsum(X, Y)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行计算 *X* 和 *Y* 的累积内积。\n\n#### 例子\n\n```\nm1=matrix(2 -1 4, 8 3 2, 9 0 1)\nm2=matrix(8 11 10, 8 17 4, 14 6 4)\nrowCumwsum(m1, m2)\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 16   | 80   | 206  |\n| -11  | 40   | 40   |\n| 40   | 48   | 52   |\n\n```\na= -10 12.3 4 -8\nb= 17.9 9 7.5 -4\nc= 5.5 6.4 -7 8\nx=array(DOUBLE[],0, 10).append!([a, b, c])\ny=array(DOUBLE[],0, 10).append!([b, a, c])\nrowCumwsum(x, y)\n// output\n[[-179,-68.30,-38.30,-6.29],[-179,-68.30,-38.30,-6.29],[30.25,71.21,120.21,184.21]]\n\ntp1 = [[3,4,5],[4,5,6]]\ntp1.setColumnarTuple!()\n\ntp2 = [[13,41,25],[21,30,10]]\ntp2.setColumnarTuple!()\nrowCumwsum(tp1, tp2)\n// output\n[[39,203,328],[84,234,294]]\n```\n"
    },
    "rowDenseRank": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowDenseRank.html",
        "signatures": [
            {
                "full": "rowDenseRank(X, [ascending=true], [ignoreNA=true], [percent=false])",
                "name": "rowDenseRank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [rowDenseRank](https://docs.dolphindb.cn/zh/funcs/r/rowDenseRank.html)\n\n\n\n#### 语法\n\nrowDenseRank(X, \\[ascending=true], \\[ignoreNA=true], \\[percent=false])\n\n#### 参数\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)。\n\n**ascending** 是一个布尔值，表示排序方向。true 表示升序，false 表示降序。默认值为 true。它是一个可选参数。\n\n**ignoreNA** 是一个布尔值，表示是否忽略 NULL 值。true 表示忽略 NULL 值，false 表示 NULL 值参与排名。默认值为 true。它是一个可选参数。NULL 值参与排序时，NULL 值为最小值。\n\n**percent** 是一个布尔值，表示是否以百分比形式显示返回的排名。\n\n#### 详情\n\n逐行计算 *X* 的元素连续排名，排名方式请参照 [denseRank](https://docs.dolphindb.cn/zh/funcs/d/denseRank.html)，返回一个和 *X* 维度相同的矩阵。\n\n#### 例子\n\n```\nm = matrix(1 5 8 5 9, 2 8 2 5 2, 6 5 3 3 4)\nrowDenseRank(m)\n```\n\n返回：\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 0    | 1    | 2    |\n| 0    | 1    | 0    |\n| 2    | 0    | 1    |\n| 1    | 1    | 0    |\n| 2    | 0    | 1    |\n\n返回：\n\n```\ny=matrix(1 3 3, 6 5 6, NULL 0 9)\nrowDenseRank(y)\n```\n\n返回：\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 0    |      | 1    |\n| 1    | 2    | 0    |\n| 0    | 1    | 2    |\n\n```\nrowDenseRank(y, ignoreNA=false)\n```\n\n返回：\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 2    | 0    |\n| 1    | 2    | 0    |\n| 0    | 1    | 2    |\n\n**Related information**\n\n[denseRank](https://docs.dolphindb.cn/zh/funcs/d/denseRank.html)\n\n[rowRank](https://docs.dolphindb.cn/zh/funcs/r/rowRank.html)\n"
    },
    "rowDot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowDot.html",
        "signatures": [
            {
                "full": "rowDot(X, Y)",
                "name": "rowDot",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowDot](https://docs.dolphindb.cn/zh/funcs/r/rowDot.html)\n\n\n\n#### 语法\n\nrowDot(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是长度相同的数值型向量或数组向量，或维度相同的矩阵。若 *X* 和 *Y* 为数组向量，它们对应位置的向量必须具有相同长度。\n\n#### 详情\n\n若 *X* 和 *Y* 同时为向量/矩阵，按行计算 *X* 和 *Y* 的内积。若 *X* 和 *Y* 同时为索引矩阵，会对齐标签，对标签相同的行进行计算，标签不同的行直接返回 NULL。\n\n若 *X* 和 *Y* 一个为向量，一个为矩阵，则向量的长度必须与矩阵的列数相同，计算向量与矩阵每一行的内积。\n\n若 *X* 和 *Y* 是数组向量，计算 *X* 和 *Y* 对应位置的向量的内积，即 dot(X.row(i),Y.row(i))。\n\n若 *X* 和 *Y* 一个为向量，一个为数组向量，计算向量与数组向量内每个向量的内积。两个向量的长度相同时返回计算结果，长度不相同时返回 NULL。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nrowDot(13.5 15.2 6.3, 18.6 14.8 15.5)\n// output\n[251.1,224.96,97.65]\n\ns1=indexedSeries(2020.01.01..2020.01.03, 10.4 11.2 9)\ns2=indexedSeries(2020.01.01 2020.01.03 2020.01.04, 23.5 31.2 26)\nrowDot(s1,s2)\n// output\n[244.4,349.44,234]\n\nm=matrix(23 56 47, 112 94 59)\nm1=matrix(11 15 89, 52 41 63)\nrowDot(m,m1)\n// output\n[6077,4694,7900]\n\nm.rename!(2020.01.01..2020.01.03, `A`B)\nm.setIndexedMatrix!()\nm1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\nm1.setIndexedMatrix!()\nrowDot(m,m1)\n// output\n[6077,NULL,3124,NULL]\n\na=array(DOUBLE[],0,10)\na.append!([[10.5, 11.8, 9],[15, NULL], [2.5, 2.2, 1.3, 1.5]])\nb=array(DOUBLE[],0,10)\nb.append!([[1.1, 1.8, 6],[5, 6.9], [3.5, 2, 3, 2.8]])\nrowDot(a,b)\n// output\n[86.79,75,21.25]\n```\n\n相关函数：[dot](https://docs.dolphindb.cn/zh/funcs/d/dot.html)\n"
    },
    "rowEuclidean": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowEuclidean.html",
        "signatures": [
            {
                "full": "rowEuclidean(X, Y)",
                "name": "rowEuclidean",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowEuclidean](https://docs.dolphindb.cn/zh/funcs/r/rowEuclidean.html)\n\n\n\n#### 语法\n\nrowEuclidean(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是长度相同的数值型向量或数组向量，或维度相同的矩阵。若 *X* 和 *Y* 为数组向量，它们对应位置的向量必须具有相同长度。\n\n#### 详情\n\n若 *X* 和 *Y* 同时为向量/矩阵，按行计算 *X* 和 *Y* 之间的欧式距离。若 *X* 和 *Y* 同时为索引矩阵，会对齐标签，对标签相同的行进行计算，标签不同的行直接返回 NULL。\n\n若 *X* 和 *Y* 一个为向量，一个为矩阵，则向量的长度必须与矩阵的列数相同，计算向量与矩阵每一行的欧式距离。\n\n若 *X* 和 *Y* 是数组向量，计算 *X* 和 *Y* 对应位置的向量之间的欧式距离，即 euclidean(X.row(i),Y.row(i))。\n\n若 *X* 和 *Y* 一个为向量，一个为数组向量，计算向量与数组向量内每个向量的欧式距离。两个向量的长度相同时返回计算结果，长度不相同时返回 NULL。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nrowEuclidean(3.6 5.2 6.3, 8.6 4.8 5.5)\n// output\n[5,0.4,0.8]\n\nm=matrix(23 56 47, 112 94 59)\nm1=matrix(11 15 89, 52 41 63)\nrowEuclidean(m,m1)\n// output\n[61.1882,67.0075,42.19]\n\nm.rename!(2020.01.01..2020.01.03, `A`B)\nm.setIndexedMatrix!()\nm1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\nm1.setIndexedMatrix!()\nrowEuclidean(m,m1)\n// output\n[61.1882,NULL,36.7151,NULL]\n\na=array(INT[],0,10)\na.append!([[1, 8, 9],[15, NULL], [25, 22, 13, 15]])\nb=array(INT[],0,10)\nb.append!([[11, 18, 6],[5, 9], [5, 2, 3, 1]])\nrowEuclidean(a,b)\n// output\n[14.4568,10,33.1059]\n```\n\n相关函数：[euclidean](https://docs.dolphindb.cn/zh/funcs/e/euclidean.html)\n"
    },
    "rowImax": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowImax.html",
        "signatures": [
            {
                "full": "rowImax(args...)",
                "name": "rowImax",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowImax](https://docs.dolphindb.cn/zh/funcs/r/rowImax.html)\n\n\n\n#### 语法\n\nrowImax(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n返回每行元素中最大元素的索引。如果有多个相同的最大值，返回左起第一个最大值的索引。结果为一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5 3.2, 1.5 4.8 5.9 1.7, 4.9 2.0 NULL 5.5])\nprint rowImax(m)\n```\n\n返回：\\[2,1,1,2]\n\n```\ntrades = table(10:0,`time`sym`p1`p2`p3`p4`p5`vol1`vol2`vol3`vol4`vol5,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,INT,INT,INT,INT,INT])\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 200, 180, 180, 220, 200)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.1, 32.8, 33.2, 34.3, 32.3, 150, 280, 190, 100, 220)\ninsert into trades values(2022.01.01T09:00:00, `A, 31.2, 32.6, 33.6, 35.3, 34.5, 220, 160, 130, 100, 110)\ninsert into trades values(2022.01.01T09:00:00, `A, 30.2, 32.5, 33.6, 35.3, 34.1, 200, 180, 150, 140, 120)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 180, 160, 160, 180, 200)\nselect rowAt(matrix(p1, p2, p3, p4, p5), rowImax(vol1, vol2, vol3, vol4, vol5)) as price from trades\n```\n\n返回：\n\n| price |\n| ----- |\n| 33.3  |\n| 32.8  |\n| 31.2  |\n| 30.2  |\n| 33.1  |\n\n当 args 是数组向量时，返回每行元素中的最大元素的索引，结果为一个向量：\n\n```\na = 1 8 3 8 1\nb = 5 8 1 3 6\nc =  9 5 4 7 6\nx = fixedLengthArrayVector(a, b, c)\nrowImax(x)\n```\n\n返回：\\[2,0,2,0,1]\n\n**Related information**\n\n[imax](https://docs.dolphindb.cn/zh/funcs/i/imax.html)\n\n[rowImaxLast](https://docs.dolphindb.cn/zh/funcs/r/rowimaxlast.html)\n\n[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n"
    },
    "rowImaxLast": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowimaxlast.html",
        "signatures": [
            {
                "full": "rowImaxLast(args…)",
                "name": "rowImaxLast",
                "parameters": [
                    {
                        "full": "args…",
                        "name": "args…"
                    }
                ]
            }
        ],
        "markdown": "### [rowImaxLast](https://docs.dolphindb.cn/zh/funcs/r/rowimaxlast.html)\n\n\n\n#### 语法\n\nrowImaxLast(args…)\n\n#### 参数\n\nrow 系列函数通用参数说明和计算规则请参考：[行计算系列（row 系列）](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n返回每行元素中最大元素的索引。如果有多个相同的最大值，返回右起第一个最大值的索引。结果为一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5 3.2, 1.5 4.8 5.9 1.7, 4.9 2.0 NULL 5.5])\nrowImaxLast(m)\n// output\n[2,1,1,2]\n\ntrades = table(10:0,`time`sym`p1`p2`p3`p4`p5`vol1`vol2`vol3`vol4`vol5,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,INT,INT,INT,INT,INT])\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 200, 180, 180, 220, 200)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.1, 32.8, 33.2, 34.3, 32.3, 150, 280, 190, 100, 220)\ninsert into trades values(2022.01.01T09:00:00, `A, 31.2, 32.6, 33.6, 35.3, 34.5, 220, 160, 130, 100, 110)\ninsert into trades values(2022.01.01T09:00:00, `A, 30.2, 32.5, 33.6, 35.3, 34.1, 200, 180, 150, 140, 120)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 180, 160, 160, 180, 200)\n\nselect rowAt(matrix(p1, p2, p3, p4, p5), rowImaxLast(vol1, vol2, vol3, vol4, vol5)) as price from trades\n// output\nprice\n33.3\n32.8\n31.2\n30.2\n33.1\n\n```\n\n相关函数：[rowImax](https://docs.dolphindb.cn/zh/funcs/r/rowImax.html)\n"
    },
    "rowImin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowImin.html",
        "signatures": [
            {
                "full": "rowImin(args...)",
                "name": "rowImin",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowImin](https://docs.dolphindb.cn/zh/funcs/r/rowImin.html)\n\n\n\n#### 语法\n\nrowImin(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n返回每行元素中最小元素的索引。如果有多个相同的最小值，返回左起第一个最小值的索引。结果为一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5 3.2, 1.5 4.8 5.9 1.7, 4.9 2.0 NULL 5.5])\nrowImin(m)\n```\n\n返回：\\[1,2,0,1]\n\n```\ntrades = table(10:0,`time`sym`p1`p2`p3`p4`p5`vol1`vol2`vol3`vol4`vol5,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,INT,INT,INT,INT,INT])\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 200, 180, 180, 220, 200)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.1, 32.8, 33.2, 34.3, 32.3, 150, 280, 190, 100, 220)\ninsert into trades values(2022.01.01T09:00:00, `A, 31.2, 32.6, 33.6, 35.3, 34.5, 220, 160, 130, 100, 110)\ninsert into trades values(2022.01.01T09:00:00, `A, 30.2, 32.5, 33.6, 35.3, 34.1, 200, 180, 150, 140, 120)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 180, 160, 160, 180, 200)\n\nselect rowAt(matrix(p1, p2, p3, p4, p5), rowImin(vol1, vol2, vol3, vol4, vol5)) as price from trades\n```\n\n返回：\n\n| price |\n| ----- |\n| 33.8  |\n| 34.3  |\n| 35.3  |\n| 34.1  |\n| 33.8  |\n\n当 args 是数组向量时，返回每行元素中的最小元素的索引，结果为一个向量：\n\n```\na = 1 8 3 8 1\nb = 5 7 1 3 9\nc =  5 5 4 3 6\nx = fixedLengthArrayVector(a, b, c)\nrowImin(x)\n```\n\n返回：\\[0,2,1,1,0]\n\n**Related information**\n\n[imin](https://docs.dolphindb.cn/zh/funcs/i/imin.html)\n\n[rowIminLast](https://docs.dolphindb.cn/zh/funcs/r/rowiminlast.html)\n\n[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n"
    },
    "rowIminLast": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowiminlast.html",
        "signatures": [
            {
                "full": "rowIminLast(args…)",
                "name": "rowIminLast",
                "parameters": [
                    {
                        "full": "args…",
                        "name": "args…"
                    }
                ]
            }
        ],
        "markdown": "### [rowIminLast](https://docs.dolphindb.cn/zh/funcs/r/rowiminlast.html)\n\n\n\n#### 语法\n\nrowIminLast(args…)\n\n#### 参数\n\nrow 系列函数通用参数说明和计算规则请参考：[行计算系列（row 系列）](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n返回每行元素中最小元素的索引。如果有多个相同的最小值，返回右起第一个最小值的索引。结果为一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5 3.2, 1.5 4.8 5.9 1.7, 4.9 2.0 NULL 5.5])\nrowIminLast(m)\n// output\n[1,2,0,1]\n\ntrades = table(10:0,`time`sym`p1`p2`p3`p4`p5`vol1`vol2`vol3`vol4`vol5,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,INT,INT,INT,INT,INT])\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 200, 180, 180, 220, 200)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.1, 32.8, 33.2, 34.3, 32.3, 150, 280, 190, 100, 220)\ninsert into trades values(2022.01.01T09:00:00, `A, 31.2, 32.6, 33.6, 35.3, 34.5, 220, 160, 130, 100, 110)\ninsert into trades values(2022.01.01T09:00:00, `A, 30.2, 32.5, 33.6, 35.3, 34.1, 200, 180, 150, 140, 120)\ninsert into trades values(2022.01.01T09:00:00, `A, 33.2, 33.8, 33.6, 33.3, 33.1, 180, 160, 160, 180, 200)\n\nselect rowAt(matrix(p1, p2, p3, p4, p5), rowIminLast(vol1, vol2, vol3, vol4, vol5)) as price from trades\n// output\nprice\n33.6\n34.3\n35.3\n34.1\n33.6\n\n```\n\n相关函数：[rowImin](https://docs.dolphindb.cn/zh/funcs/r/rowImin.html)\n"
    },
    "rowKurtosis": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowKurtosis.html",
        "signatures": [
            {
                "full": "rowKurtosis(X, [biased=true])",
                "name": "rowKurtosis",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [rowKurtosis](https://docs.dolphindb.cn/zh/funcs/r/rowKurtosis.html)\n\n\n\n#### 语法\n\nrowKurtosis(X, \\[biased=true])\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否为有偏估计。默认值为 true，表示为有偏估计。\n\n#### 详情\n\n逐行计算 *X* 的峰度。\n\nDolphinDB 使用以下公式计算峰度（当 *biased*=true 时）：\n\n![kurtosisx](https://docs.dolphindb.cn/zh/images/kurtosisx.png)\n\n#### 例子\n\n```\nm = [4.5 2.6 1.5 1.5 4.8, 5.9 4.9 2.0 4.0 6.3, 2 2 2 2 2, 2.1 3.4 4.2 5.5 2.3]\nrowKurtosis(m);\n// output\n[1.336589711715856,1.839333299961742,2.248755164221374,1.437834622248661,1.341044189891083]\n\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL, 4.3 NULL 3.5]);\nrowKurtosis(m);\n// output\n[2.270290894661423,1.499999999999941,1.499999999999972]\n\nt1=table(1..5 as x, 10..6 as y, 15..19 as z, take(3,5) as t);\nrowKurtosis(t1);\n// output\n[1.417974225003112,1.676864,1.951167883478534,2.158698670898631,2.262015004030008]\n```\n\n相关函数：[kurtosis](https://docs.dolphindb.cn/zh/funcs/k/kurtosis.html)\n"
    },
    "rowMax": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowMax.html",
        "signatures": [
            {
                "full": "rowMax(args...)",
                "name": "rowMax",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowMax](https://docs.dolphindb.cn/zh/funcs/r/rowMax.html)\n\n\n\n#### 语法\n\nrowMax(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行取最大值的操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowMax(m);\n```\n\n返回：\\[4.9,4.8,5.9]\n\n```\nt1=table(1..5 as x, 6..10 as y)\nt2=table(5..1 as a, 10..6 as b);\n\nrowMax(t1);\n```\n\n返回：\\[6,7,8,9,10]\n\n```\nrowMax(t1[`y], t2, take(8, 5));\n```\n\n返回：\\[10,9,8,9,10]\n\n```\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect sym,rowMax(price1,price2) as max from t;\n```\n\n返回：\n\n| sym  | max    |\n| ---- | ------ |\n| AAPL | 175.23 |\n| MS   | 50.76  |\n| IBM  | 50.32  |\n| IBM  | 51.29  |\n| C    | 174.97 |\n\n**Related information**\n\n[max](https://docs.dolphindb.cn/zh/funcs/m/max.html)\n"
    },
    "rowMin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowMin.html",
        "signatures": [
            {
                "full": "rowMin(args...)",
                "name": "rowMin",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowMin](https://docs.dolphindb.cn/zh/funcs/r/rowMin.html)\n\n\n\n#### 语法\n\nrowMin(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行取最小值的操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowMin(m);\n// output\n[1.5,2,1.5]\n\nt1=table(1..5 as x, 6..10 as y)\nt2=table(5..1 as a, 10..6 as b);\n\nrowMin(t1);\n// output\n[1,2,3,4,5]\n\nrowMin(t1[`x], t2, take(2, 5));\n// output\n[1,2,2,2,1]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect sym,rowMin(price1,price2) as min from t;\n```\n\n| sym  | min   |\n| ---- | ----- |\n| AAPL | 49.6  |\n| MS   | 29.46 |\n| IBM  | 29.52 |\n| IBM  | 30.02 |\n| C    | 26.23 |\n\n相关函数：[min](https://docs.dolphindb.cn/zh/funcs/m/min.html)\n"
    },
    "rowMove": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowMove.html",
        "signatures": [
            {
                "full": "rowMove(X, steps)",
                "name": "rowMove",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "steps",
                        "name": "steps"
                    }
                ]
            }
        ],
        "markdown": "### [rowMove](https://docs.dolphindb.cn/zh/funcs/r/rowMove.html)\n\n\n\n#### 语法\n\nrowMove(X, steps)\n\n#### 参数\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)。\n\n**steps** 是一个整数，表示移动多少位置。\n\n* 如果 *steps* 为正数，*X* 向右移动 *steps* 个位置；\n\n* 如果 *steps* 为负数，*X* 向左移动 *steps* 个位置；\n\n* 如果 *steps* 为 0，不改变 *X* 的位置。\n\n#### 详情\n\n根据 *steps* 的设置，逐行移动元素。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowMove(m, 2)\n```\n\n返回：\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n|      |      | 4.5  |\n|      |      | 2.6  |\n|      |      | 1.5  |\n\n```\nrowMove(m, -2)\n```\n\n返回：\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 4.9  |      |      |\n| 2    |      |      |\n|      |      |      |\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowMove(a, 2)\n\n//output: [[00i,00i,1],[00i,00i],[00i,00i,6]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowMove(tp, -2)\n\n//output: [[2.3,00F,00F],[6.200000000000001,00F,00F]]\n```\n"
    },
    "rowNames": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowNames.html",
        "signatures": [
            {
                "full": "rowNames(X)",
                "name": "rowNames",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowNames](https://docs.dolphindb.cn/zh/funcs/r/rowNames.html)\n\n\n\n#### 语法\n\nrowNames(X)\n\n#### 参数\n\n**X** 是一个矩阵\n\n#### 详情\n\n返回矩阵 *X* 的行名。参见相关函数： [columnNames](https://docs.dolphindb.cn/zh/funcs/c/columnNames.html)\n\n#### 例子\n\n```\nx=1..6$2:3;\nx\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nx.rename!(1 2, `a`b`c);\n```\n\n|   | a | b | c |\n| - | - | - | - |\n| 1 | 1 | 3 | 5 |\n| 2 | 2 | 4 | 6 |\n\n```\nrowNames x;\n// output\n[1,2]\n```\n"
    },
    "rowNext": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowNext.html",
        "signatures": [
            {
                "full": "rowNext(X)",
                "name": "rowNext",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowNext](https://docs.dolphindb.cn/zh/funcs/r/rowNext.html)\n\n\n\n#### 语法\n\nrowNext(X)\n\n#### 详情\n\n逐行将 *X* 向左移动一个位置。\n\n#### 参数\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowNext(m)\n```\n\n返回：\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1.5  | 4.9  |      |\n| 4.8  | 2    |      |\n| 5.9  |      |      |\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowNext(a)\n\n//output: [[2,3,00i],[5,00i],[7,8,00i]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowNext(tp)\n\n//output: [[2.5,2.3,00F],[5.3,6.2,00F]]\n```\n"
    },
    "rowNo": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowNo.html",
        "signatures": [
            {
                "full": "rowNo(X)",
                "name": "rowNo",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowNo](https://docs.dolphindb.cn/zh/funcs/r/rowNo.html)\n\n\n\n#### 语法\n\nrowNo(X)\n\n#### 参数\n\n**X** 是向量。\n\n#### 详情\n\n*rowNo* 通常用于在表中产生行号。行号从 0 开始。\n\n#### 例子\n\n```\nteam=1 1 1 1 1 2 2 2 2 2\nid=1..5 join 2..6\nx=11..20\\2\nt=table(team, id, x)\nt;\n```\n\n| team | id | x   |\n| ---- | -- | --- |\n| 1    | 1  | 5.5 |\n| 1    | 2  | 6   |\n| 1    | 3  | 6.5 |\n| 1    | 4  | 7   |\n| 1    | 5  | 7.5 |\n| 2    | 2  | 8   |\n| 2    | 3  | 8.5 |\n| 2    | 4  | 9   |\n| 2    | 5  | 9.5 |\n| 2    | 6  | 10  |\n\n```\nselect * from t where rowNo(id)%3=0;\n```\n\n| team | id | x   |\n| ---- | -- | --- |\n| 1    | 1  | 5.5 |\n| 1    | 4  | 7   |\n| 2    | 3  | 8.5 |\n| 2    | 6  | 10  |\n\n```\nupdate t set teamFirst=(rowNo(id)==0) context by team;\nt;\n```\n\n| team | id | x   | teamFirst |\n| ---- | -- | --- | --------- |\n| 1    | 1  | 5.5 | 1         |\n| 1    | 2  | 6   | 0         |\n| 1    | 3  | 6.5 | 0         |\n| 1    | 4  | 7   | 0         |\n| 1    | 5  | 7.5 | 0         |\n| 2    | 2  | 8   | 1         |\n| 2    | 3  | 8.5 | 0         |\n| 2    | 4  | 9   | 0         |\n| 2    | 5  | 9.5 | 0         |\n| 2    | 6  | 10  | 0         |\n"
    },
    "rowOr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowOr.html",
        "signatures": [
            {
                "full": "rowOr(args...)",
                "name": "rowOr",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowOr](https://docs.dolphindb.cn/zh/funcs/r/rowOr.html)\n\n\n\n#### 语法\n\nrowOr(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行逻辑或操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([true false false, true true true, true true true])\nrowOr(m);\n// output\n[1,1,1]\n\nt1=table(false true true true false as x, false true false true true as y)\nrowOr(t1);\n\n0,1,1,1,1]]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect *  from t where rowOr(price1>30, price2>100);\n```\n\n| sym  | price1 | price2 |\n| ---- | ------ | ------ |\n| AAPL | 49.6   | 175.23 |\n| IBM  | 30.02  | 51.29  |\n| C    | 174.97 | 26.23  |\n\n相关函数：[or](https://docs.dolphindb.cn/zh/funcs/o/or.html)\n"
    },
    "rowPrev": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowPrev.html",
        "signatures": [
            {
                "full": "rowPrev(X)",
                "name": "rowPrev",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rowPrev](https://docs.dolphindb.cn/zh/funcs/r/rowPrev.html)\n\n\n\n#### 语法\n\nrowPrev(X)\n\n#### 详情\n\n逐行将 *X* 向右移动一个位置。\n\n#### 参数\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowPrev(m)\n```\n\n返回：\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n|      | 4.5  | 1.5  |\n|      | 2.6  | 4.8  |\n|      | 1.5  | 5.9  |\n\n```\na=array(INT[], 0, 10).append!([1 2 3, 4 5, 6 7 8]);\nrowPrev(a)\n\n//output: [[00i,1,2],[00i,4],[00i,6,7]]\n\ntp = [[1.3,2.5,2.3], [4.1,5.3,6.2]]\ntp.setColumnarTuple!()\nrowPrev(tp)\n\n//output: [[00F,1.3,2.5],[00F,4.1,5.3]]\n```\n"
    },
    "rowProd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowProd.html",
        "signatures": [
            {
                "full": "rowProd(args...)",
                "name": "rowProd",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowProd](https://docs.dolphindb.cn/zh/funcs/r/rowProd.html)\n\n\n\n#### 语法\n\nrowProd(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行元素求乘积操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowProd(m);\n// output\n[33.075,24.96,8.85]\n\nv1=1 0 2 -2 5\nv2=-8 1 2 4 2\nrowProd(v1, v2);\n// output\n[-8,0,4,-8,10]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect * from t where rowOr(price1>50, price2>50);\n```\n\n| sym  | price     |\n| ---- | --------- |\n| AAPL | 8691.408  |\n| MS   | 1495.3896 |\n| IBM  | 1485.4464 |\n| IBM  | 1539.7258 |\n| C    | 4589.4631 |\n\n相关函数：[prod](https://docs.dolphindb.cn/zh/funcs/p/prod.html)\n"
    },
    "rowRank": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowRank.html",
        "signatures": [
            {
                "full": "rowRank(X, [ascending=true], [groupNum], [ignoreNA=true], [tiesMethod='min'], [percent=false], [precision])",
                "name": "rowRank",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[groupNum]",
                        "name": "groupNum",
                        "optional": true
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='min']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'min'"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[precision]",
                        "name": "precision",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rowRank](https://docs.dolphindb.cn/zh/funcs/r/rowRank.html)\n\n\n\n#### 语法\n\nrowRank(X, \\[ascending=true], \\[groupNum], \\[ignoreNA=true], \\[tiesMethod='min'], \\[percent=false], \\[precision])\n\n#### 详情\n\n逐行计算 *X* 的元素排名或组排名，排名方式请参照 [rank](https://docs.dolphindb.cn/zh/funcs/r/rank.html)，返回一个和 *X* 维度相同的矩阵。\n\n#### 参数\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)。\n\n**ascending** 是一个布尔值，表示排序方向。true 表示升序，false 表示降序。默认值为 true。它是一个可选参数。\n\n**groupNum** 是一个正整数，表示排序形成的组的数量。它是一个可选参数。\n\n**ignoreNA** 是一个布尔值，表示是否忽略 NULL 值。true 表示忽略 NULL 值，false 表示 NULL 值参与排名。默认值为 true。它是一个可选参数。NULL 值参与排序时，NULL 值为最小值。\n\n**tiesMethod** 是一个字符串，表示如何对具有相同值的元素进行排名。\n\n* 'min'表示取最小排名。\n\n* 'max'表示取最大排名。\n\n* 'average'表示取排名的均值。\n\n* 'first' 表示按照原数据的顺序排名。\n\n**percent** 是一个布尔值，表示是否以百分比形式显示返回的排名。\n\n**precision** 是一个 \\[1, 15] 范围内的整数，用于设置参与排序的值的精度。若两个值之差的绝对值小于等于 10^(-precision) ，则认为两值相等。\n\n**Note:** 指定 *precision* 参数后，*X* 只能是数值型对象。且 *tiesMethod* 不能指定为 'first'。\n\n#### 例子\n\n```\nm=matrix(3 1 2 4 7 6 9 8 5, 9 NULL 2 3 5 6 3 2 8).transpose();\nm\n```\n\n返回：\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 3  | 1  | 2  | 4  | 7  | 6  | 9  | 8  | 5  |\n| 9  |    | 2  | 3  | 5  | 6  | 3  | 2  | 8  |\n\n```\nm.rowRank();\n```\n\n返回：\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 2  | 0  | 1  | 3  | 6  | 5  | 8  | 7  | 4  |\n| 7  |    | 0  | 2  | 4  | 5  | 2  | 0  | 6  |\n\n```\nm.rowRank(false);\n```\n\n返回：\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 6  | 8  | 7  | 5  | 2  | 3  | 0  | 1  | 4  |\n| 0  |    | 6  | 4  | 3  | 2  | 4  | 6  | 1  |\n\n```\nm.rowRank(groupNum=3);\n```\n\n返回：\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 0  | 0  | 0  | 1  | 2  | 1  | 2  | 2  | 1  |\n| 2  |    | 0  | 0  | 1  | 1  | 0  | 0  | 2  |\n\n```\nm.rowRank(ignoreNA=false);\n```\n\n返回：\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 2  | 0  | 1  | 3  | 6  | 5  | 8  | 7  | 4  |\n| 8  | 0  | 1  | 3  | 5  | 6  | 3  | 1  | 7  |\n\n```\nm.rowRank(ignoreNA=false, tiesMethod='max');\n```\n\n返回：\n\n| #0 | #1 | #2 | #3 | #4 | #5 | #6 | #7 | #8 |\n| -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| 2  | 0  | 1  | 3  | 6  | 5  | 8  | 7  | 4  |\n| 8  | 0  | 2  | 4  | 5  | 6  | 4  | 2  | 7  |\n\n```\nm.rowRank(ignoreNA=false, tiesMethod='first');\n```\n\n返回：\n\n| col1 | col2 | col3 | col4 | col5 | col6 | col7 | col8 | col9 |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 2    | 0    | 1    | 3    | 6    | 5    | 8    | 7    | 4    |\n| 8    | 0    | 1    | 3    | 5    | 6    | 4    | 2    | 7    |\n\n**Related information**\n\n[rowDenseRank](https://docs.dolphindb.cn/zh/funcs/r/rowDenseRank.html)\n\n[rank](https://docs.dolphindb.cn/zh/funcs/r/rank.html)\n"
    },
    "rows": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rows.html",
        "signatures": [
            {
                "full": "rows(X)",
                "name": "rows",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rows](https://docs.dolphindb.cn/zh/funcs/r/rows.html)\n\n\n\n#### 语法\n\nrows(X)\n\n#### 参数\n\n**X** 可以是向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 中的行数。参见相关函数： [cols](https://docs.dolphindb.cn/zh/funcs/c/cols.html)。\n\n#### 例子\n\n```\ny=1 2 3;\nrows(y);\n// output\n3\n// 一个向量可以被视为一个 n* 1 的矩阵\n\nx=1..6$2:3;\nX\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nrows X\n// output\n2\n\na=table(1..3 as x,`IBM`C`AAPL as y);\na\n```\n\n| x | y    |\n| - | ---- |\n| 1 | IBM  |\n| 2 | C    |\n| 3 | AAPL |\n\n```\nrows a;\n// output\n3\n```\n"
    },
    "rowSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowSize.html",
        "signatures": [
            {
                "full": "rowSize(args...)",
                "name": "rowSize",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowSize](https://docs.dolphindb.cn/zh/funcs/r/rowSize.html)\n\n\n\n#### 语法\n\nrowSize(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行元素统计（包含空值）操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]);\nrowSize(m);\n// output\n[3,3,3]\n\nt1=table(1 NULL 3 NULL 5 as x, 6..10 as y);\nt2=table(5 NULL 3 NULL 1 as a, 10..6 as b);\nrowSize(t1);\n// output\n[2,2,2,2,2]\n\nrowCount(t1[`x], t2, 1 NULL 2 NULL NULL);\n// output\n[4,1,4,1,3]\nrowSize(t1[`x], t2, 1 NULL 2 NULL NULL);\n// output\n[4,4,4,4,4]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, [49.6, NULL, 29.52, NULL, 174.97] as price1, [175.23, NULL, 50.32, 51.29, 26.23] as price2);\nselect sym,rowSize(price1,price2) as size from t;\n```\n\n输出返回：\n\n| sym  | size |\n| ---- | ---- |\n| AAPL | 2    |\n| MS   | 2    |\n| IBM  | 2    |\n| IBM  | 2    |\n| C    | 2    |\n\n相关函数：[rowCount](https://docs.dolphindb.cn/zh/funcs/r/rowCount.html), [size](https://docs.dolphindb.cn/zh/funcs/s/size.html)\n"
    },
    "rowSkew": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowSkew.html",
        "signatures": [
            {
                "full": "rowSkew(X, [biased=true])",
                "name": "rowSkew",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [rowSkew](https://docs.dolphindb.cn/zh/funcs/r/rowSkew.html)\n\n\n\n#### 语法\n\nrowSkew(X, \\[biased=true])\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否为有偏估计。默认值为 true，表示为有偏估计。\n\n#### 详情\n\n逐行计算 *X* 的斜度。\n\nDolphinDB 使用以下公式计算倾斜度（当 *biased*=true 时）：\n\n![skewx](https://docs.dolphindb.cn/zh/images/rowskewx.png)\n\n#### 例子\n\n```\nm = [4.5 2.6 1.5 1.5 4.8, 5.9 4.9 2.0 4.0 6.3, 2 2 2 2 2]\nrowSkew(m);\n// output\n[-0.329206341655613,0.586870565935934,-0.707106781186563,0.595170064139497,-0.350377619697706]\n\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL, 4.3 NULL 3.5]);\nrowSkew(m);\n// output\n[-1.064430070205901,0.577633692366209,0.110780117654846]\n\nt1=table(1..5 as x, 10..6 as y, take(3, 5) as z);\nrowSkew(t1);\n// output\n[0.567316577993729,0.652012117044047,0.707106781186548,0.528004979218188,-0.381801774160629]\n```\n\n相关函数：[skew](https://docs.dolphindb.cn/zh/funcs/s/skew.html)\n"
    },
    "rowStd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowStd.html",
        "signatures": [
            {
                "full": "rowStd(args...)",
                "name": "rowStd",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowStd](https://docs.dolphindb.cn/zh/funcs/r/rowStd.html)\n\n\n\n#### 语法\n\nrowStd(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行元素求样本标准差操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowStd(m);\n// output\n[1.858315,1.474223,3.11127]\n\nt1=table(1..5 as x, 10..6 as y, take(3, 5) as z)\nt2=table(5..1 as a, 6..10 as b, take(8, 5) as c);\n\nrowStd(t1);\n// output\n[4.725816,3.785939,2.886751,2.081666,1.527525]\n\nrowStd(t1[`x], t2, 1 1 2 2 2);\n// output\n[3.114482,3.04959,2.949576,3.316625,3.834058]\n\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect sym,rowStd(price1,price2) as std from t;\n```\n\n| sym  | std        |\n| ---- | ---------- |\n| AAPL | 88.833825  |\n| MS   | 15.061374  |\n| IBM  | 14.707821  |\n| IBM  | 15.040161  |\n| C    | 105.175063 |\n\n相关函数：[rowStdp](https://docs.dolphindb.cn/zh/funcs/r/rowStdp.html), [std](https://docs.dolphindb.cn/zh/funcs/s/std.html)\n"
    },
    "rowStdp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowStdp.html",
        "signatures": [
            {
                "full": "rowStdp(args...)",
                "name": "rowStdp",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowStdp](https://docs.dolphindb.cn/zh/funcs/r/rowStdp.html)\n\n\n\n#### 语法\n\nrowStdp(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行元素求总体标准差操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowStdp(m);\n// output\n[1.517307556898806,1.203698005684518,2.2]\n\nt1=table(1..5 as x, 10..6 as y, take(3, 5) as z)\nt2=table(5..1 as a, 6..10 as b, take(8, 5) as c);\nrowStdp(t1);\n// output\n[3.858612300930075,3.091206165165235,2.357022603955159,1.699673171197595,1.247219128924648]\n\nrowStdp(t1[`x], t2, 1 1 2 2 2);\n// output\n[2.785677655436824,2.727636339397171,2.638181191654584,2.966479394838265,3.42928563989645]\n\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect sym,rowStdp(price1,price2) as stdp from t;\n```\n\n| sym  | stdp   |\n| ---- | ------ |\n| AAPL | 62.815 |\n| MS   | 10.65  |\n| IBM  | 10.4   |\n| IBM  | 10.635 |\n| C    | 74.37  |\n\n相关函数：[rowStd](https://docs.dolphindb.cn/zh/funcs/r/rowStd.html), [std](https://docs.dolphindb.cn/zh/funcs/s/std.html)\n"
    },
    "rowSum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowSum.html",
        "signatures": [
            {
                "full": "rowSum(args...)",
                "name": "rowSum",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowSum](https://docs.dolphindb.cn/zh/funcs/r/rowSum.html)\n\n\n\n#### 语法\n\nrowSum(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行元素求和操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\nrowSum(m);\n// output\n[10.9,9.4,7.4]\n\nt1=table(1..5 as x, 6..10 as y)\nt2=table(5..1 as a, 10..6 as b);\n\nrowSum(t1);\n// output\n[7,9,11,13,15]\n\nrowSum(t1[`x], t2, 1 1 2 2 2);\n// output\n[17,16,16,15,14]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2)\nselect sym,rowSum(price1,price2) as priceSum from t;\n```\n\n| sym  | priceSum |\n| ---- | -------- |\n| AAPL | 224.83   |\n| MS   | 80.22    |\n| IBM  | 79.84    |\n| IBM  | 81.31    |\n| C    | 201.2    |\n\n相关函数：[sum](https://docs.dolphindb.cn/zh/funcs/s/sum.html)\n"
    },
    "rowSum2": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowSum2.html",
        "signatures": [
            {
                "full": "rowSum2(args...)",
                "name": "rowSum2",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowSum2](https://docs.dolphindb.cn/zh/funcs/r/rowSum2.html)\n\n\n\n#### 语法\n\nrowSum2(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行元素求平方和操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]);\nrowSum2(m);\n// output\n[46.51,33.8,37.06]\n\nt1=table(1..5 as x, 6..10 as y);\nt2=table(5..1 as a, 10..6 as b);\n\nrowSum2(t1);\n// output\n[37,53,73,97,125]\n\nrowSum2(t1[`x], t2, 1 1 2 2 2);\n// output\n[127,102,86,73,66]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect sym,rowSum2(price1,price2) as price2Sum from t;\n```\n\n| sym  | priceSum |\n| ---- | -------- |\n| AAPL | 224.83   |\n| MS   | 80.22    |\n| IBM  | 79.84    |\n| IBM  | 81.31    |\n| C    | 201.2    |\n\n相关函数：[sum2](https://docs.dolphindb.cn/zh/funcs/s/sum2.html)\n"
    },
    "rowTanimoto": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowTanimoto.html",
        "signatures": [
            {
                "full": "rowTanimoto(X, Y)",
                "name": "rowTanimoto",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowTanimoto](https://docs.dolphindb.cn/zh/funcs/r/rowTanimoto.html)\n\n\n\n#### 语法\n\nrowTanimoto(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是长度相同的数值型向量或数组向量，或维度相同的矩阵。若 *X* 和 *Y* 为数组向量，它们对应位置的向量必须具有相同长度。\n\n#### 详情\n\n若 *X* 和 *Y* 同时为向量/矩阵，按行计算 *X* 和 *Y* 之间的谷本距离。若 *X* 和 *Y* 同时为索引矩阵，会对齐标签，对标签相同的行进行计算，标签不同的行直接返回 NULL。\n\n若 *X* 和 *Y* 一个为向量，一个为矩阵，则向量的长度必须与矩阵的列数相同，计算向量与矩阵每一行的谷本距离。\n\n若 *X* 和 *Y* 是数组向量，计算 *X* 和 *Y* 对应位置的向量之间的谷本距离，即 tanimoto(X.row(i),Y.row(i))。\n\n若 *X* 和 *Y* 一个为向量，一个为数组向量，计算向量与数组向量内每个向量的谷本距离。两个向量的长度相同时返回计算结果，长度不相同时返回 NULL。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nrowTanimoto(3.6 5.2 6.3, 8.6 4.8 5.5)\n// output\n[0.4467,0.0064,0.0181]\n\na=array(INT[],0,10)\na.append!([[1, 8, 9],[15, NULL], [25, 22, 13, 15]])\nb=array(INT[],0,10)\nb.append!([[11, 18, 6],[5, 9], [5, 2, 3, 1]])\nrowTanimoto(a,b)\n// output\n[0.5,0.5714,0.8309]\n\ns1=indexedSeries(2020.01.01..2020.01.03, 10.4 11.2 9)\ns2=indexedSeries(2020.01.01 2020.01.03 2020.01.04, 23.5 31.2 26)\nrowTanimoto(s1,s2)\n// output\n[0.4125,0.5337,0.5526]\n\nm=matrix(23 56 47, 112 94 59)\nm1=matrix(11 15 89, 52 41 63)\nrowTanimoto(m,m1)\n// output\n[0.3812,0.4889,0.1839]\n\nm.rename!(2020.01.01..2020.01.03, `A`B)\nm.setIndexedMatrix!()\nm1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\nm1.setIndexedMatrix!()\nrowTanimoto(m,m1)\n// output\n[0.3812,NULL,0.3014,NULL]\n```\n\n相关函数：[tanimoto](https://docs.dolphindb.cn/zh/funcs/t/tanimoto.html)\n"
    },
    "rowVar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowVar.html",
        "signatures": [
            {
                "full": "rowVar(args...)",
                "name": "rowVar",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowVar](https://docs.dolphindb.cn/zh/funcs/r/rowVar.html)\n\n\n\n#### 语法\n\nrowVar(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行元素求样本方差操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]);\nrowVar(m);\n// output\n[3.453333,2.173333,9.68]\n\nt1=table(1..5 as x, 10..6 as y, take(3, 5) as z);\nt2=table(5..1 as a, 6..10 as b, take(8, 5) as c);\n\nrowVar(t1);\n// output\n[22.333333,14.333333,8.333333,4.333333,2.333333]\n\nrowVar(t1[`x], t2, 1 1 2 2 2);\n// output\n[9.7,9.3,8.7,11,14.7]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect sym,rowVar(price1,price2) as var from t;\n```\n\n| sym  | var        |\n| ---- | ---------- |\n| AAPL | 7891.44845 |\n| MS   | 226.845    |\n| IBM  | 216.32     |\n| IBM  | 226.20645  |\n| C    | 11061.7938 |\n\n相关函数：[rowVarp](https://docs.dolphindb.cn/zh/funcs/r/rowVarp.html), [varp](https://docs.dolphindb.cn/zh/funcs/v/varp.html)\n"
    },
    "rowVarp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowVarp.html",
        "signatures": [
            {
                "full": "rowVarp(args...)",
                "name": "rowVarp",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowVarp](https://docs.dolphindb.cn/zh/funcs/r/rowVarp.html)\n\n\n\n#### 语法\n\nrowVarp(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行元素求总体方差操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]);\nrowVarp(m);\n// output\n[2.302222222222225,1.448888888888887,4.84]\n\nt1=table(1..5 as x, 10..6 as y, take(3, 5) as z);\nt2=table(5..1 as a, 6..10 as b, take(8, 5) as c);\nrowVarp(t1);\n// output\n[14.888888888888891,9.555555555555557,5.555555555555558,2.888888888888891,1.555555555555557]\n\nrowVarp(t1[`x], t2, 1 1 2 2 2);\n// output\n[7.76,7.440000000000001,6.96,8.8,11.760000000000001]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect sym,rowVarp(price1,price2) as varp from t;\n```\n\n| sym  | varp      |\n| ---- | --------- |\n| AAPL | 3945.7242 |\n| MS   | 113.4225  |\n| IBM  | 108.16    |\n| IBM  | 113.1032  |\n| C    | 5530.8969 |\n\n相关函数：[rowVar](https://docs.dolphindb.cn/zh/funcs/r/rowVar.html), [varp](https://docs.dolphindb.cn/zh/funcs/v/varp.html)\n"
    },
    "rowWavg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowWavg.html",
        "signatures": [
            {
                "full": "rowWavg(X, Y)",
                "name": "rowWavg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowWavg](https://docs.dolphindb.cn/zh/funcs/r/rowWavg.html)\n\n\n\n#### 语法\n\nrowWavg(X, Y)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行计算 *X* 以 *Y* 为权重的加权平均，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm1=matrix(2 -1 4, 8 3 2, 9 0 1)\nm2=matrix(8 11 10, 8 17 4, 14 6 4)\nrowWavg(m1, m2)\n// output\n[6.8667, 1.1765, 2.8889]\n\nm3=matrix(2 NULL 4, 8 NULL 2, 9 NULL NULL)\nrowWavg(m3, m2)\n// output\n[6.8667, , 3.4286]\n\na= -10 12.3 -10 -8\nb= 17.9 9 7.5 -4\nc= 5.5 5.5 -7 8\n\nrowWavg(matrix(a, b, c), matrix(b, a, c))\n// output\n[-24.459, 9.3899, 10.6316, -32]\n\nx=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[a, b, c\\]\\)\ny=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[b, a, c\\]\\)\nrowWavg\\(x, y\\)\n// output\n\\[-3.6612, 7.0892, 14.4583\\]\n```\n\n相关函数：[wavg](https://docs.dolphindb.cn/zh/funcs/w/wavg.html)\n"
    },
    "rowWsum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowWsum.html",
        "signatures": [
            {
                "full": "rowWsum(X, Y)",
                "name": "rowWsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [rowWsum](https://docs.dolphindb.cn/zh/funcs/r/rowWsum.html)\n\n\n\n#### 语法\n\nrowWsum(X, Y)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行计算 *X* 和 *Y* 的内积，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm1=matrix(2 -1 4, 8 3 2, 9 0 1)\nm2=matrix(8 11 10, 8 17 4, 14 6 4)\nrowWsum(m1, m2)\n// output\n[206, 40, 52]\n\nm3=matrix(8 NULL 10, 8 NULL 4, 14 NULL NULL)\nrowWsum(m1, m3)\n// output\n[206, , 48]\n\na= -10 12.3 4 -8\nb= 17.9 9 7.5 -4\nc= 5.5 6.4 -7 8\nx=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[a, b, c\\]\\)\ny=array\\(DOUBLE\\[\\],0, 10\\).append!\\(\\[b, a, c\\]\\)\n\nrowWsum\\(x, y\\)\n// output\n\\[0.63, -6.3 , 184.21\\]\n```\n\n相关函数：[wsum](https://docs.dolphindb.cn/zh/funcs/w/wsum.html)\n"
    },
    "rowXor": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rowXor.html",
        "signatures": [
            {
                "full": "rowXor(args...)",
                "name": "rowXor",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [rowXor](https://docs.dolphindb.cn/zh/funcs/r/rowXor.html)\n\n\n\n#### 语法\n\nrowXor(args...)\n\nrow 系列函数通用参数说明和计算规则请参考：[rowFunctions](https://docs.dolphindb.cn/zh/funcs/themes/rowFunctions.html)\n\n#### 详情\n\n逐行进行逻辑异或操作，返回一个长度与输入参数行数相同的向量。\n\n#### 例子\n\n```\nm=matrix([true false false, true true true, true true true]);\nrowXor(m);\n// output\n[1,0,0]\n\nt=table(true false false true false true as x, false true false true false true as y, false false true true false false as z);\nt;\n```\n\n| x  | y  | z  |\n| :- | :- | :- |\n| 1  | 0  | 0  |\n| 0  | 1  | 0  |\n| 0  | 0  | 1  |\n| 1  | 1  | 1  |\n| 0  | 0  | 0  |\n| 1  | 1  | 0  |\n\n```\nrowXor(t);\n// output\n[1,1,1,1,0,0]\n\nt=table(`AAPL`MS`IBM`IBM`C as sym, 49.6 29.46 29.52 30.02 174.97 as price1, 175.23 50.76 50.32 51.29 26.23 as price2);\nselect * from t where rowXor(price1$ 30, price2$ 50);\n```\n\n| sym | price1 | price2 |\n| --- | ------ | ------ |\n| MS  | 29.46  | 50.76  |\n| IBM | 29.52  | 50.32  |\n| C   | 174.97 | 26.23  |\n\n相关函数：[xor](https://docs.dolphindb.cn/zh/funcs/x/xor.html)\n"
    },
    "rpad": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rpad.html",
        "signatures": [
            {
                "full": "rpad(str, length, [pattern])",
                "name": "rpad",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "length",
                        "name": "length"
                    },
                    {
                        "full": "[pattern]",
                        "name": "pattern",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [rpad](https://docs.dolphindb.cn/zh/funcs/r/rpad.html)\n\n\n\n#### 语法\n\nrpad(str, length, \\[pattern])\n\n#### 参数\n\n**str** 是一个字符串或字符串向量。它表示目标字符串。\n\n**length** 是一个非负整数。它表示返回字符串的长度。如果 *length* 小于 *str* 的长度，`rpad` 会把 *str* 截断成长度为 *length* 的字符串。\n\n**pattern** 是一个填充字符串。它是一个可选参数。如果没有指定，则在 *str* 的右边填充空格。\n\n#### 详情\n\n在字符串的右边填充特定字符串。\n\n#### 例子\n\n```\nrpad(\"Hello\",2);\n// output\nHe\n\nrpad(`Hello, 10);\n// output\nHello\n\nrpad(`Hello, 12, `0);\n// output\nHello0000000\n```\n"
    },
    "rpc": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rpc.html",
        "signatures": [
            {
                "full": "rpc(nodeAlias, func, args, ...)",
                "name": "rpc",
                "parameters": [
                    {
                        "full": "nodeAlias",
                        "name": "nodeAlias"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "args",
                        "name": "args"
                    },
                    {
                        "full": "...",
                        "name": "..."
                    }
                ]
            }
        ],
        "markdown": "### [rpc](https://docs.dolphindb.cn/zh/funcs/r/rpc.html)\n\n\n\n#### 语法\n\nrpc(nodeAlias, func, args, ...)\n\n#### 参数\n\n**nodeAlias** 是远程节点的别名。\n\n**func** 是函数，它不能被引用。这个函数可以是内置函数或调用节点上的用户自定义函数。\n\n**args** 是函数的参数。\n\n#### 详情\n\n在指定的远程节点上调用本地函数，并把结果返回到本地节点。这个函数可以是内置函数或调用节点上的用户自定义函数。函数的参数暂不支持值为函数定义的字典。\n\n调用节点和远程节点必须在同一集群。否则，我们需要使用 [remoteRun](https://docs.dolphindb.cn/zh/funcs/r/remoteRun.html) 函数。详情请参考 [BatchJobManagement](https://docs.dolphindb.cn/zh/sys_man/BatchJobManagement.html)。\n\n#### 例子\n\n* 远程调用用户定义函数\n\n  ```\n  rpc(\"nodeA\", def(x,y):x+y, 10, 15)\n  ```\n\n* 远程调用部分应用\n\n  ```\n  rpc(\"nodeA\", getRecentJobs{10})\n  ```\n\n* 远程调用引用了用户定义函数的内置函数\n\n  ```\n  def jobDemo(n){\n      s = 0\n      for (x in 1 : n) {\n         s += sum(sin rand(1.0, 100000000)-0.5)\n             print(\"iteration \" + x + \" \" + s)\n      }\n      return s\n  };\n  // the node \"DFS_NODE2\" is located in the same cluster as the local node.\n  rpc(\"DFS_NODE2\", submitJob, \"jobDemo3\", \"job demo\", jobDemo, 10);\n  // output: \n  jobDemo3\n\n  rpc(\"DFS_NODE2\", getJobReturn, \"jobDemo3\")\n  // output: \n  -3426.577521\n  ```\n"
    },
    "rshift": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rshift.html",
        "signatures": [
            {
                "full": "rshift(X, a)",
                "name": "rshift",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "a",
                        "name": "a"
                    }
                ]
            }
        ],
        "markdown": "### [rshift](https://docs.dolphindb.cn/zh/funcs/r/rshift.html)\n\n\n\n#### 语法\n\nrshift(X, a) 或 X>>a\n\n#### 参数\n\n**X** 可以是标量、数据对、向量或矩阵\n\n**a** 是移动的位数。\n\n#### 详情\n\n`rshift` 将参数按位右移。\n\n#### 例子\n\n```\nrshift(2048, 2);\n// output\n512\n\n 1..10 >> 1;\n// output\n[0,1,1,2,2,3,3,4,4,5]\n\n1:10>>1;\n// output\n0 : 5\n```\n\n相关函数：[lshift](https://docs.dolphindb.cn/zh/funcs/l/lshift.html)\n"
    },
    "rtrim": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/rtrim.html",
        "signatures": [
            {
                "full": "rtrim(X)",
                "name": "rtrim",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [rtrim](https://docs.dolphindb.cn/zh/funcs/r/rtrim.html)\n\n\n\n#### 语法\n\nrtrim(X)\n\n#### 参数\n\n**X** 是一个字符串或字符串向量。\n\n#### 详情\n\n删除字符串或字符串向量的每个元素右边的空格。\n\n#### 例子\n\n```\nrtrim(\"I love      \")+\" \"+ltrim(\"    this game!\");\n// output\nI love this game!\n```\n"
    },
    "run": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/run.html",
        "signatures": [
            {
                "full": "run(scriptFile, [newSession=false], [clean=true])",
                "name": "run",
                "parameters": [
                    {
                        "full": "scriptFile",
                        "name": "scriptFile"
                    },
                    {
                        "full": "[newSession=false]",
                        "name": "newSession",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[clean=true]",
                        "name": "clean",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [run](https://docs.dolphindb.cn/zh/funcs/r/run.html)\n\n\n\n#### 语法\n\nrun(scriptFile, \\[newSession=false], \\[clean=true])\n\n#### 参数\n\n**scriptFile** 是服务器端的脚本所在路径。\n\n**newSession** 是否新开一个 session 运行脚本。\n\n**clean** 是否清理当前 session 中的变量。默认为 true，即 `run` 运行后会清除变量。\n\n#### 详情\n\n执行一个已经保存的程序文件。该命令必须要用户登录后才能执行。\n\n如果设置 *newSession* = false，程序文件在当前 session 中运行。如果设置 *newSession* = true，程序文件在新开的 session 中运行。运行结束，关闭该 session。\n\n#### 例子\n\n```\nrun \"/home/DolphinDB/test.script\";\nd = dict(STRING, ANY)\nd[\"TradePrice\"] = 1..1000\n// clean参数设置为 false，当前 session 中定义的变量 d 不会被清除。\nrun(\"/home/DolphinDB/test.script\", clean=false)\nparseExpr(\"avg(TradePrice)\",d).eval()\n// output\n500.5\n```\n"
    },
    "runScript": {
        "url": "https://docs.dolphindb.cn/zh/funcs/r/runScript.html",
        "signatures": [
            {
                "full": "runScript(script)",
                "name": "runScript",
                "parameters": [
                    {
                        "full": "script",
                        "name": "script"
                    }
                ]
            }
        ],
        "markdown": "### [runScript](https://docs.dolphindb.cn/zh/funcs/r/runScript.html)\n\n\n\n#### 语法\n\nrunScript(script)\n\n#### 参数\n\n**script** 是字符串，表示需要执行的脚本。\n\n#### 详情\n\n本地执行一段脚本。该命令必须要用户登录后才能执行。\n\n#### 例子\n\n```\nt = table(1..100 as id,201..300 as val1)\nscript1 = 'dn = \"dfs://test\";if(existsDatabase(dn)){dropDatabase(dn)};db = database(dn,VALUE,1..10);pt = db.createPartitionedTable(t,`pt,`id).append!(t)'\nscript2 = 'select * from loadTable(\"dfs://test\",`pt)'\nrunScript(script1)\nrunScript(script2)\n```\n"
    },
    "saveAsNpy": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/saveAsNpy.html",
        "signatures": [
            {
                "full": "saveAsNpy(obj, fileName)",
                "name": "saveAsNpy",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "fileName",
                        "name": "fileName"
                    }
                ]
            }
        ],
        "markdown": "### [saveAsNpy](https://docs.dolphindb.cn/zh/funcs/s/saveAsNpy.html)\n\n\n\n#### 语法\n\nsaveAsNpy(obj, fileName)\n\n#### 参数\n\n**obj** 是一个数值向量或矩阵。\n\n**fileName** 是服务器端输出文件的绝对路径或相对路径。\n\n#### 详情\n\n将一个 DolphinDB 向量或矩阵保存为 Python Numpy 支持的 npy 格式的二进制文件。该函数必须要用户登录后才能执行。\n\n如果 DOUBLE 类型的向量或矩阵中包含 NULL 值，那么 NULL 值会被转换成 Python Numpy DOUBLE 类型的 NaN；如果其他类型的向量或矩阵中包含 NULL 值，那么 NULL 值会被转换成 Python Numpy FLOAT 类型的 NaN。\n\n#### 例子\n\n```\nv = 1..1000\nv.saveAsNpy(\"/home/DolphinDB/intVec.npy\")\n\nm = (1..1000 + 0.5)$20:50\nm.saveAsNpy(\"/home/DolphinDB/doubleMat.npy\")\n```\n\n在 Python 中加载保存的文件。\n\n```\nimport numpy as np\nv = np.load(\"/home/DolphinDB/intVec.npy\")\nm = np.load(\"/home/DolphinDB/doubleMat.npy\")\n```\n\n**Related information**\n\n[loadNpy](https://docs.dolphindb.cn/zh/funcs/l/loadNpy.html)\n"
    },
    "saveDatabase": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/saveDatabase.html",
        "signatures": [
            {
                "full": "saveDatabase(dbHandle)",
                "name": "saveDatabase",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    }
                ]
            }
        ],
        "markdown": "### [saveDatabase](https://docs.dolphindb.cn/zh/funcs/s/saveDatabase.html)\n\n\n\n#### 语法\n\nsaveDatabase(dbHandle)\n\n#### 参数\n\n**dbHandle** 是 DolphinDB 数据库句柄。\n\n#### 详情\n\n保存数据库句柄。该命令必须要用户登录后才能执行。这个命令和 [database](https://docs.dolphindb.cn/zh/funcs/d/database.html) 函数配合使用。\n\n第一次创建数据库之后，我们需要用 `saveDatabase` 命令保存数据库。如果数据库位于一个已经包含了 DolphinDB 表相关文件的目录下，函数 `database` 会重新打开之前创建的数据库，且不需要用 `saveDatabase` 命令保存。\n\n#### 例子\n\n```\ndb=database(\"C:/DolphinDB/\")\nsaveDatabase(db);\n```\n"
    },
    "saveDualPartition": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/saveDualPartition.html",
        "signatures": [
            {
                "full": "saveDualPartition(dbHandle1, dbHandle2, table, tableName, partitionColumn1, partitionColumn2, [compression=false])",
                "name": "saveDualPartition",
                "parameters": [
                    {
                        "full": "dbHandle1",
                        "name": "dbHandle1"
                    },
                    {
                        "full": "dbHandle2",
                        "name": "dbHandle2"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "partitionColumn1",
                        "name": "partitionColumn1"
                    },
                    {
                        "full": "partitionColumn2",
                        "name": "partitionColumn2"
                    },
                    {
                        "full": "[compression=false]",
                        "name": "compression",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [saveDualPartition](https://docs.dolphindb.cn/zh/funcs/s/saveDualPartition.html)\n\n\n\n#### 语法\n\nsaveDualPartition(dbHandle1, dbHandle2, table, tableName, partitionColumn1, partitionColumn2, \\[compression=false])\n\n#### 参数\n\n**dbHandle1** 是第一级分区的数据库句柄。\n\n**dbHandle2** 是第二级分区的数据库句柄。\n\n**table** 是要保存的内存中的表。\n\n**tableName** 是表示保存的分区表的名称的字符串。\n\n**partitionColumn1** 是表示第一级分区的分区列的字符串。\n\n**partitionColumn2** 是表示第二级分区的分区列的字符串。\n\n**compression** 是一个布尔变量。它表示是否压缩表。当它设置为 true 时，表将被压缩保存到磁盘。默认设置为 false（不压缩）。\n\n#### 详情\n\n在共享表前，将一张表保存为组合分区。该命令必须要用户登录后才能执行。\n\n它通常与 [share](https://docs.dolphindb.cn/zh/progr/statements/share.html) 一起使用。如果分区和表已经存在，该函数会把新数据追加到已有表格。\n\n#### 例子\n\n```\nn=1000000\nID=rand(10, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(1.0, n)\nt=table(ID, date, x);\n\nhdb = database(\"C:/DolphinDB/Data/dualDB\", RANGE,  0 5 10)\nvdb = database(, VALUE, dates)\nsaveDualPartition(hdb, vdb, t, `tDualPartition, `ID, `date)\n```\n"
    },
    "saveModel": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/saveModel.html",
        "signatures": [
            {
                "full": "saveModel(model, location)",
                "name": "saveModel",
                "parameters": [
                    {
                        "full": "model",
                        "name": "model"
                    },
                    {
                        "full": "location",
                        "name": "location"
                    }
                ]
            }
        ],
        "markdown": "### [saveModel](https://docs.dolphindb.cn/zh/funcs/s/saveModel.html)\n\n\n\n#### 语法\n\nsaveModel(model, location)\n\n#### 参数\n\n**model** 需要保存的模型，一般是字典，由 [randomForestClassifier](https://docs.dolphindb.cn/zh/funcs/r/randomForestClassifier.html), [randomForestRegressor](https://docs.dolphindb.cn/zh/funcs/r/randomForestRegressor.html) 等机器学习函数生成。\n\n**location** 字符串，表示服务器端输出文件的绝对路径或相对路径。\n\n#### 详情\n\n把模型保存到本地文件中，返回表示保存结果的布尔值。\n\n#### 例子\n\n```\nx1 = rand(100.0, 100)\nx2 = rand(100.0, 100)\nb0 = 6\nb1 = 1\nb2 = -2\nerr = norm(0, 10, 100)\ny = b0 + b1 * x1 + b2 * x2 + err\nt = table(x1, x2, y)\nmodel = randomForestRegressor(sqlDS(<select * from t>), `y, `x1`x2)\nsaveModel(model, \"/home/DolphinDB/Data/regressionModel.txt\");\n```\n"
    },
    "saveModule": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/saveModule.html",
        "signatures": [
            {
                "full": "saveModule(name, [moduleDir], [overwrite=false])",
                "name": "saveModule",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "[moduleDir]",
                        "name": "moduleDir",
                        "optional": true
                    },
                    {
                        "full": "[overwrite=false]",
                        "name": "overwrite",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [saveModule](https://docs.dolphindb.cn/zh/funcs/s/saveModule.html)\n\n\n\n#### 语法\n\nsaveModule(name, \\[moduleDir], \\[overwrite=false])\n\n#### 参数\n\n**name** 是一个字符串，表示模块的名称。\n\n**moduleDir** 是一个字符串，表示模块 dos 文件所在的目录。\n\n**overwrite** 是一个布尔值，表示是否覆盖已有的模块 dom 文件。\n\n#### 详情\n\n将模块序列化成扩展名为 dom 的二进制文件，可以增加代码的保密性和安全性。该函数必须要用户登录后才能执行。\n\n如果没有指定 *moduleDir*，默认是相对目录 modules。系统搜寻相对目录 modules 的顺序如下：先到节点的 home 目录寻找，再到节点的工作目录寻找，最后到 DolphinDB 可执行文件所在目录寻找。请注意，单节点模式下，这三个目录默认为同一目录。\n\n#### 例子\n\n假设节点 home 目录下的 modules 目录中包含了 ta.dos 以及 system/log/fileLog.dos 模块文件，将它们序列化为二进制文件。\n\n```\nsaveModule(\"ta\");\n\nsaveModule(\"system::log::fileLog\");\n```\n\n相关函数：[loadModule](https://docs.dolphindb.cn/zh/funcs/l/loadModule.html)\n"
    },
    "savePartition": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/savePartition.html",
        "signatures": [
            {
                "full": "savePartition(dbHandle, table, tableName, [compression=true])",
                "name": "savePartition",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[compression=true]",
                        "name": "compression",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [savePartition](https://docs.dolphindb.cn/zh/funcs/s/savePartition.html)\n\n\n\n#### 语法\n\nsavePartition(dbHandle, table, tableName, \\[compression=true])\n\n#### 参数\n\n**dbHandle** 是一个 DolphinDB 数据库句柄。\n\n**table** 是将要保存的内存中的表。\n\n**tableName** 是表示保存的分区表名称的字符串。\n\n**compression** 是否压缩数据。默认的设置是 true。\n\n#### 详情\n\n把一张表保存为分布式数据库中的分区表。该命令必须要用户登录后才能执行。\n\n在用 *savePartition* 保存之前，要用 [createPartitionedTable](https://docs.dolphindb.cn/zh/funcs/c/createPartitionedTable.html) 先创建空的分区表。\n\n#### 例子\n\n```\nn=1000000\nID=rand(10, n)\nvalue=rand(1.0, n)\nt=table(ID, value);\n\ndb=database(\"dfs://rangedb_Trades\", RANGE,  0 5 10)\nTrades = db.createPartitionedTable(t, \"Trades\", \"ID\");\nsavePartition(db, t, `Trades)\n\nTrades=loadTable(db, `Trades)\nselect count(value) from Trades;\n// output\n1,000,000\n```\n\n在上述例子中，数据库 db 有两个分区：\\[0,5)和\\[5,10)。表t被保存为一个分区表 Trades，它包含数据库 db 中的分区列。\n\n我们可以在表 Trades 中追加另一个表：\n\n```\nn=500000\nID=rand(10, n)\nvalue=rand(1.0, n)\nt1=table(ID, value);\nsavePartition(db, t1, `Trades)\nTrades=loadTable(db, `Trades)\nselect count(value) from Trades;\n// output\n1,500,000\n```\n"
    },
    "saveTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/saveTable.html",
        "signatures": [
            {
                "full": "saveTable(dbHandle, table, [tableName], [append=false], [compression=false])",
                "name": "saveTable",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "[tableName]",
                        "name": "tableName",
                        "optional": true
                    },
                    {
                        "full": "[append=false]",
                        "name": "append",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[compression=false]",
                        "name": "compression",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [saveTable](https://docs.dolphindb.cn/zh/funcs/s/saveTable.html)\n\n\n\n#### 语法\n\nsaveTable(dbHandle, table, \\[tableName], \\[append=false], \\[compression=false])\n\n#### 参数\n\n**dbHandle** 是一个未分区的数据库的句柄。\n\n**table** 是将要被保存的内存中的表。\n\n**tableName** 是要保存的表的名称。如果没有指定，将会与内存中的表的名称相同。它需要用反引号(\\`)或双引号引用。\n\n**appending** 设置了追加模式。当它为 true 时，新的表会被追加到旧的表之后。默认的设置是 false。\n\n**compression** 设置压缩模式。当它为 true 时，表会以压缩模式保存到磁盘中。默认的设置是 false。\n\n#### 详情\n\n将一个表保存在未分区的本地磁盘表中。该命令必须要用户登录后才能执行。\n\n如果要把表保存至分区数据库中，需要先使用 `createPartitionedTable` 函数创建分区表，再使用 `append!` 函数或 `tableInsert` 函数把数据保存至分区表中。\n\n**Note:**\n\n磁盘表仅应用于备份数据和本地计算的场景，其相较于分布式表，在使用上具有一定局限，例如不能进行权限控制等。\n\n#### 例子\n\n```\ndb=database(\"C:/DolphinDB/Data/db1\")\nt=table(take(1..10,10000000) as id, rand(10,10000000) as x, rand(10.0,10000000) as y);\n```\n\n把表 t 保存为本地磁盘表：\n\n```\nsaveTable(db, t);\n```\n\n指定 *tableName*：\n\n```\nsaveTable(db, t, `t1);\n```\n\n指定 *tableName*，并把 *appending* 设置为 true：\n\n```\nsaveTable(db, t, `t2, 1);\n```\n\n指定 *tableName*，并把 *compression* 设置为 true：\n\n```\nsaveTable(db, t, `t3, 0, 1);\n```\n"
    },
    "saveText": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/saveText.html",
        "signatures": [
            {
                "full": "saveText(obj, filename, [delimiter=','], [append=false], [header=true], [bom=''])",
                "name": "saveText",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[delimiter='",
                        "name": "[delimiter='"
                    },
                    {
                        "full": "']",
                        "name": "']"
                    },
                    {
                        "full": "[append=false]",
                        "name": "append",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[header=true]",
                        "name": "header",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[bom='']",
                        "name": "bom",
                        "optional": true,
                        "default": "''"
                    }
                ]
            }
        ],
        "markdown": "### [saveText](https://docs.dolphindb.cn/zh/funcs/s/saveText.html)\n\n\n\n#### 语法\n\nsaveText(obj, filename, \\[delimiter=','], \\[append=false], \\[header=true], \\[bom=''])\n\n#### 参数\n\n**obj** 可以是表、矩阵、向量或 SQL 元代码。*obj* 取 SQL 元代码时，系统将分配多个线程并发读取数据，并通过独立的写线程将数据写入文件。否则，数据查询和写入将由当前 worker 处理。\n\n**filename** 是在服务器端输出文件的绝对路径或相对路径。不支持指定保存文件的格式，目前仅支持保存为 CSV 格式的文本。\n\n**delimiter** 是表中的列分隔符。系统的默认分隔符是逗号(,)。\n\n**append** 是一个布尔值，表示输出文件能够被追加。默认值为 false。\n\n**header** 是一个布尔值，表示 *obj* 为数据表时，是否在文件中保留列名。默认值为 true。\n\n**Note:** 向已存在的非空文件中追加数据（即 *append* = true 时），该参数将失效。\n\n**bom** 字符串标量（大小写不敏感），表示是否输出 BOM 头格式。目前仅支持”UTF-8“。默认为空，表示不输出 BOM 头。若用户需要用 Excel 打开导出的 CSV 文件（且数据包含中文），建议传入”UTF-8“，否则可能出现乱码。\n\n#### 详情\n\n将 DolphinDB 变量或 SQL 读取的数据存为磁盘上的文本文件。与 [saveTable](https://docs.dolphindb.cn/zh/funcs/s/saveTable.html) 命令相比，`saveText` 需要更多的磁盘空间且耗时更久。\n\n#### 例子\n\n例1.\n\n```\nn=20000000\nsyms=`IBM`C`MS`MSFT`JPM`ORCL`GE`EBAY`GOOG`FORD`GS\ntimestamp=09:30:00+rand(18000,n)\nsym=rand(syms,n)\nqty=100*(1+rand(100,n))\nprice=5.0+rand(100.0,n)\nt1=table(timestamp,sym,qty,price);\n\ntimer saveText(t1, \"/home/DolphinDB/trades.txt\");\n// output\nTime elapsed: 191488 ms\n```\n\n例2.\n\n```\nn=100\nt1=table(1..n as id, rand(1000, n) as x)\nsaveText(t1, \"/home/DolphinDB/t.csv\",,1)\nt2=table((n+1)..(2*n) as id, rand(1000, n) as x)\nsaveText(t2, \"/home/DolphinDB/t.csv\",,1)\nt = loadText(\"/home/DolphinDB/t.csv\")\nselect count(*) from t;\n// output\n200\n```\n\n例3. 将分布式表的数据存储为文本文件。\n\n```\nif(existsDatabase(\"dfs://testdb\")){\n  dropDatabase(\"dfs://testdb\")\n}\nn=3000\nticker = rand(`MSFT`GOOG`FB`ORCL`IBM`PPT`AZH`ILM`ANZ,n);\nid = rand(`A`B`C, n)\nx=rand(1.0, n)\nt=table(ticker, id, x)\ndb=database(directory=\"dfs://testdb\", partitionType=HASH, partitionScheme=[STRING, 5])\npt = db.createPartitionedTable(t, `pt, `ticker)\npt.append!(t)\n\nsaveText(<select * from pt>, \"/home/DolphinDB/pt.txt\")\n```\n"
    },
    "saveTextFile": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/saveTextFile.html",
        "signatures": [
            {
                "full": "saveTextFile(content, filename, [append=false], [lastModified])",
                "name": "saveTextFile",
                "parameters": [
                    {
                        "full": "content",
                        "name": "content"
                    },
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "[append=false]",
                        "name": "append",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[lastModified]",
                        "name": "lastModified",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [saveTextFile](https://docs.dolphindb.cn/zh/funcs/s/saveTextFile.html)\n\n\n\n#### 语法\n\nsaveTextFile(content, filename, \\[append=false], \\[lastModified])\n\n#### 参数\n\n**content** 是要写入文件的内容。\n\n**filename** 是要保存的文件名。仅支持 CSV 格式的文件。若传入其他格式文件，则无法保证数据准确性。\n\n**append** 是一个布尔值。True 表示追加，False表示覆盖。\n\n**lastModified** 是最后修改的时间，显示的是1970年1月1日零时开始的秒数。\n\n#### 详情\n\n通过追加或覆盖将字符串保存到文件中。该函数必须要用户登录后才能执行。\n\n#### 例子\n\n```\nsaveTextFile(\"1234567890\\n0987654321\\nabcdefghijk\\n\", \"/home/test/abc.txt\", false, 1495762562671l);\n\n// output\n[content of file \"/home/test/abc.txt\"]\n1234567890\n0987654321\nabcdefghijk\n```\n"
    },
    "scheduleJob": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/scheduleJob.html",
        "signatures": [
            {
                "full": "scheduleJob(jobId, jobDesc, jobFunc, scheduleTime, startDate, endDate, frequency, [days], [onComplete], [priority], [parallelism])",
                "name": "scheduleJob",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    },
                    {
                        "full": "jobDesc",
                        "name": "jobDesc"
                    },
                    {
                        "full": "jobFunc",
                        "name": "jobFunc"
                    },
                    {
                        "full": "scheduleTime",
                        "name": "scheduleTime"
                    },
                    {
                        "full": "startDate",
                        "name": "startDate"
                    },
                    {
                        "full": "endDate",
                        "name": "endDate"
                    },
                    {
                        "full": "frequency",
                        "name": "frequency"
                    },
                    {
                        "full": "[days]",
                        "name": "days",
                        "optional": true
                    },
                    {
                        "full": "[onComplete]",
                        "name": "onComplete",
                        "optional": true
                    },
                    {
                        "full": "[priority]",
                        "name": "priority",
                        "optional": true
                    },
                    {
                        "full": "[parallelism]",
                        "name": "parallelism",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [scheduleJob](https://docs.dolphindb.cn/zh/funcs/s/scheduleJob.html)\n\n\n\n#### 语法\n\nscheduleJob(jobId, jobDesc, jobFunc, scheduleTime, startDate, endDate, frequency, \\[days], \\[onComplete], \\[priority], \\[parallelism])\n\n#### 参数\n\n**jobId** 是一个字符串。\n\n**jobDesc** 是关于任务描述的字符串。\n\n**jobFunc** 是一个没有参数的函数。它通常是一个部分应用。注意：若该函数是一个自定义函数，则它只能接收标量、数据对或常规数组作为默认参数。\n\n**scheduleTime** 是一个 MINUTE 类型的标量/向量。任务之间的时间间隔最小为5分钟。\n\n**startDate** 是一个日期标量。\n\n**endDate** 是一个日期标量。\n\n**frequency** 是一个字符。它可以是下列3个值之一：'D' 表示每日，'W' 表示每周，'M' 表示每月。\n\n**days** 是一个整型标量/向量，表示执行定时任务的日期。如果 *frequency* 为 'W' 或 'M' 时，它是必需的。如果 *frequency* 为W，*days* 可以取以下值：0（周日），1（周一），...，5（周五），6（周六）。\n\n**onComplete** 是一个有4个参数的回调函数，细节请见以下最后一个例子。当定时作业执行完毕（包括有异常的情况）后，会执行该函数。可通过该函数向外部消息系统如邮件系统或微信与钉钉发送消息。\n\n**priority**属于 0 到 8 的整数，表示任务的优先级。默认值为 4。\n\n**parallelism**属于 0 到 8 的整数，表示任务的并行度。默认值为 2。\n\n注：用户设置的优先级和并行度，还分别受到 [setMaxJobPriority](https://docs.dolphindb.cn/zh/funcs/s/setMaxJobPriority.html) 的参数 *maxPriority*和 [setMaxJobParallelism](https://docs.dolphindb.cn/zh/funcs/s/setMaxJobParallelism.html) 的参数 *maxParallelism*限制。最终的优先级和并行度分别为 min(*priority*, *maxPriority*), min(*parallelism*, *maxParallelism*)。\n\n#### 详情\n\n返回定时任务的任务 ID。如果 *jobId* 与已有的定时任务的 ID 不一致，系统返回 *jobId*。否则在 *jobId* 后面添加当前日期，\"000\", \"001\" 等作为后缀，直到产生唯一的任务 ID。 我们可以使用 [getRecentJobs](https://docs.dolphindb.cn/zh/funcs/g/getRecentJobs.html) 来查看最近完成的定时任务。\n\n执行定时任务生成的信息保存在 jodId.msg 文件中；如果定时任务会返回值，它会保存在 jobId.object 文件中。 jobId.msg 和 jobId.object 保存在 batchIobs 文件夹中。我们可以分别使用 [getJobMessage](https://docs.dolphindb.cn/zh/funcs/g/getJobMessage.html) 和 [getJobReturn](https://docs.dolphindb.cn/zh/funcs/g/getJobReturn.html) 来查看这两个文件。\n\n#### 例子\n\n定时执行一个函数：\n\n```\ndef f():1+2;\nscheduleJob(jobId=`daily, jobDesc=\"Daily Job 1\", jobFunc=f, scheduleTime=17:23m, startDate=2018.01.01, endDate=2018.12.31, frequency='D');\nscheduleJob(jobId=`weekly, jobDesc=\"Weekly Job\", jobFunc=f, scheduleTime=17:30m, startDate=2018.01.01, endDate=2018.12.31, frequency='W', days=2);\n```\n\n定时执行一个脚本：\n\n```\nscheduleJob(jobId=`monthly, jobDesc=\"Monthly Job 1\", jobFunc=run{\"monthlyJob.dos\"}, scheduleTime=17:23m, startDate=2018.01.01, endDate=2018.12.31, frequency='M', days=1);\n```\n\n这里使用部分应用 run{\\<script>}，因为 *jobFunc* 必须是没有参数的函数。\n\n```\ngetJobMessage(`daily);\n// output\n018-02-08 17:23:27.166296 Start the job [daily]: Daily Job 1\n018-02-08 17:23:27.167303 The job is done.\n\ngetJobReturn(`daily);\n// output\n3\n```\n\n可以在一天中多次定时执行相同的任务：\n\n```\nscheduleJob(jobId=`Trading, jobDesc=\"Generate Trading Tickets\", jobFunc=run{\"TradingTickets.dos\"}, scheduleTime=[09:25m, 12:00m, 02:00m, 15:50m], startDate=2018.01.01, endDate=2018.12.31, frequency='D');\n```\n\n在这种情况下，每次执行定时任务时，任务 ID 是不一样的。\n\n可以在每周的工作日中多次执行相同的定时任务：\n\n```\nscheduleJob(jobId=`PnL, jobDesc=\"Calculate Profit & Loss\", jobFunc=run{\"PnL.dos\"}, scheduleTime=[12:00m, 02:00m, 14:50m], startDate=2018.01.01, endDate=2018.12.31, frequency='W', days=[1,2,3,4,5]);\n```\n\n定时任务执行结束后可发送邮件通知。以下脚本运行前需安装 HttpClient 插件。\n\n```\ndef sendEmail(jobId, jobDesc, success, result){\n  desc = \"jobId=\" + jobId + \" jobDesc=\" + jobDesc\n  if(success){\n  desc += \" successful \" + result\n    res = httpClient::sendEmail('patrick.mahomes@dolphindb.com','password','andy.reid@dolphindb.com','This is a subject',desc)\n  }\n  else{\n  desc += \" with error: \" + result\n    res = httpClient::sendEmail('patrick.mahomes@dolphindb.com','password','andy.reid@dolphindb.com','This is a subject',desc)\n  }\n}\nscheduleJob(jobId=`PnL, jobDesc=\"Calculate Profit & Loss\", jobFunc=run{\"PnL.dos\"}, scheduleTime=[12:00m, 02:00m, 14:50m], startDate=2018.01.01, endDate=2018.12.31, frequency='W', days=[1,2,3,4,5], onComplete=sendEmail);\n```\n"
    },
    "schema": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/schema.html",
        "signatures": [
            {
                "full": "schema(table|dbHandle)",
                "name": "schema",
                "parameters": [
                    {
                        "full": "table|dbHandle",
                        "name": "table|dbHandle"
                    }
                ]
            }
        ],
        "markdown": "### [schema](https://docs.dolphindb.cn/zh/funcs/s/schema.html)\n\n#### 语法\n\nschema(table|dbHandle)\n\n#### 详情\n\n显示指定数据表或数据库的结构信息。`schema`返回一个无序字典，包含以下字段（按首字母排序）：\n\n* atomic：写入事务的原子性层级。\n\n* chunkGranularity：分区粒度。\n\n* clusterReplicationEnabled：集群间异步复制的开启状态。若开启，则该值为 true，否则为 false。\n\n* colDefs：数据表各字段的结构信息。\n\n  * name：列名\n\n  * typeString：列的类型\n\n  * typeInt：列类型对应的ID\n\n  * extra：仅在列类型为 DECIMAL 时，显示 DECIMAL 的 scale\n\n  * comment：列字段的注释信息\n\n* compressMethods：分布式表各列的压缩算法类型。\n\n  * name：列名\n\n  * compressMethods：压缩算法类型。lz4，delta （即 delta-of-delta encoding 算法）或 zstd\n\n* databaseDir：数据库的保存目录的路径。\n\n* databaseOwner：数据库创建者名称。\n\n* engineType：存储引擎的类型，OLAP 或者 TSDB。\n\n* keepDuplicates：数据保留策略。\n\n* partitionColumnIndex：分区列在表字段中对应的下标。维度表时，该值为 -1。\n\n* partitionColumnName：分区列的名称。\n\n* partitionColumnType：分区列类型对应的 ID，参照数据类型章节。\n\n* partitionSchema：分区的结构。\n\n* partitionSites：若 `database` 函数配置了 *locations* 参数，则该字段将列出 locations 指定节点的 ip:port 信息。\n\n* partitionTypeName / partitionType：分区的类型名和对应的 ID。VALUE(1), RANGE(2), LIST(3), COMPO(4), HASH(5)。\n\n* sortColumns：数据表的排序列。\n\n* softDelete：创建的表开启了软删除。仅在通过 TSDB 存储引擎创建的库中的表的 schema 返回值中可见。该功能开启时，softDelete 返回字段中显示为 true；否则显示为 false。\n\n* sortKeyMappingFunction：索引列的映射函数。\n\n* tableComment：表的注释。\n\n* tableOwner：表创建者名称。\n\n* partitionFunction：处理分区列数据的函数。是一个字符串向量，每个元素是一个函数签名。若某个元素为 asis，则表示建表时未指定函数对象。例如：`partitionFunction->[myPartitionFunc{, 6, 8},asis]`。\n\n* latestKeyCache：该分区表是否开启最新值缓存功能。\n\n* compressHashSortKey：该分区表是否开启静态表 sortKey 压缩功能。\n\n#### 参数\n\n参数可为一个数据表，亦可为一个数据库句柄 （dbHandle）。\n\n#### 例子\n\n应用于 OLAP 引擎下的数据库：\n\n```\nn=1000000  // 设置变量n为1000000\nID=rand(10, n)  // 生成一个随机整数数组ID\nx=rand(1.0, n)  // 生成一个随机浮点数数组x\nt=table(ID, x)  // 创建表t，包含ID和x两列\ndb=database(\"dfs://rangedb101\", RANGE, 0 5 10)  // 创建分布式数据库dfs://rangedb101，使用RANGE分布方式\npt = db.createPartitionedTable(t, `pt, `ID)  // 创建分区表pt，使用ID作为分区键\npt.append!(t)  // 将表t的数据追加到分区表pt中\npt=loadTable(db,`pt);  // 从数据库db中加载分区表pt\nschema(db);  // 显示数据库db的模式信息\n```\n\n返回：\n\n```\ndatabaseDir->dfs://rangedb101\npartitionSchema->[0,5,10]\npartitionSites->\natomic->TRANS\nchunkGranularity->TABLE\npartitionType->2\npartitionTypeName->RANGE\npartitionColumnType->4\nclusterReplicationEnabled->1\ndatabaseOwner->admin\n```\n\n应用于 OLAP 引擎下的数据表时：\n\n```\nschema(pt);\n```\n\n返回：\n\n```\nchunkGranularity->TABLE\ntableOwner->admin\ncompressMethods->\nname compressMethods\n---- ---------------\nID   lz4            \nx    lz4            \n\ncolDefs->\nname typeString typeInt comment\n---- ---------- ------- -------\nID   INT        4              \nx    DOUBLE     16             \n\nchunkPath->\npartitionColumnIndex->0\npartitionColumnName->ID\npartitionColumnType->4\npartitionType->2\npartitionTypeName->RANGE\npartitionSchema->[0,5,10]\npartitionSites->\n```\n\n应用于 TSDB 引擎下的数据库：\n\n```\nn = 10000 // 设置变量n为10000\nSecurityID = rand(`st0001`st0002`st0003`st0004`st0005, n) // 从指定的证券ID中随机选择n个值赋给SecurityID\nsym = rand(`A`B, n)  // 从符号A和B中随机选择n个值赋给sym\nTradeDate = 2022.01.01 + rand(100,n) // 从2022年1月1日至100天后的日期中随机选择n个日期赋给TradeDate\nTotalVolumeTrade = rand(1000..3000, n)  // 生成n个介于1000和3000之间的随机整数赋给TotalVolumeTrade\nTotalValueTrade = rand(100.0, n)  // 生成n个小数赋给TotalValueTrade\nschemaTable_snap = table(SecurityID, TradeDate, TotalVolumeTrade, TotalValueTrade).sortBy!(`SecurityID`TradeDate)  \n// 创建表schemaTable_snap，并按SecurityID和TradeDate排序\n\ndbPath = \"dfs://TSDB_STOCK\"  // 设置数据库路径为dfs://TSDB_STOCK\nif (existsDatabase(dbPath)){dropDatabase(dbPath)}  // 如果数据库路径存在，则删除该数据库\ndb_snap = database(dbPath, VALUE, 2022.01.01..2022.01.05, engine='TSDB')  // 创建名为db_snap的数据库，时间范围为2022年1月1日至2022年1月5日，引擎为TSDB\n\nschema(db_snap)  // 显示db_snap的模式信息\n```\n\n返回：\n\n```\ndatabaseDir->dfs://TSDB_STOCK\npartitionSchema->[2022.01.01,2022.01.02,2022.01.03,2022.01.04,2022.01.05]\npartitionSites->\nengineType->TSDB\natomic->TRANS\nchunkGranularity->TABLE\npartitionType->1\npartitionTypeName->VALUE\npartitionColumnType->6\nclusterReplicationEnabled->1\ndatabaseOwner->admin\n```\n\n应用于 TSDB 引擎下的数据表：\n\n```\n// 定义名为myHashFunc的函数，该函数接受一个参数x，并返回x的哈希桶编号，桶数为10\ndef myHashFunc(x){\n  return hashBucket(x, 10)\n}\n\n// 使用db_snap中的schemaTable_snap创建一个分区表snap，表名为\"snap\"\n// 以TradeDate分区，以SecurityID和TradeDate排序\n// 保留重复值，排序键映射函数为myHashFunc\nsnap = createPartitionedTable(dbHandle=db_snap, table=schemaTable_snap, tableName=\"snap\", partitionColumns=`TradeDate, sortColumns=`SecurityID`TradeDate, keepDuplicates=ALL, sortKeyMappingFunction=[myHashFunc])\n\n// 显示snap表的模式信息\nschema(snap)\n```\n\n返回：\n\n```\nengineType->TSDB\nkeepDuplicates->ALL\nchunkGranularity->TABLE\nsortColumns->[\"SecurityID\",\"TradeDate\"]\nsortKeyMappingFunction->[\"def myHashFunc(x){\n  return hashBucket(x, 10)\n}\"]\nsoftDelete->0\ntableOwner->admin\ncompressMethods->\nname             compressMethods\n---------------- ---------------\nSecurityID       lz4            \nTradeDate        lz4            \nTotalVolumeTrade lz4            \nTotalValueTrade  lz4            \n\ncolDefs->\nname             typeString typeInt extra comment\n---------------- ---------- ------- ----- -------\nSecurityID       SYMBOL     17                   \nTradeDate        DATE       6                    \nTotalVolumeTrade INT        4                    \nTotalValueTrade  DOUBLE     16                   \n\nchunkPath->\npartitionColumnIndex->1\npartitionColumnName->TradeDate\npartitionColumnType->6\npartitionType->1\npartitionTypeName->VALUE\npartitionSchema->[2022.01.01,2022.01.02,2022.01.03,2022.01.04,2022.01.05]\npartitionSites->\n```\n\n建立一个点位管理表，复合分区方案按 id 和 ts 分区，创建了一个名为 pt 的点位管理表。该表使用 ticket 和 id2 作为唯一识别一个点位的两列；启用最新值缓存，且 value 为 IOTANY 类型，可存储不同类型的测点数据；启用了 hashSortKey 压缩。\n\n```\ndbName = \"pt\"\nif(existsDatabase(dbName)){\n        dropDatabase(dbName)\n}\ndb1 = database(, partitionType=HASH, partitionScheme=[INT, 10])\ndb2 = database(, partitionType=VALUE, partitionScheme=2017.08.07..2017.08.11)\ndb = database(dbName, COMPO, [db1, db2], engine='IOTDB')\n\ncreate table \"dfs://db\".\"pt\" (\n        id INT,\n        ticket SYMBOL,\n        id2 LONG,\n        ts TIMESTAMP,\n        id3 IOTANY\n)\npartitioned by id, ts,\nsortColumns = [`ticket, `id2, `ts],\nsortKeyMappingFunction = [hashBucket{, 50}, hashBucket{, 50}],\nlatestKeyCache = true,\ncompressHashSortKey = true\nprint schema(loadTable(dbName, `pt))\n```\n\n返回：\n\n```\n/* \nengineType->IOTDB\nkeepDuplicates->ALL\nchunkGranularity->TABLE\nsortColumns->[\"deviceId\",\"location\",\"timestamp\"]\nsortKeyMappingFunction->[\"hashBucket{, 50}\",\"hashBucket{, 50}\"]\nsoftDelete->0\ntableOwner->admin\ncompressMethods->name      compressMethods\n--------- ---------------\ndeviceId  lz4            \nlocation  lz4            \ntimestamp lz4            \nvalue     lz4            \n\ntableComment->\nlatestKeyCache->1\ncompressHashSortKey->0\ncolDefs->name      typeString typeInt extra comment\n--------- ---------- ------- ----- -------\ndeviceId  INT        4                    \nlocation  SYMBOL     17                   \ntimestamp TIMESTAMP  12                   \nvalue     IOTANY     41                   \n\nchunkPath->\npartitionColumnIndex->[0,2]\npartitionColumnName->[\"deviceId\",\"timestamp\"]\npartitionColumnType->[4,6]\npartitionType->[5,1]\npartitionTypeName->[\"HASH\",\"VALUE\"]\npartitionSchema->(20,[2017.08.07,2017.08.08,2017.08.09,2017.08.10,2017.08.11,2024.10.12])\npartitionSites->\n*/\n```\n\n\n\n**Related information**\n\n[database](https://docs.dolphindb.cn/zh/funcs/d/database.html)\n\n[createTable](https://docs.dolphindb.cn/zh/funcs/c/createTable.html)\n\n[createPartitionedTable](https://docs.dolphindb.cn/zh/funcs/c/createPartitionedTable.html)\n"
    },
    "schur": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/schur.html",
        "signatures": [
            {
                "full": "schur(obj, [sort])",
                "name": "schur",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[sort]",
                        "name": "sort",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [schur](https://docs.dolphindb.cn/zh/funcs/s/schur.html)\n\n\n\n#### 语法\n\nschur(obj, \\[sort])\n\n#### 参数\n\n**obj** 是一个方阵。\n\n**sort** 是一个字符串，表示根据所选参数对高特征值进行排序。它的可选参数可以是 'lhp'（特征值为小于零的实数），'rhp'（特征值为大于零的实数），'iuc'（特征值的绝对值<=1.0），或 'ouc'（特征值的绝对值>1.0）。\n\n**Note:** 若没有指定该参数，表示不进行排序。\n\n#### 详情\n\n计算矩阵的 Schur（舒尔）分解。\n\n假设输入方阵为 A：\n\n* 如果不指定 *sort* 参数，返回两个矩阵：T 矩阵（矩阵 A 的 schur 形式，正交矩阵）与酉矩阵 Z（对于实数矩阵而言，Z 的转置矩阵与其逆矩阵相等），使得 A = Z*T*Z-1 。\n\n* 如果指定 *sort* 参数，返回结果还包含一个整数，表示满足排序条件的特征值的数量。\n\n#### 例子\n\n```\nm=matrix([[0,0,1],[2,1,0],[2,2,1]]);\nT,Z=schur(m)\nT;\n```\n\n| #0       | #1        | #2        |\n| -------- | --------- | --------- |\n| 2.658967 | 1.424405  | -1.929334 |\n| 0        | -0.329484 | -0.490637 |\n| 0        | 1.311789  | -0.329484 |\n\n```\nZ\n```\n\n| #0       | #1        | #2        |\n| -------- | --------- | --------- |\n| 0.727116 | -0.601562 | 0.330796  |\n| 0.528394 | 0.798019  | 0.289768  |\n| 0.438294 | 0.035904  | -0.898114 |\n\n```\nT,Z,s=schur(m, 'lhp');\nT;\n```\n\n| #0        | #1        | #2        |\n| --------- | --------- | --------- |\n| -0.329484 | 1.570974  | 2.251318  |\n| -0.40969  | -0.329484 | -0.092398 |\n| 0         | 0         | 2.658967  |\n\n```\nZ\n```\n\n| #0        | #1        | #2       |\n| --------- | --------- | -------- |\n| 0.703818  | -0.632169 | 0.324042 |\n| 0.509043  | 0.766983  | 0.390655 |\n| -0.495495 | -0.109999 | 0.861618 |\n\n```\ns\n// output\n2\nT,Z,s=schur(m, 'rhp');\n\ns;\n// output\n1\n\nm=matrix([[0,0,9],[-2,1,0],[2,2,1]]);\nT,Z,s=schur(m, 'iuc');\ns;\n// output\n0\n\nT,Z,s=schur(m, 'ouc');\ns;\n// output\n1\n```\n"
    },
    "scs": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/scs.html",
        "signatures": [
            {
                "full": "scs(f, [P], [A], [b], [Aeq], [beq], [lb], [ub], [x0], [c], [eps], [alpha])",
                "name": "scs",
                "parameters": [
                    {
                        "full": "f",
                        "name": "f"
                    },
                    {
                        "full": "[P]",
                        "name": "P",
                        "optional": true
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[b]",
                        "name": "b",
                        "optional": true
                    },
                    {
                        "full": "[Aeq]",
                        "name": "Aeq",
                        "optional": true
                    },
                    {
                        "full": "[beq]",
                        "name": "beq",
                        "optional": true
                    },
                    {
                        "full": "[lb]",
                        "name": "lb",
                        "optional": true
                    },
                    {
                        "full": "[ub]",
                        "name": "ub",
                        "optional": true
                    },
                    {
                        "full": "[x0]",
                        "name": "x0",
                        "optional": true
                    },
                    {
                        "full": "[c]",
                        "name": "c",
                        "optional": true
                    },
                    {
                        "full": "[eps]",
                        "name": "eps",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [scs](https://docs.dolphindb.cn/zh/funcs/s/scs.html)\n\n\n\n#### 语法\n\nscs(f, \\[P], \\[A], \\[b], \\[Aeq], \\[beq], \\[lb], \\[ub], \\[x0], \\[c], \\[eps], \\[alpha])\n\n#### 详情\n\n求解目标函数在约束条件下的最优解。具体模型如下：\n\n![image](https://docs.dolphindb.cn/zh/images/scs01.png)\n\n返回结果是具有两个元素的元组。第一个元素是目标函数的最小值，第二个元素是目标函数取最小值时，x 的取值。\n\n#### 参数\n\n**Note:**\n\n以下参数中，除 *lb*, *ub* 可以为空外，其它参数都不可包含空值。\n\n**f** 二次规划中的一次项系数向量。必须和 x0 长度相同。\n\n**P** 一个矩阵，通过将二次项系数矩阵的对角线元素乘以2得到。例如：所有二次项组成上三角矩阵\n\n![image](https://docs.dolphindb.cn/zh/images/scs02.png)\n\n将对角线上的系数乘以2，其它系数不变，得到的矩阵就是 *P*。\n\n**A** 线性不等式约束的系数矩阵。列数必须和 x 的长度相同。\n\n**b** 线性不等式约束的右端向量。\n\n**Aeq** 线性等式约束的系数矩阵。列数必须和 x 的长度相同。\n\n**beq** 线性等式约束的右端向量。\n\n**lb** 变量的下界。可以是标量或与 x 等长的向量。注意：当 *lb* 为空时，表示 x 无下界约束。\n\n**ub** 变量的上界。可以是标量或与 x 等长的向量。注意：当 *lb* 为空时，表示 x 无上界约束。\n\n若 *lb* 或 *ub* 是标量，则所有变量都受同一个下界或上界约束。若 *lb* 或 *ub* 为NULL，表示 x 无相应的下界或上界约束。\n\n若 *lb* 或 *ub* 是向量，则 x 中的元素受 *lb* 或 *ub* 中相应位置的元素约束。若向量 *lb* 或 *ub* 中某元素为 NULL，表示此位置的 x 元素无相应的下界或上界约束\n\n**x0** 向量绝对值不等式约束的系数向量。必须和 f 长度相同。\n\n**c** 一个非负数字，表示绝对值不等式约束的右侧常量系数。\n\n**eps** 正浮点数，表示求解的精度。默认值为1e-6，范围为 \\[1e-4, 1e-9]。通过减小该参数值以获得更高精度的解。如果该参数设置值超过规定范围，则会自动调整为默认值。\n\n**alpha** 正浮点数，表示松弛参数。默认值为1.5，范围为 (0, 2)。通过增加 *alpha* 的值来加快求解速度。如果该参数设置值超过规定范围，则会自动调整为默认值。\n\n#### 例子\n\n求 x, y 满足以下约束条件时，目标函数 x2 + y 2 的最小值\n\n![image](https://docs.dolphindb.cn/zh/images/scs03.png)\n\n```\n// 目标函数中没有一次项，所以系数都为0，f取值如下\nf = [0, 0];\n// 仅存在二次项x^2 和 y^2，系数为均为1，则 P 的取值为\nP = [2, 0, 0, 2]$2:2;\n// 绝对值不等式的约束系数和右端向量\nx0 = [0.4, 0.6];\nc = 0.5;\n// 线性等式为 x+y=1，因此 Aeq 和 beq 的取值为\nAeq = [1, 1]$1:2;\nbeq = [1];\n// 由 x,y>0 得到变量的下界\nlb = [0, 0];\nre = scs(f=f,P=P,Aeq=Aeq,beq=beq,lb=lb,x0=x0,c=c);\nre[1]\n// output\n[0.500000043984074,0.499999955746447]\n```\n\n相关函数：[linprog](https://docs.dolphindb.cn/zh/funcs/l/linprog.html), [quadprog](https://docs.dolphindb.cn/zh/funcs/q/quadprog.html)\n"
    },
    "searchK": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/searchK.html",
        "signatures": [
            {
                "full": "searchK(X, k)",
                "name": "searchK",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "k",
                        "name": "k"
                    }
                ]
            }
        ],
        "markdown": "### [searchK](https://docs.dolphindb.cn/zh/funcs/s/searchK.html)\n\n\n\n#### 语法\n\nsearchK(X, k)\n\n#### 参数\n\n**X** 是一个向量。\n\n#### 详情\n\n返回第 *k* 小的元素，忽略 NULL 值。\n\n#### 例子\n\n```\nsearchK(1 7 3 5 3 9 6 1 NULL, 1);\n```\n\n输出返回：1\n\n```\nsearchK(1 7 3 5 3 9 6 1 NULL, 2);\n```\n\n输出返回：1\n\n```\nsearchK(1 7 3 5 3 9 6 1 NULL, 3);\n```\n\n输出返回：3\n"
    },
    "seasonalEsd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/seasonalEsd.html",
        "signatures": [
            {
                "full": "seasonalEsd(data, period, [hybrid], [maxAnomalies], [alpha])",
                "name": "seasonalEsd",
                "parameters": [
                    {
                        "full": "data",
                        "name": "data"
                    },
                    {
                        "full": "period",
                        "name": "period"
                    },
                    {
                        "full": "[hybrid]",
                        "name": "hybrid",
                        "optional": true
                    },
                    {
                        "full": "[maxAnomalies]",
                        "name": "maxAnomalies",
                        "optional": true
                    },
                    {
                        "full": "[alpha]",
                        "name": "alpha",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [seasonalEsd](https://docs.dolphindb.cn/zh/funcs/s/seasonalEsd.html)\n\n\n\n#### 语法\n\nseasonalEsd(data, period, \\[hybrid], \\[maxAnomalies], \\[alpha])\n\n#### 参数\n\n**data** 是一个数值向量，表示时间序列。\n\n**period** 是一个大于1的整数，表示时间序列的周期。\n\n**hybrid** 是一个布尔值，表示是否用中位数和绝对中位差代替 Grubb's test 中 zscore 计算的平均值和标准差。如果 *hybrid* 为 true，算法更具鲁棒性。默认值为 false。\n\n**maxAnomalies** 是一个正整数或(0, 0.5)之间的浮点数。默认值为0.1。\n\n* 如果 *maxAnomalies* 是正整数，且 *maxAnomalies* 必须小于 data 长度的一半，函数最多检测 *maxAnomalies* 个异常点。\n\n* 如果 *maxAnomalies* 是(0, 0.5)之间的浮点数，函数最多检测 int(size(data) \\* *maxAnomalies* ) 个异常点。\n\n**alpha** 是一个正数，表示显著度。*alpha* 越大，数据越有可能被判断为异常点。\n\n#### 详情\n\n使用 S-ESD(Seasonal Extreme Studentized Deviate) 算法对周期性的时间序列进行异常检测。返回结果是包含了异常值的表，该表有两列，index 列记录原始数据中异常值的下标，anoms 列记录异常值。\n\n#### 例子\n\n定时执行一个函数：\n\n```\nn = 100\ntrend = 6 * sin(1..n \\ 200)\nseasonal = sin(pi / 6 * 1..n)\nresidual = rand(1.0, n) - 0.5\ndata = trend + seasonal + residual\ndata[20 50 70] += 20;\n\nseasonalEsd(data, 12);\n```\n\n| index | anoms     |\n| ----- | --------- |\n| 50    | 22.6365   |\n| 70    | 21.141346 |\n| 20    | 19.174165 |\n\n相关函数：[stl](https://docs.dolphindb.cn/zh/funcs/s/stl.html), [esd](https://docs.dolphindb.cn/zh/funcs/e/esd.html)\n"
    },
    "second": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/second.html",
        "signatures": [
            {
                "full": "second(X)",
                "name": "second",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [second](https://docs.dolphindb.cn/zh/funcs/s/second.html)\n\n\n\n#### 语法\n\nsecond(X)\n\n#### 详情\n\n返回对应的秒数，返回值的类型是 SECOND，一个时间值。\n\n#### 参数\n\n**X** 可以是整数/时间类型/字符串类型的标量或向量。\n\n#### 例子\n\n```\nsecond();\n```\n\n返回：null\n\n```\nsecond(1)\n```\n\n返回：00:00:01\n\n```\nsecond(\"19:36:12\");\n```\n\n返回：19:36:12\n\n```\nsecond(now());\n```\n\n返回：16:01:32\n\n```\nsecond 2012.12.03 01:22:01;\n```\n\n返回：01:22:01\n\n```\nsecond(61);\n```\n\n返回：00:01:01\n\n```\nsecond(\"09:00:01\")\n```\n\n返回：09:00:01\n\n**Related information**\n\n[minute](https://docs.dolphindb.cn/zh/funcs/m/minute.html)\n\n[hour](https://docs.dolphindb.cn/zh/funcs/h/hour.html)\n\n[date](https://docs.dolphindb.cn/zh/funcs/d/date.html)\n\n[month](https://docs.dolphindb.cn/zh/funcs/m/month.html)\n\n[year](https://docs.dolphindb.cn/zh/funcs/y/year.html)\n"
    },
    "secondOfMinute": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html",
        "signatures": [
            {
                "full": "secondOfMinute(X)",
                "name": "secondOfMinute",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [secondOfMinute](https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html)\n\n\n\n#### 语法\n\nsecondOfMinute(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n返回 *X* 中的秒数。\n\n#### 例子\n\n```\nsecondOfMinute(12:32:00);\n// output\n0\n\nsecondOfMinute([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n// output\n[0,0,47,14]\n```\n\n相关函数：[dayOfYear](https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html), [weekOfYear](https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html), [hourOfDay](https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html), [millisecond](https://docs.dolphindb.cn/zh/funcs/m/millisecond.html), [microsecond](https://docs.dolphindb.cn/zh/funcs/m/microsecond.html), [nanosecond](https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html)\n"
    },
    "seek": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/seek.html",
        "signatures": [
            {
                "full": "seek(handle, offset, [mode])",
                "name": "seek",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "offset",
                        "name": "offset"
                    },
                    {
                        "full": "[mode]",
                        "name": "mode",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [seek](https://docs.dolphindb.cn/zh/funcs/s/seek.html)\n\n\n\n#### 语法\n\nseek(handle, offset, \\[mode])\n\n#### 参数\n\n**handle** 必须是一个文件句柄。\n\n**offset** 是一个整数。\n\n**mode** 是 HEAD, CURRENT, TAIL 之一。默认的 *mode* 是 CURRENT。\n\n#### 详情\n\n如果没有抛出异常，`seek` 函数将返回文件内部游标经计算后的位置。\n\n当系统从一个文件中读取数据，或把数据写入一个文件中时，内部的游标将前进。用户可以通过 `seek` 函数手动操纵游标。\n\n#### 例子\n\n```\n// 编写一个返回文件长度的函数\ndef fileLength(f): file(f).seek(0, TAIL)\nfileLength(\"test.txt\");\n// output\n14\n\n// 把内部游标移动到文件头部。\nfin=file(\"test.txt\")\nfin.readLine();\n// output\nHello World!\n\nfin.seek(0, HEAD);\n// output\n0\n\nfin.readLine();\n// output\nHello World!\n```\n"
    },
    "segment": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/segment.html",
        "signatures": [
            {
                "full": "segment(X, [segmentOffset=true])",
                "name": "segment",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[segmentOffset=true]",
                        "name": "segmentOffset",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [segment](https://docs.dolphindb.cn/zh/funcs/s/segment.html)\n\n\n\n#### 语法\n\nsegment(X, \\[segmentOffset=true])\n\n#### 参数\n\n**X** 是一个向量。\n\n**segmentOffset** 是一个布尔值。默认值为 true。\n\n#### 详情\n\n将向量分组，连续的相同元素为一组。返回的结果是与 *X* 等长的向量。\n\n如果 *segmentOffset* 为 true，返回的结果是每组第一个元素在 *X* 中的下标。\n\n如果 *segmentOffset* 为 false，返回的结果表示每个元素位于第几组。组号从0开始编号。\n\n#### 例子\n\n```\nx = 1 1 2 4 4 5 2 5 NULL NULL\nsegment(x);\n// output\n[0,0,2,3,3,5,6,7,8,8]\n\nsegment(x, false);\n// output\n[0,0,1,2,2,3,4,5,6,6]\n\nx = 1 2 1 2 1 2 1 2 1 2 1 2;\ny = 0 0 1 1 1 2 2 1 1 3 3 2;\nt = table(x,y);\nselect *, cumsum(x) from t context by segment(y);\n```\n\n| y | x | cumsum\\_x |\n| - | - | --------- |\n| 0 | 1 | 1         |\n| 0 | 2 | 3         |\n| 1 | 1 | 1         |\n| 1 | 2 | 3         |\n| 1 | 1 | 4         |\n| 2 | 2 | 2         |\n| 2 | 1 | 3         |\n| 1 | 2 | 2         |\n| 1 | 1 | 3         |\n| 3 | 2 | 2         |\n| 3 | 1 | 3         |\n| 2 | 2 | 2         |\n"
    },
    "sem": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sem.html",
        "signatures": [
            {
                "full": "sem(X)",
                "name": "sem",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sem](https://docs.dolphindb.cn/zh/funcs/s/sem.html)\n\n\n\n#### 语法\n\nsem(X)\n\n#### 参数\n\n**X** 是数值型向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 的平均值的标准误差。\n\n若 *X* 为矩阵，计算每列的标准误差，返回一个向量。\n\n若 *X* 为表，计算每列的标准误差，返回一个表。\n\n#### 例子\n\n```\nsem([85,90,95,NULL]);\n// output\n2.886751\n```\n"
    },
    "semiMonthBegin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/semiMonthBegin.html",
        "signatures": [
            {
                "full": "semiMonthBegin(X, [dayOfMonth=15], [offset], [n=1])",
                "name": "semiMonthBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[dayOfMonth=15]",
                        "name": "dayOfMonth",
                        "optional": true,
                        "default": "15"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [semiMonthBegin](https://docs.dolphindb.cn/zh/funcs/s/semiMonthBegin.html)\n\n\n\n#### 语法\n\nsemiMonthBegin(X, \\[dayOfMonth=15], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**dayOfMonth** 是2到27之间的整数。它是一个可选参数，默认值为15。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在半月的第一天。假设 *X* 为当月的第 d 天：\n\n* 如果 d<*dayOfMonth*，那么 *semiMonthBegin* 返回X所在月份的第一天。\n\n* 如果 d>=*dayOfMonth*，那么 *semiMonthBegin* 返回X所在月份的第 *dayOfMonth* 天。\n\n如果指定了 *offset* ，表示从 *offset* 开始，结果每隔 *n* 个半月更新一次。注意，只有当 *n>1* 时，*offset* 才会生效。\n\n#### 例子\n\n```\nsemiMonthBegin(2012.06.12);\n```\n\n输出返回： 2012.06.01\n\n```\nsemiMonthBegin(2012.06.24);\n```\n\n输出返回： 2012.06.15\n\n```\nsemiMonthBegin(2012.06.15);\n```\n\n输出返回： 2012.06.15\n\n```\nsemiMonthBegin(2012.06.16, 16);\n```\n\n输出返回： 2012.06.16\n\n```\ndate=2016.04.07+(1..10)*7\ntime = take(09:30:00, 10);\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\nt1;\n```\n\n输出返回：\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2016.04.14 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2016.04.21 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2016.04.28 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2016.05.05 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.05.12 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2016.05.19 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2016.05.26 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2016.06.02 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2016.06.09 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2016.06.16 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by semiMonthBegin(date);\n```\n\n输出返回：\n\n| semiMonthBegin\\_date | avg\\_price | sum\\_qty |\n| -------------------- | ---------- | -------- |\n| 2016.04.01           | 49.6       | 2200     |\n| 2016.04.15           | 29.49      | 4000     |\n| 2016.05.01           | 102.495    | 10000    |\n| 2016.05.15           | 112.995    | 6700     |\n| 2016.06.01           | 50.805     | 11300    |\n| 2016.06.15           | 52.38      | 4500     |\n\n相关函数： [monthBegin](https://docs.dolphindb.cn/zh/funcs/m/monthBegin.html), [monthEnd](https://docs.dolphindb.cn/zh/funcs/m/monthEnd.html), [semiMonthEnd](https://docs.dolphindb.cn/zh/funcs/s/semiMonthEnd.html)\n"
    },
    "semiMonthEnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/semiMonthEnd.html",
        "signatures": [
            {
                "full": "semiMonthEnd(X, [dayOfMonth=15], [offset], [n=1])",
                "name": "semiMonthEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[dayOfMonth=15]",
                        "name": "dayOfMonth",
                        "optional": true,
                        "default": "15"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [semiMonthEnd](https://docs.dolphindb.cn/zh/funcs/s/semiMonthEnd.html)\n\n\n\n#### 语法\n\nsemiMonthEnd(X, \\[dayOfMonth=15], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATEHOUR, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**dayOfMonth** 是2到27之间的整数。它是一个可选参数，默认值为15。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在半月的最后一天。假设 *X* 为该月的第 d 天：\n\n* 如果d<*dayOfMonth*，那么 *semiMonthBegin* 返回 *X* 所在月份的上一个月的最后一天。\n\n* 如果d>=*dayOfMonth*，那么 *semiMonthBegin* 返回X所在月份的第 *dayOfMonth* 天。\n\n如果指定了 *offset* ，表示从 *offset* 开始，结果每隔 *n* 个半月更新一次。注意，只有当 *n>1* 时，*offset* 才会生效。\n\n#### 例子\n\n```\nsemiMonthEnd(2012.06.12);\n// output\n012.05.31\n\n \nsemiMonthEnd(2012.06.24);\n// output\n012.06.15\n\n \nsemiMonthEnd(2012.06.15);\n// output\n012.06.15\n\n \nsemiMonthEnd(2012.06.16, 16);\n// output\n012.06.16\n\n\ndate=2016.04.07+(1..10)*7\ntime = take(09:30:00, 10);\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2016.04.14 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2016.04.21 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2016.04.28 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2016.05.05 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.05.12 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2016.05.19 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2016.05.26 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2016.06.02 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2016.06.09 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2016.06.16 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by semiMonthEnd(date);\n```\n\n| semiMonthEnd\\_date | avg\\_price | sum\\_qty |\n| ------------------ | ---------- | -------- |\n| 2016.03.31         | 49.6       | 2200     |\n| 2016.04.15         | 29.49      | 4000     |\n| 2016.04.30         | 102.495    | 10000    |\n| 2016.05.15         | 112.995    | 6700     |\n| 2016.05.31         | 50.805     | 11300    |\n| 2016.06.15         | 52.38      | 4500     |\n\n相关函数：[monthBegin](https://docs.dolphindb.cn/zh/funcs/m/monthBegin.html), [monthEnd](https://docs.dolphindb.cn/zh/funcs/m/monthEnd.html), [semiMonthBegin](https://docs.dolphindb.cn/zh/funcs/s/semiMonthBegin.html)\n"
    },
    "seq": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/seq.html",
        "signatures": [
            {
                "full": "seq(start, end)",
                "name": "seq",
                "parameters": [
                    {
                        "full": "start",
                        "name": "start"
                    },
                    {
                        "full": "end",
                        "name": "end"
                    }
                ]
            }
        ],
        "markdown": "### [seq](https://docs.dolphindb.cn/zh/funcs/s/seq.html)\n\n\n\n#### 语法\n\nseq(start, end) 或 start..end\n\n#### 参数\n\n**start** 和 **end** 必须是整型或时间类型。\n\n#### 详情\n\n返回一个以 *start* 开始，以 *end* 结尾的数据序列。两个相邻元素之间的差为1。\n\n#### 例子\n\n```\nx=0..3;\nx;\n// output\n[0,1,2,3]\n\n1..3+1;\n// output\n[2,3,4]\n\n11..1;\n// output\n[11,10,9,8,7,6,5,4,3,2,1]\n\nseq(3,1);\n// output\n[3,2,1]\n\n2015.01M..2015.12M;\n// output\n[2015.01M,2015.02M,2015.03M,2015.04M,2015.05M,2015.06M,2015.07M,2015.08M,2015.09M,2015.10M,2015.11M,2015.12M]\n\n2016.01.01..2016.01.07;\n// output\n[2016.01.01,2016.01.02,2016.01.03,2016.01.04,2016.01.05,2016.01.06,2016.01.07]\n```\n"
    },
    "sessionWindow": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sessionWindow.html",
        "signatures": [
            {
                "full": "sessionWindow(X, sessionGap)",
                "name": "sessionWindow",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "sessionGap",
                        "name": "sessionGap"
                    }
                ]
            }
        ],
        "markdown": "### [sessionWindow](https://docs.dolphindb.cn/zh/funcs/s/sessionWindow.html)\n\n\n\n#### 语法\n\nsessionWindow(X, sessionGap)\n\n#### 参数\n\n**X** 整型或时间类型向量。\n\n**SessionGap** 正整数，表示两个会话之间的间隔。其单位同 *X* 一致。\n\n#### 详情\n\n从 *X* 的第一个非空元素开始一个会话窗口，依次判断 *X* 中每个元素与前一个相邻元素的差值是否小于 *sessionGap*。若差值小于 *sessionGap*，则会话窗口继续打开；否则，会话窗口关闭，且由当前元素开始一个新的会话窗口。以各个会话窗口的第一个元素值作为它的编号。该函数返回 *X* 中每个元素所属的会话窗口的编号。\n\n**Note:**\n\n* 对于 *X* 中的空值（不参与比较）：若空值位于 *X* 的开头，则返回空；否则，返回其前一个非空元素所属会话窗口的编号。\n\n* 乱序数据不会参与比较，直接返回当前会话窗口的编号。\n\n#### 例子\n\n```\nx = 1 5 6 12 13 13 15\nsessionWindow(x, 5)\n// output\n[1,1,1,12,12,12,12]\n\ny = 2012.06.13 2012.06.15 2012.06.19 2012.06.26 2012.06.28\nsessionWindow(y, 5)\n// output\n[2012.06.13,2012.06.13,2012.06.13,2012.06.26,2012.06.26]\n```\n\n在下例中，第二个会话窗口（编号为12）之后出现的乱序数据3和7不参与判断，直接返回编号12。其后的元素15属于会话窗口12（因为15-12<4）。\n\n```\nx = [, , 1, 12, 3, 7, 15, 19]\nsessionWindow(x, 4) \n// output\n[,,1,12,12,12,12,12,12,19]\n\n```\n\n```\ncolTime = 2023.06.01T10:00:00.000 + 1 2 3 4 5 6 7 8 9 21 22 23 28 29 30\ncolSym = take(`A`B`C,15)\ncolVolume = [2,1,5,5,2,3,2,3,2,2,5,5,2,7,2]\nt = table(colTime as time, colSym as sym, colVolume as volume)\nt\n```\n\n| time                    | sym | volume |\n| ----------------------- | --- | ------ |\n| 2023.06.01 10:00:00.001 | A   | 2      |\n| 2023.06.01 10:00:00.002 | B   | 1      |\n| 2023.06.01 10:00:00.003 | C   | 5      |\n| 2023.06.01 10:00:00.004 | A   | 5      |\n| 2023.06.01 10:00:00.005 | B   | 2      |\n| 2023.06.01 10:00:00.006 | C   | 3      |\n| 2023.06.01 10:00:00.007 | A   | 2      |\n| 2023.06.01 10:00:00.008 | B   | 3      |\n| 2023.06.01 10:00:00.009 | C   | 2      |\n| 2023.06.01 10:00:00.021 | A   | 2      |\n| 2023.06.01 10:00:00.022 | B   | 5      |\n| 2023.06.01 10:00:00.023 | C   | 5      |\n| 2023.06.01 10:00:00.028 | A   | 2      |\n| 2023.06.01 10:00:00.029 | B   | 7      |\n| 2023.06.01 10:00:00.030 | C   | 2      |\n\n在下面的代码中，我们使用了高阶函数 `contextby`，根据股票代码 sym 对数据进行分组，并在每个分组内使用 `sessionWindow` 划分会话窗口，然后计算每个窗口中的交易量总和。其中，`sessionWinodow` 使用了部分应用，其第一个参数固定为时间列 time。\n\n```\nselect sum(volume) from t group by contextby(sessionWindow{, 5}, time, sym) as time,sym\n```\n\n| time                    | sym | sum\\_volume |\n| ----------------------- | --- | ----------- |\n| 2023.06.01 10:00:00.001 | A   | 9           |\n| 2023.06.01 10:00:00.002 | B   | 6           |\n| 2023.06.01 10:00:00.003 | C   | 10          |\n| 2023.06.01 10:00:00.021 | A   | 2           |\n| 2023.06.01 10:00:00.022 | B   | 5           |\n| 2023.06.01 10:00:00.023 | C   | 5           |\n| 2023.06.01 10:00:00.028 | A   | 2           |\n| 2023.06.01 10:00:00.029 | B   | 7           |\n| 2023.06.01 10:00:00.030 | C   | 2           |\n"
    },
    "set": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/set.html",
        "signatures": [
            {
                "full": "set(X)",
                "name": "set",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [set](https://docs.dolphindb.cn/zh/funcs/s/set.html)\n\n\n\n#### 语法\n\nset(X)\n\n#### 参数\n\n**X** 是一个向量。\n\n#### 详情\n\n返回向量 *X* 对应的集合对象。\n\n#### 例子\n\n`set` 函数返回一个集合。\n\n```\nx=set(4 5 5 2 3 11 6);\nx;\n// output\nset(6,11,3,2,5,4)\n\nx.intersection(set([2,5,9]));\n// output\nset(2,5)\n```\n\n与此不同，[distinct](https://docs.dolphindb.cn/zh/funcs/d/distinct.html) 函数返回一个向量。\n\n```\ndistinct(4 5 5 2 3 11 6);\n// output\n[6,11,3,2,5,4]\n```\n"
    },
    "setAtomicLevel": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setAtomicLevel.html",
        "signatures": [
            {
                "full": "setAtomicLevel(dbHandle, atomic)",
                "name": "setAtomicLevel",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "atomic",
                        "name": "atomic"
                    }
                ]
            }
        ],
        "markdown": "### [setAtomicLevel](https://docs.dolphindb.cn/zh/funcs/s/setAtomicLevel.html)\n\n\n\n#### 语法\n\nsetAtomicLevel(dbHandle, atomic)\n\n#### 参数\n\n**dbHandle** 是 [database](https://docs.dolphindb.cn/zh/funcs/d/database.html) 函数返回的分布式数据库句柄。\n\n**atomic** 表示写入事务的原子性层级，决定了是否允许并发写入同一分区。可选值为 'TRANS' 和 'CHUNK'，默认值为 'TRANS'。\n\n* 设置为'TRANS'，写入事务的原子性层级为事务，即一个事务写入多个分区时，若某个分区被其他写入事务锁定而出现写入冲突，则该事务的写入全部失败。因此，该设置下，不允许并发写入同一个分区。\n\n* 设置为'CHUNK'，写入事务的原子性层级为分区。若一个事务写入多个分区时，某分区被其它写入事务锁定而出现冲突，系统会完成其他分区的写入，同时对之前发生冲突的分区不断尝试写入，尝试数分钟后仍冲突才放弃。此设置下，允许并发写入同一个分区，但由于不能完全保证事务的原子性，可能出现部分分区写入成功而部分分区写入失败的情况。同时由于采用了重试机制，写入速度可能较慢。\n\n#### 详情\n\n修改分布式数据库的并发写入权限。\n\n#### 例子\n\n```\ndbPath=\"dfs://test\"\nmydb=database(dbPath, VALUE, ['AMZN','NFLX', 'NVDA'])\nmydb.schema()\n\n// output\ndatabaseDir->dfs://test\npartitionSchema->[NVDA,AMZN,NFLX]\npartitionSites->\npartitionTypeName->VALUE\npartitionType->1\natomic->TRANS\n```\n\n```\nsetAtomicLevel(mydb, `CHUNK)\nmydb.schema()\n\n// output\ndatabaseDir->dfs://test\npartitionSchema->[NVDA,AMZN,NFLX]\npartitionSites->\npartitionTypeName->VALUE\npartitionType->1\natomic->CHUNK\n```\n"
    },
    "setCacheEngineMemSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setCacheEngineMemSize.html",
        "signatures": [
            {
                "full": "setCacheEngineMemSize(memSize)",
                "name": "setCacheEngineMemSize",
                "parameters": [
                    {
                        "full": "memSize",
                        "name": "memSize"
                    }
                ]
            }
        ],
        "markdown": "### [setCacheEngineMemSize](https://docs.dolphindb.cn/zh/funcs/s/setCacheEngineMemSize.html)\n\n#### 语法\n\nsetCacheEngineMemSize(memSize)\n\n#### 参数\n\n**memSize** 一个数值型标量，且必须大于0且小于 *maxMemSize* \\* 0.75。\n\n#### 详情\n\n在线修改 Cache Engine 的容量。集群环境下，该命令只能由管理员在数据节点/计算节点上执行。执行前需要确保开启了 Cache Engine (配置参数 *chunkCacheEngineMemSize*)。仅 OLAP 引擎支持该命令。\n\n**Note:**\n\n此命令修改的配置值在集群重启后将失效。若需要配置值永久生效，请更改配置文件中的 *chunkCacheEngineMemSize* 。\n\n#### 场景\n\nCache Engine 开启后，写入数据时，系统会先把数据写入缓存，当缓存中的数据量达到 *chunkCacheEngineMemSize* 的30%时，才会写入磁盘。若该配置项设置过小，大批量数据写入时，Cache Engine 可能很快被占满，从而导致写入卡住。此时，通过该命令在线修改 Cache Engine 的容量，来保证写入继续进行。\n\n#### 相关函数\n\n可以使用 [getCacheEngineMemSize](https://docs.dolphindb.cn/zh/funcs/g/getCacheEngineMemSize.html) 获取 Cache Engine 的实时状态，确认 Cache Engine 是否在线修改成功。\n"
    },
    "setColumnarTuple!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setColumnarTuple_.html",
        "signatures": [
            {
                "full": "setColumnarTuple!(X, [on=true])",
                "name": "setColumnarTuple!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[on=true]",
                        "name": "on",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [setColumnarTuple!](https://docs.dolphindb.cn/zh/funcs/s/setColumnarTuple_.html)\n\n\n\n#### 语法\n\nsetColumnarTuple!(X, \\[on=true])\n\n#### 参数\n\n`X` 相同类型的向量或标量组成的 tuple。\n\n`on` 布尔值，表示 tuple 和 columnar tuple 之间的转换。默认为 true，表示将 tuple 转换成 columnar tuple；若为 false，表示将 columnar tuple 转换为 tuple。\n\n#### 详情\n\n用于 tuple 和 columnar tuple 的相互转化。\n\n#### 例子\n\n```\ntp = [[1,2,3], [4,5,6], [7,8]]\nisColumnarTuple(tp)\n// output\nfalse\n\ntp.setColumnarTuple!()\nisColumnarTuple(tp)\n// output\ntrue\n \nt = table(1..5 as id, [`a`a,`b`a,`c, `f`e, `g] as val)\nisColumnarTuple(t.val)\n// output\ntrue\n\nt1 = t.val.setColumnarTuple!(false)\nisColumnarTuple(t1)\n// output\nfalse\n```\n"
    },
    "setColumnComment": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setColumnComment.html",
        "signatures": [
            {
                "full": "setColumnComment(table, columnComments)",
                "name": "setColumnComment",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "columnComments",
                        "name": "columnComments"
                    }
                ]
            }
        ],
        "markdown": "### [setColumnComment](https://docs.dolphindb.cn/zh/funcs/s/setColumnComment.html)\n\n\n\n#### 语法\n\nsetColumnComment(table, columnComments)\n\n#### 参数\n\n**table** 是一个分布式表或 mvcc 表。\n\n**columnComments** 是一个字典，其中 key 表示表中的列，value 表示各列的注释。\n\n#### 详情\n\n给分布式表或 mvcc 表的列添加注释。通过 [schema](https://docs.dolphindb.cn/zh/funcs/s/schema.html) 函数可以查看各列的注释。\n\n#### 例子\n\n```\nn=1000000\nsym=rand(`A`B`C`D`E`F,n)\ndate=rand(2019.06.01..2019.06.10,n)\nopen=rand(100.0,n)\nhigh=rand(200.0,n)\nclose=rand(200.0,n)\npre_close=rand(200.0,n)\nchange=rand(100.0,n)\nvol=rand(10000,n)\namount=rand(100000.0,n)\nt=table(sym,date,open,high,close,pre_close,change,vol,amount);\n\ndb1=database(\"\",VALUE,2019.06.01..2019.06.10)\ndb2=database(\"\",VALUE,`A`B`C`D`E`F)\ndb=database(\"dfs://db1\",COMPO,[db1,db2])\npt=db.createPartitionedTable(t,`pt,`date`sym).append!(t);\n\nsetColumnComment(pt,{sym:\"股票代码\",date:\"交易日期\",open:\"开盘价\",high:\"最高价\",close:\"收盘价\",pre_close:\"昨收价\",change:\"涨跌额\",vol:\"成交量（手）\",amount:\"成交额（千元）\"})\nschema(pt).colDefs;\n```\n\n| name       | typeString | typeInt | comment |\n| ---------- | ---------- | ------- | ------- |\n| sym        | SYMBOL     | 17      | 股票代码    |\n| date       | DATE       | 6       | 交易日期    |\n| open       | DOUBLE     | 16      | 开盘价     |\n| high       | DOUBLE     | 16      | 最高价     |\n| close      | DOUBLE     | 16      | 收盘价     |\n| pre\\_close | DOUBLE     | 16      | 昨收价     |\n| change     | DOUBLE     | 16      | 涨跌额     |\n| vol        | INT        | 4       | 成交量（手）  |\n| amount     | DOUBLE     | 16      | 成交额（千元） |\n\n```\nid=`XOM`GS`AAPL\nx=102.1 33.4 73.6\nmt = mvccTable(id, x);\nsetColumnComment(mt, {id:\"标识符\"})\nschema(mt).colDefs\n```\n\n| name | typeString | typeInt | extra | comment |\n| ---- | ---------- | ------- | ----- | ------- |\n| id   | STRING     | 18      |       | 标识符     |\n| x    | DOUBLE     | 16      |       |         |\n"
    },
    "setComputeNodeCachingDelay": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setcomputenodecachingdelay.html",
        "signatures": [
            {
                "full": "setComputeNodeCachingDelay(delay)",
                "name": "setComputeNodeCachingDelay",
                "parameters": [
                    {
                        "full": "delay",
                        "name": "delay"
                    }
                ]
            }
        ],
        "markdown": "### [setComputeNodeCachingDelay](https://docs.dolphindb.cn/zh/funcs/s/setcomputenodecachingdelay.html)\n\n\n\n#### 语法\n\nsetComputeNodeCachingDelay(delay)\n\n#### 参数\n\n**delay** 非负整数，表示时间间隔，单位为秒。\n\n#### 详情\n\n在线设置当前节点下配置项 *computeNodeCachingDelay* 的生效值。只能由管理员在控制节点执行。\n\n#### 例子\n\n```\nsetComputeNodeCachingDelay(580) \n```\n\n相关函数：[getComputeNodeCachingDelay](https://docs.dolphindb.cn/zh/funcs/g/getcomputenodecachingdelay.html)\n"
    },
    "setDatabaseClusterReplicationExecutionSet": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setdatabaseclusterreplicationexecutionset.html",
        "signatures": [
            {
                "full": "setDatabaseClusterReplicationExecutionSet(dbHandle, executionSet)",
                "name": "setDatabaseClusterReplicationExecutionSet",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "executionSet",
                        "name": "executionSet"
                    }
                ]
            }
        ],
        "markdown": "### [setDatabaseClusterReplicationExecutionSet](https://docs.dolphindb.cn/zh/funcs/s/setdatabaseclusterreplicationexecutionset.html)\n\n\n\n#### 语法\n\nsetDatabaseClusterReplicationExecutionSet(dbHandle, executionSet)\n\n#### 参数\n\n**dbHandle** 数据库句柄，代表要设置执行集的数据库。\n\n**executionSet** 整型标量，只能是 0 或 1，代表执行集。数据库启用异步复制后，默认的执行集为 0。\n\n#### 详情\n\n为一个数据库设置异步复制任务的执行集。不同执行集的任务彼此隔离，互不影响。此函数只能由管理员在主集群的数据节点上对开启了异步复制的数据库执行。\n\n#### 例子\n\n```\nsetDatabaseClusterReplicationExecutionSet(dbHandle=database(\"dfs://test\"), executionSet=1)\n```\n"
    },
    "setDatabaseForClusterReplication": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setDatabaseForClusterReplication.html",
        "signatures": [
            {
                "full": "setDatabaseForClusterReplication(dbHandle, option)",
                "name": "setDatabaseForClusterReplication",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "option",
                        "name": "option"
                    }
                ]
            }
        ],
        "markdown": "### [setDatabaseForClusterReplication](https://docs.dolphindb.cn/zh/funcs/s/setDatabaseForClusterReplication.html)\n\n\n\n#### 语法\n\nsetDatabaseForClusterReplication(dbHandle, option)\n\n#### 参数\n\n`dbHandle`：一个分布式数据库句柄。\n\n`option`：布尔值，表示开启（true）/关闭（false）指定数据库的异步复制，默认为 false。\n\n#### 详情\n\n开启/关闭分布式数据库的集群间的异步复制。该函数只能由管理员在主集群的数据节点调用。\n\n相关函数：[getDatabaseClusterReplicationStatus](https://docs.dolphindb.cn/zh/funcs/g/getDatabaseClusterReplicationStatus.html)\n"
    },
    "setDatanodeRestartInterval": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setDatanodeRestartInterval.html",
        "signatures": [
            {
                "full": "setDatanodeRestartInterval(interval)",
                "name": "setDatanodeRestartInterval",
                "parameters": [
                    {
                        "full": "interval",
                        "name": "interval"
                    }
                ]
            }
        ],
        "markdown": "### [setDatanodeRestartInterval](https://docs.dolphindb.cn/zh/funcs/s/setDatanodeRestartInterval.html)\n\n\n\n#### 语法\n\nsetDatanodeRestartInterval(interval)\n\n#### 参数\n\n**interval** 非负整数，表示时间，单位为秒。\n\n#### 详情\n\n在线设置控制节点自动重启计算节点/数据节点的功能。该命令只能由管理员在控制节点上调用。\n\n* 若 *interval*=0，则控制节点不会自动重启数据节点/计算节点。\n\n* 若 *interval*>0，则当节点离线时长超过 interval 时，控制节点会自动启动该节点。\n\n**Note:**\n\n* 该命令并不会改变配置文件中的 datanodeRestartInterval 值。因此，一旦控制节点重启，通过该命令设置的 interval 将失效。\n\n* 高可用环境下，Leader 节点通过该命令设置的 interval 并不会同步到其它 Follower 节点。\n\n相关函数：[getDatanodeRestartInterval](https://docs.dolphindb.cn/zh/funcs/g/getDatanodeRestartInterval.html)\n"
    },
    "setDefaultCatalog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setDefaultCatalog.html",
        "signatures": [
            {
                "full": "setDefaultCatalog(catalog)",
                "name": "setDefaultCatalog",
                "parameters": [
                    {
                        "full": "catalog",
                        "name": "catalog"
                    }
                ]
            }
        ],
        "markdown": "### [setDefaultCatalog](https://docs.dolphindb.cn/zh/funcs/s/setDefaultCatalog.html)\n\n\n\n#### 语法\n\nsetDefaultCatalog(catalog)\n\n#### 参数\n\n**catalog** 字符串标量，表示 catalog 的名称。若为空，则表示重置当前 catalog 空间为初始状态，即无默认 catalog。\n\n#### 详情\n\n为当前 session 设置默认的 catalog。\n\n#### 例子\n\n```\ngetCurrentCatalog()\n// 返回为空\n\ncreateCatalog(\"cat1\")\nsetDefaultCatalog(\"cat1\")\ngetCurrentCatalog()\n// Output: cat1\n\nsetDefaultCatalog(\"\")\ngetCurrentCatalog()\n// 返回为空\n```\n"
    },
    "setDynamicConfig": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setdynamicconfig.html",
        "signatures": [
            {
                "full": "setDynamicConfig(configName, configValue)",
                "name": "setDynamicConfig",
                "parameters": [
                    {
                        "full": "configName",
                        "name": "configName"
                    },
                    {
                        "full": "configValue",
                        "name": "configValue"
                    }
                ]
            }
        ],
        "markdown": "### [setDynamicConfig](https://docs.dolphindb.cn/zh/funcs/s/setdynamicconfig.html)\n\n\n\n#### 语法\n\nsetDynamicConfig(configName, configValue)\n\n#### 参数\n\n**configName** 字符串标量，表示待修改的配置项名。\n\n**configValue** 标量，表示待修改的配置项的值。\n\n#### 详情\n\n在线修改指定的配置项。无返回值。\n\n**Note:** 此命令修改的配置值在系统重启后将失效。\n\n如下为支持修改的配置项。详情请参考文档 [DolphinDB-功能配置](https://docs.dolphindb.cn/zh/db_distr_comp/cfg/function_configuration.dita)。\n\n| 配置项名                          | 支持输入类型                                 |\n| ----------------------------- | -------------------------------------- |\n| enableMultiThreadMerge        | BOOL                                   |\n| logLevel                      | ENUM {DEBUG, INFO, WARNING, ERROR} 中的值 |\n| maxBlockSizeForReservedMemory | NUMBER                                 |\n| maxConnections                | INTEGRAL                               |\n| memLimitOfQueryResult         | NUMBER                                 |\n| memLimitOfTaskGroupResult     | NUMBER                                 |\n| maxMemSize                    | NUMBER                                 |\n| maxPartitionNumPerQuery       | INT                                    |\n| memLimitOfTempResult          | NUMBER                                 |\n| OLAPCacheEngineSize           | NUMBER                                 |\n| recoveryWorkers               | INT                                    |\n| reservedMemSize               | NUMBER                                 |\n| dfsChunkNodeHeartBeatTimeout  | INT                                    |\n| TSDBCacheEngineSize           | NUMBER                                 |\n| memLimitOfAllTempResults      | NUMBER                                 |\n| TSDBVectorIndexCacheSize      | DOUBLE                                 |\n\n**Note:** 其中，NUMBER表示类型 CHAR/SHORT/INT/LONG/FLOATING/DOUBLE/DECIMAL，INTEGRAL 表示类型 CHAR/SHORT/INT/LONG。\n\n#### 例子\n\n```\nsetDynamicConfig(\"maxMemSize\", 8);\nsetDynamicConfig(\"maxConnections\", 4096);\n```\n\n**Related information**\n\n[getDynamicConfig](https://docs.dolphindb.cn/zh/funcs/g/getdynamicconfig.html)\n"
    },
    "setGpFitnessFunc": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setgpfitnessfunc.html",
        "signatures": [
            {
                "full": "setGpFitnessFunc(engine, func, [funcArgs])",
                "name": "setGpFitnessFunc",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "func",
                        "name": "func"
                    },
                    {
                        "full": "[funcArgs]",
                        "name": "funcArgs",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [setGpFitnessFunc](https://docs.dolphindb.cn/zh/funcs/s/setgpfitnessfunc.html)\n\n#### 语法\n\nsetGpFitnessFunc(engine, func, \\[funcArgs])\n\n**Note:**\n\n社区版 License 暂不支持该函数，如需使用此功能，请联系技术支持。\n\n#### 详情\n\n重置 GPLearn 引擎的适应度函数。\n\n#### 参数\n\n**engine** 通过函数 `createGPLearnEngine` 创建引擎的返回对象。\n\n**func** 替换后的适应度函数，可以是\n\n* 字符串类型标量，必须为 'mse', 'rmse', 'pearson', 'spearmanr', 'mae' 之一。\n* 用户自定义函数，至少包含两个入参，第一个参数代表因子计算结果，第二个参数代表预测值，如有其他参数，则通过 *funcArgs*传递；函数的返回值必须是一个浮点型标量。自定义函数目前不支持复杂赋值、if、for 等语句，只支持 return 语句。return 值为支持的适应度函数和训练函数的组合，其中适应度函数需要手动写公式实现。例如：\n\n  ```\n  def f(x, y){\n    return mean((x+y)*(x+y)-y*y)\n  }\n  ```\n\n自定义的适应度函数，还可与辅助函数进行组合，从而实现在计算适应度前，对数据进行预处理。辅助函数如下所示\n\n<table id=\"table_zzr_lnv_mbc\"><thead><tr><th>\n\n**函数名**\n\n</th><th>\n\n**备注**\n\n</th></tr></thead><tbody><tr><td>\n\nclip(X,Y,Z)\n\n</td><td>\n\n</td></tr><tr><td>\n\nzscore(x)\n\n</td><td>\n\n</td></tr><tr><td>\n\nmad(X, \\[useMedian=false])\n\n</td><td>\n\n</td></tr><tr><td>\n\nmed(x)\n\n</td><td>\n\n</td></tr><tr><td>\n\nmean(x)\n\n</td><td>\n\n</td></tr><tr><td>\n\ncorr(X,Y)\n\n</td><td>\n\n</td></tr><tr><td>\n\ngroupby(func, funcArgs, groupingCol)\n\n</td><td>\n\n</td></tr><tr><td>\n\nstd(X)\n\n</td><td>\n\n</td></tr><tr><td>\n\nstdp(X)\n\n</td><td>\n\n</td></tr><tr><td>\n\nskew(X)\n\n</td><td>\n\n</td></tr><tr><td>\n\nkurtosis(X)\n\n</td><td>\n\n</td></tr><tr><td>\n\ncontextby(func, funcArgs, groupingCol, \\[sortingCol])\n\n</td><td>\n\n仅支持 *func*为辅助函数 `rank` 或 `zscore`。\n\n</td></tr><tr><td>\n\nrank(X, \\[ascending=true], \\[groupNum], \\[ignoreNA=true], \\[tiesMethod='min'], \\[percent=false], \\[precision])\n\n</td><td>\n\n暂不支持设置参数 *groupNum*, *ignoreNA*, *precision*.\n\n</td></tr></tbody>\n</table>**funcArgs**元组，其每个元素依次代表用户自定义的 *func*中除因子计算结果和预测值外的其他参数。\n\n#### 例子\n\n```\ndef myFitness(x, y, groupCOlA, groupColB) {\n  return mean(abs(groupby(mean, x, groupCOlA) - groupby(mean, x, groupCOlA)))\n}\nsetGpFitnessFunc(engine=myEngine, func=myFitness, funcArgs=[groupColA, groupColB])\n```\n\n\n\n**Related information**\n\n[Shark GPLearn 快速上手](https://docs.dolphindb.cn/zh/tutorials/gplearn.html)\n"
    },
    "setIndexedMatrix!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setIndexedMatrix_.html",
        "signatures": [
            {
                "full": "setIndexedMatrix!(X, [on=true])",
                "name": "setIndexedMatrix!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[on=true]",
                        "name": "on",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [setIndexedMatrix!](https://docs.dolphindb.cn/zh/funcs/s/setIndexedMatrix_.html)\n\n\n\n#### 语法\n\nsetIndexedMatrix!(X, \\[on=true])\n\n#### 参数\n\n**X** 是一个有行与列标签的矩阵。行与列标签均须严格递增，无重复项。\n\n**on** 布尔值，表示普通矩阵和索引矩阵之间的转换。默认为 true，表示将普通矩阵转换成索引矩阵；若为 false，表示将索引矩阵转换为普通矩阵。\n\n#### 详情\n\n将矩阵的行与列标签设为索引。\n\n#### 例子\n\n```\nm=matrix(1..5, 11..15)\nm.rename!(2020.01.01..2020.01.05, `A`B)\nm.setIndexedMatrix!();\n```\n\n|            | A | B  |\n| ---------- | - | -- |\n| 2020.01.01 | 1 | 11 |\n| 2020.01.02 | 2 | 12 |\n| 2020.01.03 | 3 | 13 |\n| 2020.01.04 | 4 | 14 |\n| 2020.01.05 | 5 | 15 |\n"
    },
    "setIndexedSeries!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setIndexedSeries_.html",
        "signatures": [
            {
                "full": "setIndexedSeries!(X, [on=true])",
                "name": "setIndexedSeries!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[on=true]",
                        "name": "on",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [setIndexedSeries!](https://docs.dolphindb.cn/zh/funcs/s/setIndexedSeries_.html)\n\n\n\n#### 语法\n\nsetIndexedSeries!(X, \\[on=true])\n\n#### 参数\n\n**X** 是一个有行标签的单列矩阵。行标签须严格递增，无重复项。\n\n**on** 布尔值，表示普通矩阵和索引序列之间的转换。默认为 true，表示将普通矩阵转换成索引序列；若为 false， 表示将索引序列转换为普通矩阵。\n\n#### 详情\n\n将一个有行标签的单列矩阵转化为有索引的序列。\n\n#### 例子\n\n```\ns = matrix(1..10).rename!(2012.01.01..2012.01.10, ).setIndexedSeries!();\ns;\n```\n\n|            | #0 |\n| ---------- | -- |\n| 2012.01.01 | 1  |\n| 2012.01.02 | 2  |\n| 2012.01.03 | 3  |\n| 2012.01.04 | 4  |\n| 2012.01.05 | 5  |\n| 2012.01.06 | 6  |\n| 2012.01.07 | 7  |\n| 2012.01.08 | 8  |\n| 2012.01.09 | 9  |\n| 2012.01.10 | 10 |\n"
    },
    "setLogLevel": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setLogLevel.html",
        "signatures": [
            {
                "full": "setLogLevel(logLevel)",
                "name": "setLogLevel",
                "parameters": [
                    {
                        "full": "logLevel",
                        "name": "logLevel"
                    }
                ]
            }
        ],
        "markdown": "### [setLogLevel](https://docs.dolphindb.cn/zh/funcs/s/setLogLevel.html)\n\n\n\n#### 语法\n\nsetLogLevel(logLevel)\n\n#### 参数\n\n**logLevel** 日志等级，从低到高可选值为：DEBUG, INFO, WARNING, ERROR。\n\n#### 详情\n\n在线设置当前节点的日志文件的等级。设置后，系统只打印当前 logLevel 及以上级别的日志。该命令只能由管理员调用。\n"
    },
    "setMaxBlockSizeForReservedMemory": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setMaxBlockSizeForReservedMemory.html",
        "signatures": [
            {
                "full": "setMaxBlockSizeForReservedMemory(blockSizeKB)",
                "name": "setMaxBlockSizeForReservedMemory",
                "parameters": [
                    {
                        "full": "blockSizeKB",
                        "name": "blockSizeKB"
                    }
                ]
            }
        ],
        "markdown": "### [setMaxBlockSizeForReservedMemory](https://docs.dolphindb.cn/zh/funcs/s/setMaxBlockSizeForReservedMemory.html)\n\n\n\n#### 语法\n\nsetMaxBlockSizeForReservedMemory(blockSizeKB)\n\n#### 参数\n\n**blockSizeKB** 一个数值型标量（单位为KB），必须大于0。\n\n#### 详情\n\n在线修改系统预留内存可以分配的最大内存块大小。该命令只能由管理员在数据节点/计算节点上执行。\n\n请注意，此命令修改的配置值只对当前节点有效，且在系统重启后将失效。若需要配置值永久生效，请更改配置文件中的 *maxBlockSizeForReservedMemory*。\n"
    },
    "setMaxConnections": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setMaxConnections.html",
        "signatures": [
            {
                "full": "setMaxConnections(newValue)",
                "name": "setMaxConnections",
                "parameters": [
                    {
                        "full": "newValue",
                        "name": "newValue"
                    }
                ]
            }
        ],
        "markdown": "### [setMaxConnections](https://docs.dolphindb.cn/zh/funcs/s/setMaxConnections.html)\n\n\n\n#### 语法\n\nsetMaxConnections(newValue)\n\n#### 参数\n\n**newValue** 一个小于 2^16（65536）的正整数。\n\n#### 详情\n\n在线修改当前节点的最大连接数。该命令只能由管理员执行。\n\n可以在控制节点调用函数 [getClusterPerf](https://docs.dolphindb.cn/zh/funcs/g/getClusterPerf.html) 返回的 maxConnections 字段查看是否成功修改。\n\n**Note:**\n\n* *newValue* 指定的值必须大于当前的最大连接数，否则无法生效。\n\n* 此命令修改的配置值在系统重启后将失效。若需要配置值永久生效，请更改配置文件中的 *maxConnections*。\n\n* `getClusterPerf` 函数获取节点信息存在延迟，获取的可能不是最新的连接数。\n"
    },
    "setMaxJobParallelism": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setMaxJobParallelism.html",
        "signatures": [
            {
                "full": "setMaxJobParallelism(userId, maxParallelism)",
                "name": "setMaxJobParallelism",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    },
                    {
                        "full": "maxParallelism",
                        "name": "maxParallelism"
                    }
                ]
            }
        ],
        "markdown": "### [setMaxJobParallelism](https://docs.dolphindb.cn/zh/funcs/s/setMaxJobParallelism.html)\n\n\n\n#### 语法\n\nsetMaxJobParallelism(userId, maxParallelism)\n\n#### 参数\n\n**userId** 是一个字符串，表示用户名。\n\n**maxParallelism** 是一个1到64之间的整数，表示该用户的作业的最大并行度，即最多可以有多少个子任务同时并行执行。\n\n#### 详情\n\n为给定用户指定其提交的作业最多可以有多少个子任务同时并行执行。该命令必须要用户登录后才能执行。\n\n若未执行该函数，管理员的作业的默认最大并行度为64；非管理员用户的作业的默认最大并行度为2。\n\n**Note:** 该函数可在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n```\nlogin(`admin,`123456)\ncreateUser(`ElonMusk, `superman)\nsetMaxJobParallelism(`ElonMusk, 64);\n```\n"
    },
    "setMaxJobPriority": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setMaxJobPriority.html",
        "signatures": [
            {
                "full": "setMaxJobPriority(userId, maxPriority)",
                "name": "setMaxJobPriority",
                "parameters": [
                    {
                        "full": "userId",
                        "name": "userId"
                    },
                    {
                        "full": "maxPriority",
                        "name": "maxPriority"
                    }
                ]
            }
        ],
        "markdown": "### [setMaxJobPriority](https://docs.dolphindb.cn/zh/funcs/s/setMaxJobPriority.html)\n\n\n\n#### 语法\n\nsetMaxJobPriority(userId, maxPriority)\n\n#### 参数\n\n**userId** 是一个字符串，表示用户名。\n\n**maxPriority** 是一个0到8之间的整数，表示给定用户提交作业的最高优先级。\n\n#### 详情\n\n为给定用户指定其提交作业的最高优先级。该函数必须要用户登录后才能执行。\n\n**Note:** 该函数可在控制节点、数据节点和计算节点运行。\n\n#### 例子\n\n```\nlogin(`admin,`123456)\ncreateUser(`KyleMurray, `Cardinals2020QB)\nsetMaxJobPriority(`KyleMurray, 7);\n```\n"
    },
    "setMaxMemSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setMaxMemSize.html",
        "signatures": [
            {
                "full": "setMaxMemSize(memSizeGB)",
                "name": "setMaxMemSize",
                "parameters": [
                    {
                        "full": "memSizeGB",
                        "name": "memSizeGB"
                    }
                ]
            }
        ],
        "markdown": "### [setMaxMemSize](https://docs.dolphindb.cn/zh/funcs/s/setMaxMemSize.html)\n\n\n\n#### 语法\n\nsetMaxMemSize(memSizeGB)\n\n#### 参数\n\n**memSizeGB** 一个数值型标量（单位为 GB），必须大于0且不能大于 DolphinDB 的许可证文件配置的 *maxMemoryPerNode* （通过函数 `license` 查看），否则系统会报错。\n\n#### 详情\n\n在线修改可以分配给 DolphinDB 的最大内存空间（以 GB 为单位）大小。该命令只能由管理员执行。可通过 getClusterPerf().maxMemSize 查看修改后的设置是否生效。\n\n**Note:**\n\n此命令修改的配置值在系统重启后将失效。若需要配置值永久生效，请更改配置文件中的 *maxMemSize*。\n"
    },
    "setMemLimitOfAllTempResults": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setmemlimitofalltempresults.html",
        "signatures": [
            {
                "full": "setMemLimitOfAllTempResults()",
                "name": "setMemLimitOfAllTempResults",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [setMemLimitOfAllTempResults](https://docs.dolphindb.cn/zh/funcs/s/setmemlimitofalltempresults.html)\n\n\n\n#### 语法\n\nsetMemLimitOfAllTempResults()\n\n#### 参数\n\n**memLimit** 一个数值型标量，必须大于0且不能大于 *maxMemSize* 的设置值。\n\n#### 详情\n\n某些分布式查询操作（例如表连接、GROUP BY、CONTEXT BY、PIVOT BY），可能会产生临时表用于存储查询中产生的结果。该函数用于在线设置这些临时表允许占用的内存上限，单位为 GB。可通过 `getMemLimitOfAllTempResults` 查看设置是否生效。\n\n**Note:**\n\n* 该函数只能由管理员在数据节点/计算节点上执行。\n\n* 此函数修改的配置值在系统重启后将失效。若需要配置值永久生效，请更改配置文件中的 *memLimitOfAllTempResults*。\n\n#### 例子\n\n```\nsetMemLimitOfAllTempResults(3.0)\n```\n\n相关函数：[getMemLimitOfAllTempResults](https://docs.dolphindb.cn/zh/funcs/g/getmemlimitofalltempresults.html)\n"
    },
    "setMemLimitOfQueryResult": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setMemLimitOfQueryResult.html",
        "signatures": [
            {
                "full": "setMemLimitOfQueryResult(memLimit)",
                "name": "setMemLimitOfQueryResult",
                "parameters": [
                    {
                        "full": "memLimit",
                        "name": "memLimit"
                    }
                ]
            }
        ],
        "markdown": "### [setMemLimitOfQueryResult](https://docs.dolphindb.cn/zh/funcs/s/setMemLimitOfQueryResult.html)\n\n\n\n#### 语法\n\nsetMemLimitOfQueryResult(memLimit)\n\n#### 参数\n\n**memLimit** 数值类型标量，表示内存上限，单位为 GB。该值必须小于 80% \\* maxMemSize。\n\n#### 详情\n\n在线修改单次查询结果占用的最大内存上限。该命令只能由管理员在数据节点/计算节点执行。\n\n相关函数： [getMemLimitOfQueryResult](https://docs.dolphindb.cn/zh/funcs/g/getMemLimitOfQueryResult.html)\n"
    },
    "setMemLimitOfTaskGroupResult": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setMemLimitOfTaskGroupResult.html",
        "signatures": [
            {
                "full": "setMemLimitOfTaskGroupResult(memLimit)",
                "name": "setMemLimitOfTaskGroupResult",
                "parameters": [
                    {
                        "full": "memLimit",
                        "name": "memLimit"
                    }
                ]
            }
        ],
        "markdown": "### [setMemLimitOfTaskGroupResult](https://docs.dolphindb.cn/zh/funcs/s/setMemLimitOfTaskGroupResult.html)\n\n\n\n#### 语法\n\nsetMemLimitOfTaskGroupResult(memLimit)\n\n#### 参数\n\n**memLimit** 数值类型标量，表示内存上限。单位为 GB。\n\n#### 详情\n\n在线修改当前节点发送的批量子查询占用的内存上限。该命令只能由管理员在数据节点/计算节点执行。\n\n相关函数： [getMemLimitOfTaskGroupResult](https://docs.dolphindb.cn/zh/funcs/g/getMemLimitOfTaskGroupResult.html)\n"
    },
    "setMemLimitOfTempResult": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setMemLimitOfTempResult.html",
        "signatures": [
            {
                "full": "setMemLimitOfTempResult(X)",
                "name": "setMemLimitOfTempResult",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [setMemLimitOfTempResult](https://docs.dolphindb.cn/zh/funcs/s/setMemLimitOfTempResult.html)\n\n\n\n#### 语法\n\nsetMemLimitOfTempResult(X)\n\n#### 参数\n\n**X** 一个数值型标量，必须大于0且不能大于 *maxMemSize* 的设置值。\n\n#### 详情\n\n在线修改表连接过程中产生的临时数据表（单个）的大小，单位为 GB。该命令只能由管理员在数据节点/计算节点上执行。\n\n**Note:** 此命令修改的配置值在系统重启后将失效。若需要配置值永久生效，请更改配置文件中的 *memLimitOfTempResult*。\n"
    },
    "setOLAPCacheEngineSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setOLAPCacheEngineSize.html",
        "signatures": [
            {
                "full": "setOLAPCacheEngineSize(memSize)",
                "name": "setOLAPCacheEngineSize",
                "parameters": [
                    {
                        "full": "memSize",
                        "name": "memSize"
                    }
                ]
            }
        ],
        "markdown": "### [setOLAPCacheEngineSize](https://docs.dolphindb.cn/zh/funcs/s/setOLAPCacheEngineSize.html)\n\n\n\n#### 语法\n\nsetOLAPCacheEngineSize(memSize)\n\n别名：setCacheEngineMemSize\n\n#### 参数\n\n**memSize** 一个数值型标量，且必须大于0且小于 *maxMemSize* \\* 0.75。单位：GB。\n\n#### 详情\n\n在线修改 Cache Engine 的容量。集群环境下，该命令只能由管理员在数据节点/计算节点上执行。执行前需要确保开启了 Cache Engine (配置参数 *OLAPCacheEngineSize*)。仅 OLAP 引擎支持该命令。\n\n**Note:**\n\n此命令修改的配置值在集群重启后将失效。若需要配置值永久生效，请更改配置文件中的 *OLAPCacheEngineSize* 。\n\n#### 场景\n\nCache Engine 开启后，写入数据时，系统会先把数据写入缓存，当缓存中的数据量达到 *OLAPCacheEngineSize* 的30%时，才会写入磁盘。若该配置项设置过小，大批量数据写入时，Cache Engine 可能很快被占满，从而导致写入卡住。此时，通过该命令在线修改 Cache Engine 的容量，来保证写入继续进行。\n\n#### 相关函数：\n\n可以使用 [getOLAPCacheEngineSize](https://docs.dolphindb.cn/zh/funcs/g/getOLAPCacheEngineSize.html) 获取 Cache Engine 的实时状态，确认 Cache Engine 是否在线修改成功。\n"
    },
    "setPrefetchComputeNodeData": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setprefetchcomputenodedata.html",
        "signatures": [
            {
                "full": "setPrefetchComputeNodeData(flag)",
                "name": "setPrefetchComputeNodeData",
                "parameters": [
                    {
                        "full": "flag",
                        "name": "flag"
                    }
                ]
            }
        ],
        "markdown": "### [setPrefetchComputeNodeData](https://docs.dolphindb.cn/zh/funcs/s/setprefetchcomputenodedata.html)\n\n\n\n#### 语法\n\nsetPrefetchComputeNodeData(flag)\n\n#### 参数\n\n**flag** 布尔值，表示配置项 *enableComputeNodePrefetchData* 的内存生效值。\n\n#### 详情\n\n在线设置当前节点下配置项 *enableComputeNodePrefetchData* 的生效值。只能由管理员在控制节点执行。\n\n#### 例子\n\n```\nsetPrefetchComputeNodeData(false) \n```\n\n相关函数：[getPrefetchComputeNodeData](https://docs.dolphindb.cn/zh/funcs/g/getprefetchcomputenodedata.html)\n"
    },
    "setRaftElectionTick": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setRaftElectionTick.html",
        "signatures": [
            {
                "full": "setRaftElectionTick(groupId, tickCount)",
                "name": "setRaftElectionTick",
                "parameters": [
                    {
                        "full": "groupId",
                        "name": "groupId"
                    },
                    {
                        "full": "tickCount",
                        "name": "tickCount"
                    }
                ]
            }
        ],
        "markdown": "### [setRaftElectionTick](https://docs.dolphindb.cn/zh/funcs/s/setRaftElectionTick.html)\n\n\n\n#### 语法\n\nsetRaftElectionTick(groupId, tickCount)\n\n#### 参数\n\n**groupId** 是一个正整数，表示 raft 组的 ID，目前只能是1，表示控制节点组成的 raft 组 ID。\n\n**tickCount** 是一个不小于800的整数，单位为10ms。\n\n#### 详情\n\n通过该命令可以动态实现配置项 *raftElectionTick* 的功能。 由 *tickCount* 确定一个时间区间：\\[*tickCount*, 2 \\* *tickCount*]。在指定的 raft 组内， follower 在该区间内的一个随机时刻之后仍然没有收到 leader 的心跳，则会发出竞选 leader 的请求。\n\n**Note:**\n\n1. 必须由管理员在 raft 组内的所有控制节点上执行该命令，保证它们的 *raftElectionTick* 设置值相同。\n\n2. 该命令不会修改配置文件，重启后会恢复成默认配置或 *raftElectionTick* 指定的配置。\n\n相关函数： [getRaftElectionTick](https://docs.dolphindb.cn/zh/funcs/g/getRaftElectionTick.html), [getControllerElectionTick](https://docs.dolphindb.cn/zh/funcs/g/getControllerElectionTick.html)\n"
    },
    "setRandomSeed": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setRandomSeed.html",
        "signatures": [
            {
                "full": "setRandomSeed(seed)",
                "name": "setRandomSeed",
                "parameters": [
                    {
                        "full": "seed",
                        "name": "seed"
                    }
                ]
            }
        ],
        "markdown": "### [setRandomSeed](https://docs.dolphindb.cn/zh/funcs/s/setRandomSeed.html)\n\n\n\n#### 语法\n\nsetRandomSeed(seed)\n\n#### 参数\n\n**seed** 是一个整数，表示随机数种子。\n\n#### 详情\n\n设置随机数种子。\n\n#### 例子\n\n```\nsetRandomSeed(5);\nrand(10, 10);\n```\n\n输出返回：\\[2,0,8,8,2,3,9,9,4,0]\n"
    },
    "setReservedMemSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setReservedMemSize.html",
        "signatures": [
            {
                "full": "setReservedMemSize(memSizeGB)",
                "name": "setReservedMemSize",
                "parameters": [
                    {
                        "full": "memSizeGB",
                        "name": "memSizeGB"
                    }
                ]
            }
        ],
        "markdown": "### [setReservedMemSize](https://docs.dolphindb.cn/zh/funcs/s/setReservedMemSize.html)\n\n\n\n#### 语法\n\nsetReservedMemSize(memSizeGB)\n\n#### 参数\n\n**memSizeGB** 一个数值型标量（单位为GB），必须大于0，且不能超过 *maxMemSize* \\* 0.5。\n\n#### 详情\n\n在线修改系统预留内存空间的大小。该命令只能由管理员执行。\n\n请注意，此命令修改的配置值在系统重启后将失效。若需要配置值永久生效，请更改配置文件中的 *reservedMemSize*。\n"
    },
    "setRetentionPolicy": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setRetentionPolicy.html",
        "signatures": [
            {
                "full": "setRetentionPolicy(dbHandle, retentionHours, [retentionDimension], [hoursToColdVolume])",
                "name": "setRetentionPolicy",
                "parameters": [
                    {
                        "full": "dbHandle",
                        "name": "dbHandle"
                    },
                    {
                        "full": "retentionHours",
                        "name": "retentionHours"
                    },
                    {
                        "full": "[retentionDimension]",
                        "name": "retentionDimension",
                        "optional": true
                    },
                    {
                        "full": "[hoursToColdVolume]",
                        "name": "hoursToColdVolume",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [setRetentionPolicy](https://docs.dolphindb.cn/zh/funcs/s/setRetentionPolicy.html)\n\n\n\n#### 语法\n\nsetRetentionPolicy(dbHandle, retentionHours, \\[retentionDimension], \\[hoursToColdVolume])\n\n#### 参数\n\n**dbHandle** 分布式数据库的句柄。数据库的分区方案必须包含 DATE 类型或 DATEHOUR 类型。\n\n**retentionHours** 正整数，表示数据保留时间，单位是小时。\n\n**retentionDimension** 整数，表示时间分区所在的层次。默认值是0，表示第一层分区是按时间分区。\n\n**hoursToColdVolume** 正整数，表示 volumes 数据的保留时间，单位是小时。存储在 volumes 中的数据，经过 *hoursToColdVolume* 指定的时间后，将会自动迁移至 coldVolumes（该配置项需在配置文件中预先指定）。若不指定该参数，则 volumes 数据不会自动迁移。\n\n**Note:**\n\n必须满足 *retentionHours* - *hoursToColdVolume* > 7 \\* 24（即 7 天）\n\n#### 详情\n\n设置数据保留策略以及 [TieredStorage](https://docs.dolphindb.cn/zh/db_distr_comp/db/tiered_storage.html) 策略。若用户只通过该函数配置分级存储策略，建议将参数 *retentionHours* 指定为一个尽可能大的值。\n\n分级存储和数据保留策略都以分区为单位进行，因此 *retentionHours* 和 *hoursToColdVolume* 配置的时间必须是分区精度的倍数，如按天分区，则需要为 24 的整数倍。\n\n数据库会根据当前系统的机器时间，保留数据时间戳为最近 *retentionHours* 小时的数据。其中最新 *hoursToColdVolume* 小时的数据将继续存储在 volumes 中。在 \\[当前时间 - *hoursToColdVolume* - 10天，当前时间 - *hoursToColdVolume*) 范围内的数据将被迁移到 *coldVolumes*。若 *coldVolumes* 配置了多个路径，则数据将随机分布在各个存储路径下 。\n\n对于保留时间外的数据，只会删除 \\[当前时间 - *retentionHours* - 10 天, 当前时间 - *retentionHours*) 范围的数据。若需要删除之前的数据，可以调用 [dropPartition](https://docs.dolphindb.cn/zh/funcs/d/dropPartition.html) 函数实现。\n\n**Note:** 该函数只能对分布式数据库使用。\n\n可以通过 [schema](https://docs.dolphindb.cn/zh/funcs/s/schema.html) 函数查看数据库的数据保留时间。\n\n#### 例子\n\n```\ndb=database(\"dfs://db1\",VALUE,2019.06.01..date(now()))\nretentionHour=9*24\nhoursToColdVolume=1*24\nsetRetentionPolicy(db,retentionHour,0, hoursToColdVolume);\n\nschema(db);\n// output\npartitionSchema->[2022.05.05,2022.05.04,2022.05.03,2022.05.02,2022.05.01,2022.04.30,2022.04.29,2022.04.28,2022.04.27,2022.04.26,...]\npartitionSites->\npartitionTypeName->VALUE\nhoursToColdVolume->24\natomic->TRANS\ndatabaseDir->dfs://db1\nengineType->OLAP\nchunkGranularity->TABLE\nretentionDimension->0\npartitionType->1\nretentionHours->216\n```\n"
    },
    "setStreamTableFilterColumn": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setStreamTableFilterColumn.html",
        "signatures": [
            {
                "full": "setStreamTableFilterColumn(streamTable, columnName)",
                "name": "setStreamTableFilterColumn",
                "parameters": [
                    {
                        "full": "streamTable",
                        "name": "streamTable"
                    },
                    {
                        "full": "columnName",
                        "name": "columnName"
                    }
                ]
            }
        ],
        "markdown": "### [setStreamTableFilterColumn](https://docs.dolphindb.cn/zh/funcs/s/setStreamTableFilterColumn.html)\n\n\n\n#### 语法\n\nsetStreamTableFilterColumn(streamTable, columnName)\n\n#### 参数\n\n**streamTable** 是流数据表。\n\n**columnName** 是一个字符串。\n\n#### 详情\n\n指定流数据表的过滤列。该函数需要配合 [subscribeTable](https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html) 函数的 *filter* 参数一起使用。*filter* 是一个向量，*streamTable* 的 *columnName* 列在 *filter* 中的数据才会发布到订阅端，不在 *filter* 中的数据不会发布。一个流数据表只能指定一个过滤列。\n\n#### 例子\n\n下例中，指定了流数据表 trades 的 symbol 列为过滤列，同一节点上的表 trades\\_slave 订阅流数据表 trades 时把 filter 设置为 \\[\"IBM\", \"GOOG\"]，即流数据表 trades 的 symbol 为 \"IBM\" 或 \"GOOG\" 时才会发布到订阅端。\n\n```\nshare streamTable(10000:0,`time`symbol`price, [TIMESTAMP,SYMBOL,INT]) as trades\nsetStreamTableFilterColumn(trades, `symbol)\ntrades_1=table(10000:0,`time`symbol`price, [TIMESTAMP,SYMBOL,INT])\n\nfilter=symbol(`IBM`GOOG)\n\nsubscribeTable(tableName=`trades, actionName=`trades_1, handler=append!{trades_1}, msgAsTable=true, filter=filter);\n```\n"
    },
    "setStreamTableTimestamp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setstreamtabletimestamp.html",
        "signatures": [
            {
                "full": "setStreamTableTimestamp(streamTable, columnName)",
                "name": "setStreamTableTimestamp",
                "parameters": [
                    {
                        "full": "streamTable",
                        "name": "streamTable"
                    },
                    {
                        "full": "columnName",
                        "name": "columnName"
                    }
                ]
            }
        ],
        "markdown": "### [setStreamTableTimestamp](https://docs.dolphindb.cn/zh/funcs/s/setstreamtabletimestamp.html)\n\n#### 语法\n\nsetStreamTableTimestamp(streamTable, columnName)\n\n#### 详情\n\n为指定的流数据表设置一个时间戳列（支持所有时间类型）。设置后，每次向流表写入数据时，系统会记录写入时的系统时间到该时间戳列。这有助于用户统计实时数据写入流表时的延迟。\n\n注意：设置后不可更改和撤销时间戳列。\n\n#### 参数\n\n**streamTable** 流数据表。可以是普通流表、共享流表、持久化流表和高可用流表。\n\n**columnName** 一个字符串，是流数据表最后一列的列名。该列用于记录数据写入流表的系统时间。\n\n#### 例子\n\n```\nshare streamTable(10000:0,`time`symbol`price`timestamp, [TIMESTAMP,SYMBOL,DOUBLE,TIMESTAMP]) as trades\n//指定 timestamp 列为时间戳列\nsetStreamTableTimestamp(trades, `timestamp)\n\n//插入的数据中不能包含 timestamp 列，系统会自动为其添加时间戳。\ninsert into trades values(2023.03.19T03:17:49, `A, 10.2)\n\nselect * from trades\n            \n```\n\n| time                    | symbol | price | timestamp               |\n| ----------------------- | ------ | ----- | ----------------------- |\n| 2023.03.19 03:17:49.000 | A      | 10.2  | 2024.03.31 08:01:31.324 |\n\n"
    },
    "setSystem": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setSystem.html",
        "signatures": [
            {
                "full": "setSystem(paramName, paramValue)",
                "name": "setSystem",
                "parameters": [
                    {
                        "full": "paramName",
                        "name": "paramName"
                    },
                    {
                        "full": "paramValue",
                        "name": "paramValue"
                    }
                ]
            }
        ],
        "markdown": "### [setSystem](https://docs.dolphindb.cn/zh/funcs/s/setSystem.html)\n\n\n\n#### 语法\n\nsetSystem(paramName, paramValue)\n\n#### 参数\n\n**paramName** 是参数名，**paramValue** 是对应的参数值。\n\n#### 详情\n\n`setSystem` 用于设置以下的系统级参数：\n\n* 在命令行窗口显示的对象的最大行数\n\n* 在命令行窗口显示的对象的最大行宽\n\n只有管理员有权限执行 `setSystem` 命令。\n\n#### 例子\n\n```\nsetSystem(\"rows\", 30);\nsetSystem(\"width\", 200);\n```\n"
    },
    "setTableComment": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/settablecomment.html",
        "signatures": [
            {
                "full": "setTableComment(table, comment)",
                "name": "setTableComment",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "comment",
                        "name": "comment"
                    }
                ]
            }
        ],
        "markdown": "### [setTableComment](https://docs.dolphindb.cn/zh/funcs/s/settablecomment.html)\n\n\n\n#### 语法\n\nsetTableComment(table, comment)\n\n#### 参数\n\n**table** 是一个分布式表。\n\n**comment** 字符串标量，表示表注释。长度不可超过 4096 字节。\n\n#### 详情\n\n给分布式表添加注释，表注释可通过函数 [schema](https://docs.dolphindb.cn/zh/funcs/s/schema.html) 查看。\n\n#### 例子\n\n```\n// 创建分布式表\ndb = database(directory=\"dfs://testDB\", partitionType=VALUE, partitionScheme=1..5)\nschemaTB = table(1..5 as id, take(`A`B`C,5) as sym, rand(10.0,5) as price)\npt = db.createPartitionedTable(table=schemaTB, tableName=\"pt\", partitionColumns=\"id\")\n\n// 设置表的注释\nsetTableComment(table=pt, comment=\"my first pt\")\n\n// 通过 schema 查看\nschema(pt)[\"tableComment\"]\n// output：'my first pt'\n```\n"
    },
    "setTimeoutTick": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setTimeoutTick.html",
        "signatures": [
            {
                "full": "setTimeoutTick(tick)",
                "name": "setTimeoutTick",
                "parameters": [
                    {
                        "full": "tick",
                        "name": "tick"
                    }
                ]
            }
        ],
        "markdown": "### [setTimeoutTick](https://docs.dolphindb.cn/zh/funcs/s/setTimeoutTick.html)\n\n\n\n#### 语法\n\nsetTimeoutTick(tick)\n\n别名： setDfsChunkNodeHeartBeatTimeoutTick\n\n#### 参数\n\n**tick** 一个正整数，表示超时时间，单位为秒。\n\n#### 详情\n\n动态设置控制节点判断数据节点是否在线的超时时间。该命令只能由管理员在控制节点上执行。若为高可用集群，则需要在 raft 组的每个控制节点上执行该命令。\n\n**Note:** 此命令修改的配置值在集群重启后将失效。若需要配置值永久生效，请更改配置文件中的 *dfsChunkNodeHeartBeatTimeout* 。\n"
    },
    "setTSDBCacheEngineSize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/setTSDBCacheEngineSize.html",
        "signatures": [
            {
                "full": "setTSDBCacheEngineSize(memSize)",
                "name": "setTSDBCacheEngineSize",
                "parameters": [
                    {
                        "full": "memSize",
                        "name": "memSize"
                    }
                ]
            }
        ],
        "markdown": "### [setTSDBCacheEngineSize](https://docs.dolphindb.cn/zh/funcs/s/setTSDBCacheEngineSize.html)\n\n\n\n#### 语法\n\nsetTSDBCacheEngineSize(memSize)\n\n#### 参数\n\n**memSize** 一个数值型标量（单位为GB），必须大于0且小于 *maxMemSize* \\* 0.75。\n\n#### 详情\n\n用于在线修改 TSDB 引擎的 Cache Engine 容量。集群环境下，该命令只能由管理员在数据节点/计算节点上执行。执行前需要确保开启了 Cache Enigne (配置参数 *TSDBCacheEngineSize* )。可以通过 `getTSDBCacheEngineSize` 查看设置是否生效。\n\n**Note:**\n\n此命令修改的配置值在集群重启后将失效。若需要配置值永久生效，请更改配置文件中的 *TSDBCacheEngineSize*。\n\n**首发版本**：2.00.4\n\n相关函数： [getTSDBCacheEngineSize](https://docs.dolphindb.cn/zh/funcs/g/getTSDBCacheEngineSize.html)\n"
    },
    "shape": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/shape.html",
        "signatures": [
            {
                "full": "shape(X)",
                "name": "shape",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [shape](https://docs.dolphindb.cn/zh/funcs/s/shape.html)\n\n\n\n#### 语法\n\nshape(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n以数据对的形式返回标量、向量或矩阵的维度。\n\n#### 例子\n\n标量的维度总是 1:1\n\n```\nshape 1;\n// output\n1:1\n\ns;\n```\n\n向量的维度总是向量长度:1\n\n```\nshape 1 5 3 7 8;\n// output\n5:1\n```\n\n矩阵的维度\n\n```\nm=(5 3 1 4 9 10)$3:2;\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 5  | 4  |\n| 3  | 9  |\n| 1  | 10 |\n\n```\nshape m;\n\n// output\n3 :2\n```\n\n表的维度\n\n```\nt=table(1 2 3 as x, 4 5 6 as y);\nt;\n```\n\n| x | y |\n| - | - |\n| 1 | 4 |\n| 2 | 5 |\n| 3 | 6 |\n\n```\nshape t;\n// output\n3 :2\n```\n"
    },
    "shapiroTest": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/shapiroTest.html",
        "signatures": [
            {
                "full": "shapiroTest(X)",
                "name": "shapiroTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [shapiroTest](https://docs.dolphindb.cn/zh/funcs/s/shapiroTest.html)\n\n\n\n#### 语法\n\nshapiroTest(X)\n\n#### 参数\n\n**X** 是一个数值向量，表示样本。\n\n#### 详情\n\n对样本数据进行 Shapiro-Wilk 检验。返回的结果是一个字典，包含以下 key：\n\n* method ：字符串 \"Shapiro-Wilk normality test\"\n\n* pValue ：p 值\n\n* W ：W 统计量\n\n#### 例子\n\n```\nx = norm(0.0, 1.0, 50)\nshapiroTest(x);\n\n// output\nmethod->Shapiro-Wilk normality test\npValue->0.621668\nW->0.981612\n```\n"
    },
    "share": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/share.html",
        "signatures": [
            {
                "full": "share(table, sharedName, [database], [dbName], [partitionColumn], [readonly=false])",
                "name": "share",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "sharedName",
                        "name": "sharedName"
                    },
                    {
                        "full": "[database]",
                        "name": "database",
                        "optional": true
                    },
                    {
                        "full": "[dbName]",
                        "name": "dbName",
                        "optional": true
                    },
                    {
                        "full": "[partitionColumn]",
                        "name": "partitionColumn",
                        "optional": true
                    },
                    {
                        "full": "[readonly=false]",
                        "name": "readonly",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [share](https://docs.dolphindb.cn/zh/funcs/s/share.html)\n\n\n\n#### 语法\n\nshare(table, sharedName, \\[database], \\[dbName], \\[partitionColumn], \\[readonly=false])\n\n#### 参数\n\n**table** 是要在会话中共享的表或引擎。\n\n**sharedName** 是在会话中共享表的名称，或共享的分布式表的名称。\n\n**database** 是数据库句柄。当该参数是用 [database](https://docs.dolphindb.cn/zh/funcs/d/database.html) 函数定义时，它需要指定每个分区的名称。\n\n**dbName** 是分布式数据库的名称。\n\n**partitionColumn** 是分布式表的分区列。\n\n**readonly** 是一个布尔值，表示是否将普通/键值/索引内存表共享为一个只读的内存表，以提升读取和查询时的性能。默认值为 false。\n\n#### 详情\n\n如果只有 *table* 和 *sharedName* 两个参数:\n\n* *table* 是表时，以指定名称在会话中共享表。包括表在内的本地对象在其他会话中不可见的。只有通过共享，它们才能在其他会话中可见。共享表的名称必须与会话中的普通表的名称不同。一般来说，共享的流数据表不支持删除和更新记录，但是 [table](https://docs.dolphindb.cn/zh/funcs/t/table.html) 和 [mvccTable](https://docs.dolphindb.cn/zh/funcs/m/mvccTable.html) 函数创建的表共享后支持删除和更新记录。所有的共享表都支持插入记录。\n\n* *table* 是引擎时，会对引擎增加写入锁，以实现对引擎的并发写入。\n\n如果使用了5个参数，填充分布式表的碎片，然后以指定名称在会话中共享。分区碎片是以给定列为基础。我们可以使用多个 *share* 语句在多个节点之间保存分区表。\n\n请注意，不可以将同一个流数据表通过修改共享变量名称的方式共享2次及以上。\n\n#### 例子\n\n```\nshare(t, `sharedT);\nshare(t, `quotes, tickDB, `tickDB, `date);\ntrades = streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE])\nshare table(100:0, `sym`time`factor1, [SYMBOL, TIMESTAMP, DOUBLE]) as outputTable\nengine = createReactiveStateEngine(name=\"test\", metrics=[<time>, <mavg(price, 3)>], dummyTable=trades, outputTable=outputTable, keyColumn=`sym)\n# 将引擎 engine 共享\nshare(engine, \"test\")\n\n# 第一个自定义函数，向 engine 写入数据\ndef write1(mutable engine) {\n\tN = 10\n\tfor (i in 1..500) {\n\t\tdata = table(take(now(), N) as time, take(`A`B, N) as sym, rand(10.0, N) as price)\n\t\tengine.append!(data)\n\t}\n}\n# 第二个自定义函数，向 engine 写入数据\ndef write2(mutable engine) {\n\tN = 10\n\tfor (i in 1..500) {\n\t\tdata = table(take(now(), N) as time, take(`C`D, N) as sym, rand(10.0, N) as price)\n\t\tengine.append!(data)\n\t}\n}\n# 提交作业，使 write1 和 write2 同时向引擎写入数据\nsubmitJob(\"j1\", \"j1\", write1, engine)\nsubmitJob(\"j2\", \"j2\", write2, engine)\n# 查看输出表中数据行数为 10000，正好是 write1 和 write2 写入的数据量之和。\nselect count(*) from outputTable \n// output\n10,000\n```\n"
    },
    "shell": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/shell.html",
        "signatures": [
            {
                "full": "shell(cmd)",
                "name": "shell",
                "parameters": [
                    {
                        "full": "cmd",
                        "name": "cmd"
                    }
                ]
            }
        ],
        "markdown": "### [shell](https://docs.dolphindb.cn/zh/funcs/s/shell.html)\n\n\n\n#### 语法\n\nshell(cmd)\n\n#### 参数\n\n**cmd** 是字符串，表示操作系统命令。\n\n#### 详情\n\n执行操作系统命令。该函数只能在配置参数 enableShellFunction 设置为 true 时，由 DolphinDB 系统管理员执行。\n\n#### 例子\n\n调用对应操作系统的 `system()` 函数。若 *cmd* 成功被执行，系统会返回 0。其它返回值请参阅相应操作系统的 `system()` 函数返回值。\n\n```\ncmd=\"rm -rf /home/user1/test.txt\"\nshell(cmd);\n```\n"
    },
    "short": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/short.html",
        "signatures": [
            {
                "full": "short(X)",
                "name": "short",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [short](https://docs.dolphindb.cn/zh/funcs/s/short.html)\n\n\n\n#### 语法\n\nshort(X)\n\n#### 详情\n\n将输入的数据类型转换为 SHORT。\n\n#### 参数\n\n**x** 可以是任意数据类型。\n\n#### 例子\n\n```\nx=short();\nx;\n```\n\n返回：null\n\n```\ntypestr x;\n```\n\n返回：SHORT\n\n```\nshort(`12.3);\n```\n\n返回：12\n\n```\nshort(`120.9c);\n```\n\n返回：120\n\n```\nshort(32767);\n```\n\n返回：32,767\n\n**Note:** SHORT 数据类型的范围是\\[ -215+1, 215 -1] = \\[-32767, 32767]。如果 *X* 超出了该范围，将会发生[溢出](https://docs.dolphindb.cn/zh/progr/data_types.md#section_oxj_hty_jxb)。\n\n```\nshort(32768);\n//Output\nnull\n\nshort(65578);\n//Output\n42\n\nshort(32789)\n//Output\n-32747\n```\n"
    },
    "shuffle": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/shuffle.html",
        "signatures": [
            {
                "full": "shuffle(X)",
                "name": "shuffle",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [shuffle](https://docs.dolphindb.cn/zh/funcs/s/shuffle.html)\n\n\n\n#### 语法\n\nshuffle(X)\n\nshuffle! 是 shuffle 的原地计算的版本。\n\n#### 参数\n\n**x** 可以是向量或矩阵。\n\n#### 详情\n\n对数据重组后，返回一个新的向量或矩阵。\n\n#### 例子\n\n```\nx=(1..6).shuffle();\nx;\n// output\n[1,6,3,5,4,2]\n\nx.shuffle!();\n// output\n[5,4,1,3,2,6]\n\n\nx=(1..6).reshape(3:2);\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nx.shuffle();\n```\n\n| #0 | #1 |\n| -- | -- |\n| 5  | 3  |\n| 2  | 1  |\n| 4  | 6  |\n"
    },
    "shuffle!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/shuffle_.html",
        "signatures": [
            {
                "full": "shuffle(X)",
                "name": "shuffle",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [shuffle!](https://docs.dolphindb.cn/zh/funcs/s/shuffle_.html)\n\n是 [shuffle](https://docs.dolphindb.cn/zh/funcs/s/shuffle.html) 的别名。\n\nshuffle! 是 shuffle 的原地计算的版本。\n\n\n以下是 `shuffle` 函数的文档：\n### [shuffle](https://docs.dolphindb.cn/zh/funcs/s/shuffle.html)\n\n\n\n#### 语法\n\nshuffle(X)\n\nshuffle! 是 shuffle 的原地计算的版本。\n\n#### 参数\n\n**x** 可以是向量或矩阵。\n\n#### 详情\n\n对数据重组后，返回一个新的向量或矩阵。\n\n#### 例子\n\n```\nx=(1..6).shuffle();\nx;\n// output\n[1,6,3,5,4,2]\n\nx.shuffle!();\n// output\n[5,4,1,3,2,6]\n\n\nx=(1..6).reshape(3:2);\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nx.shuffle();\n```\n\n| #0 | #1 |\n| -- | -- |\n| 5  | 3  |\n| 2  | 1  |\n| 4  | 6  |\n"
    },
    "signbit": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/signbit.html",
        "signatures": [
            {
                "full": "signbit(X)",
                "name": "signbit",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [signbit](https://docs.dolphindb.cn/zh/funcs/s/signbit.html)\n\n#### 语法\n\nsignbit(X)\n\n#### 参数\n\n**X**：一个整型或者浮点型的标量。\n\n#### 详情\n\n获取输入数据的符号位。\n\n返回值：负号返回 ture；正号返回 false。\n\n#### 例子\n\n```\nsignbit('a')\nfalse\n\nsignbit(-21)\ntrue\n\nsignbit(-2.1)\ntrue\n\nb=complex(10,-5)//创建一个复数\nb\n10.0-5.0i\nsignbit(highDouble(b)) //判断虚部符号\ntrue\n\nsignbit(lowDouble(b))  //判断实部符号\nfalse\n```\n\n"
    },
    "signum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/signum.html",
        "signatures": [
            {
                "full": "signum(X)",
                "name": "signum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [signum](https://docs.dolphindb.cn/zh/funcs/s/signum.html)\n\n\n\n#### 语法\n\nsignum(X)\n\n别名：sign\n\n#### 参数\n\n**X** 是布尔值或数值类型的标量、向量或矩阵。\n\n#### 详情\n\n返回 *X* 的符号标志。如果 *X* 为正数，返回1； 如果 *X* 为0，返回0；如果 *X* 为负数，返回-1；如果 *X* 中元素为 NULL，则返回 NULL。\n\n#### 例子\n\n```\nsignum(8.2 0 -6 NULL);\n// output\n[1,0,-1, ]\n```\n"
    },
    "sin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sin.html",
        "signatures": [
            {
                "full": "sin(X)",
                "name": "sin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html)\n\n\n\n#### 语法\n\nsin(X)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n#### 详情\n\n返回 *X* 的正弦。\n\n#### 例子\n\n```\nsin(1 2 3);\n// output\n[0.841471,0.909297,0.141120]\n```\n\n相关函数：[asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html), [acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html), [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html), [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html), [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html), [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html), [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html), [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html), [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html), [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html), [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n"
    },
    "sinh": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sinh.html",
        "signatures": [
            {
                "full": "sinh(X)",
                "name": "sinh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html)\n\n\n\n#### 语法\n\nsinh(X)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n#### 详情\n\n返回 *X* 的双曲正弦。\n\n#### 例子\n\n```\nsinh 1 2 3;\n// output\n[1.175201,3.62686,10.017875]\n```\n\n相关函数：[asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html), [acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html), [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html), [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html), [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html), [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html), [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html), [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html), [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html), [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html), [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n"
    },
    "snippet": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sinppet.html",
        "signatures": [
            {
                "full": "snippet(X)",
                "name": "snippet",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [snippet](https://docs.dolphindb.cn/zh/funcs/s/sinppet.html)\n\n\n\n#### 语法\n\nsnippet(X)\n\n#### 参数\n\n**X** 任意数据。\n\n#### 详情\n\n获取打印结果。返回一个字符串标量。\n\n#### 例子\n\n```\na = [[\"a\",\"b\"],\"c\"]\nsnippet(a)\n//output\n\"([\"a\",\"b\"],\"c\")\"\n\nsnippet(date(2023.01.01))\n//output\n\"2023.01.01\"\n```\n"
    },
    "size": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/size.html",
        "signatures": [
            {
                "full": "size(X)",
                "name": "size",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [size](https://docs.dolphindb.cn/zh/funcs/s/size.html)\n\n\n\n#### 语法\n\nsize(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n对于向量或矩阵，`size` 返回元素的个数，而 [count](https://docs.dolphindb.cn/zh/funcs/c/count.html) 返回的是非 NULL 元素个数。\n\n对于内存表，`size` 返回行数。\n\n#### 例子\n\n```\nsize(3 NULL 5 6);\n// output\n4\ncount(3 NULL 5 6);\n// output\n3\n\nm=1 2 3 NULL 4 5$2:3;\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 4  |\n| 2  |    | 5  |\n\n```\nsize(m);\n// output\n6\n\ncount(m);\n// output\n5\n\nt = table(1 NULL 3 as id, 3 NULL 9 as qty);\nt;\n```\n\n| id | qty |\n| -- | --- |\n| 1  | 3   |\n|    |     |\n| 3  | 9   |\n\n```\nsize(t);\n// output\n3\n\ncount(t);\n// output\n3\n```\n"
    },
    "skew": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/skew.html",
        "signatures": [
            {
                "full": "skew(X, [biased=true])",
                "name": "skew",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [skew](https://docs.dolphindb.cn/zh/funcs/s/skew.html)\n\n\n\n#### 语法\n\nskew(X, \\[biased=true])\n\n#### 参数\n\n**X** 是一个向量、矩阵或表。\n\n**biased** 是一个布尔值，表示是否为有偏估计。默认值为 true，表示为有偏估计。**biased**\n\n值为 false ，表示无偏估计。\n\n#### 详情\n\n计算 *X* 的倾斜度。`skew` 函数在计算时会忽略 NULL 值。\n\nDolphinDB 使用以下公式计算倾斜度：\n\n* 当 *biased*=true 时，\n\n  ![](https://docs.dolphindb.cn/zh/images/rowskewx.png)\n\n* 当 *biased*= false 时\n\n  ![](https://docs.dolphindb.cn/zh/images/skew.png)\n\n若 *X* 为矩阵，计算每列的倾斜度，返回一个向量。\n\n若 *X* 为表，计算每列的倾斜度，返回一个表。\n\n`skew` 函数也支持校正偏差查询分区表和分布式表。\n\n#### 例子\n\n下面的例子使用了 [norm](https://docs.dolphindb.cn/zh/funcs/n/norm.html) 函数生成数据，每次生成的数据都会有细微差别，因此每次计算的结果会有所偏差。\n\n```\nx=norm(0, 1, 1000000);\nskew(x);\n```\n\n返回：-0.00124\n\n```\nx[0]=100;\nskew(x);\n```\n\n返回：0.983656\n\n```\nm=matrix(1..10, 1 2 3 4 5 6 7 8 9 100);\nm;\n```\n\n返回：\n\n| #0 | #1  |\n| -- | --- |\n| 1  | 1   |\n| 2  | 2   |\n| 3  | 3   |\n| 4  | 4   |\n| 5  | 5   |\n| 6  | 6   |\n| 7  | 7   |\n| 8  | 8   |\n| 9  | 9   |\n| 10 | 100 |\n\n```\nskew(m);\n```\n\n返回：\\[0,2.630083823883674]\n"
    },
    "skipClusterReplicationTask": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/skipClusterReplicationTask.html",
        "signatures": [
            {
                "full": "skipClusterReplicationTask(taskIds)",
                "name": "skipClusterReplicationTask",
                "parameters": [
                    {
                        "full": "taskIds",
                        "name": "taskIds"
                    }
                ]
            }
        ],
        "markdown": "### [skipClusterReplicationTask](https://docs.dolphindb.cn/zh/funcs/s/skipClusterReplicationTask.html)\n\n\n\n#### 语法\n\nskipClusterReplicationTask(taskIds)\n\n#### 参数\n\n`taskIds` 标量或向量，表示待跳过的异步复制任务的 id（通过函数 [getMasterReplicationStatus](https://docs.dolphindb.cn/zh/funcs/g/getMasterReplicationStatus.html) 获取）。\n\n#### 详情\n\n用于跳过异步复制任务（通常是由于执行异常导致异步复制停止的任务）。该命令只能由管理员在从集群的控制节点调用。\n\n调用该命令前，需先将集群的异步复制流程暂停（调用 [stopClusterReplication](https://docs.dolphindb.cn/zh/funcs/s/stopClusterReplication.html) 函数）。执行完该命令后，再重启异步复制（调用 [startClusterReplication](https://docs.dolphindb.cn/zh/funcs/s/startClusterReplication.html) 命令）。跳过的任务会被标记为完成状态。\n\n#### 例子\n\n```\nskipClusterReplicationTask(1);\n```\n\n相关函数： [startClusterReplication](https://docs.dolphindb.cn/zh/funcs/s/startClusterReplication.html), [stopClusterReplication](https://docs.dolphindb.cn/zh/funcs/s/stopClusterReplication.html)\n"
    },
    "sleep": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sleep.html",
        "signatures": [
            {
                "full": "sleep(X)",
                "name": "sleep",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sleep](https://docs.dolphindb.cn/zh/funcs/s/sleep.html)\n\n\n\n#### 语法\n\nsleep(X)\n\n#### 参数\n\n**X** 是一个非负数。\n\n#### 详情\n\n暂停程序 *X* 毫秒。\n\n#### 例子\n\n```\nfor(s in 1:10){\n   sleep(1000)\n   print(s+\" seconds passed.\")\n};\n\n// output\n1 seconds passed.\n2 seconds passed.\n3 seconds passed.\n4 seconds passed.\n5 seconds passed.\n6 seconds passed.\n7 seconds passed.\n8 seconds passed.\n9 seconds passed.\n```\n"
    },
    "slice": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/slice.html",
        "signatures": [
            {
                "full": "slice(obj, index)",
                "name": "slice",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "index",
                        "name": "index"
                    }
                ]
            },
            {
                "full": "slice(obj, rowIndex, [colIndex])",
                "name": "slice",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "rowIndex",
                        "name": "rowIndex"
                    },
                    {
                        "full": "[colIndex]",
                        "name": "colIndex",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [slice](https://docs.dolphindb.cn/zh/funcs/s/slice.html)\n\n\n\n#### 语法\n\nslice(obj, index)\n\n或\n\nslice(obj, rowIndex, \\[colIndex])\n\n相当于obj\\[index]或obj\\[rowIndex, colIndex]\n\n#### 参数\n\n**obj** 可以是数组向量、矩阵或表。\n\n**index**, **rowIndex** 和 **colIndex** 可以是标量、向量或数据对，表示行或列的下标。如果 *index*, *rowIndex* 或 *colIndex* 为数据对，那么它表示下标的范围，上边界不包含在内。\n\n#### 详情\n\n对于第一种用法：\n\n* 如果 *obj* 是一个数组向量，\n\n  * *index* 是标量，返回指定的列，用向量表示。\n\n  * *index* 是向量，返回指定行组成的数组向量。\n\n  * *index* 是数据对，返回指定列组成的数组向量。\n\n* 如果 *obj* 是一个矩阵，\n\n  * *index* 是标量，返回指定的列，用向量表示。\n\n  * *index* 是向量或数据对，返回指定列组成的子矩阵。\n\n* 如果 *obj* 是一个表，\n\n  * *index* 是标量，返回指定的行，用字典表示。\n\n  * *index* 是向量或数据对，返回指定行组成的子表。\n\n对于第二种用法：\n\n* 如果 *obj* 是一个数组向量，\n\n  * *rowIndex* 和 *colIndex* 都是标量，返回指向行列的值，用向量表示。\n\n  * *rowIndex* 是标量，*colIndex* 是数据对，返回由指定行列组成的数组向量。\n\n  * *rowIndex* 是数据对，*colIndex* 是标量，返回由指定行列组成的向量。\n\n  * *rowIndex* 和 *colIndex* 都是数据对，返回由指定行列组成的数组向量。\n\n* 如果 *obj* 是一个矩阵，\n\n  * *rowIndex* 和 *colIndex* 都是标量，返回指定行列的值，用标量表示。\n\n  * *rowIndex* 和 *colIndex* 中一个是标量，另一个是数据对，返回由指定行列组成的子矩阵。\n\n  * *rowIndex* 和 *colIndex* 都是向量或数据对，返回指定行列组成的子矩阵。\n\n* 如果 *obj* 是一个表，\n\n  * *rowIndex* 和 *colIndex* 都是标量，返回指定行列的值，用标量表示。\n\n  * *rowIndex* 和 *colIndex* 中一个是标量，另一个是数据对，返回指定行列组成的子表。\n\n  * *rowIndex* 和 *colIndex* 都是向量或数据对，返回指定行列组成的子表。\n\n**Note:**\n\n*index*, *rowIndex*，*collIndex* 作为数组向量或矩阵的索引值或索引范围时，若其值不在 \\[0, size(X)-1] 内，则超出 \\[0, size(X)-1] 的值所对应的位置返回空值。\n\n#### 例子\n\n例1. 矩阵\n\n```\nm=1..9$3:3\nm.slice(0);\n[1,2,3]\n\nm.slice([0]);\n```\n\n| #0 |\n| -- |\n| 1  |\n| 2  |\n| 3  |\n\n```\nm.slice(0:2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nm.slice(0 2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 7  |\n| 2  | 8  |\n| 3  | 9  |\n\n```\nm.slice(0,1);\n// output\n4\n\nm.slice(0 1,0 1);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n\n```\nm.slice(1:2,1:2);\n```\n\n| #0 |\n| -- |\n| 5  |\n\n例2. 表\n\n```\nt=table(`A`B`C as sym,2018.01.01..2018.01.03 as date,10 48 5 as val)\nt.slice(0);\n\n// output\nval->10\ndate->2018.01.01\nsym->A\nt.slice([0]);\n```\n\n| sym | date       | val |\n| --- | ---------- | --- |\n| A   | 2018.01.01 | 10  |\n\n```\nt.slice(0 1);\n```\n\n| sym | date       | val |\n| --- | ---------- | --- |\n| A   | 2018.01.01 | 10  |\n| B   | 2018.01.02 | 48  |\n\n```\nt.slice(0:1);\n```\n\n| sym | date       | val |\n| --- | ---------- | --- |\n| A   | 2018.01.01 | 10  |\n\n```\nt.slice(0,1);\n// output\n2018.01.01\n\nt.slice(0 1,0 1);\n```\n\n| sym | date       |\n| --- | ---------- |\n| A   | 2018.01.01 |\n| B   | 2018.01.02 |\n\n```\nt.slice(1:2,1:2);\n```\n\n| date       |\n| ---------- |\n| 2018.01.02 |\n\n例3. 数组向量\n\n```\nav =array(DOUBLE[], 0, 10).append!([1.0, 2.1 4.1 6.8, 0.5 2.2 2]);\nav[1]\n// output\n[,4.1,2.2]\nav[1,1]\n// output\n[4.1]\nav[1:3,1:3]\n// output\n[[4.1,6.8],[2.2,2]]\n```\n"
    },
    "sliceByKey": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sliceByKey.html",
        "signatures": [
            {
                "full": "sliceByKey(table, rowKeys, [colNames])",
                "name": "sliceByKey",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "rowKeys",
                        "name": "rowKeys"
                    },
                    {
                        "full": "[colNames]",
                        "name": "colNames",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sliceByKey](https://docs.dolphindb.cn/zh/funcs/s/sliceByKey.html)\n\n\n\n#### 语法\n\nsliceByKey(table, rowKeys, \\[colNames])\n\n#### 参数\n\n**table** 是键值表或索引内存表。\n\n**rowKeys** 是标量或向量，表示索引列的指定值。\n\n**colNames** 是字符串标量或向量，表示要选择的列的列名。\n\n#### 详情\n\n从键值表或索引内存表中获取含有索引列指定值（由参数 *rowKeys* 指定）的行以及指定列（由 *colNames* 参数指定）的数据。耗时约为相应的 SQL 语句的50%。\n\n如果是键值表，*rowKeys* 参数必须含有所有 *keyColumns* 的值。\n\n如果是索引内存表，可指定前 n 个 *keyColumns* 的值，若其中有一列指定值为向量，所有指定列的指定值均需为同等长度的向量。\n\n若不指定 *colNames* 参数，则会输出所有列。\n\n结果的数据结构取决于 *colNames*。若 *colNames* 为标量，返回一个向量；若 *colNames* 为向量，返回一个内存表。\n\n#### 例子\n\n```\nt = indexedTable(`sym`side, 10000:0, `sym`side`price`qty, [SYMBOL,CHAR,DOUBLE,INT])\ninsert into t values(`IBM`MSFT`IBM, ['B','S','S'], 125.27 208.9 125.29, 1000 800 200)\na=sliceByKey(t,\"IBM\", 'price');\n\na;\n// output\n[125.27,125.29]\n\ntypestr(a);\n// output\nFAST DOUBLE VECTOR\n\na=sliceByKey(t,(\"IBM\",'S'));\na;\n```\n\n| sym | side | price  | qty |\n| --- | ---- | ------ | --- |\n| IBM | S    | 125.29 | 200 |\n\n```\ntypestr(a);\n// output\nIN-MEMORY TABLE\n\nt1 = keyedTable(`sym`side, 10000:0, `sym`side`price`qty, [SYMBOL,CHAR,DOUBLE,INT])\ninsert into t1 values(`IBM`MSFT`IBM, ['B','S','S'], 125.27 208.9 125.29, 1000 800 200)\nsliceByKey(t1, [[\"IBM\", \"MSFT\"], ['B', 'S']]);\n```\n\n| sym  | side | price  | qty  |\n| ---- | ---- | ------ | ---- |\n| IBM  | B    | 125.27 | 1000 |\n| MSFT | S    | 208.9  | 800  |\n"
    },
    "sma": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sma.html",
        "signatures": [
            {
                "full": "sma(X, window)",
                "name": "sma",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [sma](https://docs.dolphindb.cn/zh/funcs/s/sma.html)\n\n\n\n#### 语法\n\nsma(X, window)\n\nTA-lib 系列函数参数说明和窗口计算规则请参考：[TAlib](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的简单移动平均（Simple Moving Average）。\n\n其计算公式为：\n\n![](https://docs.dolphindb.cn/zh/images/sma.png)\n\n#### 例子\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\nsma(x,3);\n// output\n[,,12.299999999999998,12.533333333333331,12.433333333333331,12.099999999999999,11.566666666666664]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\nsma(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n| 12.3    | 15.6667 |\n| 12.5333 | 17.3333 |\n| 12.4333 | 19.3333 |\n| 12.1    | 17.3333 |\n| 11.5667 | 14.3333 |\n\n相关函数：[wma](https://docs.dolphindb.cn/zh/funcs/w/wma.html), [trima](https://docs.dolphindb.cn/zh/funcs/t/trima.html)\n"
    },
    "socp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/socp.html",
        "signatures": [
            {
                "full": "socp(f, [G], [h], [l], [q], [A], [b])",
                "name": "socp",
                "parameters": [
                    {
                        "full": "f",
                        "name": "f"
                    },
                    {
                        "full": "[G]",
                        "name": "G",
                        "optional": true
                    },
                    {
                        "full": "[h]",
                        "name": "h",
                        "optional": true
                    },
                    {
                        "full": "[l]",
                        "name": "l",
                        "optional": true
                    },
                    {
                        "full": "[q]",
                        "name": "q",
                        "optional": true
                    },
                    {
                        "full": "[A]",
                        "name": "A",
                        "optional": true
                    },
                    {
                        "full": "[b]",
                        "name": "b",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [socp](https://docs.dolphindb.cn/zh/funcs/s/socp.html)\n\n#### 语法\n\nsocp(f, \\[G], \\[h], \\[l], \\[q], \\[A], \\[b])\n\n#### 详情\n\n该函数用于求解二阶锥规划问题，计算目标函数在限定条件下的最小值。若其约束条件以标准形式给出，其形式如下：\n\n![](https://docs.dolphindb.cn/zh/images/socp_standard_format.png)\n\n则矩阵 G 为：\n\n![](https://docs.dolphindb.cn/zh/images/socp_matrix_g.png)\n\n向量 h 为：\n\n![](https://docs.dolphindb.cn/zh/images/socp_h.png)\n\n返回一个长度为 3 的元组：\n\n* 第一个元素表示求解状态：\n  * Problem solved to optimality：达到最优解\n  * Found certificate of primal infeasibility：原始问题无解\n  * Found certificate of dual infeasibility：对偶问题无解\n  * Offset exitflag at inaccurate results：结果不精确\n  * Maximum number of iterations reached ：达到最大迭代次数\n  * Search direction unreliable ：搜索方向不可靠\n  * Unknown problem in solver：求解问题未知\n* 第二个元素是目标函数取最小值时 x 的取值。\n* 第三个元素是目标函数的最小值。\n\n#### 参数\n\n二阶锥规划（Second-Order Cone Programming，SOCP）问题的约束条件形式如下：\n\n![](https://docs.dolphindb.cn/zh/images/socp.png)\n\n其中 K 为锥，s 为松弛变量，其值在优化过程中会被确定。\n\n**f** 是数值型向量，表示目标函数的系数向量。\n\n**G** 是数值型矩阵，表示锥约束的系数矩阵。\n\n**h** 是数值型向量，表示锥约束的右端向量。\n\n**l** 是整数标量，表示非负象限约束的维度。\n\n**q** 是正数向量，表示各个二阶锥约束的维度大小，形式为 \\[r0,r1,…,rN-1]。\n\n**A** 是数值型矩阵，表示等式约束的系数矩阵。\n\n**b** 是数值型向量，表示等式约束的右端向量。\n\n#### 例子\n\n求解以下二阶锥规划问题：\n\n![](https://docs.dolphindb.cn/zh/images/socp_exp.png)\n\n```\nf = [-6, -4, -5]\nG = matrix([[16, 7, 24, -8, 8, -1, 0, -1, 0], \n[-14, 2, 7, -13, -18, 3, 0, 0, -1], \n[5, 0, -15, 12, -6, 17, 0, 0, 0]])\nh = [-3, 5, 12, -2, -14, -13, 10, 0, 0]\n\nl = 2\nq = [4,3]\n\nre = socp(f,G,h,l,q, ,)\nprint(re)\n```\n\n返回：(\"Problem solved to optimality\",\\[-9.902804882871327,-1.39084684264198,26.211851780740154],-66.079042235904907)\n\n"
    },
    "solve": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/solve.html",
        "signatures": [
            {
                "full": "solve(X, Y)",
                "name": "solve",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [solve](https://docs.dolphindb.cn/zh/funcs/s/solve.html)\n\n\n\n#### 语法\n\nsolve(X, Y)\n\n#### 参数\n\n**X** 是矩阵；\n\n**Y** 是向量。\n\n#### 详情\n\n返回线性方程 X\\*b=Y 的解 b。\n\n#### 例子\n\n```\nm=1..4$2:2;\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 3  |\n| 2  | 4  |\n\n```\nm.solve(7 10);\n// output\n[1, 2]\n```\n"
    },
    "sort": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sort.html",
        "signatures": [
            {
                "full": "sort(X, [ascending=true])",
                "name": "sort",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [sort](https://docs.dolphindb.cn/zh/funcs/s/sort.html)\n\n\n\n#### 语法\n\nsort(X, \\[ascending=true])\n\n 是 sort 的原地版本。\n\n#### 参数\n\n**X** 可以是向量。\n\n**ascending** 是一个布尔值，表示按升序排序还是按降序排序。默认值为 true（按升序排序）。\n\n#### 详情\n\n返回一个排序后的向量。\n\n#### 例子\n\n```\nx=9 1 5;\nx;\n// output\n[9,1,5]\n\ny=sort(x);\ny;\n// output\n[1,5,9]\n\nsort(x, false);  // 逆序排序\n// output\n[9,5,1]\n\nx=1 4 2 5 6 3$2:3;\nx;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 2  | 6  |\n| 4  | 5  | 3  |\n\n```\nsort x;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\nsort! 函数排序并修改输入。\n\n```\nx=9 1 5;\nsort!(x);\nx;\n\n[1 5 9];\n```\n\n相关函数：[isort](https://docs.dolphindb.cn/zh/funcs/i/isort.html)\n"
    },
    "sortBy!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sortBy_.html",
        "signatures": [
            {
                "full": "sortBy!(table, sortColumns, [sortDirections])",
                "name": "sortBy!",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "sortColumns",
                        "name": "sortColumns"
                    },
                    {
                        "full": "[sortDirections]",
                        "name": "sortDirections",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sortBy!](https://docs.dolphindb.cn/zh/funcs/s/sortBy_.html)\n\n\n\n#### 语法\n\nsortBy!(table, sortColumns, \\[sortDirections])\n\n#### 参数\n\n**table** 是 DolphinDB 中 Table 类型的表。它可以是分区或未分区的内存表。\n\n**sortColumns** 是一个字符串标量或向量，表示某列，该表按照该列进行排序。它也可以是表达式的元代码。\n\n**sortDirections** 是一个布尔值，表示排序方向。1表示按照升序排序，0表示按照降序排序。如果 *sortColumns* 是向量而 *sortDirections* 是标量，那么所有的排序列都根据 *sortDirections* 表示的排序方向排序。\n\n#### 详情\n\n根据指定列和指定的排序方向对一个表进行就地排序。如果是分区表，将对每个分区进行排序，而不是对整个表进行排序。\n\n如果 table 是分区表并且启用了并行处理功能（即配置参数 localExcutors > 0），那么该操作是并行操作。\n\n#### 例子\n\n对未分区表进行排序：\n\n```\nn=20000000\ntrades=table(rand(`IBM`MSFT`GM`C`YHOO`GOOG,n) as sym, 2000.01.01+rand(365,n) as date, 10.0+rand(2.0,n) as price, rand(1000,n) as qty);\ntrades.sortBy!(`sym`date, [0,1]);\n```\n\n对分区表进行排序：\n\n```\nworkDir = \"C:/DolphinDB/Data\"\nif(!exists(workDir)) mkdir(workDir)\ntrades.saveText(workDir + \"/trades.txt\")\ndb = database(workDir + \"/trade\",VALUE,`IBM`MSFT`GM`C`YHOO`GOOG)\ndb.loadTextEx(\"trades\",\"sym\", workDir + \"/trades.txt\")\ntrades = db.loadTable(\"trades\",`IBM`GM`YHOO,1)\ntrades.sortBy!(`date)\ntrades.sortBy!(`date, false)\ntrades.sortBy!(`date`qty, false)\ntrades.sortBy!(`date`qty, false true)\ntrades.sortBy!(<qty*price>)\ntrades.sortBy!(<[date, sym]>)\ntrades.sortBy!(<[sym, qty*price]>, true false)\n```\n"
    },
    "sort!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sort_.html",
        "signatures": [
            {
                "full": "sort!(X, [ascending=true])",
                "name": "sort!",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [sort!](https://docs.dolphindb.cn/zh/funcs/s/sort_.html)\n\n\n\n#### 语法\n\nsort!(X, \\[ascending=true])\n\n#### 参数\n\n**X** 是一个向量。\n\n**ascending** 是一个布尔值，表示按升序排序还是按降序排序。默认值为 true（按升序排序）。\n\n#### 详情\n\n返回一个排序后的向量。该函数会改变 *X* 的值。\n\n#### 例子\n\n```\nx=9 1 5;\nsort!(x);\nx;\n// output\n[1 5 9]\n\nx.sort!(0);\nx;\n// output\n[9,5,1]\n```\n"
    },
    "spearmanr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/spearmanr.html",
        "signatures": [
            {
                "full": "spearmanr(X, Y)",
                "name": "spearmanr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [spearmanr](https://docs.dolphindb.cn/zh/funcs/s/spearmanr.html)\n\n\n\n#### 语法\n\nspearmanr(X, Y)\n\n#### 参数\n\n**X** 是一个向量或矩阵。\n\n**Y** 是一个向量或矩阵。\n\n#### 详情\n\n计算 *X* 和 *Y* 的 Spearman 等级相关系数。`spearman` 函数在计算时会忽略 NULL 值。Spearman 相关性是两个数据集之间关系的单调性的非参数度量，该系数在-1和+1之间变化，其中0表示无相关。-1或+1意味着确切的单调关系。正相关表明，随着 *X* 的增加，*Y* 也随之增加。负相关性表示随着 *X* 增加，*Y* 减少。\n\n若 *X* 或 *Y* 是矩阵，计算每列的 Spearman 等级相关系数，返回一个向量。\n\n#### 例子\n\n```\nx=[2013.06.13, 2013.06.14, 2013.06.15]\ny=1 5 3\nspearmanr(x, y)\n// output\n0.5\n\nx = [33,21,46,-11,78,47,18,20,-5,66]\ny = [1,NULL,10,6,10,3,NULL,NULL,5,3]\nspearmanr(x, y)\n// output\n0.109109\n```\n\n如果 *X* 是矩阵，*Y* 可以是标量、向量或者是与 *X* 行数相同的矩阵。返回结果是与 *X* 列数相同的向量。\n\n```\nm1 = [34,77,35,-40,-39,-86,49,-55,15,72,NULL,-24,16,20,26,-82,80,-93,-65,99,45,90,44,46]$4:6\nm2 = [0, 25, 7, 3]\nspearmanr(m1, m2)\n// output\n[0.8, -0.4, 0.5, 0.6, -0.8, 0.4]\n```\n"
    },
    "splev": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/splev.html",
        "signatures": [
            {
                "full": "splev(x, tck)",
                "name": "splev",
                "parameters": [
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "tck",
                        "name": "tck"
                    }
                ]
            }
        ],
        "markdown": "### [splev](https://docs.dolphindb.cn/zh/funcs/s/splev.html)\n\n\n\n#### 语法\n\nsplev(x, tck)\n\n#### 参数\n\n**x** Integral/Temporal/Floating 类型向量。一组点，用来获得样条上的对应的值。\n\n**tck** 三元组或 B 样条曲线对象。若传入元组，则应为长度为3的序列；若传入 B 样条曲线对象，则应包含节点 t、B 样条系数 c 和样条次数 k，可使用函数 [splrep](https://docs.dolphindb.cn/zh/funcs/s/splrep.html) 生成。注意，须遵守 1<=k<=5。\n\n#### 详情\n\n`splev` 全称 Spline Evaluation，即评估 B 样条曲线或其导数。给定 B 样条表示的节点和系数，使用该函数可求解平滑多项式及其导数的值。若 x, tck 传入参数中包含 None 将直接填充为 0。\n\n返回值 y 为 DOUBLE 类型的向量，表示在 x 点处求解的样条函数值的数组。\n\n**Note:**\n\n不建议自定义 *tck*，如果 *tck* 不是由 splrep 生成，则返回的 y 可能是随机值，也可能全为0。\n\n#### 例子\n\n```\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\ny = [0, 3, 5, 6, 5, 3, 1, 2, 4, 5]\nnewx = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5]\nt=[1,3,5,8]\ntck= splrep(x, y, t=t)\nprint(tck)\n// output\n([0,0,0,0,1,3,5,8,9,9,9,9],\n[0,2.234794827972243,2.999908797063527,8.195517483732592,0.982766102937427,0.416533320193195,6.868465914739519,5,0,0,0,0],\n3)\n\nnewy = splev(newx, tck)\nprint(newy)\n// output\n[2.147514374187927,3.928180605155257,5.780093403045226,5.788551610920491,3.842319632145274,1.928386784305488,1.343262026468735,2.600266282317609,5.680148059970901,-0.902321655035049] \n```\n\n相关函数：[splrep](https://docs.dolphindb.cn/zh/funcs/s/splrep.html)\n"
    },
    "spline": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/spline.html",
        "signatures": [
            {
                "full": "spline(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false])",
                "name": "spline",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "resampleRule",
                        "name": "resampleRule"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    },
                    {
                        "full": "[outputX=false]",
                        "name": "outputX",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [spline](https://docs.dolphindb.cn/zh/funcs/s/spline.html)\n\n\n\n#### 语法\n\nspline(X, Y, resampleRule, \\[closed='left'], \\[origin='start\\_day'], \\[outputX=false])\n\n#### 详情\n\n该函数根据 *resampleRule*, *closed*, *origin* 确定的采样规则，对 *X* 进行重采样操作。并根据重采样后的 *X*，对 *Y* 进行三次样条插值（Cubic Spline Interpolation）。\n\n若不指定 *outputX*，仅返回一个对 *Y* 插值后的向量。若指定 *outputX* = true，则返回一个 tuple，其第一个元素为 *X* 重采样后的向量，第二个元素为对 *Y* 插值后的向量。\n\n#### 参数\n\n**X** 严格递增的时间类型向量。\n\n**Y** 同 *X* 等长的数值型向量。\n\n**resampleRule** 一个字符串，可选值请参考 [resample](https://docs.dolphindb.cn/zh/funcs/r/resample.html) 的 *rule* 参数。\n\n**closed** 和 **origin** 同 [resample](https://docs.dolphindb.cn/zh/funcs/r/resample.html) 的 *closed* 和 *origin* 参数。\n\n**outputX** 布尔类型，表示是否输出 *X* 按照 *resampleRule*, *closed*, *origin* 重采样后的向量。默认值为 false。\n\n#### 例子\n\n```\nspline([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min);\n\n// output\n[1,1.0313,1.0626,1.0942,1.1262,1.1585,1.1914,1.225,1.2593,1.2944,1.3306,1.3678,1.4062,1.446,1.4871,1.5298,1.5741,1.6201,1.668,1.7178\n,1.7697,1.8237,1.8801,1.9388,2,2.0638,2.1301,2.1987,2.2697,2.3428,2.418,2.4951,2.5741,2.6548,2.7371,2.821,2.9062,2.9928,3.0806,3.1694\n,3.2593,3.35,3.4414,3.5335,3.6262,3.7192,3.8126,3.9063,4]\n```\n"
    },
    "split": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/split.html",
        "signatures": [
            {
                "full": "split(str, [delimiter])",
                "name": "split",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [split](https://docs.dolphindb.cn/zh/funcs/s/split.html)\n\n\n\n#### 语法\n\nsplit(str, \\[delimiter])\n\n#### 参数\n\n**str** 是STRING类型标量或向量；\n\n**delimiter** 是 CHAR 类型或 STRING 类型标量，表示分隔符。分隔符可以是一个或多个字符，默认是逗号（\",\"）。\n\n#### 详情\n\n若 *str* 为标量：\n\n* 如果没有指定 *delimiter*，把 *str* 分割为 CHAR 类型向量。\n\n* 如果指定了 *delimiter*，把它作为分隔符，把 *str* 分成 CHAR 类型或 STRING 类型的向量。\n\n若 *str* 为向量，则对 *str* 的每一个元素进行分割，返回一个列式元组（columnar tuple）。\n\n#### 例子\n\n```\nsplit(\"xyz 1\");\n// output\n['x','y','z',' ','1']\n\nsplit(\"xyz 1\",\" \");\n// output\n[\"xyz\",\"1\"]\n\nsplit(`xyz1,`xyz);\n// output\n[,\"1\"]\n\nsplit(`xyz1,`xyz)[1];\n// output\n1\n\na = split\\(\"20220101 09:00:00\" \"20220101 09:12:20\" \"20220101 10:00:00\", \" \"\\)\n// output\n\\(\\[\"20220101\",\"09:00:00\"\\],\\[\"20220101\",\"09:12:20\"\\],\\[\"20220101\",\"10:00:00\"\\]\\)\n\n// 按列取数\na\\[0\\];\n// output\n\\[\"20220101\",\"20220101\",\"20220101\"\\]\n\na\\[1\\];\n// output\n\\[\"09:00:00\",\"09:12:20\",\"10:00:00\"\\]\n\n// 按行取数\na.row\\(0\\)\n// output\n\\[\"20220101\",\"09:00:00\"\\]\n```\n"
    },
    "splrep": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/splrep.html",
        "signatures": [
            {
                "full": "splrep(x, y, t)",
                "name": "splrep",
                "parameters": [
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "y",
                        "name": "y"
                    },
                    {
                        "full": "t",
                        "name": "t"
                    }
                ]
            }
        ],
        "markdown": "### [splrep](https://docs.dolphindb.cn/zh/funcs/s/splrep.html)\n\n\n\n#### 语法\n\nsplrep(x, y, t)\n\n#### 参数\n\n**x**/**y** Integral/Temporal/Floating 类型向量，定义三次样条曲线 y = f(x) 的数据点。\n\n**Note:** *x* 与 *y* 的输入值须保证相同长度，且 *y* 的输入值须为递增向量。\n\n**t** 向量，可选，表示结点。样条在结点两边可以是不同的多项式。*t* 须满足 Schoenberg-Whitney 条件，如必须存在一个数据点的子集 x\\[j] 对于所有的 j=0, 1,...,n-5，满足 t\\[j] < x\\[j] < t\\[j+4]。\n\n#### 详情\n\n`splrep` 全称 Spline Representation，即样条插值函数，要求找到一维曲线的 B 样条表示。在给定数据点集 (x\\[i], y\\[i]) 后，使用该函数可确定在区间 x\\[0] <= x <= x\\[size(x)-1] 上的度数为 3 的平滑样条逼近。注意，若 *x*, *y*, *t* 传入参数中包含 NULL 将直接填充为 0。\n\n返回值为一个长度为3的元组，其各个元素的含义如下：\n\n第一个元素：向量，表示样条曲线的结点。\n\n第二个元素：向量，表示 B 样条系数。\n\n第三个元素：标量，表示样条的次数。\n\n#### 例子\n\n```\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\ny = [0, 3, 5, 6, 5, 3, 1, 2, 4, 5]\nt=[1,3,5,8]\ntck= splrep(x, y, t=t)\nprint(tck)\n//output\n([0,0,0,0,1,3,5,8,9,9,9,9],[0,2.234794827972243,2.999908797063527,8.195517483732592,0.982766102937427,0.416533320193195,6.868465914739519,5,0,0,0,0],3)\n```\n\n相关函数：[splev](https://docs.dolphindb.cn/zh/funcs/s/splev.html)\n"
    },
    "sql": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sql.html",
        "signatures": [
            {
                "full": "sql(select, from, [where], [groupBy], [groupFlag], [csort], [ascSort], [having], [orderBy], [ascOrder], [limit], [hint], [exec=false], [map=false])",
                "name": "sql",
                "parameters": [
                    {
                        "full": "select",
                        "name": "select"
                    },
                    {
                        "full": "from",
                        "name": "from"
                    },
                    {
                        "full": "[where]",
                        "name": "where",
                        "optional": true
                    },
                    {
                        "full": "[groupBy]",
                        "name": "groupBy",
                        "optional": true
                    },
                    {
                        "full": "[groupFlag]",
                        "name": "groupFlag",
                        "optional": true
                    },
                    {
                        "full": "[csort]",
                        "name": "csort",
                        "optional": true
                    },
                    {
                        "full": "[ascSort]",
                        "name": "ascSort",
                        "optional": true
                    },
                    {
                        "full": "[having]",
                        "name": "having",
                        "optional": true
                    },
                    {
                        "full": "[orderBy]",
                        "name": "orderBy",
                        "optional": true
                    },
                    {
                        "full": "[ascOrder]",
                        "name": "ascOrder",
                        "optional": true
                    },
                    {
                        "full": "[limit]",
                        "name": "limit",
                        "optional": true
                    },
                    {
                        "full": "[hint]",
                        "name": "hint",
                        "optional": true
                    },
                    {
                        "full": "[exec=false]",
                        "name": "exec",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[map=false]",
                        "name": "map",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [sql](https://docs.dolphindb.cn/zh/funcs/s/sql.html)\n\n\n\n#### 语法\n\nsql(select, from, \\[where], \\[groupBy], \\[groupFlag], \\[csort], \\[ascSort], \\[having], \\[orderBy], \\[ascOrder], \\[limit], \\[hint], \\[exec=false], \\[map=false])\n\n#### 参数\n\n**select** 是表示选取的列的元代码。每列由函数 [sqlCol](https://docs.dolphindb.cn/zh/funcs/s/sqlCol.html) 或 [sqlColAlias](https://docs.dolphindb.cn/zh/funcs/s/sqlColAlias.html) 生成。若选择多列，使用元组表示。\n\n**from** 选取数据的表对象或表名称。\n\n**where** where 条件。如果有多个 where 条件，使用 ANY 向量来表示，每个元素对应一个条件的元代码。\n\n**groupBy** group by 后面的关键字（列名）。如果有多个 group by 关键字，使用 ANY 向量来表示，每个元素对应一个列名的元代码。\n\n**groupFlag** 1表示 group by，0表示 context by，2表示 pivot by。默认值为1。\n\n**csort** csort 后面的关键字（列名）。只有当 *groupFlag*=0，即使用 context by 时，才能指定该参数。如果有多个 csort 关键字，使用元组来表示，每个元素对应一个列名的元代码。\n\n**ascSort** 表示 csort 关键字按升序或降序排列的整型标量或向量。1表示升序，0表示降序。默认值为1。\n\n**having** having 条件。如果有多个 having 条件，使用 ANY 向量来表示，每个元素对应一个条件的元代码。\n\n**orderBy** order by 后面的关键字（列名）。如果有多个 order by 关键字，使用 ANY 向量来表示，每个元素对应一个列名的元代码。\n\n**ascOrder** 表示 order by 后面的关键字按升序或降序排列的整型标量或向量。1表示升序，0表示降序。默认值为1。\n\n**limit** 整数或整型数据对，表示从第一行开始选取的行数。如果指定了 *groupBy* 且 *groupFlag*=0，从每组的第一行开始选取 limit 行记录。它对应的是 SQL 中的 top 语句。\n\n**hint** 常量。目前该参数可以是 HINT\\_HASH、HINT\\_SNAPSHOT 或 HINT\\_KEEPORDER。HINT\\_HASH 表示执行 group by 查询时采用哈希算法，HINT\\_SNAPSHOT 表示从快照引擎中查询数据，HINT\\_KEEPORDER 表示执行context by 后的结果仍然按输入数据中的顺序排列。\n\n**exec** 表示是否使用 exec 子句。默认值为 false。若设置为 true，可以生成一个标量或者一个向量，与 pivot by 共同使用，可以生成一个矩阵。\n\n**map** 布尔类型的标量，表示是否使用 map 关键字，默认值为 false。\n\n#### 详情\n\n动态生成 SQL 语句。使用函数 [eval](https://docs.dolphindb.cn/zh/funcs/e/eval.html) 执行生成的 SQL 语句。\n\n#### 例子\n\n```\nsymbol = take(`GE,6) join take(`MSFT,6) join take(`F,6)\ndate=take(take(2017.01.03,2) join take(2017.01.04,4), 18)\nprice=31.82 31.69 31.92 31.8  31.75 31.76 63.12 62.58 63.12 62.77 61.86 62.3 12.46 12.59 13.24 13.41 13.36 13.17\nvolume=2300 3500 3700 2100 1200 4600 1800 3800 6400 4200 2300 6800 4200 5600 8900 2300 6300 9600\nt1 = table(symbol, date, price, volume);\n\nt1;\n```\n\n| symbol | date       | price volume |\n| ------ | ---------- | ------------ |\n| GE     | 2017.01.03 | 31.82 2300   |\n| GE     | 2017.01.03 | 31.69 3500   |\n| GE     | 2017.01.04 | 31.92 3700   |\n| GE     | 2017.01.04 | 31.8 2100    |\n| GE     | 2017.01.04 | 31.75 1200   |\n| GE     | 2017.01.04 | 31.76 4600   |\n| MSFT   | 2017.01.03 | 63.12 1800   |\n| MSFT   | 2017.01.03 | 62.58 3800   |\n| MSFT   | 2017.01.04 | 63.12 6400   |\n| MSFT   | 2017.01.04 | 62.77 4200   |\n| MSFT   | 2017.01.04 | 61.86 2300   |\n| MSFT   | 2017.01.04 | 62.3 6800    |\n| F      | 2017.01.03 | 12.46 4200   |\n| F      | 2017.01.03 | 12.59 5600   |\n| F      | 2017.01.04 | 13.24 8900   |\n| F      | 2017.01.04 | 13.41 2300   |\n| F      | 2017.01.04 | 13.36 6300   |\n| F      | 2017.01.04 | 13.17 9600   |\n\n```\nx=5000\nwhereConditions = [<symbol=`MSFT>,<volume>x>]\nhavingCondition = <sum(volume)>200>;\n\nsql(sqlCol(\"*\"), t1);\n//output:< select * from t1 >\n\nsql(sqlCol(\"*\"), t1, whereConditions);\n//output:< select * from t1 where symbol == \"MSFT\",volume > x >\n\nsql(select=sqlColAlias(<avg(price)>), from=t1, where=whereConditions, groupBy=sqlCol(`date));\n//output:< select avg(price) as avg_price from t1 where symbol == \"MSFT\",volume > x group by date >\n\nsql(select=sqlColAlias(<avg(price)>), from=t1, groupBy=[sqlCol(`date),sqlCol(`symbol)]);\n//output:< select avg(price) as avg_price from t1 group by date,symbol >\n\nsql(select=(sqlCol(`symbol),sqlCol(`date),sqlColAlias(<cumsum(volume)>, `cumVol)), from=t1, groupBy=sqlCol(`date`symbol), groupFlag=0);\n//output:< select symbol,date,cumsum(volume) as cumVol from t1 context by date,symbol >\n\nsql(select=(sqlCol(`symbol),sqlCol(`date),sqlColAlias(<cumsum(volume)>, `cumVol)), from=t1, where=whereConditions, groupBy=sqlCol(`date), groupFlag=0);\n//output:< select symbol,date,cumsum(volume) as cumVol from t1 where symbol == \"MSFT\",volume > x context by date >\n\nsql(select=(sqlCol(`symbol),sqlCol(`date),sqlColAlias(<cumsum(volume)>, `cumVol)), from=t1, where=whereConditions, groupBy=sqlCol(`date), groupFlag=0, csort=sqlCol(`volume), ascSort=0);\n//output:< select symbol,date,cumsum(volume) as cumVol from t1 where symbol == \"MSFT\",volume > x context by date csort volume desc >\n\nsql(select=(sqlCol(`symbol),sqlCol(`date),sqlColAlias(<cumsum(volume)>, `cumVol)), from=t1, where=whereConditions, groupBy=sqlCol(`date), groupFlag=0, having=havingCondition);\n//output:< select symbol,date,cumsum(volume) as cumVol from t1 where symbol == \"MSFT\",volume > x context by date having sum(volume) > 200 >\n\nsql(select=sqlCol(\"*\"), from=t1, where=whereConditions, orderBy=sqlCol(`date), ascOrder=0);\n//output:< select * from t1 where symbol == \"MSFT\",volume > x order by date desc >\n\nsql(select=sqlCol(\"*\"), from=t1, limit=1);\n//output:< select top 1 * from t1 >\n\nsql(select=sqlCol(\"*\"), from=t1, groupBy=sqlCol(`symbol), groupFlag=0, limit=1);\n//output:< select top 1 * from t1 context by symbol >\n\nsql(select=(sqlCol(`symbol),sqlCol(`date),sqlColAlias(<cumsum(volume)>, `cumVol)), from=t1, groupBy=sqlCol(`date`symbol), groupFlag=0, hint=HINT_KEEPORDER);\n//output:< select [128] symbol,date,cumsum(volume) as cumVol from t1 context by date,symbol >\n\nwhereConditions1 = <symbol=`MSFT or volume>x>\nsql(select=sqlCol(\"*\"), from=t1, where=whereConditions1, orderBy=sqlCol(`date), ascOrder=0);\n//output:< select * from t14059d76a00000000 where symbol == \"MSFT\" or volume > x order by date desc >\nsql(select=sqlCol(\"*\"), from=t1, where=whereConditions, orderBy=sqlCol(`date), ascOrder=0, map=true);\n//output:< select [256] * from t17092a30500000000 where symbol == \"MSFT\",volume > x order by date desc map >\n```\n\n可以定义一个函数使用 `sql` 函数来动态生成 SQL 语句。\n\n```\ndef f1(t, sym, x){\nwhereConditions=[<symbol=sym>,<volume>x>]\nreturn sql(sqlCol(\"*\"),t,whereConditions).eval()\n};\n\nf1(t1, `MSFT, 5000);\n```\n\n| symbol | date       | price volume |\n| ------ | ---------- | ------------ |\n| MSFT   | 2017.01.04 | 63.12 6400   |\n| MSFT   | 2017.01.04 | 62.3 6800    |\n\n```\nf1(t1, `F, 9000);\n```\n\n| symbol | date       | price volume |\n| ------ | ---------- | ------------ |\n| F      | 2017.01.04 | 13.17 9600   |\n\n```\ndef f2(t, sym, colNames, filterColumn, filterValue){\n whereConditions=[<symbol=sym>,expr(sqlCol(filterColumn),>,filterValue)]\n    return sql(sqlCol(colNames),t,whereConditions).eval()\n};\n```\n\n```\nf2(t1,`GE, `symbol`date`volume, `volume, 3000);\n```\n\n| symbol | date       | volume |\n| ------ | ---------- | ------ |\n| GE     | 2017.01.03 | 3500   |\n| GE     | 2017.01.04 | 3700   |\n| GE     | 2017.01.04 | 4600   |\n\n```\nf2(t1,`F, `symbol`date`volume,`price,13.2);\n```\n\n| symbol | date       | volume |\n| ------ | ---------- | ------ |\n| F      | 2017.01.04 | 8900   |\n| F      | 2017.01.04 | 2300   |\n| F      | 2017.01.04 | 6300   |\n\n设置参数 *exec*=true，配合 pivot by 语句，生成一个矩阵：\n\n```\ndate = 2020.09.21 + 0 0 0 0 1 1 1 1\nsym = `MS`MS`GS`GS`MS`MS`GS`GS$SYMBOL\nfactorNum = 1 2 1 2 1 2 1 2\nfactorValue = 1.2 -3.4 -2.5 6.3 1.1 -3.2 -2.1 5.6\nt = table(date, sym, factorNum, factorValue);\nsql(select=sqlCol(`factorValue), from=t, groupBy=[sqlCol(`date), sqlCol(`sym)], groupFlag=2, exec=true)\n\n//output:< exec factorValue from t pivot by date,sym >\n```\n"
    },
    "sqlCol": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sqlCol.html",
        "signatures": [
            {
                "full": "sqlCol(colName, [func], [alias], [qualifier])",
                "name": "sqlCol",
                "parameters": [
                    {
                        "full": "colName",
                        "name": "colName"
                    },
                    {
                        "full": "[func]",
                        "name": "func",
                        "optional": true
                    },
                    {
                        "full": "[alias]",
                        "name": "alias",
                        "optional": true
                    },
                    {
                        "full": "[qualifier]",
                        "name": "qualifier",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sqlCol](https://docs.dolphindb.cn/zh/funcs/s/sqlCol.html)\n\n\n\n#### 语法\n\nsqlCol(colName, \\[func], \\[alias], \\[qualifier])\n\n#### 参数\n\n**colName** 是一个字符串标量或向量，表示列名。\n\n**func** 是一个一元函数。\n\n**alias** 是一个字符串标量或向量，表示选择列或计算结果列的别名。\n\n**qualifier** 是一个字符串标量，表示表名。多表连接时，可以通过该参数指定含有相同名字的非连接列属于哪个表。\n\n#### 详情\n\n生成表示选择某些列或对某些列进行计算的元代码。一般与函数 [sql](https://docs.dolphindb.cn/zh/funcs/s/sql.html) 和 [eval](https://docs.dolphindb.cn/zh/funcs/e/eval.html) 共同使用，用于动态生成 SQL 语句。\n\n#### 例子\n\n```\nt = table(`GME`AMC`KOSS as symbol, 325 13.26 64 as price);\ncolName=\"symbol\";\nsql(select=sqlCol(colName), from=t).eval();\n```\n\n| symbol |\n| ------ |\n| GME    |\n| AMC    |\n| KOSS   |\n\n```\ncolName=\"price\";\nsql(select=sqlCol(colName, max, `maxPrice), from=t).eval();\n```\n\n| maxPrice |\n| -------- |\n| 325      |\n\n```\nt1 = table(1 2 3 3 as id, 7.8 4.6 5.1 0.1 as value, 4 3 2 1 as x);\nt2 = table(5 3 1 as id,  300 500 800 as qty, 44 66 88 as x) ;\nsql(select=(sqlCol(`id),sqlCol(colName=`x, alias=\"t1_x\", qualifier=\"t1\"),sqlCol(colName=`x, alias=\"t2_x\", qualifier=`t2)), from=<ej(t1,t2,`id)>).eval()\n```\n\n| id | t1\\_x | t2\\_x |\n| -- | ----- | ----- |\n| 1  | 4     | 88    |\n| 3  | 2     | 66    |\n| 3  | 1     | 66    |\n"
    },
    "sqlColAlias": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sqlColAlias.html",
        "signatures": [
            {
                "full": "sqlColAlias(colDefs, [colNames])",
                "name": "sqlColAlias",
                "parameters": [
                    {
                        "full": "colDefs",
                        "name": "colDefs"
                    },
                    {
                        "full": "[colNames]",
                        "name": "colNames",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sqlColAlias](https://docs.dolphindb.cn/zh/funcs/s/sqlColAlias.html)\n\n\n\n#### 语法\n\nsqlColAlias(colDefs, \\[colNames])\n\n#### 参数\n\n**colDefs** 是给定的元代码；\n\n**colNames** 是表示别名的字符串。\n\n#### 详情\n\n使用元代码和可选择的别名来定义一个列。它通常用于计算列。\n\n#### 例子\n\n```\nsqlColAlias(<x>, `y);\n// output\n< x as y >\n\nsqlColAlias(<avg(PRC)>, `avgPRC);\n// output\n< avg(PRC) as avgPRC >\n\nsqlColAlias(<avg(PRC)>);\n// output\n< avg(PRC) as avg_PRC >\n```\n"
    },
    "sqlDelete": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sqlDelete.html",
        "signatures": [
            {
                "full": "sqlDelete(table, [where], [from])",
                "name": "sqlDelete",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "[where]",
                        "name": "where",
                        "optional": true
                    },
                    {
                        "full": "[from]",
                        "name": "from",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sqlDelete](https://docs.dolphindb.cn/zh/funcs/s/sqlDelete.html)\n\n\n\n#### 语法\n\nsqlDelete(table, \\[where], \\[from])\n\n#### 参数\n\n**table** 可以是内存表，亦可为分布式表。\n\n**where** 是元代码，表示 where 条件。\n\n**from** 是元代码，表示 from 子句。\n\n#### 详情\n\n动态生成 SQL delete 语句的元代码。若需执行生成的元代码，请配合使用 [eval](https://docs.dolphindb.cn/zh/funcs/e/eval.html) 函数。\n\n#### 例子\n\n例1. 删除内存表记录\n\n```\nt1=table(`A`B`C as symbol, 10 20 30 as x)\nsqlDelete(t1, <symbol=`C>).eval()\nt1;\n```\n\n| symbol | x  |\n| ------ | -- |\n| A      | 10 |\n| B      | 20 |\n\n例2. 删除分区表记录\n\n```\nif(existsDatabase(\"dfs://db1\")){\n    dropDatabase(\"dfs://db1\")\n}\n\nn=1000000\nt=table(take(`A`B`C`D,n) as symbol, rand(10.0, n) as value)\ndb = database(\"dfs://db1\", VALUE, `A`B`C`D)\nTrades = db.createPartitionedTable(t, \"Trades\", \"symbol\")\nTrades.append!(t)\nselect count(*) from Trades;\n\n// output: 1000000\n\nTrades=loadTable(\"dfs://db1\", \"Trades\")\nsqlDelete(Trades, <symbol=`A>).eval()\nselect count(*) from Trades;\n\n// output: 750000\n```\n\n例3. 结合表连接删除记录\n\n```\nt1 = table(1..5 as id, [1,2,2,1,1] as flag)\nt2 = table(3..7 as id, [100,200,100,150,100] as profit)\nsqlDelete(table=t2, where=<flag=1>, from=<ej(t2,t1,`id)>).eval()\nt2\n```\n\n<table id=\"table_drc_cmf_xbc\"><thead><tr><th>\n\nid\n\n</th><th>\n\nprofit\n\n</th></tr></thead><tbody><tr><td>\n\n3\n\n</td><td>\n\n100\n\n</td></tr><tr><td>\n\n6\n\n</td><td>\n\n150\n\n</td></tr><tr><td>\n\n7\n\n</td><td>\n\n100\n\n</td></tr></tbody>\n</table>\n"
    },
    "sqlDS": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html",
        "signatures": [
            {
                "full": "sqlDS(sqlObj, [forcePartition=false])",
                "name": "sqlDS",
                "parameters": [
                    {
                        "full": "sqlObj",
                        "name": "sqlObj"
                    },
                    {
                        "full": "[forcePartition=false]",
                        "name": "forcePartition",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html)\n\n\n\n#### 语法\n\nsqlDS(sqlObj, \\[forcePartition=false])\n\n#### 参数\n\n**sqlObj** 是 SQL 元代码。元代码的详情请参考 [Metaprogramming](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n**forcePartition** 是一个布尔值。默认值为 false。如果 *forcePartition*=false，系统会检查该查询能够拆分为多个子查询。如果不能拆分为多个子查询，系统不会在分区上拆分查询，并且会抛出异常。如果 *forcePartition*=true，系统会在分区上拆分查询，并且在选中的分区中执行查询。下面两种情况的查询不能拆分为多个子查询：(1) group by 关键字不是分区列；(2) 指定了 order by 子句。\n\n#### 详情\n\n根据输入的 SQL 元代码创建数据源列表。如果 SQL 查询中的数据表有 n 个分区，`sqlDS` 生成 n 个数据源。如果 SQL 查询没有包含任何分区表，`sqlDS` 返回包含一个数据源的元组。\n\n#### 例子\n\n```\nn=1000000\ndate=take(2019.01.01..2019.01.03,n)\nsym = take(`C`MS`MS`MS`IBM`IBM`IBM`C`C$SYMBOL,n)\nprice= take(49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29,n)\nqty = take(2200 1900 2100 3200 6800 5400 1300 2500 8800,n)\nt=table(date, sym, price, qty)\n\ndb1=database(\"\",VALUE,2019.01.01..2019.01.03)\ndb2=database(\"\",VALUE,`C`MS`IBM)\ndb=database(\"dfs://stock\",COMPO,[db1,db2])\ntrades=db.createPartitionedTable(t,`trades,`date`sym).append!(t)\n\nds=sqlDS(<select * from trades where date=2019.01.02>);\n\ntypestr ds;\n// output\nANY VECTOR\n\nsize ds;\n// output\n3\n\nds[0];\n// output\nDataSource< select [7] * from trades [partition = /stock/20190102/C] >\n\nds[1];\n// output\nDataSource< select [7] * from trades [partition = /stock/20190102/IBM] >\n\nds[2];\n// output\nDataSource< select [7] * from trades [partition = /stock/20190102/MS] >\n```\n"
    },
    "sqlTuple": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sqlTuple.html",
        "signatures": [
            {
                "full": "sqlTuple(colNames)",
                "name": "sqlTuple",
                "parameters": [
                    {
                        "full": "colNames",
                        "name": "colNames"
                    }
                ]
            }
        ],
        "markdown": "### [sqlTuple](https://docs.dolphindb.cn/zh/funcs/s/sqlTuple.html)\n\n\n\n#### 语法\n\nsqlTuple(colNames)\n\n#### 参数\n\n**colNames** 字符串标量或向量，表示列名。\n\n#### 详情\n\n生成一个元代码，其内容是一个元组表达式，元组的元素为 colNames 指定的列。常与函数 sql，makeUnifiedCall 共同使用，用于动态生成 SQL 语句。\n\n#### 例子\n\n下例中，函数 makeUnifiedCall 以 sqlTuple 生成的元组表达式的元代码为参数，调用自定义函数 f，其结果作为函数 sql 的参数 select ，从而生成元代码 c 。\n\n```\n// 自定义函数\nf = def (x,y)->(x-y)/(x+y)\n\n// 定义待查询的表\nt = table(1.0 2.0 3.0 as qty1, 1.0 3.0 7.0 as qty2)\n\n// 生成查询的元代码\nc = sql(select=makeUnifiedCall(f, sqlTuple(`qty1`qty2)), from=t)\n\n// 执行对应元代码\nc.eval()\n```\n\n| \\_qty1 |\n| ------ |\n| 0      |\n| -0.2   |\n| -0.4   |\n\n**Related information**\n\n[makeUnifiedCall](https://docs.dolphindb.cn/zh/funcs/m/makeUnifiedCall.html)\n"
    },
    "sqlUpdate": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sqlUpdate.html",
        "signatures": [
            {
                "full": "sqlUpdate(table, updates, [from], [where], [contextBy], [csort], [ascSort], [having])",
                "name": "sqlUpdate",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "updates",
                        "name": "updates"
                    },
                    {
                        "full": "[from]",
                        "name": "from",
                        "optional": true
                    },
                    {
                        "full": "[where]",
                        "name": "where",
                        "optional": true
                    },
                    {
                        "full": "[contextBy]",
                        "name": "contextBy",
                        "optional": true
                    },
                    {
                        "full": "[csort]",
                        "name": "csort",
                        "optional": true
                    },
                    {
                        "full": "[ascSort]",
                        "name": "ascSort",
                        "optional": true
                    },
                    {
                        "full": "[having]",
                        "name": "having",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [sqlUpdate](https://docs.dolphindb.cn/zh/funcs/s/sqlUpdate.html)\n\n\n\n#### 语法\n\nsqlUpdate(table, updates, \\[from], \\[where], \\[contextBy], \\[csort], \\[ascSort], \\[having])\n\n#### 参数\n\n各参数对应 SQL update 语句中相应部分：\n\n```\nupdate\n    table_name\n    set col1=X1, [col2=X2,…]\n    [from table_joiner(table_names)]\n    [where condition(s)]\n    [context by col_name(s)]\n```\n\n**table** 可以是内存表，亦可为分布式表。\n\n**updates** 是元代码或元代码组成的元组，表示更新的操作。\n\n**from** 是元代码，表示表连接操作。\n\n**where** 是元代码，表示 where 条件。\n\n**contextBy** 是元代码，表示 context by 子句。\n\n**csort** 是 csort 后面的关键字（列名）。仅在使用 context by 子句时，才能指定该参数。如果有多个 csort 关键字，使用元组来表示，每个元素对应一个列名的元代码。\n\n**ascSort** 是 csort 关键字按升序或降序排列的整型标量或向量。仅在使用 context by 子句时，才能指定该参数。1 表示升序，0 表示降序。默认值为 1。\n\n**having** 是 having 条件。仅在使用 context by 子句时，才能指定该参数。如果有多个 having 条件，使用 ANY 向量来表示，每个元素对应一个条件的元代码。\n\n#### 详情\n\n动态生成 SQL update 语句的元代码。若需执行生成的元代码，请配合使用 [eval](https://docs.dolphindb.cn/zh/funcs/e/eval.html) 函数。\n\n#### 例子\n\n例1. 更新内存表记录\n\n```\nt1=table(`A`A`B`B as symbol, 2021.04.15 2021.04.16 2021.04.15 2021.04.16 as date, 12 13 21 22 as price)\nt2=table(`A`A`B`B as symbol, 2021.04.15 2021.04.16 2021.04.15 2021.04.16 as date, 10 20 30 40 as volume);\n\nsqlUpdate(t1, <price*2 as updatedPrice>).eval()\nt1;\n```\n\n| symbol | date       | price | updatedPrice |\n| ------ | ---------- | ----- | ------------ |\n| A      | 2021.04.15 | 12    | 24           |\n| A      | 2021.04.16 | 13    | 26           |\n| B      | 2021.04.15 | 21    | 42           |\n| B      | 2021.04.16 | 22    | 44           |\n\n```\nsqlUpdate(table=t1, updates=[<price*10 as updatedPrice>,<price*20 as updatedPrice2>]).eval()\nt1;\n```\n\n| symbol | date       | price | updatedPrice | updatedPrice2 |\n| ------ | ---------- | ----- | ------------ | ------------- |\n| A      | 2021.04.15 | 12    | 120          | 240           |\n| A      | 2021.04.16 | 13    | 130          | 260           |\n| B      | 2021.04.15 | 21    | 210          | 420           |\n| B      | 2021.04.16 | 22    | 220          | 440           |\n\n```\nsqlUpdate(table=t2, updates=<cumsum(volume) as cumVolume>, contextby=<symbol>).eval()\n\nt2;\n```\n\n| symbol | date       | volume | cumVolume |\n| ------ | ---------- | ------ | --------- |\n| A      | 2021.04.15 | 10     | 10        |\n| A      | 2021.04.16 | 20     | 30        |\n| B      | 2021.04.15 | 30     | 30        |\n| B      | 2021.04.16 | 40     | 70        |\n\n```\nsqlUpdate(table=t1, updates=<updatedPrice*volume as dollarVolume>, from=<lj(t1, t2, `symbol`date)>).eval()\n\nt1;\n```\n\n| symbol | date       | price | updatedPrice | dollarVolume |\n| ------ | ---------- | ----- | ------------ | ------------ |\n| A      | 2021.04.15 | 12    | 120          | 1200         |\n| A      | 2021.04.16 | 13    | 130          | 2600         |\n| B      | 2021.04.15 | 21    | 42           | 1260         |\n| B      | 2021.04.16 | 22    | 44           | 1760         |\n\n```\nsqlUpdate(table=t2,updates=<cumsum(volume) as cumVolume>,contextBy=<symbol>,csort=<volume>,ascSort=0).eval() \n\nt2;\n```\n\n| symbol | date       | volume | cumVolume |\n| ------ | ---------- | ------ | --------- |\n| A      | 2021.04.15 | 10     | 30        |\n| A      | 2021.04.16 | 20     | 20        |\n| B      | 2021.04.15 | 30     | 70        |\n| B      | 2021.04.16 | 40     | 40        |\n\n例2. 更新分区表记录\n\n```\nif(existsDatabase(\"dfs://db1\")){\n    dropDatabase(\"dfs://db1\")\n}\nn=1000000\nt=table(take(`A`B`C`D,n) as symbol, rand(10.0, n) as value)\ndb = database(\"dfs://db1\", VALUE, `A`B`C`D)\nTrades = db.createPartitionedTable(t, \"Trades\", \"symbol\")\nTrades.append!(t)\nx=exec sum(value) from Trades;\n\nTrades=loadTable(\"dfs://db1\", \"Trades\")\nsqlUpdate(table=Trades, updates=<value+1 as value>, where=<symbol=`A>).eval()\ny=exec sum(value) from Trades;\n\ny-x;\n\n// output\n250000\n```\n"
    },
    "sqrt": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sqrt.html",
        "signatures": [
            {
                "full": "sqrt(X)",
                "name": "sqrt",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sqrt](https://docs.dolphindb.cn/zh/funcs/s/sqrt.html)\n\n\n\n#### 语法\n\nsqrt(X)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n#### 详情\n\n计算 *X* 中每个元素的平方根。返回的结果是 DOUBLE 类型。\n\n#### 例子\n\n```\nsqrt(4 16 -4 NULL);\n// output\n[2,4, , ]\n\ntypestr(sqrt(4));\n// output\nDOUBLE\n```\n"
    },
    "square": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/square.html",
        "signatures": [
            {
                "full": "square(X)",
                "name": "square",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [square](https://docs.dolphindb.cn/zh/funcs/s/square.html)\n\n\n\n#### 语法\n\nsquare(X)\n\n#### 参数\n\n**X** 可以是标量、数据对、向量或矩阵。\n\n#### 详情\n\n返回 *X* 的平方。返回结果的数据类型为 DOUBLE 类型。\n\n#### 例子\n\n```\nsquare(3);\n// output\n9\n\nsquare(2 4 NULL 6);\n// output\n[4,16,,36]\n\nsquare(1..4$2:2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 9  |\n| 4  | 16 |\n"
    },
    "startClusterReplication": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/startClusterReplication.html",
        "signatures": [
            {
                "full": "startClusterReplication()",
                "name": "startClusterReplication",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [startClusterReplication](https://docs.dolphindb.cn/zh/funcs/s/startClusterReplication.html)\n\n\n\n#### 语法\n\nstartClusterReplication()\n\n#### 参数\n\n无\n\n#### 详情\n\n重启由多次任务失败而停止或调用 [stopClusterReplication](https://docs.dolphindb.cn/zh/funcs/s/stopClusterReplication.html) 主动停止的异步复制。该命令只能由管理员在主/从集群的控制节点调用。调用该命令前，必须先配置 *replicationMode* 参数。\n\n#### 例子\n\n```\nstartClusterReplication();\n```\n\n相关函数： [stopClusterReplication](https://docs.dolphindb.cn/zh/funcs/s/stopClusterReplication.html), [skipClusterReplicationTask](https://docs.dolphindb.cn/zh/funcs/s/skipClusterReplicationTask.html)\n"
    },
    "startDataNode": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/startDataNode.html",
        "signatures": [
            {
                "full": "startDataNode(X)",
                "name": "startDataNode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [startDataNode](https://docs.dolphindb.cn/zh/funcs/s/startDataNode.html)\n\n\n\n#### 语法\n\nstartDataNode(X)\n\n#### 参数\n\n**X** 是一个向量。包含了要启动的数据节点/计算节点的信息。\n\n#### 详情\n\n用于在集群控制器上启动数据节点/计算节点。\n\n#### 例子\n\n```\nx = [\"192.168.1.27:8506\",\"192.168.1.27:8502\",\"192.168.1.27:8527\"]\nstartDataNode(x);\n```\n"
    },
    "startHeapSample": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/startheapsample.html",
        "signatures": [
            {
                "full": "startHeapSample(sampleParameter)",
                "name": "startHeapSample",
                "parameters": [
                    {
                        "full": "sampleParameter",
                        "name": "sampleParameter"
                    }
                ]
            }
        ],
        "markdown": "### [startHeapSample](https://docs.dolphindb.cn/zh/funcs/s/startheapsample.html)\n\n\n\n#### 语法\n\nstartHeapSample(sampleParameter)\n\n#### 参数\n\n**sampleParameter** 长整型标量，表示采样阈值，单位为字节。在分配到指定字节的内存后会，将进行一次内存采样。取值范围是 \\[1, 524288]，建议设置为 524288。\n\n#### 详情\n\n用于动态启用堆内存采样。调用后将动态设置环境变量 TCMALLOC\\_SAMPLE\\_PARAMETER 的值，从而使开发者能够监控和分析程序的内存使用情况。仅管理员可执行该函数。\n\n#### 例子\n\n对内存使用情况进行分析的流程如下：\n\n1. 启用堆内存采样。\n\n2. 在可能发生内存泄漏的操作前、后分别执行 `dumpHeapSample`，保存两个不同的文件。通过对比两个文件，确认操作涉及到的内存分配和使用情况。\n\n3. 关闭堆内存采样。\n\n```\nstartHeapSample(524288)\n\ndumpHeapSample(\"/DolphinDB/Data/heap1\")\ndumpHeapSample(\"/DolphinDB/Data/heap2\")\n\nstopHeapSample()\n```\n\n相关函数：[dumpHeapSample](https://docs.dolphindb.cn/zh/funcs/d/dumpheapsample.html), [stopHeapSample](https://docs.dolphindb.cn/zh/funcs/s/stopheapsample.html)\n"
    },
    "startsWith": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/startsWith.html",
        "signatures": [
            {
                "full": "startsWith(X, str)",
                "name": "startsWith",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "str",
                        "name": "str"
                    }
                ]
            }
        ],
        "markdown": "### [startsWith](https://docs.dolphindb.cn/zh/funcs/s/startsWith.html)\n\n\n\n#### 语法\n\nstartsWith(X, str)\n\n#### 参数\n\n**X** 是在该字符串中搜索。它可以是标量或向量。\n\n**str** 是被搜索的目标字符串。它必须是标量。\n\n#### 详情\n\n检查 *X* 是否以 *str* 开头。如果是，返回 true； 否则返回 false。\n\n#### 例子\n\n```\nstr1=\"US product\"\nstr2=\"UK product\"\nif (startsWith(str1, \"US\")) print \"str1 is a US product.\"\nelse print \"str1 is not a US product.\"\nif (startsWith(str2, \"US\")) print \"str2 is a US product.\"\nelse print \"str2 is not a US product.\";\n\n// output\nstr1 is a US product.\nstr2 is not a US product.\n```\n"
    },
    "stat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/stat.html",
        "signatures": [
            {
                "full": "stat(X)",
                "name": "stat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [stat](https://docs.dolphindb.cn/zh/funcs/s/stat.html)\n\n\n\n#### 语法\n\nstat(X)\n\n#### 参数\n\n**X** 可以是向量或矩阵。\n\n#### 详情\n\n返回一个字典，它包含了 *X* 的统计信息，有平均值、最大值、最小值、计数、中位数和标准差。\n\n#### 例子\n\n```\nx=5 7 4 3 2 1 7 8 9 NULL;\n\nstat(x);\n// output\nMedian->5\nAvg->5.111111\nMin->1\nStdev->2.803767\nCount->9\nSize->10\nName->x\nMax->9\n\nstats = stat(x);\nstats[`Avg];\n// output\n5.111111\n```\n"
    },
    "stateIterate": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/stateIterate.html",
        "signatures": [
            {
                "full": "stateIterate(X, initial, initialWindow, iterateFunc, combineCoeff)",
                "name": "stateIterate",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "initial",
                        "name": "initial"
                    },
                    {
                        "full": "initialWindow",
                        "name": "initialWindow"
                    },
                    {
                        "full": "iterateFunc",
                        "name": "iterateFunc"
                    },
                    {
                        "full": "combineCoeff",
                        "name": "combineCoeff"
                    }
                ]
            }
        ],
        "markdown": "### [stateIterate](https://docs.dolphindb.cn/zh/funcs/s/stateIterate.html)\n\n\n\n#### 语法\n\nstateIterate(X, initial, initialWindow, iterateFunc, combineCoeff)\n\n该函数只能用作响应式状态引擎 *metrics* 中的函数。\n\n#### 参数\n\n**X** 输入表中的字段或其应用向量函数的计算结果。\n\n**initial** 数据形式同 *X*，作为 *initialWindow* 内数据的输出结果。\n\n**initialWindow** 正整数，表示初始化窗口的长度。其确定的窗口范围为\\[0, initialWindow)。\n\n**iterateFunc** 用于迭代计算的函数。必须是一个单目函数，其唯一参数是 `stateIterate` 对应输出表中的字段。目前只支持以下函数（非单目函数以部分应用形式给出其他参数）：\n\n* 滑动窗口函数：`tmove`, `tmavg`, `tmmax`, `tmmin`, `tmsum`, `mavg`, `mmax`, `mmin`, `mcount`, `msum`\n\n* 累计窗口函数：`cumlastNot`, `cumfirstNot`\n\n* 序列相关函数：`ffill`, `move`\n\n**Note:**\n\n* 由于迭代是基于历史数据进行的，因此当前记录的输出是基于输出表中的历史结果和 *X* 计算得到的。\n\n* tm 系列函数计算时，时间窗口由当前记录的时间戳确定。且计算窗口范围为 (T - window, T)。\n\n**combineCoeff** 长度为 2 的向量，作为 *iterateFunc* 迭代结果和 *X* 的关联系数。\n\n#### 详情\n\n通过线性迭代实现线性递归。\n\n假设该函数计算结果对应输出表的列为 factor，且迭代仅基于前一个值，对于第 k 条记录(k = 0, 1, 2 …)，其计算逻辑为：\n\n* k < *initialWindow*：factor\\[k] = initial\\[k]\n\n* k >= *initialWindow*：factor\\[k] = combineCoeff\\[0] \\* X\\[k] + combineCoeff\\[1] \\* iterateFunc(factor)\\[k-1]。\n\n注意：若 `iterateFunc` 为窗口函数，则会基于前多个 factor 值进行计算。\n\n#### 例子\n\n```\ntrade = table(take(\"A\", 6) join take(\"B\", 6) as sym,  1..12 as val0,  take(10, 12) as val1)\ntrade;\n```\n\n| sym | val0 | val1 |\n| --- | ---- | ---- |\n| A   | 1    | 10   |\n| A   | 2    | 10   |\n| A   | 3    | 10   |\n| A   | 4    | 10   |\n| A   | 5    | 10   |\n| A   | 6    | 10   |\n| B   | 7    | 10   |\n| B   | 8    | 10   |\n| B   | 9    | 10   |\n| B   | 10   | 10   |\n| B   | 11   | 10   |\n| B   | 12   | 10   |\n\n定义一个响应式状态引擎，并按 sym 列分组进行计算。组内的计算逻辑如下：\n\n* 前 *initialWindow* 行记录，计算公式为 factor\\[k]=initial\\[k]，因此 factor\\[0], factor\\[1], factor\\[2] 均将 val1 列的值直接作为 factor 列的输出。\n\n* 之后的记录，对应计算公式为 factor\\[k]=0.5\\*val0\\[k]+0.5\\*msum(factor, 3)\\[k-1]。以计算 sym=\\`A，val0=4 这条记录为例，此时 factor 列仅有前 3 条数据的输出，即 factor=\\[10, 10, 10]，k=3，带入计算公式即 0.5\\*4+0.5\\*msum(\\[10, 10, 10], 3)\\[2]=17。同理 sym=\\`A，val0=5 这条记录带入计算公式即 0.5\\*5+0.5\\*msum(\\[10, 10, 10, 17], 3)\\[3]=21，以此类推。\n\n```\ninputTable = streamTable(1:0, `sym`val0`val1, [SYMBOL, INT, INT])\noutputTable = table(100:0, `sym`factor, [STRING, DOUBLE])\nengine = createReactiveStateEngine(name=\"rsTest\", metrics=<[stateIterate(val0, val1, 3, msum{, 3}, [0.5, 0.5])]>, dummyTable=inputTable, outputTable=outputTable, keyColumn=[\"sym\"], keepOrder=true)\n\nengine.append!(trade)\nselect * from outputTable\n```\n\n| sym | factor |\n| --- | ------ |\n| A   | 10     |\n| A   | 10     |\n| A   | 10     |\n| A   | 17     |\n| A   | 21     |\n| A   | 27     |\n| B   | 10     |\n| B   | 10     |\n| B   | 10     |\n| B   | 20     |\n| B   | 25.5   |\n| B   | 33.75  |\n\n相关函数：[conditionalIterate](https://docs.dolphindb.cn/zh/funcs/c/conditionalIterate.html)\n"
    },
    "std": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/std.html",
        "signatures": [
            {
                "full": "std(X)",
                "name": "std",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [std](https://docs.dolphindb.cn/zh/funcs/s/std.html)\n\n\n\n#### 语法\n\nstd(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n若 *X* 为向量，返回 *X* 的标准差。\n\n若 *X* 为矩阵，计算每列的标准差，返回一个向量。\n\n若 *X* 为表，计算每列的标准差，返回一个表。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n**Note:** 该函数返回无偏差样本标准差（unbiased sample standard deviation），而不是总体标准差。\n\n#### 例子\n\n```\nstd(1 2 3);\n// output\n1\n\nm=matrix(1 3 5 7 9, 1 4 7 10 13);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 3  | 4  |\n| 5  | 7  |\n| 7  | 10 |\n| 9  | 13 |\n\n```\nstd(m);\n// output\n[3.162277660168379,4.743416490252569]\n```\n\n相关函数：[std](https://docs.dolphindb.cn/zh/funcs/s/std.html), [cumstd](https://docs.dolphindb.cn/zh/funcs/c/cumstd.html)\n"
    },
    "stdp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/stdp.html",
        "signatures": [
            {
                "full": "stdp(X)",
                "name": "stdp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [stdp](https://docs.dolphindb.cn/zh/funcs/s/stdp.html)\n\n\n\n#### 语法\n\nstdp(X)\n\n#### 参数\n\n**X** 可以是向量、矩阵或表。\n\n#### 详情\n\n若 *X* 为向量，返回 *X* 的总体标准差。\n\n若 *X* 为矩阵，计算每列的总体标准差，返回一个向量。\n\n若 *X* 为表，计算每列的总体标准差，返回一个表。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nstdp(1 2 3);\n// output\n0.816497\n\nm=matrix(1 3 5 7 9, 1 4 7 10 13);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 3  | 4  |\n| 5  | 7  |\n| 7  | 10 |\n| 9  | 13 |\n\n```\nstdp(m);\n// output\n[2.8284,4.2426]\n```\n\n相关函数：[std](https://docs.dolphindb.cn/zh/funcs/s/std.html), [cumstdp](https://docs.dolphindb.cn/zh/funcs/c/cumstdp.html)\n"
    },
    "stl": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/stl.html",
        "signatures": [
            {
                "full": "stl(data, period, sWindow, [sDegree], [sJump], [tWindow], [tDegree], [tJump], [lWindow], [lDegree], [lJump], [robust], [inner], [outer])",
                "name": "stl",
                "parameters": [
                    {
                        "full": "data",
                        "name": "data"
                    },
                    {
                        "full": "period",
                        "name": "period"
                    },
                    {
                        "full": "sWindow",
                        "name": "sWindow"
                    },
                    {
                        "full": "[sDegree]",
                        "name": "sDegree",
                        "optional": true
                    },
                    {
                        "full": "[sJump]",
                        "name": "sJump",
                        "optional": true
                    },
                    {
                        "full": "[tWindow]",
                        "name": "tWindow",
                        "optional": true
                    },
                    {
                        "full": "[tDegree]",
                        "name": "tDegree",
                        "optional": true
                    },
                    {
                        "full": "[tJump]",
                        "name": "tJump",
                        "optional": true
                    },
                    {
                        "full": "[lWindow]",
                        "name": "lWindow",
                        "optional": true
                    },
                    {
                        "full": "[lDegree]",
                        "name": "lDegree",
                        "optional": true
                    },
                    {
                        "full": "[lJump]",
                        "name": "lJump",
                        "optional": true
                    },
                    {
                        "full": "[robust]",
                        "name": "robust",
                        "optional": true
                    },
                    {
                        "full": "[inner]",
                        "name": "inner",
                        "optional": true
                    },
                    {
                        "full": "[outer]",
                        "name": "outer",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [stl](https://docs.dolphindb.cn/zh/funcs/s/stl.html)\n\n\n\n#### 语法\n\nstl(data, period, sWindow, \\[sDegree], \\[sJump], \\[tWindow], \\[tDegree], \\[tJump], \\[lWindow], \\[lDegree], \\[lJump], \\[robust], \\[inner], \\[outer])\n\n#### 参数\n\n**data** 是一个数值型向量，表示时间序列。\n\n**period** 是一个大于1的整数，表示时间序列的周期。\n\n**sWindow** 可以是一个字符串，它的取值只能是 \"periodic\"，表示在提取时间序列中的周期性时，不采取平滑算法，直接用平均值代替；*sWindow* 也可以是一个大于7的奇数，表示提取时间序列中的周期性时 Loess 窗口的长度。\n\n**sDegree** 可以是0,1或2，表示提取时间序列中的周期性时，局部拟合的多项式次数。默认值为1。\n\n**sJump** 是一个大于1的整数，表示提取时间序列的周期性时，每隔 *sJump* 个元素执行一次平滑计算。默认值为 ceil(*sWindow*/10)。\n\n**tWindow** 是一个正奇数，表示提取时间序列中的趋势性时 Loess 窗口的长度。默认值为 1.5 \\* *period* / (1 - (1.5 / *sWindow*)) 的下一个奇数。\n\n**tDegree** 可以是0,1或2，表示提取时间序列中的趋势性时，局部拟合的多项式次数。默认值为1。\n\n**tJump** 是一个大于1的整数，表示提取时间序列的趋势性时，每隔 *tJump* 个元素执行一次平滑计算。默认值为ceil(tWindow/10)。\n\n**lWindow** 是一个正奇数，表示提取时间序列的周期性时，每一个子序列的低通滤波器的 Loess 窗口长度。默认值为 *period* 的下一个奇数。\n\n**lDegree** 可以是0,1或2，表示子序列的低通滤波器中，局部拟合的多项式次数。默认值为1。\n\n**lJump** 是一个大于1的整数，表示子序列的低通滤波器中，每隔 *lJump* 个元素执行一次平滑计算。默认值为 ceil(*lWindow*/10)。\n\n**robust** 是一个布尔值，表示在 Loess 过程中是否采用稳健拟合。默认值为 false。\n\n**inner** 是一个大于等于1的整数，表示内部迭代次数，一般较小的取值即可满足需求。如果 *robust* 为 true，*inner* 的默认值为1，如果 *robust* 为 false，*inner* 的默认值为2。\n\n**outer** 是一个大于等于1的整数，表示外部迭代次数，用于增加稳健性。如果 *robust* 为 true，*outer* 的默认值为15，如果 *robust* 为 false，*outer* 的默认值为0。\n\n#### 详情\n\n使用 Loess 方法将一个时间序列分解为趋势性、季节性和随机性。返回的结果是一个包含以下 key 的字典：trend, seasonal 和 residual，每个 key 对应一个与 data 长度相同的向量。\n\n#### 例子\n\n```\nn = 100\ntrend = 6 * sin(1..n \\ 200)\nseasonal = sin(pi / 6 * 1..n)\nresidual = rand(1.0, n) - 0.5\ndata = trend + seasonal + residual\nres = stl(data, 12, \"periodic\");\n```\n\n我们可以在 DolphinDB GUI 中画图检验分解结果。\n\n```\nplot([trend, res.trend]);\n```\n\n![stl1](https://docs.dolphindb.cn/zh/images/stl01.png)\n\n```\nplot([seasonal, res.seasonal]);\n```\n\n![stl2](https://docs.dolphindb.cn/zh/images/stl02.png)\n"
    },
    "stopClusterReplication": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/stopClusterReplication.html",
        "signatures": [
            {
                "full": "stopClusterReplication()",
                "name": "stopClusterReplication",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [stopClusterReplication](https://docs.dolphindb.cn/zh/funcs/s/stopClusterReplication.html)\n\n\n\n#### 语法\n\nstopClusterReplication()\n\n#### 参数\n\n无\n\n#### 详情\n\n停止集群间的异步复制。该命令只能由管理员在主/从集群的控制节点调用。\n\n* 主集群：调用后，停止将任务放入发送队列。\n\n* 从集群：调用后，停止从主集群读取新任务，但执行中的任务不会停止。\n\n调用该命令前，必须先配置 *replicationMode* 参数。\n\n#### 例子\n\n```\nstopClusterReplication();\n```\n\n相关函数： [startClusterReplication](https://docs.dolphindb.cn/zh/funcs/s/startClusterReplication.html), [skipClusterReplicationTask](https://docs.dolphindb.cn/zh/funcs/s/skipClusterReplicationTask.html)\n"
    },
    "stopDataNode": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/stopDataNode.html",
        "signatures": [
            {
                "full": "stopDataNode(X)",
                "name": "stopDataNode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [stopDataNode](https://docs.dolphindb.cn/zh/funcs/s/stopDataNode.html)\n\n\n\n#### 语法\n\nstopDataNode(X)\n\n#### 参数\n\n**X** 是一个向量。包含了要停止的数据节点/计算节点的信息。\n\n#### 详情\n\n用于在集群控制器上停止数据节点/计算节点。\n\n#### 例子\n\n```\nx = [\"192.168.1.27:8506\",\"192.168.1.27:8502\",\"192.168.1.27:8527\"]\nstopDataNode(x);\n```\n"
    },
    "stopHeapSample": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/stopheapsample.html",
        "signatures": [
            {
                "full": "stopHeapSample()",
                "name": "stopHeapSample",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [stopHeapSample](https://docs.dolphindb.cn/zh/funcs/s/stopheapsample.html)\n\n\n\n#### 语法\n\nstopHeapSample()\n\n#### 参数\n\n无\n\n#### 详情\n\n动态关闭堆内存采样。仅管理员可执行该函数。\n\n#### 例子\n\n对内存使用情况进行分析的流程如下：\n\n1. 启用堆内存采样：可在启动 DolphinDB 前，设置环境变量 TCMALLOC\\_SAMPLE\\_PARAMETER 为1-524288之间的值（建议值 524288）；或通过函数 `startHeapSample` 动态开启。\n\n2. 在可能发生内存泄漏的操作前、后分别执行 `dumpHeapSample`，保存两个不同的文件。通过对比两个文件，确认操作涉及到的内存分配和使用情况。\n\n3. 关闭堆内存采样。\n\n```\nstartHeapSample(524288)\n\ndumpHeapSample(\"/DolphinDB/Data/heap1\")\ndumpHeapSample(\"/DolphinDB/Data/heap2\")\n\nstopHeapSample()\n```\n\n相关函数：[dumpHeapSample](https://docs.dolphindb.cn/zh/funcs/d/dumpheapsample.html), [startHeapSample](https://docs.dolphindb.cn/zh/funcs/s/startheapsample.html)\n"
    },
    "streamEngineParser": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/streamEngineParser.html",
        "signatures": [
            {
                "full": "streamEngineParser(name, metrics, dummyTable, outputTable, keyColumn, [timeColumn], [useSystemTime=false], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup], [filter], [keepOrder], [keyPurgeFilter], [keyPurgeFreqInSecond], [triggeringPattern='perBatch'], [triggeringInterval=1000], [lastBatchOnly=false], [contextByColumn], [updateTime], [useWindowStartTime=false], [roundTime=true], [forceTriggerTime], [sessionBegin], [sessionEnd], [mergeSessionEnd=false], [closed='left'], [fill='none'], [garbageSize], [forceTriggerSessionEndTime], [keyPurgeFreqInSec=-1])",
                "name": "streamEngineParser",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "metrics",
                        "name": "metrics"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "outputTable",
                        "name": "outputTable"
                    },
                    {
                        "full": "keyColumn",
                        "name": "keyColumn"
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[useSystemTime=false]",
                        "name": "useSystemTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[snapshotDir]",
                        "name": "snapshotDir",
                        "optional": true
                    },
                    {
                        "full": "[snapshotIntervalInMsgCount]",
                        "name": "snapshotIntervalInMsgCount",
                        "optional": true
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[filter]",
                        "name": "filter",
                        "optional": true
                    },
                    {
                        "full": "[keepOrder]",
                        "name": "keepOrder",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFilter]",
                        "name": "keyPurgeFilter",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSecond]",
                        "name": "keyPurgeFreqInSecond",
                        "optional": true
                    },
                    {
                        "full": "[triggeringPattern='perBatch']",
                        "name": "triggeringPattern",
                        "optional": true,
                        "default": "'perBatch'"
                    },
                    {
                        "full": "[triggeringInterval=1000]",
                        "name": "triggeringInterval",
                        "optional": true,
                        "default": "1000"
                    },
                    {
                        "full": "[lastBatchOnly=false]",
                        "name": "lastBatchOnly",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[contextByColumn]",
                        "name": "contextByColumn",
                        "optional": true
                    },
                    {
                        "full": "[updateTime]",
                        "name": "updateTime",
                        "optional": true
                    },
                    {
                        "full": "[useWindowStartTime=false]",
                        "name": "useWindowStartTime",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[roundTime=true]",
                        "name": "roundTime",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[forceTriggerTime]",
                        "name": "forceTriggerTime",
                        "optional": true
                    },
                    {
                        "full": "[sessionBegin]",
                        "name": "sessionBegin",
                        "optional": true
                    },
                    {
                        "full": "[sessionEnd]",
                        "name": "sessionEnd",
                        "optional": true
                    },
                    {
                        "full": "[mergeSessionEnd=false]",
                        "name": "mergeSessionEnd",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[closed='left']",
                        "name": "closed",
                        "optional": true,
                        "default": "'left'"
                    },
                    {
                        "full": "[fill='none']",
                        "name": "fill",
                        "optional": true,
                        "default": "'none'"
                    },
                    {
                        "full": "[garbageSize]",
                        "name": "garbageSize",
                        "optional": true
                    },
                    {
                        "full": "[forceTriggerSessionEndTime]",
                        "name": "forceTriggerSessionEndTime",
                        "optional": true
                    },
                    {
                        "full": "[keyPurgeFreqInSec=-1]",
                        "name": "keyPurgeFreqInSec",
                        "optional": true,
                        "default": "-1"
                    }
                ]
            }
        ],
        "markdown": "### [streamEngineParser](https://docs.dolphindb.cn/zh/funcs/s/streamEngineParser.html)\n\n\n\n#### 语法\n\nstreamEngineParser(name, metrics, dummyTable, outputTable, keyColumn, \\[timeColumn], \\[useSystemTime=false], \\[snapshotDir], \\[snapshotIntervalInMsgCount], \\[raftGroup], \\[filter], \\[keepOrder], \\[keyPurgeFilter], \\[keyPurgeFreqInSecond], \\[triggeringPattern='perBatch'], \\[triggeringInterval=1000], \\[lastBatchOnly=false], \\[contextByColumn], \\[updateTime], \\[useWindowStartTime=false], \\[roundTime=true], \\[forceTriggerTime], \\[sessionBegin], \\[sessionEnd], \\[mergeSessionEnd=false], \\[closed='left'], \\[fill='none'], \\[garbageSize], \\[forceTriggerSessionEndTime], \\[keyPurgeFreqInSec=-1])\n\n#### 详情\n\n在实际场景下，用户的因子可能嵌套横截面、历史状态、时序窗口、表连接等多种复杂逻辑，需要多个计算引擎的级联才能实现。`streamEngineParser` 为只涉及横截面、历史状态、时序窗口三种逻辑嵌套的复杂因子，提供了一个统一的计算入口。用户无需编写复杂的级联代码，只需将嵌套因子按规则改写后传入`streamEngineParser` ，系统将自动解析各层嵌套涉及的计算逻辑，形成流计算引擎流水线，自动分发给对应的引擎进行计算。\n\n为满足各逻辑对应引擎的功能，该函数集合了（日级）时序引擎、响应式状态引擎和横截面引擎的参数。需要注意的是，由于部分为公共参数（如 *keyColumn*），若公共参数在不同计算逻辑下需要指定的值不同（如时序窗口按天分组，状态逻辑要求按股票代码分组，则需要配置不同的 *keyColumn*），不能使用该函数，只能通过级联实现。\n\n返回一个表对象，为解析后流水线上第一个流计算引擎返回的表，向该表写入数据意味着这些数据进入流水线进行计算。删除时，需要根据 `streamEngineParser` 解析出的引擎对应的名称（详见 *name*）单独进行删除。暂不支持通过一个函数删除全部引擎。\n\n根据上文，若要使用 `streamEngineParser` ，必须根据业务场景提供的指标，分析业务中涉及的流计算引擎，将指标改写成 `streamEngineParser` 能够识别分解的 *metrics*。若 *metrics* 中包含了用户自定义函数，引擎对函数体内部的嵌套逻辑进一步进行解析。\n\n改写规则如下：\n\n1. **引擎分解标识**\n   * 若指标中的某一层嵌套逻辑要求计算截面数据，需将对应的计算函数改成以 “row开头” 的函数作为标识，若不添加 row 则该操作默认在响应式状态引擎处理。如：需要在截面计算排名，则需要将该层嵌套改写为 `rowRank`。\n\n     目前支持的标识函数如下：\n\n     ```\n     \"byRow\", \"rowAvg\", \"rowCount\", \"count\", \"rowDenseRank\", \"rowMax\", \"rowMin\", \"rowProd\", \"rowRank\",\n     \"rowSize\", \"rowSkew\", \"rowStd\", \"rowStdp\", \"rowSum\", \"rowSum2\", \"rowVar\", \"rowVarp\",\n     \"rowAnd\", \"rowOr\", \"rowXor\", \"rowKurtosis\", \"rowCorr\", \"rowCovar\", \"rowBeta\", \"rowWsum\", \"rowWavg\"\n     ```\n\n     用户自定义函数或者 row 系列函数不支持的逻辑可以通过 `byRow` 高阶函数实现。\n\n   * 若指标中的某一层嵌套逻辑涉及到时序聚合窗口的计算，必须在指标中以 [rolling](https://docs.dolphindb.cn/zh/funcs/ho_funcs/rolling.html) 作为标识进行改写。如：窗口为 3， 步长为 3，窗口内进行求和计算，计算列为 price，空值以前值填充，则可以写为 rolling(sum, price, 3, 3, 'ffill')。形式如下：\n\n     ```\n     rolling(func, funcArgs, window, [step=1], [fill='none'])\n     ```\n\n   * 分解时，不包含上述标识的内置函数均在响应式状态引擎中处理。\n\n2. **中间引擎输入表结构**\n\n   在 `streamEngineParser` 中，用户只能通过参数 *dummyTable* 指定第一个引擎输入表的 schema ，中间引擎的 *dummyTable* 对用户而言是透明的， 为了能在 *metrics* 和部分参数中指定中间表的列名，`streamEngineParser` 提供了一套中间引擎 *dummyTable* 的命名规范：\n\n   * 第一列为时间列。\n\n   * 之后几列对应指定的 *keyColumn*。\n\n   * 后续列为 *metrics* 对应的计算结果列，列名为：“col\\_0\\_, col\\_1\\_, col\\_2\\_...”。\n\n   **Note:**\n\n   * 由于响应式状态引擎的输出表没有时间列，而时间序列聚合引擎以及横截面引擎的输出表需包含时间列，因此当流水线中涉及到响应式状态引擎相关操作时，其 *metrics* 会自动增加时间列作为下一个引擎的 *dummyTable* 的一列。若此时 *useSystemTime* = true，则其中间表的时间列的列名为 \"datatime\"。\n   * 以下引擎的部分参数需要指定列名，如：\n\n     * 横截面引擎：*contextByColumn*\n     * 响应式状态引擎：*filter*, *keyPurgeFilter*\n       若这些参数需要指定中间引擎的 *dummyTable* 的列名，则可以根据如上的命名规则给出的列名进行指定，如 \"*contextByColumn* = col\\_0\\_\"。若指定的列为 *timeColumn* 和 *keyColumn*，则也可以指定参数对应的列名。\n\n#### 必选参数\n\n**name** 是一个字符串，表示指定流水线内引擎名称的前缀，可包含字母，数字和下划线，但必须以字母开头。比如指定 *name* = \"test\"，则流水线内部对应的引擎名称为 \"test0\", \"test1\", \"test2\"... 其中，数字代表 *metrics* 分解出的流数据引擎的级联顺序。\n\n**metrics** 以元代码的形式表示计算指标，支持输入元组。有关元代码的更多信息可参考 [Metaprogramming](https://docs.dolphindb.cn/zh/progr/objs/meta_progr.html)。\n\n* metrics 可以是系统内置或用户自定义的函数，如 <\\[sum(qty), avg(price)]>；可以对计算结果使用表达式，如 <\\[avg(price1)-avg(price2)]>；也可以对多列进行运算，如 <\\[std(price1-price2)]>。\n\n* metrics 内支持具有多个返回值的函数，例如 \\<func(price) as `col1`col2>（可不指定列名）。\n\n在 `streamEngineParser` 中，计算指标通常是一个嵌套的因子，每层嵌套逻辑都被解析后放入特定的引擎进行计算。更多说明见详情。\n\n**dummyTable** 一个表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。\n\n**outputTable** 计算结果的输出表，可以是内存表或者分布式表。调用 `streamEngineParser` 之前，需要将输出表预先设立为一个空表，并指定各列列名以及数据类型。各引擎会将计算结果插入该表。 若 *metrics* 分解的流水线上的最后一个操作对应：\n\n* **时序聚合引擎**\n\n  输出表的各列的顺序为：时间列，分组列，计算结果列。\n\n  其中：\n\n  * 第一列必须是时间类型。\n    * 若 *useSystemTime* = true，为 TIMESTAMP 类型。\n    * 若 *useSystemTime* = false，数据类型与 *timeColumn* 列一致。\n    * 若 *useWindowStartTime* = true，显示时间为数据窗口起始时间。\n    * 若 *useWindowStartTime* = false，显示时间为数据窗口终止时间。\n  * 如果 *keyColumn* 不为空，则其后几列和 *keyColumn* 设置的列及其顺序保持一致。\n  * 最后为计算结果列，可为多列。\n    最终的 schema 为“时间列，分组列(可选)，计算结果列1，计算结果列2...”这样的格式。\n\n* **响应式状态引擎**\n\n  输出表的各列的顺序为：分组列，计算结果列。\n\n  其中：\n\n  * 根据 *keyColumn* 的设置，输出表的前几列必须和 *keyColumn* 设置的列及其顺序保持一致。\n  * 其后为计算结果列，可为多列。\n\n* **横截面引擎**\n\n  输出表的 schema 需要遵循以下规范:\n\n  * 如果没有指定 *contextByColumn*， 输出表的列数为 *metrics* 数量+1，第一列为 TIMESTAMP 类型，用于存放发生计算的时间戳（如果指定了 *timeColumn* 则是对应记录的时间戳），其他列为 *metrics* 计算结果对应的列，其数据类型必须与 *metrics* 返回结果的数据类型一致。\n  * 如果指定 *contextByColumn*， 输出表的列数为 *metrics* 数量+2。第一列为 TIMESTAMP 类型，用于存放发生计算的时间戳（如果指定了 *timeColumn* 则是对应记录的时间戳）；第二列为 *contextByColumn* 指定的列；最后几列为 *metrics* 计算结果对应的列，其数据类型必须与 *metrics* 返回结果的数据类型一致。\n\n**keyColumn** 是一个字符串标量或向量。\n\n* 时序聚合引擎/响应式状态引擎：表示分组列名。若设置，计算按分组进行，例如以每支股票为一组进行聚合计算。\n\n* 横截面引擎：表示将某列值作为横截面引擎的 key，横截面引擎的每次计算，只使用每个 key 对应的最新一条记录。\n\n#### 可选参数\n\n**timeColumn** 指定订阅的流数据表中时间列的名称。当 *useSystemTime* = false 时，必须指定该参数。\n\n* 时序聚合引擎/响应式状态引擎：是一个字符串标量或向量。请注意，若为字符串向量，必须是 date 和 time 组成的向量，date 类型为 DATE，time 类型为 TIME, SECOND 或 NANOTIME。此时，输出表第一列的时间类型必须与 [concatDateTime(date, time)](https://docs.dolphindb.cn/zh/funcs/c/concatDateTime.html) 的类型一致。\n\n* 横截面引擎：是一个字符串，仅支持 TIMESTAMP 类型。\n\n**useSystemTime** 表示是否使用系统时间作为时间戳。\n\n* 横截面引擎：可选参数。表示 *outputTable* 中第一列（时间列）为系统当前时间( *useSystemTime* = true)或数据中时间列( *useSystemTime* = false)。\n\n* 时间序列聚合引擎：可选参数，表示时间序列引擎计算的触发方式。若指定该参数为 true，不能指定 *timeColumn*。\n\n  a. 当 *useSystemTime* = true 时，时间序列引擎会按照数据进入时间序列引擎的时刻（毫秒精度的本地系统时间，与数据中的时间列无关），每隔固定时间截取固定长度窗口的流数据进行计算。只要一个数据窗口中含有数据，数据窗口结束后就会自动进行计算。结果中的第一列为计算发生的时间戳，与数据中的时间无关。 b. 当 *useSystemTime* = false（缺省值）时，时间序列引擎根据流数据中的 timeColumn 列来截取数据窗口。一个数据窗口结束后的第一条新数据才会触发该数据窗口的计算。请注意，触发计算的数据并不会参与该次计算。\n\n若要开启快照机制 （snapshot），必须指定 *snapshotDir* 与 *snapshotIntervalInMsgCount*。启用快照机制之后，系统若出现异常，可及时将流数据引擎恢复到最新的快照状态。\n\n**snapshotDir** 可选参数，字符串，表示保存引擎快照的文件目录。\n\n* 指定的目录必须存在，否则系统会提示异常。\n\n* 创建流数据引擎时，如果指定了 *snapshotDir*，会检查该目录下是否存在快照。如果存在，会加载该快照，恢复引擎的状态。\n\n* 多个引擎可以指定同一个目录存储快照，用引擎的名称来区分快照文件。\n\n* 一个引擎的快照可能会使用三个文件名：\n\n* 临时存储快照信息：文件名为 \\<engineName>.tmp；\n\n* 快照生成并刷到磁盘：文件保存为 \\<engineName>.snapshot；\n\n* 存在同名快照：旧快照自动重命名为 \\<engineName>.old。\n\n**snapshotIntervalInMsgCount** 可选参数，为整数类型，表示每隔多少条数据保存一次流数据引擎快照。\n\n**raftGroup** 是流数据高可用订阅端 raft 组的 ID (大于1的整数，由流数据高可用相关的配置项 *streamingRaftGroups* 指定)。设置该参数表示开启计算引擎高可用。在 leader 节点创建流数据引擎后，会同步在 follower 节点创建该引擎。每次保存的 snapshot 也会同步到 follower。当 raft 组的 leader 节点宕机时，会自动切换新 leader 节点重新订阅流数据表。请注意，若要指定 *raftGroup*，必须同时指定 *snapshotDir*。\n\n该流水线引擎只能在 raft 组的 leader 节点创建。\n\n各引擎特有的参数如下：\n\n* 响应式状态引擎 [createReactiveStateEngine](https://docs.dolphindb.cn/zh/funcs/c/createReactiveStateEngine.html): *filter*, *keepOrder*, *keyPurgeFilter*, *keyPurgeFreqInSecond*\n\n* 横截面引擎参数 [createCrossSectionalEngine](https://docs.dolphindb.cn/zh/funcs/c/createCrossSectionalEngine.html): *triggeringPattern*, *triggeringInterval*, *lastBatchOnly*, *contextByColumn*\n\n* 时间序列聚合引擎 [createTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createTimeSeriesEngine.html): *updateTime*, *useWindowStartTime*, *roundTime*, *forceTriggerTime*, closed, fill, garbageSize, keyPurgeFreqInSec\n\n* 日级时间序列聚合引擎 [createDailyTimeSeriesEngine](https://docs.dolphindb.cn/zh/funcs/c/createDailyTimeSeriesEngine.html): *sessionBegin*, *sessionEnd*, *mergeSessionEnd*, closed, fill, garbageSize, forceTriggerSessionEndTime, keyPurgeFreqInSec\n\n**Note:** 如果 *triggeringPattern*='keyCount'，则 *keepOrder* 的默认值为 true，且不可设置为 false。\n\n#### 例子\n\n下面的例子是 World Quant 101 个 Alpha 因子中的1号因子公式的流数据实现。`rank` 函数是一个横截面操作。`rank` 的参数部分用响应式状态引擎实现。`rank` 函数本身用横截面引擎实现。横截面引擎作为状态引擎的输出。\n\n```\nn = 100\nsym = rand(`aaa`bbb`ccc, n)\ntime = 2021.01.01T13:30:10.008 + 1..n\nmaxIndex=rand(100.0, n)\ndata = table(sym as sym, time as time, maxIndex as maxIndex)\n```\n\n```\nrank(Ts_ArgMax(SignedPower((returns<0?stddev(returns,20):close), 2), 5))-0.5\n\n// 创建横截面引擎，计算每个股票的rank\ndummy = table(1:0, `sym`time`maxIndex, [SYMBOL, TIMESTAMP, DOUBLE])\nresultTable = streamTable(10000:0, `time`sym`factor1, [TIMESTAMP, SYMBOL, DOUBLE])\nccsRank = createCrossSectionalAggregator(name=\"alpha1CCS\", metrics=<[sym, rank(maxIndex, percent=true) - 0.5]>,  dummyTable=dummy, outputTable=resultTable,  keyColumn=`sym, triggeringPattern='keyCount', triggeringInterval=3000, timeColumn=`time, useSystemTime=false)\n\n@state\ndef wqAlpha1TS(close){\n    ret = ratios(close) - 1\n    v = iif(ret < 0, mstd(ret, 20), close)\n    return mimax(signum(v)*v*v, 5)\n}\n\n// 创建响应式状态引擎，输出到前面的横截面引擎ccsRank\ninput = table(1:0, `sym`time`close, [SYMBOL, TIMESTAMP, DOUBLE])\nrse = createReactiveStateEngine(name=\"alpha1\", metrics=<[time, wqAlpha1TS(close)]>, dummyTable=input, outputTable=ccsRank, keyColumn=\"sym\")\nrse.append!(data)\n\ndropStreamEngine(\"alpha1CCS\")\ndropStreamEngine(\"alpha1\")\n```\n\n上述操作可以通过直接构建流水线引擎进行替代：\n\n```\ninput = table(1:0, `sym`time`close, [SYMBOL, TIMESTAMP, DOUBLE])\nresultTable = streamTable(10000:0, `time`sym`factor1, [TIMESTAMP, SYMBOL, DOUBLE])\n\n// 构建计算因子\nmetrics=<[sym, rowRank(wqAlpha1TS(close), percent=true)- 0.5]>\n\nstreamEngine=streamEngineParser(name=`alpha1_parser, metrics=metrics, dummyTable=input, outputTable=resultTable, keyColumn=`sym, timeColumn=`time, triggeringPattern='keyCount', triggeringInterval=3000)\nstreamEngine.append!(data)\n\ndropStreamEngine(\"alpha1_parser0\")\ndropStreamEngine(\"alpha1_parser1\")\n```\n"
    },
    "streamFilter": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/streamFilter.html",
        "signatures": [
            {
                "full": "streamFilter(name, dummyTable, filter, [msgSchema], [timeColumn], [conditionColumn])",
                "name": "streamFilter",
                "parameters": [
                    {
                        "full": "name",
                        "name": "name"
                    },
                    {
                        "full": "dummyTable",
                        "name": "dummyTable"
                    },
                    {
                        "full": "filter",
                        "name": "filter"
                    },
                    {
                        "full": "[msgSchema]",
                        "name": "msgSchema",
                        "optional": true
                    },
                    {
                        "full": "[timeColumn]",
                        "name": "timeColumn",
                        "optional": true
                    },
                    {
                        "full": "[conditionColumn]",
                        "name": "conditionColumn",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [streamFilter](https://docs.dolphindb.cn/zh/funcs/s/streamFilter.html)\n\n\n\n#### 语法\n\nstreamFilter(name, dummyTable, filter, \\[msgSchema], \\[timeColumn], \\[conditionColumn])\n\n#### 详情\n\n创建流数据过滤引擎，对输入引擎的数据进行过滤和分发处理，返回一个表对象。\n\n该引擎的处理流程包含以下步骤：\n\n1. 输入数据为异构流数据表（由 [replay](https://docs.dolphindb.cn/zh/funcs/r/replay.html) 函数回放得到）时，解析（反序列化）数据。输入数据为普通流数据表时无此步骤。注意：1.30.18 版本开始，streamFilter 函数支持过滤普通流数据表数据，并进行分发处理。\n\n2. 根据 *filter* 指定的规则对流数据表进行过滤。\n\n3. 过滤后的数据按照时间顺序分发到不同的 *handler* 处理。\n\n**Note:**\n\n2.00.5 版本开始，DolphinDB 支持通过 [replay](https://docs.dolphindb.cn/zh/funcs/r/replay.html) 函数将多个结构不同的流数据表，回放（序列化）到一个流数据表里，这个流数据表被称为异构流数据表。`streamFilter` 函数用于解析（反序列化）和过滤异构流数据表的数据并进行分发处理。\n\n#### 参数\n\n**name** 字符串标量，表示流数据过滤引擎的名称，可包含字母，数字和下划线，但必须以字母开头。\n\n**dummyTable** 表对象，和订阅的流数据表的 schema 一致，可以含有数据，亦可为空表。\n\n**filter** 单个字典或包含多个字典的 tuple。对注入引擎的数据进行过滤和处理。\n\n字典可选的 key-value 说明如下：\n\n* 'timeRange'：可选字段，一个数据对或包含多个数据对的 tuple。以指定的 *timeRange* 对 *timeColumn* 进行过滤。注意：若分发普通流数据表，则 *timeRange* 必须和 *timeColumn* 的数据类型一致；异构流数据表无该限制。\n\n* 'condition'：表示过滤条件。\n\n* 若分发异构流数据表，则 'condition' 是一个字符串，且必须是 replay 参数 *inputTables* 的键值（表的标识）。用于过滤出异构表中具有 *condition* 标识的数据。\n\n* 若分发普通流数据表，则 'condition' 可以是一个字符串标量/向量，或者是包含一个或多个布尔表达式的元代码。其中表达式中可以使用内置函数，但不支持部分应用。请注意，若 'condition' 指定为字符串标量/向量，必须为 *conditionColumn* 指定列的元素。\n\n* 'handler'：一元函数或表对象（包括流数据引擎返回的表对象）。\n\n* 如果它是一元函数，它唯一的参数是经过解析和过滤后的数据表。\n\n* 如果它是表对象，经过解析和过滤后的数据会直接插入到该表中。\n\n**msgSchema** 可选字段，字典。\n\n* 若分发异构流数据表，其结构与 replay 回放到异构流数据表的数据表结构保持一致。引擎将根据 *msgSchema* 指定的结构对注入的数据解析;\n\n* 若分发普通流数据表，该参数必须设置为空。\n\n以下参数仅在分发普通流数据表时指定：\n\n**timeColumn** 字符串，指定为 *dummyTable* 中时间列的名称。若不指定，则取 *dummyTable* 第一列的列名。\n\n**conditionColumn** 字符串，指定为 *dummyTable* 中的列名。注意 *conditionColumn* 只能指定 STRING 或 SYMBOL 类型的列。若不指定该参数，则 *filter* 的 *condition* 字段将失效。\n\n#### 例子\n\n(1) 异构流数据表分发：\n\n一个典型场景：对分布式数据库中的订单表和交易表进行回放，模拟两者实时 asof join 的场景。如使用 replay 进行 N 对 N 回放，则无法保证数据严格按照时间戳 顺序注入 asof join 引擎的左表和右表（原因详见 `replay` 说明）。但通过 `replay` 将两表回放到一个异构流数据表则可以保证表内所有数据按照时间戳顺序排序， 之后通过 `streamFilter` 将表中数据分发至 asof join 引擎的左、右表时，可保证数据按时间戳顺序注入引擎左、右两表。\n\n```\n// 创建 order 表\nn=1000\nsym = take(take(\"IBM\",n).join(take(\"GS\",n)), n*2*3)\ndate=take(2022.01.04..2022.01.06, n*2*3).sort!()\ntimestamp1=take(2022.01.04 09:30:00.000+rand(1000,n),n) join take(2022.01.04 09:31:00.000+rand(1000,n),n)\ntimestamp2=take(2022.01.05 09:30:00.000+rand(1000,n),n) join take(2022.01.05 09:31:00.000+rand(1000,n),n)\ntimestamp3=take(2022.01.06 09:30:00.000+rand(1000,n),n) join take(2022.01.06 09:31:00.000+rand(1000,n),n)\ntimestamp=timestamp1 join timestamp2 join timestamp3\nvolume = rand(100, n*2*3)\nt=table(sym,date,timestamp,volume)\n\nif(existsDatabase(\"dfs://test_order\")){\ndropDatabase(\"dfs://test_order\")\n}\ndb1_or=database(\"\",RANGE, 2022.01.04..2022.01.07)\ndb2_or=database(\"\",VALUE,`IBM`GS)\ndb_or=database(\"dfs://test_order\",COMPO,[db1_or, db2_or])\norders=db_or.createPartitionedTable(t,`orders,`date`sym)\norders.append!(t);\nselect count(*) from orders\n// output\n6000\n\n// 创建trades表\nn=2000\nsym = take(take(\"IBM\",n).join(take(\"GS\",n)), n*2*3)\ndate=take(2022.01.04..2022.01.06, n*2*3).sort!()\ntimestamp1=take(2022.01.04 09:30:00.000+rand(1000,n),n) join take(2022.01.04 09:31:00.000+rand(1000,n),n)\ntimestamp2=take(2022.01.05 09:30:00.000+rand(1000,n),n) join take(2022.01.05 09:31:00.000+rand(1000,n),n)\ntimestamp3=take(2022.01.06 09:30:00.000+rand(1000,n),n) join take(2022.01.06 09:31:00.000+rand(1000,n),n)\ntimestamp=timestamp1 join timestamp2 join timestamp3\nvolume = rand(100, n*2*3)\nprice = rand(50.0, n*3) join  rand(20.0, n*3)\n\nt=table(sym,date,timestamp,volume,price)\n\nif(existsDatabase(\"dfs://test_trades\")){\ndropDatabase(\"dfs://test_trades\")\n}\ndb1=database(\"\",RANGE, 2022.01.04..2022.01.07)\ndb2=database(\"\",VALUE,`IBM`GS)\ndb=database(\"dfs://test_trades\",COMPO,[db1, db2])\ntrades=db.createPartitionedTable(t,`trades,`date`sym)\ntrades.append!(t);\nselect count(*) from trades\n// output\n12000\n\n// 准备回放的数据源和输出表\nds_or = replayDS(sqlObj=<select * from loadTable(db_or, `orders)>, dateColumn=`date, timeColumn=`timestamp)\nds = replayDS(sqlObj=<select * from loadTable(db, `trades)>, dateColumn=`date, timeColumn=`timestamp)\ninput_dict=dict([\"orders\",\"trades\"], [ds_or, ds])\nshare streamTable(100:0,`timestamp`sym`blob`volume, [TIMESTAMP,SYMBOL, BLOB, INT]) as opt\n\n\n// 订阅异构流数据表回放数据到分配引擎\nshare streamTable(100:0,`timestamp`sym`blob`volume, [TIMESTAMP,SYMBOL, BLOB, INT]) as streamFilterOpt\nshare streamTable(100:0, `sym`date`timestamp`volume, [SYMBOL, DATE, TIMESTAMP, INT] ) as streamOrders\nshare streamTable(100:0, `sym`date`timestamp`volume`price, [SYMBOL, DATE, TIMESTAMP, INT, DOUBLE] ) as streamTrades\nstreamOpt=table(100:0, `timestamp`sym`volume`price`result, [TIMESTAMP, SYMBOL, INT, DOUBLE, DOUBLE])\n\nfilter1=dict(STRING,ANY)\nfilter1['condition']=`orders\nfilter1['timeRange']=09:30:00.000:09:30:00.005\n\nfilter2=dict(STRING,ANY)\nfilter2['condition']=`trades\nfilter2['timeRange']=09:30:00.000:09:30:00.005\n\najEngine=createAsofJoinEngine(name=\"ajEngine\", leftTable=streamOrders, rightTable=streamTrades, outputTable=streamOpt, metrics=<[volume,price,price*volume]>, matchingColumn=`sym, useSystemTime=true)\nfilter1['handler']=getLeftStream(ajEngine)\nfilter2['handler']=getRightStream(ajEngine)\nschema=dict([\"orders\",\"trades\"], [streamOrders, streamTrades])\n\nengine=streamFilter(name=`streamFilter,dummyTable=streamFilterOpt, filter=[filter1,filter2],msgSchema=schema)\nsubscribeTable(tableName=\"opt\", actionName=\"sub1\", offset=0, handler=engine, msgAsTable=true)\n\n// 结构不同的两个表数据回放到opt\nreplay(inputTables=input_dict,outputTables=opt, timeColumn=`timestamp)\n\nselect count(*) from streamOpt\n// output\n20\n\n// 取消订阅\nunsubscribeTable(tableName=\"opt\", actionName=\"sub1\")\ndropStreamEngine(`streamFilter)\ndropStreamEngine(`ajEngine)\n```\n\n(2) 普通流数据表分发：\n\n下例，将普通流数据表（trades）数据注入分发引擎中，根据过滤条件进行分发处理。\n\n```\nn=20\nsym = symbol(take(`A`B`C,n))\nname = string(rand(1..10,n))\ndate = temporalAdd(2012.12.06,0..(n-1),'d')\ntime = temporalAdd(09:30:00.000,0..(n-1),'ms')\nvol = 100+take(1..8,20)\nt = table(date,time,sym,name,vol)\n\n// 定义两个流数据引擎，作为分发引擎 handler\nshare streamTable(100:0,`date`time`sym`name`vol,[DATE,TIME,SYMBOL,STRING,INT]) as st1\nshare streamTable(100:0,`date`time`sym`name`vol,[DATE,TIME,SYMBOL,STRING,INT]) as st2\nshare streamTable(100:0,`date`time`sym`name`vol,[DATE,TIME,SYMBOL,STRING,INT]) as st3\n\n// handler为引擎时的输入流数据表\nshare streamTable(100:0,`time`sym`sum_vol,[TIME,SYMBOL,INT]) as output1\nshare streamTable(100:0,`time`avg_vol,[TIME,INT]) as output2\nengine1=createTimeSeriesEngine(name=\"timeEngine\", windowSize=3, step=3, metrics=<[sum(vol)]>, dummyTable=st3, outputTable=output1, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50)\nengine2=createReactiveStateEngine(name=\"reactiveEngine\", metrics=<[mavg(vol, 3)]>, dummyTable=st1, outputTable=output2, keyColumn=`sym)\n\n// 需要注入分发引擎的流数据表\nshare streamTable(100:0,`date`time`sym`name`vol,[DATE,TIME,SYMBOL,STRING,INT]) as trades\n\n// 设置第一个过滤条件，将 trades 表中 sym 列对应元素为 A 且时间在09:30:00.001:09:30:00.010和09:29:00.000:09:30:00.000的数据输入状态引擎进行处理\nfilter1 = dict(STRING,ANY)\nfilter1['condition']=`A\nfilter1['handler']=engine2\nfilter1['timeRange']=(09:30:00.001:09:30:00.010,09:29:00.000:09:30:00.000)\n\n// 设置第二个过滤条件，将 trades 表时间范围在09:30:00.002:09:30:00.005里的数据全部输出到st2表里\nfilter2 = dict(STRING,ANY)\nfilter2['handler']=st2\nfilter2['timeRange']=09:30:00.002:09:30:00.005\n\n// 设置第三个过滤条件，将 trades 表中 sym 列对应元素为 A 和 C 的数据输入时序引擎进行处理\nfilter3 = dict(STRING,ANY)\nfilter3['condition']=`C`A\nfilter3['handler']=engine1\n\n// 订阅分发引擎，根据以上三个过滤条件，对 trades 表中的数据进行分发处理\nstreamFilter2=streamFilter(name=\"streamFilterDemo\",dummyTable=trades,filter=[filter1,filter2,filter3], timeColumn=`time, conditionColumn=`sym)\nsubscribeTable(tableName=\"trades\", actionName=\"sub1\", offset=0, handler=streamFilter2, msgAsTable=true)\ntrades.append!(t)\nselect * from output1\n```\n\n| time         | sym | sum\\_vol |\n| ------------ | --- | -------- |\n| 09:30:00.003 | A   | 101      |\n| 09:30:00.003 | C   | 103      |\n| 09:30:00.006 | A   | 104      |\n| 09:30:00.006 | C   | 106      |\n| 09:30:00.009 | A   | 107      |\n| 09:30:00.009 | C   | 101      |\n| 09:30:00.012 | A   | 102      |\n| 09:30:00.012 | C   | 104      |\n| 09:30:00.015 | A   | 105      |\n| 09:30:00.015 | C   | 107      |\n| 09:30:00.018 | A   | 108      |\n\n```\nselect * from output2\n```\n\n| time         | avg\\_vol |\n| ------------ | -------- |\n| 00:00:00.001 |          |\n| 00:00:00.001 |          |\n| 00:00:00.001 | 104      |\n| 00:00:00.001 | 104      |\n\n```\nselect * from st2\n```\n\n| date       | time         | sym | name | vol |\n| ---------- | ------------ | --- | ---- | --- |\n| 2012.12.08 | 09:30:00.002 | C   | 6    | 103 |\n| 2012.12.09 | 09:30:00.003 | A   | 8    | 104 |\n| 2012.12.10 | 09:30:00.004 | B   | 10   | 105 |\n| 2012.12.11 | 09:30:00.005 | C   | 10   | 106 |\n| 2012.12.12 | 09:30:00.006 | A   | 10   | 107 |\n| 2012.12.13 | 09:30:00.007 | B   | 1    | 108 |\n| 2012.12.14 | 09:30:00.008 | C   | 3    | 101 |\n| 2012.12.15 | 09:30:00.009 | A   | 4    | 102 |\n| 2012.12.16 | 09:30:00.010 | B   | 9    | 103 |\n\n可以为 condition 指定表达式，以支持更复杂的过滤逻辑，将上例中 filter2 的 *condition* 指定为条件表达式，同时对 vol 和 date 列进行过滤。\n\n```\nfilter2 = dict(STRING,ANY)\nfilter2['condition'] = <sym==`A and 101<vol<105 and date<2012.12.15>\nfilter2['handler'] = st2\nfilter2['timeRange'] = 09:30:00.002:09:30:00.010\n\nselect * from st2\n```\n\n| date       | time         | sym | name | vol |\n| ---------- | ------------ | --- | ---- | --- |\n| 2012.12.09 | 09:30:00.003 | A   | 7    | 104 |\n"
    },
    "streamTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/streamTable.html",
        "signatures": [
            {
                "full": "streamTable(X, [X1], [X2], .....)",
                "name": "streamTable",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            },
            {
                "full": "streamTable(capacity:size, colNames, colTypes)",
                "name": "streamTable",
                "parameters": [
                    {
                        "full": "capacity:size",
                        "name": "capacity:size"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "colTypes",
                        "name": "colTypes"
                    }
                ]
            }
        ],
        "markdown": "### [streamTable](https://docs.dolphindb.cn/zh/funcs/s/streamTable.html)\n\n\n\n#### 语法\n\nstreamTable(X, \\[X1], \\[X2], .....)\n\n或\n\nstreamTable(capacity:size, colNames, colTypes)\n\n#### 参数\n\n第一种情况中，**X**, **X1** ....是向量。\n\n第二种情况中：\n\n* **capacity** 是正整数，表示建表时系统为该表分配的内存（以记录数为单位）。当记录数超过 *capacity* 时，系统会首先会分配 *capacity* 1.2\\~2倍的新的内存空间，然后复制数据到新的内存空间，最后释放原来的内存。对于规模较大的表，此类操作的内存占用会很高。因此，建议建表时预先分配一个合理的 *capacity*。\n\n* **size** 是正整数，表示该表新建时的行数。若 *size*=0，创建一个空表。\n\n* **colNames** 是列名称的向量。\n\n* **colTypes** 是列类型的向量。\n\n#### 详情\n\n创建[流数据表](https://docs.dolphindb.cn/zh/stream/str_table.html)。流数据表可处理并发的读写操作。\n\n#### 例子\n\n```\nid=`XOM`GS`AAPL\nx=102.1 33.4 73.6\n\nrt=streamTable(id, x);\n\nrt=streamTable(`XOM`GS`AAPL as id, 102.1 33.4 73.6 as x);\n\ncolName=[\"Name\",\"Age\"]\ncolType=[\"string\",\"int\"]\nrt=streamTable(100:10, colName, colType);\n```\n"
    },
    "stretch": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/stretch.html",
        "signatures": [
            {
                "full": "stretch(X, n)",
                "name": "stretch",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [stretch](https://docs.dolphindb.cn/zh/funcs/s/stretch.html)\n\n\n\n#### 语法\n\nstretch(X, n)\n\n#### 参数\n\n**X** 向量/元组/矩阵/表。\n\n**n** 非负整数。\n\n#### 详情\n\n*X* 是向量/元组时，将 *X* 均匀拉伸为长度为 n 的向量/元组。\n\n*X* 是矩阵/表时，将 *X* 均匀拉伸为行数为 *n* 的矩阵/表。\n\n该函数与 [take](https://docs.dolphindb.cn/zh/funcs/t/take.html) 的区别为：\n\n`take` 是对向量整体进行循环拼接，而 `stretch` 则是对向量的每一个元素进行复制达到拉伸的效果。\n\n#### 例子\n\n```\nX = 1 NULL 2 3\nprint stretch(X, 11)\n```\n\n返回：\\[1,1,1,,,,2,2,2,3,3]\n\n```\nprint stretch(X, 12)\n```\n\n返回：\\[1,1,1,,,,2,2,2,3,3,3]\n\n以下用 `take` 做比较：\n\n```\nprint take(X, 10)\n```\n\n返回：\\[1,,2,3,1,,2,3,1,]\n\n另一个例子：\n\n```\nY=array(INT[], 0, 10).append!([1 NULL 3, 4 5, 6 NULL 8, 9 10]);\nprint stretch(Y,7)\n```\n\n返回：\\[\\[1,00i,3],\\[1,00i,3],\\[4,5],\\[4,5],\\[6,00i,8],\\[6,00i,8],\\[9,10]]\n\n```\ns=[1 2 3, 4 5 6]\nstretch(s, 5)\n```\n\n返回：\n\n|       | 0          | 1          | 2          | 3          | 4          |\n| ----- | ---------- | ---------- | ---------- | ---------- | ---------- |\n| **0** | \\[1, 2, 3] | \\[1, 2, 3] | \\[1, 2, 3] | \\[4, 5, 6] | \\[4, 5, 6] |\n\n```\nm=matrix(1 2 3, 4 5 6)\nstretch(m,5)\n```\n\n返回：\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 4    |\n| 1    | 4    |\n| 2    | 5    |\n| 2    | 5    |\n| 3    | 6    |\n\n```\nt=table(1 2 3 as a, 4 5 6 as b)\nstretch(t,5)\n```\n\n返回：\n\n| a | b |\n| - | - |\n| 1 | 4 |\n| 1 | 4 |\n| 2 | 5 |\n| 2 | 5 |\n| 3 | 6 |\n"
    },
    "string": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/string.html",
        "signatures": [
            {
                "full": "string(X)",
                "name": "string",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [string](https://docs.dolphindb.cn/zh/funcs/s/string.html)\n\n\n\n#### 语法\n\nstring(X)\n\n#### 详情\n\n将输入转化为一个字符串。\n\n#### 参数\n\n**X** 可以是任何数据类型。\n\n#### 例子\n\n```\nstring()==\"\";  // 创建一个新的字符串，默认值为\"\"。\n```\n\n返回：true\n\n```\nstring(10);\n```\n\n返回：10\n\n```\ntypestr string(108.5);\n```\n\n返回：STRING\n\n```\nstring(now());\n```\n\n返回：2024.02.22T15:09:40.931\n\n**Note:** 以 字符串形式返回当前系统时间。\n"
    },
    "stringFormat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/stringFormat.html",
        "signatures": [
            {
                "full": "stringFormat(format, [args...])",
                "name": "stringFormat",
                "parameters": [
                    {
                        "full": "format",
                        "name": "format"
                    },
                    {
                        "full": "[args...]",
                        "name": "[args...]"
                    }
                ]
            }
        ],
        "markdown": "### [stringFormat](https://docs.dolphindb.cn/zh/funcs/s/stringFormat.html)\n\n\n\n#### 语法\n\nstringFormat(format, \\[args...])\n\n#### 参数\n\n**format** 包含0个或多个占位符的字符串。\n\n**args...** 可选参数，1个或多个填入格式化字符串的值。若指定，则其数量和数据类型必须与 *format* 中的占位符的数量和类型一致。若不指定，则直接输出 *format*。\n\n#### 详情\n\n对字符串进行格式化处理，即将用户传入的值按指定的格式进行处理后填充到字符串中。在占位符内部，可以通过格式符指定进制格式、字段宽度、精度、对齐方式等选项，以便对输出进行更精确的控制。\n\n表一：占位符支持的数据类型列表\n\n| 类型            | 占位符(%数据类型符号) | args 示例                                                      |\n| ------------- | ------------ | ------------------------------------------------------------ |\n| BOOL          | %b           | 1b, 0b, true, false                                          |\n| CHAR          | %c           | 'a', 97c                                                     |\n| SHORT         | %h           | 122h                                                         |\n| 十进制整数（INT）    | %i           | 21                                                           |\n| 八进制整数         | %o           | 31                                                           |\n| 十六进制整数（小写）    | %x           | 2f                                                           |\n| 十六进制整数（大写）    | %X           | 2F                                                           |\n| LONG          | %l           | 25l                                                          |\n| DATE          | %d           | 2022.01.01                                                   |\n| MONTH         | %M           | 2022.05M                                                     |\n| TIME          | %t           | 13:00:10.706                                                 |\n| MINUTE        | %m           | 13:30m                                                       |\n| SECOND        | %s           | 13:30:10                                                     |\n| DATETIME      | %D           | 2012.06.13 13:30:10, 2012.06.13T13:30:10                     |\n| TIMESTAMP     | %T           | 2012.06.13 13:30:10.008, 2012.06.13T13:30:10.008             |\n| NANOTIME      | %n           | 13:30:10.008007006                                           |\n| NANOTIMESTAMP | %N           | 2012.06.13 13:30:10.008007006, 2012.06.13T13:30:10.008007006 |\n| FLOAT         | %f           | 2.1f                                                         |\n| DOUBLE        | %F           | 2.1                                                          |\n| SYMBOL        | %S           | symbol(\\[\"aaa\",\"bbb\"])                                       |\n| STRING        | %W           | \"Hello\"                                                      |\n| ANY（元组）       | %A           | (1, 45, 'sah')                                               |\n\n注意：若字符串包含 \"%\" ，则须通过百分号进行转义，即写为 \"%%\" 。\n\n在占位符内部（即在`%`与数据类型符号之间）插入一个或多个格式化操作符，对输出格式进行控制，书写形式为 `%[(var)][#][±][0][m/*][.][n/*]数据类型符号`。\n\n表二：以小数点为分隔，下表解释小数点前的部分支持的符号：\n\n| 符号        | 功能                                                                                                                                                                                                               | 用法示例                                                                                                                                                      |\n| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| m （一个正整数） | 支持在 %f, %F, %W 中使用。- 当占位符类型是 f 或 F 时，表示输出字符串的**最小**总宽度，默认使用空格填充宽度。 当 m 小于浮点数实际位数时，输出完整的浮点数（保留至小数点后六位）；当 m 大于浮点数实际位数时，默认填充空格。- 当占位符类型是 W 时，表示输出字符串的**最小**位数：当 m 小于字符串长度时，输出完整的字符串；当 m 大于字符串长度时，默认填充空格。默认对齐方式为右对齐。 | `stringFormat(\"%10f\", pi)`输出：`··3.141593` `stringFormat(\"%2f\", 12345.0)`输出：`12345.000000``stringFormat(\"%10W\", \"6chars\")`输出：`····6chars`                  |\n| \\*        | 与 m 功能类似，通过参数（*args*）指定输出字符串的宽度。在对应的 *args* 中指定具体宽度数值，形式为一个元组：`(宽度值，格式化字符串)`。                                                                                                                                    | 定义宽度：`stringFormat(\"%*f\", (10,pi))`输出：\\`··3.141593\\`                                                                                                      |\n| 0         | 当宽度不足时，在输出的字符串前填充“0”来实现指定宽度（左对齐时，从右边开始填充）。若不指定，则使用空格填充。                                                                                                                                                          | `stringFormat(\"%010f\", pi)`输出：`003.141593`                                                                                                                |\n| -         | 左对齐，仅适用于数值类型。若不指定该符号，则默认为右对齐。                                                                                                                                                                                    | `stringFormat(\"%-10.3f\", pi)`输出：`3.142`                                                                                                                   |\n| +         | 在正数前显示加号（+）。                                                                                                                                                                                                     | `stringFormat('%+f', pi)`输出：`+3.141593`                                                                                                                   |\n| (var)     | 映射变量，var 只能是字典形式。不可与其他操作符混用。                                                                                                                                                                                     | `employee = {\"name\":\"Lisa Mill\", \"year\":2010} stringFormat(\"%(name)W joined the company in %(year)i\", employee)`输出：`Lisa Mill joined the company in 2010` |\n| #         | 在八进制数前显示 “0o”；在十六进制前显示 ”0x“ （当数据类型符号为 “x“时）或者 “0X”（当数据类型符号为 “X” 时）。                                                                                                                                              | `stringFormat(\"%#o\", 33)`输出：`0o41``stringFormat(\"%#X\", 33)`输出：`0X21`                                                                                      |\n\n表三：小数点后的部分支持的符号（**仅支持在 %f, %F 和 %W 中使用**）：\n\n| 符号       | 功能                                                                                                                                      | 用法示例                                                                                                                                   |\n| -------- | --------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |\n| n（一个正整数） | - 当占位符类型是 f 或 F 时，表示小数点后保留位数。若 n 小于浮点数的小数位数，则会将浮点数四舍五入至指定位数；若该数字大于浮点数的小数位数，则会补零对齐。- 当占位符类型是 W 时，表示保留字符串位数。n 小于字符串长度时对字符串截断，大于字符串长度时不补充。 | `stringFormat(\"%10.5f\", pi)`输出：`···3.14159` `stringFormat('%10.3f' , 3.1)`输出：`·····3.100``stringFormat(\"%2.10W\", \"6chars\")`输出：`6chars` |\n| \\*       | 与 n 功能类似，在对应的 *args* 中指定输出字符串的小数点后的位数，形式为一个元组：`([宽度], [精度值], 格式化字符串的值)`。                                                                | 定义小数点后位数：`stringFormat(\"%.*f\", (5,pi))`输出：`3.14159`同时定义宽度与小数点位数：`stringFormat(\"%0*.*f\", (10,5,pi))`输出：`···3.14159`                     |\n\n#### 例子\n\n```\nstringFormat(\"date: %d, time: %t\", 2022.12.01, 10:12:45.065)\n```\n\n输出返回：date: 2022.12.01, time: 10:12:45.065\n\n```\nstringFormat(\"Students account for %i%% of our customers.\", 50)\n```\n\n输出返回：Students account for 50% of our customers.\n\n```\nt = datetime(now())\nstringFormat(\"The current time is %D.\", t)\n```\n\n输出返回：The current time is 2023.01.02T20:36:03.\n\n```\na = 7.596\nstringFormat(\"%-+10.5f\", a)\n```\n\n输出返回：+7.59600\n\n```\nstringFormat(\"%010.3f\", a) \n```\n\n输出返回：000007.596\n\n```\nproduct = {\"item\":\"Eggs\", \"price_per_unit\":2}\nstringFormat(\"%(item)W: $ %(price_per_unit)i\", product)\n```\n\n输出返回：Eggs: $ 2\n"
    },
    "strip": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/strip.html",
        "signatures": [
            {
                "full": "strip(X)",
                "name": "strip",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [strip](https://docs.dolphindb.cn/zh/funcs/s/strip.html)\n\n\n\n#### 语法\n\nstrip(X)\n\n#### 参数\n\n**X** 是字符串标量或向量。\n\n#### 详情\n\n去掉首尾所有空格，制表符，换行和回车符号。\n\n#### 例子\n\n```\nx=\"\\nhello world\\t\\n\";\nx;\n\n// output\nhello world\n\nstrip x;\n// output\nhello world\n```\n\n相关函数：[trim](https://docs.dolphindb.cn/zh/funcs/t/trim.html)\n"
    },
    "strlen": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/strlen.html",
        "signatures": [
            {
                "full": "strlen(X)",
                "name": "strlen",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [strlen](https://docs.dolphindb.cn/zh/funcs/s/strlen.html)\n\n\n\n#### 语法\n\nstrlen(X)\n\n#### 参数\n\n**X** 是目标字符串。它可以是标量或向量。\n\n#### 详情\n\n获取目标字符串的长度。\n\n#### 例子\n\n```\nstrlen('abcdefg');\n// output\n7\n\nstrlen(\"I am a boy.\");\n// output\n11\n\nstrlen([\"abc\",\"123456789\"]);\n// output\n[3,9]\n```\n"
    },
    "strlenu": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/strlenu.html",
        "signatures": [
            {
                "full": "strlenu(X)",
                "name": "strlenu",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [strlenu](https://docs.dolphindb.cn/zh/funcs/s/strlenu.html)\n\n\n\n#### 语法\n\nstrlenu(X)\n\n#### 参数\n\n**X** 是一个字符串标量或向量。\n\n#### 详情\n\n用于获取 Unicode 编码的目标字符串的长度。\n\n#### 例子\n\n```\nstrlenu(\"高性能分布式时序数据库\")\n// output\n11\n\n\nstrlenu([\"高性能分布式时序数据库\",\"DolphinDB\"])\n// output\n[11,9]\n```\n"
    },
    "strpos": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/strpos.html",
        "signatures": [
            {
                "full": "strpos(X, str)",
                "name": "strpos",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "str",
                        "name": "str"
                    }
                ]
            }
        ],
        "markdown": "### [strpos](https://docs.dolphindb.cn/zh/funcs/s/strpos.html)\n\n\n\n#### 语法\n\nstrpos(X, str)\n\n别名：strFind\n\n#### 参数\n\n**X** 是在该字符串中搜索。它可以是标量或向量。\n\n**str** 是被搜索的目标字符串。它必须是标量。\n\n#### 详情\n\n检查 *X* 是否包含 *str*。如果是，返回 *str* 在 *X* 中的起始位置； 否则返回-1。\n\n#### 例子\n\n```\nstrpos(\"abcdefg\",\"cd\");\n// output\n2\n\nstrpos(\"abcdefg\",\"d\");\n// output\n3\n\nstrpos(\"abcdefg\",\"ah\");\n// output\n-1\n```\n"
    },
    "strReplace": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/strReplace.html",
        "signatures": [
            {
                "full": "strReplace(str, pattern, replacement)",
                "name": "strReplace",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "pattern",
                        "name": "pattern"
                    },
                    {
                        "full": "replacement",
                        "name": "replacement"
                    }
                ]
            }
        ],
        "markdown": "### [strReplace](https://docs.dolphindb.cn/zh/funcs/s/strReplace.html)\n\n\n\n#### 语法\n\nstrReplace(str, pattern, replacement)\n\n#### 参数\n\n**str** 是目标字符串。它可以是标量或向量。\n\n**pattern** 是被替换的字符串。\n\n**replacement** 是替换的字符串。\n\n#### 详情\n\n返回 *str* 的副本。如果 *str* 包含 *pattern*，则将 *pattern* 替换为 *replacement*。\n\n#### 例子\n\n```\nstrReplace(\"The ball is red.\", \"red\", \"green\");\n// output\nThe ball is green.\n\nstrReplace([\"The ball is red.\", \"The car is red too.\"], \"red\", \"yellow\");\n// output\n[\"The ball is yellow.\",\"The car is yellow too.\"]\n```\n"
    },
    "sub": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sub.html",
        "signatures": [
            {
                "full": "sub(X, Y)",
                "name": "sub",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [sub](https://docs.dolphindb.cn/zh/funcs/s/sub.html)\n\n\n\n#### 语法\n\nsub(X, Y) 或 X-Y\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量、矩阵或集合。如果 *X* 或 *Y* 的其中一个是数据对、向量或矩阵，另一个参数可以是标量或具有相同长度或维度的数据对、向量或矩阵。\n\n#### 详情\n\n逐元素地返回 *X* 和 *Y* 的差。如果 *X* 和 *Y* 是集合， `sub` 返回一个集合，它是从 *X* 中减去 *X* 和 *Y* 相同元素后的集合。\n\n#### 例子\n\n```\n4:5-2;\n// output\n2 : 3\n\n4:5-1:2;\n// output\n3 : 3\n\nx=1 2 3;\nx-1;\n// output\n[0,1,2]\n\n1 sub x;\n// output\n[0,-1,-2]\n\ny=4 5 6;\nsub(x,y);\n// output\n[-3,-3,-3]\n\nm1=1..6$2:3;\nm1;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm-2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| -1 | 1  | 3  |\n| 0  | 2  | 4  |\n\n```\nm2=6..1$2:3;\nm2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 6  | 4  | 2  |\n| 5  | 3  | 1  |\n\n```\nm1-m2;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| -5 | -1 | 3  |\n| -3 | 1  | 5  |\n\n```\nx=set([5,3,4]);\ny=set(8 9 4 6);\nx-y;\n// output\nset(3,5)\n\ny-x;\n// output\nset(6,9,8)\n```\n"
    },
    "subarray": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/subarray.html",
        "signatures": [
            {
                "full": "subarray(X, range)",
                "name": "subarray",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "range",
                        "name": "range"
                    }
                ]
            }
        ],
        "markdown": "### [subarray](https://docs.dolphindb.cn/zh/funcs/s/subarray.html)\n\n\n\n#### 语法\n\nsubarray(X, range)\n\n#### 参数\n\n**X** 可以是向量或矩阵。\n\n**range** 是表示范围的数据对，范围包括下限，不包括上限。若 *range* 不在 \\[0, size(X)-1] 内，则超出 \\[0, size(X)-1] 的值所对应的位置返回空值。\n\n#### 详情\n\n当使用某个向量的一部分元素进行计算时，例如若使用 close\\[10:].avg() 的语句，系统会从向量 close 中复制数据产生一个新的向量 close\\[10:] 再进行计算，不仅占用更多内存而且耗时。\n\n`subarray` 函数返回输入向量的一个子向量。它是原向量的一个视图，只记录了原向量的指针以及子向量的开始和结束位置。由于并没有分配大块内存来存储新向量，所以没有发生数据复制。所有向量的只读操作都可直接应用于 `subarray` 。\n\n#### 例子\n\n```\nx=1..100\nsubarray(x, 10:20);\n// output\n[11,12,13,14,15,16,17,18,19,20]\n\n\nsubarray(x, 90:);\n// output\n[91,92,93,94,95,96,97,98,99,100]\n\n\nsubarray(x, :10);\n// output\n[1,2,3,4,5,6,7,8,9,10]\n\n\na=rand(1000.0,20000000);\ntimer a.subarray(0:1000000).avg();\n// output\nTime elapsed: 1.5 ms\n\ntimer a[0:1000000].avg();\n// output\nTime elapsed: 8 ms\n\n\n// subarray is read-only:\nb=a.subarray(0:1000000);\nb[0]=1;\n// output\nb[0] = 1 => Immutable sub vector doesn't support method set\n```\n"
    },
    "submitJob": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/submitJob.html",
        "signatures": [
            {
                "full": "submitJob(jobId, jobDesc, jobDef, args...)",
                "name": "submitJob",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    },
                    {
                        "full": "jobDesc",
                        "name": "jobDesc"
                    },
                    {
                        "full": "jobDef",
                        "name": "jobDef"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [submitJob](https://docs.dolphindb.cn/zh/funcs/s/submitJob.html)\n\n\n\n#### 语法\n\nsubmitJob(jobId, jobDesc, jobDef, args...)\n\n#### 参数\n\n**jobId** 是作业的 ID，是字符串类型。\n\n**jobDesc** 是字符串，用于描述作业。\n\n**jobDef** 是用于定义作业的本地函数。请注意，该参数是一个函数对象，而不是表示函数名的字符串，因此不可使用引号。\n\n**args...** 是函数的参数。如果函数没有参数，可以不指定。\n\n#### 详情\n\n把批处理作业提交到本地节点并且返回作业的 ID。如果要把批处理作业提交到远程节点，需要结合使用 `rpc` 或 [remoteRun](https://docs.dolphindb.cn/zh/funcs/r/remoteRun.html) 函数。详情请参考 [BatchJobManagement](https://docs.dolphindb.cn/zh/sys_man/BatchJobManagement.html)。\n\n#### 例子\n\n把作业提交到本地节点：\n\n```\ndef jobDemo(n){\n    s = 0\n    for (x in 1 : n) {\n        s += sum(sin rand(1.0, 100000000)-0.5)\n        print(\"iteration \" + x + \" \" + s)\n    }\n    return s\n};\n\nsubmitJob(\"jobDemo1\",\"job demo\", jobDemo, 100);\n// output\njobDemo1\n\ngetJobStatus(\"jobDemo1\");\n```\n\n| node      | userID | jobId    | rootJobId                            | jobDesc  | priority | parallelism | clientIp  | clientPort | receivedTime            | startTime               | endTime | errorMsg |\n| --------- | ------ | -------- | ------------------------------------ | -------- | -------- | ----------- | --------- | ---------- | ----------------------- | ----------------------- | ------- | -------- |\n| local8848 | guest  | jobDemo1 | d1d76cad-d46f-338c-4179-21cface3ce7c | job demo | 4        | 2           | 127.0.0.1 | 62016      | 2023.12.12T17:52:01.576 | 2023.12.12T17:52:01.585 |         |          |\n\n在作业的状态中，endTime 为空，这意味着作业还在执行中。作业完成后，就能在状态中看到 endTime 的值。\n\n```\ngetJobStatus(\"jobDemo1\");\n```\n\n| node      | userID | jobId    | rootJobId                            | jobDesc  | priority | parallelism | clientIp  | clientPort | receivedTime            | startTime               | endTime                 | errorMsg |\n| --------- | ------ | -------- | ------------------------------------ | -------- | -------- | ----------- | --------- | ---------- | ----------------------- | ----------------------- | ----------------------- | -------- |\n| local8848 | guest  | jobDemo1 | d1d76cad-d46f-338c-4179-21cface3ce7c | job demo | 4        | 2           | 127.0.0.1 | 62016      | 2023.12.12T17:52:01.576 | 2023.12.12T17:52:01.585 | 2023.12.12T17:53:23.204 |          |\n\n```\ngetJobMessage(\"jobDemo1\");\n\n// output\n2023-12-12 17:52:01.586399 Start the job [jobDemo1]: job demo\n2023-12-12 17:52:02.550241 iteration 1 1094.345887943766229\n2023-12-12 17:52:03.417464 iteration 2 3167.431462436133642\n2023-12-12 17:52:04.463558 iteration 3 5265.929786668073575\n...\n2023-12-12 17:53:21.609843 iteration 97 25681.096442654183192\n2023-12-12 17:53:22.401263 iteration 98 25609.952331757223873\n2023-12-12 17:53:23.204495 iteration 99 23660.316042780508723\n2023-12-12 17:53:23.204495 The job is done.\n\ngetJobReturn(\"jobDemo1\");\n// output\n924.915703\n\nsubmitJob(\"jobDemo2\",, jobDemo, 10);\n// output\njobDemo2\n\ngetRecentJobs();\n```\n\n| node      | userID | jobId    | rootJobId                            | jobDesc  | priority | parallelism | clientIp  | clientPort | receivedTime            | startTime               | endTime                 | errorMsg |\n| --------- | ------ | -------- | ------------------------------------ | -------- | -------- | ----------- | --------- | ---------- | ----------------------- | ----------------------- | ----------------------- | -------- |\n| local8848 | guest  | jobDemo1 | d1d76cad-d46f-338c-4179-21cface3ce7c | job demo | 4        | 2           | 127.0.0.1 | 62016      | 2023.12.12T17:52:01.576 | 2023.12.12T17:52:01.585 | 2023.12.12T17:53:23.204 |          |\n| local8848 | guest  | jobDemo2 | def84639-5b21-c6b0-47be-986b4563e192 | jobDemo  | 4        | 2           | 127.0.0.1 | 62016      | 2023.12.12T17:57:42.325 | 2023.12.12T17:57:42.327 | 2023.12.12T17:57:49.995 |          |\n\n把作业提交到远程节点：\n\n使用 `rpc` 函数（\"DFS\\_NODE2\" 与本地节点在同一集群）：\n\n```\ndef jobDemo(n){\n    s = 0\n    for (x in 1 : n) {\n        s += sum(sin rand(1.0, 100000000)-0.5)\n        print(\"iteration \" + x + \" \" + s)\n    }\n    return s\n}\n\nrpc(\"DFS_NODE2\", submitJob, \"jobDemo3\", \"job demo\", jobDemo, 10);\n// output\nOutput: jobDemo3\n\n\nrpc(\"DFS_NODE2\", getJobReturn, \"jobDemo3\");\n// output\nOutput: -3426.577521\n```\n\n* 使用 `remoteRun` 函数或 `remoteRunWithCompression` 函数，这里以 `remoteRun` 为例：\n\n```\nconn = xdb(\"DFS_NODE2\")\nconn.remoteRun(submitJob, \"jobDemo4\", \"job demo\", jobDemo, 10);\n// output\nOutput: jobDemo4\n\nconn.remoteRun(getJobReturn, \"jobDemo4\");\n// output\nOutput: 4238.832005\n```\n"
    },
    "submitJobEx": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/submitJobEx.html",
        "signatures": [
            {
                "full": "submitJobEx(jobId, jobDesc, priority, parallelism, jobDef, args...)",
                "name": "submitJobEx",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    },
                    {
                        "full": "jobDesc",
                        "name": "jobDesc"
                    },
                    {
                        "full": "priority",
                        "name": "priority"
                    },
                    {
                        "full": "parallelism",
                        "name": "parallelism"
                    },
                    {
                        "full": "jobDef",
                        "name": "jobDef"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [submitJobEx](https://docs.dolphindb.cn/zh/funcs/s/submitJobEx.html)\n\n\n\n#### 语法\n\nsubmitJobEx(jobId, jobDesc, priority, parallelism, jobDef, args...)\n\n#### 参数\n\n**jobId** 是作业的 ID，是字符串类型。\n\n**jobDesc** 是字符串，用于描述作业。\n\n**priority** 是0到9之间的整数，表示作业的优先级。9表示优先级最高。\n\n**parallelism** 是正整数，表示分配给该作业的线程数上限。\n\n**jobDef** 是用于定义作业的本地函数。请注意，该参数是一个函数对象，而不是表示函数名的字符串，因此不可使用引号。\n\n**args...** 是函数的参数。如果函数没有参数，它可以不指定。\n\n#### 详情\n\n把批处理作业提交到本地节点并且返回作业的ID。`submitJobEx` 与 [submitJob](https://docs.dolphindb.cn/zh/funcs/s/submitJob.html) 的唯一区别在于 `submitJobEx` 中可以指定参数 *priority* 与 *parallelism*。\n\n#### 例子\n\n```\ndef jobDemo(n){\n    s = 0\n    for (x in 1 : n) {\n        s += sum(sin rand(1.0, 100000000)-0.5)\n        print(\"iteration \" + x + \" \" + s)\n    }\n    return s\n};\n\nsubmitJobEx(\"jobDemo1\",\"job demo\", 8, 12, jobDemo, 100);\n```\n"
    },
    "submitJobEx2": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/submitJobEx2.html",
        "signatures": [
            {
                "full": "submitJobEx2(jobId, jobDesc, priority, parallelism, onComplete, jobDef, args...)",
                "name": "submitJobEx2",
                "parameters": [
                    {
                        "full": "jobId",
                        "name": "jobId"
                    },
                    {
                        "full": "jobDesc",
                        "name": "jobDesc"
                    },
                    {
                        "full": "priority",
                        "name": "priority"
                    },
                    {
                        "full": "parallelism",
                        "name": "parallelism"
                    },
                    {
                        "full": "onComplete",
                        "name": "onComplete"
                    },
                    {
                        "full": "jobDef",
                        "name": "jobDef"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [submitJobEx2](https://docs.dolphindb.cn/zh/funcs/s/submitJobEx2.html)\n\n#### 语法\n\nsubmitJobEx2(jobId, jobDesc, priority, parallelism, onComplete, jobDef, args...)\n\n#### 详情\n\n提交批处理作业到本地节点并返回作业的 ID，待作业完成后，执行回调函数。\n\n**Note:** `submitJobEx2` 与 [submitJobEx](https://docs.dolphindb.cn/zh/funcs/s/submitJobEx.html) 的区别在于：执行完成后，`submitJobEx2` 会执行回调函数。\n\n#### 参数\n\n**jobId** 是作业的 ID，字符串类型。\n\n**jobDesc** 是字符串，用于描述作业。\n\n**priority** 是 0 到 9 之间的整数，表示作业的优先级。9 表示优先级最高。\n\n**parallelism** 是正整数，表示分配给该作业的线程数上限。\n\n**onComplete** 是一个有 4 个参数的回调函数，细节请见以下例子。批处理作业执行完毕（包括有异常的情况）后，会执行该函数。\n\n**jobDef** 是用于定义作业的本地函数。\n\n**Note:** 该参数是一个函数对象，而非表示函数名的字符串，因此不可使用引号。\n\n**args…** 是函数的参数。如果函数没有参数，它可以不指定。\n\n#### 例子\n\n```\ndef jobDemo(n){\n    s = 0\n    for (x in 1 : n) {\n        s += sum(sin rand(1.0, 100000000)-0.5)\n        print(\"iteration \" + x + \" \" + s)\n    }\n    return s\n}\n\ndef cbFunc(jobId, jobDesc, success, result){\n    desc = jobId + \" \" + jobDesc\n    if(success){\n        desc += \" successful \" + result\n    }\n    else{\n        desc += \" with error: \" + result\n    }\n    writeLog(desc)\n}\n\nsubmitJobEx2(\"jobDemo1\",\"job demo\", 8, 12, cbFunc, jobDemo, 100)\n```\n\n"
    },
    "subscribeTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html",
        "signatures": [
            {
                "full": "subscribeTable([server],tableName,[actionName],[offset=-1],handler,[msgAsTable=false],[batchSize=0],[throttle=1],[hash=-1],[reconnect=false],[filter],[persistOffset=false],[timeTrigger=false],[handlerNeedMsgId=false],[raftGroup],[userId=\"\"],[password=\"\"],[udpMulticast=false])",
                "name": "subscribeTable",
                "parameters": [
                    {
                        "full": "[server]",
                        "name": "server",
                        "optional": true
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[actionName]",
                        "name": "actionName",
                        "optional": true
                    },
                    {
                        "full": "[offset=-1]",
                        "name": "offset",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "handler",
                        "name": "handler"
                    },
                    {
                        "full": "[msgAsTable=false]",
                        "name": "msgAsTable",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[batchSize=0]",
                        "name": "batchSize",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[throttle=1]",
                        "name": "throttle",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[hash=-1]",
                        "name": "hash",
                        "optional": true,
                        "default": "-1"
                    },
                    {
                        "full": "[reconnect=false]",
                        "name": "reconnect",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[filter]",
                        "name": "filter",
                        "optional": true
                    },
                    {
                        "full": "[persistOffset=false]",
                        "name": "persistOffset",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[timeTrigger=false]",
                        "name": "timeTrigger",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[handlerNeedMsgId=false]",
                        "name": "handlerNeedMsgId",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    },
                    {
                        "full": "[userId=\"\"]",
                        "name": "userId",
                        "optional": true,
                        "default": "\"\""
                    },
                    {
                        "full": "[password=\"\"]",
                        "name": "password",
                        "optional": true,
                        "default": "\"\""
                    },
                    {
                        "full": "[udpMulticast=false]",
                        "name": "udpMulticast",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [subscribeTable](https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html)\n\n\n\n#### 语法\n\nsubscribeTable(\\[server],tableName,\\[actionName],\\[offset=-1],handler,\\[msgAsTable=false],\\[batchSize=0],\\[throttle=1],\\[hash=-1],\\[reconnect=false],\\[filter],\\[persistOffset=false],\\[timeTrigger=false],\\[handlerNeedMsgId=false],\\[raftGroup],\\[userId=\"\"],\\[password=\"\"],\\[udpMulticast=false])\n\n#### 详情\n\n从客户端节点订阅本地或远程服务器的流数据表。可在 *handler* 调用函数来处理订阅数据。\n\n返回一个订阅主题（topic），即一个订阅的名称。它是一个字符串，由订阅表所在节点的别名、流数据表名称和订阅任务名称（如果指定了 *actionName*）组合而成，使用 \"/\" 分隔。如果订阅主题已经存在，函数将会抛出异常。\n\n* 如果指定了 *batchSize*，当未处理消息数量达到 *batchSize* 或距离上次 *handler* 被触发已过去 *throttle* 秒，*handler* 将会被触发。\n\n* 如果订阅的表被重定义了，为了保证订阅能够正常使用，需要使用 [unsubscribeTable](https://docs.dolphindb.cn/zh/funcs/u/unsubscribeTable.html) 命令取消订阅，然后重新创建订阅。\n\n* 在高可用订阅流数据写入分布式表的场景下，订阅节点构成的 raft 组发生 leader 切换或集群重启时，可能导致之前登录的用户退出。由于 guest 用户无权限写入分布式表，写入会被中断（可以通过 [getCurrentSessionAndUser](https://docs.dolphindb.cn/zh/funcs/g/getCurrentSessionAndUser.html) 函数查看当前的用户）。若配置 *userId* 和 *password* 参数，用户退出后系统会自动尝试重新登录，以保证订阅数据成功写入分布式表。需要注意的是，从 2.00.10.10 开始，用户可以通过配置项 *enhancedSecurityVerification* 控制在登录时是否约束密码重试的次数。若不设置 *enhancedSecurityVerification*，则不约束；若设置 *enhancedSecurityVerification*=true，则当用户登录时，在1分钟内连续5次使用了错误密码，会导致用户被锁定，必须等待10分钟后才可以再次登录。\n\n如果使用 UDP 组播作为订阅发布方式，为保证组播性能，需要为发布端所在服务器的 socket 缓冲区设置合理的数值，推荐数值大于或等于 1MB。在 Linux 中的 socket 缓冲区的设置方法如下：\n\n* 在 Linux 终端中，运行以下命令：\n\n  ```\n  sudo sysctl -w net.core.rmem_default=1048576\n  sudo sysctl -w net.core.rmem_max=1048576\n  sudo sysctl -w net.core.wmem_default=1048576\n  sudo sysctl -w net.core.wmem_max=1048576\n  ```\n\n* 也可以编辑 */etc/sysctl.conf* 文件，添加或修改 *net.core.rmem\\_default*, *net.core.rmem\\_max*, *net.core.wmem\\_default* 和 *net.core.wmem\\_max* 的值为 1048576 后运行\n\n  ```\n  sudo sysctl -p\n  ```\n\n**Note:** 在 TCP 和 UDP 之间切换订阅发布方式时，需要先使用 `unsubscibeTable` 取消已有订阅，再使用 `subscribeTable` 建立新的订阅任务。\n\n**Note:** 为流数据 join 引擎订阅数据时，*handler* 参数需要为 `appendForJoin`、[getLeftStream](https://docs.dolphindb.cn/zh/funcs/g/getLeftStream.html) 或 [getRightStream](https://docs.dolphindb.cn/zh/funcs/g/getRightStream.html) 函数。\n\n#### 参数\n\n只有 **tableName** 和 **handler** 两个参数是必选参数。其他所有参数都是可选参数。\n\n**server** 是一个字符串，表示服务器的别名或远程连接的句柄。如果未指定或者为空字符串，表示流数据所在的服务器是本地实例。\n\n**tableName** 是被订阅的数据表名。该表必须为共享的流数据表。\n\n**actionName** 是一个字符串，表示订阅任务的名称。它可以包含字母，数字和下划线，并以字母开头。如果一个节点有多个订阅任务均订阅了同一张表，则每个订阅必须指定唯一的 *actionName*。\n\n**offset** 是订阅任务开始后的第一条消息所在的位置。消息是流数据表中的行。\n\n* 如果未指定，或设为-1，订阅将会从流数据表的当前行开始。\n\n* 如果 *offset* = -2，系统会获取持久化到磁盘上的 *offset*，并从该位置开始订阅。注意：须同时设置 *persistOffset* = true，*offset* = -2 才会生效；否则 *offset* 会变为 -1。\n\n*offset* 与流数据表创建时的第一行对应。如果某些行因为内存限制被删除，在决定订阅开始的位置时，这些行仍然考虑在内。\n\n**handler** 是一元函数、二元函数或数据表，用于处理订阅的数据。\n\n* 一元函数：它唯一的参数是订阅的数据。订阅的数据可以是一个表或元组，订阅数据表的每个列是元组的一个元素。\n* *handlerNeedMsgId* = true 时，*handler* 必须是二元函数，其两个参数分别是订阅的数据（msgBody）和数据偏移量（msgId）。详见 *handlerNeedMsgId* 参数说明。\n* 数据表：可以是流数据引擎、共享流数据表、共享内存表、共享键值表、共享索引表或 DFS 表。订阅数据会直接插入到该表中。\n\n**msgAsTable** 是布尔值，表示订阅的数据是否为表。默认值是 false，表示订阅的数据是由列组成的元组。\n\n**batchSize** 是一个整数。若为正数，表示未处理消息的数量达到 *batchSize* 时，*handler* 才会处理消息。若未指定或为非正数，每一批次的消息到达之后，*handler* 就会马上处理。\n\n**throttle** 是一个浮点数，单位为秒，默认值为1。表示继上次 *handler* 处理消息之后，若 *batchSize* 条件一直未达到，多久后再次处理消息。如果没有指定 *batchSize*，*throttle* 即使指定，也不起作用。 若 *throttle* 需要设置小于1秒，则需要先修改配置项 *subThrottle*。\n\n**hash** 是一个非负整数，指定某个订阅线程处理进来的消息。如果没有指定该参数，系统会自动分配一个线程。如果需要使用同一个线程来处理多个订阅任务的消息，可把这些订阅任务的 hash 设置为相同的值。\n\n**reconnect** 是一个布尔值，表示订阅中断后，是否会自动重新订阅。默认值为 false。如果 *reconnect* = true，有以下三种情况：\n\n* 如果发布端与订阅端处于正常状态，但是网络中断，那么订阅端会在网络正常时，自动从中断位置重新订阅。\n* 如果发布端崩溃，订阅端会在发布端重启后不断尝试重新订阅。\n  * 如果发布端对流数据表启用了持久化，发布端重启后会首先读取硬盘上的数据，直到发布端读取到订阅中断位置的数据，订阅端才能成功重新订阅。\n  * 如果发布端没有对流数据表启用持久化，那么订阅端将自动重新订阅失败。\n* 如果订阅端崩溃，订阅端重启后不会自动重新订阅，需要重新执行 subscribeTable 函数。\n\n**Note:** 如果订阅高可用流数据表，需要设置 *reconnect* 为 true，以保证 leader 发生切换时可以成功连接新的 leader。\n\n**filter**用来指定过滤条件。主要分以下两种用法：\n\n* 若配合 [setStreamTableFilterColumn](https://docs.dolphindb.cn/zh/funcs/s/setStreamTableFilterColumn.html) 函数一起使用来指定流数据表的过滤列，则流数据表过滤列在 *filter* 中的数据才会发布到订阅端，不在 *filter* 中的数据不会发布。*filter* 不支持过滤 BOOL 类型数据。*filter* 参数可以使用以下三种方法指定。\n  * 值过滤：一个向量。\n  * 范围过滤：一个数据对。范围包含下限值，但不包括上限值。\n  * 哈希过滤：一个元组。第一个元素表示 bucket 的个数；第二个元素是一个标量或数据对，其中标量表示 bucket 的索引（从0开始），数据对表示 bucket 的索引范围（包含下限值，但不包括上限值）。\n\n* 若传入自定义函数进行灵活过滤，可以通过如下两种方式传入：\n\n  * 函数：直接传入一个函数，则订阅的数据会以表的形式传入函数，并把函数返回的结果发送给订阅者。\n\n  * 字符串：传入表示函数名称的字符串，或者是一个 lambda 表达式的字符串。\n\n**persistOffset** 是一个布尔值，表示是否持久化保存最新一条已经处理的订阅数据的偏移量。持久化保存的偏移量用于重订阅，可通过 [getTopicProcessedOffset](https://docs.dolphindb.cn/zh/funcs/g/getTopicProcessedOffset.html) 函数获取。默认值为 false。\n\n**Note:**\n\n* 若要订阅高可用流数据表，需要设置 *persistOffset* 为 true，以防止订阅端丢失数据。\n* 设置 *persistOffset* 为 true，且取消订阅（`unsubscribeTable`）时，设置 *removeOffset* = false，再次订阅时才会从持久化保存的偏移量开始订阅。\n\n**timeTrigger** 是一个布尔值。若设为 true，表示即使没有新的消息进入，*handler* 也会在 *throttle* 参数所设定的时间间隔被触发。\n\n**handlerNeedMsgId** 是一个布尔值，默认值为 false。\n\n* 若设为 true，*handler* 必须支持两个参数：一个是 msgBody（传入的消息），一个是 msgId（消息的偏移量）。如：以部分应用的形式固定 [appendMsg](https://docs.dolphindb.cn/zh/funcs/a/appendMsg.html) 的 *engine* 参数后，将其作为二元应用传入 *handler*。\n* 若设为 false，*handler* 仅支持一个参数：msgBody。调用 *handler* 时，只传入消息本身。\n\n**raftGroup** 是 raft 组的 ID。设置该参数表示开启订阅端高可用，不设置则表示普通订阅。设置 *raftGroup* 参数以指定 raft 组后，在对应 raft 组内 leader 发生切换时，新的 leader 会重新订阅。\n\n**Note:** `subscribeTable` 函数如果指定了 *raftGroup*，则只能在 leader 上执行。若同时指定 *handlerNeedMsgId* = true，则 *handler* 只能是计算引擎，即 *handler* = engine(创建引擎时的句柄变量)或 *handler* = getStreamEngine(engineName)。\n\n**userId** 字符串，表示用户名。\n\n**password** 字符串，表示用户密码。\n\n**udpMulticast** 布尔值，默认为 false。用于设置是否开启 UDP （User Datagram Protocol）Multicast 数据传输协议。设置为 true 后，发布端将通过 UDP 协议、以组播的方式将订阅数据发布到组播通道上。\n\n使用 TCP 和 UDP 组播进行发布订阅的性能差异如下：\n\n<table id=\"table_tjd_4pc_bbc\"><thead><tr><th>\n\n协议\n\n</th><th>\n\n优点\n\n</th><th>\n\n缺点\n\n</th><th>\n\n适用场景\n\n</th></tr></thead><tbody><tr><td>\n\nTCP\n\n</td><td>\n\n* 数据传输可靠，能够确保按序到达订阅端\n* 能够检测和纠正传输中的错误\n\n</td><td>\n\n一对一的连接方式决定了当订阅端为多个时，需要占用发布端大量的服务器资源及网络带宽\n\n</td><td>\n\n* 可靠性要求高\n* 顺序性要求高\n\n</td></tr><tr><td>\n\nUDP Multicast\n\n</td><td>\n\n* 可以一次性将数据发布给多个订阅端，适合实时数据传输\n* 发布端服务器资源和网络带宽占用少\n\n</td><td>\n\n数据包可能会缺失或乱序\n\n</td><td>\n\n有多个订阅端、要求快速实时传输数据\n\n</td></tr></tbody>\n</table>**Note:**\n\n1. 启用该参数前，需要确保 *reconnect*, *persisitOffset*, *timeTrigger* 设置为 false，以及 *raftGroup* 设置为 -1。\n2. 目前仅 Linux 版本的 DolphinDB Server 支持该参数。\n3. 在使用该参数前，请确保发布端和接收端所在的网络的路由器或交换机是否支持 UDP Multicast 协议栈。\n\n#### 例子\n\n例1\n\n下面是关于流计算的例子。在本例中，集群有两个节点：DFS\\_NODE1 和 DFS\\_NODE2。我们需要在 cluster.cfg 中指定 *maxPubConnections和subPort* 参数来启动发布/订阅功能。例如：\n\n```\nmaxPubConnections=32\nDFS_NODE1.subPort=9010\nDFS_NODE1.persistenceDir=C:/DolphinDB/Data\nDFS_NODE2.subPort=9011\n```\n\n在 DFS\\_NODE1 上执行以下脚本：\n\n1. 创建一个共享的流数据表 trades\\_stream，并以同步模式保存。此时，表 trades\\_stream 有0行记录。\n\n   ```\n   n=20000000\n   colNames = `time`sym`qty`price\n   colTypes = [TIME,SYMBOL,INT,DOUBLE]\n   enableTableShareAndPersistence(table=streamTable(n:0, colNames, colTypes), tableName=\"trades_stream\", asynWrite=false, cacheSize=n)\n   go\n   ```\n\n2. 创建一个分布式表 trades。此时，表 trades 有0行记录。\n\n   ```\n   if(existsDatabase(\"dfs://STREAM_TEST\")){\n        dropDatabase(\"dfs://STREAM_TEST\")\n   }\n   dbDate = database(directory=\"\", partitionType=VALUE, partitionScheme=temporalAdd(date(today()),0..30,'d'))\n   dbSym= database(directory=\"\", partitionType=RANGE, partitionScheme=string('A'..'Z') join \"ZZZZ\")\n   db = database(directory=\"dfs://STREAM_TEST\", partitionType=COMPO, partitionScheme=[dbDate, dbSym])\n   colNames = `date`time`sym`qty`price\n   colTypes = [DATE,TIME,SYMBOL,INT,DOUBLE]\n   trades = db.createPartitionedTable(table=table(1:0, colNames, colTypes), tableName=\"trades\", partitionColumns=`date`sym)\n   ```\n\n3. 创建表 trades\\_stream 的本地订阅。使用 saveTradesToDFS 函数把表 trades\\_stream 的流数据和今天的日期保存至表 trades。\n\n   ```\n   def saveTradesToDFS(mutable dfsTrades, msg): dfsTrades.append!(select today() as date,* from msg)\n   subscribeTable(tableName=\"trades_stream\", actionName=\"trades\", offset=0, handler=saveTradesToDFS{trades}, msgAsTable=true, batchSize=100000, throttle=60)\n   ```\n\n4. 创建表 trades\\_stream 的另一个本地订阅。使用每分钟的流数据计算成交量加权平均价格（vwap），并以异步模式把结果保存至共享的流数据表 vwap\\_stream 中。\n\n   ```\n   n=1000000\n   tmpTrades = table(n:0, colNames, colTypes)\n   lastMinute = [00:00:00.000]\n   colNames = `time`sym`vwap\n   colTypes = [MINUTE,SYMBOL,DOUBLE]\n   enableTableShareAndPersistence(table=streamTable(n:0, colNames, colTypes), tableName=\"vwap_stream\")\n   go\n\n   def calcVwap(mutable vwap, mutable tmpTrades, mutable lastMinute, msg){\n       tmpTrades.append!(msg)\n       curMinute = time(msg.time.last().minute()*60000l)\n       t = select wavg(price, qty) as vwap from tmpTrades where time < curMinute, time >= lastMinute[0] group by time.minute(), sym\n       if(t.size() == 0) return\n       vwap.append!(t)\n       t = select * from tmpTrades where time >= curMinute\n       tmpTrades.clear!()\n       lastMinute[0] = curMinute\n       if(t.size() > 0) tmpTrades.append!(t)\n   }\n   subscribeTable(tableName=\"trades_stream\", actionName=\"vwap\", offset=0, handler=calcVwap{vwap_stream, tmpTrades, lastMinute}, msgAsTable=true, batchSize=100000, throttle=60)\n   ```\n\n在 DFS\\_NODE2 上执行以下脚本，创建表 trades\\_stream 的远程订阅，并以异步模式把流数据保存至表 trades\\_stream\\_slave 中。\n\n```\nn=20000000\ncolNames = `time`sym`qty`price\ncolTypes = [TIME,SYMBOL,INT,DOUBLE]\nenableTableShareAndPersistence(table=streamTable(n:0, colNames, colTypes), tableName=\"trades_stream_slave\", cacheSize=n)\ngo\nsubscribeTable(server=\"DFS_NODE1\", tableName=\"trades_stream\", actionName=\"slave\", offset=0, handler=trades_stream_slave)\n```\n\n在 DFS\\_NODE1 上执行以下脚本，模拟3支股票在10分钟内的流数据。每支股票每分钟生成2,000,000条记录。每分钟的数据被插入到流数据表 trades\\_stream 的600个数据块中。每两个数据块有100毫秒的时间间隔。\n\n```\nn=10\nticks = 2000000\nrows = ticks*3\nstartMinute = 09:30:00.000\nblocks=600\nfor(x in 0:n){\n    time = startMinute + x*60000 + rand(60000, rows)\n    indices = isort(time)\n    time = time[indices]\n    sym = array(SYMBOL,0,rows).append!(take(`IBM,ticks)).append!(take(`MSFT,ticks)).append!(take(`GOOG,ticks))[indices]\n    price = array(DOUBLE,0,rows).append!(norm(153,1,ticks)).append!(norm(91,1,ticks)).append!(norm(1106,20,ticks))[indices]\n    indices = NULL\n    blockSize = rows / blocks\n    for(y in 0:blocks){\n        range =pair(y * blockSize, (y+1)* blockSize)\n        insert into trades_stream values(subarray(time,range), subarray(sym,range), 10+ rand(100, blockSize), subarray(price,range))\n        sleep(100)\n    }\n\n    blockSize = rows % blocks\n    if(blockSize > 0){\n        range =pair(rows - blockSize, rows)\n        insert into trades_stream values(subarray(time,range), subarray(sym,range), 10+ rand(100, blockSize), subarray(price,range))\n    }\n}\n```\n\n在 DFS\\_NODE1 上执行以下脚本来检查结果：\n\n```\ntrades=loadTable(\"dfs://STREAM_TEST\", `trades)\nselect count(*) from trades\n```\n\n预期结果有 60,000,000 条记录。\n\n```\nselect * from vwap_stream\n```\n\n表 vwap\\_stream 预期有 27 条记录。\n\n在 DFS\\_NODE2 上执行以下脚本：\n\n```\nselect count(*) from trades_stream_slave\n```\n\n我们看到的结果小于 60,000,000 行，因为部分表的记录已经保存到磁盘中。\n\n例2\n\n在集群的 dnode1 上执行以下脚本创建流数据表 publisher：\n\n```\nshare streamTable(10:0,`time`id`value,[TIMESTAMP,INT,DOUBLE])\n              as publisher\n```\n\n在 dnode2 节点执行以下脚本，采用 UDP 组播订阅 dnode1 上的 publisher，将其写入本地流表 sub1：\n\n```\nsub1 = streamTable(10:0,`time`id`value,[TIMESTAMP,INT,DOUBLE])\n            subscribeTable(server=\"dnode1\",tableName=\"publisher\",actionName=\"sub1\",offset=-1,handler=append!{sub1},msgAsTable=true,\n            udpMulticast=true)\n```\n\n在 dnode1 节点模拟数据写入：\n\n```\npublisher.tableInsert(table(now()+1..10*1000 as time,1..10 as\n              id, rand(100,10) as value))\n```\n\n此时在 dnode1 可以查看 UDP 组播发布状态：\n\n`getStreamingStat().udpPubTables`\n\n| tableName | channel        | msgOffset | actions | subNum |\n| --------- | -------------- | --------- | ------- | ------ |\n| publisher | 224.1.1.1:1235 | 10        | sub1    | 1      |\n\n在 dnode2 可以查看订阅工作线程状态\n\n`getStreamingStat().subWorkers`\n\n| workerId | topic | type                                 | queueDepthLimit | queueDepth | processedMsgCount | lastMsgId | failedMsgCount | lastFailedMsgId | lastFailedTimestamp | lastErrMsg | msgAsTable | batchSize | throttle | hash | filter | persistOffset | timeTrigger | handlerNeedMsgId | raftGroup |\n| -------- | ----- | ------------------------------------ | --------------- | ---------- | ----------------- | --------- | -------------- | --------------- | ------------------- | ---------- | ---------- | --------- | -------- | ---- | ------ | ------------- | ----------- | ---------------- | --------- |\n| 0        | 2     | localhost:8702:dnode1/publisher/sub1 | udp             | 10,000,000 | 0                 | 10        | 9              | 0               | -1                  |            |            | true      | 0        | 0    | 1      |               | false       | false            | false     |\n\n例3\n\n传入自定义函数 `filterFn` 对订阅数据进行过滤。\n\n```\nst = streamTable(100:0, `sym`val, `SYMBOL`DOUBLE)\nenableTableShareAndPersistence(st, `st1, cacheSize=1000)\n\noutTable = table(100:0, `sym`val, `SYMBOL`DOUBLE)\n\nfilterFn = def (msg) {\n\treturn (select * from msg where val > 50.0)\n}\n\nsubscribeTable(tableName=`st1, actionName=`testFilter, handler=tableInsert{outTable}, filter=\"filterFn\", offset=0)\n\nfor (i in 1..100) {\n\tn = 100\n\tt = table(rand(`A`B`C, n) as sym, rand(100.0, n) as val)\n\tst.append!(t)\n}\nselect * from outTable\n```\n\n`subscribeTable` 中关于参数 *filter*的另一种表述方式：\n\n```\nfilterFn = \"def (msg) { return (select * from msg where val > 50.0) }\"\nsubscribeTable(tableName=`st1, actionName=`testFilter, handler=tableInsert{outTable}, filter=filterFn, offset=0)\n```\n"
    },
    "substr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/substr.html",
        "signatures": [
            {
                "full": "substr(X, offset, [length])",
                "name": "substr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "offset",
                        "name": "offset"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [substr](https://docs.dolphindb.cn/zh/funcs/s/substr.html)\n\n\n\n#### 语法\n\nsubstr(X, offset, \\[length])\n\n#### 参数\n\n**X** 是一个字符串。它可以是标量或向量。\n\n**offset** 是一个非负整数。\n\n**length** 是一个正整数。\n\n#### 详情\n\n从 *X* 的指定位置开始截取指定长度的字符串。*X* 的第一个字符的位置为0。如果 *length* 超过了 *X* 的长度，则到 *X* 的尾部结束。\n\n#### 例子\n\n```\nsubstr(\"This is a test\", 0, 4);\n// output\nThis\n\nsubstr(\"This is a test\", 5, 2);\n// output\nis\n\nsubstr(\"This is a test\", 5);\n// output\nis a test\n\nsubstr(\"This is a test\", 8, 100);\n// output\na test\n```\n"
    },
    "substru": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/substru.html",
        "signatures": [
            {
                "full": "substru(X, offset, [length])",
                "name": "substru",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "offset",
                        "name": "offset"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [substru](https://docs.dolphindb.cn/zh/funcs/s/substru.html)\n\n\n\n#### 语法\n\nsubstru(X, offset, \\[length])\n\n#### 参数\n\n**X** 是 Unicode 编码的字符串。它可以是标量或向量。\n\n**offset** 是一个非负整数。\n\n**length** 是一个正整数。\n\n#### 详情\n\n从 *X* 的指定位置开始截取指定长度的字符串。*X* 的第一个字符的位置为0。 如果 *length* 超过了 *X* 的长度，则到 *X* 的尾部结束。\n\n#### 例子\n\n```\nsubstru(\"这是测试字符串\",0,4)\n// output\n这是测试\n\nsubstru(\"这是测试字符串\",4,3)\n// output\n字符\n\nsubstru(\"这是测试字符串\",2)\n// output\n测试字符串\n\nsubstru(\"这是测试字符串\",2,10)\n// output\n测试字符串\n```\n\n相关函数：[substr](https://docs.dolphindb.cn/zh/funcs/s/substr.html)\n"
    },
    "subtuple": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/subtuple.html",
        "signatures": [
            {
                "full": "subtuple(X, range)",
                "name": "subtuple",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "range",
                        "name": "range"
                    }
                ]
            }
        ],
        "markdown": "### [subtuple](https://docs.dolphindb.cn/zh/funcs/s/subtuple.html)\n\n\n\n#### 语法\n\nsubtuple(X, range)\n\n#### 参数\n\n**X** 是一个元组，它的每个元素必须是长度相同的向量。\n\n**range** 是一个整型数据对，表示范围，只包含下限不包含上限。\n\n#### 详情\n\n创建 *X* 的只读子元组。*subtuple* 几乎能在瞬间创建一个只读向量，相比之下，创建一个新的元组需要耗费更多时间。\n\n#### 例子\n\n例1：\n\n```\nx=(1..10, 11..20, 21..30, 31..40)\nsubtuple(x, 2:4);\n// output\n([3,4],[13,14],[23,24],[33,34])\n```\n\n例2：\n\n```\nm=1000.0\nn=20000000\na=(rand(m,n), rand(m,n))\nk=10000000;\ntimer each(avg, a.subtuple(0:k));\n// output\nTime elapsed: 30.87 ms\n\ntimer each(avg, (a[0][0:k], a[1][0:k]));\n// output\nTime elapsed: 46.508 ms\n```\n\n例3：\n\n```\nx=(1..10, 11..20)\nsubtuple(x, 2:4)=([4, 5], [14, 15]);\n// output\nSyntax Error: [line #2] Please use '==' rather than '=' as equal operator in non-sql expression.\n```\n\n`subtuple` 函数创建的元组只能读取，不能写入。\n"
    },
    "sum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sum.html",
        "signatures": [
            {
                "full": "sum(X)",
                "name": "sum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sum](https://docs.dolphindb.cn/zh/funcs/s/sum.html)\n\n\n\n#### 语法\n\nsum(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n* 若 *X* 为向量，返回 *X* 中所有元素之和。\n\n* 若 *X* 为矩阵，计算每列元素之和，返回一个向量。\n\n* 若 *X* 为表，计算每列元素之和，返回一个表。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n如果 *X* 中的所有元素为 NULL，`sum` 返回的结果为 NULL。\n\n#### 例子\n\n```\nsum(1 2 3 NULL 4);\n// output\n10\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nsum(m);\n// output\n[6,15]\n```\n"
    },
    "sum2": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sum2.html",
        "signatures": [
            {
                "full": "sum2(X)",
                "name": "sum2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sum2](https://docs.dolphindb.cn/zh/funcs/s/sum2.html)\n\n\n\n#### 语法\n\nsum2(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n若 *X* 为向量，返回 *X* 中所有元素的平方和。\n\n若 *X* 为矩阵，计算每列元素的平方和，返回一个向量。\n\n若 *X* 为表，计算每列元素的平方和，返回一个表。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n即使 *X* 的数据类型是 INT 或 LONG, `sum2` 返回结果的数据类型总是 DOUBLE 类型。如果 *X* 中的所有元素为 NULL, `sum2` 返回的结果为 NULL。\n\n#### 例子\n\n```\nsum2(1 2 3);\n// output\n14\n\nsum2(1 NULL NULL);\n// output\n1\n\nsum2(1.5 4.6 7.8);\n// output\n84.25\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nsum2(m);\n// output\n[14,77]\n```\n"
    },
    "sum3": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sum3.html",
        "signatures": [
            {
                "full": "sum3(X)",
                "name": "sum3",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sum3](https://docs.dolphindb.cn/zh/funcs/s/sum3.html)\n\n\n\n#### 语法\n\nsum3(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n若 *X* 为向量，返回 *X* 中所有元素的立方和。\n\n若 *X* 为矩阵，计算每列元素的立方和，返回一个向量。\n\n若 *X* 为表，计算每列元素的立方和，返回一个表。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n即使 *X* 的数据类型是 INT 或 LONG，返回结果的数据类型总是 DOUBLE 类型。如果 *X* 中的所有元素为 NULL，返回的结果为 NULL。\n\n#### 例子\n\n```\nsum3(1 2 3);\n// output\n36\n\nsum3(1 NULL NULL);\n// output\n1\n\nsum3(1.5 4.6 7.8);\n// output\n575.263\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nsum3(m);\n// output\n[36,405]\n```\n"
    },
    "sum4": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sum4.html",
        "signatures": [
            {
                "full": "sum4(X)",
                "name": "sum4",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [sum4](https://docs.dolphindb.cn/zh/funcs/s/sum4.html)\n\n\n\n#### 语法\n\nsum4(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n若 *X* 为向量，返回 *X* 中所有元素的四次方和。\n\n若 *X* 为矩阵，计算每列元素的四次方和，返回一个向量。\n\n若 *X* 为表，计算每列元素的四次方和，返回一个表。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n即使 *X* 的数据类型是 INT 或 LONG，返回结果的数据类型总是 DOUBLE 类型。如果 *X* 中的所有元素为 NULL，返回的结果为 NULL。\n\n#### 例子\n\n```\nsum4(1 2 3);\n// output\n98\n\nsum4(1 NULL NULL);\n// output\n1\n\nsum4(1.5 4.6 7.8);\n// output\n4154.3137\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nsum4(m);\n// output\n[98,2177]\n```\n"
    },
    "sumbars": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/sumbars.html",
        "signatures": [
            {
                "full": "sumbars(X, Y)",
                "name": "sumbars",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [sumbars](https://docs.dolphindb.cn/zh/funcs/s/sumbars.html)\n\n\n\n#### 语法\n\nsumbars(X, Y)\n\n#### 参数\n\n**X** 向量/矩阵/元组/表。其元素必须为非负数。\n\n**Y** 向量/标量，表示累加和的阈值。\n\n* 若 *X* 为向量， *Y* 是一个标量；\n\n* 若 *X* 是元组，*Y* 是一个与 *X* 长度相同的向量；\n\n* 若 *X* 为矩阵/表，*Y* 是一个长度与 *X* 列数相同的向量。\n\n#### 详情\n\n对 *X* 中每个元素，计算其向前累加直到不小于指定值 *Y* 时经过的周期数。若 *X* 向前的所有元素累加后的值仍不能大于等于 *Y*，则返回0。\n\n#### 例子\n\n```\nsumbars(1 2 3.3 2 5, 3)\n// output\n[0,2,1,2,1]\n\nsumbars(matrix(5 3 6 2 3, 2 6 1 5 4), [5, 8])\n```\n\n| col1 | col2 |\n| ---- | ---- |\n| 1    | 0    |\n| 2    | 2    |\n| 1    | 3    |\n| 2    | 3    |\n| 2    | 2    |\n\n```\n# 求完全换手到现在的周期数。\n# calculate the turnover period\nid = `A`A`B`A`C`B`A`C`A`B\ntime = 2022.01.01T09:00:00 + 0..9\nvolume = 100 150 80 120 220 200 180 90 100 125\nt = table(id, time, volume)\ncapital = 300\nre = select *, sumbars(volume, capital) as period from t\nre;\n```\n\n| id | time                | volume | period |\n| -- | ------------------- | ------ | ------ |\n| A  | 2022.01.01T09:00:00 | 100    | 0      |\n| A  | 2022.01.01T09:00:01 | 150    | 0      |\n| B  | 2022.01.01T09:00:02 | 80     | 3      |\n| A  | 2022.01.01T09:00:03 | 120    | 3      |\n| C  | 2022.01.01T09:00:04 | 220    | 2      |\n| B  | 2022.01.01T09:00:05 | 200    | 2      |\n| A  | 2022.01.01T09:00:06 | 180    | 2      |\n| C  | 2022.01.01T09:00:07 | 90     | 3      |\n| A  | 2022.01.01T09:00:08 | 100    | 3      |\n| B  | 2022.01.01T09:00:09 | 125    | 3      |\n"
    },
    "summary": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/summary.html",
        "signatures": [
            {
                "full": "summary(X,[interpolation],[characteristic],[percentile],[precision],[partitionSampling])",
                "name": "summary",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[interpolation]",
                        "name": "interpolation",
                        "optional": true
                    },
                    {
                        "full": "[characteristic]",
                        "name": "characteristic",
                        "optional": true
                    },
                    {
                        "full": "[percentile]",
                        "name": "percentile",
                        "optional": true
                    },
                    {
                        "full": "[precision]",
                        "name": "precision",
                        "optional": true
                    },
                    {
                        "full": "[partitionSampling]",
                        "name": "partitionSampling",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [summary](https://docs.dolphindb.cn/zh/funcs/s/summary.html)\n\n\n\n#### 语法\n\nsummary(X,\\[interpolation],\\[characteristic],\\[percentile],\\[precision],\\[partitionSampling])\n\n#### 详情\n\n生成数据的汇总统计信息，返回一个内存表，包含最小值、最大值、计数、均值、标准差和指定的百分位数（以升序输出）。\n\n**Note:**\n\n* 若 *X* 是表，则 `summary` 只统计表中数值类型的列，忽略非数值类型的列。\n\n* 若 *X* 是数据源，则数据源只能包含数值类型的列，否则在进行 `summary` 统计时会报错。\n\n#### 参数\n\n**X** 可以是内存表、DFS 表或由 [sqlDS](https://docs.dolphindb.cn/zh/funcs/s/sqlDS.html) 函数生成的数据源。注意：暂不支持由 `sqlDS` 生成的包含表连接的数据源。\n\n**interpolation** 字符串，表示计算百分位采用的插值方法，可以是 'linear'（默认值）, 'nearst', 'lower', 'higher', 'midpoint'。\n\n**characteristic** 字符串标量或向量，表示需要输出的统计特征。可选值为 'avg', 'std'。若不指定该参数，则默认同时输出 'avg' 和 'std'。\n\n**percentile** DOUBLE 类型向量，范围是\\[0,100]。默认值为 \\[25, 50, 75]，表示返回第25, 50和75百分位数。\n\n**precision** 大于0的 DOUBLE 类型标量，表示插值计算百分位时的迭代精度。默认值为 1e-3。当前计算结果与上一次迭代计算结果的差值小于等于该值时，将退出迭代。建议取值范围为\\[1.000e-3, 1.000e-9]，若值较小，则可能因迭代次数过多而导致性能下降；若值较大，则可能导致计算的结果不精确。\n\n**partitionSampling** 正整数或(0,1]之间的浮点数。正整数表示随机选取的分区个数；浮点数表示随机选取相应比例的分区。若不指定，则表示选取所有分区。指定该参数时需要注意以下事项：\n\n* 对于分区表：\n\n  * 至少会选择1个分区，即当 *partitionSampling* 是浮点数，且 partitionSampling \\* 分区总个数小于1时，会选取1个分区；当 *partitionSampling* \\* 分区总个数是大于1，但不是一个整数时，则向下取整。比如 *partitionSampling*=0.26，分区总个数为10，则会随机选取2个分区。\n\n  * 若指定的分区个数大于实际分区数量，则会选择所有分区。\n\n* 对于非分区表，指定该参数不会生效；\n\n#### 例子\n\n```\nn=2022\ndata=1..n\nvalue=take(1..3,n)\nname=take(`APPLE`IBM`INTEL,n)\nt=table(data,value,name);\nsummary(t, precision=0.001); \n// name 非数值类型，不会输出到表中 \n\n```\n\n输出返回：\n\n| name  | min | max   | nonNullCount | count | avg     | std      | percentile                |\n| ----- | --- | ----- | ------------ | ----- | ------- | -------- | ------------------------- |\n| data  | 1   | 2,022 | 2,022        | 2,022 | 1,011.5 | 583.8454 | \\[506.24,1011.50,1516.75] |\n| value | 1   | 3     | 2,022        | 2,022 | 2       | 0.8167   | \\[1.00,1.99,2.99]         |\n\n```\n\nn = 5000\ndata1 = take(1..5000000, n)\ndata2 = rand(10000000, n)\ndata3 = take(\"A\" + string(0..10), n)\n\nt = table(data1, data2, data3)\ndbname = \"dfs://summary\"\nif(existsDatabase(dbname)) {\n    dropDatabase(dbname)\n}\ndb = database(dbname, HASH, [INT, 10])\npt = createPartitionedTable(db, t, `pt, `data1)\npt.append!(t)\n\nds = sqlDS(<select data1,data2 from loadTable(db, `pt)>)\nquery_percentile = [25,50,75,90]\n\nds_re1 = summary(ds);\n\n// 返回第25, 50, 75, 90 百分位值\nds_re2 = summary(ds, percentile=query_percentile, precision=0.0001);\n\n// 分区占比为 0.6，即统计6个分区数据的信息\nds_re3 = summary(loadTable(db, `pt), percentile=query_percentile, precision=0.0001, partitionSampling=0.6);\n```\n"
    },
    "suspendRecovery": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/suspendRecovery.html",
        "signatures": [
            {
                "full": "suspendRecovery()",
                "name": "suspendRecovery",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [suspendRecovery](https://docs.dolphindb.cn/zh/funcs/s/suspendRecovery.html)\n\n\n\n#### 语法\n\nsuspendRecovery()\n\n#### 参数\n\n无\n\n#### 详情\n\n用于暂停在线恢复节点的进程。恢复进程中，处于 \"In-Progress\" 状态的数据会继续恢复，\"Waiting\" 状态的数据会暂停恢复。暂停后，恢复进程的源节点可以继续写入数据。该函数只能由管理员在控制节点上调用。\n\n**Note:**\n\n启用高可用集群时，需要在 raft 组内每个节点执行该命令。\n\n相关命令： [resumeRecovery](https://docs.dolphindb.cn/zh/funcs/r/resumeRecovery.html)\n"
    },
    "svd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/svd.html",
        "signatures": [
            {
                "full": "svd(obj, [fullMatrices=true], [computeUV=true])",
                "name": "svd",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[fullMatrices=true]",
                        "name": "fullMatrices",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[computeUV=true]",
                        "name": "computeUV",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [svd](https://docs.dolphindb.cn/zh/funcs/s/svd.html)\n\n\n\n#### 语法\n\nsvd(obj, \\[fullMatrices=true], \\[computeUV=true])\n\n#### 参数\n\n**obj** 是一个矩阵。\n\n**fullMatrices** 是一个布尔值，其默认值为 true。\n\n**computeUV** 是一个布尔值，默认值为 true。\n\n#### 详情\n\n计算矩阵的奇异分解。\n\n假设输入矩阵 A 的行数为 m，列数为 n：\n\n* 若 *fullMatrices*=true，结果为一个 m\\*m 矩阵 U（以左奇异向量为列的矩阵），一个 n\\*n 矩阵 V（以右奇异向量为行的矩阵）和一个向量 s（按降序排列的奇异值），并满足以下条件：A=U\\*S\\*V。其中 S 是一个 m\\*n 矩阵，其对角线元素为s。\n\n* 若 *fullMatrices*=false，S 矩阵仅保留有奇异值的那部分方阵，即矩阵 S 为 k\\*k，其中 k=min(m,n)，并将与删除的这些行或列相乘的 U 与 V 中的行或列删除。矩阵 U 为 m\\*k，矩阵 V 为 k\\*n。\n\n* 若 *computeUV*=false时，只返回向量 s。\n\n#### 例子\n\n```\nm=matrix([[2,1,0],[1,3,1],[0,1,4],[1,2,3]]);\nU,s,V=svd(m);\nU;\n```\n\n| #0        | #1       | #2        |\n| --------- | -------- | --------- |\n| -0.233976 | 0.57735  | -0.782254 |\n| -0.560464 | 0.57735  | 0.593756  |\n| -0.79444  | -0.57735 | -0.188498 |\n\n```\ns;\n// output\n[6.029042,3,1.284776]\n\nV;\n```\n\n| #0        | #1        | #2        | #3        |\n| --------- | --------- | --------- | --------- |\n| -0.170577 | -0.449459 | -0.620036 | -0.620036 |\n| 0.57735   | 0.57735   | -0.57735  | 0         |\n| -0.755582 | 0.630862  | -0.12472  | -0.12472  |\n| -0.258199 | -0.258199 | -0.516398 | 0.774597  |\n\n```\nU,s,V=svd(m,fullMatrices=false);\nV;\n```\n\n| #0        | #1        | #2        | #3        |\n| --------- | --------- | --------- | --------- |\n| -0.170577 | -0.449459 | -0.620036 | -0.620036 |\n| 0.57735   | 0.57735   | -0.57735  | 0         |\n| -0.755582 | 0.630862  | -0.12472  | -0.12472  |\n"
    },
    "symbol": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/symbol.html",
        "signatures": [
            {
                "full": "symbol(X)",
                "name": "symbol",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [symbol](https://docs.dolphindb.cn/zh/funcs/s/symbol.html)\n\n\n\n#### 语法\n\nsymbol(X)\n\n#### 详情\n\n把输入转换为一个符号向量。\n\n#### 参数\n\n**X** 是字符串或符号的向量。\n\n#### 例子\n\n```\nx=`XOM`y;\ntypestr(x);\n```\n\n返回：STRING VECTOR\n\n```\ny=symbol(x);\ny;\n```\n\n返回：\\[\"XOM\",\"y\"]\n\n```\ntypestr(y);\n```\n\n返回：FAST SYMBOL VECTOR\n"
    },
    "symbolCode": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/symbolCode.html",
        "signatures": [
            {
                "full": "symbolCode(X)",
                "name": "symbolCode",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [symbolCode](https://docs.dolphindb.cn/zh/funcs/s/symbolCode.html)\n\n\n\n#### 语法\n\nsymbolCode(X)\n\n#### 参数\n\n**X** 是 SYMBOL 类型的向量或矩阵。\n\n#### 详情\n\n返回一个与 *X* 相同维度的整型向量或矩阵，表示 SYMBOL 类型数据的内部编码。空字符串的内部编码为0。\n\nSYMBOL 类型是特殊的字符串类型，在系统内部的存储结构为一个编码字典。将设备名，股票名等字符串重复较多的向量存储为 SYMBOL 类型，可以达到向量压缩的目的。\n\n#### 例子\n\n```\na=symbol(`IBM`APPL)\nsymbolCode(a)\n```\n\n输出返回：\\[1,2]\n\n```\nx=symbol(`MS`AMZN`AAPL`MS`IBM`AAPL)$3:2\nsymbolCode(x)\n```\n\n输出返回：\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 2  | 4  |\n| 3  | 3  |\n"
    },
    "symmetricDifference": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/symmetricDifference.html",
        "signatures": [
            {
                "full": "symmetricDifference(X, Y)",
                "name": "symmetricDifference",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [symmetricDifference](https://docs.dolphindb.cn/zh/funcs/s/symmetricDifference.html)\n\n\n\n#### 语法\n\nsymmetricDifference(X, Y) 或 X^Y\n\n#### 参数\n\n**X** 和 **Y** 是集合。\n\n#### 详情\n\n返回两个集合的并集减去两个集合的交集。\n\n#### 例子\n\n```\nx=set([5,3,4])\ny=set(8 9 4 6);\n\ny^x;\n// output\nset(5,8,3,9,6)\n\nx^y;\n// output\nset(8,5,3,6,9)\n```\n"
    },
    "syncDict": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/syncDict.html",
        "signatures": [
            {
                "full": "syncDict(keyObj, valueObj, [sharedName], [ordered=false])",
                "name": "syncDict",
                "parameters": [
                    {
                        "full": "keyObj",
                        "name": "keyObj"
                    },
                    {
                        "full": "valueObj",
                        "name": "valueObj"
                    },
                    {
                        "full": "[sharedName]",
                        "name": "sharedName",
                        "optional": true
                    },
                    {
                        "full": "[ordered=false]",
                        "name": "ordered",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "syncDict(keyType, valueType, [sharedName], [ordered=false])",
                "name": "syncDict",
                "parameters": [
                    {
                        "full": "keyType",
                        "name": "keyType"
                    },
                    {
                        "full": "valueType",
                        "name": "valueType"
                    },
                    {
                        "full": "[sharedName]",
                        "name": "sharedName",
                        "optional": true
                    },
                    {
                        "full": "[ordered=false]",
                        "name": "ordered",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [syncDict](https://docs.dolphindb.cn/zh/funcs/s/syncDict.html)\n\n\n\n#### 语法\n\nsyncDict(keyObj, valueObj, \\[sharedName], \\[ordered=false])\n\n或\n\nsyncDict(keyType, valueType, \\[sharedName], \\[ordered=false])\n\n#### 参数\n\n* 第一种用法中，**keyObj** 是表示键的标量或向量，**valueObj** 是表示值的标量或向量。\n\n* 第二种用法中，**keyType** 是字典键的数据类型； **valueType** 是字典值的数据类型。系统支持以下键的数据类型：Logical, Integral, Floating和Temporal。字典中的值不支持 COMPLEX, POINT 类别。\n\n**sharedName** 为一个字符串。指定后此字典会被共享，共享的字典名为 *sharedName*。\n\n**ordered** 一个布尔值，默认为 false，表示创建一个无序字典。当 *ordered* = true 时，创建一个有序字典。无序字典在输出或进行遍历时，其键值对不保留输入时的顺序；有序字典在输出或进行遍历时，键值对的顺序与输入顺序保持一致。\n\n#### 详情\n\n创建一个线程安全的同步字典。同步字典允许多个线程对其进行并发读写。\n\n#### 例子\n\n```\nx=1 6 3\ny=4.5 7.8 4.3\nz=syncDict(x,y);\n// output\n3->4.3\n1->4.5\n6->7.8\n\nz=syncDict(INT,DOUBLE)\nz[5]=7.9\nz;\n// output\n5->7.9\n\nsyncDict(INT,DOUBLE, `sn)\nsn[5 6]=10.99 2.33\nsn[5];\n// output\n10.99\n\n\n// y 为 DECIMAL32 类型的向量，将 y 作为 value 值创建有序字典 z\nx=1 3 2\ny = decimal32\\(1.23 3 3.14, 3\\)\nz=dict\\(x,y,true\\);\nz;\n// output\n1-&gt;1.230\n3-&gt;3.000\n2-&gt;3.140\n```\n\n下面的例子中，我们分别对普通字典 z1 和同步字典 z2 并发写入。\n\n对普通字典 z1 进行多线程并发写入会造成节点崩溃：\n\n```\ndef task1(mutable d,n){\n    for(i in 0..n){\n        d[i]=i*2\n    }\n}\n\ndef task2(mutable d,n){\n    for(i in 0..n){\n        d[i]=i+1\n    }\n}\nn=10000000\n\nz1=dict(INT,INT)\njobId1=submitJob(\"task1\",,task1,z1,n)\njobId2=submitJob(\"task2\",,task2,z1,n);\n```\n\n同步字典 z2 允许多线程并发写入：\n\n```\nz2=syncDict(INT,INT)\njobId3=submitJob(\"task1\",,task1,z2,n)\njobId4=submitJob(\"task2\",,task2,z2,n)\ngetJobReturn(jobId3, true)\ngetJobReturn(jobId4, true)\nz2;\n```\n\n相关函数：[array](https://docs.dolphindb.cn/zh/funcs/a/array.html), [matrix](https://docs.dolphindb.cn/zh/funcs/m/matrix.html), [dictUpdate!](https://docs.dolphindb.cn/zh/funcs/d/dictUpdate_.html), [dict](https://docs.dolphindb.cn/zh/funcs/d/dict.html)\n"
    },
    "syntax": {
        "url": "https://docs.dolphindb.cn/zh/funcs/s/syntax.html",
        "signatures": [
            {
                "full": "syntax(X)",
                "name": "syntax",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [syntax](https://docs.dolphindb.cn/zh/funcs/s/syntax.html)\n\n\n\n#### 语法\n\nsyntax(X)\n\n#### 参数\n\n**X** 是 DolphinDB 函数或命令。\n\n#### 详情\n\n返回 *X* 表示的函数或命令的语法。\n\n#### 例子\n\n```\nsyntax(createPartitionedTable);\n// output\ncreatePartitionedTable(dbHandle, table, tableName, [partitionColumns], [compressMethods])\n```\n"
    },
    "t3": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/t3.html",
        "signatures": [
            {
                "full": "t3(X, window, [vfactor=1.0])",
                "name": "t3",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[vfactor=1.0]",
                        "name": "vfactor",
                        "optional": true,
                        "default": "1.0"
                    }
                ]
            }
        ],
        "markdown": "### [t3](https://docs.dolphindb.cn/zh/funcs/t/t3.html)\n\n\n\n#### 语法\n\nt3(X, window, \\[vfactor=1.0])\n\nTA-lib 系列函数参数说明和窗口计算规则请参考：[TAlib](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 参数\n\n**vfactor** 是一个0-1之间的浮点数。 默认值是1.0。\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的三重指数移动平均（Triple Exponential Moving Average）。\n\n其计算公式为：\n\n![ema1](https://docs.dolphindb.cn/zh/images/ema1.png)\n\n![ema2](https://docs.dolphindb.cn/zh/images/ema2.png) ![gd](https://docs.dolphindb.cn/zh/images/gd.png) ![t3](https://docs.dolphindb.cn/zh/images/t3.png)\n\n#### 例子\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2 16.9 55.6 5.6 3.3 66 6 57\nt3(x, 3, 0.5);\n// output\n[,,,,,,,,,,,,27.652790217144499,33.482904095904814]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2 15.7 18.6 13.2 19.6 20.3 22.4 11, 14 15 18 19 21 12 10 6 5.5 7 11 16 15 9.9)\nt3(x, 3, 0.8);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n| 20.9284 | 13.8993 |\n| 18.3094 | 13.4915 |\n\n相关函数：[tema](https://docs.dolphindb.cn/zh/funcs/t/tema.html)\n"
    },
    "table": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/table.html",
        "signatures": [
            {
                "full": "table(X, [X1], [X2], .....)",
                "name": "table",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[X1]",
                        "name": "X1",
                        "optional": true
                    },
                    {
                        "full": "[X2]",
                        "name": "X2",
                        "optional": true
                    },
                    {
                        "full": ".....",
                        "name": "....."
                    }
                ]
            }
        ],
        "markdown": "### [table](https://docs.dolphindb.cn/zh/funcs/t/table.html)\n\n\n\n#### 语法\n\ntable(X, \\[X1], \\[X2], .....) 或 table(capacity:size, colNames, colTypes)\n\n#### 详情\n\n用法一：将单个或多个向量/矩阵/元组，或多个向量和元组的混合数据形式转换成表。\n\n**Note:**\n\n* 若 Xk 是普通元组，则其元素必须是等长的向量，长度等于表的行数。元组的每个元素将作为表的每列。\n\n* 若 Xk 是列式元组，则其元素可以不等长，但其元素的个数必须和表的行数保持一致。Xk 将单独作为表的一列（列类型为 ANY），其每个元素将作为该列每行的元素值。只能通过用法一创建一个包含列式元组的表。\n\nDolphinDB 支持将元素不等长的普通元组自动识别为列式元组存储；对于元素等长的元组，必须通过 `setColumnarTuple!` 函数转化为列式元组才能将每个元素按行存储。\n\n用法二：创建一个固定数据类型的空表或初始化的表。\n\n#### 参数\n\n第一种用法中，**X**, **X1**, **X2** ... 可以是向量、矩阵或元组。\n\n第二种用法中：\n\n* **capacity** 是正整数，表示建表时系统为该表分配的内存（以记录数为单位）。当记录数超过 *capacity* 时，系统首先会分配 *capacity* 1.2\\~2倍的新的内存空间，然后复制数据到新的内存空间，最后释放原来的内存。对于规模较大的表，此类操作的内存占用会很高。因此，建议创建内存表时预先分配一个合理的 *capacity*。\n\n* **size** 是整数，表示该表新建时的行数。若 *size* =0，创建一个空表。 若 *size*>0，则建立一个只包含 size 条记录的表，记录初始值如下：\n\n  * BOOL 类型默认值为 false；\n\n  * 数值类型、时间类型、IPADDR、COMPLEX、POINT 的默认值为 0；\n\n  * Literal, INT128 类型的默认值为 NULL。\n\n  **Note:** 如果 *colTypes* 指定为数组向量， *size* 必须为0。\n\n* **colNames** 是一个向量，表示列名。\n\n* **colTypes** 是一个向量，表示每列的数据类型。可使用表示数据类型的系统保留字或相应的字符串。\n\n#### 例子\n\n第一种用法：\n\n```\nid=`XOM`GS`AAPL\nx=102.1 33.4 73.6\ntable(id, x);\n```\n\n| id   | x     |\n| ---- | ----- |\n| XOM  | 102.1 |\n| GS   | 33.4  |\n| AAPL | 73.6  |\n\n```\ntable(`XOM`GS`AAPL as id, 102.1 33.4 73.6 as x);\n```\n\n| id   | x     |\n| ---- | ----- |\n| XOM  | 102.1 |\n| GS   | 33.4  |\n| AAPL | 73.6  |\n\n```\nm=matrix(1 2, 3 4, 5 6);\nm;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\ntable(m);\n```\n\n| C0 | C1 | C2 |\n| -- | -- | -- |\n| 1  | 3  | 5  |\n| 2  | 4  | 6  |\n\n```\nm.rename!(1 2, `a`b`x);\nm;\n```\n\n|   | a | b | x |\n| - | - | - | - |\n| 1 | 1 | 3 | 5 |\n| 2 | 2 | 4 | 6 |\n\n```\ntable(m);\n```\n\n| a | b | x |\n| - | - | - |\n| 1 | 3 | 5 |\n| 2 | 4 | 6 |\n\n```\nx=1..6\ny=matrix(11..16, 17..22)\nz=(101..106, 201..206)\nt=table(x,y,z)\nt.rename!(`x`y1`y2`z1`z2);\n\nt;\n```\n\n| x | y1 | y2 | z1  | z2  |\n| - | -- | -- | --- | --- |\n| 1 | 11 | 17 | 101 | 201 |\n| 2 | 12 | 18 | 102 | 202 |\n| 3 | 13 | 19 | 103 | 203 |\n| 4 | 14 | 20 | 104 | 204 |\n| 5 | 15 | 21 | 105 | 205 |\n| 6 | 16 | 22 | 106 | 206 |\n\n目前不支持通过建表语句 `table(capacity:size, colNames, colTypes)` 指定 *colTypes* 为 ANY 类型，若需要创建包含 ANY 类型的内存表，必须通过用法一使用 ANY 向量来生成表对象。此时的 ANY 对象必须是一个[列式元组](https://docs.dolphindb.cn/zh/progr/data_types_forms/columnarTuple.html)，即元素类型必须是相同的元组，创建方法为：\n\n```\nid = 1 2 3\nval = [[1,2,3], [4,5,6],[7,8,9]]\nt = table(id, val)\nschema(t)\n```\n\n| id | col1 | col2 | col3 |\n| -- | ---- | ---- | ---- |\n| 1  | 1    | 4    | 7    |\n| 2  | 2    | 5    | 8    |\n| 3  | 3    | 6    | 9    |\n\n第二种用法：\n\n```\ntable(100:5, `name`id`value, [STRING,INT,DOUBLE]);\n```\n\n| name | id | value |\n| ---- | -- | ----- |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n\n```\ntable(100:5, `name`id`value, `STRING`INT`DOUBLE);\n```\n\n| name | id | value |\n| ---- | -- | ----- |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n|      | 0  | 0     |\n\n```\ntable(100:1, [`value], [DOUBLE]);\n```\n\n| value |\n| ----- |\n| 0     |\n"
    },
    "tableInsert": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tableInsert.html",
        "signatures": [
            {
                "full": "tableInsert(table, args...)",
                "name": "tableInsert",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [tableInsert](https://docs.dolphindb.cn/zh/funcs/t/tableInsert.html)\n\n\n\n#### 语法\n\ntableInsert(table, args...)\n\n#### 详情\n\n将*args...* 插入到 *table* 中，并返回插入的行数。\n\n如果 *args...* 是一个表，它的结构必须与 *table* 的结构相同。若 *table* 是分区表，*args...* 只能是一个表。\n\n如果 *args...* 是一个元组，那么它的元素个数必须与 *table* 的列数相同，并且每个元素的数据类型必须与 *table* 中与之对应的每列的数据类型相同。\n\n如果 *args...* 是多个向量或元组，那么向量与元组的个数必须与 *table* 中列数一致，且每个向量或元组的数据类型必须与 *table* 中与之对应的每列的数据类型相同。\n\n如果 *args...* 是一个字典，那么它的 keys 对应 *table* 的列名，values 对应 *table* 中每列的值，且 values 必须为元组。这种用法只适用于 *table* 为内存表的情况。\n\n**Note:** 若数据库为 VALUE 分区，且分区列为字符串类型，则追加的分区列数据不能包含空格，“/n”, “/r”, “/t”。\n\n#### 参数\n\n**table** 是表对象或表名。该表可为内存表或 DFS 表。在远程调用中，由于得不到远程表对象的引用，因此必须使用表名。\n\n**args...** 可以是一个表、元组或字典，或多个向量或元组。\n\n#### 例子\n\n```\ncolName=[\"Name\",\"Age\"]\ncolType=[\"string\",\"int\"]\nt1=table(100:0,colName, colType);\n\nname=`Tom`Jerry`John\nage=24 25 26\nt2=table(name, age)\n\ntableInsert(t1, t2);\n// output\n3\n\nt1;\n```\n\n| Name  | Age |\n| ----- | --- |\n| Tom   | 24  |\n| Jerry | 25  |\n| John  | 26  |\n\n```\ntableInsert(t1, (`George, 29));\n// output\n1\n\nt1;\n```\n\n| Name   | Age |\n| ------ | --- |\n| Tom    | 24  |\n| Jerry  | 25  |\n| John   | 26  |\n| George | 29  |\n\n```\ntableInsert(t1, (`Frank`Henry, 31 32));\n// output\n2\n\ntableInsert(t1, `Nicole`Nancy, 28 29);\n// output\n2\n\nt1.tableInsert(dict(`Name`Age, [`Patrick, 22]));\n// output\n1\n```\n\n使用 `tableInsert` 函数向分布式表中插入批量数据：\n\n```\ndb=database(\"dfs://db1\",RANGE,0 20 50 101)\nn=100000\nid=rand(100,n)\nval=rand(100.0,n)\nt=table(id,val)\npt=db.createPartitionedTable(t,`pt,`id).append!(t);\n\ntmp=table(rand(100,10000) as id,take(200.0,10000) as val);\n\ntableInsert(pt,tmp);\n// output\n10000\n```\n"
    },
    "tableUpsert": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tableUpsert.html",
        "signatures": [
            {
                "full": "tableUpsert(obj, newData, [ignoreNull=false], [keyColNames], [sortColumns])",
                "name": "tableUpsert",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "newData",
                        "name": "newData"
                    },
                    {
                        "full": "[ignoreNull=false]",
                        "name": "ignoreNull",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColNames]",
                        "name": "keyColNames",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns]",
                        "name": "sortColumns",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [tableUpsert](https://docs.dolphindb.cn/zh/funcs/t/tableUpsert.html)\n\n\n\n#### 语法\n\ntableUpsert(obj, newData, \\[ignoreNull=false], \\[keyColNames], \\[sortColumns])\n\n#### 参数\n\n**obj** 是一个索引内存表、键值内存表，或者 DFS 表（分布式表或维度表）。\n\n**newData** 是一个内存表。\n\n**ignoreNull** 是一个布尔值，表示若 *newData* 中某元素为 NULL 值，是否对目标表中的相应数据进行更新。默认值为 false。\n\n**keyColNames** 是一个字符串标量或向量。由于 DFS 表没有键值列，对 DFS 表进行更新时，将该参数指定的列和分区列一起视为键值列。\n\n**sortColumns** 是一个字符串标量或向量。设置该参数，更新的分区内的所有数据会根据指定的列进行排序。排序在每个分区内部进行，不会跨分区排序。\n\n**Note:**\n\n* 仅 OLAP 引擎下使用 `upsert!` 时，才支持设置 *sortColumns*。\n* 要设置 *sortColumns*， *obj* 必须为分布式表。\n* 仅对同一个分区内的数据 按照 *sortColumns* 进行排序，不同分区之间的数据不会进行排序。\n* *obj* 为一个空表时，设置 *sortColumns* 无效，即更新后不对新插入的数据进行排序。\n* 在 PKEY 引擎下不支持设置 *ignoreNull*, *keyColNames*, *sortColumns*。\n\n#### 详情\n\n返回值：LONG 类型数据对，第一个元素表示新插入的记录数，第二个元素表示更新的记录数。\n\n将新数据写入索引内存表、键值内存表，或者 DFS 表。若新数据的主键值已存在，更新该主键值的数据；否则添加数据。\n\n`tableUpsert` 与 `upsert!` 的用法一致，区别在于 `tableUpsert` 会返回操作行数，而 `upsert!` 进行了就地修改，用于链式操作。\n\n**Note:**\n\n* 调用该函数时，需要保证 *newData* 和 *obj* 两表各列的顺序一致，否则可能产生错误结果或报错。\n\n* 若 *keyColNames* 指定的列存在重复值，对重复值进行 `upsert!` 操作，仅会更新第一个值所在行，其余值所在行不会更新。\n\n#### 例子\n\n对键值内存表使用 `tableUpsert`：\n\n```\nsym=`A`B`C\ndate=take(2021.01.06, 3)\nx=1 2 3\ny=5 6 7\nt=keyedTable(`sym`date, sym, date, x, y)\nnewData = table(`A`B`C`D as sym1, take(2021.01.06, 4) as date1, NULL NULL 300 400 as x1, NULL 600 700 800 as y1);\ntableUpsert(t, newData, ignoreNull=true)\n// output\n1:2\n```\n\n对索引内存表使用 `tableUpsert`：\n\n```\nsym=`A`B`C\ndate=take(2021.01.06, 3)\nx=1 2 3\ny=5 6 7\nt=indexedTable(`sym`date, sym, date, x, y)\nnewData = table(`A`B`C`D as sym1, take(2021.01.06, 4) as date1, NULL NULL 300 400 as x1, NULL 600 700 800 as y1);\ntableUpsert(t, newData, ignoreNull=true)\n// output\n1:2\n```\n\n对 DFS 表使用 `tableUpsert`：\n\n```\nID=0 1 2 2\nx=0.1*0..3\nt=table(ID, x)\ndb=database(\"dfs://rangedb128\", VALUE,  0..10)\npt=db.createPartitionedTable(t, `pt, `ID)\npt.append!(t)\nt1=table(1 as ID, 111 as x)\ntableUpsert(pt, t1, keyColNames=`ID)\n// output\n0:1\n```\n"
    },
    "tail": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tail.html",
        "signatures": [
            {
                "full": "tail(obj, [n=1])",
                "name": "tail",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [tail](https://docs.dolphindb.cn/zh/funcs/t/tail.html)\n\n\n\n#### 语法\n\ntail(obj, \\[n=1])\n\n#### 参数\n\n* **obj** 可以是向量、矩阵或表。\n\n* **n** 是一个正整数。\n\n#### 详情\n\n*tail* 返回向量的最后 *n* 个元素，或者矩阵的最后 *n* 列，或者表的最后 *n* 行。如果 *n* 没有指定，*n* 取默认值 1。\n\n#### 例子\n\n```\nx=1..10;\ntail(x);\n// output\n10\n\ntail(x,2);\n// output\n[9,10]\n\nx=1..10$2:5;\nx;\n```\n\n| #0 | #1 | #2 | #3 | #4 |\n| -- | -- | -- | -- | -- |\n| 1  | 3  | 5  | 7  | 9  |\n| 2  | 4  | 6  | 8  | 10 |\n\n```\nx.tail();\n// output\n[9,10]\n\ntail(x,2);\n```\n\n| #0 | #1 |\n| -- | -- |\n| 7  | 9  |\n| 8  | 10 |\n\n```\nx=table(1..5 as a, 6..10 as b);\nx;\n```\n\n| a | b  |\n| - | -- |\n| 1 | 6  |\n| 2 | 7  |\n| 3 | 8  |\n| 4 | 9  |\n| 5 | 10 |\n\n```\ntail(x);\n// output\nb->10\na->5\n\n\nx.tail(2);\n```\n\n| a | b  |\n| - | -- |\n| 4 | 9  |\n| 5 | 10 |\n\n相关函数：[head](https://docs.dolphindb.cn/zh/funcs/h/head.html)\n"
    },
    "take": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/take.html",
        "signatures": [
            {
                "full": "take(X, n)",
                "name": "take",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [take](https://docs.dolphindb.cn/zh/funcs/t/take.html)\n\n\n\n#### 语法\n\ntake(X, n)\n\n#### 参数\n\n**X** 可以是标量、向量、元组、矩阵或表。\n\n**n** 是一个整数标量或向量。\n\n#### 详情\n\n如果 *X* 是标量，则 *n* 必须是标量，返回由 *n* 个 *X* 组成的向量。\n\n如果 *X* 是向量/元组：\n\n* *n* 标量：从 *X* 中循环地依次取值，共取 *n* 个值。结果是一个向量。*n* 是正数时，从左到右取数，*n* 是负数时，从右到左取数。\n\n* *n* 是向量：*n* 的长度必须和 *X* 相同。从 *X* 中依次取出 n\\[i] 个 X\\[i]。当 n\\[i] <=0 时，不会取 X\\[i]。结果是一个向量。\n\n如果 *X* 是矩阵/表：\n\n* *n* 标量：从 *X* 中循环地依次逐行取值，共取 *n* 行。结果是一个矩阵/表。*n* 是正数时，从上到下取数，*n* 是负数时，则从下到上取数。\n\n* *n* 是向量：*n* 的长度必须和 *X* 的行数相同。从 *X* 中依次取出 n\\[i] 个第 i 行的元素。当 n\\[i] <=0 时，不会取第 i 行元素。结果是一个矩阵/表。\n\n#### 例子\n\n```\ntake(10,5);\n// output\n[10,10,10,10,10]\n\nx=`IBM`C`AAPL`BABA;\ntake(x,10);\n// output\n[\"IBM\",\"C\",\"AAPL\",\"BABA\",\"IBM\",\"C\",\"AAPL\",\"BABA\",\"IBM\",\"C\"]\n# sequentially and iteratively take 10 elements from vector x\n\nx=3 5 4 6 9;\ntake(x,3);\n// output\n[3,5,4]\n\n\nx=1..3;\nx.take(10);\n// output\n[1,2,3,1,2,3,1,2,3,1]\n\ntake(1 2 3, 10);\n// output\n[1,2,3,1,2,3,1,2,3,1]\n\n\ntake(1,10);\n// output\n[1,1,1,1,1,1,1,1,1,1]\n# an efficient way to generate a vector with default values.\n\n\nx=take(1,0);\n# return an empty INT VECTOR\n\nx;\n// output\n[]\n\ntypestr x;\n// output\nFAST INT VECTOR\n\n\nx=1..12$3:4;\ntake(x,2);\n// output\n[1,2]\n\ntake(x,-2);\n// output\n[11,12]\n\ntake(1..3,2 0 2)\n// output\n[1,1,3,3]\n\nm=matrix(1 2 3, 4 5 6)\ntake(m,5)\ncol1   col2\n1\t4\n2\t5\n3\t6\n1\t4\n2\t5\n\ntake(m, 0 2 1)\ncol1   col2\n2\t5\n2\t5\n3\t6\n\nt=table(1 2 3 as a, 4 5 6 as b)\ntake(t,-4)\na\tb\n3\t6\n1\t4\n2\t5\n3\t6\n\ntake(t, -2 2 1)\na\tb\n2\t5\n2\t5\n3\t6\n\n```\n"
    },
    "talibNull": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/talibNull.html",
        "signatures": [
            {
                "full": "talibNull(args...)",
                "name": "talibNull",
                "parameters": [
                    {
                        "full": "args...",
                        "name": "args..."
                    }
                ]
            }
        ],
        "markdown": "### [talibNull](https://docs.dolphindb.cn/zh/funcs/t/talibNull.html)\n\n\n\n#### 语法\n\ntalibNull(args...)\n\n#### 参数\n\n**args...** 是两个及以上的 vector，所有 vector 长度需保持一致。\n\n#### 详情\n\n该函数对输入的每个 vector 处理后，返回一个由处理结果组成的 tuple。处理方式如下：\n\n从0开始遍历每个 vector (v1, v2, …, vn) 的下标，若存在某个下标 i，满足 v1\\[i], v2\\[i], ..., vn\\[i] 均为非 NULL 值，则结果中下标对应 0 \\~ i 的元素均取 NULL 值，下标 i 及之后的元素与原向量对应下标的元素保持一致。\n\n#### 例子\n\n下标为2时，所有向量对应元素满足全部非空，因此输出结果，在下标2之前的元素均被置为空。\n\n```\ntalibNull(2 3 4 5 6, NULL 1 2 NULL 4, 7 NULL 9 10 11)\n// output\n([,,4,5,6],[,,2,,4],[,,9,10,11])\n```\n"
    },
    "tan": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tan.html",
        "signatures": [
            {
                "full": "tan(X)",
                "name": "tan",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html)\n\n\n\n#### 语法\n\ntan(X)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n#### 详情\n\n返回 *X* 的正切。\n\n#### 例子\n\n```\ntan(0 1 2);\n// output\n[0,1.557408,-2.185040]\n```\n\n相关函数：[asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html), [acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html), [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html), [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html), [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html), [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html), [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html), [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html), [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html), [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html), [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n"
    },
    "tanh": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tanh.html",
        "signatures": [
            {
                "full": "tanh(X)",
                "name": "tanh",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [tanh](https://docs.dolphindb.cn/zh/funcs/t/tanh.html)\n\n\n\n#### 语法\n\ntanh(X)\n\n#### 参数\n\n**X** 可以是标量、向量或矩阵。\n\n#### 详情\n\n返回 *X* 的双曲正切\n\n#### 例子\n\n```\ntanh(0 1 2);\n// output\n[0,0.761594,0.964028]\n```\n\n相关函数：[asin](https://docs.dolphindb.cn/zh/funcs/a/asin.html), [acos](https://docs.dolphindb.cn/zh/funcs/a/acos.html), [atan](https://docs.dolphindb.cn/zh/funcs/a/atan.html), [sin](https://docs.dolphindb.cn/zh/funcs/s/sin.html), [cos](https://docs.dolphindb.cn/zh/funcs/c/cos.html), [tan](https://docs.dolphindb.cn/zh/funcs/t/tan.html), [asinh](https://docs.dolphindb.cn/zh/funcs/a/asinh.html), [acosh](https://docs.dolphindb.cn/zh/funcs/a/acosh.html), [atanh](https://docs.dolphindb.cn/zh/funcs/a/atanh.html), [sinh](https://docs.dolphindb.cn/zh/funcs/s/sinh.html), [cosh](https://docs.dolphindb.cn/zh/funcs/c/cosh.html)\n"
    },
    "tanimoto": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tanimoto.html",
        "signatures": [
            {
                "full": "tanimoto(X, Y)",
                "name": "tanimoto",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [tanimoto](https://docs.dolphindb.cn/zh/funcs/t/tanimoto.html)\n\n\n\n#### 语法\n\ntanimoto(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 是长度相同的数值型标量/向量/矩阵。\n\n#### 详情\n\n若 *X* 和 *Y* 是标量或向量，计算 *X* 和 *Y* 之间的谷本距离。\n\n若 *X* 或 *Y* 是矩阵，计算每列元素之间的谷本距离，返回一个向量。 注意，若 *X* 或 *Y* 同时为索引矩阵或索引序列，会自动对齐标签，返回标签相同的行的计算结果，忽略标签不同的行。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\na=[10.5, 11.8, 9]\nb=[11.3, 15.1, 8.9]\ntanimoto(a,b)\n// output\n0.029706\n\ns1=indexedSeries(2020.01.01..2020.01.03, 10.4 11.2 9)\ns2=indexedSeries(2020.01.01 2020.01.03 2020.01.04, 23.5 31.2 26)\ntanimoto(s1,s2)\n// output\n0.5585\n\nm=matrix(23 56 47, 112 94 59)\nm1=matrix(11 15 89, 52 41 63)\ntanimoto(m,m1)\n// output\n[0.40490.3242]\n\nm.rename!(2020.01.01..2020.01.03, `A`B)\nm.setIndexedMatrix!()\nm1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\nm1.setIndexedMatrix!()\ntanimoto(m,m1)\n// output\n[0.5494,0.3225]\n```\n\n相关函数：[rowTanimoto](https://docs.dolphindb.cn/zh/funcs/r/rowTanimoto.html)\n"
    },
    "tema": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tema.html",
        "signatures": [
            {
                "full": "tema(X, window)",
                "name": "tema",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tema](https://docs.dolphindb.cn/zh/funcs/t/tema.html)\n\n\n\n#### 语法\n\ntema(X, window)\n\nTA-lib 系列函数参数说明和窗口计算规则请参考：[TAlib](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的三重指数移动平均（Triple Exponential Moving Average）。\n\n其计算公式为：\n\n![ema1](https://docs.dolphindb.cn/zh/images/ema1.png)\n\n![ema2](https://docs.dolphindb.cn/zh/images/ema2.png) ![tema](https://docs.dolphindb.cn/zh/images/tema.png)\n\n#### 例子\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\ntema(x,3);\n// output\n[,,,,,,11.24444444444444]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\ntema(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n| 11.2444 | 10.6296 |\n\n相关函数：[ema](https://docs.dolphindb.cn/zh/funcs/e/ema.html), [dema](https://docs.dolphindb.cn/zh/funcs/d/dema.html)\n"
    },
    "temporalAdd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/temporalAdd.html",
        "signatures": [
            {
                "full": "temporalAdd(obj, duration, [unit])",
                "name": "temporalAdd",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "duration",
                        "name": "duration"
                    },
                    {
                        "full": "[unit]",
                        "name": "unit",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [temporalAdd](https://docs.dolphindb.cn/zh/funcs/t/temporalAdd.html)\n\n\n\n#### 语法\n\ntemporalAdd(obj, duration, \\[unit])\n\n别名：datetimeAdd\n\n#### 详情\n\n为时间变量加上一个指定的值。\n\n#### 参数\n\n**obj** 是时间类型的标量或向量。\n\n**duration** 是一个整数或 DURATION 类型数据。\n\n**unit** 是一个字符串标量。\n\n* *duration* 是整数时，*unit* 表示：\n\n  * *duration* 的单位，取值可以是：\"ns\"(nanosecond), \"us\"(microsecond), \"ms\"(millisecond), \"s\"(second), \"m\"(minute), \"H\"(hour), \"d\"(day), \"w\"(week), \"M\"(month), \"y\"(year), “B”(business day)\n\n  * 交易日历的标识，例如：国外交易所的 ISO Code、国内交易所简称或自定义交易日历名称。对应的文件必须保存在 marketHolidayDir 中。\n\n* *duration* 是 DURATION 类型数据时，*unit* 无需设置。\n\n**Note:** 时间单位为 year 或 month 时，计算结果与 mysql 保持一致。Pandas 提供了一个时间偏移对象（Date offsets）来完成时间偏移工作，当 DateOffset 参数取 months 或 years 时，与 `temporalAdd` 单位为 M 或 y 的计算结果也一致。\n\n#### 例子\n\n```\ntemporalAdd(2017.01.16,1,\"d\");\n// output\n2017.01.17\n\ntemporalAdd(2017.01.16,1,\"w\");\n// output\n2017.01.23\n\ntemporalAdd(2016.12M,2,\"M\");\n// output\n2017.02M\n\ntemporalAdd(2012.07.31T13:30:10.008,-1,'M');\n// output\n2012.06.30T13:30:10.008\n\ntemporalAdd(2012.07.31T13:30:10.008,1,'y');\n// output\n2013.07.31T13:30:10.008\n\ntemporalAdd(13:30:10.008007006,100,\"ns\");\n// output\n13:30:10.008007106\n\nx=[12:23:34, 23:34:45];\ntemporalAdd(x, 10m);\n// output\n[12:33:34,23:44:45]\n```\n\n为 2021.08.06 增加 4 个工作日。\n\n```\ntemporalAdd(2021.08.06, 4B)\n// output\n2021.08.12\n```\n\n按照 CFFEX 的交易日历，为 date 增加 2 个交易日。\n\n```\ndate=[2023.01.01, 2023.01.02, 2023.01.03, 2023.01.04]\ntemporalAdd(date,2,`CFFEX)\n// output\n[2023.01.04,2023.01.04,2023.01.05,2023.01.06]\n```\n\n```\ntemporalAdd(datetime(2020.08.31), -2M)\n// output\n2020.06.30T00:00:00\n\n# pandas中 DateOffset 传入参数 months，计算结果一致\npd1 = pd.Timestamp(\"2020.08.31\")\nprint(pd1 -pd.offsets.DateOffset(months=2))\n// output\n2020-06-30 00:00:00\n\ntemporalAdd(datetime(2020.02.29), -1y)\n// output\n2019.02.28T00:00:00\ntemporalAdd(datetime(2020.02.29), -4y)\n// output\n2016.02.29T00:00:00\n\n// pandas 中 offset 设为1年\npd1 = pd.Timestamp(\"2020.02.29\")\nprint(pd1 - pd.offsets.DateOffset(years=1))\n// output\n2019-02-28 00:00:00\n// pandas 中 offset 设为4年\npd2 = pd.Timestamp(\"2020.02.29\")\nprint(pd2 - pd.offsets.DateOffset(years=4))\n// output\n2016-02-29 00:00:00\n```\n"
    },
    "temporalFormat": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/temporalFormat.html",
        "signatures": [
            {
                "full": "temporalFormat(X, format)",
                "name": "temporalFormat",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "format",
                        "name": "format"
                    }
                ]
            }
        ],
        "markdown": "### [temporalFormat](https://docs.dolphindb.cn/zh/funcs/t/temporalFormat.html)\n\n\n\n#### 语法\n\ntemporalFormat(X, format)\n\n别名：datetimeFormat\n\n#### 详情\n\n把 DolphinDB 时序类型的数据转换成指定格式的字符串。详情请参考： [日期和时间的调整及格式](https://docs.dolphindb.cn/zh/progr/data_mani/format_temp_obj.html)。\n\n#### 参数\n\n**X** 是一个时间序列标量或向量。\n\n**format** 是表示时间格式的字符串。\n\n#### 例子\n\n```\ntemporalFormat(2018.02.14,\"dd-MM-yyyy\");\n// output: 14-02-2018\n\ntemporalFormat(2018.02.14,\"dd-MMM-yy\");\n// output: 14-FEB-18\n\ntemporalFormat(02:19:06,\"HH.mm.ss\");\n// output: 02.19.06\n\ntemporalFormat(2018.02.06T13:30:10.001, \"y-M-d-H-m-s-SSS\");\n// output: 2018-2-6-13-30-10-001\n\ntemporalFormat(14:19:06,\"hhmmssaa\");\n// output: 021906PM\n```\n"
    },
    "temporalParse": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/temporalParse.html",
        "signatures": [
            {
                "full": "temporalParse(X, format)",
                "name": "temporalParse",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "format",
                        "name": "format"
                    }
                ]
            }
        ],
        "markdown": "### [temporalParse](https://docs.dolphindb.cn/zh/funcs/t/temporalParse.html)\n\n\n\n#### 语法\n\ntemporalParse(X, format)\n\n别名：datetimeParse\n\n#### 参数\n\n**X** 是一个字符串。\n\n**format** 是表示时间序列对象格式的字符串。\n\n#### 详情\n\n把字符串转换成 DolphinDB 中的时序类型数据。如果系统不能识别时序格式，将返回 NULL。\n\nDolphinDB 具有以下时序格式：\n\n| 格式        | 含义       | 范围                                          |\n| --------- | -------- | ------------------------------------------- |\n| yyyy      | 年份（4个数字） | 1000-9999                                   |\n| yy        | 年份（2个数字） | 00-99. (00-39: 2000-2039; 40-99: 1940-1999) |\n| MM        | 月份       | 1月12日                                       |\n| MMM       | 月份       | JAN, FEB, ... DEC （不区分大小写）                  |\n| dd        | 日期       | 1月31日                                       |\n| HH        | 时（24小时制） | 0-23                                        |\n| hh        | 时（12小时制） | 0-11                                        |\n| mm        | 分钟       | 0-59                                        |\n| ss        | 秒        | 0-59                                        |\n| aa        | 上午/下午    | AM, PM. （不区分大小写）                            |\n| SSS       | 毫秒       | 0-999                                       |\n| nnnnnn    | 微秒       | 0-999999                                    |\n| nnnnnnnnn | 纳秒       | 0-999999999                                 |\n\n`temporalParse` 函数中的 *format* 参数有以下两种表示方式：\n\n* 使用分隔符\n\n  对于 *format* 参数 ，除了 y, M, d, H, h, m, s, a, S, n 以外的符号的字符都可以作为分隔符。*format* 参数中的分隔符需要与输入字符串中的分隔符一致。\n\n  ```\n  temporalParse(\"14-02-2018\",\"dd-MM-yyyy\");\n  // output\n  2018.02.14\n\n  temporalParse(\"14-02-2018\",\"dd/MM/yyyy\");\n  // output\n  00d\n\n  temporalParse(\"14//02//2018\",\"dd//MM//yyyy\");\n  // output\n  2018.02.14\n\n  temporalParse(\"14//02//2018\",\"dd/MM/yyyy\");\n  // output\n  00d\n\n  temporalParse(\"14//02//2018\",\"dd..MM..yyyy\");\n  // output\n  00d\n  ```\n\n  我们可以使用单个字母来简化格式。例如，使用 \"y/M/d\" 代替 \"yyyy/MM/dd\"。因为 \"y\" 可以表示 \"yyyy\" 和 \"yy\", 系统会根据数字的个数采用 \"yyyy\" 或 \"yy\"。\n\n  ```\n  temporalParse(\"14-02-18\",\"d-M-y\");\n  // output\n  2018.02.14\n\n  temporalParse(\"2018/2/6 02:33:01 PM\",\"y/M/d h:m:s a\");\n  // output\n  2018.02.06T14:33:01\n  ```\n\n  \"MMM\",\"SSS\", \"nnnnnn\" , \"nnnnnnnnn\" 不能使用单个字母。\n\n  ```\n  temporalParse(\"02-FEB-2018\",\"d-MMM-y\");\n  // output\n  2018.02.02\n\n  temporalParse(\"02-FEB-2018\",\"d-M-y\");\n  // output\n  00d\n\n  temporalParse(\"13:30:10.001\",\"H:m:s.SSS\");\n  // output\n  13:30:10.001\n\n  temporalParse(\"13:30:10.001\",\"H:m:s.S\");\n  // output\n  Invalid temporal format: 'H:m:s.S'. Millisecond (S) must have three digits.\n\n  temporalParse(\"13:30:10.008001\",\"H:m:s.nnnnnn\");\n  // output\n  13:30:10.008001000\n\n  temporalParse(\"13:30:10.008001\",\"H:m:s.n\");\n  // output\n  Invalid temporal format: 'H:m:s.n'. Nanosecond (n) must have six or nine digits.\n  ```\n\n  `temporalParse` 函数解释输入字符串中数字个数的方式是非常灵活的。\n\n  ```\n  temporalParse(\"2-4-18\",\"d-M-y\");\n  // output\n  2018.04.02\n\n  temporalParse(\"2-19-6\",\"H-m-s\");\n  // output\n  02:19:06\n\n  temporalParse(\"002-019-006\",\"H-m-s\");\n  // output\n  02:19:06\n  ```\n\n  对于毫秒，微秒和纳秒，对应的数字位个数必须是3, 6, 9。\n\n  ```\n  temporalParse(\"2018/2/6 13:30:10.001\",\"y/M/d H:m:s.SSS\");\n  // output\n  2018.02.06T13:30:10.001\n\n  temporalParse(\"2018/2/6 13:30:10.01\",\"y/M/d H:m:s.SSS\");\n  // output\n  00T\n\n  temporalParse(\"2018/2/6 13:30:10.000001\",\"y/M/d H:m:s.nnnnnn\");\n  // output\n  2018.02.06T13:30:10.000001000\n\n  temporalParse(\"2018/2/6 13:30:10.0000010\",\"y/M/d H:m:s.nnnnnn\");\n  // output\n  00N\n  ```\n\n* 不使用分隔符\n\n  对于这种表示方式，*format* 参数必须与上述表格中的格式对应，不能使用单个字母来表示格式。\n\n  ```\n  temporalParse(\"20180214\",\"yyyyMMdd\");\n  // output\n  2018.02.14\n\n  temporalParse(\"122506\",\"MMddyy\");\n  // output\n  2006.12.25\n\n  temporalParse(\"155950\",\"HHmmss\");\n  // output\n  15:59:50\n\n  temporalParse(\"035901PM\",\"hhmmssaa\");\n  // output\n  15:59:01\n\n  temporalParse(\"02062018155956001000001\",\"MMddyyyyHHmmssnnnnnnnnn\");\n  // output\n  2018.02.06T15:59:56.001000001\n  ```\n"
    },
    "temporalSeq": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/temporalSeq.html",
        "signatures": [
            {
                "full": "temporalSeq(start, end, rule, [closed], [label], [origin='start_day'])",
                "name": "temporalSeq",
                "parameters": [
                    {
                        "full": "start",
                        "name": "start"
                    },
                    {
                        "full": "end",
                        "name": "end"
                    },
                    {
                        "full": "rule",
                        "name": "rule"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    },
                    {
                        "full": "[label]",
                        "name": "label",
                        "optional": true
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    }
                ]
            }
        ],
        "markdown": "### [temporalSeq](https://docs.dolphindb.cn/zh/funcs/t/temporalSeq.html)\n\n\n\n#### 语法\n\ntemporalSeq(start, end, rule, \\[closed], \\[label], \\[origin='start\\_day'])\n\n#### 详情\n\n根据 *rule* 指定的频率，对由 *start* 开始，*end* 结尾的时间序列进行重采样，并返回新生成的时间序列。\n\n#### 返回值\n\nTemporal 类型向量。\n\n#### 参数\n\n**start** 时间类型标量。\n\n**end** 时间类型标量。必须和 *start* 的类型相同，且值必须大于 *start*。\n\n**rule** 字符串，可取以下值：\n\n| rule 参数取值 | 对应 DolphinDB 函数      |\n| --------- | -------------------- |\n| \"B\"       | businessDay          |\n| \"W\"       | weekEnd              |\n| \"WOM\"     | weekOfMonth          |\n| \"LWOM\"    | lastWeekOfMonth      |\n| \"M\"       | monthEnd             |\n| \"MS\"      | monthBegin           |\n| \"BM\"      | businessMonthEnd     |\n| \"BMS\"     | businessMonthBegin   |\n| \"SM\"      | semiMonthEnd         |\n| \"SMS\"     | semiMonthBegin       |\n| \"Q\"       | quarterEnd           |\n| \"QS\"      | quarterBegin         |\n| \"BQ\"      | businessQuarterEnd   |\n| \"BQS\"     | businessQuarterBegin |\n| \"REQ\"     | fy5253Quarter        |\n| \"A\"       | yearEnd              |\n| \"AS\"      | yearBegin            |\n| \"BA\"      | businessYearEnd      |\n| \"BAS\"     | businessYearBegin    |\n| \"RE\"      | fy5253               |\n| \"D\"       | date                 |\n| \"H\"       | hourOfDay            |\n| \"U\"       | microsecond          |\n| \"L\"       | millisecond          |\n| \"min\"     | minuteOfHour         |\n| \"N\"       | nanosecond           |\n| \"S\"       | secondOfMinute       |\n\n上述字符串亦可配合使用数字，例如 \"2M\" 表示频率为每两个月月末。此外，*rule* 也可以是交易日历标识，例如：国外交易所的 ISO Code、国内交易所简称或自定义交易日历名称。\n\n**closed** 字符串，表示重采样时间窗口的闭合边界。可取值为 \"left\", \"right\"。\n\n* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，*closed* 的默认取值为 'right' ，否则，*closed* 的默认取值为 'left'。\n* *origin* 取 'end' 或者 'end\\_day' 时，*closed* 的默认值为 'right'。\n\n**label** 字符串，表示重采样时间窗口的标签位置。可取值为 \"left\", \"right\"。\n\n* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，label 的默认取值为 'right' ，否则，*label* 的默认取值为 'left'。\n\n* *origin* 取 'end' 或者 'end\\_day' 时，*label* 的默认值为 'right'。\n\n**origin** 字符串或与 *start/end* 具有相同时间类型的标量，表示重采样的基准时间点，即重采样的起始点。*origin* 的取值为 'epoch', start', 'start\\_day', 'end', 'end\\_day' 或自定义的时间对象，默认值为 'start\\_day'。 字符串，表示重采样时间窗口的标签位置。可取值为 \"left\", \"right\"。\n\n* 'epoch'：分组起始点为1970-01-01。\n\n* 'start'：分组起始点为 *start* 参数指定的值。\n\n* 'start\\_day'：分组起始点是 *start* 参数指定值对应日期的午夜零点。\n\n* 'end'：分组起始点是 *end* 参数指定的值。\n\n* 'end\\_day'：分组起始点是 *end* 参数指定值对应日期的午夜24点（即下一日的零点）。\n\n#### 例子\n\n```\ntemporalSeq(start=2022.01.01 00:01:00,end=2022.01.01 00:08:00,rule=\"3min\")\n```\n\n输出返回：`[2022.01.01T00:00:00,2022.01.01T00:03:00,2022.01.01T00:06:00]`\n\n```\ntemporalSeq(start=2022.01.01 00:01:00, end=2022.01.01 00:08:00, rule=\"3min\", closed=`right)\n```\n\n输出返回：`[2022.01.01T00:00:00,2022.01.01T00:03:00,2022.01.01T00:06:00]`\n\n```\ntemporalSeq(start=2022.01.01 00:01:00, end=2022.01.01 00:08:00, rule=\"3min\", closed=`right, origin=`end)\n```\n\n输出返回：`[2022.01.01T00:02:00,2022.01.01T00:05:00,2022.01.01T00:08:00]`\n\n```\ntemporalSeq(start=2022.01.01 00:01:00, end=2022.01.01 00:08:00, rule=\"3min\", closed=`right, origin=2022.10.01 00:00:10)\n```\n\n输出返回：`[2022.01.01T00:00:10,2022.01.01T00:03:10,2022.01.01T00:06:10]`\n"
    },
    "tensor": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tensor.html",
        "signatures": [
            {
                "full": "tensor(X)",
                "name": "tensor",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [tensor](https://docs.dolphindb.cn/zh/funcs/t/tensor.html)\n\n\n\n#### 语法\n\ntensor(X)\n\n#### 参数\n\n**X** 可以是标量、向量、元组、列式元组、矩阵或表。目前仅支持以下数据类型：BOOL, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE。\n\n#### 详情\n\n将 *X* 转换为一个 tensor。转换规则如下：\n\n<table id=\"table_hpg_f52_xbc\"><thead><tr><th>\n\n**X**\n\n</th><th>\n\n**转换结果**\n\n</th></tr></thead><tbody><tr><td>\n\n标量\n\n</td><td>\n\n1 维 tensor\n\n</td></tr><tr><td>\n\n常规向量\n\n</td><td>\n\n1 维 tensor\n\n</td></tr><tr><td>\n\n列式元组\n\n</td><td>\n\n2 维 tensor\n\n</td></tr><tr><td>\n\n矩阵\n\n</td><td>\n\n2 维 tensor\n\n</td></tr><tr><td>\n\n表（每一列具有相同类型）\n\n</td><td>\n\n2 维 tensor\n\n</td></tr><tr><td>\n\ntuple（每个元素都是具有相同类型的向量，tuple of vector）\n\n</td><td>\n\n2 维 tensor\n\n</td></tr><tr><td>\n\ntuple（每个元素都是维度和类型都相同的矩阵，tuple of matrix）\n\n</td><td>\n\n3 维 tensor\n\n</td></tr><tr><td>\n\ntuple（每个元素都是 tuple，且子 tuple 的每个元素都是类型相同的向量，tuple of tuple）\n\n</td><td>\n\n3 维 tensor\n\n</td></tr><tr><td>\n\n多个 tuple 嵌套\n\n</td><td>\n\nn 维 tensor，n<=10\n\n</td></tr></tbody>\n</table>目前 tensor 主要应用于 DolphinDB 插件（如 LibTorch 等），与深度学习框架进行数据交换。DolphinDB 中的 tensor 目前暂不支持直接存储和计算，并且不支持直接访问和修改其元素。\n\n#### topic\n\n```\n// 标量转为 tensor\ntensor(3)\n/* 输出一个长度为 1 的 1 维 tensor<int[1]>:\n0: int 3\n*/\n\n// 向量转为 tensor\ntensor(1 2 3)\n/* 输出一个长度为 3 的 1 维 tensor<int[3]>：\n0: int 1\n1: int 2\n2: int 3\n*/\n\n//列式元组转为 tensor\ntp = [[1.3,2.5,2.3], [4.1,5.3,5], [4.1,5.3,5]]\ntp.setColumnarTuple!()\ntensor(tp)\n\n/* 输出一个 2 维 tensor<double[3][3]>：\n0: double[3] [1.3, 2.5, 2.3]\n1: double[3] [4.1, 5.3, 5]\n2: double[3] [4.1, 5.3, 5] \n */\n\n//矩阵转为 tensor\nm= 1..6$2:3\ntensor(m)\n\n/* 输出一个 2 维 tensor<int[2][3]>：\n0: int[3] [1, 3, 5]\n1: int[3] [2, 4, 6]\n*/\n\n// 表转为 tensor\nt=table(1..5 as id1, 6..10 as id2)\ntensor(t)\n\n/* 输出一个 2 维 tensor<int[5][2]>：\n0: int[2] [1, 6]\n1: int[2] [2, 7]\n2: int[2] [3, 8]\n3: int[2] [4, 9]\n4: int[2] [5, 10]\n*/\n\n// 元组转为 tensor\ntp1 = [[1.3,2.5,2.3], [4.1,5.3,5], [4.1,5.3,5]]\ntensor(tp1)\n\n/* 输出一个 2 维 tensor<double[3][3]>：\n0: double[3] [1.3, 4.1, 4.1]\n1: double[3] [2.5, 5.3, 5.3]\n2: double[3] [2.3, 5, 5]\n*/\n\n// tuple of matrix 转为 tensor\nm1= 1..6$2:3\nm2=4..9$2:3\ntensor([m1,m2])\n\n/* 输出一个 3 维 tensor<int[2][2][3]>:\n0: int[2][3]\n1: int[2][3]\n*/\n\n// tuple of tuple 转为 tensor\ntp1 = [[1.3,2.5,2.3], [4.1,5.3,5], [4.1,5.3,5]]\ntp2 = [[1.1,1.2,1.4], [1.5,1.2,1.6], [1.3,1.5,1.8]]\ntensor([tp1, tp2])\n\n/* 输出一个 3 维 tensor<double[2][3][3]>:\n0: double[3][3]\n1: double[3][3]\n*/\n\n// tuple 嵌套转为 tensor\ntp1 = [[1.3,2.5,2.3], [4.1,5.3,5], [4.1,5.3,5]]\ntp2 = [[1.1,1.2,1.4], [1.5,1.2,1.6], [1.3,1.5,1.8]]\ntp3 = [[2.1,6.2,4.4], [3.5,1.9,3.6], [1.8,3.5,9.8]]\ntensor([[tp1, tp2],[tp1, tp3]])\n\n/* 输出一个 4 维 tensor<double[2][2][3][3]>:\n0: double[2][3][3]\n1: double[2][3][3]\n*/\n```\n"
    },
    "test": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/test.html",
        "signatures": [
            {
                "full": "test(scriptFile, [outputFile], [testMemLeaking=false])",
                "name": "test",
                "parameters": [
                    {
                        "full": "scriptFile",
                        "name": "scriptFile"
                    },
                    {
                        "full": "[outputFile]",
                        "name": "outputFile",
                        "optional": true
                    },
                    {
                        "full": "[testMemLeaking=false]",
                        "name": "testMemLeaking",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [test](https://docs.dolphindb.cn/zh/funcs/t/test.html)\n\n\n\n#### 语法\n\ntest(scriptFile, \\[outputFile], \\[testMemLeaking=false])\n\n#### 参数\n\n**scriptFile** 是字符串，表示服务器端的测试脚本文件或目录。可以是相对路径或绝对路径。\n\n**outputFile** 是字符串，表示服务器端的测试结果输出文件。可以是相对路径或绝对路径。\n\n**testMemLeaking** 是布尔值，表示是否测试内存泄漏。\n\n#### 详情\n\n用于单元测试的系统命令。该命令必须要用户登录后才能执行。\n\n如果 *scriptFile* 是一个目录，将执行测试目录中所有脚本文件，不会执行子目录中的文件。\n\n如果 *outputFile* 没有指定，测试结果将会显示在屏幕上。如果 *outputFile* 指定为相对路径，则测试结果文件输出到 \\<HomeDir>。\n\n#### 例子\n\n```\ntest(\"/home/Data/test.dos\", \"/home/Data/result.dos\");\ntest(\"/home/Data\");\n```\n"
    },
    "textChunkDS": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/textChunkDS.html",
        "signatures": [
            {
                "full": "textChunkDS(filename, chunkSize, [delimiter], [schema], [skipRows=0], [arrayDelimiter], [containHeader], [arrayMarker])",
                "name": "textChunkDS",
                "parameters": [
                    {
                        "full": "filename",
                        "name": "filename"
                    },
                    {
                        "full": "chunkSize",
                        "name": "chunkSize"
                    },
                    {
                        "full": "[delimiter]",
                        "name": "delimiter",
                        "optional": true
                    },
                    {
                        "full": "[schema]",
                        "name": "schema",
                        "optional": true
                    },
                    {
                        "full": "[skipRows=0]",
                        "name": "skipRows",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[arrayDelimiter]",
                        "name": "arrayDelimiter",
                        "optional": true
                    },
                    {
                        "full": "[containHeader]",
                        "name": "containHeader",
                        "optional": true
                    },
                    {
                        "full": "[arrayMarker]",
                        "name": "arrayMarker",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [textChunkDS](https://docs.dolphindb.cn/zh/funcs/t/textChunkDS.html)\n\n\n\n#### 语法\n\ntextChunkDS(filename, chunkSize, \\[delimiter], \\[schema], \\[skipRows=0], \\[arrayDelimiter], \\[containHeader], \\[arrayMarker])\n\n#### 参数\n\n**filename** 一个字符串，表示文件的绝对路径。仅支持 CSV 格式的文件。若传入其他格式文件，则无法保证数据准确性。\n\n**chunkSize** 1 到 2048 之间的整数，表示文件块的大小，单位是 MB。\n\n**delimiter** 字符串标量，表示数据文件中各列的分隔符。分隔符可以是一个或多个字符，默认是逗号（\",\"）。\n\n**schema** 表对象，用于指定各字段的数据类型。具体请参考 [loadText](https://docs.dolphindb.cn/zh/funcs/l/loadText.html) 的 *schema* 参数。\n\n**skipRows** 0 到 1024 之间的整数，表示从文件头开始忽略的行数。它是一个可选参数。默认值为 0。\n\n**arrayDelimiter** 数据文件中数组向量列的分隔符。默认是逗号。由于不支持自动识别数组向量，必须同步修改 *schema* 的 type 列修为数组向量类型。\n\n**containHeader** 布尔值，表示数据文件是否包含标题行，默认为空。具体请参考 [loadText](https://docs.dolphindb.cn/zh/funcs/l/loadText.html) 的 *containHeader* 参数。\n\n**arrayMarker** 包含两个字符的字符串或或 CHAR 类型数据对，两个字符分别表示数组向量左右边界的标识符。默认标识符为双引号（\"）。\n\n* 不能包含空格、Tab(`\\t`) 和换行符(`\\t`和`\\n`)。\n\n* 不能包含数字或字母。\n\n* 如果其中一个为双引号(\")，另一个也必须为双引号。\n\n* 如果标识符为 `'`，`\"` 或`\\` ，需视情况添加转义符。例如 `arrayMarker=\"\\\"\\\"\"`。\n\n* 如果 *delimiter*是单个字符，则 *arrayMarker*不能包含与其相同的字符。\n\n* 如果 *delimiter*是多个字符，则 *arrayMarker* 左边界不能与 *delimiter*的首个字符相同。\n\n#### 详情\n\n将文件划分为多个数据源，每个数据源的大小为 *chunkSize*。如果需要将大文本文件加载到 DolphinDB, 可以使用 *textChunkDS* 函数将文本文件划分为多个小文件数据源，再通过 [mr](https://docs.dolphindb.cn/zh/funcs/m/mr.html) 函数写入到数据库中。与直接把大文本文件加载到数据库对比，这种方法占用的内存更少。\n\n当 DolphinDB 加载数据文件时，会进行随机抽样，并基于样本决定每列的数据类型。这个方法不一定每次都能准确决定各列的数据类型。因此我们建议，在加载数据前，使用 [extractTextSchema](https://docs.dolphindb.cn/zh/funcs/e/extractTextSchema.html) 函数查看 DolphinDB 识别每列的数据类型。如果 DolphinDB 识别的数据类型不符合预期，可以在 *schema* 的 type 列中指定数据类型。对于日期列或时间列，如果 DolphinDB 识别的数据类型不符合预期，不仅需要在 *schema* 的 type 列指定时间类型，还需要在 format 列中指定数据文件中日期或时间的格式（用字符串表示），如 \"MM/dd/yyyy\"。如何表示日期和时间格式请参考 [日期和时间的调整及格式](https://docs.dolphindb.cn/zh/progr/data_mani/format_temp_obj.html)。\n\n#### 例子\n\n首先，通过以下脚本生成一个大约 3.2G 的文本文件：\n\n```\nn=30000000\nworkDir = \"/home/DolphinDB\"\nif(!exists(workDir)) mkdir(workDir)\ntrades=table(rand(`IBM`MSFT`GM`C`FB`GOOG`V`F`XOM`AMZN`TSLA`PG`S,n) as sym, 2000.01.01+rand(365,n) as date, 10.0+rand(2.0,n) as price1, 100.0+rand(20.0,n) as price2, 1000.0+rand(200.0,n) as price3, 10000.0+rand(2000.0,n) as price4, 10000.0+rand(3000.0,n) as price5, 10000.0+rand(4000.0,n) as price6, rand(10,n) as qty1, rand(100,n) as qty2, rand(1000,n) as qty3, rand(10000,n) as qty4, rand(10000,n) as qty5, rand(10000,n) as qty6)\ntrades.saveText(workDir + \"/trades.txt\");\n```\n\n通过 `textChunkDS` 函数和 `mr` 函数将该文件导入到分布式数据库中：\n\n```\ndb=database(\"dfs://db1\",VALUE, `IBM`MSFT`GM`C`FB`GOOG`V`F`XOM`AMZN`TSLA`PG`S)\npt=db.createPartitionedTable(trades,`pt,`sym)\nds=textChunkDS(workDir + \"/trades.txt\",500)\nmr(ds,append!{pt},,,false)\n```\n\n**Note:** 每个小文件数据源可能包含相同分区的数据。DolphinDB 不允许多个线程同时对相同分区进行写入，因此要将 `mr` 函数 *parallel* 参数设置为 false，否则会抛出异常。\n"
    },
    "til": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/til.html",
        "signatures": [
            {
                "full": "til(n)",
                "name": "til",
                "parameters": [
                    {
                        "full": "n",
                        "name": "n"
                    }
                ]
            }
        ],
        "markdown": "### [til](https://docs.dolphindb.cn/zh/funcs/t/til.html)\n\n\n\n#### 语法\n\ntil(n)\n\n#### 参数\n\n**n** 非负整数。\n\n#### 详情\n\n返回 0 到 *n*-1 的整型向量。注意：若 *n* 为 0，则返回空向量。\n\n**Note:**\n\n返回值的类型与 *n* 的类型保持一致，如：若 *n* 类型是 LONG，则返回值的类型是 FAST LONG VECTOR。\n\n#### 例子\n\n```\ntil(0);\n// output\n[]\n\ntil(5);\n// output\n[0,1,2,3,4]\n\nn = 10;\nt = table(2022.01.01 + til(n) as date, rand(10.0, n) as val);\nt;\n// output\ndate        val\n2022.01.01  8.403\n2022.01.02  9.424\n2022.01.03  0.4779\n2022.01.04  1.8934\n2022.01.05  9.6637\n2022.01.06  1.7993\n2022.01.07  7.1143\n2022.01.08  8.3044\n2022.01.09  2.6919\n2022.01.10  1.9294\n```\n\n相关函数：[take](https://docs.dolphindb.cn/zh/funcs/t/take.html), [rand](https://docs.dolphindb.cn/zh/funcs/r/rand.html)\n"
    },
    "time": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/time.html",
        "signatures": [
            {
                "full": "time(X)",
                "name": "time",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [time](https://docs.dolphindb.cn/zh/funcs/t/time.html)\n\n\n\n#### 语法\n\ntime(X)\n\n#### 详情\n\n返回毫秒精度时间。返回的数据类型是 TIME。\n\n#### 参数\n\n**X** 是一个时间标量/向量。\n\n#### 例子\n\n```\ntime();\n```\n\n返回：null\n\n```\ntime(1)\n```\n\n返回：00:00:00.001\n\n```\ntime(\"12:32:56.356\");\n```\n\n返回：12:32:56.356\n\n```\ntime(now());\n```\n\n返回：16:03:36.529\n"
    },
    "timestamp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/timestamp.html",
        "signatures": [
            {
                "full": "timestamp(X)",
                "name": "timestamp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [timestamp](https://docs.dolphindb.cn/zh/funcs/t/timestamp.html)\n\n\n\n#### 语法\n\ntimestamp(X)\n\n#### 参数\n\n**X** 是一个时间标量或向量。\n\n**Note:** 自 2.00.12 版本起，支持转换 MONTH 类型的数据。\n\n#### 详情\n\n返回由日期和精确到毫秒的时间组成的时间戳。返回的数据类型是 TIMESTAMP，一个时间值。如果参数 *X* 不是日期和时间，则返回值是 1970.01.01 00:00:00.000 + *X* 毫秒的时间戳。\n\n#### 例子\n\n```\ntimestamp(1)\n```\n\n返回：1970.01.01 00:00:00.001\n\n```\ntimestamp(2016.10.12);\n```\n\n返回：2016.10.12 00:00:00.000\n\n```\ntimestamp(2016.10.12)+1;\n```\n\n返回：2016.10.12 00:00:00.001\n\n```\ntimestamp(now());\n```\n\n返回：2024.02.22 15:57:33.291\n\n```\ntimestamp(2012.01M)\n```\n\n返回：2012.01.01T00:00:00.000\n"
    },
    "tmavg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmavg.html",
        "signatures": [
            {
                "full": "tmavg(T, X, window)",
                "name": "tmavg",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmavg](https://docs.dolphindb.cn/zh/funcs/t/tmavg.html)\n\n\n\n#### 语法\n\ntmavg(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 元素的平均值。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 2 -1 2 4\nm = table(T as t,X as x)\nselect *, tmavg(t, x, 3) from m\n```\n\n| t | x  | tmavg\\_t |\n| - | -- | -------- |\n| 1 | 1  | 1        |\n| 1 | 4  | 2.5      |\n| 1 | 2  | 2.3333   |\n| 2 | -1 | 1.5      |\n| 5 | 2  | 2        |\n| 6 | 4  | 3        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = 1 4 2 -1 2 4\nm = table(T as t,X as x)\nselect *, tmavg(t, x, 3d) from m\n```\n\n| t          | x  | tmavg\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 | 1  | 1        |\n| 2021.01.02 | 4  | 2.5      |\n| 2021.01.04 | 2  | 2.3333   |\n| 2021.01.05 | -1 | 0.5      |\n| 2021.01.07 | 2  | 0.5      |\n| 2021.01.08 | 4  | 3        |\n\n```\nselect *, tmavg(t, x, 1w) from m\n```\n\n| t          | x  | tmavg\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 | 1  | 1        |\n| 2021.01.02 | 4  | 2.5      |\n| 2021.01.04 | 2  | 2.3333   |\n| 2021.01.05 | -1 | 1.5      |\n| 2021.01.07 | 2  | 1.6      |\n| 2021.01.08 | 4  | 2        |\n\n相关函数：[mavg](https://docs.dolphindb.cn/zh/funcs/m/mavg.html), [avg](https://docs.dolphindb.cn/zh/funcs/a/avg.html)\n"
    },
    "tmavgTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmavgTopN.html",
        "signatures": [
            {
                "full": "tmavgTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmavgTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmavgTopN](https://docs.dolphindb.cn/zh/funcs/t/tmavgTopN.html)\n\n\n\n#### 语法\n\ntmavgTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，计算前 *top* 个元素的平均值。\n\n#### 返回值\n\nDOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]  // S 中包含的空值不参与排序，对应位置的 X 不参与计算\ntmavgTopN(T,X,S,6,4)\n// output\n[2,1.5,2.3333,2.3333,2.75,3.25,3]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmavgTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n| 8      |\n| 3      |\n| 2      |\n| 2      |\n| 2.6666 |\n| 3      |\n\n相关函数：[tmavg](https://docs.dolphindb.cn/zh/funcs/t/tmavg.html)\n"
    },
    "tmbeta": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmbeta.html",
        "signatures": [
            {
                "full": "tmbeta(T, Y, X, window)",
                "name": "tmbeta",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmbeta](https://docs.dolphindb.cn/zh/funcs/t/tmbeta.html)\n\n\n\n#### 语法\n\ntmbeta(T, Y, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间长度衡量）的移动窗口中，计算 *Y* 在 *X* 上的回归系数的最小二乘估计。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmbeta(t, y, x, 3) from m\n```\n\n| t | x  | y  | tmbeta\\_t |\n| - | -- | -- | --------- |\n| 1 | 1  | 2  |           |\n| 1 | 4  | 5  | 1         |\n| 1 | 2  | -3 | 1.4286    |\n| 2 | -1 | 6  | -0.3846   |\n| 5 | 2  | 9  |           |\n| 6 | 4  | 1  | -4        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmbeta(t, y, x, 3d) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 1         |\n| 2021.01.04 | 2  | -3 | 1.4286    |\n| 2021.01.05 | -1 | 6  | -3        |\n| 2021.01.07 | 2  | 9  | 1         |\n| 2021.01.08 | 4  | 1  | -4        |\n\n```\nselect *, tmbeta(t, y, x, 1w) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 1         |\n| 2021.01.04 | 2  | -3 | 1.4286    |\n| 2021.01.05 | -1 | 6  | -0.3846   |\n| 2021.01.07 | 2  | 9  | -0.1818   |\n| 2021.01.08 | 4  | 1  | -0.4444   |\n\n相关函数：[mbeta](https://docs.dolphindb.cn/zh/funcs/m/mbeta.html), [beta](https://docs.dolphindb.cn/zh/funcs/b/beta.html)\n"
    },
    "tmbetaTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmbetaTopN.html",
        "signatures": [
            {
                "full": "tmbetaTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmbetaTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmbetaTopN](https://docs.dolphindb.cn/zh/funcs/t/tmbetaTopN.html)\n\n\n\n#### 语法\n\ntmbetaTopN(T, X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，计算 *Y* 在 *X* 上的回归系数的最小二乘估计。\n\n返回值：DOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nY=[1, 7, 8, 9, 0, 5, 8]\nS = [5, 8, 1, , 1, 1, 3]  // S 中包含的空值不参与排序，对应位置的 X 和 Y不参与计算\ntmbetaTopN(T,X,Y,S,6,4)\n// output\n[,-0.1666,0.1279,0.1279,-0.06,0.0853,-0.1871]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nY=1 7 8 9 0 5\nS=1 5 2 3 1 1\nt=table(T as time, X as val1, Y as val2, S as id)\nselect tmbetaTopN(time,val1,val2,id,4,3) as topN from t\n```\n\n| topN    |\n| ------- |\n|         |\n|         |\n| -2      |\n| -0.5    |\n| -0.3972 |\n| -0.3442 |\n\n相关函数：[tmbeta](https://docs.dolphindb.cn/zh/funcs/t/tmbeta.html)\n"
    },
    "tmcorr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmcorr.html",
        "signatures": [
            {
                "full": "tmcorr(T, X, Y, window)",
                "name": "tmcorr",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmcorr](https://docs.dolphindb.cn/zh/funcs/t/tmcorr.html)\n\n\n\n#### 语法\n\ntmcorr(T, X, Y, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间长度衡量）的滑动窗口内，计算 *X* 和 *Y* 元素的相关性。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmcorr(t, y, x, 3) from m\n```\n\n| t | x  | y  | tmcorr\\_t |\n| - | -- | -- | --------- |\n| 1 | 1  | 2  |           |\n| 1 | 4  | 5  | 1         |\n| 1 | 2  | -3 | 0.5399    |\n| 2 | -1 | 6  | -0.1981   |\n| 5 | 2  | 9  |           |\n| 6 | 4  | 1  | -1        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmcorr(t, y, x, 3d) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 1         |\n| 2021.01.04 | 2  | -3 | 0.5399    |\n| 2021.01.05 | -1 | 6  | -1        |\n| 2021.01.07 | 2  | 9  | 1         |\n| 2021.01.08 | 4  | 1  | -1        |\n\n```\nselect *, tmcorr(t, y, x, 1w) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 1         |\n| 2021.01.04 | 2  | -3 | 0.5399    |\n| 2021.01.05 | -1 | 6  | -0.1981   |\n| 2021.01.07 | 2  | 9  | -0.0726   |\n| 2021.01.08 | 4  | 1  | -0.1995   |\n\n相关函数：[mcorr](https://docs.dolphindb.cn/zh/funcs/m/mcorr.html), [corr](https://docs.dolphindb.cn/zh/funcs/c/corr.html)\n"
    },
    "tmcorrTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmcorrTopN.html",
        "signatures": [
            {
                "full": "tmcorrTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmcorrTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmcorrTopN](https://docs.dolphindb.cn/zh/funcs/t/tmcorrTopN.html)\n\n\n\n#### 语法\n\ntmcorrTopN(T, X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，计算 *X* 和 *Y* 之间的相关性。\n\n#### 返回值\n\nDOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nY=[1, 7, 8, 9, 0, 5, 8]\nS = [5, 8, 1, , 1, 1, 3]  // S 中包含的空值不参与排序，对应位置的 X 和 Y不参与计算\ntmcorrTopN(T,X,Y,S,6,4)\n// output\n[,-1,0.317,0.317,-0.16329,0.3296,-0.4995]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nY=1 7 8 9 0 5\nS=1 5 2 3 1 1\nt=table(T as time, X as val1, Y as val2, S as id)\nselect tmcorrTopN(time,val1,val2,id,4,3) as topN from t\n```\n\n| topN    |\n| ------- |\n|         |\n|         |\n| -1      |\n| -0.5    |\n| -0.9413 |\n| -0.8962 |\n\n相关函数：[tmcorr](https://docs.dolphindb.cn/zh/funcs/t/tmcorr.html)\n"
    },
    "tmcount": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmcount.html",
        "signatures": [
            {
                "full": "tmcount(T, X, window)",
                "name": "tmcount",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmcount](https://docs.dolphindb.cn/zh/funcs/t/tmcount.html)\n\n\n\n#### 语法\n\ntmcount(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内统计 *X* 中的非 NULL 元素个数。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmcount(t, x, 3) from m\n```\n\n| t | x  | tmcount\\_t |\n| - | -- | ---------- |\n| 1 | 1  | 1          |\n| 1 | 4  | 2          |\n| 1 |    | 2          |\n| 2 | -1 | 3          |\n| 5 |    | 0          |\n| 6 | 4  | 1          |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.09\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmcount(t, x, 3d) from m\n```\n\n| t          | x  | tmcount\\_t |\n| ---------- | -- | ---------- |\n| 2021.01.02 |    | 0          |\n| 2021.01.02 | 4  | 1          |\n| 2021.01.04 |    | 1          |\n| 2021.01.05 | -1 | 1          |\n| 2021.01.07 | 2  | 2          |\n| 2021.01.09 | 4  | 2          |\n\n```\nselect *, tmcount(t, x, 1w) from m\n```\n\n| t          | x  | tmcount\\_t |\n| ---------- | -- | ---------- |\n| 2021.01.02 |    | 0          |\n| 2021.01.02 | 4  | 1          |\n| 2021.01.04 |    | 1          |\n| 2021.01.05 | -1 | 2          |\n| 2021.01.07 | 2  | 3          |\n| 2021.01.09 | 4  | 3          |\n\n相关函数：[mcount](https://docs.dolphindb.cn/zh/funcs/m/mcount.html), [count](https://docs.dolphindb.cn/zh/funcs/c/count.html)\n"
    },
    "tmcovar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmcovar.html",
        "signatures": [
            {
                "full": "tmcovar(T, X, Y, window)",
                "name": "tmcovar",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmcovar](https://docs.dolphindb.cn/zh/funcs/t/tmcovar.html)\n\n\n\n#### 语法\n\ntmcovar(T, X, Y, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间长度衡量）的滑动窗口内，计算 *X* 和 *Y* 元素的协方差。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmcovar(t, y, x, 3) from m\n```\n\n| t | x  | y  | tmbeta\\_t |\n| - | -- | -- | --------- |\n| 1 | 1  | 2  |           |\n| 1 | 4  | 5  | 4.5       |\n| 1 | 2  | -3 | 3.3333    |\n| 2 | -1 | 6  | -1.6667   |\n| 5 | 2  | 9  |           |\n| 6 | 4  | 1  | -8        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = 1 4 2 -1 2 4\nY = 2 5 -3 6 9 1\nm = table(T as t,X as x, Y as y)\nselect *, tmcovar(t, y, x, 3d) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 4.5       |\n| 2021.01.04 | 2  | -3 | 3.3333    |\n| 2021.01.05 | -1 | 6  | -13.5     |\n| 2021.01.07 | 2  | 9  | 4.5       |\n| 2021.01.08 | 4  | 1  | -8        |\n\n```\nselect *, tmcovar(t, y, x, 1w) from m\n```\n\n| t          | x  | y  | tmcorr\\_t |\n| ---------- | -- | -- | --------- |\n| 2021.01.02 | 1  | 2  |           |\n| 2021.01.02 | 4  | 5  | 4.5       |\n| 2021.01.04 | 2  | -3 | 3.3333    |\n| 2021.01.05 | -1 | 6  | -1.6667   |\n| 2021.01.07 | 2  | 9  | -0.6      |\n| 2021.01.08 | 4  | 1  | -1.6      |\n\n相关函数：[mcovar](https://docs.dolphindb.cn/zh/funcs/m/mcovar.html), [covar](https://docs.dolphindb.cn/zh/funcs/c/covar.html)\n"
    },
    "tmcovarTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmcovarTopN.html",
        "signatures": [
            {
                "full": "tmcovarTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmcovarTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmcovarTopN](https://docs.dolphindb.cn/zh/funcs/t/tmcovarTopN.html)\n\n\n\n#### 语法\n\ntmcovarTopN(T, X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，计算 *X* 和 *Y* 的协方差。\n\n#### 返回值\n\nDOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nY=[1, 7, 8, 9, 0, 5, 8]\nS = [5, 8, 1, , 1, 1, 3]  //S 中包含的空值不参与排序，对应位置的 X 和 Y 不参与计算\ntmcovarTopN(T,X,Y,S,6,4)\n// output\n[,-3,1.8333,1.8333,-1,1.1666,-2.6666]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nY=1 7 8 9 0 5\nS=1 5 2 3 1 1\nt=table(T as time, X as val1, Y as val2, S as id)\nselect tmcovarTopN(time,val1,val2,id,4,3) as topN from t\n```\n\n| topN    |\n| ------- |\n|         |\n|         |\n| -1      |\n| -0.5    |\n| -9.6666 |\n| -7      |\n\n相关函数：[tmcovar](https://docs.dolphindb.cn/zh/funcs/t/tmcovar.html)\n"
    },
    "tmfirst": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmfirst.html",
        "signatures": [
            {
                "full": "tmfirst(T, X, window)",
                "name": "tmfirst",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmfirst](https://docs.dolphindb.cn/zh/funcs/t/tmfirst.html)\n\n\n\n#### 语法\n\ntmfirst(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 的第一个元素。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmfirst(t, x, 3) from m\n```\n\n| t | x  | tmfirst\\_t |\n| - | -- | ---------- |\n| 1 | 1  | 1          |\n| 1 | 4  | 1          |\n| 1 |    | 1          |\n| 2 | -1 | 1          |\n| 5 |    |            |\n| 6 | 4  |            |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = 3 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmfirst(t, x, 3d) from m\n```\n\n| t          | x  | tmfirst\\_t |\n| ---------- | -- | ---------- |\n| 2021.01.02 | 3  | 3          |\n| 2021.01.02 | 4  | 3          |\n| 2021.01.04 |    | 3          |\n| 2021.01.05 | -1 |            |\n| 2021.01.07 | 2  | -1         |\n| 2021.01.08 | 4  | 2          |\n\n```\nselect *, tmfirst(t, x, 1w) from m\n```\n\n| t          | x  | tmfirst\\_t |\n| ---------- | -- | ---------- |\n| 2021.01.02 | 3  | 3          |\n| 2021.01.02 | 4  | 3          |\n| 2021.01.04 |    | 3          |\n| 2021.01.05 | -1 | 3          |\n| 2021.01.07 | 2  | 3          |\n| 2021.01.08 | 4  | 3          |\n\n相关函数：[mfirst](https://docs.dolphindb.cn/zh/funcs/m/mfirst.html), [first](https://docs.dolphindb.cn/zh/funcs/f/first.html)\n"
    },
    "tmkurtosis": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmkurtosis.html",
        "signatures": [
            {
                "full": "tmkurtosis(T, X, window, [biased=true])",
                "name": "tmkurtosis",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [tmkurtosis](https://docs.dolphindb.cn/zh/funcs/t/tmkurtosis.html)\n\n\n\n#### 语法\n\ntmkurtosis(T, X, window, \\[biased=true])\n\n部分通用参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否是有偏估计。默认值为 true，表示有偏估计。\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 的峰度。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t, X as x)\nselect *, tmkurtosis(t, x, 3) from m\n```\n\n| t | x  | tmkurtosis\\_t |\n| - | -- | ------------- |\n| 1 | 1  |               |\n| 1 | 4  |               |\n| 1 |    |               |\n| 2 | -1 | 1.5           |\n| 5 |    |               |\n| 6 | 4  |               |\n\n```\nT = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\nX = 1 NULL 3 4 5 NULL 3 NULL 5 3\nm = table(T as t,X as x)\nselect *, tmkurtosis(t, x, 3d) from m\n```\n\n| t             | x | tmkurtosis\\_t |\n| ------------- | - | ------------- |\n| 2019.06.13T13 | 1 |               |\n| 2019.06.13T13 |   |               |\n| 2019.06.13T13 | 3 |               |\n| 2019.06.13T13 | 4 | 1.5           |\n| 2019.06.13T14 | 5 | 1.8457        |\n| 2019.06.13T15 |   | 1.8457        |\n| 2019.06.13T16 | 3 | 2.2169        |\n| 2019.06.13T17 |   | 2.2169        |\n| 2019.06.13T18 | 5 | 2.2401        |\n| 2019.06.13T19 | 3 | 2.4072        |\n\n```\nselect *, tmkurtosis(t, x, 1w) from m\n```\n\n| t             | x | tmkurtosis\\_t |\n| ------------- | - | ------------- |\n| 2019.06.13T13 | 1 |               |\n| 2019.06.13T13 |   |               |\n| 2019.06.13T13 | 3 |               |\n| 2019.06.13T13 | 4 | 1.5           |\n| 2019.06.13T14 | 5 | 1.8457        |\n| 2019.06.13T15 |   | 1.8457        |\n| 2019.06.13T16 | 3 | 2.2169        |\n| 2019.06.13T17 |   | 2.2169        |\n| 2019.06.13T18 | 5 | 2.2401        |\n| 2019.06.13T19 | 3 | 2.4072        |\n\n相关函数：[mkurtosis](https://docs.dolphindb.cn/zh/funcs/m/mkurtosis.html), [kurtosis](https://docs.dolphindb.cn/zh/funcs/k/kurtosis.html)\n"
    },
    "tmkurtosisTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmkurtosisTopN.html",
        "signatures": [
            {
                "full": "tmkurtosisTopN(T, X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "tmkurtosisTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmkurtosisTopN](https://docs.dolphindb.cn/zh/funcs/t/tmkurtosisTopN.html)\n\n\n\n#### 语法\n\ntmkurtosisTopN(T, X, S, window, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否是有偏估计。默认值为 true，表示有偏估计。\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，计算前 *top* 个元素的峰度。\n\n#### 返回值\n\nDOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..10\nX = [2, 1, 4, 3, 4, 3, 1, 5, 8, 2]\nS = [5, 8, 1, , 1, 1, 3, 2, 5 ,1]  //S 中包含的空值不参与排序，对应位置的 X 不参与计算\ntmkurtosisTopN(T,X,S,6,4)\n// output\n[,,1.5,1.5,1.2798,1.628,2,2,1.8457,1.64]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12 2023.01.13 2023.01.14 2023.01.15 2023.01.16\nX=8 3 1 2 5 2 5 4 2 6\nS=1 5 2 3 1 1 2 4 5 3\nt=table(T as time, X as val, S as id)\nselect tmkurtosisTopN(time,val,id,6,4) as topN from t\n```\n\n| topN   |\n| ------ |\n|        |\n|        |\n| 1.5    |\n| 1.5    |\n| 1.8457 |\n| 2.1852 |\n| 1.1522 |\n| 1      |\n| 1      |\n| 2.1852 |\n\n相关函数：[tmkurtosis](https://docs.dolphindb.cn/zh/funcs/t/tmkurtosis.html)\n"
    },
    "tmlast": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmlast.html",
        "signatures": [
            {
                "full": "tmlast(T, X, window)",
                "name": "tmlast",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmlast](https://docs.dolphindb.cn/zh/funcs/t/tmlast.html)\n\n\n\n#### 语法\n\ntmlast(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 的最后一个元素。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmlast(t, x, 3) from m\n```\n\n| t | x  | tmlast\\_t |\n| - | -- | --------- |\n| 1 | 1  | 1         |\n| 1 | 4  | 4         |\n| 1 |    |           |\n| 2 | -1 | -1        |\n| 5 |    |           |\n| 6 | 4  | 4         |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmlast(t, x, 3d) from m\n```\n\n| t          | x  | tmlast\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 4         |\n| 2021.01.04 |    |           |\n| 2021.01.05 | -1 | -1        |\n| 2021.01.07 | 2  | 2         |\n| 2021.01.08 | 4  | 4         |\n\n```\nselect *, tmlast(t, x, 1w) from m\n```\n\n| t          | x  | tmlast\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 4         |\n| 2021.01.04 |    |           |\n| 2021.01.05 | -1 | -1        |\n| 2021.01.07 | 2  | 2         |\n| 2021.01.08 | 4  | 4         |\n\n相关函数：[mlast](https://docs.dolphindb.cn/zh/funcs/m/mlast.html), [last](https://docs.dolphindb.cn/zh/funcs/l/last.html)\n"
    },
    "tmLowRange": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmlowrange.html",
        "signatures": [
            {
                "full": "tmLowRange(T, X, window)",
                "name": "tmLowRange",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmLowRange](https://docs.dolphindb.cn/zh/funcs/t/tmlowrange.html)\n\n#### 语法\n\ntmLowRange(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，统计每个元素 Xi 左侧相邻且连续大于它的元素个数。NULL 被视为最小值。\n\n#### 例子\n\n```\nt = [0, 1, 2, 3, 7, 8, 9, 10, 11]\nx = [NULL, 3.1, NULL, 3.0, 2.9, 2.8, 3.1, NULL, 3.2]\ntmLowRange(t, x, window=3)\n// output: [,0,1,0,0,1,0,2,0]\n\ntmLowRange(t, x, window=4)\n// output: [,0,1,0,0,1,0,3,0]\n\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\ntmLowRange(index, data, 4h)\n// output: [0,1,0,0,0,3,0,1,0,1]\n```\n\n"
    },
    "tmmax": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmmax.html",
        "signatures": [
            {
                "full": "tmmax(T, X, window)",
                "name": "tmmax",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmmax](https://docs.dolphindb.cn/zh/funcs/t/tmmax.html)\n\n\n\n#### 语法\n\ntmmax(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 元素的最大值。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmmax(t, x, 3) from m\n```\n\n| t | x  | tmmax\\_t |\n| - | -- | -------- |\n| 1 | 1  | 1        |\n| 1 | 4  | 4        |\n| 1 |    | 4        |\n| 2 | -1 | 4        |\n| 5 |    |          |\n| 6 | 4  | 4        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmmax(t, x, 3d) from m\n```\n\n| t          | x  | tmmax\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | -1       |\n| 2021.01.07 | 2  | 2        |\n| 2021.01.08 | 4  | 4        |\n\n```\nselect *, tmmax(t, x, 1w) from m\n```\n\n| t          | x  | tmmax\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | 4        |\n| 2021.01.07 | 2  | 4        |\n| 2021.01.08 | 4  | 4        |\n\n相关函数：[mmax](https://docs.dolphindb.cn/zh/funcs/m/mmax.html), [max](https://docs.dolphindb.cn/zh/funcs/m/max.html)\n"
    },
    "tmmed": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmmed.html",
        "signatures": [
            {
                "full": "tmmed(T, X, window)",
                "name": "tmmed",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmmed](https://docs.dolphindb.cn/zh/funcs/t/tmmed.html)\n\n\n\n#### 语法\n\ntmmed(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 元素的中位数。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmmed(t, x, 3) from m\n```\n\n| t | x  | tmmed\\_t |\n| - | -- | -------- |\n| 1 | 1  | 1        |\n| 1 | 4  | 2.5      |\n| 1 |    | 2.5      |\n| 2 | -1 | 1        |\n| 5 |    |          |\n| 6 | 4  | 4        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmmed(t, x, 3d) from m\n```\n\n| t          | x  | tmmed\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | -1       |\n| 2021.01.07 | 2  | 0.5      |\n| 2021.01.08 | 4  | 3        |\n\n```\nselect *, tmmed(t, x, 1w) from m\n```\n\n| t          | x  | tmmed\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | 1.5      |\n| 2021.01.07 | 2  | 2        |\n| 2021.01.08 | 4  | 3        |\n\n相关函数：[mmed](https://docs.dolphindb.cn/zh/funcs/m/mmed.html), [med](https://docs.dolphindb.cn/zh/funcs/m/med.html)\n"
    },
    "tmmin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmmin.html",
        "signatures": [
            {
                "full": "tmmin(T, X, window)",
                "name": "tmmin",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmmin](https://docs.dolphindb.cn/zh/funcs/t/tmmin.html)\n\n\n\n#### 语法\n\ntmmin(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 元素的最小值。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmmin(t, x, 3) from m\n```\n\n| t | x  | tmmin\\_t |\n| - | -- | -------- |\n| 1 | 1  | 1        |\n| 1 | 4  | 1        |\n| 1 |    | 1        |\n| 2 | -1 | -1       |\n| 5 |    |          |\n| 6 | 4  | 4        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmmin(t, x, 3d) from m\n```\n\n| t          | x  | tmmin\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | -1       |\n| 2021.01.07 | 2  | -1       |\n| 2021.01.08 | 4  | 2        |\n\n```\nselect *, tmmin(t, x, 1w) from m\n```\n\n| t          | x  | tmmin\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  | 4        |\n| 2021.01.04 |    | 4        |\n| 2021.01.05 | -1 | -1       |\n| 2021.01.07 | 2  | -1       |\n| 2021.01.08 | 4  | -1       |\n\n相关函数：[mmin](https://docs.dolphindb.cn/zh/funcs/m/mmin.html), [min](https://docs.dolphindb.cn/zh/funcs/m/min.html)\n"
    },
    "tmove": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmove.html",
        "signatures": [
            {
                "full": "tmove(T, X, window)",
                "name": "tmove",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmove](https://docs.dolphindb.cn/zh/funcs/t/tmove.html)\n\n\n\n#### 语法\n\ntmove(T, X, window)\n\n#### 详情\n\n返回 *T* 向前偏移 *window* 后对应的 *X* 中元素。即：对于 *T* 中每个时间T i，向前偏移 *window* 后为T i - *window*, 返回T i - *window* 对应的 *X* 中的元素，若 *T* 中无对应时间，则返回Ti - *window* 前一个临近时间对应的 *X* 中的元素。\n\n#### 参数\n\n**T** 是一个递增的整型或时间类型的向量，且不能包含 NULL 值。\n\n**X** 是一个与 *T* 长度相同的向量。\n\n**window** 是一个正整数或一个 [duration](https://docs.dolphindb.cn/zh/funcs/d/duration.html)。表示向前移动的区间。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmove(t, x, 3) from m\n```\n\n| t | x  | tmove\\_t |\n| - | -- | -------- |\n| 1 | 1  |          |\n| 1 | 4  |          |\n| 1 |    |          |\n| 2 | -1 |          |\n| 5 |    | -1       |\n| 6 | 4  | -1       |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.09\nX = 5 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmove(t, x, 3d) from m\n```\n\n| t          | x  | tmove\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 | 5  |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 | 4        |\n| 2021.01.07 | 2  |          |\n| 2021.01.09 | 4  | -1       |\n\n```\nselect *, tmove(t, x, 1w) from m\n```\n\n| t          | x  | tmove\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 | 5  |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 |          |\n| 2021.01.07 | 2  |          |\n| 2021.01.09 | 4  | 4        |\n\n**Related information**\n\n[move](https://docs.dolphindb.cn/zh/funcs/m/move.html)\n"
    },
    "tmovingWindowData": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmovingWindowData.html",
        "signatures": [
            {
                "full": "tmovingWindowData(T, X, window, [leftClosed = false])",
                "name": "tmovingWindowData",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[leftClosed = false]",
                        "name": "[leftClosed = false]"
                    }
                ]
            }
        ],
        "markdown": "### [tmovingWindowData](https://docs.dolphindb.cn/zh/funcs/t/tmovingWindowData.html)\n\n\n\n#### 语法\n\ntmovingWindowData(T, X, window, \\[leftClosed = false])\n\n#### 参数\n\n**T** 是一个非严格递增的整型或时间类型的向量。\n\n**X** 是一个与 T 长度相同的向量。\n\n**window** 是一个正整型或 DURATION 标量，表示以时间衡量的窗口的长度。\n\n**leftClosed** 是一个布尔值，表示窗口是否包含左边界的数据，默认为 false。\n\n#### 详情\n\n返回一个数组向量，其每行元素表示 *X* 每个滑动窗口的元素。\n\n#### 例子\n\n```\nT = 2022.01.01T09:00:00 + 1 1 2 3 6 7 9 10 13 14\nS = 1..10\ntmovingWindowData(T, S, 3s)\n[[1],[1,2],[1,2,3],[1,2,3,4],[5],[5,6],[6,7],[7,8],[9],[9,10]]\n\ntmovingWindowData(T, S, 3s, leftClosed=true)\n[[1],[1,2],[1,2,3],[1,2,3,4],[4,5],[5,6],[5,6,7],[6,7,8],[8,9],[9,10]]\n\n// 在响应式引擎中获取10分钟滑动窗口的数据\nn = 100\nDateTime = 2023.01.01T09:00:00 + rand(10000, n).sort!()\nSecurityID = take(`600021`600022`600023`600024`600025, n)\nPrice = 1.0 + rand(1.0, n) \nt = table(1:0, `DateTime`SecurityID`Price, [TIMESTAMP, SYMBOL, DOUBLE])\ntableInsert(t, DateTime, SecurityID, Price)\noutput = table(100:0, `SecurityID`DateTime`PriceNew, [SYMBOL, DATETIME, DOUBLE[]])\n\nengine = createReactiveStateEngine(name=\"rseEngine\", metrics=[<DateTime>, <tmovingWindowData(DateTime, Price,10m)>], dummyTable=t, outputTable=output, keyColumn=`SecurityID, keepOrder=true)\nengine.append!(t)\ndropStreamEngine(`rseEngine)\n```\n"
    },
    "tmpercentile": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmpercentile.html",
        "signatures": [
            {
                "full": "tmpercentile(T, X, percent, window, [interpolation='linear'])",
                "name": "tmpercentile",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "percent",
                        "name": "percent"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[interpolation='linear']",
                        "name": "interpolation",
                        "optional": true,
                        "default": "'linear'"
                    }
                ]
            }
        ],
        "markdown": "### [tmpercentile](https://docs.dolphindb.cn/zh/funcs/t/tmpercentile.html)\n\n\n\n#### 语法\n\ntmpercentile(T, X, percent, window, \\[interpolation='linear'])\n\n部分通用参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 参数\n\n**percent** 是0到100之间的整数或小数。\n\n**interpolation** 是一个字符串，表示当选中的分位点位于在 *X* 的第 i 和第 i+1 个元素之间时，采用的插值方法。它具有以下取值：\n\n* 'linear': ![linear](https://docs.dolphindb.cn/zh/images/tmlinear.png) 其中 ![fraction](https://docs.dolphindb.cn/zh/images/tmfraction.png)\n\n* 'lower': ![lower](https://docs.dolphindb.cn/zh/images/xi.png)\n\n* 'higher': ![higher](https://docs.dolphindb.cn/zh/images/higher.png)\n\n* 'nearest': ![lower](https://docs.dolphindb.cn/zh/images/xi.png) 和![higher](https://docs.dolphindb.cn/zh/images/higher.png)之中最接近分位点的数据\n\n* 'midpoint': ![midpoint](https://docs.dolphindb.cn/zh/images/midpoint.png)\n\n如果没有指定 *interpolation*，默认采用 'linear'。\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 元素在其对应窗口内的百分位数。\n\n#### 例子\n\n```\nT = 1 1 1 2 5 6\nX = 1 4 NULL -1 NULL 4\nm = table(T as t,X as x)\nselect *, tmpercentile(t, x, 3) from m\n```\n\n| t  | x  | tmpercentile\\_t |\n| -- | -- | --------------- |\n| 1  | 5  | 5               |\n| 1  | 2  | 2.3             |\n| 3  | 4  | 2.4             |\n| 5  | 1  | 1.3             |\n| 8  | 2  | 2               |\n| 15 | 8  | 8               |\n| 15 | 9  | 8.1             |\n| 20 | 10 | 10              |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmpercentile(t, x, 50, 3d) from m\n```\n\n| t          | x  | tmpercentile\\_t |\n| ---------- | -- | --------------- |\n| 2021.01.02 |    |                 |\n| 2021.01.02 | 4  | 4               |\n| 2021.01.04 |    | 4               |\n| 2021.01.05 | -1 | -1              |\n| 2021.01.07 | 2  | 0.5             |\n| 2021.01.08 | 4  | 3               |\n\n```\nselect *, tmpercentile(t, x, 50, 1w) from m\n```\n\n| t          | x  | tmpercentile\\_t |\n| ---------- | -- | --------------- |\n| 2021.01.02 |    |                 |\n| 2021.01.02 | 4  | 4               |\n| 2021.01.04 |    | 4               |\n| 2021.01.05 | -1 | 1.5             |\n| 2021.01.07 | 2  | 2               |\n| 2021.01.08 | 4  | 3               |\n\n相关函数：[percentile](https://docs.dolphindb.cn/zh/funcs/p/percentile.html), [mpercentile](https://docs.dolphindb.cn/zh/funcs/m/mpercentile.html)\n"
    },
    "tmprod": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmprod.html",
        "signatures": [
            {
                "full": "tmprod(T, X, window)",
                "name": "tmprod",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmprod](https://docs.dolphindb.cn/zh/funcs/t/tmprod.html)\n\n\n\n#### 语法\n\ntmprod(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 元素的乘积。\n\n#### 例子\n\n```\nT = 1 1 3 5 8 15 15 20\nX = 5 2 4 1 2 8 9 10\nm=table(T as t, X as x)\nselect *, tmprod(t, x, 3) from m\n```\n\n| t  | x  | tmprod\\_t |\n| -- | -- | --------- |\n| 1  | 5  | 5         |\n| 1  | 2  | 10        |\n| 3  | 4  | 40        |\n| 5  | 1  | 4         |\n| 8  | 2  | 2         |\n| 15 | 8  | 8         |\n| 15 | 9  | 72        |\n| 20 | 10 | 10        |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmprod(t, x, 3d) from m\n```\n\n| t          | x  | tmprod\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 4         |\n| 2021.01.04 |    | 4         |\n| 2021.01.05 | -1 | -1        |\n| 2021.01.07 | 2  | -2        |\n| 2021.01.08 | 4  | 8         |\n\n```\nselect *, tmprod(t, x, 1w) from m\n```\n\n| t          | x  | tmprod\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 4         |\n| 2021.01.04 |    | 4         |\n| 2021.01.05 | -1 | -1        |\n| 2021.01.07 | 2  | -2        |\n| 2021.01.08 | 4  | 8         |\n\n相关函数：[mprod](https://docs.dolphindb.cn/zh/funcs/m/mprod.html), [prod](https://docs.dolphindb.cn/zh/funcs/p/prod.html)\n"
    },
    "tmrank": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmrank.html",
        "signatures": [
            {
                "full": "tmrank(T, X, ascending, window, [ignoreNA=true], [tiesMethod='min'], [percent=false])",
                "name": "tmrank",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "ascending",
                        "name": "ascending"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[ignoreNA=true]",
                        "name": "ignoreNA",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='min']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'min'"
                    },
                    {
                        "full": "[percent=false]",
                        "name": "percent",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [tmrank](https://docs.dolphindb.cn/zh/funcs/t/tmrank.html)\n\n\n\n#### 语法\n\ntmrank(T, X, ascending, window, \\[ignoreNA=true], \\[tiesMethod='min'], \\[percent=false])\n\n部分通用参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 参数\n\n**ascending** 是一个布尔值，表示是否按升序排序。默认值是 true。\n\n**ignoreNA** 是一个布尔值，表示是否忽略 NULL 值。true 表示忽略 NULL 值（默认值），false 表示 NULL 值参与排名，此时 NULL 值为最小值。\n\n**tiesMethod** 是一个字符串，表示窗口内若存在重复值时，排名如何选取。\n\n* 'min'表示取最小排名。\n\n* 'max'表示取最大排名。\n\n* 'average'表示取排名的均值。\n\n**percent** 是一个布尔值，表示是否以百分比形式显示返回的排名，默认值为 false。\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 元素在其对应窗口内的排名。\n\n#### 例子\n\n```\ntmrank(1 1 3 5 8 15 15 20, 5 2 4 1 2 8 9 10, ascending=true, window=3)\n// output\n[0,0,1,0,0,0,1,0]\n\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.14 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\n\ntmrank(index, data, ascending=true, window=4h)\n// output\n[0,,1,2,0,,0,,1,0]\n\ntmrank(index, data, ascending=true, window=2d)\n// output\n[0,,1,2,3,,1,,4,1]\n```\n\n相关函数：[mrank](https://docs.dolphindb.cn/zh/funcs/m/mrank.html), [rank](https://docs.dolphindb.cn/zh/funcs/r/rank.html)\n"
    },
    "tmskew": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmskew.html",
        "signatures": [
            {
                "full": "tmskew(T, X, window, [biased=true])",
                "name": "tmskew",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [tmskew](https://docs.dolphindb.cn/zh/funcs/t/tmskew.html)\n\n\n\n#### 语法\n\ntmskew(T, X, window, \\[biased=true])\n\n部分通用参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否是有偏估计。默认值为 true，表示有偏估计。\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 的斜度。\n\n#### 例子\n\n```\ntmskew(1 1 3 5 8 15 15 20, 5 2 4 1 2 8 9 10, 3)\n// output\n[,0,-0.381801774160607,0,,,0,]\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\ntmskew(index, data, 4h)\n// output\n[,,,-0.3818,,,0,0,0,0.7071]\ntmskew(index, data, 2d)\n// output\n[,,0,-0.3818,-0.4347,-0.4347,-0.37,-0.37,-0.5653,-0.4363]\n```\n\n相关函数：[mskew](https://docs.dolphindb.cn/zh/funcs/m/mskew.html), [skew](https://docs.dolphindb.cn/zh/funcs/s/skew.html)\n"
    },
    "tmskewTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmskewTopN.html",
        "signatures": [
            {
                "full": "tmskewTopN(T, X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
                "name": "tmskewTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[biased=true]",
                        "name": "biased",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmskewTopN](https://docs.dolphindb.cn/zh/funcs/t/tmskewTopN.html)\n\n\n\n#### 语法\n\ntmskewTopN(T, X, S, window, top, \\[biased=true], \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 参数\n\n**biased** 是一个布尔值，表示是否是有偏估计。默认值为 true，表示有偏估计。\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，计算前 *top* 个元素的斜度。\n\n#### 返回值\n\nDOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]  //S 中包含的空值不参与排序，对应位置的 X 不参与计算\ntmskewTopN(T,X,S,6,4)\n// output\n[,0,0.3818,0.3818,-0.2138,-0.4933,-0.8164]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmskewTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n|        |\n|        |\n| 0      |\n| 0      |\n| 0.5280 |\n| 0.7071 |\n\n相关函数：[tmskew](https://docs.dolphindb.cn/zh/funcs/t/tmskew.html)\n"
    },
    "tmstd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmstd.html",
        "signatures": [
            {
                "full": "tmstd(T, X, window)",
                "name": "tmstd",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmstd](https://docs.dolphindb.cn/zh/funcs/t/tmstd.html)\n\n\n\n#### 语法\n\ntmstd(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 的样本标准差。\n\n#### 例子\n\n```\nT = 1 1 3 5 8 15 15 20\nX = 5 2 4 1 2 8 9 10\nm=table(T as t, X as x)\nselect *, tmstd(t, x, 3) from m\n```\n\n| t  | x  | tmstd\\_t |\n| -- | -- | -------- |\n| 1  | 5  |          |\n| 1  | 2  | 2.1213   |\n| 3  | 4  | 1.5275   |\n| 5  | 1  | 2.1213   |\n| 8  | 2  |          |\n| 15 | 8  |          |\n| 15 | 9  | 0.7071   |\n| 20 | 10 |          |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmstd(t, x, 3d) from m\n```\n\n| t          | x  | tmstd\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 |          |\n| 2021.01.07 | 2  | 2.1213   |\n| 2021.01.08 | 4  | 1.4142   |\n\n```\nselect *, tmstd(t, x, 1w) from m\n```\n\n| t          | x  | tmstd\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 | 3.5355   |\n| 2021.01.07 | 2  | 2.5166   |\n| 2021.01.08 | 4  | 2.3629   |\n\n相关函数：[mstd](https://docs.dolphindb.cn/zh/funcs/m/mstd.html), [std](https://docs.dolphindb.cn/zh/funcs/s/std.html)\n"
    },
    "tmstdp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmstdp.html",
        "signatures": [
            {
                "full": "tmstdp(T, X, window)",
                "name": "tmstdp",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmstdp](https://docs.dolphindb.cn/zh/funcs/t/tmstdp.html)\n\n\n\n#### 语法\n\ntmstdp(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 的总体标准差。\n\n#### 例子\n\n```\nT = 1 1 3 5 8 15 15 20\nX = 5 2 4 1 2 8 9 10\nm=table(T as t, X as x)\nselect *, tmstdp(t, x, 3) from m\n```\n\n| t  | x  | tmstdp\\_t |\n| -- | -- | --------- |\n| 1  | 5  | 0         |\n| 1  | 2  | 1.5       |\n| 3  | 4  | 1.2472    |\n| 5  | 1  | 1.5       |\n| 8  | 2  | 0         |\n| 15 | 8  | 0         |\n| 15 | 9  | 0.5       |\n| 20 | 10 | 0         |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmstdp(t, x, 3d) from m\n```\n\n| t          | x  | tmstdp\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 0         |\n| 2021.01.04 |    | 0         |\n| 2021.01.05 | -1 | 0         |\n| 2021.01.07 | 2  | 1.5       |\n| 2021.01.08 | 4  | 1         |\n\n```\nselect *, tmstdp(t, x, 1w) from m\n```\n\n| t          | x  | tmstdp\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 0         |\n| 2021.01.04 |    | 0         |\n| 2021.01.05 | -1 | 2.5       |\n| 2021.01.07 | 2  | 2.0548    |\n| 2021.01.08 | 4  | 2.0463    |\n\n相关函数：[mstdp](https://docs.dolphindb.cn/zh/funcs/m/mstdp.html), [stdp](https://docs.dolphindb.cn/zh/funcs/s/stdp.html)\n"
    },
    "tmstdpTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmstdpTopN.html",
        "signatures": [
            {
                "full": "tmstdpTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmstdpTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmstdpTopN](https://docs.dolphindb.cn/zh/funcs/t/tmstdpTopN.html)\n\n\n\n#### 语法\n\ntmstdpTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，计算前 *top* 个元素的总体标准差。\n\n#### 返回值\n\nDOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]  //S 中包含的空值不参与排序，对应位置的 X 不参与计算\ntmstdpTopN(T,X,S,6,4)\n// output\n[0,0.5,1.2472,1.2472,1.299,0.8291,1.2247]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmstdpTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n| 0      |\n| 0      |\n| 1      |\n| 0.8164 |\n| 1.6996 |\n| 1.4142 |\n\n相关函数：[tmstdp](https://docs.dolphindb.cn/zh/funcs/t/tmstdp.html)\n"
    },
    "tmstdTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmstdTopN.html",
        "signatures": [
            {
                "full": "tmstdTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmstdTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmstdTopN](https://docs.dolphindb.cn/zh/funcs/t/tmstdTopN.html)\n\n\n\n#### 语法\n\ntmstdTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，计算前 *top* 个元素的标准差。\n\n#### 返回值\n\nDOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]  //S 中包含的空值不参与排序，对应位置的 X 不参与计算\ntmstdTopN(T,X,S,6,4)\n// output\n[,0.7071,1.5275,1.5275,1.5,0.9574,1.4142]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmstdTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n|        |\n|        |\n| 1.4142 |\n| 1      |\n| 2.0816 |\n| 1.732  |\n\n相关函数：[tmstd](https://docs.dolphindb.cn/zh/funcs/t/tmstd.html)\n"
    },
    "tmsum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmsum.html",
        "signatures": [
            {
                "full": "tmsum(T, X, window)",
                "name": "tmsum",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmsum](https://docs.dolphindb.cn/zh/funcs/t/tmsum.html)\n\n\n\n#### 语法\n\ntmsum(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 的元素和。\n\n#### 例子\n\n```\ntmsum(1 1 3 5 8 15 15 20, 5 2 4 1 2 8 9 10, 3)\n// output\n[5,7,11,5,2,8,17,10]\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\ntmsum(index, data, 4h)\n// output\n[1,1,4,8,13,13,16,8,8,11]\ntmsum(index, data, 1d)\n// output\n[1,1,4,8,13,13,16,16,21,24]\n```\n\n相关函数：[msum](https://docs.dolphindb.cn/zh/funcs/m/msum.html), [sum](https://docs.dolphindb.cn/zh/funcs/s/sum.html)\n"
    },
    "tmsum2": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmsum2.html",
        "signatures": [
            {
                "full": "tmsum2(T, X, window)",
                "name": "tmsum2",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmsum2](https://docs.dolphindb.cn/zh/funcs/t/tmsum2.html)\n\n\n\n#### 语法\n\ntmsum2(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 元素的平方和。请注意，该函数的返回值是 DOUBLE 类型。\n\n#### 例子\n\n```\ntmsum2(1 1 3 5 8 15 15 20, 5 2 4 1 2 8 9 10, 3)\n// output\n[25,29,45,17,4,64,145,100]\n\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\ntmsum2(index, data, 4h)\n// output\n[1,1,10,26,51,51,60,34,34,43]\n\ntmsum2(index, data, 1d)\n// output\n[1,1,10,26,51,51,60,60,85,94]\n```\n\n相关函数：[msum2](https://docs.dolphindb.cn/zh/funcs/m/msum2.html), [sum2](https://docs.dolphindb.cn/zh/funcs/s/sum2.html)\n"
    },
    "tmsumTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmsumTopN.html",
        "signatures": [
            {
                "full": "tmsumTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmsumTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmsumTopN](https://docs.dolphindb.cn/zh/funcs/t/tmsumTopN.html)\n\n\n\n#### 语法\n\ntmsumTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，取前 *top* 个元素并进行求和计算。\n\n#### 返回值\n\n*X* 为整型，返回 LONG 类型向量，*X* 为浮点数，返回 DOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]  //S 中包含的空值不参与排序，对应位置的 X 不参与计算\ntmsumTopN(T,X,S,6,4)\n// output\n[2,3,7,7,11,13,12]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmsumTopN(time,val,id,4,3) as topN from t\n```\n\n| topN |\n| ---- |\n| 8    |\n| 3    |\n| 4    |\n| 6    |\n| 8    |\n| 9    |\n\n相关函数：[tmsum](https://docs.dolphindb.cn/zh/funcs/t/tmsum.html)\n"
    },
    "tmTopRange": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmtoprange.html",
        "signatures": [
            {
                "full": "tmTopRange(T, X, window)",
                "name": "tmTopRange",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmTopRange](https://docs.dolphindb.cn/zh/funcs/t/tmtoprange.html)\n\n#### 语法\n\ntmTopRange(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，统计每个元素 Xi 左侧相邻且连续小于它的元素个数。NULL 被视为最小值。\n\n#### 例子\n\n```\nt = [0, 1, 2, 3, 7, 8, 9, 10, 11]\nx = [NULL, 3.1, NULL, 3.0, 2.9, 2.8, 3.1, NULL, 3.2];\ntmTopRange(t, x, window=3);\n//output: [,1,0,1,0,0,2,0,2]\n\ntmTopRange(t, x, window=4);\n// output: [,1,0,1,0,0,2,0,3]\n\nindex = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\ndata = 1 NULL 3 4 5 NULL 3 NULL 5 3\ntmTopRange(index, data, 4h)\n// output: [0,0,2,3,4,0,1,0,3,0]\n```\n\n"
    },
    "tmvar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmvar.html",
        "signatures": [
            {
                "full": "tmvar(T, X, window)",
                "name": "tmvar",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmvar](https://docs.dolphindb.cn/zh/funcs/t/tmvar.html)\n\n\n\n#### 语法\n\ntmvar(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 的样本方差。\n\n#### 例子\n\n```\nT = 1 1 3 5 8 15 15 20\nX = 5 2 4 1 2 8 9 10\nm=table(T as t, X as x)\nselect *, tmvar(t, x, 3) from m\n```\n\n| t  | x  | tmvar\\_t |\n| -- | -- | -------- |\n| 1  | 5  |          |\n| 1  | 2  | 4.5      |\n| 3  | 4  | 2.3333   |\n| 5  | 1  | 4.5      |\n| 8  | 2  |          |\n| 15 | 8  |          |\n| 15 | 9  | 0.5      |\n| 20 | 10 |          |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmvar(t, x, 3d) from m\n```\n\n| t          | x  | tmvar\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 |          |\n| 2021.01.07 | 2  | 4.5      |\n| 2021.01.08 | 4  | 2        |\n\n```\nselect *, tmvar(t, x, 1w) from m\n```\n\n| t          | x  | tmvar\\_t |\n| ---------- | -- | -------- |\n| 2021.01.02 |    |          |\n| 2021.01.02 | 4  |          |\n| 2021.01.04 |    |          |\n| 2021.01.05 | -1 | 12.5     |\n| 2021.01.07 | 2  | 6.333    |\n| 2021.01.08 | 4  | 5.5833   |\n\n相关函数：[mvar](https://docs.dolphindb.cn/zh/funcs/m/mvar.html), [var](https://docs.dolphindb.cn/zh/funcs/v/var.html)\n"
    },
    "tmvarp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmvarp.html",
        "signatures": [
            {
                "full": "tmvarp(T, X, window)",
                "name": "tmvarp",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmvarp](https://docs.dolphindb.cn/zh/funcs/t/tmvarp.html)\n\n\n\n#### 语法\n\ntmvarp(T, X, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内计算 *X* 的总体方差。\n\n#### 例子\n\n```\nT = 1 1 3 5 8 15 15 20\nX = 5 2 4 1 2 8 9 10\nm=table(T as t, X as x)\nselect *, tmvarp(t, x, 3) from m\n```\n\n| t  | x  | tmvarp\\_t |\n| -- | -- | --------- |\n| 1  | 5  | 0         |\n| 1  | 2  | 2.25      |\n| 3  | 4  | 1.5556    |\n| 5  | 1  | 2.25      |\n| 8  | 2  | 0         |\n| 15 | 8  | 0         |\n| 15 | 9  | 0.25      |\n| 20 | 10 | 0         |\n\n```\nT = 2021.01.02 2021.01.02  2021.01.04  2021.01.05 2021.01.07 2021.01.08\nX = NULL 4 NULL -1 2 4\nm = table(T as t,X as x)\nselect *, tmvarp(t, x, 3d) from m\n```\n\n| t          | x  | tmvarp\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 0         |\n| 2021.01.04 |    | 0         |\n| 2021.01.05 | -1 | 0         |\n| 2021.01.07 | 2  | 2.25      |\n| 2021.01.08 | 4  | 1         |\n\n```\nselect *, tmvarp(t, x, 1w) from m\n```\n\n| t          | x  | tmvarp\\_t |\n| ---------- | -- | --------- |\n| 2021.01.02 |    |           |\n| 2021.01.02 | 4  | 0         |\n| 2021.01.04 |    | 0         |\n| 2021.01.05 | -1 | 6.25      |\n| 2021.01.07 | 2  | 4.2222    |\n| 2021.01.08 | 4  | 4.1875    |\n\n相关函数：[mvarp](https://docs.dolphindb.cn/zh/funcs/m/mvarp.html), [varp](https://docs.dolphindb.cn/zh/funcs/v/varp.html)\n"
    },
    "tmvarpTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmvarpTopN.html",
        "signatures": [
            {
                "full": "tmvarpTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmvarpTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmvarpTopN](https://docs.dolphindb.cn/zh/funcs/t/tmvarpTopN.html)\n\n\n\n#### 语法\n\ntmvarpTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，计算前 *top* 个元素的总体方差。\n\n#### 返回值\n\nDOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]  //S 中包含的空值不参与排序，对应位置的 X 不参与计算\ntmvarpTopN(T,X,S,6,4)\n// output\n[0,0.25,1.5555,1.5555,1.6875,0.6875,1.5]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmvarpTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n| 0      |\n| 0      |\n| 1      |\n| 0.6666 |\n| 2.8888 |\n| 2      |\n\n相关函数：[tmvarp](https://docs.dolphindb.cn/zh/funcs/t/tmvarp.html)\n"
    },
    "tmvarTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmvarTopN.html",
        "signatures": [
            {
                "full": "tmvarTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmvarTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmvarTopN](https://docs.dolphindb.cn/zh/funcs/t/tmvarTopN.html)\n\n\n\n#### 语法\n\ntmvarTopN(T, X, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 按照 *S* 进行稳定排序后，计算前 *top* 个元素的方差。\n\n#### 返回值\n\nDOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nS = [5, 8, 1, , 1, 1, 3]  //S 中包含的空值不参与排序，对应位置的 X 不参与计算\ntmvarTopN(T,X,S,6,4)\n// output\n[,0.5,2.3333,2.3333,2.25,0.9166,2]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nS=1 5 2 3 1 1\nt=table(T as time, X as val, S as id)\nselect tmvarTopN(time,val,id,4,3) as topN from t\n```\n\n| topN   |\n| ------ |\n|        |\n|        |\n| 2      |\n| 1      |\n| 4.3333 |\n| 3      |\n\n相关函数：[tmvar](https://docs.dolphindb.cn/zh/funcs/t/tmvar.html)\n"
    },
    "tmwavg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmwavg.html",
        "signatures": [
            {
                "full": "tmwavg(T, X, Y, window)",
                "name": "tmwavg",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmwavg](https://docs.dolphindb.cn/zh/funcs/t/tmwavg.html)\n\n\n\n#### 语法\n\ntmwavg(T, X, Y, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间长度衡量）的滑动窗口内，以 *Y* 为权重（权重会自动缩放，使其元素之和为1），计算 *X* 元素的加权平均。\n\n#### 例子\n\n```\nT= 1 1 1 1 2 5 6 8 9 10\nX = 1..10\nY = double(1..10)\\10\nm = table(T as t,X as x, Y as y)\nselect *, tmwavg(t, x, y, 3) from m\n```\n\n| t  | x  | y   | tmwavg\\_t |\n| -- | -- | --- | --------- |\n| 1  | 1  | 0.1 | 1         |\n| 1  | 2  | 0.2 | 1.6667    |\n| 1  | 3  | 0.3 | 2.3333    |\n| 1  | 4  | 0.4 | 3         |\n| 2  | 5  | 0.5 | 3.6667    |\n| 5  | 6  | 0.6 | 6         |\n| 6  | 7  | 0.7 | 6.5385    |\n| 8  | 8  | 0.8 | 7.5333    |\n| 9  | 9  | 0.9 | 8.5294    |\n| 10 | 10 | 1   | 9.0741    |\n\n```\nT = 2021.01.02 2021.01.06 join 2021.01.07..2021.01.14\nX = 1..10\nY = double(1..10)\\10\nm=table(T as t,X as x, Y as y)\nselect *, tmwavg(t, y, x, 3) from m\n```\n\n| t          | x  | y   | tmwavg\\_t |\n| ---------- | -- | --- | --------- |\n| 2021.01.02 | 1  | 0.1 | 0.1       |\n| 2021.01.06 | 2  | 0.2 | 0.2       |\n| 2021.01.07 | 3  | 0.3 | 0.26      |\n| 2021.01.08 | 4  | 0.4 | 0.3222    |\n| 2021.01.09 | 5  | 0.5 | 0.4167    |\n| 2021.01.10 | 6  | 0.6 | 0.5133    |\n| 2021.01.11 | 7  | 0.7 | 0.6111    |\n| 2021.01.12 | 8  | 0.8 | 0.7095    |\n| 2021.01.13 | 9  | 0.9 | 0.8083    |\n| 2021.01.14 | 10 | 1   | 0.9074    |\n\n```\nselect *, tmwavg(t, y, x, 1w) from m\n```\n\n| t          | x  | y   | tmwavg\\_t |\n| ---------- | -- | --- | --------- |\n| 2021.01.02 | 1  | 0.1 | 0.1       |\n| 2021.01.06 | 2  | 0.2 | 0.1667    |\n| 2021.01.07 | 3  | 0.3 | 0.2333    |\n| 2021.01.08 | 4  | 0.4 | 0.3       |\n| 2021.01.09 | 5  | 0.5 | 0.3857    |\n| 2021.01.10 | 6  | 0.6 | 0.45      |\n| 2021.01.11 | 7  | 0.7 | 0.5148    |\n| 2021.01.12 | 8  | 0.8 | 0.58      |\n| 2021.01.13 | 9  | 0.9 | 0.6667    |\n| 2021.01.14 | 10 | 1   | 0.7571    |\n\n相关函数：[wavg](https://docs.dolphindb.cn/zh/funcs/w/wavg.html), [mwavg](https://docs.dolphindb.cn/zh/funcs/m/mwavg.html)\n"
    },
    "tmwsum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmwsum.html",
        "signatures": [
            {
                "full": "tmwsum(T, X, Y, window)",
                "name": "tmwsum",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [tmwsum](https://docs.dolphindb.cn/zh/funcs/t/tmwsum.html)\n\n\n\n#### 语法\n\ntmwsum(T, X, Y, window)\n\n参数说明和窗口计算规则请参考：[tmFunctions](https://docs.dolphindb.cn/zh/funcs/themes/tmFunctions.html)\n\n#### 详情\n\n在给定长度（以时间长度衡量）的滑动窗口内，计算 *X* 和 *Y* 元素的内积。\n\n#### 例子\n\n```\nT = 1 1 1 1 2 5 6 8 9 10\nX = 1..10\nY = double(1..10)\\10\nm = table(T as t,X as x, Y as y)\nselect *, tmwsum(t, y, x, 3) from m\n```\n\n| t  | x  | y   | tmwsum\\_t |\n| -- | -- | --- | --------- |\n| 1  | 1  | 0.1 | 0.1       |\n| 1  | 2  | 0.2 | 0.5       |\n| 1  | 3  | 0.3 | 1.4       |\n| 1  | 4  | 0.4 | 3         |\n| 2  | 5  | 0.5 | 5.5       |\n| 5  | 6  | 0.6 | 3.6       |\n| 6  | 7  | 0.7 | 8.5       |\n| 8  | 8  | 0.8 | 11.3      |\n| 9  | 9  | 0.9 | 14.5      |\n| 10 | 10 | 1   | 24.5      |\n\n```\nT = 2021.01.02 2021.01.06 join 2021.01.07..2021.01.14\nX = 1..10\nY = double(1..10)\\10\nm=table(T as t,X as x, Y as y)\nselect *, tmwsum(t, y, x, 3) from m\n```\n\n| t          | x  | y   | tmwsum\\_t |\n| ---------- | -- | --- | --------- |\n| 2021.01.02 | 1  | 0.1 | 0.1       |\n| 2021.01.06 | 2  | 0.2 | 0.4       |\n| 2021.01.07 | 3  | 0.3 | 1.3       |\n| 2021.01.08 | 4  | 0.4 | 2.9       |\n| 2021.01.09 | 5  | 0.5 | 5         |\n| 2021.01.10 | 6  | 0.6 | 7.7       |\n| 2021.01.11 | 7  | 0.7 | 11        |\n| 2021.01.12 | 8  | 0.8 | 14.9      |\n| 2021.01.13 | 9  | 0.9 | 19.4      |\n| 2021.01.14 | 10 | 1   | 24.5      |\n\n```\nselect *, tmwsum(t, y, x, 1w) from m\n```\n\n| t          | x  | y   | tmwsum\\_t |\n| ---------- | -- | --- | --------- |\n| 2021.01.02 | 1  | 0.1 | 0.1       |\n| 2021.01.06 | 2  | 0.2 | 0.5       |\n| 2021.01.07 | 3  | 0.3 | 1.4       |\n| 2021.01.08 | 4  | 0.4 | 3         |\n| 2021.01.09 | 5  | 0.5 | 5.4       |\n| 2021.01.10 | 6  | 0.6 | 9         |\n| 2021.01.11 | 7  | 0.7 | 13.9      |\n| 2021.01.12 | 8  | 0.8 | 20.3      |\n| 2021.01.13 | 9  | 0.9 | 28        |\n| 2021.01.14 | 10 | 1   | 37.1      |\n\n相关函数：[wsum](https://docs.dolphindb.cn/zh/funcs/w/wsum.html), [mwsum](https://docs.dolphindb.cn/zh/funcs/m/mwsum.html)\n"
    },
    "tmwsumTopN": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tmwsumTopN.html",
        "signatures": [
            {
                "full": "tmwsumTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
                "name": "tmwsumTopN",
                "parameters": [
                    {
                        "full": "T",
                        "name": "T"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "S",
                        "name": "S"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    },
                    {
                        "full": "top",
                        "name": "top"
                    },
                    {
                        "full": "[ascending=true]",
                        "name": "ascending",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[tiesMethod='latest']",
                        "name": "tiesMethod",
                        "optional": true,
                        "default": "'latest'"
                    }
                ]
            }
        ],
        "markdown": "### [tmwsumTopN](https://docs.dolphindb.cn/zh/funcs/t/tmwsumTopN.html)\n\n\n\n#### 语法\n\ntmwsumTopN(T, X, Y, S, window, top, \\[ascending=true], \\[tiesMethod='latest'])\n\n参数说明和窗口计算规则请参考：[tmTopN](https://docs.dolphindb.cn/zh/funcs/themes/tmTopN.html)\n\n#### 详情\n\n在给定长度（以时间 *T* 衡量）的滑动窗口内，根据 *ascending* 指定的排序方式将 *X* 和 *Y* 按照 *S* 进行稳定排序后，取前 *top* 个元素，计算 *X* 和 *Y* 的内积。\n\n#### 返回值\n\nDOUBLE 类型向量。\n\n#### 例子\n\n```\nT=2023.01.03+1..7\nX = [2, 1, 4, 3, 4, 3, 1]\nY=[1, 7, 8, 9, 0, 5, 8]\nS = [5, 8, 1, , 1, 1, 3]  //S 中包含的空值不参与排序，对应位置的 X 和 Y 不参与计算\ntmwsumTopN(T,X,Y,S,6,4)\n// output\n[2,9,41,41,41,49,55]\n\nT=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\nX=8 3 1 2 5 2\nY=1 7 8 9 0 5\nS=1 5 2 3 1 1\nt=table(T as time, X as val1, Y as val2, S as id)\nselect tmwsumTopN(time,val1,val2,id,4,3) as topN from t\n```\n\n| topN |\n| ---- |\n| 8    |\n| 21   |\n| 29   |\n| 47   |\n| 26   |\n| 28   |\n\n相关函数：[tmwsum](https://docs.dolphindb.cn/zh/funcs/t/tmwsum.html)\n"
    },
    "toCharArray": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/toCharArray.html",
        "signatures": [
            {
                "full": "toCharArray(X)",
                "name": "toCharArray",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [toCharArray](https://docs.dolphindb.cn/zh/funcs/t/toCharArray.html)\n\n\n\n#### 语法\n\ntoCharArray(X)\n\n#### 参数\n\n**X** STRING/BLOB/SYMBOL 类型标量或向量。\n\n#### 详情\n\n将字符串拆分字符向量。\n\n* 若 *X* 是标量，返回一个向量。\n\n* 若 *X* 是向量，返回一个数组向量。\n\n#### 例子\n\n```\nstr = \"It is great!\\n\"\nprint str.toCharArray()\n// output\n['I','t',' ','i','s',' ','g','r','e','a','t','!',10]\n\nstr1 = [\"A#\", \"B C\", \"D\\t\"]\nprint str1.toCharArray()\n// output\n[['A','#'],['B',' ','C'],['D',9]]\n```\n\n将一个包含了 BLOB 类型的数据写入文件，需要使用 `toCharArray` 进行转换，以保证写入的数据正确。\n\n```\n//将一个向量压缩后，存入一个二进制文件\nx=1..100\n//BLOB 类型的字符串开头会使用4个字节来标识它的长度\ny=blob(compress(x).concat())\ndir = WORK_DIR+\"/toCharArray.bin\"\ng = file(dir, \"w\")\n//使用 toCharArray 函数对 BLOB 类型的字符串进行转换，则只会将正确的数据写入文件（头部的4个字节不会写入）\ng.write(y.toCharArray())   //实际写入了467个字节\ng.close()\n\n// output\ndir1 = WORK_DIR+\"/toCharArray1.bin\"\ng1 = file(dir1, \"w\")\ng1.write(y)    //实际写入了471个字节\ng1.close()\n```\n\n相关函数：[split](https://docs.dolphindb.cn/zh/funcs/s/split.html)\n"
    },
    "today": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/today.html",
        "signatures": [
            {
                "full": "today()",
                "name": "today",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [today](https://docs.dolphindb.cn/zh/funcs/t/today.html)\n\n\n\n#### 语法\n\ntoday()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回当前系统的日期。\n"
    },
    "toJson": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/toJson.html",
        "signatures": [
            {
                "full": "toJson(X)",
                "name": "toJson",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [toJson](https://docs.dolphindb.cn/zh/funcs/t/toJson.html)\n\n\n\n#### 语法\n\ntoJson(X)\n\n#### 参数\n\n**X** 可以是任意数据类型。\n\n#### 详情\n\n将 DolphinDB 对象转换为 JSON 字符串。该 JSON 字符串包含了5个键值对：name（变量名），form（数据结构），type（数据类型），size（长度），value（值）。\n\n针对不同数据形式，`toJson` 最大可转换的数据长度不同：\n\n| 数据形式     | 最大长度   |\n| -------- | ------ |\n| matrix   | 300000 |\n| set      | 300000 |\n| vector   | 300000 |\n| dict 键值对 | 300000 |\n| table    | 100000 |\n\n#### 例子\n\n```\nx=1 2 3\ny=toJson(x)\ny;\n// output\n{\"name\":\"x\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[1,2,3]}\n\nt=table(1 2 3 as id, 10 20 30 as val)\ntoJson(t);\n// output\n{\"name\":\"t\",\"form\":\"table\",\"size\":\"3\",\"value\":[{\"name\":\"id\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[1,2,3]},{\"name\":\"val\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[10,20,30]}]}\n\n//set的长度超过30000，toJson最多只能转换前30000个元素\nx=set(1..400001)\ny=toJson(x)\nsize(fromJson(y))\n// output\n300000\n```\n\n相关函数：[fromJson](https://docs.dolphindb.cn/zh/funcs/f/fromJson.html)\n"
    },
    "tokenize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tokenize.html",
        "signatures": [
            {
                "full": "tokenize(text, parser, [full=false], [lowercase=true], [stem=false])",
                "name": "tokenize",
                "parameters": [
                    {
                        "full": "text",
                        "name": "text"
                    },
                    {
                        "full": "parser",
                        "name": "parser"
                    },
                    {
                        "full": "[full=false]",
                        "name": "full",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[lowercase=true]",
                        "name": "lowercase",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[stem=false]",
                        "name": "stem",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [tokenize](https://docs.dolphindb.cn/zh/funcs/t/tokenize.html)\n\n\n\n#### 语法\n\ntokenize(text, parser, \\[full=false], \\[lowercase=true], \\[stem=false])\n\n#### 参数\n\n**text** STRING 类型标量，表示待分词的文本。\n\n**parser** STRING 类型标量，指定分词器。没有默认值，必须显式指定。可选值为 'none', 'english', 'chinese', 'mixed'：\n\n* none：不分词。\n\n* english：英文分词器，按照空格和标点进行分词。\n\n* chinese：中文分词器，按照中文词库、空格和标点进行分词。\n\n* mixed：混合分词器。英文按单词分词，中文按 Bigram 分词。\n\n**full** 设置中文分词时的分词模式，仅在 parser='chinese' 时有效：\n\n* false：默认模式。词语之间不会重叠和包含。\n\n* true：全分词模式。该模式会尽可能多的分析句子中包含的词语。\n\n**lowercase** 布尔类型标量，表示是否将英文单词转换为小写（不会对原数据造成影响）。该属性在 *parser* 为 english, chinese, mixed 时有效。默认值为 true。\n\n**stem** 是否将英文单词作为词干匹配。该属性仅在 parser='english'，且 lowercase=true 时生效。默认值为 false。\n\n#### 详情\n\n此函数可用于检查分词操作的实际效果。\n\n根据指定的设置对输入文本进行分词操作，并返回一个 STRING 类型的向量，包含分词的结果。\n\n#### 例子\n\n```\ntext1 = \"The sun was shining brightly as I walked down the street, enjoying the warmth of the summer day.\"\ntokenize(text=text1, parser='english', lowercase=false, stem=true)\n// output:[\"The\",\"sun\",\"shine\",\"bright\",\"I\",\"walk\",\"down\",\"street\",\"enjoy\",\"warmth\",\"summer\",\"day\"]\n\ntext2 = \"武汉市长江大桥\"\ntokenize(text=text2, parser='chinese', full=true)\n// output:[\"武汉\",\"武汉市\",\"市长\",\"长江\",\"长江大桥\",\"大桥\"]\n```\n"
    },
    "topRange": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/topRange.html",
        "signatures": [
            {
                "full": "topRange(X)",
                "name": "topRange",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [topRange](https://docs.dolphindb.cn/zh/funcs/t/topRange.html)\n\n\n\n#### 语法\n\ntopRange(X)\n\n#### 参数\n\n**X** 向量/元组/矩阵/表。\n\n#### 详情\n\n对于 *X* 中的每个元素 *Xi*，统计 *Xi* 左侧相邻且连续小于它的元素个数。\n\n该函数常用于统计一个序列的当前值是前多少周期（日或分钟等）内的最大值。例如某只股票创几日新高等。\n\n#### 例子\n\n```\ntopRange([13.5, 13.6, 13.4, 13.3, 13.5, 13.9, 13.1, 20.1, 20.2, 20.3])\n// output\n[0,1,0,0,2,5,0,7,8,9]\n\nm = matrix(1.5 2.6 3.2 1.4 2.5 2.2 3.7 2.0, 1.6 2.3 4.2 5.6 4.1 3.2 4.4 6.9)\ntopRange(m)\n```\n\n| #0 | #1 |\n| -- | -- |\n| 0  | 0  |\n| 1  | 1  |\n| 2  | 2  |\n| 0  | 3  |\n| 1  | 0  |\n| 0  | 0  |\n| 6  | 2  |\n| 0  | 7  |\n\n```\n//模拟股票 A 8天的股价，使用 topRange 计算股票 A 当日股价创几日新高\ntrades = table(take(`A, 8) as sym,  2022.01.01 + 1..8 as date, 39.70 39.72 39.80 39.78 39.83 39.92 40.00 40.03 as price)\nselect *, topRange(price) from trades\n```\n\n| id | date       | price | topRange\\_price |\n| -- | ---------- | ----- | --------------- |\n| A  | 2022.01.02 | 39.7  | 0               |\n| A  | 2022.01.03 | 39.72 | 1               |\n| A  | 2022.01.04 | 39.8  | 2               |\n| A  | 2022.01.05 | 39.78 | 0               |\n| A  | 2022.01.06 | 39.83 | 4               |\n| A  | 2022.01.07 | 39.92 | 5               |\n| A  | 2022.01.08 | 40    | 6               |\n| A  | 2022.01.09 | 40.03 | 7               |\n\n相关函数：[lowRange](https://docs.dolphindb.cn/zh/funcs/l/lowRange.html)\n"
    },
    "toStdJson": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/toStdJson.html",
        "signatures": [
            {
                "full": "toStdJson(obj)",
                "name": "toStdJson",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    }
                ]
            }
        ],
        "markdown": "### [toStdJson](https://docs.dolphindb.cn/zh/funcs/t/toStdJson.html)\n\n#### 语法\n\ntoStdJson(obj)\n\n#### 参数\n\n**obj** 的数据形式不可为 matrix 或 pair；数据类型不可为 UUID, IPADDR, INT128, COMPRESSED 以及系统类型。\n\n#### 详情\n\n将 DolphinDB 对象转换为标准 JSON 类型。\n\n* 转化 bool 值时，返回 true 或 false 值。\n* 转换空值时，将除了 STRING 类型空值以外的其他所有类型空值都转换为null。\n\n#### 例子\n\n```\nx=1 2 3\ntoStdJson(x);\n// output: \n[1, 2, 3]\n\nt=table(1 2 3 as id, 10 20 30 as val)\ntoStdJson(t);\n// output: \n[{\"id\": 1,\"val\": 10},{\"id\": 2,\"val\": 20},{\"id\": 3,\"val\": 30}]\n\nb = set(2012.06.13T13:30:10 2017.07.10T14:10:12)\ntoStdJson(b);\n// output: \n[\"2017.07.10 14:10:12\",\"2012.06.13 13:30:10\"]\n\nb = dict(INT,DATETIME)\nb[0] = 2012.06.13 13:30:10\nb[1] = 2017.07.10 14:10:12\ntoStdJson(b);\n// output:\n{\"1\": \"2017.07.10 14:10:12\",\"0\": \"2012.06.13 13:30:10\"}\n\nt1=table(`x`y`z as b, 2012.06.13 13:30:10 2012.06.13 13:30:10 2012.06.13 13:30:10 as c,10.8 7.6 3.5 as F)\ntoStdJson(t1);\n// output:\n[{\"b\": \"x\",\"c\": \"2012.06.13 13:30:10\",\"F\": 10.8},{\"b\": \"y\",\"c\": \"2012.06.13 13:30:10\",\"F\": 7.6},{\"b\": \"z\",\"c\": \"2012.06.13 13:30:10\",\"F\": 3.5}]\n```\n\n相关函数：[toJson](https://docs.dolphindb.cn/zh/funcs/t/toJson.html)\n\n"
    },
    "toUTF8": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/toUTF8.html",
        "signatures": [
            {
                "full": "toUTF8(str, encode)",
                "name": "toUTF8",
                "parameters": [
                    {
                        "full": "str",
                        "name": "str"
                    },
                    {
                        "full": "encode",
                        "name": "encode"
                    }
                ]
            }
        ],
        "markdown": "### [toUTF8](https://docs.dolphindb.cn/zh/funcs/t/toUTF8.html)\n\n\n\n#### 语法\n\ntoUTF8(str, encode)\n\n#### 参数\n\n**str** 是一个字符串标量或向量。\n\n**encode** 是一个字符串，表示 *str* 原来的编码名称。\n\n#### 详情\n\n把字符串转换为 UTF8 编码。DolphinDB 对编码名称的大小写敏感，所有编码名称必须用小写表示。\n\n因为 Windows 版本目前仅支持 gbk 和 utf-8 两种编码的相互转换，因此在 Windows 中，`toUTF8` 的第二个参数只能是 \"gbk\"。Linux 版本支持任意两种编码之间的转换。\n\n#### 例子\n\n```\ntoUTF8(\"DolphinDB\",\"gbk\");\n// output\nDolphinDB\n\ntoUTF8([\"hello\",\"world\"],\"euc-cn\");\n// output\n[\"hello\",\"world\"]\n```\n\n相关函数：[convertEncode](https://docs.dolphindb.cn/zh/funcs/c/convertEncode.html), [fromUTF8](https://docs.dolphindb.cn/zh/funcs/f/fromUTF8.html)\n"
    },
    "transDS!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/transDS_.html",
        "signatures": [
            {
                "full": "transDS!(ds, tranFunc)",
                "name": "transDS!",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "tranFunc",
                        "name": "tranFunc"
                    }
                ]
            }
        ],
        "markdown": "### [transDS!](https://docs.dolphindb.cn/zh/funcs/t/transDS_.html)\n\n\n\n#### 语法\n\ntransDS!(ds, tranFunc)\n\n#### 参数\n\n**ds** 是数据源或数据源列表。\n\n**tranFunc** 是一个函数。它的参数必须是一个表。\n\n#### 详情\n\n将函数应用到数据源。\n\n#### 例子\n\n下例将分布式表 trades1 的时间列从 TIMESTAMP 类型转换成 NANOTIMESTAMP 类型后插入到分布式表 trades2中。\n\n```\ndb=database(\"dfs://stock1\",VALUE,`A`B`C`D)\nn=200000\ntrade_time=2018.01.02T06:12:03.458+1..n\nsym=rand(`A`B`C`D,n)\nqty=rand(100.0,n)\nprice=rand(100.0,n)\nt=table(trade_time,sym,qty,price)\ntrades1=db.createPartitionedTable(t,`trades1,`sym).append!(t);\n\nds=sqlDS(<select * from trades1>);\n\ndef convertNanotimestamp(t){\n   return select nanotimestamp(trade_time), sym, qty, price from t\n}\n\nds.transDS!(convertNanotimestamp);\n\ndb=database(\"dfs://stock2\",VALUE,`A`B`C`D)\nt=table(1:0,`trade_time`sym`qty`price,[NANOTIMESTAMP,SYMBOL,DOUBLE,DOUBLE])\ntrades2=db.createPartitionedTable(t,`trades2,`sym);\n\nmr(ds,append!{trades2},,,false);\n\nexec count(*) from trades2;\n// output\n200000\n```\n"
    },
    "transFreq": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/transFreq.html",
        "signatures": [
            {
                "full": "transFreq(X, rule, [closed], [label], [origin='start_day'])",
                "name": "transFreq",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "rule",
                        "name": "rule"
                    },
                    {
                        "full": "[closed]",
                        "name": "closed",
                        "optional": true
                    },
                    {
                        "full": "[label]",
                        "name": "label",
                        "optional": true
                    },
                    {
                        "full": "[origin='start_day']",
                        "name": "origin",
                        "optional": true,
                        "default": "'start_day'"
                    }
                ]
            }
        ],
        "markdown": "### [transFreq](https://docs.dolphindb.cn/zh/funcs/t/transFreq.html)\n\n\n\n#### 语法\n\ntransFreq(X, rule, \\[closed], \\[label], \\[origin='start\\_day'])\n\n#### 详情\n\n将给定日期或时间变量转换为给定的时间格式（或对应的交易日）。结果长度与 *X* 相同。\n\n#### 参数\n\n**X** 是表示日期或时间类型的标量或向量。\n\n**rule** 是一个字符串，可取以下值：\n\n| rule 参数取值 | 对应 DolphinDB 函数      |\n| --------- | -------------------- |\n| \"B\"       | businessDay          |\n| \"W\"       | weekEnd              |\n| \"WOM\"     | weekOfMonth          |\n| \"LWOM\"    | lastWeekOfMonth      |\n| \"M\"       | monthEnd             |\n| \"MS\"      | monthBegin           |\n| \"BM\"      | businessMonthEnd     |\n| \"BMS\"     | businessMonthBegin   |\n| \"SM\"      | semiMonthEnd         |\n| \"SMS\"     | semiMonthBegin       |\n| \"Q\"       | quarterEnd           |\n| \"QS\"      | quarterBegin         |\n| \"BQ\"      | businessQuarterEnd   |\n| \"BQS\"     | businessQuarterBegin |\n| \"A\"       | yearEnd              |\n| \"AS\"      | yearBegin            |\n| \"BA\"      | businessYearEnd      |\n| \"BAS\"     | businessYearBegin    |\n| \"D\"       | date                 |\n| \"H\"       | hourOfDay            |\n| \"min\"     | minuteOfHour         |\n| \"S\"       | secondOfMinute       |\n| \"L\"       | millisecond          |\n| \"U\"       | microsecond          |\n| \"N\"       | nanosecond           |\n\n上述字符串亦可配合使用数字（必须为正整数），例如 \"2M\" 表示频率为每两个月月末。此外，*rule* 也可以是交易日历标识（国外交易所的 ISO Code、国内交易所简称或自定义交易日历名称），以便基于交易日历进行计算。交易日历也可以配合使用数字，表示多个交易日，此时只能指定由4个大写字母组成的交易日历标识。例如：“2XSHG”，表示上海证券交易所每两个交易日。\n\n**closed** 字符串，表示分组区间哪一个边界是闭合的。\n\n* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，*closed* 的默认取值为 'right' ，否则，*closed* 的默认取值为 'left'。\n\n* *origin* 取 'end' 或者 'end\\_day' 时，*closed* 的默认值为 'right'。\n\n**label** 字符串，表示将分组区间的哪一个边界作为 *label* 输出。\n\n* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，*label* 的默认取值为 'right' ，否则，*label* 的默认取值为 'left'。\n\n* *origin* 取 'end' 或者 'end\\_day' 时，*label* 的默认值为 'right'。\n\n**origin** 字符串或和 *X* 具有相同时间类型的标量，表示基于时间戳调整分组。取值为 'epoch', start', 'start\\_day', 'end', 'end\\_day' 或自定义的时间对象，默认值为 'start\\_day'。\n\n* 'epoch'：分组起始点为1970-01-01。\n\n* 'start'：分组起始点为时间序列的第一个值。\n\n* 'start\\_day'：分组起始点是时间序列的第一个值对应日期的午夜零点。\n\n* 'end'：分组起始点是时间序列的最后一个时间戳。\n\n* 'end\\_day'：分组起始点是时间序列的最后一个时间戳对应日期的午夜24点（即下一日的零点）。\n\n#### 例子\n\n```\ntransFreq(2020.11.08 2020.11.09 2020.11.18, \"SM\");\n// output\n[2020.10.31,2020.10.31,2020.11.15]\n\ntransFreq(2020.08.08 2020.11.18, \"Q\");\n// output\n[2020.09.30,2020.12.31]\n\ntransFreq(2020.08.08 2020.11.18, \"2Q\");\n// output\n[2020.09.30,2021.03.31]\n```\n\n```\ns = temporalAdd(2022.01.01 00:00:00,1..8,`m);\n\ns.transFreq(rule=\"3min\");\n// output\n[2022.01.01T00:00:00,2022.01.01T00:00:00,2022.01.01T00:03:00,2022.01.01T00:03:00,2022.01.01T00:03:00,2022.01.01T00:06:00,2022.01.01T00:06:00,2022.01.01T00:06:00]\n\ns.transFreq(rule=`3min,closed=`right);\n// output\n[2022.01.01T00:00:00,2022.01.01T00:00:00,2022.01.01T00:00:00,2022.01.01T00:03:00,2022.01.01T00:03:00,2022.01.01T00:03:00,2022.01.01T00:06:00,2022.01.01T00:06:00]\n\ns.transFreq(rule=`3min,closed=`right,origin=`end);\n// output\n[2021.12.31T23:59:00,2021.12.31T23:59:00,2022.01.01T00:02:00,2022.01.01T00:02:00,2022.01.01T00:02:00,2022.01.01T00:05:00,2022.01.01T00:05:00,2022.01.01T00:05:00]\n```\n"
    },
    "transpose": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/transpose.html",
        "signatures": [
            {
                "full": "transpose(X)",
                "name": "transpose",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            },
            {
                "full": "flip(X)",
                "name": "flip",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [transpose](https://docs.dolphindb.cn/zh/funcs/t/transpose.html)\n\n\n\n#### 语法\n\ntranspose(X)\n\n别名：flip(X)\n\n#### 参数\n\n**X** 是一个元组、矩阵、表或字典、数组向量或列式元组。如果 *X* 是数组向量或列式元组，则每行包含的元素个数必须相等。\n\n#### 详情\n\n* 如果 *X* 是一个元组，每个向量的长度必须相同，`transpose` 函数返回的是一个与 *X* 中每个向量长度相同的元组，返回结果中的第 n 个元素是由 *X* 中每个向量的第 n 个值组成的向量。\n\n* 如果 *X* 是一个矩阵，`transpose` 函数返回 *X* 的转置矩阵。\n\n* 如果 *X* 是一个表，`transpose` 函数把表 *X* 转换为一个有序字典（从 2.00.9 版本开始支持有序字典），表中的列名为 key，每列的值为 value。\n\n* 如果 *X* 是一个字典，它的 key 必须是 STRING 类型，`transpose` 函数把字典 *X* 转换为一个表，key 为列名，每个 key 对应的 value 可以是标量或等长的向量，表示每列的值。\n\n* 如果 *X* 是一个数组向量或列式元组，transpose 函数将 *X* 的行和列转置。\n\n#### 例子\n\n例1. *X* 是一个元组。\n\n```\nx=(`A`B`C,1 2 3);\nx.transpose();\n// output：((\"A\",1),(\"B\",2),(\"C\",3))\n```\n\n例2. *X* 是一个矩阵。\n\n```\nx=1..6 $ 3:2;\nx;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\ntranspose x;\n```\n\n| #0 | #1 | #2 |\n| -- | -- | -- |\n| 1  | 2  | 3  |\n| 4  | 5  | 6  |\n\n例3. *X* 是一个表。\n\n```\ntimestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym = `C`MS`MS`MS`IBM`IBM`C`C`C\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\nt = table(timestamp, sym, qty, price);\nt;\n```\n\n| timestamp | sym | qty  | price  |\n| --------- | --- | ---- | ------ |\n| 09:34:07  | C   | 2200 | 49.6   |\n| 09:36:42  | MS  | 1900 | 29.46  |\n| 09:36:51  | MS  | 2100 | 29.52  |\n| 09:36:59  | MS  | 3200 | 30.02  |\n| 09:32:47  | IBM | 6800 | 174.97 |\n| 09:35:26  | IBM | 5400 | 175.23 |\n| 09:34:16  | C   | 1300 | 50.76  |\n| 09:34:26  | C   | 2500 | 50.32  |\n| 09:38:12  | C   | 8800 | 51.29  |\n\n```\ntranspose(t);\n/*\ntimestamp->[09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\nsym->[C,MS,MS,MS,IBM,IBM,C,C,C]\nqty->[2200,1900,2100,3200,6800,5400,1300,2500,8800]\nprice->[49.6,29.46,29.52,30.02,174.97,175.23,50.76,50.32,51.29]\n*/\n```\n\n例4. *X* 是一个字典。\n\n```\nz=dict(`id`val,[`a`b`c,1 2 3]);\nz;\n/*\nval->[1,2,3]\nid->[a,b,c]\n*/\ntranspose(z);\n```\n\n| val | id |\n| --- | -- |\n| 1   | a  |\n| 2   | b  |\n| 3   | c  |\n\n```\n//当字典的 value 既包含标量又包含向量时，transpose 会重复标量的值以匹配向量的长度\nz1=dict(`id`val,[`a,1 2 3]);\nz1;\ntranspose(z1)\n```\n\n<table id=\"table_fx3_3x5_x1c\"><tbody><tr><td>\n\n**val**\n\n</td><td>\n\n**id**\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\na\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\na\n\n</td></tr><tr><td>\n\n3\n\n</td><td>\n\na\n\n</td></tr></tbody>\n</table>\n"
    },
    "treasuryConversionFactor": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/treasuryconversionfactor.html",
        "signatures": [
            {
                "full": "treasuryConversionFactor(contractCoupon, deliverableCoupon, monthsToNextCoupon, remainingPayments, frequency)",
                "name": "treasuryConversionFactor",
                "parameters": [
                    {
                        "full": "contractCoupon",
                        "name": "contractCoupon"
                    },
                    {
                        "full": "deliverableCoupon",
                        "name": "deliverableCoupon"
                    },
                    {
                        "full": "monthsToNextCoupon",
                        "name": "monthsToNextCoupon"
                    },
                    {
                        "full": "remainingPayments",
                        "name": "remainingPayments"
                    },
                    {
                        "full": "frequency",
                        "name": "frequency"
                    }
                ]
            }
        ],
        "markdown": "### [treasuryConversionFactor](https://docs.dolphindb.cn/zh/funcs/t/treasuryconversionfactor.html)\n\n\n\n#### 语法\n\ntreasuryConversionFactor(contractCoupon, deliverableCoupon, monthsToNextCoupon, remainingPayments, frequency)\n\n#### 详情\n\n本函数基于[中金所国债转换因子和应计利息计算公式](http://www.cffex.com.cn/5tf/)对转换因子进行估值计算。成功执行后将返回转换因子的估值，是一个 DOUBLE 类型的标量或向量。\n\n#### 参数\n\n**contractCoupon** 数值型类型标量或向量，非负数，表示国债合约票面利率。\n\n**deliverableCoupon** 数值型标量或向量，非负数，表示可交割国债的票面利率。\n\n**monthsToNextCoupon** 整数类型标量或向量，非负数，表示交割月到下一付息月的月份数。\n\n**remainingPayments** 整数类型标量或向量，非负数，表示剩余付息次数。\n\n**frequency** 表示可交割国债每年的付息频率，支持两种输入类型：\n\n* INT 类型标量或向量，正数，表示可交割国债每年的付息次数。例如，*frequency* = 1 表示每年付息 1 次，即按年支付；*frequency* = 2 表示每年付息 2 次，即按半年期支付。\n\n* DURATION 标量或向量：表示可交割国债每隔多久进行一次付息。例如，*frequency* = duration(\\`3M)，表示每隔 3 个月付息一次，即按季度支付。\n\n<table id=\"table_x5h_gyw_bdc\"><thead><tr><th align=\"left\">\n\n可选值\n\n</th><th align=\"left\">\n\n含义\n\n</th></tr></thead><tbody><tr><td>\n\n1 / 1y\n\n</td><td>\n\n表示每年付息1次\n\n</td></tr><tr><td>\n\n2 / 6M\n\n</td><td>\n\n表示每年付息2次 / 每6个月付息1次\n\n</td></tr><tr><td>\n\n3 / 4M\n\n</td><td>\n\n表示每年付息3次 / 每4个月付息1次\n\n</td></tr><tr><td>\n\n4 / 3M\n\n</td><td>\n\n表示每年付息4次 / 每3个月付息1次\n\n</td></tr><tr><td>\n\n6 / 2M\n\n</td><td>\n\n表示每年付息6次 / 每2个月付息1次\n\n</td></tr><tr><td>\n\n12 / 1M\n\n</td><td>\n\n表示每年付息12次 / 每月付息1次\n\n</td></tr><tr><td>\n\n13 / 4w\n\n</td><td>\n\n表示每年付息13次 / 每4周付息1次\n\n</td></tr><tr><td>\n\n26 / 2w\n\n</td><td>\n\n表示每年付息26次 / 每2周付息1次\n\n</td></tr><tr><td>\n\n52 / 1w\n\n</td><td>\n\n表示每年付息52次 / 每周付息1次\n\n</td></tr><tr><td>\n\n365 / 1d\n\n</td><td>\n\n表示每年付息365次 / 每天付息1次\n\n</td></tr></tbody>\n</table>注意：在调用此函数时，必须保证所有提供的向量参数长度相同。若参数向量长度不一致，函数将会报错。\n\n#### 例子\n\n假设 5 年期国债合约票面利率为 3%，交割月到下一付息月的月份数为 2，剩余付息次数为 1，可交割国债的票面利率为 3.2%，付息频率为 4，该种情况下对转换因子进行估值计算。\n\n```\ntreasuryConversionFactor(contractCoupon=0.03, deliverableCoupon=0.032, monthsToNextCoupon=2, remainingPayments=1, frequency=4)\n// Output：1.000324624767048\n```\n"
    },
    "triggerCheckpointForIMOLTP": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/triggercheckpointforimoltp.html",
        "signatures": [
            {
                "full": "triggerCheckpointForIMOLTP([force=false], [sync=false])",
                "name": "triggerCheckpointForIMOLTP",
                "parameters": [
                    {
                        "full": "[force=false]",
                        "name": "force",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[sync=false]",
                        "name": "sync",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [triggerCheckpointForIMOLTP](https://docs.dolphindb.cn/zh/funcs/t/triggercheckpointforimoltp.html)\n\n#### 语法\n\ntriggerCheckpointForIMOLTP(\\[force=false], \\[sync=false])\n\n#### 详情\n\n用于手动向处于正常运行状态的 OLTP 发出创建检查点（checkpoint）的请求。\n\n#### 参数\n\n* **force**：布尔类型的可选参数，默认为 false。用于设定是否强制执行 checkpoint。设定为 true 后，OLTP 将在接收到该函数发出的指令后强制执行 checkpoint。\n\n* **sync**：布尔类型的可选参数，默认为 false。用于设定是否异步执行强制的 checkpoint。\n\n  * 设置为 false 时，该函数请求一次异步的 checkpoint，并不会等到请求完成再返回执行结果；\n\n  * 设置为 true时，该函数会等到请求受理后再返回执行结果。注意：此时的执行结果并不一定意味着 checkpoint 文件的创建完成。\n\n**Note:** 该函数的两个可选参数均设定为 true 后，手动创建 checkpoint 文件成功的前提是配置项 *enableIMOLTPEngine* 和 *enableIMOLTPCheckpoint* 均已启用且 OLTP 处于正常运行状态。\n\n"
    },
    "triggerNodeReport": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/triggerNodeReport.html",
        "signatures": [
            {
                "full": "triggerNodeReport(nodeAlias)",
                "name": "triggerNodeReport",
                "parameters": [
                    {
                        "full": "nodeAlias",
                        "name": "nodeAlias"
                    }
                ]
            }
        ],
        "markdown": "### [triggerNodeReport](https://docs.dolphindb.cn/zh/funcs/t/triggerNodeReport.html)\n\n\n\n#### 语法\n\ntriggerNodeReport(nodeAlias)\n\n#### 参数\n\n**nodeAlias** 字符串，表示节点的别名。\n\n#### 详情\n\n强制触发别名为 *nodeAlias* 的节点向控制节点汇报信息，以更新控制节点维护的元数据信息。\n\n使用场景：该命令用于解决数据节点离线并再次上线后，出现不汇报某些 chunk 信息的问题。\n\n操作步骤如下：\n\n1. 通过命令 `getClusterPerf` 查看 state 字段，以确定各个节点的存活情况。\n\n2. 通过 [getClusterChunksStatus](https://docs.dolphindb.cn/zh/funcs/g/getClusterChunksStatus.html) 查看 replicas, replicaCount 字段，以确定 chunk 的副本信息。\n\n3. 若节点存活，但出现副本数不一致，在 controller 的日志中，搜索对应的 chunkId，并定位出未汇报的数据节点。在该数据节点上调用 `tirggerNodeReport` 强制触发其汇报 chunk 信息。\n\n4. 若此方法失效，建议重启节点。\n"
    },
    "triggerPKEYCompaction": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/triggerPKEYCompaction.html",
        "signatures": [
            {
                "full": "triggerPKEYCompaction(chunkId, [async=true])",
                "name": "triggerPKEYCompaction",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    },
                    {
                        "full": "[async=true]",
                        "name": "async",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [triggerPKEYCompaction](https://docs.dolphindb.cn/zh/funcs/t/triggerPKEYCompaction.html)\n\n\n\n#### 语法\n\ntriggerPKEYCompaction(chunkId, \\[async=true])\n\n#### 详情\n\n异步强制触发指定 chunk 进行 compaction，从而提升读取效率。\n\n#### 参数\n\n**chunkId** STRING 类型标量或向量，表示 chunk 对应的 ID。\n\n**async**BOOL 类型标量，表示是否异步触发：\n\n* 默认为 true，表示异步触发，即不等待 compaction 任务完成直接返回；\n* false 表示同步触发，即等待所有 compaction 任务完成后返回。\n\n#### 例子\n\n```\ntriggerPKEYCompaction(chunkId=\"1486f935-6f87-479c-b341-34c6a303d4f9\", async=false)\n```\n"
    },
    "triggerTSDBCompaction": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/triggerTSDBCompaction.html",
        "signatures": [
            {
                "full": "triggerTSDBCompaction(chunkId, [level=0])",
                "name": "triggerTSDBCompaction",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    },
                    {
                        "full": "[level=0]",
                        "name": "level",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [triggerTSDBCompaction](https://docs.dolphindb.cn/zh/funcs/t/triggerTSDBCompaction.html)\n\n\n\n#### 语法\n\ntriggerTSDBCompaction(chunkId, \\[level=0])\n\n#### 参数\n\n**chunkId** 是字符串标量，表示 chunk 的 ID。\n\n**level**是属于 \\[0,3] 的正整数，指定触发哪一层级的 Level File 合并。默认值为 0，此时触发 level 0 级别。\n\n注：当 chunk 保留所有数据（即建表时指定 keepDuplicates=ALL）时，不可将 *level* 设置为 3。\n\n#### 详情\n\n在 TSDB 存储引擎中，强制触发指定 chunk 内level 0 级别的所有指定层级 level file 的合并操作，以提升读取效率。\n\n#### 例子\n\n一个分区内包含两种文件类型，一种是记录数据库和数据表结构信息的文件（file chunk），另一种是数据文件（tablet chunk）。 因为只能对数据文件进行合并操作，在查询 chunk ID 时，需通过 type=1（代表数据文件）来进行过滤。\n\n```\nchunkIds = exec chunkId from getChunksMeta() where type=1\nfor (x in chunkIds) {\n    triggerTSDBCompaction(x)\n}\n```\n"
    },
    "tril": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tril.html",
        "signatures": [
            {
                "full": "tril(X, [k=0])",
                "name": "tril",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k=0]",
                        "name": "k",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [tril](https://docs.dolphindb.cn/zh/funcs/t/tril.html)\n\n\n\n#### 语法\n\ntril(X, \\[k=0])\n\n#### 参数\n\n**X** 是一个矩阵。\n\n**k** 是一个整数。\n\n#### 详情\n\n* 若未指定 *k*： 返回矩阵 *X* 的下三角部分，其余元素设为0。\n\n* 若指定 *k*： 返回矩阵 *X* 的第 *k* 条对角线上以及该对角线下方的元素，其余元素设为0。矩阵的主对角线为其第0条对角线。\n\n#### 例子\n\n```\nm=matrix(1 2 3, 4 5 6, 7 8 9);\nm;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 7    |\n| 2    | 5    | 8    |\n| 3    | 6    | 9    |\n\n```\ntril(m);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 0    | 0    |\n| 2    | 5    | 0    |\n| 3    | 6    | 9    |\n\n```\ntril(m,1);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 0    |\n| 2    | 5    | 8    |\n| 3    | 6    | 9    |\n\n```\ntril(m,-1);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 0    | 0    | 0    |\n| 2    | 0    | 0    |\n| 3    | 6    | 0    |\n\n相关函数：[triu](https://docs.dolphindb.cn/zh/funcs/t/triu.html)\n"
    },
    "trim": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/trim.html",
        "signatures": [
            {
                "full": "trim(X)",
                "name": "trim",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [trim](https://docs.dolphindb.cn/zh/funcs/t/trim.html)\n\n\n\n#### 语法\n\ntrim(X)\n\n#### 参数\n\n**X** 是一个字符串标量或向量。\n\n#### 详情\n\n去掉每个字符串首尾的空格。\n\n#### 例子\n\n```\nx=[\"  t1\", \" t2 \"];\ntrim(x);\n// output\n[\"t1\",\"t2\"]\n```\n\n相关函数：[strip](https://docs.dolphindb.cn/zh/funcs/s/strip.html)\n"
    },
    "trima": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/trima.html",
        "signatures": [
            {
                "full": "trima(X, window)",
                "name": "trima",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [trima](https://docs.dolphindb.cn/zh/funcs/t/trima.html)\n\n\n\n#### 语法\n\ntrima(X, window)\n\nTA-lib 系列函数参数说明和窗口计算规则请参考：[TAlib](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的三角移动平均（Triangular Moving Average）。\n\n其计算公式为：![](https://docs.dolphindb.cn/zh/images/trima.png)\n\n其中 *w1 = (window + 1)/2* 向上取整；*w2 = (window + 1)/2* 向下取整。\n\n#### 例子\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\ntrima(x,3);\n// output\n[,,12.274999999999998,18.625,18.662500000000001,15.225000000000001,11.59375]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\ntrima(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n| 12.2749 | 15.5000 |\n| 12.5499 | 17.5000 |\n| 12.5249 | 19.2500 |\n| 12.0499 | 18.2500 |\n| 11.5750 | 13.7500 |\n\n相关函数：[sma](https://docs.dolphindb.cn/zh/funcs/s/sma.html), [wma](https://docs.dolphindb.cn/zh/funcs/w/wma.html), [trima](https://docs.dolphindb.cn/zh/funcs/t/trima.html)\n"
    },
    "triu": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/triu.html",
        "signatures": [
            {
                "full": "triu(X, [k=0])",
                "name": "triu",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[k=0]",
                        "name": "k",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [triu](https://docs.dolphindb.cn/zh/funcs/t/triu.html)\n\n\n\n#### 语法\n\ntriu(X, \\[k=0])\n\n#### 参数\n\n**X** 是一个矩阵。\n\n**k** 是一个整数。\n\n#### 详情\n\n* 若未指定 *k*： 返回矩阵 *X* 的上三角部分，其余元素设为0。\n\n* 若指定 *k*： 返回矩阵 *X* 的第 *k* 条对角线上以及该对角线上方的元素，其余元素设为0。矩阵的主对角线为其第0条对角线。\n\n#### 例子\n\n```\nm=matrix(1 2 3, 4 5 6, 7 8 9);\nm;\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 7    |\n| 2    | 5    | 8    |\n| 3    | 6    | 9    |\n\n```\ntriu(m);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 7    |\n| 0    | 5    | 8    |\n| 0    | 0    | 9    |\n\n```\ntriu(m,1);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 0    | 4    | 7    |\n| 0    | 0    | 8    |\n| 0    | 0    | 0    |\n\n```\ntriu(m,-1);\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 4    | 7    |\n| 2    | 5    | 8    |\n| 0    | 6    | 9    |\n\n相关函数： [tril](https://docs.dolphindb.cn/zh/funcs/t/tril.html)\n"
    },
    "trueRange": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/trueRange.html",
        "signatures": [
            {
                "full": "trueRange(high, low, close)",
                "name": "trueRange",
                "parameters": [
                    {
                        "full": "high",
                        "name": "high"
                    },
                    {
                        "full": "low",
                        "name": "low"
                    },
                    {
                        "full": "close",
                        "name": "close"
                    }
                ]
            }
        ],
        "markdown": "### [trueRange](https://docs.dolphindb.cn/zh/funcs/t/trueRange.html)\n\n\n\n#### 语法\n\ntrueRange(high, low, close)\n\n#### 参数\n\n**high**, **low** 和 **close** 是等长的数值型向量。\n\n#### 详情\n\n计算真实波幅，即 | 最高价-最低价 | 和 | 最高价-昨收 | 和 | 昨收-最低价 | 的最大值。\n\n#### 例子\n\n```\nsym=take(`A`B,10)\ndate=2020.01.01 2020.01.01 2020.01.02 2020.01.02 2020.01.03 2020.01.03 2020.01.04 2020.01.04 2020.01.05 2020.01.05\nhigh=[11.48,10.23,12.26,10.7,12.24,10.45,12.3,10.51,12.24,10.49]\nlow=[10.91,9.41,11.18,10,11.71,9.83,11.62,9.91,11.1,9.6]\nclose=[11.38,10.22,12.1,10.31,11.89,10.21,12.13,10.47,11.35,9.81]\nt=table(sym,date,high,low,close)\nselect sym,trueRange(high,low,close) as trange from t context by sym;\n```\n\n| sym | trange |\n| --- | ------ |\n| A   |        |\n| A   | 1.08   |\n| A   | 0.53   |\n| A   | 0.68   |\n| A   | 1.14   |\n| B   |        |\n| B   | 0.7    |\n| B   | 0.62   |\n| B   | 0.6    |\n| B   | 0.89   |\n"
    },
    "truncate": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/truncate.html",
        "signatures": [
            {
                "full": "truncate(dbUrl, tableName)",
                "name": "truncate",
                "parameters": [
                    {
                        "full": "dbUrl",
                        "name": "dbUrl"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [truncate](https://docs.dolphindb.cn/zh/funcs/t/truncate.html)\n\n\n\n#### 语法\n\ntruncate(dbUrl, tableName)\n\n#### 参数\n\n**dbUrl** 字符串，表示数据库的路径。\n\n**tableName** 字符串，表示数据表的表名。\n\n#### 详情\n\n删除分布式表的所有数据，但保留数据表结构。其性能较 [delete](https://docs.dolphindb.cn/zh/progr/sql/delete.html) 语句以及 [dropPartition](https://docs.dolphindb.cn/zh/funcs/d/dropPartition.html) 命令均有数倍提升。\n\n若仅需要删除表中所有的数据，但保留表结构，建议调用 `truncate` 实现。若无需保留表结构，建议调用 [dropTable](https://docs.dolphindb.cn/zh/funcs/d/dropTable.html) 命令。\n\n#### 例子\n\n```\nn=1000000\nID=rand(150, n)\ndates=2017.08.07..2017.08.11\ndate=rand(dates, n)\nx=rand(10.0, n)\nt=table(ID, date, x)\ndbDate = database(, VALUE, 2017.08.07..2017.08.11)\ndbID = database(, RANGE, 0 50 100 150)\n\ndbName=\"dfs://compoDB\"\nif(existsDatabase(dbName)){\n\n      dropDatabase(dbName)\n}\ndb = database(dbName, COMPO, [dbDate, dbID])\npt = db.createPartitionedTable(t, `pt, `date`ID)\npt.append!(t);\n\ntruncate(dbName, `pt)\n```\n"
    },
    "tTest": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tTest.html",
        "signatures": [
            {
                "full": "tTest(X, [Y], [mu=0.0], [confLevel=0.95], [equalVar=false])",
                "name": "tTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    },
                    {
                        "full": "[mu=0.0]",
                        "name": "mu",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[confLevel=0.95]",
                        "name": "confLevel",
                        "optional": true,
                        "default": "0.95"
                    },
                    {
                        "full": "[equalVar=false]",
                        "name": "equalVar",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [tTest](https://docs.dolphindb.cn/zh/funcs/t/tTest.html)\n\n\n\n#### 语法\n\ntTest(X, \\[Y], \\[mu=0.0], \\[confLevel=0.95], \\[equalVar=false])\n\n#### 参数\n\n**X** 是一个数值向量，表示用于t检验的样本。\n\n**Y** 是一个数值向量，表示用于独立双样本t检验的另一个样本。它是可选参数。\n\n**mu** 是一个浮点数，默认值是0。如果没有指定 *Y* ，*mu* 表示 *X* 的均值的假设值；如果指定了 *Y*，*mu* 表示 *X*, *Y* 均值之差的假设值。\n\n**confLevel** 是0到1之间的浮点数，表示置信区间的置信水平。\n\n**equalVar** 是一个布尔值，表示 *X*, *Y* 的方差是否相等。\n\n#### 详情\n\n对未知方差的数据进行t检验。\n\n如果没有指定 *Y*，对正态分布 *X* 进行单样本 t 检验；如果指定了 *Y*，对独立正态分布 *X* 和 *Y* 进行双样本 t 检验。返回的结果是一个字典，包含以下 key：\n\n* stat：一张表，包含三种不同备择假设下的 p 值和置信区间\n\n* df：t 分布的自由度\n\n* confLevel：置信水平\n\n* tValue：t 统计量\n\n#### 例子\n\n单样本 t 检验：\n\n```\nx = norm(10.0, 1.0, 20)\ntTest(x, , 10.0);\n\n// output\nstat->\nalternativeHypothesis        pValue   lowerBound upperBound\n---------------------------- -------- ---------- ----------\ntrue mean is not equal to 10 0.499649 9.68582    10.621998\ntrue mean is less than 10    0.750176 -Infinity  10.540616\ntrue mean is greater than 10 0.249824 9.767202   Infinity\n\ndf->19\nconfLevel->0.95\nmethod->One sample t-test\ntValue->0.688192\n```\n\n独立同方差双样本 t 检验：\n\n```\nx = norm(10.0, 1.0, 20)\ny = norm(4.0, 1.0, 10)\ntTest(x, y, 6.0, , true);\n\n// output\nstat->\nalternativeHypothesis                pValue   lowerBound upperBound\n------------------------------------ -------- ---------- ----------\ndifference of mean is not equal to 6 0.438767 5.539812   7.03262\ndifference of mean is less than 6    0.780616 -Infinity  6.906078\ndifference of mean is greater than 6 0.219384 5.666354   Infinity\n\ndf->28\nconfLevel->0.95\nmethod->Two sample t-test\ntValue->0.785483\n```\n\n独立不同方差双样本 t 检验：\n\n```\nx = norm(10.0, 1.0, 20)\ny = norm(1.0, 2.0, 10)\ntTest(x, y, 9.0);\n\n// output\nstat->\nalternativeHypothesis          pValue   lowerBound upperBound\n------------------------------ ----------------- ---------- ----------\ntrue difference of mean is n...0.983376 7.752967   10.271656\ntrue difference of mean is l...0.508312 -Infinity  10.04285\ntrue difference of mean is g...0.491688 7.981773   Infinity\n\ndf->12.164434\nconfLevel->0.95\nmethod->Welch two sample t-test\ntValue->0.021269\n```\n"
    },
    "tupleSum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/tupleSum.html",
        "signatures": [
            {
                "full": "tupleSum(X)",
                "name": "tupleSum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [tupleSum](https://docs.dolphindb.cn/zh/funcs/t/tupleSum.html)\n\n\n\n#### 语法\n\ntupleSum(X)\n\n#### 参数\n\n**X** 是一个元组。\n\n#### 详情\n\n`tupleSum` 用于从多个 `map` 调用中总结单个结果。如果每个 `map` 调用返回了一个包含 N 个非元组对象的元祖，那么 `tupleSum` 函数的输入将是一个包含 N 个元组对象的元组。每一个子元组包含 m 个拥有相同数据形式和数据类型的对象，m 是 `map` 函数调用的次数。如果有一个单独的 `map` 调用，`tupleSum` 以 `map` 调用的结果作为输入，将输入直接返回作为输出。\n\n`tupleSum` 的函数调用结果和 `map` 调用的结果总是有相同的格式。如果 `map` 调用返回一个包含至少 2 个非元组对象的元祖，`tupleSum` 将返回一个包含了具有相同个数的非元组对象的元组。\n\n#### 例子\n\n```\nx = [(1 2, 3 4, 5 6), (0.5, 0.6, 0.7)];\ntupleSum(x);\n// output\n([9,12],1.8)\n```\n\n如果 `map` 调用返回单个非元组的对象，`tupleSum` 也会返回单个非元组对象。\n\n```\nx = [(1 2, 3 4, 5 6)];\ntupleSum(x);\n// output\n[9,12]\n```\n"
    },
    "type": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/type.html",
        "signatures": [
            {
                "full": "type(X)",
                "name": "type",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [type](https://docs.dolphindb.cn/zh/funcs/t/type.html)\n\n\n\n#### 语法\n\ntype(X)\n\n#### 参数\n\n**X** 可以是系统支持的任意数据类型。\n\n#### 详情\n\n返回一个表明 *X* 的数据类型的整数。详细信息参见 [数据类型](https://docs.dolphindb.cn/zh/progr/data_types.html)。\n\n#### 例子\n\n```\nx=3;\nx;\n// output\n3\n\ntype(x);\n// output\n4\n// INT\n\ntype(1.2);\n// output\n16\n// DOUBLE\n\ntype(\"Hello\");\n// output\n18\n// STRING\n```\n"
    },
    "typestr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/t/typestr.html",
        "signatures": [
            {
                "full": "typestr(X)",
                "name": "typestr",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [typestr](https://docs.dolphindb.cn/zh/funcs/t/typestr.html)\n\n\n\n#### 语法\n\ntypestr(X)\n\n#### 参数\n\n**X** 可以是系统支持的任意数据类型。\n\n#### 详情\n\n返回一个表明X的数据类型的字符串。详细信息参见 [数据类型](https://docs.dolphindb.cn/zh/progr/data_types.html)。\n"
    },
    "undef": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/undef.html",
        "signatures": [
            {
                "full": "undef(obj, [objType=VAR])",
                "name": "undef",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "[objType=VAR]",
                        "name": "objType",
                        "optional": true,
                        "default": "VAR"
                    }
                ]
            }
        ],
        "markdown": "### [undef](https://docs.dolphindb.cn/zh/funcs/u/undef.html)\n\n\n\n#### 语法\n\nundef(obj, \\[objType=VAR])\n\n或\n\nundef all\n\n#### 参数\n\n**obj** 需要取消定义的对象。如果想要取消所有变量、所有全局变量或所有用户自定义函数的定义，*obj* 可以使用 \"all\"。\n\n**objType** 需要取消定义的对象的类型。可以是以下取值之一：VAR（本地变量）,SHARED（共享变量） 或 DEF（函数定义）。默认值是 VAR。\n\n使用 `undef all` 删除系统中所有用户自定义的对象。\n\n#### 详情\n\n从内存中释放变量和函数定义。VAR（本地变量）亦可通过 \"= NULL\" 释放变量。\n\n#### 例子\n\n```\nundef all;\nx=1\nundef(`x);\nx=1\ny=2\nundef(`x`y);\nshare table(1..3 as x, 4..6 as y) as t\nundef(`t, SHARED);\n```\n\n```\ndef f(a){return a+1}\nundef(`f, DEF);\na=1\nb=2\nundef all, VAR;\n// 取消所有变量的定义，但不包括函数定义。\n```\n"
    },
    "ungroup": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/ungroup.html",
        "signatures": [
            {
                "full": "ungroup(X)",
                "name": "ungroup",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [ungroup](https://docs.dolphindb.cn/zh/funcs/u/ungroup.html)\n\n\n\n#### 语法\n\nungroup(X)\n\n#### 参数\n\n**X** 必须是一个表对象。\n\n#### 详情\n\n若表 *X* 的某列中包含数组向量或列式元组，则将其展开后整体做为一列；同时保留原同行中其余列的数据，按照对应数组向量或列式元组的元素数量进行复制填充；最后返回一个表。\n\n若 *X* 的行数为0或不包含数组向量或列式元组，则直接返回 *X*。\n\n#### 例子\n\n```\nx = array(INT[], 0).append!([1 2 3, 4 5, 6 7 8, 9 10])\nt = table(1 2 3 4 as id, x as vol)\nungroup(t)\n// output\nid vol\n-- -------\n1  1      \n1  2      \n1  3      \n2  4      \n2  5      \n3  6      \n3  7      \n3  8      \n4  9      \n4  10     \n\n//创建一个表，其中 price 列为列式元组。\nsym = `st1`st2`st3\nprice = [[3.1,2.5,2.8], [3.1,3.3], [3.2,2.9,3.3]]\nt = table(sym, price)\nt;\n```\n\n| sym | price                   |\n| --- | ----------------------- |\n| st1 | \\[3.1000,2.5000,2.8000] |\n| st2 | \\[3.1000,3.3000]        |\n| st3 | \\[3.2000,2.9000,3.3000] |\n\n```\n\nungroup(t)\n```\n\n| sym | price |\n| --- | ----- |\n| st1 | 3.1   |\n| st1 | 2.5   |\n| st1 | 2.8   |\n| st2 | 3.1   |\n| st2 | 3.3   |\n| st3 | 3.2   |\n| st3 | 2.9   |\n| st3 | 3.3   |\n\n```\n\nsym = `st1`st2`st2`st1`st3`st1`st3`st2`st3\nvolume = 106 115 121 90 130 150 145 123 155;\nt = table(sym, volume);\nt;\n\nt1 = select toArray(volume) as volume_all from t group by sym;\nt1;\n```\n\n| sym | volume\\_all    |\n| --- | -------------- |\n| st1 | \\[106,90,150]  |\n| st2 | \\[115,121,123] |\n| st3 | \\[130,145,155] |\n\n```\n\nungroup(t1)\n```\n\n| sym | volume\\_all |\n| --- | ----------- |\n| st1 | 106         |\n| st1 | 90          |\n| st1 | 150         |\n| st2 | 115         |\n| st2 | 121         |\n| st2 | 123         |\n| st3 | 130         |\n| st3 | 145         |\n| st3 | 155         |\n"
    },
    "unifiedExpr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/unifiedExpr.html",
        "signatures": [
            {
                "full": "unifiedExpr(objs, optrs)",
                "name": "unifiedExpr",
                "parameters": [
                    {
                        "full": "objs",
                        "name": "objs"
                    },
                    {
                        "full": "optrs",
                        "name": "optrs"
                    }
                ]
            }
        ],
        "markdown": "### [unifiedExpr](https://docs.dolphindb.cn/zh/funcs/u/unifiedExpr.html)\n\n\n\n#### 语法\n\nunifiedExpr(objs, optrs)\n\n#### 参数\n\n**objs** 是包含两个及以上元素的元组。\n\n**optrs** 是由二元运算符组成的向量，其数量为 size(*objs*)-1。\n\n#### 详情\n\n使用 *optrs* 中的二元运算符，将 *objs* 中元素连接，生成一个多元运算表达式的元代码。使用 [eval](https://docs.dolphindb.cn/zh/funcs/e/eval.html) 函数可以执行 `unifiedExpr` 函数生成的元代码。\n\n#### 例子\n\n```\nunifiedExpr((1, 2), add)\n// output\n<1 + 2>\n\nt=table(1..3 as price1, 4..6 as price2, 5..7 as price3)\na=sqlColAlias(unifiedExpr((sqlCol(\"price1\"), sqlCol(\"price2\"), sqlCol(\"price3\")), take(add, 2)))\nsql(select=(sqlCol(`price1),sqlCol(`price2),sqlCol(`price3),a), from=t).eval()\n```\n\n| price1 | price2 | price3 | price1\\_add |\n| ------ | ------ | ------ | ----------- |\n| 1      | 4      | 5      | 10          |\n| 2      | 5      | 6      | 13          |\n| 3      | 6      | 7      | 16          |\n\n相关函数： [binaryExpr](https://docs.dolphindb.cn/zh/funcs/b/binaryExpr.html)\n"
    },
    "union": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/union.html",
        "signatures": [
            {
                "full": "union(X, Y)",
                "name": "union",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [union](https://docs.dolphindb.cn/zh/funcs/u/union.html)\n\n\n\n#### 语法\n\nunion(X, Y) 或 X|Y\n\n#### 参数\n\n**X** 和 **Y** 是集合\n\n#### 详情\n\n返回两个集合的并集。\n\n#### 例子\n\n```\nx=set([5,5,3,4]);\ny=set(8 9 9 4 6);\nx | y;\n// output\nset(8,9,6,4,3,5)\n```\n"
    },
    "unionAll": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/unionAll.html",
        "signatures": [
            {
                "full": "unionAll(tableA, tableB, [byColName=false])",
                "name": "unionAll",
                "parameters": [
                    {
                        "full": "tableA",
                        "name": "tableA"
                    },
                    {
                        "full": "tableB",
                        "name": "tableB"
                    },
                    {
                        "full": "[byColName=false]",
                        "name": "byColName",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "unionAll(tables, [partition=true], [byColName=false])",
                "name": "unionAll",
                "parameters": [
                    {
                        "full": "tables",
                        "name": "tables"
                    },
                    {
                        "full": "[partition=true]",
                        "name": "partition",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[byColName=false]",
                        "name": "byColName",
                        "optional": true,
                        "default": "false"
                    }
                ]
            },
            {
                "full": "unionAll(tables, tableB)",
                "name": "unionAll",
                "parameters": [
                    {
                        "full": "tables",
                        "name": "tables"
                    },
                    {
                        "full": "tableB",
                        "name": "tableB"
                    }
                ]
            }
        ],
        "markdown": "### [unionAll](https://docs.dolphindb.cn/zh/funcs/u/unionAll.html)\n\n\n\n#### 语法\n\nunionAll(tableA, tableB, \\[byColName=false])\n\n或\n\nunionAll(tables, \\[partition=true], \\[byColName=false])\n\n或\n\nunionAll(tables, tableB)\n\n#### 参数\n\n* 用法一：\n\n  * **tableA** 和 **tableB** 是列数相同的内存表。\n\n* 用法二：\n\n  * **tables** 是一个元组，其中每个元素都是一个表，并且它们具有相同的列数。\n\n  * **partition** 是布尔值，表示是否进行顺序分区（SEQ），默认值是 true。\n\n  * **byColName** 是一个布尔值。若设为 true，表示表合并时，依照列名进行，各表中相同列名的列进行合并，缺失的列用空值填充。若设为 false，表示表合并时仅基于列顺序，不管列名是否一致。\n\n* 用法三：\n\n  * **tables** 是一个元组，其中每个元素都是一个内存表，并且它们具有相同的列数。**tableB** 是一个和 *tables* 中表列数相同的内存表。\n\n**Note:**\n\n*tableA*, *tableB*, *tables* 支持以下内存表：table, keyedTable, indexedTable, latestKeyedTable, latestIndexedTable。此外，用法三的 *tableB* 还可以是一个分区内存表。\n\n#### 详情\n\n第一种用法只能将两个表合并成一个表，返回的结果是未分区的内存表。\n\n第二种用法可以多个表合并成一个表。如果 *partition* 为 false，返回的结果是未分区的内存表；如果 *partition* 为 true，返回的结果是一个顺序分区的内存表。默认值为 true。\n\n当 *byColName* =true 时，各表可有不同数量的列。若某列在某些表中不存在，结果中会以空值填充。\n\n当 *byColName* =false 时，各表必须有相同数量的列。\n\n第三种用法是将多个表追加到指定的表，并返回该表。常用于 `mr` 函数的 finalFunc。\n\n#### 例子\n\n用法一：合并两个内存表\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x)\nt2=table(4 5 6 as id, 14 15 16 as x)\nre=unionAll(t1,t2)\nre;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n| 6  | 16 |\n\n```\ntypestr(re);\n// output\nIN-MEMORY TABLE\n```\n\n用法二：合并多个内存表\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x)\nt2=table(4 5 6 as id, 14 15 16 as x)\nt3=table(7 8 as id, 17 18 as x)\nre=unionAll([t1,t2,t3])\nselect * from re;\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n| 6  | 16 |\n| 7  | 17 |\n| 8  | 18 |\n\n```\ntypestr(re);\n// output\nSEGMENTED IN-MEMORY TABLE\n```\n\n指定 byColName：\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x)\nt2=table(14 15 16 as x, 4 5 6 as id)\nunionAll(t1,t2,true);\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 4  | 14 |\n| 5  | 15 |\n| 6  | 16 |\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x)\nt2=table(14 15 16 as x, 4 5 6 as id)\nunionAll(t1,t2);\n```\n\n| id | x  |\n| -- | -- |\n| 1  | 11 |\n| 2  | 12 |\n| 3  | 13 |\n| 14 | 4  |\n| 15 | 5  |\n| 16 | 6  |\n\n上例中可见，若不指定 *byColName* （即 *byColName* =false），请务必确认各表中列名顺序一致，否则会产生错误结果。\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x, 21 22 23 as y)\nt2=table(4 5 6 as id, 14 15 16 as x)\nunionAll(t1,t2,true);\n```\n\n| id | x  | y  |\n| -- | -- | -- |\n| 1  | 11 | 21 |\n| 2  | 12 | 22 |\n| 3  | 13 | 23 |\n| 4  | 14 |    |\n| 5  | 15 |    |\n| 6  | 16 |    |\n\n```\nt1=table(1 2 3 as id, 11 12 13 as x, 21 22 23 as y)\nt2=table(4 5 6 as id, 14 15 16 as x)\nunionAll(t1, t2) => The number of columns of the table to insert must be the same as that of the original table.\n```\n\n上例中可见，若各表中列数不一致，必须将 *byColName* 设为 true。\n\n用法三：将多个内存表合并到分区内存表\n\n```\ndef testFunc(data, off){\n    return select *, price * (1-off) as `discountPrice from data\n}\nn = 100\ndates = 2021.01.01..2021.12.31\nt = table(take(dates, 365 * n).sort() as `date, `sym + take(1..n, 365 * n).sort()$STRING as `sym, round(10 + norm(0, 2, 365 * n), 2) as `price)\n\ndb = database(\"\", VALUE, 2021.01.01..2021.12.31)\ntrade = db.createPartitionedTable(table=t, tableName=\"trade\", partitionColumns=`date).append!(t)\ndb = database(\"\", RANGE, date(month(dates.first()) .. (month(dates.last()) + 1)))\noutputT=table(1:0, `date`sym`price`discountPrice, [DATE,SYMBOL,DOUBLE,DOUBLE])\nports = db.createPartitionedTable(outputT, \"ports\", `date)\n//map reduce\nmr(sqlDS(<select * from trade>), testFunc{,0.3},,unionAll{,ports})\n\nselect * from ports\n```\n"
    },
    "unpack": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/unpack.html",
        "signatures": [
            {
                "full": "unpack(format, buf)",
                "name": "unpack",
                "parameters": [
                    {
                        "full": "format",
                        "name": "format"
                    },
                    {
                        "full": "buf",
                        "name": "buf"
                    }
                ]
            }
        ],
        "markdown": "### [unpack](https://docs.dolphindb.cn/zh/funcs/u/unpack.html)\n\n\n\n#### 语法\n\nunpack(format, buf)\n\n#### 参数\n\n**format** 格式字符串，用于指定数据格式。指定方式参见附录。关于格式字符串的说明：\n\n* 格式字符之前可以带有整数表示重复计数。 例如，格式字符串 '4h' 的含义与 'hhhh' 完全相同。\n\n* 格式之间的空白字符会被忽略；但是计数及其格式字符中不可有空白字符。\n\n* 对于 's' 格式字符，计数会被解析为字节的长度，而不是像其他格式字符那样的重复计数；例如，'10s' 表示一个 10 字节的字节串，而 '10c' 表示 10 个字符。 若未给出计数，则默认值为1。返回结果的字节对象长度必须恰好等于指定的字节数量。 作为特殊情况，'0c' 表示 0 个字符。\n\n**buf** 二进制字节流，可以是 STRING 或 BLOB 类型。*buf* 中各元素的字节大小和类型必须匹配 *format* 所要求的大小和类型。\n\n#### 详情\n\n根据 *format* 指定的格式，将 *buf* 解包成 DolphinDB 中的数据。返回一个元组，其元素为解包后的数据。\n\n#### 例子\n\n```\nres = pack(\"N\",1);\nres1 = unpack(\"N\", res);\nprint(res1)\n// output\n(1)\n\n\nres = pack(\"3s i\", `123, 3)\nres1 = unpack(\"3s i\",  res);\nprint(res1)\n// output\n(\"123\",3)\n```\n\n#### 附录\n\n格式和类型的对应关系见前述格式字符与类型相关内容。\n\n默认情况下，C 类型以本机格式和字节顺序表示，在必要时通过跳过填充字节进行正确对齐（根据 C 编译器使用的规则）。\n\n格式字符串的第一个字符可用于指示打包数据的字节顺序，大小和对齐方式。 如果第一个字符不是其中之一，则按 '@' 处理。\n\n相关函数：[pack](https://docs.dolphindb.cn/zh/funcs/p/pack.html)\n"
    },
    "unpivot": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/unpivot.html",
        "signatures": [
            {
                "full": "unpivot(obj, keyColNames, valueColNames, [func])",
                "name": "unpivot",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "keyColNames",
                        "name": "keyColNames"
                    },
                    {
                        "full": "valueColNames",
                        "name": "valueColNames"
                    },
                    {
                        "full": "[func]",
                        "name": "func",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [unpivot](https://docs.dolphindb.cn/zh/funcs/u/unpivot.html)\n\n\n\n#### 语法\n\nunpivot(obj, keyColNames, valueColNames, \\[func])\n\n#### 参数\n\n**obj** 是一个表。\n\n**keyColNames** 是表示列名的标量或向量，用于指定要在输出表中保留的列。\n\n**valueColNames** 是一个列名向量。*valueColNames* 中的数据将转换成一列。 请注意 *valueColNames* 各列的数据类型应一致。\n\n**func** 是一个函数。如果指定了 *func* 函数，该函数将会应用到 *valueColNames* 上，再将其合并。\n\n#### 详情\n\n把多列的数据转换成一列。\n\n返回一个表，列的顺序依次为 *keyColNames* 指定的各列，valueType 列和 value 列。其中，若未指定 *func* 参数，则 valueType 列存储 *valueColNames* 中的列名，否则 ，valueType 列存储 *func* 应用于 *valueColNames* 中各列的结果；value 列存储 *valueColNames* 中各列的值。\n\n#### 例子\n\n```\nt=table(1..3 as id, 2010.01.01 + 1..3 as time, 4..6 as col1, 7..9 as col2, 10..12 as col3, `aaa`bbb`ccc as col4, `ddd`eee`fff as col5, 'a' 'b' 'c' as col6);\nt;\n```\n\n| id | time       | col1 | col2 | col3 | col4 | col5 | col6 |\n| -- | ---------- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 1  | 2010.01.02 | 4    | 7    | 10   | aaa  | ddd  | 'a'  |\n| 2  | 2010.01.03 | 5    | 8    | 11   | bbb  | eee  | 'b'  |\n| 3  | 2010.01.04 | 6    | 9    | 12   | ccc  | fff  | 'c'  |\n\n保留表 t 中的 id 列，将 col1 列和 col2 列转换为一列：\n\n```\nt.unpivot(keyColNames=`id, valueColNames=`col1`col2);\n```\n\n| id | valueType | value |\n| -- | --------- | ----- |\n| 1  | col1      | 4     |\n| 2  | col1      | 5     |\n| 3  | col1      | 6     |\n| 1  | col2      | 7     |\n| 2  | col2      | 8     |\n| 3  | col2      | 9     |\n\n保留表 t 中的 id 列，将 col1 列和 col2 列转换为一列，且将自定义函数应用于 col1 列和 col2 列：\n\n```\nf = def(x): x.split(\"col\")[1];\nt.unpivot(keyColNames=`id, valueColNames=`col1`col2, func=f);\n```\n\n| id | valueType | value |\n| -- | --------- | ----- |\n| 1  | 1         | 4     |\n| 2  | 1         | 5     |\n| 3  | 1         | 6     |\n| 1  | 2         | 7     |\n| 2  | 2         | 8     |\n| 3  | 2         | 9     |\n\n不保留其它列，仅仅将 col1 列和 col2 列转换为一列：\n\n```\nt.unpivot(, valueColNames=`col1`col2);\n```\n\n| valueType | value |\n| --------- | ----- |\n| col1      | 4     |\n| col1      | 5     |\n| col1      | 6     |\n| col2      | 7     |\n| col2      | 8     |\n| col2      | 9     |\n\n保留表 t 中的 id 列，将 col1 列、col2 列 和 col3 列转换为一列，且将自定义函数应用于 col1 列、col2 列和 col3 列：\n\n```\nf = def(x): x.regexReplace(\"col\", \"var\")\nt.unpivot(keyColNames=`id, valueColNames=`col1`col2`col3, func=f);\n```\n\n| id | valueType | value |\n| -- | --------- | ----- |\n| 1  | var1      | 4     |\n| 2  | var1      | 5     |\n| 3  | var1      | 6     |\n| 1  | var2      | 7     |\n| 2  | var2      | 8     |\n| 3  | var2      | 9     |\n| 1  | var3      | 10    |\n| 2  | var3      | 11    |\n| 3  | var3      | 12    |\n\n```\nt.unpivot(keyColNames=`time, valueColNames=`col4`col5)\n```\n\n| time       | valueType | value |\n| ---------- | --------- | ----- |\n| 2010.01.02 | col4      | aaa   |\n| 2010.01.03 | col4      | bbb   |\n| 2010.01.04 | col4      | ccc   |\n| 2010.01.02 | col5      | ddd   |\n| 2010.01.03 | col5      | eee   |\n| 2010.01.04 | col5      | fff   |\n\n```\nt = table(1..3 as id, 2010.01.01 + 1..3 as time, 8.1 9.2 11.3 as bid1, 12.4 11.1 10.5 as bid2, 10.1 10.2 10.3 as bid3, 10.1 10.2 10.3 as bid4, 10.1 11.2 9.3 as bid5, 7.7 8.2 10.5 as ask1, 11.4 10.1 9.5 as ask2, 9.6 9.2 11.3 as ask3, 12.1 7.2 8.3 as ask4, 10.1 12.5 8.9 as ask5);\nt;\n//保留 id 和 time 列，将 bid1~bid5 列转换到一个列\nt1 = t.unpivot(`id`time, `bid1`bid2`bid3`bid4`bid5);\n//不保留其它列，仅仅将 ask1~ask5 列转换到一个列\nt2 = t.unpivot(, `ask1`ask2`ask3`ask4`ask5);\n//分别将 t1 和 t2 的 valueType 和 value 列重命名后进行合并\nre = rename!(t1, `valueType`value, `bid_type`bid_value) join rename!(t2, `valueType`value, `ask_type`ask_value)\nre;\n```\n\n| id | time       | bid\\_type | bid\\_value | ask\\_type | ask\\_value |\n| -- | ---------- | --------- | ---------- | --------- | ---------- |\n| 1  | 2010.01.02 | bid1      | 8.1        | ask1      | 8.1        |\n| 2  | 2010.01.03 | bid1      | 9.2        | ask1      | 9.2        |\n| 3  | 2010.01.04 | bid1      | 11.3       | ask1      | 11.3       |\n| 1  | 2010.01.02 | bid2      | 12.4       | ask2      | 12.4       |\n| 2  | 2010.01.03 | bid2      | 11.1       | ask2      | 11.1       |\n| 3  | 2010.01.04 | bid2      | 10.5       | ask2      | 10.5       |\n| 1  | 2010.01.02 | bid3      | 10.1       | ask3      | 10.1       |\n| 2  | 2010.01.03 | bid3      | 10.2       | ask3      | 10.2       |\n| 3  | 2010.01.04 | bid3      | 10.3       | ask3      | 10.3       |\n| 1  | 2010.01.02 | bid4      | 10.1       | ask4      | 10.1       |\n| 2  | 2010.01.03 | bid4      | 10.2       | ask4      | 10.2       |\n| 3  | 2010.01.04 | bid4      | 10.3       | ask4      | 10.3       |\n| 1  | 2010.01.02 | bid5      | 10.1       | ask5      | 10.1       |\n| 2  | 2010.01.03 | bid5      | 11.2       | ask5      | 11.2       |\n| 3  | 2010.01.04 | bid5      | 9.3        | ask5      | 9.3        |\n"
    },
    "unregisterSnapshotEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/unregisterSnapshotEngine.html",
        "signatures": [
            {
                "full": "unregisterSnapshotEngine(dbName, tableName)",
                "name": "unregisterSnapshotEngine",
                "parameters": [
                    {
                        "full": "dbName",
                        "name": "dbName"
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    }
                ]
            }
        ],
        "markdown": "### [unregisterSnapshotEngine](https://docs.dolphindb.cn/zh/funcs/u/unregisterSnapshotEngine.html)\n\n\n\n#### 语法\n\nunregisterSnapshotEngine(dbName, tableName)\n\n#### 参数\n\n**dbName** 是一个字符串，表示分布式数据库的名称。\n\n**tableName** 是一个字符串，表示分布式表的名称。\n\n#### 详情\n\n取消注册分布式表的快照引擎。在集群模式下，此函数将取消各节点上已注册的该分布式表的快照引擎。\n\n#### 例子\n\n```\nunregisterSnapshotEngine(\"dfs://compoDB\",\"pt\")\n```\n"
    },
    "unsubscribeTable": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/unsubscribeTable.html",
        "signatures": [
            {
                "full": "unsubscribeTable([server], tableName, [actionName], [removeOffset=true], [raftGroup])",
                "name": "unsubscribeTable",
                "parameters": [
                    {
                        "full": "[server]",
                        "name": "server",
                        "optional": true
                    },
                    {
                        "full": "tableName",
                        "name": "tableName"
                    },
                    {
                        "full": "[actionName]",
                        "name": "actionName",
                        "optional": true
                    },
                    {
                        "full": "[removeOffset=true]",
                        "name": "removeOffset",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[raftGroup]",
                        "name": "raftGroup",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [unsubscribeTable](https://docs.dolphindb.cn/zh/funcs/u/unsubscribeTable.html)\n\n\n\n#### 语法\n\nunsubscribeTable(\\[server], tableName, \\[actionName], \\[removeOffset=true], \\[raftGroup])\n\n#### 参数\n\n**server** 是表示服务器的别名或与流数据表所在服务器创建的 xdb 连接的字符串。\n\n**tableName** 是表示取消订阅的流数据表名称的字符串。\n\n**actionName** 是表示句柄名称的字符串。它可以包含字母、数字和下划线。如果创建订阅时指定了 *actionName*，取消订阅时必须指定 *actionName*。\n\n**removeOffset** 是一个布尔值，表示是否删除持久化保存的最新一条已经处理订阅数据的偏移量（在 [subscribeTable](https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html) 函数中通过指定 *persistOffset* 参数为 true 获得）。\n\n**raftGroup** 是在 [subscribeTable](https://docs.dolphindb.cn/zh/funcs/s/subscribeTable.html) 中设定的 raft 组的 ID，用于取消相应的订阅高端可用。不设置该参数，则订阅信息仍然保留在 raft 中，再次切换 leader 会重新订阅。\n\n**Note:** `unsubscribeTable` 函数如果指定了 *raftGroup* ，则只能在 leader 上执行。\n\n#### 详情\n\n在信息订阅端的节点执行，以停止向信息发布者订阅数据。在调用该命令时，会删除流计算执行线程的队列中未处理的消息。\n\n#### 例子\n\n在发布节点发布一张表 trades。\n\n```\nt=streamTable(100:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nshare t as trades\nt=NULL\n```\n\n在订阅节点上创建表 trades2 来保存发布节点中的表 trades 的数据。\n\n```\nt=streamTable(100:0,`date`time`sym`qty`price`exch,[DATE,TIME,SYMBOL,INT,DOUBLE,SYMBOL])\nshare t as trades2\nt=NULL\nh=xdb(\"localhost\",8902)\nsubscribeTable(server=h, tableName=\"trades\", actionName=\"sub1\", handler=trades2);\n// output\nlocalhost:8902:node1/trades/sub1\n```\n\n取消订阅表 trades 的数据：\n\n```\nunsubscribeTable(h, \"trades\",\"sub1\");\n```\n"
    },
    "updateLicense": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/updateLicense.html",
        "signatures": [
            {
                "full": "updateLicense()",
                "name": "updateLicense",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [updateLicense](https://docs.dolphindb.cn/zh/funcs/u/updateLicense.html)\n\n\n\n#### 语法\n\nupdateLicense()\n\n#### 参数\n\n无\n\n#### 详情\n\n用于在线更新 license。先手动替换 license 文件，然后执行该函数在线更新 license，而无需重启节点。用户可通过 [getLicenseExpiration](https://docs.dolphindb.cn/zh/funcs/g/getLicenseExpiration.html) 获得当前 license 的过期时间，以判断 license 是否生效。\n\n该函数只在执行该函数的节点生效。因此在集群环境下，需要在所有节点上运行该函数。\n\n**Note:**\n\n* 待升级 license 需满足以下条件才能成功升级（可通过 `license` 函数查看）：\n\n  * 授权的客户名称（cilentName）和授权模式（authorization）必须与原来的 license 相同。\n\n  * 授权的节点个数（maxNodes），内存大小（maxMemoryPerNode），CPU 核数（maxCoresPerNode）不小于原 license 的授权。\n\n* 若原 license 授权模式（authorization）为 site，则无法进行在线升级。\n\n* 从 2.00.9 版本开始，支持将 DolphinDB 进程绑定到具体的 CPU 内核上。若待升级 license 中修改了绑定核信息，则升级 license 后须重启 DolphinDB 以使 CPU 内核绑定的设置生效。\n\n#### 例子\n\n```\nupdateLicense()\n// output\nauthorization->commercial\nlicenseType->0\nmaxMemoryPerNode->32\nmaxCoresPerNode->8\nclientName->test license\nbindCPU->true\nexpiration->2022.03.01\nmaxNodes->8\nversion->\nmodules->-1\n```\n"
    },
    "updateMarketHoliday": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/updateMarketHoliday.html",
        "signatures": [
            {
                "full": "updateMarketHoliday(marketName, holiday)",
                "name": "updateMarketHoliday",
                "parameters": [
                    {
                        "full": "marketName",
                        "name": "marketName"
                    },
                    {
                        "full": "holiday",
                        "name": "holiday"
                    }
                ]
            }
        ],
        "markdown": "### [updateMarketHoliday](https://docs.dolphindb.cn/zh/funcs/u/updateMarketHoliday.html)\n\n\n\n#### 语法\n\nupdateMarketHoliday(marketName, holiday)\n\n#### 参数\n\n**marketName** 字符串标量，表示交易日历标识，例如：国外交易所的 ISO Code、国内交易所简称或自定义交易日历名称。\n\n**holiday** DATE 类型向量，表示节假日。因为系统默认周末为节假日，所以 *holiday* 只需指定非周末的节假日（休市）日期。\n\n#### 详情\n\n在线覆盖内存中文件名为 *marketName* 的交易市场节假日或交易日文件，并同步更新至 *marketHolidayDir*；若内存中不存在该文件，则报错。\n\n**Note:**\n\n* 该函数只能由管理员调用。\n\n* 该函数仅对当前节点有效。集群环境中，可通过 `pnodeRun` 调用该函数，使其在其它节点生效。\n\n* 若手动修改了 *marketHolidayDir* 下的交易日历，想要在不关机的情况下，同步修改内容到内存，可以通过 `loadText` 将已修改的 csv 文件加载到内存表，并转换表数据为向量（holiday），然后通过该函数将 `holiday` 更新至内存。\n\n#### 例子\n\n```\ntemporalAdd(2022.01.01,1,\"CCFX\")\n```\n\n返回：2022.01.04\n\n```\nindex = [2022.01.01, 2022.01.02, 2022.01.03, 2022.01.04]\ns = indexedSeries(index, 1..4)\ns.resample(\"CCFX\", sum);\n```\n\n返回：\n\n| label      | col1 |\n| ---------- | ---- |\n| 2021.12.31 | 6    |\n| 2022.01.04 | 4    |\n\n```\nupdateMarketHoliday(\"CCFX\",2022.01.03 2022.01.04)\ntemporalAdd(2022.01.01,1,\"CCFX\")\n```\n\n返回：2022.01.05\n\n**Related information**\n\n[addMarketHoliday](https://docs.dolphindb.cn/zh/funcs/a/addMarketHoliday.html)\n\n[getMarketCalendar](https://docs.dolphindb.cn/zh/funcs/g/getMarketCalendar.html)\n\n[getTradingCalendarType](https://docs.dolphindb.cn/zh/funcs/g/gettradingcalendartype.html)\n"
    },
    "updateOrderBookEngineParams": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/updateOrderBookEngineParams.html",
        "signatures": [
            {
                "full": "updateOrderBookEngineParams(engine, [prevClose], [maxPrice], [minPrice], [outputCodeMap])",
                "name": "updateOrderBookEngineParams",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "[prevClose]",
                        "name": "prevClose",
                        "optional": true
                    },
                    {
                        "full": "[maxPrice]",
                        "name": "maxPrice",
                        "optional": true
                    },
                    {
                        "full": "[minPrice]",
                        "name": "minPrice",
                        "optional": true
                    },
                    {
                        "full": "[outputCodeMap]",
                        "name": "outputCodeMap",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [updateOrderBookEngineParams](https://docs.dolphindb.cn/zh/funcs/u/updateOrderBookEngineParams.html)\n\n\n\n#### 语法\n\nupdateOrderBookEngineParams(engine, \\[prevClose], \\[maxPrice], \\[minPrice], \\[outputCodeMap])\n\n#### 详情\n\n在线为 OrderBook 引擎设定参数值。该函数必须在创建 OrderBook 引擎后，向引擎注入数据前调用。\n\n#### 参数\n\n**engine** OrderBook 引擎名或者或 `createOrderBookSnapshotEngine` 返回的句柄。\n\n**prevClose** 字典，其 key 为字符串标量或向量，表示股票代码；其 value 为数值类型，表示对应于股票代码的上一个交易日的收盘价格。\n\n**maxPrice** 可选参数，字典。其 key 为字符串类型，表示证券代码；其 value 为 DOUBLE 类型，表示涨停价格。\n\n**minPrice** 可选参数，字典。其 key 为字符串类型，表示证券代码；其 value 为 DOUBLE 类型，表示跌停价格。\n\n**outputCodeMap**可选参数，字符串向量，表示股票代码，例如：“000803.SZ”。指定该参数后，将只输出指定股票对应的数据。\n\n#### 例子\n\n运行代码前，先下载 [../data/orderbookDemoInput.zip](https://docs.dolphindb.cn/zh/funcs/data/orderbookDemoInput.zip) 文件。\n\n```\n// 通过参数 outputTable 指定输出表\nsuffix = string(1..10)\ncolNames = `SecurityID`timestamp`lastAppSeqNum`tradingPhaseCode`modified`turnover`volume`tradeNum`totalTurnover`totalVolume`totalTradeNum`lastPx`highPx`lowPx`ask`bid`askVol`bidVol`preClosePx`invalid  join (\"bids\" + suffix) join (\"bidVolumes\" + suffix) join (\"bidOrderNums\" + suffix) join (\"asks\" + suffix)  join (\"askVolumes\" + suffix) join (\"askOrderNums\" + suffix) \ncolTypes = [SYMBOL,TIMESTAMP,LONG,INT,BOOL,DOUBLE,LONG,INT,DOUBLE,LONG,INT,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,LONG,DOUBLE,BOOL] join take(DOUBLE, 10) join take(LONG, 10) join take(INT, 10) join take(DOUBLE, 10) join take(LONG, 10) join take(INT, 10) \nshare table(10000000:0, colNames, colTypes) as outTable\n\n// 通过参数 dummyTable 指定输入表的表结构\ncolNames = `SecurityID`Date`Time`SecurityIDSource`SecurityType`Index`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo\ncolTypes = [SYMBOL, DATE, TIME, SYMBOL, SYMBOL, LONG, INT, INT, LONG, LONG, INT, LONG, LONG, LONG, INT]\ndummyOrderStream = table(1:0, colNames, colTypes)\n\n// 通过参数 inputColMap 指定输入表各字段的含义\ninputColMap = dict(`codeColumn`timeColumn`typeColumn`priceColumn`qtyColumn`buyOrderColumn`sellOrderColumn`sideColumn`msgTypeColumn`seqColumn, `SecurityID`Time`Type`Price`Qty`BuyNo`SellNo`BSFlag`SourceType`ApplSeqNum)\nprevClose = dict(SYMBOL, DOUBLE)\n\n// 定义引擎，每 1s 计算输出深交所股票 10 档买卖盘口\nengine = createOrderBookSnapshotEngine(name=\"demo\", exchange=\"XSHE\", orderbookDepth=10, intervalInMilli = 1000, date=2022.01.10, startTime=09:15:00.000, prevClose=prevClose, dummyTable=dummyOrderStream, outputTable=outTable, inputColMap=inputColMap)\n\n// 通过 updateOrderBookEngineParams 为引擎传入 prevClose 的具体取值\nprevClose = dict(`000587.SZ`002694.SZ`002822.SZ`000683.SZ`301063.SZ`300459.SZ`300057.SZ`300593.SZ`301035.SZ`300765.SZ, [1.66, 6.56, 6.10, 8.47, 38.10, 5.34, 9.14, 48.81, 60.04, 16.52])\nupdateOrderBookEngineParams(engine, prevClose)\n\n// 导入数据\nfilePath = \"./orderbookDemoInput.csv\"\ncolNames = `SecurityID`Date`Time`SecurityIDSource`SecurityType`Index`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo\ncolTypes = [SYMBOL, DATE, TIME, SYMBOL, SYMBOL, LONG, INT, INT, LONG, LONG, INT, LONG, LONG, LONG, INT]\norderTrade = table(1:0, colNames, colTypes)\norderTrade.append!(select * from loadText(filePath) order by Time)\n\n// 10支股票的逐笔数据批量注入快照合成引擎\nengine.append!(orderTrade)\nselect count(*) from outTable where SecurityID=\"300593.SZ\", timestamp between 2022.01.10T13:15:01.000 and 2022.01.10T13:15:10.000\n```\n"
    },
    "updatePKEYDeleteBitmap": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/updatepkeydeletebitmap.html",
        "signatures": [
            {
                "full": "updatePKEYDeleteBitmap(chunkId)",
                "name": "updatePKEYDeleteBitmap",
                "parameters": [
                    {
                        "full": "chunkId",
                        "name": "chunkId"
                    }
                ]
            }
        ],
        "markdown": "### [updatePKEYDeleteBitmap](https://docs.dolphindb.cn/zh/funcs/u/updatepkeydeletebitmap.html)\n\n\n\n#### 语法\n\nupdatePKEYDeleteBitmap(chunkId)\n\n#### 详情\n\n更新 PKEY 引擎的 delete bitmap，完成后清空主键的暂存缓冲区。\n\n#### 参数\n\n**chunkId** STRING 类型标量或向量，表示 chunk 对应的 ID。\n\n#### 例子\n\n```\nupdatePKEYDeleteBitmap(chunkId=\"1486f935-6f87-479c-b341-34c6a303d4f9\")\n```\n"
    },
    "updateRule": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/updateRule.html",
        "signatures": [
            {
                "full": "updateRule(engineName, key, rules)",
                "name": "updateRule",
                "parameters": [
                    {
                        "full": "engineName",
                        "name": "engineName"
                    },
                    {
                        "full": "key",
                        "name": "key"
                    },
                    {
                        "full": "rules",
                        "name": "rules"
                    }
                ]
            }
        ],
        "markdown": "### [updateRule](https://docs.dolphindb.cn/zh/funcs/u/updateRule.html)\n\n#### 语法\n\nupdateRule(engineName, key, rules)\n\n#### 详情\n\n如果此规则引擎中存在指定的规则 *key*，则修改其 value 为输入参数 *rules*。\n\n如果此规则引擎中不存在这个规则 *key*，则向其增加此规则 *key* 及其 *rules*。\n\n如果执行成功，返回 true，否则返回false。\n\n#### 参数\n\n**engineName** 是一个字符串，表示引擎名。\n\n**key** 是 STRING 或 INT 类型的标量，表示要更新的规则对应的 key 。\n\n**rules** 是一个元代码元组，表示要更新的规则对应的 value。\n\n#### 例子\n\n```\n// 设置规则集，并创建规则引擎\nx = [1, 2, NULL]\ny = [ [ < value>1 > ], [ < price<2 >, < price>6 > ], [ < value*price>10 > ] ]\nruleSets = dict(x, y)\nnames = `sym`value`price`quantity\ntypes = [INT, DOUBLE, DOUBLE, DOUBLE]\ndummy = table(10:0, names, types)\noutputNames = `sym`value`price`rule\noutputTypes = [INT, DOUBLE, DOUBLE, BOOL[]]\noutputTable = table(10:0, outputNames, outputTypes)\ntest = createRuleEngine(name=\"ruleEngineTest\", ruleSets=ruleSets, dummyTable=dummy, outputColumns=[\"sym\",\"value\",\"price\"], outputTable=outputTable, policy=\"all\", ruleSetColumn=\"sym\")\n\n// 修改规则前\ntest.append!(table(1 as sym, 0 as value, 2 as price, 3 as quantity))\ntest.append!(table(3 as sym, 6 as value, 1 as price, 3 as quantity))\n\n// 将 sym=1 对应的规则修改为 value >=0\nupdateRule(\"ruleEngineTest\", 1, [ <value >= 0>])\ntest.append!(table(1 as sym, 0 as value, 2 as price, 3 as quantity))\n\n// 增加 sym=3 对应的规则为 value > 5\nupdateRule(\"ruleEngineTest\",3,[<value>5>])\ntest.append!(table(3 as sym, 6 as value, 1 as price, 3 as quantity))\n\n```\n\n此时的输出表 outputTable 内容如下\n\n| sym | value | price |   rule   |\n| :-: | :---: | :---: | :------: |\n|  1  |   0   |   2   | \\[false] |\n|  3  |   6   |   1   | \\[false] |\n|  1  |   0   |   2   |  \\[true] |\n|  3  |   6   |   1   |  \\[true] |\n\n\n\n**Related information**\n\n[createRuleEngine](https://docs.dolphindb.cn/zh/funcs/c/createRuleEngine.html)\n\n[deleteRule](https://docs.dolphindb.cn/zh/funcs/d/deleteRule.html)\n"
    },
    "update!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/update_.html",
        "signatures": [
            {
                "full": "update!(table, colNames, newValues, [filter])",
                "name": "update!",
                "parameters": [
                    {
                        "full": "table",
                        "name": "table"
                    },
                    {
                        "full": "colNames",
                        "name": "colNames"
                    },
                    {
                        "full": "newValues",
                        "name": "newValues"
                    },
                    {
                        "full": "[filter]",
                        "name": "filter",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [update!](https://docs.dolphindb.cn/zh/funcs/u/update_.html)\n\n\n\n#### 语法\n\nupdate!(table, colNames, newValues, \\[filter])\n\n#### 参数\n\n**table** 是 DolphinDB 中 Table 类型的表。它可以是分区的内存表。\n\n**colNames** 是一个字符串标量/向量，表示要更新的列。\n\n**newValues** 是对指定列的操作的元代码。元代码是对象或表达式，它们包含在<>中。详情请参考元编程。\n\n**filter** 是表示过滤条件的元代码。\n\n#### 详情\n\n就地更新表中的列。如果 *colNames* 中的某列不存在，将会创建新列。如果指定了过滤条件，只有符合过滤条件的记录行会被更新。\n\n如果 *table* 是分区表并且启用了并行处理功能（即配置参数 *localExcutors* > 0），那么该操作是并行操作。\n\n#### 例子\n\n```\nn=20000000\nworkDir = \"C:/DolphinDB/Data\"\nif(!exists(workDir)) mkdir(workDir)\ntrades=table(rand(`IBM`MSFT`GM`C`YHOO`GOOG,n) as sym, 2000.01.01+rand(365,n) as date, 10.0+rand(2.0,n) as price, rand(1000,n) as qty)\ntrades.saveText(workDir + \"/trades.txt\");\n\ntrades = ploadText(workDir + \"/trades.txt\")\nselect top 10 * from trades;\n```\n\n| sym  | date       | price     | qty |\n| ---- | ---------- | --------- | --- |\n| MSFT | 2000.10.09 | 10.123936 | 569 |\n| IBM  | 2000.09.22 | 10.825785 | 834 |\n| MSFT | 2000.09.13 | 10.467937 | 418 |\n| IBM  | 2000.08.06 | 10.159152 | 252 |\n| IBM  | 2000.09.01 | 10.614444 | 400 |\n| MSFT | 2000.05.03 | 10.40847  | 253 |\n| MSFT | 2000.02.20 | 11.470027 | 431 |\n| YHOO | 2000.11.09 | 11.570013 | 518 |\n| GOOG | 2000.03.02 | 10.206973 | 630 |\n| C    | 2000.07.09 | 10.477621 | 287 |\n\n```\ntrades.update!(`qty, <qty+10>)\nselect top 10 * from trades;\n```\n\n| sym  | date       | price     | qty |\n| ---- | ---------- | --------- | --- |\n| MSFT | 2000.10.09 | 10.123936 | 579 |\n| IBM  | 2000.09.22 | 10.825785 | 844 |\n| MSFT | 2000.09.13 | 10.467937 | 428 |\n| IBM  | 2000.08.06 | 10.159152 | 262 |\n| IBM  | 2000.09.01 | 10.614444 | 410 |\n| MSFT | 2000.05.03 | 10.40847  | 263 |\n| MSFT | 2000.02.20 | 11.470027 | 441 |\n| YHOO | 2000.11.09 | 11.570013 | 528 |\n| GOOG | 2000.03.02 | 10.206973 | 640 |\n| C    | 2000.07.09 | 10.477621 | 297 |\n\n```\ntrades.update!(`qty`price, <[qty*2, price/2]>)\nselect top 10 * from trades;\n```\n\n| sym  | date       | price    | qty  |\n| ---- | ---------- | -------- | ---- |\n| MSFT | 2000.10.09 | 5.061968 | 1158 |\n| IBM  | 2000.09.22 | 5.412893 | 1688 |\n| MSFT | 2000.09.13 | 5.233969 | 856  |\n| IBM  | 2000.08.06 | 5.079576 | 524  |\n| IBM  | 2000.09.01 | 5.307222 | 820  |\n| MSFT | 2000.05.03 | 5.204235 | 526  |\n| MSFT | 2000.02.20 | 5.735014 | 882  |\n| YHOO | 2000.11.09 | 5.785007 | 1056 |\n| GOOG | 2000.03.02 | 5.103487 | 1280 |\n| C    | 2000.07.09 | 5.238811 | 594  |\n\n```\ntrades.update!(`qty`price, <[qty*2, price/2]>, <(sym in `IBM`MSFT`GM`GOOG) and date>=2000.07.01>)\nselect top 10 * from trades;\n```\n\n| sym  | date       | price    | qty  |\n| ---- | ---------- | -------- | ---- |\n| MSFT | 2000.10.09 | 2.530984 | 2316 |\n| IBM  | 2000.09.22 | 2.706446 | 3376 |\n| MSFT | 2000.09.13 | 2.616984 | 1712 |\n| IBM  | 2000.08.06 | 2.539788 | 1048 |\n| IBM  | 2000.09.01 | 2.653611 | 1640 |\n| MSFT | 2000.05.03 | 5.204235 | 526  |\n| MSFT | 2000.02.20 | 5.735014 | 882  |\n| YHOO | 2000.11.09 | 5.785007 | 1056 |\n| GOOG | 2000.03.02 | 5.103487 | 1280 |\n| C    | 2000.07.09 | 5.238811 | 594  |\n"
    },
    "upper": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/upper.html",
        "signatures": [
            {
                "full": "upper(X)",
                "name": "upper",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [upper](https://docs.dolphindb.cn/zh/funcs/u/upper.html)\n\n\n\n#### 语法\n\nupper(X)\n\n#### 参数\n\n**X** 是一个字符串标量或向量。\n\n#### 详情\n\n`upper` 函数把字符串或字符串列表中的所有字符转换为大写。\n\n#### 例子\n\n```\nx = `Ibm`C`AapL;\nx.upper();\n// output\n[\"IBM\",\"C\",\"AAPL\"]\n\n(`Thl).upper();\n// output\nTHL\n```\n\n相关函数： [lower](https://docs.dolphindb.cn/zh/funcs/l/lower.html)\n"
    },
    "upsert!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/upsert_.html",
        "signatures": [
            {
                "full": "upsert!(obj, newData, [ignoreNull=false], [keyColNames], [sortColumns])",
                "name": "upsert!",
                "parameters": [
                    {
                        "full": "obj",
                        "name": "obj"
                    },
                    {
                        "full": "newData",
                        "name": "newData"
                    },
                    {
                        "full": "[ignoreNull=false]",
                        "name": "ignoreNull",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[keyColNames]",
                        "name": "keyColNames",
                        "optional": true
                    },
                    {
                        "full": "[sortColumns]",
                        "name": "sortColumns",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [upsert!](https://docs.dolphindb.cn/zh/funcs/u/upsert_.html)\n\n\n\n#### 语法\n\nupsert!(obj, newData, \\[ignoreNull=false], \\[keyColNames], \\[sortColumns])\n\n#### 参数\n\n**obj** 是一个索引内存表、键值内存表，或者 DFS 表（分布式表或维度表）。\n\n**newData** 是一个内存表。\n\n**ignoreNull** 是一个布尔值，表示若 *newData* 中某元素为 NULL 值，是否对目标表中的相应数据进行更新。默认值为 false。\n\n**keyColNames** 是一个字符串标量或向量。由于 DFS 表没有键值列，对 DFS 表进行更新时，将该参数指定的列和分区列一起视为键值列。\n\n**sortColumns** 是一个字符串标量或向量。设置该参数，更新的分区内的所有数据会根据指定的列进行排序。排序在每个分区内部进行，不会跨分区排序。\n\n**Note:**\n\n* 仅 OLAP 引擎下使用 `upsert!` 时，才支持设置 *sortColumns*。\n* 要设置 *sortColumns*， *obj* 必须为分布式表。\n* 仅对同一个分区内的数据 按照 *sortColumns* 进行排序，不同分区之间的数据不会进行排序。\n* *obj* 为一个空表时，设置 *sortColumns* 无效，即更新后不对新插入的数据进行排序。\n* 在 PKEY 引擎下不支持设置 *ignoreNull*, *keyColNames*, *sortColumns*。\n\n#### 详情\n\n将新数据写入索引内存表、键值内存表，或者 DFS 表。若新数据的主键值已存在，更新该主键值的数据；否则添加数据。\n\n**Note:**\n\n* 调用该函数时，需要保证 *newData* 和 *obj* 两表各列的顺序一致，否则可能产生错误结果或报错。\n\n* 若 *keyColNames* 指定的列存在重复值，对重复值进行 `upsert!` 操作，仅会更新第一个值所在行，其余值所在行不会更新。\n\n#### 例子\n\n对键值内存表使用 `upsert!`\n\n```\nsym=`A`B`C\ndate=take(2021.01.06, 3)\nx=1 2 3\ny=5 6 7\nt=keyedTable(`sym`date, sym, date, x, y)\nt;\n```\n\n| sym | date       | x | y |\n| --- | ---------- | - | - |\n| A   | 2021.01.06 | 1 | 5 |\n| B   | 2021.01.06 | 2 | 6 |\n| C   | 2021.01.06 | 3 | 7 |\n\n如果对应列的数据类型一致，就会输出结果。\n\n```\nnewData = table(`A`B`C`D as sym1, take(2021.01.06, 4) as date1, NULL NULL 300 400 as x1, NULL 600 700 800 as y1);\nnewData;\n```\n\n| sym | date       | x1  | y1  |\n| --- | ---------- | --- | --- |\n| A   | 2021.01.06 |     |     |\n| B   | 2021.01.06 |     | 600 |\n| C   | 2021.01.06 | 300 | 700 |\n| D   | 2021.01.06 | 400 | 800 |\n\n```\nupsert!(t, newData, ignoreNull=true)\nt;\n```\n\n| sym | date       | x   | y   |\n| --- | ---------- | --- | --- |\n| A   | 2021.01.06 | 1   | 5   |\n| B   | 2021.01.06 | 2   | 600 |\n| C   | 2021.01.06 | 300 | 700 |\n| D   | 2021.01.06 | 400 | 800 |\n\n以上为将 *ignoreNull* 设为 true 时的情况。此时，若新数据中有元素值为 NULL，不对目标数据表的相应的元素进行更新操作。\n\n以下为将 *ignoreNull* 设为 false（默认值）时的情况，不管新数据中值是否为 NULL，均进行更新操作。\n\n```\nsym=`A`B`C\ndate=take(2021.01.06, 3)\nx=1 2 3\ny=5 6 7\nt=keyedTable(`sym`date, sym, date, x, y)\nupsert!(t, newData)\nt;\n```\n\n| sym | date       | x   | y   |\n| --- | ---------- | --- | --- |\n| A   | 2021.01.06 |     |     |\n| B   | 2021.01.06 |     | 600 |\n| C   | 2021.01.06 | 300 | 700 |\n| D   | 2021.01.06 | 400 | 800 |\n\n对 DFS 表使用 `upsert!`：\n\n```\nID=0 1 2 2\nx=0.1*0..3\nt=table(ID, x)\ndb=database(\"dfs://rangedb128\", VALUE,  0..10)\npt=db.createPartitionedTable(t, `pt, `ID)\npt.append!(t)\nselect * from pt;\n```\n\n| ID | x   |\n| -- | --- |\n| 0  | 0   |\n| 1  | 0.1 |\n| 2  | 0.2 |\n| 2  | 0.3 |\n\n```\nt1=table(1 as ID, 111 as x)\nupsert!(pt, t1, keyColNames=`ID)\nselect * from pt;\n```\n\n| ID | x   |\n| -- | --- |\n| 0  | 0   |\n| 1  | 111 |\n| 2  | 0.2 |\n| 2  | 0.3 |\n\n```\nt1=table(2 as ID, 222 as x)\nupsert!(pt, t1, keyColNames=`ID)\nselect * from pt;\n```\n\n| ID | x   |\n| -- | --- |\n| 0  | 0   |\n| 1  | 111 |\n| 2  | 222 |\n| 2  | 0.3 |\n\n对 DFS 表使用 `upsert!` 更新数据，设置 *ignoreNull* = true，当新数据中有数据值为 NULL, 则不对目标数据表的相应的元素进行更新操作。\n\n```\nif(existsDatabase(\"dfs://valuedemo\")) {\n  dropDatabase(\"dfs://valuedemo\")\n}\ndb = database(\"dfs://valuedemo\", VALUE, 1..10)\nt = table(take(1..10, 100) as id, 1..100 as id2, 100..1 as value)\npt = db.createPartitionedTable(t, \"pt\", `id).append!(t)\nt2 = table( 1 2 as id, 1 2 as id2, 1 NULL as value)\nupsert!(pt, t2, true, \"id2\")\n```\n\n```\nif(existsDatabase(\"dfs://upsert\")) {\n  dropDatabase(\"dfs://upsert\")\n}\nsym=`A`B`C`A`D`B`A\ndate=take(2021.12.10,3) join take(2021.12.09, 3) join 2021.12.10\nprice=8.3 7.2 3.7 4.5 6.3 8.4 7.6\nval=10 19 13 9 19 16 10\nt=table(sym, date, price, val)\ndb=database(\"dfs://upsert\", VALUE,  `A`B`C)\npt=db.createPartitionedTable(t, `pt, `sym)\npt.append!(t)\nt1=table(`A`B`E as sym, take(2021.12.09, 3) as date, 11.1 10.5 6.9 as price, 12 9 11 as val)\nupsert!(pt, t1, keyColNames=`sym, sortColumns=`date`val)\nselect * from pt\n```\n\n| sym | date       | price | val |\n| --- | ---------- | ----- | --- |\n| A   | 2021.12.09 | 4.5   | 9   |\n| A   | 2021.12.09 | 11.1  | 12  |\n| A   | 2021.12.10 | 7.6   | 10  |\n| B   | 2021.12.09 | 10.5  | 9   |\n| B   | 2021.12.09 | 8.4   | 16  |\n| C   | 2021.12.10 | 3.7   | 13  |\n| D   | 2021.12.09 | 6.3   | 19  |\n| E   | 2021.12.09 | 6.9   | 11  |\n"
    },
    "uuid": {
        "url": "https://docs.dolphindb.cn/zh/funcs/u/uuid.html",
        "signatures": [
            {
                "full": "uuid(X)",
                "name": "uuid",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [uuid](https://docs.dolphindb.cn/zh/funcs/u/uuid.html)\n\n\n\n#### 语法\n\nuuid(X)\n\n#### 参数\n\n**X** 是一个字符串标量或向量。\n\n#### 详情\n\n把字符串转换成 UUID 类型。通过 rand(uuid(), n) 可以随机生成 n 个 UUID 类型的数据。\n\n#### 例子\n\n```\nuuid(\"\");\n```\n\n返回：00000000-0000-0000-0000-000000000000\n\n```\na=uuid(\"9d457e79-1bed-d6c2-3612-b0d31c1881f6\");\na;\n```\n\n返回：9d457e79-1bed-d6c2-3612-b0d31c1881f6\n\n```\ntypestr(a);\n```\n\n返回：UUID\n"
    },
    "valueChanged": {
        "url": "https://docs.dolphindb.cn/zh/funcs/v/valueChanged.html",
        "signatures": [
            {
                "full": "valueChanged(X, [mode=\"prev\"])",
                "name": "valueChanged",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[mode=\"prev\"]",
                        "name": "mode",
                        "optional": true,
                        "default": "\"prev\""
                    }
                ]
            }
        ],
        "markdown": "### [valueChanged](https://docs.dolphindb.cn/zh/funcs/v/valueChanged.html)\n\n\n\n#### 语法\n\nvalueChanged(X, \\[mode=\"prev\"])\n\n#### 参数\n\n**X** 字符串、布尔、时间或数值类型的向量/矩阵/表/元组。\n\n**mode** 字符串，可选值为：\"prev\", \"next\", \"any\" 和 \"all\"，默认值为 \"prev\"。\n\n* \"prev\"：前一个元素。\n\n* \"next\"：后一个元素。\n\n* \"any\"：前一个元素或后一个元素。\n\n* \"all\"：前一个元素和后一个元素值。\n\n#### 详情\n\n*X* 中每个元素较 *mode* 是否发生变化，若当前元素值发生变化，则返回 true，否则返回 false。若比较对象不存在，则返回 false。例如：valueChanged(X, \\[mode=\"prev\"]) 的第一个元素返回 false；valueChanged(X, \\[mode=\"next\"]) 的最后一个元素返回 false。\n\n若 *X* 为矩阵/表，在每列内进行上述操作，返回一个矩阵/表。\n\n#### 例子\n\n```\nx= 1 2 2 2 2 3 NULL 3 4 8\nvalueChanged(x)\n// output\n[false,true,false,false,false,true,true,true,true,true]\n\nvalueChanged(x,\"next\")\n// output\n[true,false,false,false,true,true,true,true,true,false]\n\nvalueChanged(x,\"any\")\n// output\n[true,true,false,false,true,true,true,true,true,true]\n\nvalueChanged(x,\"all\")\n// output\n[false,false,false,false,false,true,true,true,true,false]\n\ntup=(1 2 3, `A`A`B`C, 2021.10.12+1 2 2)\nvalueChanged(tup)\n// output\n([false,true,true],[false,false,true,true],[false,true,false])\n\nm=matrix(1 2 3, 1 2 3, 1 3 3)\nvalueChanged(m)\n```\n\n| col1  | col2  | col3  |\n| ----- | ----- | ----- |\n| false | false | false |\n| true  | true  | true  |\n| true  | true  | false |\n\n```\nid= 1 2 2 2 2 3 3 4 8\nsym=`A + string(1 2 2 2 2 3 3 4 8)\nval=83.8 92.8 8.1 61.4 40.7 67.2 15.2 20.6 96.5\nt=table(id, sym, val)\nvalueChanged(t)\n```\n\n| id    | sym   | val   |\n| ----- | ----- | ----- |\n| false | false | false |\n| true  | true  | true  |\n| false | false | true  |\n| false | false | true  |\n| false | false | true  |\n| true  | true  | true  |\n| false | false | true  |\n| true  | true  | true  |\n| true  | true  | true  |\n\n相关函数：[keys](https://docs.dolphindb.cn/zh/funcs/k/keys.html)\n"
    },
    "values": {
        "url": "https://docs.dolphindb.cn/zh/funcs/v/values.html",
        "signatures": [
            {
                "full": "values(X)",
                "name": "values",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [values](https://docs.dolphindb.cn/zh/funcs/v/values.html)\n\n\n\n#### 语法\n\nvalues(X)\n\n#### 参数\n\n**X** 是一个字典或表。\n\n#### 详情\n\n返回字典 *X* 中的所有值，或者以元组形式返回表 *X* 中的所有列。\n\n#### 例子\n\n```\nz=dict(INT,DOUBLE)\nz[5]=7.9\nz[3]=6\nz.values();\n// output\n[6,7.9]\n\nt = table(1 2 3 as id, 4 5 6 as x, `IBM`MSFT`GOOG as name);\nvalues(t);\n// output\n([1,2,3],[4,5,6],[\"IBM\",\"MSFT\",\"GOOG\"])\n```\n\n相关函数：[keys](https://docs.dolphindb.cn/zh/funcs/k/keys.html)\n"
    },
    "vanillaOption": {
        "url": "https://docs.dolphindb.cn/zh/funcs/v/vanillaoption.html",
        "signatures": [
            {
                "full": "vanillaOption(settlement, maturity, evalDate, spot, strike, riskFree, divYield, volatility, isCall, style, basis, calendar, [method=\"BS\"], [kwargs], [mode=0])",
                "name": "vanillaOption",
                "parameters": [
                    {
                        "full": "settlement",
                        "name": "settlement"
                    },
                    {
                        "full": "maturity",
                        "name": "maturity"
                    },
                    {
                        "full": "evalDate",
                        "name": "evalDate"
                    },
                    {
                        "full": "spot",
                        "name": "spot"
                    },
                    {
                        "full": "strike",
                        "name": "strike"
                    },
                    {
                        "full": "riskFree",
                        "name": "riskFree"
                    },
                    {
                        "full": "divYield",
                        "name": "divYield"
                    },
                    {
                        "full": "volatility",
                        "name": "volatility"
                    },
                    {
                        "full": "isCall",
                        "name": "isCall"
                    },
                    {
                        "full": "style",
                        "name": "style"
                    },
                    {
                        "full": "basis",
                        "name": "basis"
                    },
                    {
                        "full": "calendar",
                        "name": "calendar"
                    },
                    {
                        "full": "[method=\"BS\"]",
                        "name": "method",
                        "optional": true,
                        "default": "\"BS\""
                    },
                    {
                        "full": "[kwargs]",
                        "name": "kwargs",
                        "optional": true
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [vanillaOption](https://docs.dolphindb.cn/zh/funcs/v/vanillaoption.html)\n\n\n\n#### 语法\n\nvanillaOption(settlement, maturity, evalDate, spot, strike, riskFree, divYield, volatility, isCall, style, basis, calendar, \\[method=\"BS\"], \\[kwargs], \\[mode=0])\n\n#### 详情\n\n对香草期权（Vanilla Option）进行估值计算。\n\n#### 参数\n\n**settlement** DATE 类型标量或向量，表示期权交易日。\n\n**maturity** DATE 类型标量或向量，表示期权到期日。\n\n**evalDate** DATE 类型标量或向量，表示估值日。\n\n**spot** 数值标量或向量，表示标的资产的当前价格。\n\n**strike** 数值标量或向量，表示标的资产的行权价格。\n\n**riskFree** 数值标量或向量，表示无风险利率。\n\n**divYield** 数值标量或向量，表示分红利率。\n\n**volatility** 数值标量或向量，表示波动率。\n\n**isCall** BOOL 标量或向量，表示是看涨期权还是看跌期权：\n\n* true：表示看涨期权（call option）。\n\n* false：表示看跌期权（put option）。\n\n**style** 字符串标量或向量，表示可行权时间的类型，有两个可选值：\n\n* ‘european’：表示欧式期权。\n\n* ‘american’：表示美式期权。\n\n**basis** 整型标量或向量，表示要使用的日计数基准类型。可选值为：\n\n| Basis | 日计数基准            |\n| ----- | ---------------- |\n| 0     | US (NASD) 30/360 |\n| 1 或省略 | 实际/实际            |\n| 2     | 实际/360           |\n| 3     | 实际/365           |\n| 4     | 欧洲 30/360        |\n\n**calendar** 字符串类型标量或向量，表示使用的市场日历类型，请参阅[交易日历](https://docs.dolphindb.cn/zh/modules/MarketHoliday/mkt_calendar.html#11-%E6%9F%A5%E8%AF%A2%E4%BA%A4%E6%98%93%E6%97%A5%E5%8E%86-getmarketcalendar)。\n\n**method** 可选参数，字符串标量，表示使用的期权估值方法，可选值有：\n\n* ‘BS’：表示 Black-Scholes 方法，默认值，只能用于欧式期权估值。\n\n* 'FDBS'：表示结合有限差分法（Finite Difference Method, FDM）和 Black-Scholes 方法的数值求解方法。\n\n* 'heston'：表示 Heston 模型方法，只能用于欧式期权估值。\n\n* 'FDHeston'：表示结合有限差分法（Finite Difference Method, FDM）和 Heston 模型方法的数值求解方法。\n\n* 'PTDHeston'：表示分段时间依赖的 Heston 模型方法。分段时间依赖：Piecewise Time Dependent，PTD。该方法只能用于欧式期权估值。\n\n**kwargs** 可选参数，字典标量，表示期权估值的其他参数，不同的估值方法有不同的参数要求。当 method = 'BS'时无需填写该参数，其他方法的具体参数要求如下：\n\n* method = 'FDBS'，kwargs应包含以下成员：\n\n  * 'xGrid'：整数标量或向量，表示有限差分法在进行离散化时使用的空间网格数；xGrid 应大于 1。\n\n  * 'tGrid'：整数标量或向量，表示有限差分法在进行离散化时使用的时间网格数。tGrid 应大于 0。\n\n  * 'dampingSteps'：整数标量或向量，表示有限差分求解过程中应用的阻尼步骤数。dampingSteps 应大于等于 0。\n\n* method = 'heston'，kwargs应包含以下成员：\n\n  * 'theta'：数值标量或向量，表示波动率平方的长期均值。\n\n  * 'kappa'：数值标量或向量，表示波动率平方的均值回归速度。\n\n  * 'rho'：数值标量或向量，表示资产价格和波动率的相关系数。\n\n  * 'sigma'：数值标量或向量，表示波动率的波动率。\n\n* method = 'FDHeston'，kwargs 应包含以下成员：\n\n  * 'theta'：数值标量或向量，表示波动率平方的长期均值。\n\n  * 'kappa'：数值标量或向量，表示波动率平方的均值回归速度。\n\n  * 'rho'：数值标量或向量，表示资产价格和波动率的相关系数。\n\n  * 'sigma'：数值标量或向量，表示波动率的波动率。\n\n  * 'xGrid'：整数标量或向量，表示有限差分法在进行离散化时使用的空间网格数；xGrid 应大于 1。\n\n  * 'vGrid'：整数标量或向量，表示有限差分法在进行离散化时使用的波动率网格数；vGrid 应大于 1。\n\n  * 'tGrid'：整数标量或向量，表示有限差分法在进行离散化时使用的时间网格数；tGrid 应大于等于 0。\n\n  * 'dampingSteps'：整数标量或向量，表示有限差分求解过程中应用的阻尼步骤数。dampingSteps 应大于等于 0。\n\n* method = 'PTDHeston'，kwargs 应包含以下成员：\n\n  * 'times'：数值向量或数组向量，表示条件发生变化的时间点。\n\n  * 'theta'：数值向量或数组向量，表示各时间点对应的波动率平方的长期均值。\n\n  * 'kappa'：数值向量或数组向量，表示各时间点对应的波动率平方的均值回归速度。\n\n  * 'rho'：数值向量或数组向量，表示各时间点对应的资产价格和波动率的相关系数。\n\n  * 'sigma'：数值向量或数组向量，表示各时间点对应的波动率的波动率。\n\n  * 注意：所有成员长度应保持一致。\n\n**mode** 选参数，整型标量或向量，表示输出的模式，可选值为：\n\n* 0：只输出期权净现值（npv only），默认值。\n\n* 1：输出期权的净现值和希腊字母，用元组存储，每个元组中依次存放 npv, delta, gamma, theta, vega 和 rho。\n\n* 2：输出期权的净现值和希腊字母，用有序字典存储。\n\n注意：如果输入参数中，部分为标量，其余为向量时，则会将标量当作与向量长度相同，所有元素值等于该标量的向量。所有向量的长度必须一致。\n\n#### 返回值\n\n* 当 mode=0，返回一个浮点数标量或向量，表示期权的净现值。\n\n* 当 mode=1，返回一个浮点数tuple或浮点数tuple构成的向量，表示期权定价结果，包含期权的净现值和希腊字母，顺序是 npv, delta, gamma, theta, vega 和 rho。\n\n* 当 mode=2，返回一个字典标量，表示期权定价结果，包含期权的净现值和希腊字母。\n\n  * 'npv'：DOUBLE 类型标量或向量，表示期权的净现值。\n\n  * 'delta'：DOUBLE 类型标量或向量，希腊字母 Delta 衡量期权价格对标的资产价格小幅变化的敏感度。\n\n  * 'gamma'：DOUBLE 类型标量或向量，希腊字母 Gamma 衡量 Delta 随标的资产价格变化的速率。\n\n  * 'theta'：DOUBLE 类型标量或向量，希腊字母 Theta 衡量期权价格随时间流逝（时间衰减）的敏感度。\n\n  * 'vega'：DOUBLE 类型标量或向量，希腊字母 Vega 衡量期权价格对标的资产隐含波动率小幅变化的敏感度。\n\n  * 'rho'：DOUBLE 类型标量或向量，希腊字母 Rho 衡量期权价格对无风险利率小幅变化的敏感度。\n\n#### 例子\n\n**例1 使用 BS 方法进行估值**\n\n本例对 1998 年 5 月 17 日至 1999 年 5 月 17 日的期权交易，估值日在 1998 年 5 月 15 日；标的资产的当前价格为 36，行权价格为 40；无风险利率为 6%，无分红，波动率为 2%；可行权时间的类型为欧式看跌期权；使用实际/365 的日计数基准类型，中金所交易日历；使用 Black-Scholes 方法，输出期权的净现值和希腊字母的设定下，对其进行估值计算。\n\n```\nsettlement = 1998.05.17\nmaturity = 1999.05.17\nvalDay = 1998.05.15\nspot = 36\nstrike = 40\nriskFree = 0.06\ndividend = 0\nvolatility = 0.2\nisCall = false\nstyle = 'european'\nbasis = 3\ncalendar = 'CCFX'\n\nvanillaOption(settlement, maturity, valDay, spot, strike, riskFree, dividend, volatility, isCall, style, basis, calendar, mode=2)\n\n// Output: \ndelta->-0.549449530255\nrho->-23.753956166156\nnpv->3.844323724572\ntheta->-0.003786247950\ngamma->0.054832432745\nvega->14.290443644841\n```\n\n**例2 使用 PTDHeston 方法进行估值**\n\n本例对 1998 年 5 月 17 日至 1999 年 5 月 17 日的期权交易，估值日在 1998 年 5 月 15 日；标的资产的当前价格为 36，行权价格为 40；无风险利率为 6%，无分红，波动率为 2%；可行权时间的类型为欧式看跌期权；使用实际/365 的日计数基准类型，中金所、上交所交易日历；使用 PTDHeston 方法并传入相关参数，只输出期权净现值的设定下，对其进行估值计算。\n\n```\nsettlement = 1998.05.17\nmaturity = 1999.05.17\nvalDay = 1998.05.15\nspot = 36\nstrike = 40\nriskFree = 0.06\ndividend = 0\nisCall = false\ntimes = array(DOUBLE[], 0).append!( [1.0 2.0 3.0, 1.0 2.0 3.0])\nvolatility = 0.07071\nstyle = 'european'\nbasis = 3\ntheta = [0.010, 0.015, 0.02]\nkappa = [0.600, 0.500, 0.400]\nsigma = [0.400, 0.350, 0.300]\nrho = [-0.15, -0.10, -0.00]\ncalendar = 'CCFX' 'XSHG'\nkwargs = dict(STRING,ANY)\nkwargs[`times] = times\nkwargs[`theta] = theta\nkwargs[`kappa] = kappa\nkwargs[`sigma] = sigma\nkwargs[`rho] = rho\nmethod = 'PTDHeston'\nvanillaOption(settlement, maturity, valDay, spot, strike, riskFree, dividend, volatility, isCall, style, basis, calendar, method, kwargs)\n\n// Output: \n[1.988030590798,1.988030590798]\n```\n"
    },
    "var": {
        "url": "https://docs.dolphindb.cn/zh/funcs/v/var.html",
        "signatures": [
            {
                "full": "var(X)",
                "name": "var",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [var](https://docs.dolphindb.cn/zh/funcs/v/var.html)\n\n\n\n#### 语法\n\nvar(X)\n\n#### 参数\n\n**X** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n若 *X* 为向量，返回 *X* 的方差(variance)。\n\n若 *X* 为矩阵，计算每列的方差，返回一个向量。\n\n若 *X* 为表，计算每列的方差，返回一个表。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n请注意，返回无偏样本方差（unbiased sample variance），而不是总体方差。\n\n#### 例子\n\n```\nvar(1 1 1);\n// output\n0\nvar(1 2 3);\n// output\n1\n\nm=matrix(1 3 5 7 9, 1 4 7 10 13);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 3  | 4  |\n| 5  | 7  |\n| 7  | 10 |\n| 9  | 13 |\n\n```\nvar(m);\n// output\n[10,22.5]\n```\n\n相关函数： [covar](https://docs.dolphindb.cn/zh/funcs/c/covar.html) 和 [corr](https://docs.dolphindb.cn/zh/funcs/c/corr.html)\n"
    },
    "varma": {
        "url": "https://docs.dolphindb.cn/zh/funcs/v/varma.html",
        "signatures": [
            {
                "full": "varma(ds,endogColNames,order,[exog],[trend='c'],[errorCovType='unstructured'],[measurementError=false],[enforceStationarity=true],[enforceInvertibility=true],[trendOffset=1], [maxIter=50])",
                "name": "varma",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "endogColNames",
                        "name": "endogColNames"
                    },
                    {
                        "full": "order",
                        "name": "order"
                    },
                    {
                        "full": "[exog]",
                        "name": "exog",
                        "optional": true
                    },
                    {
                        "full": "[trend='c']",
                        "name": "trend",
                        "optional": true,
                        "default": "'c'"
                    },
                    {
                        "full": "[errorCovType='unstructured']",
                        "name": "errorCovType",
                        "optional": true,
                        "default": "'unstructured'"
                    },
                    {
                        "full": "[measurementError=false]",
                        "name": "measurementError",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[enforceStationarity=true]",
                        "name": "enforceStationarity",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[enforceInvertibility=true]",
                        "name": "enforceInvertibility",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[trendOffset=1]",
                        "name": "trendOffset",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[maxIter=50]",
                        "name": "maxIter",
                        "optional": true,
                        "default": "50"
                    }
                ]
            }
        ],
        "markdown": "### [varma](https://docs.dolphindb.cn/zh/funcs/v/varma.html)\n\n\n\n#### 语法\n\nvarma(ds,endogColNames,order,\\[exog],\\[trend='c'],\\[errorCovType='unstructured'],\\[measurementError=false],\\[enforceStationarity=true],\\[enforceInvertibility=true],\\[trendOffset=1], \\[maxIter=50])\n\n#### 详情\n\n使用向量自回归移动平均模型（Vector Autoregressive Moving-Average Model，简称 VARMA 模型）来分析多变量时间序列。返回一个字典，表示 VARMA 模型的分析结果，详细说明请参见“返回值”小节。\n\n#### 参数\n\n**ds** 一张内存表或者一个 DataSource 类型构成的向量，包含需要分析的多变量时间序列。注意：不可为空。\n\n**endogColNames** 字符串向量，表示 *ds* 中需要分析的多变量时间序列所对应的列名。\n\n**order** 非负整数型向量，长度必须为 2，第一维表示自回归部分（AR）的阶数，第二维表示移动平均部分（MA）的阶数。\n\n**exog** 可选参数，数值矩阵，表示时间序列数据之外的外生变量。矩阵每一列表示一个外生变量的时间序列数据，矩阵行数为时间序列样本数，与 *ds* 的行数相等。\n\n**trend** 可选参数，字符串标量，表示在回归中使用的常数和趋势阶数。可取值：\n\n* ‘c'表示只使用常量，默认值。\n\n* ‘ct'表示使用常量和趋势。\n\n* ’ctt'表示使用常数，线性趋势和二次趋势。\n\n* ’n‘表示不使用常量和趋势。\n\n**errorCovType** 可选参数，字符串标量，表示误差项的协方差矩阵的结构。可取值：\n\n* ’unstructured‘表示会保存协方差矩阵的下三角部分，默认值。\n\n* ’diagonal‘表示只保存对角线部分。\n\n**measurementError** 可选参数，布尔标量，表示输入的多变量时间序列是否存在误差。默认值是 false，表示不存在。\n\n**enforceStationarity** 可选参数，布尔标量，表示是否转换 AR 参数以在模型的自回归分量中增强平稳性。默认值为 true，表示转换。\n\n**enforceInvertibility** 可选参数，布尔标量，表示是否变换 MA 参数以增强模型的移动平均分量的可逆性。默认值为 true，表示转换。\n\n**trendOffset** 可选参数，正整数标量，表示开始时间序列值的偏移量。默认值为 1。\n\n**maxIter** 可选参数，正整数标量，表示拟合时最大的迭代次数，默认值为 50。\n\n#### 返回值\n\n返回一个字典，表示向量自回归移动平均模型的分析结果，字典有以下成员：\n\n* params：浮点数矩阵，表示向量自回归移动平均模型拟合得到的参数。\n\n* kAr：整数标量，表示向量自回归过程的阶数。\n\n* kMa：整数标量，表示向量移动平均部分的阶数。\n\n* kTrend：整数标量，表示向量自回归移动平均模型中的趋势数。\n\n* nobs：整数标量，表示输入的多变量时间序列的信息观测数量。\n\n* aic：浮点数标量，表示 Akaike 信息准则。\n\n* bic：浮点数标量，表示 Bayesian 信息准则。\n\n* hqic：浮点数标量，表示 Hannan-Quinn 信息准则。\n\n* llf：浮点数标量，表示向量自回归移动平均模型的对数似然值。\n\n#### 例子\n\n传入指定的 [macrodata.csv](https://docs.dolphindb.cn/zh/funcs/data/macrodata.csv) 文件，自定义相关参数，计算其使用 VARMA 进行分析的结果。\n\n```\ndata = loadText(\"macrodata.csv\")\nmy_exog = matrix(DOUBLE, size(data), 1,,1)\ntimer result = vectorARMA(data, [`realgdp, `realcons, `realinv],[1,1],trend=\"c\", exog=my_exog)\nprint(result.params)\n\n/* Output:\nparams->[0.001790301048949,0.00316068649919,-0.007884084373724,-0.338899906387031,0.755151620289276,0.058664894089324,-0.133085850042808,0.327149514373616,0.042496018394458,-2.208341476722053,4.608021740892838,0.302452516000534,0.05672697191516,-0.069554114113286,-0.024169851951263,0.030727418751981,-0.05657124857038,-0.015977698360683,0.249792312785792,-0.171657789522291,-0.075503308800943,0.001790301048949,0.00316068649919,-0.007884084373724,0.007688385840775,0.003912860123486,0.005144416435363,0.030336928784212,-0.016066382781189,0.020321167196668]\nllf->1974.199777819503424\nkAr->1\nkMa->1\nkTrend->1\nnobs->202\naic->-3888.399555639006848\nbic->-3789.151524716970925\nhqic->-3848.243622757993762\n*/\n```\n"
    },
    "varp": {
        "url": "https://docs.dolphindb.cn/zh/funcs/v/varp.html",
        "signatures": [
            {
                "full": "varp(X)",
                "name": "varp",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [varp](https://docs.dolphindb.cn/zh/funcs/v/varp.html)\n\n\n\n#### 语法\n\nvarp(X)\n\n#### 参数\n\n**X** 可以是向量、矩阵或表。\n\n#### 详情\n\n若 *X* 为向量，返回 *X* 的总体方差。\n\n若 *X* 为矩阵，计算每列的总体方差，返回一个向量。\n\n若 *X* 为表，计算每列的总体方差，返回一个表。\n\n与所有其它聚合函数一致，计算时忽略 NULL 值。\n\n#### 例子\n\n```\nvarp(1 1 1);\n// output\n0\nvarp(1 2 3);\n// output\n0.666667\n\nm=matrix(1 3 5 7 9, 1 4 7 10 13);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 1  |\n| 3  | 4  |\n| 5  | 7  |\n| 7  | 10 |\n| 9  | 13 |\n\n```\nvarp(m);\n// output\n[8,18]\n```\n\n相关函数： [cumvarp](https://docs.dolphindb.cn/zh/funcs/c/cumvarp.html)\n"
    },
    "valueAtRisk": {
        "url": "https://docs.dolphindb.cn/zh/funcs/v/var_0.html",
        "signatures": [
            {
                "full": "valueAtRisk(returns, method, [confidenceLevel=0.95])",
                "name": "valueAtRisk",
                "parameters": [
                    {
                        "full": "returns",
                        "name": "returns"
                    },
                    {
                        "full": "method",
                        "name": "method"
                    },
                    {
                        "full": "[confidenceLevel=0.95]",
                        "name": "confidenceLevel",
                        "optional": true,
                        "default": "0.95"
                    }
                ]
            }
        ],
        "markdown": "### [valueAtRisk](https://docs.dolphindb.cn/zh/funcs/v/var_0.html)\n\n\n\n#### 语法\n\nvalueAtRisk(returns, method, \\[confidenceLevel=0.95])\n\n#### 详情\n\n风控指标（Value at Risk），用于量化在给定的置信水平（例如 95% 或 99%）和特定时间范围内金融资产可能遭受的最大损失。该函数将返回最低收益率的绝对值，为 DOUBLE 类型。\n\n#### 参数\n\n**returns** 数值型向量，表示收益率序列。注意，表示收益率的每个元素都应大于 -1 且不能为空。\n\n**method** 字符串类型，表示计算 VaR 的方法，可选值为：\n\n* 'normal' 正态参数法。\n\n* 'logNormal' 对数正态参数法。\n\n* 'historical' 历史模拟法。\n\n* 'monteCarlo' 蒙特卡洛模拟法，使用正态分布进行模拟。\n\n**confidenceLevel** 数值型标量，表示置信水平，合法值域为(0,1)，默认值为 0.95。\n\n#### 例子\n\n本例中给定一个假设的收益率序列，通过历史模拟法，计算置信水平为 0.9 的风控指标。\n\n```\nreturns = [0.0, -0.0023816107391389394, -0.0028351258634076834, 0.00789570628538656, 0.0022056267475062397, -0.004515475812603498, 0.0031189325339843646, 0.010774648811452205, 0.0030816164453268957, 0.02172541561228001, 0.011106185767699728, -0.005369098699244845, -0.0096490689793588, 0.0025152212699484314, 0.017822140037111668, -0.02837536728283525, 0.018373545076599204, -0.0026401111537113003, 0.019524374522517898, -0.010800546314337627, 0.014073362622486131, -0.00398277532382243, 0.008398647051501285, 0.0024056749358184904, 0.007093080335863512, -0.005332549248384733, -0.008471915938733665, -0.0038788486165083342, -0.01308504169086584, 0.00350496242864784, 0.009036118926745962, 0.0013358223875250545, 0.0036426642608267563, 0.003974568474545581, -0.003944066366522669, -0.011969668605022311, 0.015116930499066374, 0.006931427295653037, -0.0032650627551519267, 0.003407880132851648]\nvalueAtRisk(returns, 'historical', 0.9);\n//output:0.009764216712\n```\n\n**相关函数**：[condValueAtRisk](https://docs.dolphindb.cn/zh/funcs/c/cvar.html)\n"
    },
    "vectorAR": {
        "url": "https://docs.dolphindb.cn/zh/funcs/v/vectorar.html",
        "signatures": [
            {
                "full": "vectorAR(ds, endogColNames, [exog], [trend='c'], [maxLag], [ic])",
                "name": "vectorAR",
                "parameters": [
                    {
                        "full": "ds",
                        "name": "ds"
                    },
                    {
                        "full": "endogColNames",
                        "name": "endogColNames"
                    },
                    {
                        "full": "[exog]",
                        "name": "exog",
                        "optional": true
                    },
                    {
                        "full": "[trend='c']",
                        "name": "trend",
                        "optional": true,
                        "default": "'c'"
                    },
                    {
                        "full": "[maxLag]",
                        "name": "maxLag",
                        "optional": true
                    },
                    {
                        "full": "[ic]",
                        "name": "ic",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [vectorAR](https://docs.dolphindb.cn/zh/funcs/v/vectorar.html)\n\n\n\n#### 语法\n\nvectorAR(ds, endogColNames, \\[exog], \\[trend='c'], \\[maxLag], \\[ic])\n\n#### 详情\n\n使用向量自回归模型（Vector Autoregression model，简称 VAR 模型）来分析多变量时间序列。\n\n#### 参数\n\n**ds** 一张内存表、或者一个 DataSource 类型构成的向量，包含需要分析的多变量时间序列。注意：不可为空。\n\n**endogColNames** 字符串向量，表示需要分析的内生变量(endogenous variable)在 *ds* 中所对应的列名。通过 *endogColNames* 从 *ds* 中取出的列组成的矩阵，即为需要分析的多变量时间序列数据。\n\n**exog** 可选参数，数值矩阵，表示时间序列数据之外的外生变量。矩阵每一列表示一个外生变量的时间序列数据，矩阵行数为时间序列样本数，须与 *ds* 的行数相等。\n\n**trend** 可选参数，表示在回归中使用的常数和趋势阶数。可选值为：\n\n* 'c'：只使用常数，默认值。\n\n* 'ct'：使用常数和趋势。\n\n* 'ctt'：使用常数、线性趋势和二次趋势。\n\n* 'n'：不适用常数和趋势。\n\n**maxLag** 可选参数，非负整数标量，表示在选择阶数时使用的最大滞后期。传入空值或不填时使用默认值：![](https://docs.dolphindb.cn/zh/funcs/images/vectorar.png) ，nobs 表示样本数量。\n\n**ic** 可选参数，字符串标量，表示在选择阶数时使用的信息准则类型，默认值为空值。可选值为：\n\n* 'aic'：Akaike 信息准则。\n\n* 'bic'：Bayesian 信息准则。\n\n* 'fpe'：Final prediction error，最终预测误差准则。\n\n* 'hqic'：Hannan-Quinn 信息准则。\n\n#### 返回值\n\n返回一个字典，表示向量自回归模型的分析结果，字典有以下成员：\n\n* params：浮点数矩阵，表示向量自回归模型拟合得到的参数。\n\n* kAr：整数标量，表示向量自回归过程的阶数。\n\n* kTrend：整数标量，表示向量自回归过程的趋势数。\n\n* nobs：整数标量，表示向量自回归模型分析过程中的观测数量。\n\n* sigmaU：浮点数矩阵，表示白噪声过程方差的估计值。\n\n* sigmaUMle：浮点数矩阵，表示噪声过程协方差的有偏最大似然估计值。\n\n* aic：浮点数标量，表示 Akaike 信息准则。\n\n* bic：浮点数标量，表示 Bayesian 信息准则。\n\n* hqic：浮点数标量，表示 Hannan-Quinn 信息准则。\n\n* fpe：浮点数标量，表示最终预测误差信息准则。\n\n* llf：浮点数标量，表示向量自回归模型的对数似然值。\n\n#### 例子\n\n本例提供一个 [macrodata.csv](https://docs.dolphindb.cn/zh/funcs/data/macrodata.csv) 文件。取该文件中 realgdp, realcons, realinv 三列作为内生变量，并设置最大滞后期 *maxlag* 为 2，使用 VAR 模型来分析其多变量时间序列。\n\n```\ndata = loadText(\"macrodata.csv\")//该文件需要另外下载，请点击上方文本内的链接\nvectorAR(data, [`realgdp, `realcons, `realinv],,,2)\n\n/*\noutput:\nnobs->200\nhqic->-27.789187688321\nllf->1962.570824044325\nkTrend->1\naic->-27.929339439671\nfpe->0E-12\nparams->\n#0              #1              #2             \n0.001526972352  0.005459603048  -0.023902520885\n-0.279434735873 -0.100467978082 -1.970973673795\n0.675015751748  0.268639552522  4.414162326990 \n0.033219450793  0.025738726522  0.225478953223 \n0.008221084912  -0.123173927706 0.380785849237 \n0.290457628129  0.232499435917  0.800280917529 \n-0.007320907532 0.023503761040  -0.124079061576\nsigmaU->\n#0             #1             #2            \n0.000057113648 0.000029839495 0.000224637467\n0.000029839495 0.000042830532 0.000034191732\n0.000224637467 0.000034191732 0.001567709895\nsigmaUMle->\n#0             #1             #2            \n0.000055114670 0.000028795112 0.000216775156\n0.000028795112 0.000041331464 0.000032995021\n0.000216775156 0.000032995021 0.001512840049\n\nkAr->2\nbic->-27.583016116183\n*/\n```\n"
    },
    "vectorNorm": {
        "url": "https://docs.dolphindb.cn/zh/funcs/v/vectornorm.html",
        "signatures": [
            {
                "full": "vectorNorm(x, [ord], [axis], [keepDims])",
                "name": "vectorNorm",
                "parameters": [
                    {
                        "full": "x",
                        "name": "x"
                    },
                    {
                        "full": "[ord]",
                        "name": "ord",
                        "optional": true
                    },
                    {
                        "full": "[axis]",
                        "name": "axis",
                        "optional": true
                    },
                    {
                        "full": "[keepDims]",
                        "name": "keepDims",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [vectorNorm](https://docs.dolphindb.cn/zh/funcs/v/vectornorm.html)\n\n\n\n#### 语法\n\nvectorNorm(x, \\[ord], \\[axis], \\[keepDims])\n\n#### 说明\n\n计算矩阵/向量的范数。返回值的类型和形式由参数共同决定，可能为 INT 、LONG 或 DOUBLE 类型的标量、向量或矩阵。\n\n注意：该函数在 SQL 中的行为未定义，故不建议在 SQL 中使用。\n\n#### 参数\n\n**x** 传入除 DECIMAL 以外数值类型的向量或矩阵。注意：不可为空。\n\n**ord** 可选参数，整数、浮点数或者字符串类型的标量，用来指定计算的范数类型。注意：\n\n* *ord* 是字符串时，必须是 inf, -inf, nuc, fro 中的一个。\n\n* *ord* 小于 1 时，本函数的计算结果不符合严格数学意义上的“范数”，但对其他计算可能仍然有意义。\n\n如下为传入不同参数 *x* 和 *ord* 时，计算范数的方式说明：\n\n<table id=\"table_op5_23f_fcc\"><thead><tr><th>\n\n*ord*\n\n</th><th>\n\n*x* 为向量\n\n</th><th>\n\n*x* 为矩阵\n\n</th></tr></thead><tbody><tr><td>\n\n不传入\n\n</td><td>\n\n2-norm\n\n</td><td>\n\nFrobenius norm\n\n</td></tr><tr><td>\n\n0\n\n</td><td>\n\nsum(x != 0)\n\n</td><td>\n\n不支持计算\n\n</td></tr><tr><td>\n\n-1\n\n</td><td>\n\nsum(abs(x)^ord)^(1/ord)\n\n</td><td>\n\nmin(sum(abs(x), axis=0))\n\n</td></tr><tr><td>\n\n1\n\n</td><td>\n\nsum(abs(x)^ord)^(1/ord)\n\n</td><td>\n\nmax(sum(abs(x), axis=0))\n\n</td></tr><tr><td>\n\n-2\n\n</td><td>\n\nsum(abs(x)^ord)^(1/ord)\n\n</td><td>\n\n2-norm (largest sing. value)\n\n</td></tr><tr><td>\n\n2\n\n</td><td>\n\nsum(abs(x)^ord)^(1/ord)\n\n</td><td>\n\nsmallest singular value\n\n</td></tr><tr><td>\n\n其他整数或浮点数\n\n</td><td>\n\nsum(abs(x)^ord)^(1/ord)\n\n</td><td>\n\n不支持计算\n\n</td></tr><tr><td>\n\ninf\n\n</td><td>\n\nmax(abs(x))\n\n</td><td>\n\nmax(sum(abs(x), axis=1))\n\n</td></tr><tr><td>\n\n-inf\n\n</td><td>\n\nmin(abs(x))\n\n</td><td>\n\nmin(sum(abs(x), axis=1))\n\n</td></tr><tr><td>\n\nnuc\n\n</td><td>\n\n不支持计算\n\n</td><td>\n\nnuclear norm\n\n</td></tr><tr><td>\n\nfro\n\n</td><td>\n\n不支持计算\n\n</td><td>\n\nFrobenius norm\n\n</td></tr></tbody>\n</table>**axis** 可选参数，整型向量或标量，表示求范数的方向。注意：不可包含空元素。\n\n* 当 *x* 为向量时，*axis* 只能传入标量 0。\n\n* 当 *x* 为矩阵时，*axis*：\n\n  * 长度不能超过 2。\n\n  * 元素不能重复。\n\n  * 元素值的大小不能超过 1，即只能为 0 或 1。\n\n**keepDims** 可选参数，布尔标量，表示返回结果是否和 *x* 的形式保持一致，默认为 false。\n\n#### 例子\n\n若 *x* 为向量，计算传入不同参数后的范数。\n\n```\nx = 1..4\n\nvectorNorm(x) //Output: 5.477225575051661\n\nvectorNorm(x, keepDims=true) //Output: 5.477225575051661\n\nvectorNorm(x, ord=1) //Output: 10\nvectorNorm(x, ord=1, axis=0) //Output: 10 \n\nvectorNorm(x, ord=-1) //Output 0.4800000000000001\nvectorNorm(x, ord=-1, axis=0) //Output double: 10\n\nvectorNorm(x, ord=\"inf\", axis=0) //Output: 4 \nvectorNorm(x, ord=\"-inf\", axis=0) //Output: 1\n\nvectorNorm(x, ord=3) //Output: 4.641588833612778\nvectorNorm(x, ord=-20.689) //Output: 0.9999999714010688\n\nvectorNorm(x, ord=\"fro\") // throw exception\nvectorNorm(x, ord=\"nuc\") // throw exception\n```\n\n若 *x* 为矩阵，计算传入不同参数后的范数。\n\n```\nx = 1..4$2:2\n\nvectorNorm(x) //Output: 5.477225575051661\nvectorNorm(x, keepDims=true) //Output: 5.477225575051661\n\nvectorNorm(x, ord=1) //Output: 7\nvectorNorm(x, ord=1, axis=0) //Output: 3 7 \nvectorNorm(x, ord=1, axis=1) //Output: 4 6\n\nvectorNorm(x, ord=-1, axis=0) //Output: 0.6666666666666666 1.7142857142857144\nvectorNorm(x, ord=-1, axis=1) //Output: 0.75 1.3333333333333333\n\nvectorNorm(x, ord=1, axis=(0 1)) //Output: 7\nvectorNorm(x, ord=1, axis=(1 0)) //Output: 6 \n\nvectorNorm(x, ord=-1, axis=(0 1)) //Output: 3\nvectorNorm(x, ord=-1, axis=(1 0)) //Output: 4 \n\nvectorNorm(x, ord=\"inf\", axis=(0 1)) //Output: 4 \nvectorNorm(x, ord=\"inf\", axis=(1 0)) //Output: 3 \n\nvectorNorm(x, ord=\"-inf\", axis=(0 1)) //Output: 6 \nvectorNorm(x, ord=\"-inf\", axis=(1 0)) //Output: 7 \n\nvectorNorm(x, ord=\"fro\", axis=(1 0)) //Output: 5.477225575051661\nvectorNorm(x, ord=\"fro\", axis=(0 1)) //Output: 5.477225575051661\n\nvectorNorm(x, ord=-2, axis=(1 0)) //Output: 0.3659661906262574\nvectorNorm(x, ord=-2, axis=(0 1)) //Output: 0.3659661906262574\n\nvectorNorm(x, ord=2, axis=(1 0)) //Output: 5.464985704219043\nvectorNorm(x, ord=2, axis=(0 1)) //Output: 5.464985704219043\n\nvectorNorm(x, ord=\"nuc\", axis=(1 0)) //Output: 5.8309518948453\nvectorNorm(x, ord=\"nuc\", axis=(0 1)) //Output: 5.8309518948453\n\nvectorNorm(x, ord=3) // throw exception\n```\n"
    },
    "version": {
        "url": "https://docs.dolphindb.cn/zh/funcs/v/version.html",
        "signatures": [
            {
                "full": "version()",
                "name": "version",
                "parameters": [
                    {
                        "full": "",
                        "name": ""
                    }
                ]
            }
        ],
        "markdown": "### [version](https://docs.dolphindb.cn/zh/funcs/v/version.html)\n\n\n\n#### 语法\n\nversion()\n\n#### 参数\n\n无\n\n#### 详情\n\n返回 DolphinDB 的版本、发布日期，和当前的操作系统版本、特定编译版本（非特定版本不显示）、 CPU 指令集。信息间使用空格隔开。\n\n#### 例子\n\n```\nversion();\n//output: 3.00.0 2024.03.31 LINUX x86_64\n```\n"
    },
    "volumeBar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/v/volumeBar.html",
        "signatures": [
            {
                "full": "volumeBar(X, interval, [label='seq'])",
                "name": "volumeBar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "interval",
                        "name": "interval"
                    },
                    {
                        "full": "[label='seq']",
                        "name": "label",
                        "optional": true,
                        "default": "'seq'"
                    }
                ]
            }
        ],
        "markdown": "### [volumeBar](https://docs.dolphindb.cn/zh/funcs/v/volumeBar.html)\n\n\n\n#### 语法\n\nvolumeBar(X, interval, \\[label='seq'])\n\n#### 参数\n\n**X** 是数值型向量。\n\n**interval** 非零的数值，表示一个定值或百分比。\n\n**label** 为标记分组的方法，有以下三种类型：\n\n* 'seq'：默认值，表示按 0, 1, 2, 3… 的顺序标记组号。\n\n* 'left'：当前分组第一个元素前所有元素的累加和作为组号。第1个分组的组号为 0。\n\n* 'right'：*X* 从第一个元素开始累加到当前分组中最后一个元素的值作为组号。\n\n#### 详情\n\n对 *X* 进行累加，并根据指定的阈值进行分组，返回数据所属分组的组号。分组规则为：\n\n依次累加 *X* 中的元素\n\n* 若阈值为正数，则从第一个元素开始累加，直到累加和大于等于阈值，将这些元素划分为一组。然后从下一个元素重新开始累加，并分组，以此类推。最后剩余的累加和小于阈值的元素划分为一组。\n\n* 若阈值为负数，则从第一个元素开始累加，直到累加和小于等于阈值，将这些元素划分为一组。然后从下一个元素重新开始累加，并分组，以此类推。最后剩余的累加和大于阈值的元素划分为一组。\n\n*interval* 确定了累加分组的阈值，可以是一个定值也可以是一个百分比：\n\n* 当 *interval* ∈ (0, 1) 时， 表示一个百分比，阈值为 sum(X) \\* interval。注意，系统会将阈值转换为与 *X* 相同的类型再进行比较。例如，*X* 是整型，则累加和将与 floor(sum(X) \\* interval)进行比较。\n\n* 否则，*interval* 表示一个定值，即阈值为 *interval*。\n\n#### 例子\n\n```\nX =  1 3 4 2 2 1 1 1 1 6 8\nvolumeBar(X, 4)\n```\n\n输出返回：\\[0,0,1,2,2,3,3,3,3,4,5]\n\n```\nvolumeBar(X, 4, 'left')\n```\n\n输出返回：\\[0,0,4,8,8,12,12,12,12,16,22]\n\n```\nvolumeBar(X, 4, 'right')\n```\n\n输出返回：\\[4,4,8,12,12,16,16,16,16,22,30]\n\n```\nX = -6 2 -4 -5 -1 3 -2 -1\nvolumeBar(X, -2)\n```\n\n输出返回：\\[0,1,1,2,3,3,3,3]\n\n```\nvolumeBar(X, -2, 'left')\n```\n\n输出返回：\\[0,-6,-6,-8,-13,-13,-13,-13]\n\n```\nvolumeBar(X, -2, 'right')\n```\n\n输出返回：\\[-6,-8,-8,-13,-14,-14,-14,-14]\n\n```\nsecurityID = `st001`st002`st001`st002`st001`st002\ntime = 2022.01.01 2022.01.01 2022.01.02 2022.01.02 2022.01.03 2022.01.03\nprice = 30.15 30.21 30.09 30.13 30.18 30.16\nvolume = 190 212 198 211 205 199\nt = table(securityID, time, price, volume)\n\n//每支股票根据 volume 的累加和分组，统计各分组的平均价格。\nselect avg(price) from t group by securityID, contextby(volumeBar{, 400}, volume, securityID) as cumVol\n```\n\n输出返回：\n\n| securityID | cumVol | avg\\_price |\n| ---------- | ------ | ---------- |\n| st001      | 0      | 30.14      |\n| st002      | 0      | 30.17      |\n| st002      | 1      | 30.16      |\n"
    },
    "warmupStreamEngine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/warmupStreamEngine.html",
        "signatures": [
            {
                "full": "warmupStreamEngine(engine, msgs)",
                "name": "warmupStreamEngine",
                "parameters": [
                    {
                        "full": "engine",
                        "name": "engine"
                    },
                    {
                        "full": "msgs",
                        "name": "msgs"
                    }
                ]
            }
        ],
        "markdown": "### [warmupStreamEngine](https://docs.dolphindb.cn/zh/funcs/w/warmupStreamEngine.html)\n\n\n\n#### 语法\n\nwarmupStreamEngine(engine, msgs)\n\n#### 参数\n\n**engine** 是创建流数据引擎时返回的表对象。\n\n**msgs** 是一个数据表。\n\n#### 详情\n\n把数据写入流数据引擎，但是不输出结果。下一批次数据写入此流数据引擎，可以利用已计算的结果来加速计算。\n\n目前仅支持响应式状态引擎，时间序列聚合引擎和日级时间序列引擎。\n\n#### 例子\n\n```\ntrade=table(1000:0, `date`sym`price`volume, [DATE, SYMBOL, DOUBLE, INT])\nn=3000*100\ndate=take(2021.03.08, n)\nsym=take(\"A\"+string(1..3000), n)\nprice=round(rand(100.0, n), 2)\nvolume=rand(100, n)\ntable1 = table(date, sym, price, volume)\noutputTable = table(n:0, `sym`factor1, [STRING,DOUBLE])\nengine = createReactiveStateEngine(\"test\", <ema(volume, 40)>, table1, outputTable, \"sym\")\nwarmupStreamEngine(engine, table1)\ndate=take(2021.03.09, n)\nsym=take(\"A\"+string(1..3000), n)\nprice=round(rand(100.0, n), 2)\nvolume=rand(100, n)\ntable2 = table(date, sym, price, volume)\nengine.append!(table2)\n```\n"
    },
    "wavg": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/wavg.html",
        "signatures": [
            {
                "full": "wavg(X, Y)",
                "name": "wavg",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [wavg](https://docs.dolphindb.cn/zh/funcs/w/wavg.html)\n\n\n\n#### 语法\n\nwavg(X, Y)\n\n#### 参数\n\n**X** 与 **Y** 是向量、矩阵或表。*Y* 表示权重。\n\n#### 详情\n\n对 *X*，以 *Y* 为权重，计算其加权平均数。\n\n请注意，权重向量会自动调整，使得 *X* 向量中非 NULL 之值对应的权重向量之和为1。\n\n#### 例子\n\n```\nwavg(2.2 1.1 3.3, 4 5 6);\n// output\n2.273333\n//  (2.2*4+1.1*5+3.3*6)/(4+5+6)\n\nwavg(1 NULL 1, 1 1 1);\n// output\n1\n```\n\n相关函数：[wsum](https://docs.dolphindb.cn/zh/funcs/w/wsum.html)\n"
    },
    "wc": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/wc.html",
        "signatures": [
            {
                "full": "wc(X)",
                "name": "wc",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [wc](https://docs.dolphindb.cn/zh/funcs/w/wc.html)\n\n\n\n#### 语法\n\nwc(X)\n\n#### 参数\n\n**X** 是一个字符串。它可以是标量或向量。\n\n#### 详情\n\n返回 *X* 中包含的单词数量。\n\n#### 例子\n\n```\nwc(`apple);\n// output\n1\n\nwc(\"This is a 7th generation iphone!\");\n// output\n6\n\nwc(\"This is a 7th generation iphone!\" \"I wonder what the 8th generation looks like\");\n// output\n[6,8]\n```\n"
    },
    "wcovar": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/wcovar.html",
        "signatures": [
            {
                "full": "wcovar(X, Y, W)",
                "name": "wcovar",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "W",
                        "name": "W"
                    }
                ]
            }
        ],
        "markdown": "### [wcovar](https://docs.dolphindb.cn/zh/funcs/w/wcovar.html)\n\n\n\n#### 语法\n\nwcovar(X, Y, W)\n\n#### 参数\n\n**X**, **Y** 和 **W** 是相同长度的数值型向量。\n\n*W* 表示权重。它不能包含 NULL 值。\n\n#### 详情\n\n计算 *X* 和 *Y* 的加权协方差。\n\n#### 例子\n\n```\nx=7 4 5 8 9 3 3 5 2 6 12 1 0 -5 32\ny=1.1 7 8 9 9 5 4 8.6 2 1 -9 -3 5 8 13\nwt=iterate(1,0.9,x.size())\nwcovar(x,y,wt);\n\n// output\n4.201899\n```\n"
    },
    "weekBegin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/weekBegin.html",
        "signatures": [
            {
                "full": "weekBegin(X, [weekday=0], [offset], [n=1])",
                "name": "weekBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weekday=0]",
                        "name": "weekday",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [weekBegin](https://docs.dolphindb.cn/zh/funcs/w/weekBegin.html)\n\n\n\n#### 语法\n\nweekBegin(X, \\[weekday=0], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**weekday** 是0到6之间的整数，0表示星期一，1表示星期二，... ，6表示星期日。默认值为0。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在星期或上一个星期中 *weekday* 对应的日期。\n\n* 如果参数 *weekday* > *weekday* ( *X* , *false* )，返回 *X* 所在星期的上一个星期中 *weekday* 对应的日期。\n\n* 如果参数 *weekday* <= *weekday* ( *X* , *false* )，返回X所在星期中 *weekday* 对应的日期。\n\n如果指定了 *offset* ，表示从 *offset* 开始，结果每隔 *n* 个星期更新一次。\n\n**Note:** 只有当 *n* >1时，*offset* 才会生效。\n\n#### 例子\n\n例1：\n\n```\nt = table(2017.12.01..2017.12.14 as date);\nupdate t set weekday=weekday(date, false), weekBegin=weekBegin(date), weekBegin4=weekBegin(date,4);\nt;\n```\n\n得到：\n\n| date       | weekday | weekBegin  | weekBegin4 |\n| ---------- | ------- | ---------- | ---------- |\n| 2017.12.01 | 4       | 2017.11.27 | 2017.12.01 |\n| 2017.12.02 | 5       | 2017.11.27 | 2017.12.01 |\n| 2017.12.03 | 6       | 2017.11.27 | 2017.12.01 |\n| 2017.12.04 | 0       | 2017.12.04 | 2017.12.01 |\n| 2017.12.05 | 1       | 2017.12.04 | 2017.12.01 |\n| 2017.12.06 | 2       | 2017.12.04 | 2017.12.01 |\n| 2017.12.07 | 3       | 2017.12.04 | 2017.12.01 |\n| 2017.12.08 | 4       | 2017.12.04 | 2017.12.08 |\n| 2017.12.09 | 5       | 2017.12.04 | 2017.12.08 |\n| 2017.12.10 | 6       | 2017.12.04 | 2017.12.08 |\n| 2017.12.11 | 0       | 2017.12.11 | 2017.12.08 |\n| 2017.12.12 | 1       | 2017.12.11 | 2017.12.08 |\n| 2017.12.13 | 2       | 2017.12.11 | 2017.12.08 |\n| 2017.12.14 | 3       | 2017.12.11 | 2017.12.08 |\n\n例2：\n\n```\n t = table(2018.01.03+0..10*3 as date, 0..10 as x);\n update t set weekday=weekday(date, false), weekBegin=weekBegin(date,,2018.01.02,2);\n t;\n```\n\n得到：\n\n| date       | x  | weekday | weekBegin  |\n| ---------- | -- | ------- | ---------- |\n| 2018.01.03 | 0  | 2       | 2018.01.01 |\n| 2018.01.06 | 1  | 5       | 2018.01.01 |\n| 2018.01.09 | 2  | 1       | 2018.01.01 |\n| 2018.01.12 | 3  | 4       | 2018.01.01 |\n| 2018.01.15 | 4  | 0       | 2018.01.15 |\n| 2018.01.18 | 5  | 3       | 2018.01.15 |\n| 2018.01.21 | 6  | 6       | 2018.01.15 |\n| 2018.01.24 | 7  | 2       | 2018.01.15 |\n| 2018.01.27 | 8  | 5       | 2018.01.15 |\n| 2018.01.30 | 9  | 1       | 2018.01.29 |\n| 2018.02.02 | 10 | 4       | 2018.01.29 |\n\n例3：\n\n```\ndate=2012.10.02 2012.10.03 2012.10.07 2012.10.08 2012.10.12 2012.10.16 2012.10.18 2012.10.20 2012.10.25 2012.10.28\ntime=[09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n得到：\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2012.10.02 | 09:34:07 | MSFT | 2200 | 49.6   |\n| 2012.10.03 | 09:36:42 | MSFT | 1900 | 29.46  |\n| 2012.10.07 | 09:36:51 | MSFT | 2100 | 29.52  |\n| 2012.10.08 | 09:36:59 | MSFT | 3200 | 30.02  |\n| 2012.10.12 | 09:32:47 | MSFT | 6800 | 174.97 |\n| 2012.10.16 | 09:35:26 | MSFT | 5400 | 175.23 |\n| 2012.10.18 | 09:34:16 | MSFT | 1300 | 50.76  |\n| 2012.10.20 | 09:34:26 | MSFT | 2500 | 50.32  |\n| 2012.10.25 | 09:38:12 | MSFT | 8800 | 51.29  |\n| 2012.10.28 | 09:38:13 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by weekBegin(date, 4, 2012.10.01, 2);\n```\n\n得到：\n\n| weekBegin\\_date | avg\\_price | sum\\_qty |\n| --------------- | ---------- | -------- |\n| 2012.09.28      | 34.65      | 9400     |\n| 2012.10.12      | 100.514    | 24800    |\n| 2012.10.26      | 52.38      | 4500     |\n\n**Related information**\n\n[week](https://docs.dolphindb.cn/zh/funcs/w/weekEnd.html)\n"
    },
    "weekday": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/weekday.html",
        "signatures": [
            {
                "full": "weekday(X, [startFromSunday=true])",
                "name": "weekday",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[startFromSunday=true]",
                        "name": "startFromSunday",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [weekday](https://docs.dolphindb.cn/zh/funcs/w/weekday.html)\n\n\n\n#### 语法\n\nweekday(X, \\[startFromSunday=true])\n\n#### 参数\n\n**X** 是一个时间标量或向量。\n\n**startFromSunday** 是一个布尔值，表示一周是否从星期日开始。默认值为 true。\n\n#### 详情\n\n返回一个表示与 *X* 对应的一周中日期编号。\n\n如果 *startFromSunday* =true，那么0表示星期日，1表示星期一，...，6表示星期六。如果 *startFromSunday* =false，那么0表示星期一，1表示星期二，...，6表示星期日。\n\n#### 例子\n\n```\nweekday 2012.12.05;\n// output\n3\n\nweekday(2012.12.05, false);\n// output\n2\n\nweekday 2013.05.23T12:00:00;\n// output\n4\n\nweekday(2014.01.11T23:04:28.113);\n// output\n6\n\nweekday 2012.12.05 2012.12.06 2013.01.05;\n// output\n[3,4,6]\n```\n"
    },
    "weekEnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/weekEnd.html",
        "signatures": [
            {
                "full": "weekEnd(X, [weekday=6], [offset], [n=1])",
                "name": "weekEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[weekday=6]",
                        "name": "weekday",
                        "optional": true,
                        "default": "6"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [weekEnd](https://docs.dolphindb.cn/zh/funcs/w/weekEnd.html)\n\n\n\n#### 语法\n\nweekEnd(X, \\[weekday=6], \\[offset], \\[n=1])\n\n别名：week\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**weekday** 是0到6之间的整数，0表示星期一，1表示星期二，... ，6表示星期日。默认值为6。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在星期或下一个星期中 *weekday* 对应的日期。\n\n* 如果参数 *weekday* >= *weekday* ( *X* , *false* )，返回 *X* 所在星期中 *weekday* 对应的日期。\n\n* 如果参数 *weekday* < *weekday* ( *X* , *false* )，返回 *X* 所在星期的下一个星期中 *weekday* 对应的日期。\n\n如果指定了 *offset* ，表示从 *offset* 开始，结果每隔n个星期更新一次。注意，只有当 *n*>1 时，*offset* 才会生效。\n\n#### 例子\n\n例1：\n\n```\nt = table(2017.12.01..2017.12.14 as date)\nupdate t set weekday=weekday(date, false), weekEnd=weekEnd(date), weekEnd4=weekEnd(date,4)\nt;\n```\n\n得到：\n\n| date       | weekday | weekEnd    | weekEnd4   |\n| ---------- | ------- | ---------- | ---------- |\n| 2017.12.01 | 4       | 2017.12.04 | 2017.12.01 |\n| 2017.12.02 | 5       | 2017.12.04 | 2017.12.08 |\n| 2017.12.03 | 6       | 2017.12.04 | 2017.12.08 |\n| 2017.12.04 | 0       | 2017.12.04 | 2017.12.08 |\n| 2017.12.05 | 1       | 2017.12.11 | 2017.12.08 |\n| 2017.12.06 | 2       | 2017.12.11 | 2017.12.08 |\n| 2017.12.07 | 3       | 2017.12.11 | 2017.12.08 |\n| 2017.12.08 | 4       | 2017.12.11 | 2017.12.08 |\n| 2017.12.09 | 5       | 2017.12.11 | 2017.12.15 |\n| 2017.12.10 | 6       | 2017.12.11 | 2017.12.15 |\n| 2017.12.11 | 0       | 2017.12.11 | 2017.12.15 |\n| 2017.12.12 | 1       | 2017.12.18 | 2017.12.15 |\n| 2017.12.13 | 2       | 2017.12.18 | 2017.12.15 |\n| 2017.12.14 | 3       | 2017.12.18 | 2017.12.15 |\n\n例2：\n\n```\nt = table(2018.01.03+0..10*3 as date, 0..10 as x)\nupdate t set weekday=weekday(date, false), weekEnd2=weekEnd(date,,2018.01.02,2)\nt;\n```\n\n得到：\n\n| date       | x  | weekday | weekEnd2   |\n| ---------- | -- | ------- | ---------- |\n| 2018.01.03 | 0  | 2       | 2018.01.08 |\n| 2018.01.06 | 1  | 5       | 2018.01.08 |\n| 2018.01.09 | 2  | 1       | 2018.01.22 |\n| 2018.01.12 | 3  | 4       | 2018.01.22 |\n| 2018.01.15 | 4  | 0       | 2018.01.22 |\n| 2018.01.18 | 5  | 3       | 2018.01.22 |\n| 2018.01.21 | 6  | 6       | 2018.01.22 |\n| 2018.01.24 | 7  | 2       | 2018.02.05 |\n| 2018.01.27 | 8  | 5       | 2018.02.05 |\n| 2018.01.30 | 9  | 1       | 2018.02.05 |\n| 2018.02.02 | 10 | 4       | 2018.02.05 |\n\n例3：\n\n```\ndate=2012.10.02 2012.10.03 2012.10.07 2012.10.08 2012.10.12 2012.10.16 2012.10.18 2012.10.20 2012.10.25 2012.10.28\ntime=[09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n得到：\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2012.10.02 | 09:34:07 | MSFT | 2200 | 49.6   |\n| 2012.10.03 | 09:36:42 | MSFT | 1900 | 29.46  |\n| 2012.10.07 | 09:36:51 | MSFT | 2100 | 29.52  |\n| 2012.10.08 | 09:36:59 | MSFT | 3200 | 30.02  |\n| 2012.10.12 | 09:32:47 | MSFT | 6800 | 174.97 |\n| 2012.10.16 | 09:35:26 | MSFT | 5400 | 175.23 |\n| 2012.10.18 | 09:34:16 | MSFT | 1300 | 50.76  |\n| 2012.10.20 | 09:34:26 | MSFT | 2500 | 50.32  |\n| 2012.10.25 | 09:38:12 | MSFT | 8800 | 51.29  |\n| 2012.10.28 | 09:38:13 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by weekEnd(date, 4, 2012.10.01, 2);\n```\n\n得到：\n\n| weekEnd\\_date | avg\\_price | sum\\_qty |\n| ------------- | ---------- | -------- |\n| 2012.10.05    | 39.53      | 4100     |\n| 2012.10.19    | 92.1       | 18800    |\n| 2012.11.02    | 51.33      | 15800    |\n\n**Related information**\n\n[weekBegin](https://docs.dolphindb.cn/zh/funcs/w/weekBegin.html)\n"
    },
    "weekOfMonth": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/weekOfMonth.html",
        "signatures": [
            {
                "full": "weekOfMonth(X, [week=0], [weekday=0], [offset], [n=1])",
                "name": "weekOfMonth",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[week=0]",
                        "name": "week",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[weekday=0]",
                        "name": "weekday",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [weekOfMonth](https://docs.dolphindb.cn/zh/funcs/w/weekOfMonth.html)\n\n\n\n#### 语法\n\nweekOfMonth(X, \\[week=0], \\[weekday=0], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**week** 是0到3的整数，表示第几个星期。默认值为0。\n\n**weekday** 是0到6之间的整数，表示星期编号。0表示星期一，1表示星期二，... ，6表示星期日。默认值为0。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在月份或上一个月中第 *week* 个 *weekday* 对应的日期。假设 *X* 所在月份的第 *week* 个 *weekday* 对应日期为 d：\n\n如果 *X* < *d* ，*weekOfMonth* 函数返回 *X* 的上一个月中第 *week* 个 *weekday* 对应的日期。\n\n如果 *X* >= *d* ，*weekOfMonth* 函数返回 *X* 所在月份的第 *week* 个 *weekday* 对应的日期。\n\n如果指定了 *offset* ，表示从 *offset* 开始，结果每隔 *n* 个月更新一次。注意，只有当 *n* >1时，*offset* 才会生效。\n\n#### 例子\n\n```\nweekOfMonth(2019.11.01,2,4);\n// output\n2019.10.18\n//2019年11月的第三个星期五为2019.11.15，2019.11.01在2019.11.15之前，因此返回2019年10月的第三个星期五\n\nweekOfMonth(2019.11.20,2,4);\n2019.11.15\n\ndate=2012.01.02 2012.02.03 2012.03.07 2012.04.08 2012.05.12 2012.06.16 2012.07.18 2012.08.20 2012.09.25 2012.10.28\ntime = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nselect avg(price),sum(qty) from t1 group by weekOfMonth(date,3,4,2012.01.01,2);\n```\n\n| weekOfMonth\\_date | avg\\_price | sum\\_qty |\n| ----------------- | ---------- | -------- |\n| 2011.12.23        | 39.53      | 4100     |\n| 2012.02.24        | 29.77      | 5300     |\n| 2012.04.27        | 175.1      | 12200    |\n| 2012.06.22        | 50.54      | 3800     |\n| 2012.08.24        | 51.29      | 8800     |\n| 2012.10.26        | 52.38      | 4500     |\n"
    },
    "weekOfYear": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html",
        "signatures": [
            {
                "full": "weekOfYear(X)",
                "name": "weekOfYear",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [weekOfYear](https://docs.dolphindb.cn/zh/funcs/w/weekOfYear.html)\n\n\n\n#### 语法\n\nweekOfYear(X)\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n#### 详情\n\n计算 *X* 的周数（1\\~53），返回的结果是整型。\n\n**Note:**\n\n* 该函数假设一周的第一天是周日，且每年的第一周至少有4天。\n* 如果12月31日是星期一、星期二或星期三，则该周为下一年的第 01 周。如果是星期四，则该周为刚刚结束的一年的第53周；如果是星期五，则该周为第52周（如果刚刚结束的年份是闰年，则该周为第53周）；如果是周六或周日，则该周为刚刚结束的一年的第52周。\n\n#### 例子\n\n```\nweekOfYear(2012.01.07);\n```\n\n输出返回：1\n\n```\nweekOfYear(2013.01.07);\n```\n\n输出返回：2\n\n```\nweekOfYear(2012.07.02);\n```\n\n输出返回：27\n\n```\nweekOfYear([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n```\n\n输出返回：\\[24,43,1,14]\n\n相关函数：[dayOfYear](https://docs.dolphindb.cn/zh/funcs/d/dayOfYear.html), [dayOfMonth](https://docs.dolphindb.cn/zh/funcs/d/dayOfMonth.html), [quarterOfYear](https://docs.dolphindb.cn/zh/funcs/q/quarterOfYear.html), [monthOfYear](https://docs.dolphindb.cn/zh/funcs/m/monthOfYear.html), [hourOfDay](https://docs.dolphindb.cn/zh/funcs/h/hourOfDay.html), [minuteOfHour](https://docs.dolphindb.cn/zh/funcs/m/minuteOfHour.html), [secondOfMinute](https://docs.dolphindb.cn/zh/funcs/s/secondOfMinute.html), [millisecond](https://docs.dolphindb.cn/zh/funcs/m/millisecond.html), [microsecond](https://docs.dolphindb.cn/zh/funcs/m/microsecond.html), [nanosecond](https://docs.dolphindb.cn/zh/funcs/n/nanosecond.html)\n"
    },
    "wilder": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/wilder.html",
        "signatures": [
            {
                "full": "wilder(X, window)",
                "name": "wilder",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [wilder](https://docs.dolphindb.cn/zh/funcs/w/wilder.html)\n\n\n\n#### 语法\n\nwilder(X, window)\n\nTA-lib 系列函数参数说明和窗口计算规则请参考：[TAlib](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的指数移动平均（Exponential Moving Average），该函数是 [ema](https://docs.dolphindb.cn/zh/funcs/e/ema.html) 的扩展。若 *X* 是向量，返回一个与 *X* 长度相同的向量；若 *X* 是矩阵，在每列内进行上述计算，返回一个与 *X* 维度相同的矩阵。\n\n与 [ema](https://docs.dolphindb.cn/zh/funcs/e/ema.html) 的区别在于，该函数使用 Welles Wilder 指数平滑率，其计算公式为：\n\n![wilderXk](https://docs.dolphindb.cn/zh/images/wilderxk.png)\n\n其中：![wilderXk](https://docs.dolphindb.cn/zh/images/wilderxk_name.png)为第 k 个指数移动平均值，n 为移动窗口长度，![Xk](https://docs.dolphindb.cn/zh/images/xk.png) 为向量 ![X](https://docs.dolphindb.cn/zh/images/x.png) 中第 k 个元素。\n\n#### 例子\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\nwilder(x,3);\n// output\n[,,12.299999999999998,12.466666666666668,12.27777777777778,12.051851851851854,11.767901234567903]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\nwilder(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n| 12.3    | 15.6667 |\n| 12.4667 | 16.7778 |\n| 12.2778 | 18.1852 |\n| 12.0519 | 16.1235 |\n| 11.7679 | 14.0823 |\n\n相关函数：[ema](https://docs.dolphindb.cn/zh/funcs/e/ema.html), [gema](https://docs.dolphindb.cn/zh/funcs/g/gema.html), [tema](https://docs.dolphindb.cn/zh/funcs/t/tema.html)\n"
    },
    "winsorize": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/winsorize.html",
        "signatures": [
            {
                "full": "winsorize(X, limit, [inclusive=true], [nanPolicy='upper'])",
                "name": "winsorize",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "limit",
                        "name": "limit"
                    },
                    {
                        "full": "[inclusive=true]",
                        "name": "inclusive",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[nanPolicy='upper']",
                        "name": "nanPolicy",
                        "optional": true,
                        "default": "'upper'"
                    }
                ]
            }
        ],
        "markdown": "### [winsorize](https://docs.dolphindb.cn/zh/funcs/w/winsorize.html)\n\n\n\n#### 语法\n\nwinsorize(X, limit, \\[inclusive=true], \\[nanPolicy='upper'])\n\n#### 参数\n\n**X** 是一个向量。\n\n**limit** 是一个标量或两个元素组成的向量，表示相对于未屏蔽数据的数目，数组的每一侧要掩盖的百分比，取值为0到1之间。若为标量，表示每侧均要掩盖的百分比。若 *X* 有 n 个元素（包括 NULL值 ），第 (n \\* limit\\[0]) 个最小的元素和第 (n \\* limit\\[1]) 个最大的元素被屏蔽，未屏蔽的数据总数为 n \\*(1-sum(limit))。若 *limit* 中一个元素为0，表示此侧不掩盖。\n\n**inclusive** 是一个标量或两个元素组成的向量，表示在每一侧被屏蔽的数据数量应被截断（true）还是四舍五入（false）。\n\n**nanPolicy** 是一个字符串，表示如何处理 NULL 值。可取以下值，默认值为 'upper'。\n\n* 'upper'：将 NULL 值视为最大值进行掩盖。\n\n* 'lower'：将 NULL 值视为最小值进行掩盖。\n\n* 'raise'：抛出异常。\n\n* 'omit'：不掩盖 NULL 值。\n\n#### 详情\n\n将向量 *X* 中指定百分比的极值掩盖。将第 (limits \\[0]) 个最低值设置为第 (limits \\[0]) 个百分位数，将第 (limits \\[1]) 个最高值设置为第 (1-limits \\[1]) 个百分位数。\n\n`winsorize!` 是 `winsorize` 的原地改变版本。\n\n#### 例子\n\n```\nx=1..10\n// output\nwinsorize(x, 0.1);\n[2,2,3,4,5,6,7,8,9,9]\n\nwinsorize(x, 0.12 0.17);\n// output\n[2,2,3,4,5,6,7,8,9,9]\n\nwinsorize(x, 0.12 0.17, inclusive=false);\n// output\n[2,2,3,4,5,6,7,8,8,8]\n\n\nx=1..20;\nx[19:]=NULL;\nx;\n// output\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,]\n\nwinsorize(x, 0.1);\n// output\n[3,3,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,18,18]\n\nwinsorize(x, 0.1, nanPolicy='upper');\n// output\n[3,3,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,18,18]\n\nwinsorize(x, 0.1, nanPolicy='lower');\n// output\n[2,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,17,17,2]\n```\n"
    },
    "winsorize!": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/winsorize_.html",
        "signatures": [
            {
                "full": "winsorize(X, limit, [inclusive=true], [nanPolicy='upper'])",
                "name": "winsorize",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "limit",
                        "name": "limit"
                    },
                    {
                        "full": "[inclusive=true]",
                        "name": "inclusive",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[nanPolicy='upper']",
                        "name": "nanPolicy",
                        "optional": true,
                        "default": "'upper'"
                    }
                ]
            }
        ],
        "markdown": "### [winsorize!](https://docs.dolphindb.cn/zh/funcs/w/winsorize_.html)\n\n是 [winsorize](https://docs.dolphindb.cn/zh/funcs/w/winsorize.html) 的别名。\n\n\n以下是 `winsorize` 函数的文档：\n### [winsorize](https://docs.dolphindb.cn/zh/funcs/w/winsorize.html)\n\n\n\n#### 语法\n\nwinsorize(X, limit, \\[inclusive=true], \\[nanPolicy='upper'])\n\n#### 参数\n\n**X** 是一个向量。\n\n**limit** 是一个标量或两个元素组成的向量，表示相对于未屏蔽数据的数目，数组的每一侧要掩盖的百分比，取值为0到1之间。若为标量，表示每侧均要掩盖的百分比。若 *X* 有 n 个元素（包括 NULL值 ），第 (n \\* limit\\[0]) 个最小的元素和第 (n \\* limit\\[1]) 个最大的元素被屏蔽，未屏蔽的数据总数为 n \\*(1-sum(limit))。若 *limit* 中一个元素为0，表示此侧不掩盖。\n\n**inclusive** 是一个标量或两个元素组成的向量，表示在每一侧被屏蔽的数据数量应被截断（true）还是四舍五入（false）。\n\n**nanPolicy** 是一个字符串，表示如何处理 NULL 值。可取以下值，默认值为 'upper'。\n\n* 'upper'：将 NULL 值视为最大值进行掩盖。\n\n* 'lower'：将 NULL 值视为最小值进行掩盖。\n\n* 'raise'：抛出异常。\n\n* 'omit'：不掩盖 NULL 值。\n\n#### 详情\n\n将向量 *X* 中指定百分比的极值掩盖。将第 (limits \\[0]) 个最低值设置为第 (limits \\[0]) 个百分位数，将第 (limits \\[1]) 个最高值设置为第 (1-limits \\[1]) 个百分位数。\n\n`winsorize!` 是 `winsorize` 的原地改变版本。\n\n#### 例子\n\n```\nx=1..10\n// output\nwinsorize(x, 0.1);\n[2,2,3,4,5,6,7,8,9,9]\n\nwinsorize(x, 0.12 0.17);\n// output\n[2,2,3,4,5,6,7,8,9,9]\n\nwinsorize(x, 0.12 0.17, inclusive=false);\n// output\n[2,2,3,4,5,6,7,8,8,8]\n\n\nx=1..20;\nx[19:]=NULL;\nx;\n// output\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,]\n\nwinsorize(x, 0.1);\n// output\n[3,3,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,18,18]\n\nwinsorize(x, 0.1, nanPolicy='upper');\n// output\n[3,3,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,18,18]\n\nwinsorize(x, 0.1, nanPolicy='lower');\n// output\n[2,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,17,17,2]\n```\n"
    },
    "wls": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/wls.html",
        "signatures": [
            {
                "full": "wls(Y, X, W, [intercept=true], [mode=0])",
                "name": "wls",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "W",
                        "name": "W"
                    },
                    {
                        "full": "[intercept=true]",
                        "name": "intercept",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[mode=0]",
                        "name": "mode",
                        "optional": true,
                        "default": "0"
                    }
                ]
            }
        ],
        "markdown": "### [wls](https://docs.dolphindb.cn/zh/funcs/w/wls.html)\n\n\n\n#### 语法\n\nwls(Y, X, W, \\[intercept=true], \\[mode=0])\n\n#### 参数\n\n**Y** 是因变量；**X** 是自变量。\n\n**Y** 是一个向量；**X** 是一个矩阵、表或元组。当 *X* 是矩阵时，如果行数等于 *Y* 的长度，*X* 的每一列都是一个因子；如果行数不等于 *Y* 的长度，并且如果列数等于 *Y* 的长度，*X* 的每一行都是一个因子。\n\n**W** 是一个向量，表示权重，各元素为一个非负数。\n\n**intercept** 是一个布尔变量，表示是否包含回归中的截距。默认值是 true。当它为 true 时，系统自动给 *X* 添加一列 \"1\" 以生成截距。\n\n**mode** 是一个整数，默认值为 0，可取以下 3 个值\n\n* 0：输出一个系数估计向量\n\n* 1：输出一个具有系数估计，标准差，t 统计量和 p 值的表\n\n* 2：输出一个具有 ANOVA（方差分析）、RegressionStat（回归统计）、Cofficient（系数）和 Residual（残差）的字典，具体含义见下表：\n\n键 ANOVA 对应值：\n\n| Source of Variance | 自由度（Degree of freedom） | 平方和（Sum of Square） | 均方差（Mean of square） | F统计量          | Significance |\n| ------------------ | ---------------------- | ------------------ | ------------------- | ------------- | ------------ |\n| Regression（回归）     | 变量个数（p）                | 回归平方和（SSR）         | 回归均方差（MSR=SSR/R）    | MSR 对 MSE 的比值 | 显著性，即统计出的P值  |\n| Residual（残差）       | 残差自由度（n-p-1）           | 残差平方和（SSE）         | 残差均方差（MSE=MSE/E）    |               |              |\n| Total              | 样本自由度， 不包括常数项（n-1）     | 总离差平方和（SST）        |                     |               |              |\n\n键 RegressionStat 对应值：\n\n| item         | 统计值                                                             |\n| ------------ | --------------------------------------------------------------- |\n| R2           | R 决定系数，描述回归曲线对真实数据点拟合程度的统计量。范围在\\[0,1]之间，越接近1 ，说明对y的解释能力越强，拟合越好。 |\n| AdjustedR2   | 经自由度修正后的决定系数，通过样本数量与模型数量对 R-squared 进行修正。                       |\n| StdError     | 回归残差标准误差，残差经自由度修正后的标准差。                                         |\n| Observations | 观察样本个数。                                                         |\n\n键 Coefficient 对应值：\n\n| 元素       | 说明                           |\n| -------- | ---------------------------- |\n| factor   | 自变量名称。                       |\n| beta     | 回归系数估计值。                     |\n| stdError | 回归系数标准误差。标准差越大，回归系数的估计值越不靠谱。 |\n| tstat    | T 统计值，衡量系数的统计显著性。            |\n\n键 Residual 对应每一个预测值和实际值之间的残差。\n\n#### 详情\n\n返回对 *X* 和 *Y* 计算加权最小二乘回归的结果。\n\n#### 例子\n\n```\nx1=1 3 5 7 11 16 23\nx2=2 8 11 34 56 54 100\ny=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\nw=rand(10,7)​\nwls(y, x1, w)\n\n// output\n[-17.6177  4.0016]\n\nwls(y, (x1,x2), w);\n\n// output\n[-17.4168  3.0481 0.2214]\n```\n\n```\nwls(y, (x1,x2), w, 1, 1);\n```\n\n| factor    | beta     | stdError | tstat   | pvalue |\n| --------- | -------- | -------- | ------- | ------ |\n| Intercept | -17.4168 | 4.8271   | -3.6081 | 0.0226 |\n| x1        | 3.0481   | 1.6232   | 1.8779  | 0.1336 |\n| x2        | 0.2214   | 0.3699   | 0.5986  | 0.5817 |\n\n```\nwls(y, (x1,x2), w,1, 2);\n\n// output\nCoefficient->\nfactor    beta      stdError tstat     pvalue\n--------- --------- -------- --------- --------\nintercept -10.11392 4.866583 -2.078239 0.106234\nx1        3.938138  2.061191 1.910613  0.128655\nx2        -0.088542 0.446667 -0.198227 0.852534\n\nResidual->[6.452866,3.207839,-3.002812,-5.642629,-6.147264,-12.515038,5.590914]\nRegressionStat->\nitem         statistics\n------------ ----------\nR2           0.957998\nAdjustedR2   0.936997\nStdError     17.172833\nObservations 7\n\nANOVA->\nBreakdown  DF SS           MS           F         Significance\n---------- -- ------------ ------------ --------- ------------\nRegression 2  26905.306594 13452.653297 45.616718 0.001764\nResidual   4  1179.624835  294.906209\nTotal      6  28084.931429\n```\n\n```\nx=matrix(1 4 8 2 3, 1 4 2 3 8, 1 5 1 1 5);\nw=rand(8,5)\nwls(1..5, x,w,0,1);\n```\n\n| factor | beta   | stdError | tstat   | pvalue |\n| ------ | ------ | -------- | ------- | ------ |\n| beta0  | 0.0026 | 1.4356   | 0.0018  | 0.9988 |\n| beta1  | -1     | 1.2105   | -0.8261 | 0.5605 |\n| beta2  | 0.4511 | 0.5949   | 0.7582  | 0.587  |\n| beta3  | 1.687  | 1.7389   | 0.9701  | 0.5097 |\n"
    },
    "wma": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/wma.html",
        "signatures": [
            {
                "full": "wma(X, window)",
                "name": "wma",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "window",
                        "name": "window"
                    }
                ]
            }
        ],
        "markdown": "### [wma](https://docs.dolphindb.cn/zh/funcs/w/wma.html)\n\n\n\n#### 语法\n\nwma(X, window)\n\nTA-lib 系列函数参数说明和窗口计算规则请参考：[TAlib](https://docs.dolphindb.cn/zh/funcs/themes/TAlib.html)\n\n#### 详情\n\n在给定长度（以元素个数衡量）的滑动窗口内，计算 *X* 的加权移动平均（Weighted Moving Average）。\n\n其计算公式为：\n\n![wma](https://docs.dolphindb.cn/zh/images/wma.png)\n\n#### 例子\n\n```\nx=12.1 12.2 12.6 12.8 11.9 11.6 11.2\nwma(x,3);\n// output\n[,,12.383333333333332,12.633333333333334,12.316666666666668,11.9,11.450000000000001]\n\nx=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\nwma(x,3);\n```\n\n| col1    | col2    |\n| ------- | ------- |\n|         |         |\n|         |         |\n| 12.3833 | 16.3333 |\n| 12.6333 | 18      |\n| 12.3167 | 19.8333 |\n| 11.9    | 16.1667 |\n| 11.45   | 12.5    |\n\n相关函数：[sma](https://docs.dolphindb.cn/zh/funcs/s/sma.html), [trima](https://docs.dolphindb.cn/zh/funcs/t/trima.html)\n"
    },
    "write": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/write.html",
        "signatures": [
            {
                "full": "write(handle, object, [offset=0], [length])",
                "name": "write",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "object",
                        "name": "object"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [write](https://docs.dolphindb.cn/zh/funcs/w/write.html)\n\n\n\n#### 语法\n\nwrite(handle, object, \\[offset=0], \\[length])\n\n#### 详情\n\n`write` 函数把指定的缓冲区转换为字节流，并保存到文件中。缓冲区可以是各种数据类型的标量或向量。如果发生了错误，将抛出 IOException。否则，函数返回写入元素的个数（而不是字节数）。`read!` 函数将给定数量的元素读取到缓冲区。例如，如果缓冲区是 INT 向量，该函数将把文件中的字节转换为 INT。`write` 和 `read` 函数都涉及到流和字节之间的转换问题，和计算机科学中多字节的字的0端问题。大端的最重要位位于最低地址，而小端的最不重要位位于最低地址。`write` 函数总是使用操作系统的大小端。如果文件的大小端和操作系统的大小端不同，`read!` 函数将转换大小端。在使用 `file` 函数打开文件时，有可选的布尔参数用于表明文件采用的大小端。默认情况下，采用操作系统的大小端。\n\n#### 例子\n\n```\nx=10h\ny=0h\nfile(\"test.bin\",\"w\").write(x);\n// output\n1\nfile(\"test.bin\",\"r\",true).read!(y);                // 假设文件格式是小端\n// output\n1\ny;\n// output\n10\nfile(\"test.bin\",\"r\",false).read!(y);        // 假设文件格式是大端\n// output\n1\ny;\n// output\n2560\n```\n"
    },
    "writeBytes": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/writeBytes.html",
        "signatures": [
            {
                "full": "writeBytes(handle, bytes)",
                "name": "writeBytes",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "bytes",
                        "name": "bytes"
                    }
                ]
            }
        ],
        "markdown": "### [writeBytes](https://docs.dolphindb.cn/zh/funcs/w/writeBytes.html)\n\n\n\n#### 语法\n\nwriteBytes(handle, bytes)\n\n#### 详情\n\n`writeBytes` 函数把整个缓冲区写入文件。缓冲区必须是一个字符标量或字符向量。如果操作成功，函数返回实际写入的字节数；否则，抛出一个 IOException。\n\n#### 例子\n\n```\n// 定义一个文件复制函数\ndef fileCopy(source, target){\n   s = file(source)\n   len = s.seek(0,TAIL)\n   s.seek(0,HEAD)\n   t = file(target,\"w\")\n   if(len==0) return\n   do{\n       buf = s.readBytes(min(len,1024))\n       t.writeBytes(buf)\n       len -= buf.size()\n   }while(len)\n};\n\nfileCopy(\"test.txt\",\"testcopy.txt\");\n```\n"
    },
    "writeLine": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/writeLine.html",
        "signatures": [
            {
                "full": "writeLine(handle, string, [windowsLineEnding])",
                "name": "writeLine",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "string",
                        "name": "string"
                    },
                    {
                        "full": "[windowsLineEnding]",
                        "name": "windowsLineEnding",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [writeLine](https://docs.dolphindb.cn/zh/funcs/w/writeLine.html)\n\n\n\n#### 语法\n\nwriteLine(handle, string, \\[windowsLineEnding])\n\n#### 参数\n\n可选的布尔型参数 *windowsLineEnding* 是行结束符。如果这个参数没有指定，有三种情况：\n\n* 如果句柄是一个套接字，行结束符是 \\r\\n\n\n* 如果句柄是一个文件，且操作系统不是 Windows，行结束符是 \\n\n\n* 如果句柄是一个文件，且操作系统是 Windows，行结束符是 \\r\\n\n\n#### 详情\n\n在给定的句柄中写一行。函数自动将一个行分隔符添加到字符串结尾。所以字符串不应该以行分隔符结尾。如果该操作成功，函数返回 1；否则，将抛出一个 IOException。\n\n#### 例子\n\n```\nx=`IBM`MSFT`GOOG`YHOO`ORCL\neachRight(writeLine, file(\"test.txt\",\"w\"), x);\n// output\n[1,1,1,1,1]\n\nfin = file(\"test.txt\")\ndo{\n   x=fin.readLine()\n   if(x.isVoid()) break\n   print x\n}\nwhile(true);\n\n// output\nIBM\nMSFT\nGOOG\nYHOO\nORCL\n```\n"
    },
    "writeLines": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/writeLines.html",
        "signatures": [
            {
                "full": "writeLines(handle, object, [offset=0], [length], [windowsLineEnding])",
                "name": "writeLines",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "object",
                        "name": "object"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    },
                    {
                        "full": "[windowsLineEnding]",
                        "name": "windowsLineEnding",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [writeLines](https://docs.dolphindb.cn/zh/funcs/w/writeLines.html)\n\n\n\n#### 语法\n\nwriteLines(handle, object, \\[offset=0], \\[length], \\[windowsLineEnding])\n\n#### 参数\n\n**length** 是往句柄中写入的行数。\n\n其他参数同 [writeLine](https://docs.dolphindb.cn/zh/funcs/w/writeLine.html) 函数。\n\n#### 详情\n\n向句柄中写入给定的行数。\n\n#### 例子\n\n```\ntimer(10){\n   x=rand(`IBM`MSFT`GOOG`YHOO`ORCL,10240)\n   eachRight(writeLine, file(\"test.txt\",\"w\"),x)\n   fin = file(\"test.txt\")\n   do{ y=fin.readLine() } while(!y.isVoid())\n    fin.close()\n};\n\n// output\nTime elapsed: 277.548 ms\n\ntimer(10){\n   x=rand(`IBM`MSFT`GOOG`YHOO`ORCL,10240)\n   file(\"test.txt\",\"w\").writeLines(x)\n   fin = file(\"test.txt\")\n   do{ y=fin.readLines(1024) } while(y.size()==1024)\n   fin.close()\n};\n\n// output\nTime elapsed: 28.003 ms\n\n```\n"
    },
    "writeLog": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/writeLog.html",
        "signatures": [
            {
                "full": "writeLog(X1, [X2, X3....Xn])",
                "name": "writeLog",
                "parameters": [
                    {
                        "full": "X1",
                        "name": "X1"
                    },
                    {
                        "full": "[X2",
                        "name": "[X2"
                    },
                    {
                        "full": "X3....Xn]",
                        "name": "X3....Xn]"
                    }
                ]
            }
        ],
        "markdown": "### [writeLog](https://docs.dolphindb.cn/zh/funcs/w/writeLog.html)\n\n\n\n#### 语法\n\nwriteLog(X1, \\[X2, X3....Xn])\n\n#### 参数\n\n**X1**, **X2**, **X3** ... **Xn** 是要写入日志文件的字符串。每个字符串都是日志文件中的一行。\n\n#### 详情\n\n在日志文件中写入日志。该函数必须要用户登录后才能执行。\n\n#### 例子\n\n```\nwriteLog(\"This is a message written into the log file.\")\nwriteLog(\"line1.\",\"line2.\",\"line3\");\n\n// Check the log file.\n// output\nSun Aug 06 16:41:05 2017 <INFO> :This is a message written into the log file.\nSun Aug 06 16:50:35 2017 <INFO> :line1.\nSun Aug 06 16:50:35 2017 <INFO> :line2.\nSun Aug 06 16:50:35 2017 <INFO> :line3\n```\n"
    },
    "writeLogLevel": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/writeloglevel.html",
        "signatures": [
            {
                "full": "writeLogLevel(level,X1,[X2, X3,...,Xn])",
                "name": "writeLogLevel",
                "parameters": [
                    {
                        "full": "level",
                        "name": "level"
                    },
                    {
                        "full": "X1",
                        "name": "X1"
                    },
                    {
                        "full": "[X2",
                        "name": "[X2"
                    },
                    {
                        "full": "X3",
                        "name": "X3"
                    },
                    {
                        "full": "...",
                        "name": "..."
                    },
                    {
                        "full": "Xn]",
                        "name": "Xn]"
                    }
                ]
            }
        ],
        "markdown": "### [writeLogLevel](https://docs.dolphindb.cn/zh/funcs/w/writeloglevel.html)\n\n\n\n#### 语法\n\nwriteLogLevel(level,X1,\\[X2, X3,...,Xn])\n\n#### 参数\n\n**level** 日志等级，从低到高可选值为：DEBUG, INFO, WARNING, ERROR，分别对应数字 0, 1, 2, 3。\n\n**X1**, **X2**, **X3** ... **Xn** 要写入日志文件的内容。每个 Xi 都是日志文件中的一行。支持以下数据类型：Logical, Integral, Temporal, Floating, Literal, Decimal。\n\n#### 详情\n\n在日志文件中写入指定等级的日志。该命令只能由管理员调用。\n\n**Note:**\n\n*level* 的等级必须等于或高于配置项 *logLevel* 或命令 `setLogLevel` 设置的等级，否则不会输出日志到文件中。\n\n#### 例子\n\n```\nwriteLogLevel(INFO,111111111111,\"This is an INFO message\") \n// Check the log file.\n<INFO> :111111111111\n<INFO> :This is an INFO message\n```\n"
    },
    "writeObject": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/writeObject.html",
        "signatures": [
            {
                "full": "writeObject(handle, object)",
                "name": "writeObject",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "object",
                        "name": "object"
                    }
                ]
            }
        ],
        "markdown": "### [writeObject](https://docs.dolphindb.cn/zh/funcs/w/writeObject.html)\n\n\n\n#### 语法\n\nwriteObject(handle, object)\n\n#### 详情\n\n*object* 是要写入的数据，可以把所有类型的数据结构（包括标量、向量、矩阵、集合、字典和表）写入句柄。该函数必须要用户登录后才能执行。\n\n#### 例子\n\n```\na1=10.5\na2=1..10\na3=cross(*,1..5,1..10)\na4=set(`IBM`MSFT`GOOG`YHOO)\na5=dict(a4.keys(),125.6 53.2 702.3 39.7)\na6=table(1 2 3 as id, `Jenny`Tom`Jack as name)\na7=(1 2 3, \"hello world!\", 25.6);\nfout=file(\"test.bin\",\"w\")\nfout.writeObject(a1)\nfout.writeObject(a2)\nfout.writeObject(a3)\nfout.writeObject(a4)\nfout.writeObject(a5)\nfout.writeObject(a6)\nfout.writeObject(a7)\nfout.close();\n```\n"
    },
    "writeRecord": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/writeRecord.html",
        "signatures": [
            {
                "full": "writeRecord(handle, object, [offset=0], [length])",
                "name": "writeRecord",
                "parameters": [
                    {
                        "full": "handle",
                        "name": "handle"
                    },
                    {
                        "full": "object",
                        "name": "object"
                    },
                    {
                        "full": "[offset=0]",
                        "name": "offset",
                        "optional": true,
                        "default": "0"
                    },
                    {
                        "full": "[length]",
                        "name": "length",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [writeRecord](https://docs.dolphindb.cn/zh/funcs/w/writeRecord.html)\n\n\n\n#### 语法\n\nwriteRecord(handle, object, \\[offset=0], \\[length])\n\n#### 参数\n\n**handle** 是二进制文件句柄。\n\n**object** 是一个表或一个由多个等长向量组成的元组。\n\n**offset** 表示写入的起始位置。\n\n**length** 是向文件写入的行数。\n\n#### 详情\n\n`writeRecord` 函数把 DolphinDB 对象（例如表或元组）转换为二进制文件。函数将返回向文件写入的行数。\n\n#### 例子\n\n```\nt=table(1..10000 as id, 1..10000+100 as value);\n\nf1=file(\"C:/DolphinDB/a.bin\", \"w\");        // 创建一个用于写入记录的文件句柄\nf1.writeRecord(t);\n// output\n10000\n\nf2=file(\"C:/DolphinDB/b.bin\", \"w\");\nf2.writeRecord(t, 100, 1000);\n// output\n1000\n\nf3=file(\"C:/DolphinDB/c.bin\", \"w\");\nf3.writeRecord(t, 100, 10000);\n// output\nThe optional argument length is invalid.\n```\n"
    },
    "wslr": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/wslr.html",
        "signatures": [
            {
                "full": "wslr(Y, X, W, [mse=false])",
                "name": "wslr",
                "parameters": [
                    {
                        "full": "Y",
                        "name": "Y"
                    },
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "W",
                        "name": "W"
                    },
                    {
                        "full": "[mse=false]",
                        "name": "mse",
                        "optional": true,
                        "default": "false"
                    }
                ]
            }
        ],
        "markdown": "### [wslr](https://docs.dolphindb.cn/zh/funcs/w/wslr.html)\n\n\n\n#### 语法\n\nwslr(Y, X, W, \\[mse=false])\n\n#### 参数\n\n**Y** INTEGRAL, FLOATING 或 DECIMAL类型向量，表示因变量。\n\n**X**INTEGRAL, FLOATING 或 DECIMAL类型向量，表示自变量。\n\n**W** INTEGRAL, FLOATING 或 DECIMAL类型向量，表示权重，其元素非负。\n\n**mse**布尔标量，设置是否输出残差均方差。默认值为false，表示不输出。\n\n其中，Y, X, W 的长度必须相等。\n\n#### 详情\n\nwslr 是 weighted single linear regression 的缩写，计算 Y 在 X 上加权线性回归的结果。返回一个元组，其元素依次代表回归系数 beta、截距 alpha 和残差均方差 mse (若有)。\n\n其中\n\n![](https://docs.dolphindb.cn/zh/images/wslr.png)\n\nn 为非空数据个数。\n\n相比于函数 wls：\n\n* wls 以向量的形式返回结果，wslr 返回元组\n\n* wls 是向量函数，wlsr 是聚合函数\n\n* wls 可在查询时应用于分布式表，wlsr 不支持\n\n**Note:** 此函数无法用于分布式表查询。\n\n#### 例子\n\n```\nx = [0.78,0.38,0.2,0.52,0.12,0.49,0.02,0.67,0.94,0.85]\ny = [0.11,0.63,0.19,0.36,0.02,0.35,0.98,0.07,0.55,0.43]\nw = [0.05665,0.155172,0.142857,0.236453,0.125616,0.061576,0.064039,0.051724,0.004926,0.100985]\nwslr(y,x,w)\n//output:(0.385342531009792,-0.076256407696962)\nwslr(y,x,w,true)\n//output:(0.385342531009792,-0.076256407696962,0.007842049148797)\n```\n\n由于 wls 是向量函数，无法直接与 moving 结合使用，需要用户自定义聚合函数。而 wlsr 可直接与 moving 结合使用。\n\n```\ns = [\"001\",\"002\",\"003\",\"004\",\"005\",\"006\",\"007\",\"008\",\"009\",\"010\"]\ny = [0.2531,0.5672,0.8347,0.6436,0.699,0.3732,0.0676,0.9129,0.0167,0.755]\nx = [0.5782,0.8064,0.5035,0.7857,0.5955,0.4156,0.7609,0.093,0.6504,0.9092]\nw = [0,0.095909021199675,0.195930114343433,0.300024080233914,0.408136784222979]\n\nt = table(s,y,x)\nselect moving(wslr{,,w,true},[y,x],5,5) as `bate`alpha`mse from t\n```\n\n| bate                | alpha                | mse                   |\n| ------------------- | -------------------- | --------------------- |\n|                     |                      |                       |\n|                     |                      |                       |\n|                     |                      |                       |\n|                     |                      |                       |\n| 1.0968659790128028  | -0.6117304039349463  | 0.0004078518285504836 |\n| 0.14198850512877909 | 0.7741808484080007   | 0.005713017371341482  |\n| 0.7303333678486678  | -0.6250737654103594  | 0.01852879218352463   |\n| 1.0082522818242372  | -1.1740015481453143  | 0.006523442161727362  |\n| 1.0214599029781481  | -1.4342061326057263  | 0.002086531347398113  |\n| 0.6657822330605759  | -0.25445296261591593 | 0.04738923724610222   |\n"
    },
    "wsum": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/wsum.html",
        "signatures": [
            {
                "full": "wsum(X, Y)",
                "name": "wsum",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [wsum](https://docs.dolphindb.cn/zh/funcs/w/wsum.html)\n\n\n\n#### 语法\n\nwsum(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 和 *Y* 的内积。即使 *X* 和 *Y* 都是整型，返回结果仍为 DOUBLE 类型。\n\n#### 例子\n\n```\nwsum(7 8 9, 1 2 3);\n// output\n50\n// 7*1 + 8*2 + 9*3 = 50\n```\n\n相关函数：[wavg](https://docs.dolphindb.cn/zh/funcs/w/wavg.html)\n"
    },
    "wsum2": {
        "url": "https://docs.dolphindb.cn/zh/funcs/w/wsum2.html",
        "signatures": [
            {
                "full": "wsum2(X, Y)",
                "name": "wsum2",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [wsum2](https://docs.dolphindb.cn/zh/funcs/w/wsum2.html)\n\n\n\n#### 语法\n\nwsum2(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、向量、矩阵或表。\n\n#### 详情\n\n返回 *X* 和 *Y* 的加权平方和。即使 *X* 和 *Y* 都是整型，返回结果仍为 DOUBLE 类型。\n\n#### 例子\n\n```\nwsum2(3 4 1, 1 2 3);\n// output\n44\n// 9*1 + 16*2 + 1*3 = 44\n```\n\n相关函数：[wsum](https://docs.dolphindb.cn/zh/funcs/w/wsum.html)\n"
    },
    "xdb": {
        "url": "https://docs.dolphindb.cn/zh/funcs/x/xdb.html",
        "signatures": [
            {
                "full": "xdb(siteAlias, [userId], [password])",
                "name": "xdb",
                "parameters": [
                    {
                        "full": "siteAlias",
                        "name": "siteAlias"
                    },
                    {
                        "full": "[userId]",
                        "name": "userId",
                        "optional": true
                    },
                    {
                        "full": "[password]",
                        "name": "password",
                        "optional": true
                    }
                ]
            },
            {
                "full": "xdb(host, port, [userId], [password])",
                "name": "xdb",
                "parameters": [
                    {
                        "full": "host",
                        "name": "host"
                    },
                    {
                        "full": "port",
                        "name": "port"
                    },
                    {
                        "full": "[userId]",
                        "name": "userId",
                        "optional": true
                    },
                    {
                        "full": "[password]",
                        "name": "password",
                        "optional": true
                    }
                ]
            }
        ],
        "markdown": "### [xdb](https://docs.dolphindb.cn/zh/funcs/x/xdb.html)\n\n\n\n#### 语法\n\nxdb(siteAlias, \\[userId], \\[password])\n\n或\n\nxdb(host, port, \\[userId], \\[password])\n\n#### 参数\n\n**siteAlias** 是远程节点的别名。它需要在配置文件中定义。\n\n**host** 是远程节点的主机名（IP 地址或站点）。\n\n**port** 是远程节点的端口号。\n\n**userId** 和 **password** 是基于用户的配置文件的。如果管理员启用用户访问控制，需要输入用户名和密码。\n\n#### 详情\n\n连接到节点的远程站点。如果连接成功，则返回远程连接的句柄。\n\n#### 例子\n\n```\nh2=xdb(\"local8081\");\nh2;\n// output\n\"Conn[localhost:8081:1166953221]\"\n\nh21=xdb(\"localhost\",8081);\nh21;\n// output\n\"Conn[localhost:8081:1441295757]\"\n\nh4=xdb(\"local8083\",\"userAdm\",\"passAdm\");\nh4;\n// output\n\"Conn[localhost:8083:1166953221]\"\n\nh41=xdb(\"localhost\",8083, \"user001\",\"pass001\");\nh41;\n// output\n\"Conn[localhost:8083:597793698]\"\n```\n"
    },
    "xor": {
        "url": "https://docs.dolphindb.cn/zh/funcs/x/xor.html",
        "signatures": [
            {
                "full": "xor(X, Y)",
                "name": "xor",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "Y",
                        "name": "Y"
                    }
                ]
            }
        ],
        "markdown": "### [xor](https://docs.dolphindb.cn/zh/funcs/x/xor.html)\n\n\n\n#### 语法\n\nxor(X, Y)\n\n#### 参数\n\n**X** 和 **Y** 可以是标量、数据对、向量、矩阵或表。\n\n#### 详情\n\n按元素逐个返回 *X* 逻辑异或 (`XOR`)*Y* 的结果。\n\n#### 例子\n\n```\n1 xor 0\n// output\n1\n\nx = 5 6 7\nx xor 0\n// output\n[1,1,1]\n\nx = 1 2 3\ny = 2 1 3\nx xor y\n// output\n[0,0,0]\n\ntrue xor false\n// output\n1\n```\n\n相关函数：[or](https://docs.dolphindb.cn/zh/funcs/o/or.html), [not](https://docs.dolphindb.cn/zh/funcs/n/not.html)\n"
    },
    "year": {
        "url": "https://docs.dolphindb.cn/zh/funcs/y/year.html",
        "signatures": [
            {
                "full": "year(X)",
                "name": "year",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [year](https://docs.dolphindb.cn/zh/funcs/y/year.html)\n\n\n\n#### 语法\n\nyear(X)\n\n#### 详情\n\n返回对应的年份。结果的数据类型是 INTEGER。\n\n#### 参数\n\n**X** 是一个时间标量或向量。\n\n#### 例子\n\n```\nyear(2012.12.03);\n```\n\n返回：2012\n\n```\nyear(2012.12.03 2011.11.05);\n```\n\n返回：\\[2012,2011]\n\n```\n(2012.12.03).year();\n```\n\n返回：2012\n"
    },
    "yearBegin": {
        "url": "https://docs.dolphindb.cn/zh/funcs/y/yearBegin.html",
        "signatures": [
            {
                "full": "yearBegin(X, [startingMonth=1], [offset], [n=1])",
                "name": "yearBegin",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[startingMonth=1]",
                        "name": "startingMonth",
                        "optional": true,
                        "default": "1"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [yearBegin](https://docs.dolphindb.cn/zh/funcs/y/yearBegin.html)\n\n\n\n#### 语法\n\nyearBegin(X, \\[startingMonth=1], \\[offset], \\[n=1])\n\n#### 详情\n\n返回 *X* 所在的以 *startingMonth* 为起始月份的年份的第一天。\n\n如果指定了 *offset*，表示从 *offset* 开始，结果每隔 *n* 年更新一次。注意，只有当 *n* >1时，*offset* 才会生效。\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**startingMonth** 是1到12之间的整数，表示一年的起始月份。默认值是1。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 例子\n\n```\nyearBegin(2012.06.12, 10);\n// output\n2011.10.01\n\nyearBegin(2012.06.12, 4);\n// output\n2012.04.01\n\nyearBegin(2012.06.12);\n// output\n2012.01.01\n\nyearBegin(2012.06.12, 1, 2009.04.03, 2);\n// output\n2011.01.01\n\ndate=2011.04.25+(1..10)*365\ntime = take(09:30:00, 10);\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2012.04.24 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2013.04.24 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2014.04.24 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2015.04.24 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.04.23 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2017.04.23 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2018.04.23 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2019.04.23 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2020.04.22 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2021.04.22 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by yearBegin(date, 10, 2010.10.01, 2);\n```\n\n| yearBegin\\_date | avg\\_price | sum\\_qty |\n| --------------- | ---------- | -------- |\n| 2010.10.01      | 49.6       | 2200     |\n| 2012.10.01      | 29.49      | 4000     |\n| 2014.10.01      | 102.495    | 10000    |\n| 2016.10.01      | 112.995    | 6700     |\n| 2018.10.01      | 50.805     | 11300    |\n| 2020.10.01      | 52.38      | 4500     |\n\n相关函数：[yearEnd](https://docs.dolphindb.cn/zh/funcs/y/yearEnd.html), [businessYearBegin](https://docs.dolphindb.cn/zh/funcs/b/businessYearBegin.html), [businessYearEnd](https://docs.dolphindb.cn/zh/funcs/b/businessYearEnd.html)\n"
    },
    "yearEnd": {
        "url": "https://docs.dolphindb.cn/zh/funcs/y/yearEnd.html",
        "signatures": [
            {
                "full": "yearEnd(X, [endingMonth=12], [offset], [n=1])",
                "name": "yearEnd",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[endingMonth=12]",
                        "name": "endingMonth",
                        "optional": true,
                        "default": "12"
                    },
                    {
                        "full": "[offset]",
                        "name": "offset",
                        "optional": true
                    },
                    {
                        "full": "[n=1]",
                        "name": "n",
                        "optional": true,
                        "default": "1"
                    }
                ]
            }
        ],
        "markdown": "### [yearEnd](https://docs.dolphindb.cn/zh/funcs/y/yearEnd.html)\n\n\n\n#### 语法\n\nyearEnd(X, \\[endingMonth=12], \\[offset], \\[n=1])\n\n#### 参数\n\n**X** 可以是 DATE, DATETIME, DATEHOUR, TIMESTAMP 或 NANOTIMESTAMP 类型的标量或向量。\n\n**endingMonth** 是1到12之间的整数，表示一年的结束月份。默认值是12。\n\n**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X* 中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。\n\n**n** 是一个正整数。它是一个可选参数，默认值为1。\n\n#### 详情\n\n返回 *X* 所在的以 *endingMonth* 为结束月份的年份的最后一天。\n\n如果指定了 *offset* ，表示从 *offset* 开始，结果每隔 *n* 年更新一次。注意，只有当 *n* >1时，*offset* 才会生效。\n\n#### 例子\n\n```\nyearEnd(2012.06.12, 3);\n// output\n2013.03.31\n\nyearEnd(2012.06.12, 9);\n// output\n2012.09.30\n\nyearEnd(2012.06.12);\n// output\n2012.12.31\n\nyearEnd(2012.06.12, 12, 2009.04.03, 2);\n// output\n2013.12.31\n\ndate=2011.04.25+(1..10)*365\ntime = take(09:30:00, 10);\nsym = take(`MSFT,10)\nprice= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\nqty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\nt1 = table(date, time, sym, qty, price);\n\nt1;\n```\n\n| date       | time     | sym  | qty  | price  |\n| ---------- | -------- | ---- | ---- | ------ |\n| 2012.04.24 | 09:30:00 | MSFT | 2200 | 49.6   |\n| 2013.04.24 | 09:30:00 | MSFT | 1900 | 29.46  |\n| 2014.04.24 | 09:30:00 | MSFT | 2100 | 29.52  |\n| 2015.04.24 | 09:30:00 | MSFT | 3200 | 30.02  |\n| 2016.04.23 | 09:30:00 | MSFT | 6800 | 174.97 |\n| 2017.04.23 | 09:30:00 | MSFT | 5400 | 175.23 |\n| 2018.04.23 | 09:30:00 | MSFT | 1300 | 50.76  |\n| 2019.04.23 | 09:30:00 | MSFT | 2500 | 50.32  |\n| 2020.04.22 | 09:30:00 | MSFT | 8800 | 51.29  |\n| 2021.04.22 | 09:30:00 | MSFT | 4500 | 52.38  |\n\n```\nselect avg(price),sum(qty) from t1 group by yearEnd(date, 4, 2010.04.01, 2);\n```\n\n| yearEnd\\_date | avg\\_price | sum\\_qty |\n| ------------- | ---------- | -------- |\n| 2012.04.30    | 49.6       | 2200     |\n| 2014.04.30    | 29.49      | 4000     |\n| 2016.04.30    | 102.495    | 10000    |\n| 2018.04.30    | 112.995    | 6700     |\n| 2020.04.30    | 50.805     | 11300    |\n| 2022.04.30    | 52.38      | 4500     |\n\n相关函数：[yearBegin](https://docs.dolphindb.cn/zh/funcs/y/yearBegin.html), [businessYearBegin](https://docs.dolphindb.cn/zh/funcs/b/businessYearBegin.html), [businessYearEnd](https://docs.dolphindb.cn/zh/funcs/b/businessYearEnd.html)\n"
    },
    "zigzag": {
        "url": "https://docs.dolphindb.cn/zh/funcs/z/zigzag.html",
        "signatures": [
            {
                "full": "zigzag(HL, [change=10], [percent=true], [retrace=false], [lastExtreme=true])",
                "name": "zigzag",
                "parameters": [
                    {
                        "full": "HL",
                        "name": "HL"
                    },
                    {
                        "full": "[change=10]",
                        "name": "change",
                        "optional": true,
                        "default": "10"
                    },
                    {
                        "full": "[percent=true]",
                        "name": "percent",
                        "optional": true,
                        "default": "true"
                    },
                    {
                        "full": "[retrace=false]",
                        "name": "retrace",
                        "optional": true,
                        "default": "false"
                    },
                    {
                        "full": "[lastExtreme=true]",
                        "name": "lastExtreme",
                        "optional": true,
                        "default": "true"
                    }
                ]
            }
        ],
        "markdown": "### [zigzag](https://docs.dolphindb.cn/zh/funcs/z/zigzag.html)\n\n\n\n#### 语法\n\nzigzag(HL, \\[change=10], \\[percent=true], \\[retrace=false], \\[lastExtreme=true])\n\n#### 参数\n\n**HL** 数值向量或者包含两列的数值矩阵。\n\n**change** 极值波动的最小阈值。\n\n**percent** 布尔值，表示 *change* 是否是一个百分数。\n\n**retrace** 是一个布尔值，默认为 false。\n\n* true：*change* 当前值相对于前一次波动的回撤。\n\n* false：*change* 当前值相对于两端极值点间的变化。\n\n**Note:**\n\n当 *percent*=false 时， *retrace* 的 true 值将不生效。\n\n**lastExtreme** 布尔值，表示有多个连续且值相同的极值点时，是否输出最后一个极值点，默认为 true。\n\n#### 详情\n\n`zigzag` 主要用于过滤掉 *HL* 中较小波动的值，只有满足条件的极值点会被输出。\n\n若 *HL* 是向量，返回一个与 *HL* 长度相同的向量；若 *HL* 是矩阵，返回与 *HL* 行数相同的向量。\n\n#### 例子\n\n```\nt = table(1.1 2.3 4.45 3.67 4.9 as `low, 1.3 2.8 4.9 3.73 6.28 as `high)\nHL = matrix(t[`low], t[`high])\nzz = zigzag(HL, change=10, percent=true, retrace=false, lastExtreme=true)\nzz;\n```\n\n| 0   | 1 | 2    | 3    | 4   |\n| --- | - | ---- | ---- | --- |\n| 1.2 |   | 4.45 | 3.73 | 4.9 |\n\n```\nHL = 1.2 3 3.1 14 14.5 14.7 25.0 17.8 19 10\nzz = zigzag(HL, change=10, percent=true, retrace=false, lastExtreme=true)\nzz;\n```\n\n| 0   | 1 | 2 | 3 | 4 | 5 | 6  | 7 | 8 | 9  |\n| --- | - | - | - | - | - | -- | - | - | -- |\n| 1.2 |   |   |   |   |   | 25 |   |   | 10 |\n"
    },
    "zscore": {
        "url": "https://docs.dolphindb.cn/zh/funcs/z/zscore.html",
        "signatures": [
            {
                "full": "zscore(X)",
                "name": "zscore",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    }
                ]
            }
        ],
        "markdown": "### [zscore](https://docs.dolphindb.cn/zh/funcs/z/zscore.html)\n\n\n\n#### 语法\n\nzscore(X)\n\n#### 参数\n\n**X** 是一个向量、矩阵或表\n\n#### 详情\n\n若 *X* 为向量，为 *X* 中的每个元素计算标准分数（z-score）。\n\n若 *X* 为矩阵或表，上述计算对每列分别进行。\n\n计算中使用了样本标准差，而不是总体标准差。\n\n#### 例子\n\n```\nzscore(1 2 3 4 5);\n// output\n[-1.264911,-0.632456,0,0.632456,1.264911]\n\nm=matrix(1 2 3, 4 5 6);\nm;\n```\n\n| #0 | #1 |\n| -- | -- |\n| 1  | 4  |\n| 2  | 5  |\n| 3  | 6  |\n\n```\nzscore(m);\n```\n\n| #0 | #1 |\n| -- | -- |\n| -1 | -1 |\n| 0  | 0  |\n| 1  | 1  |\n"
    },
    "zTest": {
        "url": "https://docs.dolphindb.cn/zh/funcs/z/zTest.html",
        "signatures": [
            {
                "full": "zTest(X, [Y], [mu=0.0], [sigmaX=1.0], [sigmaY=1.0], [confLevel=0.95])",
                "name": "zTest",
                "parameters": [
                    {
                        "full": "X",
                        "name": "X"
                    },
                    {
                        "full": "[Y]",
                        "name": "Y",
                        "optional": true
                    },
                    {
                        "full": "[mu=0.0]",
                        "name": "mu",
                        "optional": true,
                        "default": "0.0"
                    },
                    {
                        "full": "[sigmaX=1.0]",
                        "name": "sigmaX",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[sigmaY=1.0]",
                        "name": "sigmaY",
                        "optional": true,
                        "default": "1.0"
                    },
                    {
                        "full": "[confLevel=0.95]",
                        "name": "confLevel",
                        "optional": true,
                        "default": "0.95"
                    }
                ]
            }
        ],
        "markdown": "### [zTest](https://docs.dolphindb.cn/zh/funcs/z/zTest.html)\n\n\n\n#### 语法\n\nzTest(X, \\[Y], \\[mu=0.0], \\[sigmaX=1.0], \\[sigmaY=1.0], \\[confLevel=0.95])\n\n#### 参数\n\n**X** 是一个数值向量，表示用于 Z 检验的样本。\n\n**Y** 是一个数值向量，表示用于独立双样本 Z 检验的另一个样本。它是一个可选参数。\n\n**mu** 是一个浮点数，默认值是0。如果没有指定 *Y*，*mu* 表示 *X* 的均值的假设值；如果指定了 *Y*，*mu* 表示 *X*、*Y* 均值之差的假设值。\n\n**sigmaX** 是一个浮点数，表示 *X* 的标准差。默认值是1。\n\n**sigmaY** 是一个浮点数，表示 *Y* 的标准差。默认值是1。\n\n**confLevel** 是0到1之间的浮点数，表示置信区间的置信水平。\n\n#### 详情\n\n如果没有指定 *Y*，对正态分布 *X* 进行单样本 Z 检验。如果指定了 *Y*，对独立正态分布 *X* 和 *Y* 进行双样本 Z 检验。返回的结果是一个字典，包含以下 key：\n\n* stat：一张表，包含三种不同备择假设下的 p 值和置信区间\n\n* confLevel：置信水平\n\n* method：如果没有指定 *Y*，为字符串 \"One sample z-test\"；如果指定了 *Y*，为字符串 \"Two sample z-test\"\n\n* zValue：z 的统计量\n\n#### 例子\n\n单样本 Z 检验：\n\n```\nx = norm(5.0, 2.0, 30)\nzTest(x, , 5.0, 2.0);\n\n// output\nstat->\n\nalternativeHypothesis       pValue   lowerBound upperBound\n--------------------------- -------- ---------- -----------\ntrue mean is not equal to 5 0.035765 3.517659   4.949014\ntrue mean is less than 5    0.017882 -Infinity  4.833952\ntrue mean is greater than 5 0.982118 3.632721   Infinity\n\nconfLevel->0.95\nmethod->One sample z-test\nzValue->-2.099594\n```\n\n双样本 Z 检验：\n\n```\nx = norm(5.0, 2.0, 30)\ny = norm(10.0, 3.0, 40)\nzTest(x, y, -5.0, 2.0, 3.0);\n\n// output\nstat->\n\n------------------------------------- -------- ---------- -----------\nalternativeHypothesis                 pValue   lowerBound upperBound\ndifference of mean is not equal to -5 0.976133 -6.191162  -3.844655\ndifference of mean is less than -5    0.488067 -Infinity  -4.033283\ndifference of mean is greater than -5 0.511933 -6.002533  Infinity\n\nconfLevel->0.95\nmethod->Two sample z-test\nzValue->-0.029917\n```\n"
    }
}
