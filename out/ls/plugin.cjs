/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib sync recursive":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/ sync ***!
  \*******************************************************************************************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/.pnpm/@hapi+bourne@2.1.0/node_modules/@hapi/bourne/lib/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/@hapi+bourne@2.1.0/node_modules/@hapi/bourne/lib/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";



const internals = {
    suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
};


exports.parse = function (text, ...args) {

    // Normalize arguments

    const firstOptions = typeof args[0] === 'object' && args[0];
    const reviver = args.length > 1 || !firstOptions ? args[0] : undefined;
    const options = (args.length > 1 && args[1]) || firstOptions || {};

    // Parse normally, allowing exceptions

    const obj = JSON.parse(text, reviver);

    // options.protoAction: 'error' (default) / 'remove' / 'ignore'

    if (options.protoAction === 'ignore') {
        return obj;
    }

    // Ignore null and non-objects

    if (!obj ||
        typeof obj !== 'object') {

        return obj;
    }

    // Check original string for potential exploit

    if (!text.match(internals.suspectRx)) {
        return obj;
    }

    // Scan result for proto keys

    exports.scan(obj, options);

    return obj;
};


exports.scan = function (obj, options = {}) {

    let next = [obj];

    while (next.length) {
        const nodes = next;
        next = [];

        for (const node of nodes) {
            if (Object.prototype.hasOwnProperty.call(node, '__proto__')) {      // Avoid calling node.hasOwnProperty directly
                if (options.protoAction !== 'remove') {
                    throw new SyntaxError('Object contains forbidden prototype property');
                }

                delete node.__proto__;
            }

            for (const key in node) {
                const value = node[key];
                if (value &&
                    typeof value === 'object') {

                    next.push(node[key]);
                }
            }
        }
    }
};


exports.safeParse = function (text, reviver) {

    try {
        return exports.parse(text, reviver);
    }
    catch (ignoreError) {
        return null;
    }
};


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/index.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/index.js ***!
  \******************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const electron_not_supported_1 = __importDefault(__webpack_require__(/*! ./lib/exception/electron-not-supported */ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/exception/electron-not-supported.js"));
const missing_module_1 = __importDefault(__webpack_require__(/*! ./lib/exception/missing-module */ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/exception/missing-module.js"));
const require_1 = __importStar(__webpack_require__(/*! ./lib/require */ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/require.js"));
const log_1 = __webpack_require__(/*! @sqltools/log */ "./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/index.js");
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
const vscode_uri_1 = __webpack_require__(/*! vscode-uri */ "./node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/umd/index.js");
class AbstractDriver {
    constructor(credentials, getWorkspaceFolders) {
        this.credentials = credentials;
        this.getWorkspaceFolders = getWorkspaceFolders;
        this.deps = [];
        this.queryResults = (query, opt) => __awaiter(this, void 0, void 0, function* () {
            const result = yield this.singleQuery(query, opt);
            if (result.error)
                throw result.rawError;
            return result.results;
        });
        this.requireDep = (name) => {
            return require_1.default(name);
        };
        this.resolveDep = (name) => {
            return require_1.sqltoolsResolve(name);
        };
        this.log = log_1.createLogger(credentials.driver.toLowerCase());
    }
    getId() {
        return this.credentials.id;
    }
    singleQuery(query, opt) {
        return this.query(query, opt).then(([res]) => res);
    }
    describeTable(metadata, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.singleQuery(this.queries.describeTable(metadata), opt);
            result.baseQuery = this.queries.describeTable.raw;
            return [result];
        });
    }
    showRecords(table, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const { limit, page = 0 } = opt;
            const params = Object.assign(Object.assign({}, opt), { limit, table, offset: page * limit });
            if (typeof this.queries.fetchRecords === 'function' && typeof this.queries.countRecords === 'function') {
                const [records, totalResult] = yield (Promise.all([
                    this.singleQuery(this.queries.fetchRecords(params), opt),
                    this.singleQuery(this.queries.countRecords(params), opt),
                ]));
                records.baseQuery = this.queries.fetchRecords.raw;
                records.pageSize = limit;
                records.page = page;
                records.total = Number(totalResult.results[0].total);
                records.queryType = 'showRecords';
                records.queryParams = table;
                return [records];
            }
            return this.query(this.queries.fetchRecords(params), opt);
        });
    }
    checkDependencies() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.deps || this.deps.length === 0)
                return;
            if (Number(process.env.IS_NODE_RUNTIME || '0') !== 1) {
                throw new electron_not_supported_1.default();
            }
            this.deps.forEach(dep => {
                let mustUpgrade = false;
                switch (dep.type) {
                    case AbstractDriver.CONSTANTS.DEPENDENCY_PACKAGE:
                        try {
                            const { version } = JSON.parse(fs_1.default.readFileSync(this.resolveDep(dep.name + '/package.json')).toString());
                            if (dep.version && version !== dep.version) {
                                mustUpgrade = true;
                                throw new Error(`Version not matching. We need to upgrade ${dep.name}`);
                            }
                            this.requireDep(dep.name);
                        }
                        catch (e) {
                            throw new missing_module_1.default(this.deps, this.credentials, mustUpgrade);
                        }
                        break;
                }
            });
        });
    }
    getChildrenForItem(_params) {
        this.log.error(`###### Attention ######\getChildrenForItem not implemented for ${this.credentials.driver}\n####################`);
        return Promise.resolve([]);
    }
    searchItems(_itemType, _search, _extraParams) {
        this.log.error(`###### Attention ######\searchItems not implemented for ${this.credentials.driver}\n####################`);
        return Promise.resolve([]);
    }
    toAbsolutePath(fsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!path_1.default.isAbsolute(fsPath) && /\$\{workspaceFolder:(.+)}/g.test(fsPath)) {
                const workspaceName = fsPath.match(/\$\{workspaceFolder:(.+)}/)[1];
                if (workspaceName) {
                    const workspaceFolders = yield this.getWorkspaceFolders();
                    const dbWorkspace = workspaceFolders.find(w => w.name === workspaceName);
                    fsPath = path_1.default.resolve(vscode_uri_1.URI.parse(dbWorkspace.uri, true).fsPath, fsPath.replace(/\$\{workspaceFolder:(.+)}/g, './'));
                }
            }
            return fsPath;
        });
    }
    prepareMessage(message) {
        return { message: message.toString(), date: new Date() };
    }
}
exports["default"] = AbstractDriver;
AbstractDriver.CONSTANTS = {
    DEPENDENCY_PACKAGE: 'package',
    DEPENDENCY_NPM_SCRIPT: 'npmscript',
};


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/exception/electron-not-supported.js":
/*!*************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/exception/electron-not-supported.js ***!
  \*************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElectronNotSupportedError = void 0;
const response_error_1 = __importDefault(__webpack_require__(/*! ./response-error */ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/exception/response-error.js"));
const notification_1 = __webpack_require__(/*! ../notification */ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/notification.js");
class ElectronNotSupportedError extends response_error_1.default {
    constructor(message = `Electron is not supported. You should enable \'sqltools.useNodeRuntime\' and have NodeJS installed to continue.`) {
        super(1001, message, {
            notification: notification_1.ElectronNotSupportedNotification,
            dontNotify: true
        });
    }
}
exports.ElectronNotSupportedError = ElectronNotSupportedError;
exports["default"] = ElectronNotSupportedError;


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/exception/missing-module.js":
/*!*****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/exception/missing-module.js ***!
  \*****************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MissingModuleError = void 0;
const response_error_1 = __importDefault(__webpack_require__(/*! ./response-error */ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/exception/response-error.js"));
const notification_1 = __webpack_require__(/*! ../notification */ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/notification.js");
class MissingModuleError extends response_error_1.default {
    constructor(deps, conn, mustUpgrade = false) {
        super(1000, `Missing module "${deps.map((d, i) => `${d.name}@${d.version || 'latest'}${i === deps.length - 2 ? ' and ' : (i === deps.length - 1 ? '' : ', ')}`).join('')}". Need to ${mustUpgrade ? 'upgrade' : 'install'}.`, {
            notification: notification_1.MissingModuleNotification,
            dontNotify: true,
            args: {
                conn,
                action: mustUpgrade ? 'upgrade' : 'install',
                deps,
            }
        });
    }
}
exports.MissingModuleError = MissingModuleError;
exports["default"] = MissingModuleError;


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/exception/response-error.js":
/*!*****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/exception/response-error.js ***!
  \*****************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotifyResponseError = void 0;
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/main.js");
class NotifyResponseError extends vscode_languageserver_1.ResponseError {
    constructor(code, message, data) {
        super(code, message, data);
    }
}
exports.NotifyResponseError = NotifyResponseError;
exports["default"] = NotifyResponseError;


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/factory.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/factory.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const queryFactory = (pieces, ...placeholders) => {
    function queryConstructor(params = {}) {
        return pieces
            .reduce((q, piece, index) => {
            const ph = placeholders[index];
            q += piece.replace(/\r?\n\s+/g, ' ');
            if (typeof ph !== 'undefined') {
                q += (typeof ph !== 'function' ? ph : ph(params));
            }
            return q;
        }, '')
            .trim();
    }
    queryConstructor.raw = pieces
        .reduce((q, piece, index) => {
        const ph = placeholders[index];
        q += piece.replace(/\r?\n\s+/g, ' ');
        if (typeof ph !== 'undefined') {
            q += '${' + ph.toString() + '}';
        }
        return q;
    }, '')
        .trim();
    return queryConstructor;
};
exports["default"] = queryFactory;


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/notification.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/notification.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MissingModuleNotification = exports.ElectronNotSupportedNotification = void 0;
exports.ElectronNotSupportedNotification = 'Core/electronNotSupported';
exports.MissingModuleNotification = 'Core/missingModule';


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/require.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/require.js ***!
  \************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sqltoolsResolve = void 0;
const env_paths_1 = __importDefault(__webpack_require__(/*! env-paths */ "./node_modules/.pnpm/env-paths@2.2.1/node_modules/env-paths/index.js"));
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
const resolve_1 = __webpack_require__(/*! resolve */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/index.js");
const mkdir = __importStar(__webpack_require__(/*! make-dir */ "./node_modules/.pnpm/make-dir@3.1.0/node_modules/make-dir/index.js"));
const SQLTOOLS_PATHS = env_paths_1.default(`vscode-${process.env.EXT_NAMESPACE || 'sqltools'}`, { suffix: null });
if (!fs_1.default.existsSync(SQLTOOLS_PATHS.data)) {
    mkdir.sync(SQLTOOLS_PATHS.data);
}
if (!fs_1.default.existsSync(getDataPath('node_modules'))) {
    mkdir.sync(getDataPath('node_modules'));
}
function getDataPath(...args) {
    return path_1.default.resolve(SQLTOOLS_PATHS.data, ...args);
}
exports.sqltoolsResolve = (name) => resolve_1.sync(name, { basedir: getDataPath() });
const sqltoolsRequire = (name) => __webpack_require__("./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib sync recursive")(exports.sqltoolsResolve(name));
exports["default"] = sqltoolsRequire;


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/index.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.createLogger = void 0;
var logger;
var isVSCodeContext = function () {
    try {
        /*require.resolve*/(/*! vscode */ "vscode");
        return true;
    }
    catch (error) {
        return false;
    }
};
if (process.env.PRODUCT === 'ext' && isVSCodeContext()) {
    logger = (__webpack_require__(/*! ./lib/vscode */ "./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/lib/vscode.js")["default"]);
}
else {
    logger = (__webpack_require__(/*! ./lib/general */ "./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/lib/general.js")["default"]);
}
function createLogger(ns, bindings) {
    if (bindings === void 0) { bindings = {}; }
    if (!ns)
        return logger;
    return logger.child(__assign(__assign({}, bindings), { ns: ns }));
}
exports.createLogger = createLogger;
exports["default"] = logger;


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/lib/factory.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/lib/factory.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var pino_1 = __importDefault(__webpack_require__(/*! pino */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/pino.js"));
function factory(opts, stream) {
    if (opts === void 0) { opts = {}; }
    var logger = pino_1["default"](__assign({ name: process.env.PRODUCT || 'UNINDENTIFIED', base: {}, level:  true ? 'debug' : 0, formatters: {
            level: function (level) { return { level: level }; }
        }, prettyPrint: true }, opts), stream);
    logger.show = function () { return void 0; };
    return logger;
}
exports["default"] = factory;


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/lib/general.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/lib/general.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var factory_1 = __importDefault(__webpack_require__(/*! ./factory */ "./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/lib/factory.js"));
exports["default"] = factory_1["default"]();


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/lib/vscode.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/lib/vscode.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
if (process.env.PRODUCT !== 'ext') {
    throw 'Cant use outputchannels outside of VSCode context';
}
var stream_1 = __webpack_require__(/*! stream */ "stream");
var vscode_1 = __webpack_require__(/*! vscode */ "vscode");
var factory_1 = __importDefault(__webpack_require__(/*! ./factory */ "./node_modules/.pnpm/@sqltools+log@1.0.3/node_modules/@sqltools/log/dist/lib/factory.js"));
var outputChannel = vscode_1.window.createOutputChannel(process.env.DISPLAY_NAME || 'SQLTools');
var writableStream = new stream_1.Writable({
    write: function (chunk, _, done) {
        outputChannel.append(chunk.toString(chunk.encoding || 'utf8'));
        done();
    },
    writev: function (chunks, done) {
        chunks.forEach(function (i) { return outputChannel.append(i.chunk.toString(i.encoding || 'utf8')); });
        done();
    }
});
var logger = factory_1["default"]({}, writableStream);
logger.clear = outputChannel.clear.bind(outputChannel);
logger.outputChannel = outputChannel;
logger.show = function () { return outputChannel.show(); };
exports["default"] = logger;


/***/ }),

/***/ "./node_modules/.pnpm/@sqltools+types@0.1.7_vscode-languageserver-protocol@3.17.5/node_modules/@sqltools/types/index.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sqltools+types@0.1.7_vscode-languageserver-protocol@3.17.5/node_modules/@sqltools/types/index.js ***!
  \******************************************************************************************************************************/
/***/ ((module) => {

const ContextValue = {
  'CONNECTION': 'connection',
  'CONNECTED_CONNECTION': 'connectedConnection',
  'COLUMN': 'connection.column',
  'FUNCTION': 'connection.function',
  'SCHEMA': 'connection.schema',
  'RESOURCE_GROUP': 'connection.resource_group',
  'DATABASE': 'connection.database',
  'TABLE': 'connection.table',
  'VIEW': 'connection.view',
  'MATERIALIZED_VIEW': 'connection.materializedView',
  'NO_CHILD': 'NO_CHILD',
  'KEYWORDS': 'KEYWORDS',
};

Object.freeze(ContextValue);

module.exports = {
  ContextValue
};

/***/ }),

/***/ "./node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = __webpack_require__(/*! color-convert */ "./node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js");
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});


/***/ }),

/***/ "./node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";


/* global SharedArrayBuffer, Atomics */

if (typeof SharedArrayBuffer !== 'undefined' && typeof Atomics !== 'undefined') {
  const nil = new Int32Array(new SharedArrayBuffer(4))

  function sleep (ms) {
    // also filters out NaN, non-number types, including empty strings, but allows bigints
    const valid = ms > 0 && ms < Infinity 
    if (valid === false) {
      if (typeof ms !== 'number' && typeof ms !== 'bigint') {
        throw TypeError('sleep: ms must be a number')
      }
      throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity')
    }

    Atomics.wait(nil, 0, 0, Number(ms))
  }
  module.exports = sleep
} else {

  function sleep (ms) {
    // also filters out NaN, non-number types, including empty strings, but allows bigints
    const valid = ms > 0 && ms < Infinity 
    if (valid === false) {
      if (typeof ms !== 'number' && typeof ms !== 'bigint') {
        throw TypeError('sleep: ms must be a number')
      }
      throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity')
    }
    const target = Date.now() + Number(ms)
    while (target > Date.now()){}
  }

  module.exports = sleep

}


/***/ }),

/***/ "./node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ansiStyles = __webpack_require__(/*! ansi-styles */ "./node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js");
const {stdout: stdoutColor, stderr: stderrColor} = __webpack_require__(/*! supports-color */ "./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js");
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = __webpack_require__(/*! ./util */ "./node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js");

const {isArray} = Array;

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
			return applyStyle(builder, chalkTag(builder, ...arguments_));
		}

		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!isArray(firstString) || !isArray(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = __webpack_require__(/*! ./templates */ "./node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js");
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

module.exports = chalk;


/***/ }),

/***/ "./node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

module.exports = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMessage);
	}

	return chunks.join('');
};


/***/ }),

/***/ "./node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


const stringReplaceAll = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

module.exports = {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
};


/***/ }),

/***/ "./node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = __webpack_require__(/*! color-name */ "./node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js");

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}

convert.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ "./node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(/*! ./conversions */ "./node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js");
const route = __webpack_require__(/*! ./route */ "./node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js");

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ "./node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(/*! ./conversions */ "./node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js");

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ "./node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ "./node_modules/.pnpm/dateformat@4.6.3/node_modules/dateformat/lib/dateformat.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/dateformat@4.6.3/node_modules/dateformat/lib/dateformat.js ***!
  \***************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj}}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj}}return _typeof(obj)}(function(global){var _arguments=arguments;var dateFormat=function(){var token=/d{1,4}|D{3,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|W{1,2}|[LlopSZN]|"[^"]*"|'[^']*'/g;var timezone=/\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;var timezoneClip=/[^-+\dA-Z]/g;return function(date,mask,utc,gmt){if(_arguments.length===1&&kindOf(date)==="string"&&!/\d/.test(date)){mask=date;date=undefined}date=date||date===0?date:new Date;if(!(date instanceof Date)){date=new Date(date)}if(isNaN(date)){throw TypeError("Invalid date")}mask=String(dateFormat.masks[mask]||mask||dateFormat.masks["default"]);var maskSlice=mask.slice(0,4);if(maskSlice==="UTC:"||maskSlice==="GMT:"){mask=mask.slice(4);utc=true;if(maskSlice==="GMT:"){gmt=true}}var _=function _(){return utc?"getUTC":"get"};var _d=function d(){return date[_()+"Date"]()};var D=function D(){return date[_()+"Day"]()};var _m=function m(){return date[_()+"Month"]()};var y=function y(){return date[_()+"FullYear"]()};var _H=function H(){return date[_()+"Hours"]()};var _M=function M(){return date[_()+"Minutes"]()};var _s=function s(){return date[_()+"Seconds"]()};var _L=function L(){return date[_()+"Milliseconds"]()};var _o=function o(){return utc?0:date.getTimezoneOffset()};var _W=function W(){return getWeek(date)};var _N=function N(){return getDayOfWeek(date)};var flags={d:function d(){return _d()},dd:function dd(){return pad(_d())},ddd:function ddd(){return dateFormat.i18n.dayNames[D()]},DDD:function DDD(){return getDayName({y:y(),m:_m(),d:_d(),_:_(),dayName:dateFormat.i18n.dayNames[D()],short:true})},dddd:function dddd(){return dateFormat.i18n.dayNames[D()+7]},DDDD:function DDDD(){return getDayName({y:y(),m:_m(),d:_d(),_:_(),dayName:dateFormat.i18n.dayNames[D()+7]})},m:function m(){return _m()+1},mm:function mm(){return pad(_m()+1)},mmm:function mmm(){return dateFormat.i18n.monthNames[_m()]},mmmm:function mmmm(){return dateFormat.i18n.monthNames[_m()+12]},yy:function yy(){return String(y()).slice(2)},yyyy:function yyyy(){return pad(y(),4)},h:function h(){return _H()%12||12},hh:function hh(){return pad(_H()%12||12)},H:function H(){return _H()},HH:function HH(){return pad(_H())},M:function M(){return _M()},MM:function MM(){return pad(_M())},s:function s(){return _s()},ss:function ss(){return pad(_s())},l:function l(){return pad(_L(),3)},L:function L(){return pad(Math.floor(_L()/10))},t:function t(){return _H()<12?dateFormat.i18n.timeNames[0]:dateFormat.i18n.timeNames[1]},tt:function tt(){return _H()<12?dateFormat.i18n.timeNames[2]:dateFormat.i18n.timeNames[3]},T:function T(){return _H()<12?dateFormat.i18n.timeNames[4]:dateFormat.i18n.timeNames[5]},TT:function TT(){return _H()<12?dateFormat.i18n.timeNames[6]:dateFormat.i18n.timeNames[7]},Z:function Z(){return gmt?"GMT":utc?"UTC":(String(date).match(timezone)||[""]).pop().replace(timezoneClip,"").replace(/GMT\+0000/g,"UTC")},o:function o(){return(_o()>0?"-":"+")+pad(Math.floor(Math.abs(_o())/60)*100+Math.abs(_o())%60,4)},p:function p(){return(_o()>0?"-":"+")+pad(Math.floor(Math.abs(_o())/60),2)+":"+pad(Math.floor(Math.abs(_o())%60),2)},S:function S(){return["th","st","nd","rd"][_d()%10>3?0:(_d()%100-_d()%10!=10)*_d()%10]},W:function W(){return _W()},WW:function WW(){return pad(_W())},N:function N(){return _N()}};return mask.replace(token,function(match){if(match in flags){return flags[match]()}return match.slice(1,match.length-1)})}}();dateFormat.masks={default:"ddd mmm dd yyyy HH:MM:ss",shortDate:"m/d/yy",paddedShortDate:"mm/dd/yyyy",mediumDate:"mmm d, yyyy",longDate:"mmmm d, yyyy",fullDate:"dddd, mmmm d, yyyy",shortTime:"h:MM TT",mediumTime:"h:MM:ss TT",longTime:"h:MM:ss TT Z",isoDate:"yyyy-mm-dd",isoTime:"HH:MM:ss",isoDateTime:"yyyy-mm-dd'T'HH:MM:sso",isoUtcDateTime:"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",expiresHeaderFormat:"ddd, dd mmm yyyy HH:MM:ss Z"};dateFormat.i18n={dayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],monthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","January","February","March","April","May","June","July","August","September","October","November","December"],timeNames:["a","p","am","pm","A","P","AM","PM"]};var pad=function pad(val,len){val=String(val);len=len||2;while(val.length<len){val="0"+val}return val};var getDayName=function getDayName(_ref){var y=_ref.y,m=_ref.m,d=_ref.d,_=_ref._,dayName=_ref.dayName,_ref$short=_ref["short"],_short=_ref$short===void 0?false:_ref$short;var today=new Date;var yesterday=new Date;yesterday.setDate(yesterday[_+"Date"]()-1);var tomorrow=new Date;tomorrow.setDate(tomorrow[_+"Date"]()+1);var today_d=function today_d(){return today[_+"Date"]()};var today_m=function today_m(){return today[_+"Month"]()};var today_y=function today_y(){return today[_+"FullYear"]()};var yesterday_d=function yesterday_d(){return yesterday[_+"Date"]()};var yesterday_m=function yesterday_m(){return yesterday[_+"Month"]()};var yesterday_y=function yesterday_y(){return yesterday[_+"FullYear"]()};var tomorrow_d=function tomorrow_d(){return tomorrow[_+"Date"]()};var tomorrow_m=function tomorrow_m(){return tomorrow[_+"Month"]()};var tomorrow_y=function tomorrow_y(){return tomorrow[_+"FullYear"]()};if(today_y()===y&&today_m()===m&&today_d()===d){return _short?"Tdy":"Today"}else if(yesterday_y()===y&&yesterday_m()===m&&yesterday_d()===d){return _short?"Ysd":"Yesterday"}else if(tomorrow_y()===y&&tomorrow_m()===m&&tomorrow_d()===d){return _short?"Tmw":"Tomorrow"}return dayName};var getWeek=function getWeek(date){var targetThursday=new Date(date.getFullYear(),date.getMonth(),date.getDate());targetThursday.setDate(targetThursday.getDate()-(targetThursday.getDay()+6)%7+3);var firstThursday=new Date(targetThursday.getFullYear(),0,4);firstThursday.setDate(firstThursday.getDate()-(firstThursday.getDay()+6)%7+3);var ds=targetThursday.getTimezoneOffset()-firstThursday.getTimezoneOffset();targetThursday.setHours(targetThursday.getHours()-ds);var weekDiff=(targetThursday-firstThursday)/(864e5*7);return 1+Math.floor(weekDiff)};var getDayOfWeek=function getDayOfWeek(date){var dow=date.getDay();if(dow===0){dow=7}return dow};var kindOf=function kindOf(val){if(val===null){return"null"}if(val===undefined){return"undefined"}if(_typeof(val)!=="object"){return _typeof(val)}if(Array.isArray(val)){return"array"}return{}.toString.call(val).slice(8,-1).toLowerCase()};if(true){!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return dateFormat}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}else {}})(void 0);

/***/ }),

/***/ "./node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/dayjs.min.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/dayjs.min.js ***!
  \**************************************************************************/
/***/ (function(module) {

!function(t,e){ true?module.exports=e():0}(this,(function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",c="month",f="quarter",h="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(t){var e=["th","st","nd","rd"],n=t%100;return"["+t+(e[(n-20)%10]||e[n]||e[0])+"]"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},g="en",D={};D[g]=M;var p="$isDayjsObject",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f="set"+(this.$u?"UTC":""),l=(n={},n[a]=f+"Date",n[d]=f+"Date",n[c]=f+"Month",n[h]=f+"FullYear",n[u]=f+"Hours",n[s]=f+"Minutes",n[i]=f+"Seconds",n[r]=f+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,"0")},$=f||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case"YY":return String(e.$y).slice(-2);case"YYYY":return b.s(e.$y,4,"0");case"M":return a+1;case"MM":return b.s(a+1,2,"0");case"MMM":return h(n.monthsShort,a,c,3);case"MMMM":return h(c,a);case"D":return e.$D;case"DD":return b.s(e.$D,2,"0");case"d":return String(e.$W);case"dd":return h(n.weekdaysMin,e.$W,o,2);case"ddd":return h(n.weekdaysShort,e.$W,o,3);case"dddd":return o[e.$W];case"H":return String(s);case"HH":return b.s(s,2,"0");case"h":return d(1);case"hh":return d(2);case"a":return $(s,u,!0);case"A":return $(s,u,!1);case"m":return String(u);case"mm":return b.s(u,2,"0");case"s":return String(e.$s);case"ss":return b.s(e.$s,2,"0");case"SSS":return b.s(e.$ms,3,"0");case"Z":return i}return null}(t)||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",c],["$y",h],["$D",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));

/***/ }),

/***/ "./node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/customParseFormat.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/customParseFormat.js ***!
  \*****************************************************************************************/
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(function(){"use strict";var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},t=/(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,n=/\d/,r=/\d\d/,i=/\d\d?/,o=/\d*[^-_:/,()\s\d]+/,s={},a=function(e){return(e=+e)+(e>68?1900:2e3)};var f=function(e){return function(t){this[e]=+t}},h=[/[+-]\d\d:?(\d\d)?|Z/,function(e){(this.zone||(this.zone={})).offset=function(e){if(!e)return 0;if("Z"===e)return 0;var t=e.match(/([+-]|\d\d)/g),n=60*t[1]+(+t[2]||0);return 0===n?0:"+"===t[0]?-n:n}(e)}],u=function(e){var t=s[e];return t&&(t.indexOf?t:t.s.concat(t.f))},d=function(e,t){var n,r=s.meridiem;if(r){for(var i=1;i<=24;i+=1)if(e.indexOf(r(i,0,t))>-1){n=i>12;break}}else n=e===(t?"pm":"PM");return n},c={A:[o,function(e){this.afternoon=d(e,!1)}],a:[o,function(e){this.afternoon=d(e,!0)}],Q:[n,function(e){this.month=3*(e-1)+1}],S:[n,function(e){this.milliseconds=100*+e}],SS:[r,function(e){this.milliseconds=10*+e}],SSS:[/\d{3}/,function(e){this.milliseconds=+e}],s:[i,f("seconds")],ss:[i,f("seconds")],m:[i,f("minutes")],mm:[i,f("minutes")],H:[i,f("hours")],h:[i,f("hours")],HH:[i,f("hours")],hh:[i,f("hours")],D:[i,f("day")],DD:[r,f("day")],Do:[o,function(e){var t=s.ordinal,n=e.match(/\d+/);if(this.day=n[0],t)for(var r=1;r<=31;r+=1)t(r).replace(/\[|\]/g,"")===e&&(this.day=r)}],w:[i,f("week")],ww:[r,f("week")],M:[i,f("month")],MM:[r,f("month")],MMM:[o,function(e){var t=u("months"),n=(u("monthsShort")||t.map((function(e){return e.slice(0,3)}))).indexOf(e)+1;if(n<1)throw new Error;this.month=n%12||n}],MMMM:[o,function(e){var t=u("months").indexOf(e)+1;if(t<1)throw new Error;this.month=t%12||t}],Y:[/[+-]?\d+/,f("year")],YY:[r,function(e){this.year=a(e)}],YYYY:[/\d{4}/,f("year")],Z:h,ZZ:h};function l(n){var r,i;r=n,i=s&&s.formats;for(var o=(n=r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var o=r&&r.toUpperCase();return n||i[r]||e[r]||i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))).match(t),a=o.length,f=0;f<a;f+=1){var h=o[f],u=c[h],d=u&&u[0],l=u&&u[1];o[f]=l?{regex:d,parser:l}:h.replace(/^\[|\]$/g,"")}return function(e){for(var t={},n=0,r=0;n<a;n+=1){var i=o[n];if("string"==typeof i)r+=i.length;else{var s=i.regex,f=i.parser,h=e.slice(r),u=s.exec(h)[0];f.call(t,u),e=e.replace(u,"")}}return function(e){var t=e.afternoon;if(void 0!==t){var n=e.hours;t?n<12&&(e.hours+=12):12===n&&(e.hours=0),delete e.afternoon}}(t),t}}return function(e,t,n){n.p.customParseFormat=!0,e&&e.parseTwoDigitYear&&(a=e.parseTwoDigitYear);var r=t.prototype,i=r.parse;r.parse=function(e){var t=e.date,r=e.utc,o=e.args;this.$u=r;var a=o[1];if("string"==typeof a){var f=!0===o[2],h=!0===o[3],u=f||h,d=o[2];h&&(d=o[2]),s=this.$locale(),!f&&d&&(s=n.Ls[d]),this.$d=function(e,t,n,r){try{if(["x","X"].indexOf(t)>-1)return new Date(("X"===t?1e3:1)*e);var i=l(t)(e),o=i.year,s=i.month,a=i.day,f=i.hours,h=i.minutes,u=i.seconds,d=i.milliseconds,c=i.zone,m=i.week,M=new Date,Y=a||(o||s?1:M.getDate()),p=o||M.getFullYear(),v=0;o&&!s||(v=s>0?s-1:M.getMonth());var D,w=f||0,g=h||0,y=u||0,L=d||0;return c?new Date(Date.UTC(p,v,Y,w,g,y,L+60*c.offset*1e3)):n?new Date(Date.UTC(p,v,Y,w,g,y,L)):(D=new Date(p,v,Y,w,g,y,L),m&&(D=r(D).week(m).toDate()),D)}catch(e){return new Date("")}}(t,a,r,n),this.init(),d&&!0!==d&&(this.$L=this.locale(d).$L),u&&t!=this.format(a)&&(this.$d=new Date("")),s={}}else if(a instanceof Array)for(var c=a.length,m=1;m<=c;m+=1){o[1]=a[m-1];var M=n.apply(this,o);if(M.isValid()){this.$d=M.$d,this.$L=M.$L,this.init();break}m===c&&(this.$d=new Date(""))}else i.call(this,e)}}}));

/***/ }),

/***/ "./node_modules/.pnpm/env-paths@2.2.1/node_modules/env-paths/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/env-paths@2.2.1/node_modules/env-paths/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const os = __webpack_require__(/*! os */ "os");

const homedir = os.homedir();
const tmpdir = os.tmpdir();
const {env} = process;

const macos = name => {
	const library = path.join(homedir, 'Library');

	return {
		data: path.join(library, 'Application Support', name),
		config: path.join(library, 'Preferences', name),
		cache: path.join(library, 'Caches', name),
		log: path.join(library, 'Logs', name),
		temp: path.join(tmpdir, name)
	};
};

const windows = name => {
	const appData = env.APPDATA || path.join(homedir, 'AppData', 'Roaming');
	const localAppData = env.LOCALAPPDATA || path.join(homedir, 'AppData', 'Local');

	return {
		// Data/config/cache/log are invented by me as Windows isn't opinionated about this
		data: path.join(localAppData, name, 'Data'),
		config: path.join(appData, name, 'Config'),
		cache: path.join(localAppData, name, 'Cache'),
		log: path.join(localAppData, name, 'Log'),
		temp: path.join(tmpdir, name)
	};
};

// https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
const linux = name => {
	const username = path.basename(homedir);

	return {
		data: path.join(env.XDG_DATA_HOME || path.join(homedir, '.local', 'share'), name),
		config: path.join(env.XDG_CONFIG_HOME || path.join(homedir, '.config'), name),
		cache: path.join(env.XDG_CACHE_HOME || path.join(homedir, '.cache'), name),
		// https://wiki.debian.org/XDGBaseDirectorySpecification#state
		log: path.join(env.XDG_STATE_HOME || path.join(homedir, '.local', 'state'), name),
		temp: path.join(tmpdir, username, name)
	};
};

const envPaths = (name, options) => {
	if (typeof name !== 'string') {
		throw new TypeError(`Expected string, got ${typeof name}`);
	}

	options = Object.assign({suffix: 'nodejs'}, options);

	if (options.suffix) {
		// Add suffix to prevent possible conflict with native apps
		name += `-${options.suffix}`;
	}

	if (process.platform === 'darwin') {
		return macos(name);
	}

	if (process.platform === 'win32') {
		return windows(name);
	}

	return linux(name);
};

module.exports = envPaths;
// TODO: Remove this for the next major release
module.exports["default"] = envPaths;


/***/ }),

/***/ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const validator = __webpack_require__(/*! ./lib/validator */ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/validator.js")
const parse = __webpack_require__(/*! ./lib/parse */ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/parse.js")
const redactor = __webpack_require__(/*! ./lib/redactor */ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/redactor.js")
const restorer = __webpack_require__(/*! ./lib/restorer */ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/restorer.js")
const { groupRedact, nestedRedact } = __webpack_require__(/*! ./lib/modifiers */ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/modifiers.js")
const state = __webpack_require__(/*! ./lib/state */ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/state.js")
const rx = __webpack_require__(/*! ./lib/rx */ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/rx.js")
const validate = validator()
const noop = (o) => o
noop.restore = noop

const DEFAULT_CENSOR = '[REDACTED]'
fastRedact.rx = rx
fastRedact.validator = validator

module.exports = fastRedact

function fastRedact (opts = {}) {
  const paths = Array.from(new Set(opts.paths || []))
  const serialize = 'serialize' in opts ? (
    opts.serialize === false ? opts.serialize
      : (typeof opts.serialize === 'function' ? opts.serialize : JSON.stringify)
  ) : JSON.stringify
  const remove = opts.remove
  if (remove === true && serialize !== JSON.stringify) {
    throw Error('fast-redact â€“ remove option may only be set when serializer is JSON.stringify')
  }
  const censor = remove === true
    ? undefined
    : 'censor' in opts ? opts.censor : DEFAULT_CENSOR

  const isCensorFct = typeof censor === 'function'
  const censorFctTakesPath = isCensorFct && censor.length > 1

  if (paths.length === 0) return serialize || noop

  validate({ paths, serialize, censor })

  const { wildcards, wcLen, secret } = parse({ paths, censor })

  const compileRestore = restorer()
  const strict = 'strict' in opts ? opts.strict : true

  return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
    secret,
    censor,
    compileRestore,
    serialize,
    groupRedact,
    nestedRedact,
    wildcards,
    wcLen
  }))
}


/***/ }),

/***/ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/modifiers.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/modifiers.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  groupRedact,
  groupRestore,
  nestedRedact,
  nestedRestore
}

function groupRestore ({ keys, values, target }) {
  if (target == null || typeof target === 'string') return
  const length = keys.length
  for (var i = 0; i < length; i++) {
    const k = keys[i]
    target[k] = values[i]
  }
}

function groupRedact (o, path, censor, isCensorFct, censorFctTakesPath) {
  const target = get(o, path)
  if (target == null || typeof target === 'string') return { keys: null, values: null, target, flat: true }
  const keys = Object.keys(target)
  const keysLength = keys.length
  const pathLength = path.length
  const pathWithKey = censorFctTakesPath ? [...path] : undefined
  const values = new Array(keysLength)

  for (var i = 0; i < keysLength; i++) {
    const key = keys[i]
    values[i] = target[key]

    if (censorFctTakesPath) {
      pathWithKey[pathLength] = key
      target[key] = censor(target[key], pathWithKey)
    } else if (isCensorFct) {
      target[key] = censor(target[key])
    } else {
      target[key] = censor
    }
  }
  return { keys, values, target, flat: true }
}

/**
 * @param {RestoreInstruction[]} instructions a set of instructions for restoring values to objects
 */
function nestedRestore (instructions) {
  for (let i = 0; i < instructions.length; i++) {
    const { target, path, value } = instructions[i]
    let current = target
    for (let i = path.length - 1; i > 0; i--) {
      current = current[path[i]]
    }
    current[path[0]] = value
  }
}

function nestedRedact (store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
  const target = get(o, path)
  if (target == null) return
  const keys = Object.keys(target)
  const keysLength = keys.length
  for (var i = 0; i < keysLength; i++) {
    const key = keys[i]
    specialSet(store, target, key, path, ns, censor, isCensorFct, censorFctTakesPath)
  }
  return store
}

function has (obj, prop) {
  return obj !== undefined && obj !== null
    ? ('hasOwn' in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop))
    : false
}

function specialSet (store, o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
  const afterPathLen = afterPath.length
  const lastPathIndex = afterPathLen - 1
  const originalKey = k
  var i = -1
  var n
  var nv
  var ov
  var oov = null
  var wc = null
  var kIsWc
  var wcov
  var consecutive = false
  var level = 0
  // need to track depth of the `redactPath` tree
  var depth = 0
  var redactPathCurrent = tree()
  ov = n = o[k]
  if (typeof n !== 'object') return
  while (n != null && ++i < afterPathLen) {
    depth += 1
    k = afterPath[i]
    oov = ov
    if (k !== '*' && !wc && !(typeof n === 'object' && k in n)) {
      break
    }
    if (k === '*') {
      if (wc === '*') {
        consecutive = true
      }
      wc = k
      if (i !== lastPathIndex) {
        continue
      }
    }
    if (wc) {
      const wcKeys = Object.keys(n)
      for (var j = 0; j < wcKeys.length; j++) {
        const wck = wcKeys[j]
        wcov = n[wck]
        kIsWc = k === '*'
        if (consecutive) {
          redactPathCurrent = node(redactPathCurrent, wck, depth)
          level = i
          ov = iterateNthLevel(wcov, level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1)
        } else {
          if (kIsWc || (typeof wcov === 'object' && wcov !== null && k in wcov)) {
            if (kIsWc) {
              ov = wcov
            } else {
              ov = wcov[k]
            }
            nv = (i !== lastPathIndex)
              ? ov
              : (isCensorFct
                ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))
                : censor)
            if (kIsWc) {
              const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o[originalKey])
              store.push(rv)
              n[wck] = nv
            } else {
              if (wcov[k] === nv) {
                // pass
              } else if ((nv === undefined && censor !== undefined) || (has(wcov, k) && nv === ov)) {
                redactPathCurrent = node(redactPathCurrent, wck, depth)
              } else {
                redactPathCurrent = node(redactPathCurrent, wck, depth)
                const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o[originalKey])
                store.push(rv)
                wcov[k] = nv
              }
            }
          }
        }
      }
      wc = null
    } else {
      ov = n[k]
      redactPathCurrent = node(redactPathCurrent, k, depth)
      nv = (i !== lastPathIndex)
        ? ov
        : (isCensorFct
          ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))
          : censor)
      if ((has(n, k) && nv === ov) || (nv === undefined && censor !== undefined)) {
        // pass
      } else {
        const rv = restoreInstr(redactPathCurrent, ov, o[originalKey])
        store.push(rv)
        n[k] = nv
      }
      n = n[k]
    }
    if (typeof n !== 'object') break
    // prevent circular structure, see https://github.com/pinojs/pino/issues/1513
    if (ov === oov || typeof ov === 'undefined') {
      // pass
    }
  }
}

function get (o, p) {
  var i = -1
  var l = p.length
  var n = o
  while (n != null && ++i < l) {
    n = n[p[i]]
  }
  return n
}

function iterateNthLevel (wcov, level, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
  if (level === 0) {
    if (kIsWc || (typeof wcov === 'object' && wcov !== null && k in wcov)) {
      if (kIsWc) {
        ov = wcov
      } else {
        ov = wcov[k]
      }
      nv = (i !== lastPathIndex)
        ? ov
        : (isCensorFct
          ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))
          : censor)
      if (kIsWc) {
        const rv = restoreInstr(redactPathCurrent, ov, parent)
        store.push(rv)
        n[wck] = nv
      } else {
        if (wcov[k] === nv) {
          // pass
        } else if ((nv === undefined && censor !== undefined) || (has(wcov, k) && nv === ov)) {
          // pass
        } else {
          const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent)
          store.push(rv)
          wcov[k] = nv
        }
      }
    }
  }
  for (const key in wcov) {
    if (typeof wcov[key] === 'object') {
      redactPathCurrent = node(redactPathCurrent, key, depth)
      iterateNthLevel(wcov[key], level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1)
    }
  }
}

/**
 * @typedef {object} TreeNode
 * @prop {TreeNode} [parent] reference to the parent of this node in the tree, or `null` if there is no parent
 * @prop {string} key the key that this node represents (key here being part of the path being redacted
 * @prop {TreeNode[]} children the child nodes of this node
 * @prop {number} depth the depth of this node in the tree
 */

/**
 * instantiate a new, empty tree
 * @returns {TreeNode}
 */
function tree () {
  return { parent: null, key: null, children: [], depth: 0 }
}

/**
 * creates a new node in the tree, attaching it as a child of the provided parent node
 * if the specified depth matches the parent depth, adds the new node as a _sibling_ of the parent instead
  * @param {TreeNode} parent the parent node to add a new node to (if the parent depth matches the provided `depth` value, will instead add as a sibling of this
  * @param {string} key the key that the new node represents (key here being part of the path being redacted)
  * @param {number} depth the depth of the new node in the tree - used to determing whether to add the new node as a child or sibling of the provided `parent` node
  * @returns {TreeNode} a reference to the newly created node in the tree
 */
function node (parent, key, depth) {
  if (parent.depth === depth) {
    return node(parent.parent, key, depth)
  }

  var child = {
    parent,
    key,
    depth,
    children: []
  }

  parent.children.push(child)

  return child
}

/**
 * @typedef {object} RestoreInstruction
 * @prop {string[]} path a reverse-order path that can be used to find the correct insertion point to restore a `value` for the given `parent` object
 * @prop {*} value the value to restore
 * @prop {object} target the object to restore the `value` in
 */

/**
 * create a restore instruction for the given redactPath node
 * generates a path in reverse order by walking up the redactPath tree
 * @param {TreeNode} node a tree node that should be at the bottom of the redact path (i.e. have no children) - this will be used to walk up the redact path tree to construct the path needed to restore
 * @param {*} value the value to restore
 * @param {object} target a reference to the parent object to apply the restore instruction to
 * @returns {RestoreInstruction} an instruction used to restore a nested value for a specific object
 */
function restoreInstr (node, value, target) {
  let current = node
  const path = []
  do {
    path.push(current.key)
    current = current.parent
  } while (current.parent != null)

  return { path, value, target }
}


/***/ }),

/***/ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/parse.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/parse.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const rx = __webpack_require__(/*! ./rx */ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/rx.js")

module.exports = parse

function parse ({ paths }) {
  const wildcards = []
  var wcLen = 0
  const secret = paths.reduce(function (o, strPath, ix) {
    var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ''))
    const leadingBracket = strPath[0] === '['
    path = path.map((p) => {
      if (p[0] === '[') return p.substr(1, p.length - 2)
      else return p
    })
    const star = path.indexOf('*')
    if (star > -1) {
      const before = path.slice(0, star)
      const beforeStr = before.join('.')
      const after = path.slice(star + 1, path.length)
      const nested = after.length > 0
      wcLen++
      wildcards.push({
        before,
        beforeStr,
        after,
        nested
      })
    } else {
      o[strPath] = {
        path: path,
        val: undefined,
        precensored: false,
        circle: '',
        escPath: JSON.stringify(strPath),
        leadingBracket: leadingBracket
      }
    }
    return o
  }, {})

  return { wildcards, wcLen, secret }
}


/***/ }),

/***/ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/redactor.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/redactor.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const rx = __webpack_require__(/*! ./rx */ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/rx.js")

module.exports = redactor

function redactor ({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
  /* eslint-disable-next-line */
  const redact = Function('o', `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize)}
  `).bind(state)

  redact.state = state

  if (serialize === false) {
    redact.restore = (o) => state.restore(o)
  }

  return redact
}

function redactTmpl (secret, isCensorFct, censorFctTakesPath) {
  return Object.keys(secret).map((path) => {
    const { escPath, leadingBracket, path: arrPath } = secret[path]
    const skip = leadingBracket ? 1 : 0
    const delim = leadingBracket ? '' : '.'
    const hops = []
    var match
    while ((match = rx.exec(path)) !== null) {
      const [ , ix ] = match
      const { index, input } = match
      if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)))
    }
    var existence = hops.map((p) => `o${delim}${p}`).join(' && ')
    if (existence.length === 0) existence += `o${delim}${path} != null`
    else existence += ` && o${delim}${path} != null`

    const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join('\n')}
      }
    `

    const censorArgs = censorFctTakesPath
      ? `val, ${JSON.stringify(arrPath)}`
      : `val`

    return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : 'censor'}
          ${circularDetection}
        }
      }
    `
  }).join('\n')
}

function dynamicRedactTmpl (hasWildcards, isCensorFct, censorFctTakesPath) {
  return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : ''
}

function resultTmpl (serialize) {
  return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `
}

function strictImpl (strict, serialize) {
  return strict === true
    ? `throw Error('fast-redact: primitives cannot be redacted')`
    : serialize === false ? `return o` : `return this.serialize(o)`
}


/***/ }),

/***/ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/restorer.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/restorer.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { groupRestore, nestedRestore } = __webpack_require__(/*! ./modifiers */ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/modifiers.js")

module.exports = restorer

function restorer () {
  return function compileRestore () {
    if (this.restore) {
      this.restore.state.secret = this.secret
      return
    }
    const { secret, wcLen } = this
    const paths = Object.keys(secret)
    const resetters = resetTmpl(secret, paths)
    const hasWildcards = wcLen > 0
    const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret }
    /* eslint-disable-next-line */
    this.restore = Function(
      'o',
      restoreTmpl(resetters, paths, hasWildcards)
    ).bind(state)
    this.restore.state = state
  }
}

/**
 * Mutates the original object to be censored by restoring its original values
 * prior to censoring.
 *
 * @param {object} secret Compiled object describing which target fields should
 * be censored and the field states.
 * @param {string[]} paths The list of paths to censor as provided at
 * initialization time.
 *
 * @returns {string} String of JavaScript to be used by `Function()`. The
 * string compiles to the function that does the work in the description.
 */
function resetTmpl (secret, paths) {
  return paths.map((path) => {
    const { circle, escPath, leadingBracket } = secret[path]
    const delim = leadingBracket ? '' : '.'
    const reset = circle
      ? `o.${circle} = secret[${escPath}].val`
      : `o${delim}${path} = secret[${escPath}].val`
    const clear = `secret[${escPath}].val = undefined`
    return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `
  }).join('')
}

/**
 * Creates the body of the restore function
 *
 * Restoration of the redacted object happens
 * backwards, in reverse order of redactions,
 * so that repeated redactions on the same object
 * property can be eventually rolled back to the
 * original value.
 *
 * This way dynamic redactions are restored first,
 * starting from the last one working backwards and
 * followed by the static ones.
 *
 * @returns {string} the body of the restore function
 */
function restoreTmpl (resetters, paths, hasWildcards) {
  const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : ''

  return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `
}


/***/ }),

/***/ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/rx.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/rx.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = /[^.[\]]+|\[((?:.)*?)\]/g

/*
Regular expression explanation:

Alt 1: /[^.[\]]+/ - Match one or more characters that are *not* a dot (.)
                    opening square bracket ([) or closing square bracket (])

Alt 2: /\[((?:.)*?)\]/ - If the char IS dot or square bracket, then create a capture
                         group (which will be capture group $1) that matches anything
                         within square brackets. Expansion is lazy so it will
                         stop matching as soon as the first closing bracket is met `]`
                         (rather than continuing to match until the final closing bracket).
*/


/***/ }),

/***/ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/state.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/state.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = state

function state (o) {
  const {
    secret,
    censor,
    compileRestore,
    serialize,
    groupRedact,
    nestedRedact,
    wildcards,
    wcLen
  } = o
  const builder = [{ secret, censor, compileRestore }]
  if (serialize !== false) builder.push({ serialize })
  if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen })
  return Object.assign(...builder)
}


/***/ }),

/***/ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/validator.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/validator.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = validator

function validator (opts = {}) {
  const {
    ERR_PATHS_MUST_BE_STRINGS = () => 'fast-redact - Paths must be (non-empty) strings',
    ERR_INVALID_PATH = (s) => `fast-redact â€“ Invalid path (${s})`
  } = opts

  return function validate ({ paths }) {
    paths.forEach((s) => {
      if (typeof s !== 'string') {
        throw Error(ERR_PATHS_MUST_BE_STRINGS())
      }
      try {
        if (/ã€‡/.test(s)) throw Error()
        const expr = (s[0] === '[' ? '' : '.') + s.replace(/^\*/, 'ã€‡').replace(/\.\*/g, '.ã€‡').replace(/\[\*\]/g, '[ã€‡]')
        if (/\n|\r|;/.test(expr)) throw Error()
        if (/\/\*/.test(expr)) throw Error()
        /* eslint-disable-next-line */
        Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const ã€‡ = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)()
      } catch (e) {
        throw Error(ERR_INVALID_PATH(s))
      }
    })
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js ***!
  \************************************************************************************************/
/***/ ((module) => {

module.exports = stringify
stringify.default = stringify
stringify.stable = deterministicStringify
stringify.stableStringify = deterministicStringify

var LIMIT_REPLACE_NODE = '[...]'
var CIRCULAR_REPLACE_NODE = '[Circular]'

var arr = []
var replacerStack = []

function defaultOptions () {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  }
}

// Regular stringify
function stringify (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions()
  }

  decirc(obj, '', 0, [], undefined, 0, options)
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer)
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}

function setReplace (replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)
  if (propertyDescriptor.get !== undefined) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace })
      arr.push([parent, k, val, propertyDescriptor])
    } else {
      replacerStack.push([val, k, replace])
    }
  } else {
    parent[k] = replace
    arr.push([parent, k, val])
  }
}

function decirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)
        return
      }
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options)
      }
    } else {
      var keys = Object.keys(val)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        decirc(val[key], key, i, stack, val, depth, options)
      }
    }
    stack.pop()
  }
}

// Stable-stringify
function compareFunction (a, b) {
  if (a < b) {
    return -1
  }
  if (a > b) {
    return 1
  }
  return 0
}

function deterministicStringify (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions()
  }

  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer)
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    // Ensure that we restore the object as it was.
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}

function deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)
        return
      }
    }
    try {
      if (typeof val.toJSON === 'function') {
        return
      }
    } catch (_) {
      return
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options)
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {}
      var keys = Object.keys(val).sort(compareFunction)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        deterministicDecirc(val[key], key, i, stack, val, depth, options)
        tmp[key] = val[key]
      }
      if (typeof parent !== 'undefined') {
        arr.push([parent, k, val])
        parent[k] = tmp
      } else {
        return tmp
      }
    }
    stack.pop()
  }
}

// wraps replacer function to handle values we couldn't replace
// and mark them as replaced value
function replaceGetterValues (replacer) {
  replacer =
    typeof replacer !== 'undefined'
      ? replacer
      : function (k, v) {
        return v
      }
  return function (key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i]
        if (part[1] === key && part[0] === val) {
          val = part[2]
          replacerStack.splice(i, 1)
          break
        }
      }
    }
    return replacer.call(this, key, val)
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/flatstr@1.0.12/node_modules/flatstr/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/flatstr@1.0.12/node_modules/flatstr/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";


// You may be tempted to copy and paste this, 
// but take a look at the commit history first,
// this is a moving target so relying on the module
// is the best way to make sure the optimization
// method is kept up to date and compatible with
// every Node version.

function flatstr (s) {
  s | 0
  return s
}

module.exports = flatstr

/***/ }),

/***/ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ "./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ "./node_modules/.pnpm/ipaddr.js@2.2.0/node_modules/ipaddr.js/lib/ipaddr.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/ipaddr.js@2.2.0/node_modules/ipaddr.js/lib/ipaddr.js ***!
  \*********************************************************************************/
/***/ (function(module) {

(function (root) {
    'use strict';
    // A list of regular expressions that match arbitrary IPv4 addresses,
    // for which a number of weird notations exist.
    // Note that an address like 0010.0xa5.1.1 is considered legal.
    const ipv4Part = '(0?\\d+|0x[a-f0-9]+)';
    const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, 'i'),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, 'i'),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, 'i'),
        longValue: new RegExp(`^${ipv4Part}$`, 'i')
    };

    // Regular Expression for checking Octal numbers
    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');
    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');

    const zoneIndex = '%[0-9a-z]{1,}';

    // IPv6-matching regular expressions.
    // For IPv6, the task is simpler: it is enough to match the colon-delimited
    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at
    // the end.
    const ipv6Part = '(?:[0-9a-f]+::?)+';
    const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, 'i'),
        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, 'i')
    };

    // Expand :: in an IPv6 address or address part consisting of `parts` groups.
    function expandIPv6 (string, parts) {
        // More than one '::' means invalid adddress
        if (string.indexOf('::') !== string.lastIndexOf('::')) {
            return null;
        }

        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;

        // Remove zone index and save it for later
        if (zoneId) {
            zoneId = zoneId.substring(1);
            string = string.replace(/%.+$/, '');
        }

        // How many parts do we already have?
        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
            colonCount++;
        }

        // 0::0 is two parts more than ::
        if (string.substr(0, 2) === '::') {
            colonCount--;
        }

        if (string.substr(-2, 2) === '::') {
            colonCount--;
        }

        // The following loop would hang if colonCount > parts
        if (colonCount > parts) {
            return null;
        }

        // replacement = ':' + '0:' * (parts - colonCount)
        replacementCount = parts - colonCount;
        replacement = ':';
        while (replacementCount--) {
            replacement += '0:';
        }

        // Insert the missing zeroes
        string = string.replace('::', replacement);

        // Trim any garbage which may be hanging around if :: was at the edge in
        // the source strin
        if (string[0] === ':') {
            string = string.slice(1);
        }

        if (string[string.length - 1] === ':') {
            string = string.slice(0, -1);
        }

        parts = (function () {
            const ref = string.split(':');
            const results = [];

            for (let i = 0; i < ref.length; i++) {
                results.push(parseInt(ref[i], 16));
            }

            return results;
        })();

        return {
            parts: parts,
            zoneId: zoneId
        };
    }

    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.
    function matchCIDR (first, second, partSize, cidrBits) {
        if (first.length !== second.length) {
            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');
        }

        let part = 0;
        let shift;

        while (cidrBits > 0) {
            shift = partSize - cidrBits;
            if (shift < 0) {
                shift = 0;
            }

            if (first[part] >> shift !== second[part] >> shift) {
                return false;
            }

            cidrBits -= partSize;
            part += 1;
        }

        return true;
    }

    function parseIntAuto (string) {
        // Hexadedimal base 16 (0x#)
        if (hexRegex.test(string)) {
            return parseInt(string, 16);
        }
        // While octal representation is discouraged by ECMAScript 3
        // and forbidden by ECMAScript 5, we silently allow it to
        // work only if the rest of the string has numbers less than 8.
        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {
        if (octalRegex.test(string)) {
            return parseInt(string, 8);
        }
            throw new Error(`ipaddr: cannot parse ${string} as octal`);
        }
        // Always include the base 10 radix!
        return parseInt(string, 10);
    }

    function padPart (part, length) {
        while (part.length < length) {
            part = `0${part}`;
        }

        return part;
    }

    const ipaddr = {};

    // An IPv4 address (RFC791).
    ipaddr.IPv4 = (function () {
        // Constructs a new IPv4 address from an array of four octets
        // in network order (MSB first)
        // Verifies the input.
        function IPv4 (octets) {
            if (octets.length !== 4) {
                throw new Error('ipaddr: ipv4 octet count should be 4');
            }

            let i, octet;

            for (i = 0; i < octets.length; i++) {
                octet = octets[i];
                if (!((0 <= octet && octet <= 255))) {
                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');
                }
            }

            this.octets = octets;
        }

        // Special IPv4 address ranges.
        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses
        IPv4.prototype.SpecialRanges = {
            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
            // RFC3171
            multicast: [[new IPv4([224, 0, 0, 0]), 4]],
            // RFC3927
            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
            // RFC5735
            loopback: [[new IPv4([127, 0, 0, 0]), 8]],
            // RFC6598
            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
            // RFC1918
            'private': [
                [new IPv4([10, 0, 0, 0]), 8],
                [new IPv4([172, 16, 0, 0]), 12],
                [new IPv4([192, 168, 0, 0]), 16]
            ],
            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
            reserved: [
                [new IPv4([192, 0, 0, 0]), 24],
                [new IPv4([192, 0, 2, 0]), 24],
                [new IPv4([192, 88, 99, 0]), 24],
                [new IPv4([198, 18, 0, 0]), 15],
                [new IPv4([198, 51, 100, 0]), 24],
                [new IPv4([203, 0, 113, 0]), 24],
                [new IPv4([240, 0, 0, 0]), 4]
            ],
            // RFC7534, RFC7535
            as112: [
                [new IPv4([192, 175, 48, 0]), 24],
                [new IPv4([192, 31, 196, 0]), 24],
            ],
            // RFC7450
            amt: [
                [new IPv4([192, 52, 193, 0]), 24],
            ],
        };

        // The 'kind' method exists on both IPv4 and IPv6 classes.
        IPv4.prototype.kind = function () {
            return 'ipv4';
        };

        // Checks if this address matches other one within given CIDR range.
        IPv4.prototype.match = function (other, cidrRange) {
            let ref;
            if (cidrRange === undefined) {
                ref = other;
                other = ref[0];
                cidrRange = ref[1];
            }

            if (other.kind() !== 'ipv4') {
                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');
            }

            return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };

        // returns a number of leading ones in IPv4 address, making sure that
        // the rest is a solid sequence of 0's (valid netmask)
        // returns either the CIDR length or null if mask is not valid
        IPv4.prototype.prefixLengthFromSubnetMask = function () {
            let cidr = 0;
            // non-zero encountered stop scanning for zeroes
            let stop = false;
            // number of zeroes in octet
            const zerotable = {
                0: 8,
                128: 7,
                192: 6,
                224: 5,
                240: 4,
                248: 3,
                252: 2,
                254: 1,
                255: 0
            };
            let i, octet, zeros;

            for (i = 3; i >= 0; i -= 1) {
                octet = this.octets[i];
                if (octet in zerotable) {
                    zeros = zerotable[octet];
                    if (stop && zeros !== 0) {
                        return null;
                    }

                    if (zeros !== 8) {
                        stop = true;
                    }

                    cidr += zeros;
                } else {
                    return null;
                }
            }

            return 32 - cidr;
        };

        // Checks if the address corresponds to one of the special ranges.
        IPv4.prototype.range = function () {
            return ipaddr.subnetMatch(this, this.SpecialRanges);
        };

        // Returns an array of byte-sized values in network order (MSB first)
        IPv4.prototype.toByteArray = function () {
            return this.octets.slice(0);
        };

        // Converts this IPv4 address to an IPv4-mapped IPv6 address.
        IPv4.prototype.toIPv4MappedAddress = function () {
            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
        };

        // Symmetrical method strictly for aligning with the IPv6 methods.
        IPv4.prototype.toNormalizedString = function () {
            return this.toString();
        };

        // Returns the address in convenient, decimal-dotted format.
        IPv4.prototype.toString = function () {
            return this.octets.join('.');
        };

        return IPv4;
    })();

    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation
    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {

        try {
            const cidr = this.parseCIDR(string);
            const ipInterfaceOctets = cidr[0].toByteArray();
            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            const octets = [];
            let i = 0;
            while (i < 4) {
                // Broadcast address is bitwise OR between ip interface and inverted mask
                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
                i++;
            }

            return new this(octets);
        } catch (e) {
            throw new Error('ipaddr: the address does not have IPv4 CIDR format');
        }
    };

    // Checks if a given string is formatted like IPv4 address.
    ipaddr.IPv4.isIPv4 = function (string) {
        return this.parser(string) !== null;
    };

    // Checks if a given string is a valid IPv4 address.
    ipaddr.IPv4.isValid = function (string) {
        try {
            new this(this.parser(string));
            return true;
        } catch (e) {
            return false;
        }
    };

    // Checks if a given string is a valid IPv4 address in CIDR notation.
    ipaddr.IPv4.isValidCIDR = function (string) {
        try {
            this.parseCIDR(string);
            return true;
        } catch (e) {
            return false;
        }
    };

    // Checks if a given string is a full four-part IPv4 Address.
    ipaddr.IPv4.isValidFourPartDecimal = function (string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
            return true;
        } else {
            return false;
        }
    };

    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation
    ipaddr.IPv4.networkAddressFromCIDR = function (string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;

        try {
            cidr = this.parseCIDR(string);
            ipInterfaceOctets = cidr[0].toByteArray();
            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            octets = [];
            i = 0;
            while (i < 4) {
                // Network address is bitwise AND between ip interface and mask
                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
                i++;
            }

            return new this(octets);
        } catch (e) {
            throw new Error('ipaddr: the address does not have IPv4 CIDR format');
        }
    };

    // Tries to parse and validate a string with IPv4 address.
    // Throws an error if it fails.
    ipaddr.IPv4.parse = function (string) {
        const parts = this.parser(string);

        if (parts === null) {
            throw new Error('ipaddr: string is not formatted like an IPv4 Address');
        }

        return new this(parts);
    };

    // Parses the string as an IPv4 Address with CIDR Notation.
    ipaddr.IPv4.parseCIDR = function (string) {
        let match;

        if ((match = string.match(/^(.+)\/(\d+)$/))) {
            const maskLength = parseInt(match[2]);
            if (maskLength >= 0 && maskLength <= 32) {
                const parsed = [this.parse(match[1]), maskLength];
                Object.defineProperty(parsed, 'toString', {
                    value: function () {
                        return this.join('/');
                    }
                });
                return parsed;
            }
        }

        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');
    };

    // Classful variants (like a.b, where a is an octet, and b is a 24-bit
    // value representing last three octets; this corresponds to a class C
    // address) are omitted due to classless nature of modern Internet.
    ipaddr.IPv4.parser = function (string) {
        let match, part, value;

        // parseInt recognizes all that octal & hexadecimal weirdness for us
        if ((match = string.match(ipv4Regexes.fourOctet))) {
            return (function () {
                const ref = match.slice(1, 6);
                const results = [];

                for (let i = 0; i < ref.length; i++) {
                    part = ref[i];
                    results.push(parseIntAuto(part));
                }

                return results;
            })();
        } else if ((match = string.match(ipv4Regexes.longValue))) {
            value = parseIntAuto(match[1]);
            if (value > 0xffffffff || value < 0) {
                throw new Error('ipaddr: address outside defined range');
            }

            return ((function () {
                const results = [];
                let shift;

                for (shift = 0; shift <= 24; shift += 8) {
                    results.push((value >> shift) & 0xff);
                }

                return results;
            })()).reverse();
        } else if ((match = string.match(ipv4Regexes.twoOctet))) {
            return (function () {
                const ref = match.slice(1, 4);
                const results = [];

                value = parseIntAuto(ref[1]);
                if (value > 0xffffff || value < 0) {
                    throw new Error('ipaddr: address outside defined range');
                }

                results.push(parseIntAuto(ref[0]));
                results.push((value >> 16) & 0xff);
                results.push((value >>  8) & 0xff);
                results.push( value        & 0xff);

                return results;
            })();
        } else if ((match = string.match(ipv4Regexes.threeOctet))) {
            return (function () {
                const ref = match.slice(1, 5);
                const results = [];

                value = parseIntAuto(ref[2]);
                if (value > 0xffff || value < 0) {
                    throw new Error('ipaddr: address outside defined range');
                }

                results.push(parseIntAuto(ref[0]));
                results.push(parseIntAuto(ref[1]));
                results.push((value >> 8) & 0xff);
                results.push( value       & 0xff);

                return results;
            })();
        } else {
            return null;
        }
    };

    // A utility function to return subnet mask in IPv4 format given the prefix length
    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
            throw new Error('ipaddr: invalid IPv4 prefix length');
        }

        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);

        while (j < filledOctetCount) {
            octets[j] = 255;
            j++;
        }

        if (filledOctetCount < 4) {
            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
        }

        return new this(octets);
    };

    // An IPv6 address (RFC2460)
    ipaddr.IPv6 = (function () {
        // Constructs an IPv6 address from an array of eight 16 - bit parts
        // or sixteen 8 - bit parts in network order(MSB first).
        // Throws an error if the input is invalid.
        function IPv6 (parts, zoneId) {
            let i, part;

            if (parts.length === 16) {
                this.parts = [];
                for (i = 0; i <= 14; i += 2) {
                    this.parts.push((parts[i] << 8) | parts[i + 1]);
                }
            } else if (parts.length === 8) {
                this.parts = parts;
            } else {
                throw new Error('ipaddr: ipv6 part count should be 8 or 16');
            }

            for (i = 0; i < this.parts.length; i++) {
                part = this.parts[i];
                if (!((0 <= part && part <= 0xffff))) {
                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');
                }
            }

            if (zoneId) {
                this.zoneId = zoneId;
            }
        }

        // Special IPv6 ranges
        IPv6.prototype.SpecialRanges = {
            // RFC4291, here and after
            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
            // RFC6666
            discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],
            // RFC6145
            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
            // RFC6052
            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
            // RFC3056
            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
            // RFC6052, RFC6146
            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
            // RFC5180
            benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],
            // RFC7450
            amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],
            as112v6: [
                [new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48],
                [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48],
            ],
            deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],
            orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],
            droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],
            reserved: [
                // RFC3849
                [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],
                // RFC2928
                [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32],
            ],
        };

        // Checks if this address is an IPv4-mapped IPv6 address.
        IPv6.prototype.isIPv4MappedAddress = function () {
            return this.range() === 'ipv4Mapped';
        };

        // The 'kind' method exists on both IPv4 and IPv6 classes.
        IPv6.prototype.kind = function () {
            return 'ipv6';
        };

        // Checks if this address matches other one within given CIDR range.
        IPv6.prototype.match = function (other, cidrRange) {
            let ref;

            if (cidrRange === undefined) {
                ref = other;
                other = ref[0];
                cidrRange = ref[1];
            }

            if (other.kind() !== 'ipv6') {
                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');
            }

            return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };

        // returns a number of leading ones in IPv6 address, making sure that
        // the rest is a solid sequence of 0's (valid netmask)
        // returns either the CIDR length or null if mask is not valid
        IPv6.prototype.prefixLengthFromSubnetMask = function () {
            let cidr = 0;
            // non-zero encountered stop scanning for zeroes
            let stop = false;
            // number of zeroes in octet
            const zerotable = {
                0: 16,
                32768: 15,
                49152: 14,
                57344: 13,
                61440: 12,
                63488: 11,
                64512: 10,
                65024: 9,
                65280: 8,
                65408: 7,
                65472: 6,
                65504: 5,
                65520: 4,
                65528: 3,
                65532: 2,
                65534: 1,
                65535: 0
            };
            let part, zeros;

            for (let i = 7; i >= 0; i -= 1) {
                part = this.parts[i];
                if (part in zerotable) {
                    zeros = zerotable[part];
                    if (stop && zeros !== 0) {
                        return null;
                    }

                    if (zeros !== 16) {
                        stop = true;
                    }

                    cidr += zeros;
                } else {
                    return null;
                }
            }

            return 128 - cidr;
        };


        // Checks if the address corresponds to one of the special ranges.
        IPv6.prototype.range = function () {
            return ipaddr.subnetMatch(this, this.SpecialRanges);
        };

        // Returns an array of byte-sized values in network order (MSB first)
        IPv6.prototype.toByteArray = function () {
            let part;
            const bytes = [];
            const ref = this.parts;
            for (let i = 0; i < ref.length; i++) {
                part = ref[i];
                bytes.push(part >> 8);
                bytes.push(part & 0xff);
            }

            return bytes;
        };

        // Returns the address in expanded format with all zeroes included, like
        // 2001:0db8:0008:0066:0000:0000:0000:0001
        IPv6.prototype.toFixedLengthString = function () {
            const addr = ((function () {
                const results = [];
                for (let i = 0; i < this.parts.length; i++) {
                    results.push(padPart(this.parts[i].toString(16), 4));
                }

                return results;
            }).call(this)).join(':');

            let suffix = '';

            if (this.zoneId) {
                suffix = `%${this.zoneId}`;
            }

            return addr + suffix;
        };

        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.
        // Throws an error otherwise.
        IPv6.prototype.toIPv4Address = function () {
            if (!this.isIPv4MappedAddress()) {
                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');
            }

            const ref = this.parts.slice(-2);
            const high = ref[0];
            const low = ref[1];

            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
        };

        // Returns the address in expanded format with all zeroes included, like
        // 2001:db8:8:66:0:0:0:1
        //
        // Deprecated: use toFixedLengthString() instead.
        IPv6.prototype.toNormalizedString = function () {
            const addr = ((function () {
                const results = [];

                for (let i = 0; i < this.parts.length; i++) {
                    results.push(this.parts[i].toString(16));
                }

                return results;
            }).call(this)).join(':');

            let suffix = '';

            if (this.zoneId) {
                suffix = `%${this.zoneId}`;
            }

            return addr + suffix;
        };

        // Returns the address in compact, human-readable format like
        // 2001:db8:8:66::1
        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)
        IPv6.prototype.toRFC5952String = function () {
            const regex = /((^|:)(0(:|$)){2,})/g;
            const string = this.toNormalizedString();
            let bestMatchIndex = 0;
            let bestMatchLength = -1;
            let match;

            while ((match = regex.exec(string))) {
                if (match[0].length > bestMatchLength) {
                    bestMatchIndex = match.index;
                    bestMatchLength = match[0].length;
                }
            }

            if (bestMatchLength < 0) {
                return string;
            }

            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
        };

        // Returns the address in compact, human-readable format like
        // 2001:db8:8:66::1
        // Calls toRFC5952String under the hood.
        IPv6.prototype.toString = function () {
            return this.toRFC5952String();
        };

        return IPv6;

    })();

    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation
    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {
        try {
            const cidr = this.parseCIDR(string);
            const ipInterfaceOctets = cidr[0].toByteArray();
            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            const octets = [];
            let i = 0;
            while (i < 16) {
                // Broadcast address is bitwise OR between ip interface and inverted mask
                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
                i++;
            }

            return new this(octets);
        } catch (e) {
            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
    };

    // Checks if a given string is formatted like IPv6 address.
    ipaddr.IPv6.isIPv6 = function (string) {
        return this.parser(string) !== null;
    };

    // Checks to see if string is a valid IPv6 Address
    ipaddr.IPv6.isValid = function (string) {

        // Since IPv6.isValid is always called first, this shortcut
        // provides a substantial performance gain.
        if (typeof string === 'string' && string.indexOf(':') === -1) {
            return false;
        }

        try {
            const addr = this.parser(string);
            new this(addr.parts, addr.zoneId);
            return true;
        } catch (e) {
            return false;
        }
    };

    // Checks if a given string is a valid IPv6 address in CIDR notation.
    ipaddr.IPv6.isValidCIDR = function (string) {

        // See note in IPv6.isValid
        if (typeof string === 'string' && string.indexOf(':') === -1) {
            return false;
        }

        try {
            this.parseCIDR(string);
            return true;
        } catch (e) {
            return false;
        }
    };

    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation
    ipaddr.IPv6.networkAddressFromCIDR = function (string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;

        try {
            cidr = this.parseCIDR(string);
            ipInterfaceOctets = cidr[0].toByteArray();
            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            octets = [];
            i = 0;
            while (i < 16) {
                // Network address is bitwise AND between ip interface and mask
                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
                i++;
            }

            return new this(octets);
        } catch (e) {
            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
    };

    // Tries to parse and validate a string with IPv6 address.
    // Throws an error if it fails.
    ipaddr.IPv6.parse = function (string) {
        const addr = this.parser(string);

        if (addr.parts === null) {
            throw new Error('ipaddr: string is not formatted like an IPv6 Address');
        }

        return new this(addr.parts, addr.zoneId);
    };

    ipaddr.IPv6.parseCIDR = function (string) {
        let maskLength, match, parsed;

        if ((match = string.match(/^(.+)\/(\d+)$/))) {
            maskLength = parseInt(match[2]);
            if (maskLength >= 0 && maskLength <= 128) {
                parsed = [this.parse(match[1]), maskLength];
                Object.defineProperty(parsed, 'toString', {
                    value: function () {
                        return this.join('/');
                    }
                });
                return parsed;
            }
        }

        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');
    };

    // Parse an IPv6 address.
    ipaddr.IPv6.parser = function (string) {
        let addr, i, match, octet, octets, zoneId;

        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {
            return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string)) {
            return expandIPv6(string, 8);
        }
        if ((match = string.match(ipv6Regexes.transitional))) {
            zoneId = match[6] || '';
            addr = match[1]
            if (!match[1].endsWith('::')) {
                addr = addr.slice(0, -1)
            }
            addr = expandIPv6(addr + zoneId, 6);
            if (addr.parts) {
                octets = [
                    parseInt(match[2]),
                    parseInt(match[3]),
                    parseInt(match[4]),
                    parseInt(match[5])
                ];
                for (i = 0; i < octets.length; i++) {
                    octet = octets[i];
                    if (!((0 <= octet && octet <= 255))) {
                        return null;
                    }
                }

                addr.parts.push(octets[0] << 8 | octets[1]);
                addr.parts.push(octets[2] << 8 | octets[3]);
                return {
                    parts: addr.parts,
                    zoneId: addr.zoneId
                };
            }
        }

        return null;
    };

    // A utility function to return subnet mask in IPv6 format given the prefix length
    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
            throw new Error('ipaddr: invalid IPv6 prefix length');
        }

        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);

        while (j < filledOctetCount) {
            octets[j] = 255;
            j++;
        }

        if (filledOctetCount < 16) {
            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
        }

        return new this(octets);
    };

    // Try to parse an array in network order (MSB first) for IPv4 and IPv6
    ipaddr.fromByteArray = function (bytes) {
        const length = bytes.length;

        if (length === 4) {
            return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
            return new ipaddr.IPv6(bytes);
        } else {
            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');
        }
    };

    // Checks if the address is valid IP address
    ipaddr.isValid = function (string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
    };

    // Checks if the address is valid IP address in CIDR notation
    ipaddr.isValidCIDR = function (string) {
        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);
    };


    // Attempts to parse an IP Address, first through IPv6 then IPv4.
    // Throws an error if it could not be parsed.
    ipaddr.parse = function (string) {
        if (ipaddr.IPv6.isValid(string)) {
            return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
            return ipaddr.IPv4.parse(string);
        } else {
            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');
        }
    };

    // Attempt to parse CIDR notation, first through IPv6 then IPv4.
    // Throws an error if it could not be parsed.
    ipaddr.parseCIDR = function (string) {
        try {
            return ipaddr.IPv6.parseCIDR(string);
        } catch (e) {
            try {
                return ipaddr.IPv4.parseCIDR(string);
            } catch (e2) {
                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');
            }
        }
    };

    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address
    ipaddr.process = function (string) {
        const addr = this.parse(string);

        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
            return addr.toIPv4Address();
        } else {
            return addr;
        }
    };

    // An utility function to ease named range matching. See examples below.
    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors
    // on matching IPv4 addresses to IPv6 ranges or vice versa.
    ipaddr.subnetMatch = function (address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;

        if (defaultName === undefined || defaultName === null) {
            defaultName = 'unicast';
        }

        for (rangeName in rangeList) {
            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
                rangeSubnets = rangeList[rangeName];
                // ECMA5 Array.isArray isn't available everywhere
                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
                    rangeSubnets = [rangeSubnets];
                }

                for (i = 0; i < rangeSubnets.length; i++) {
                    subnet = rangeSubnets[i];
                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                        return rangeName;
                    }
                }
            }
        }

        return defaultName;
    };

    // Export for both the CommonJS and browser-like environment
    if ( true && module.exports) {
        module.exports = ipaddr;

    } else {
        root.ipaddr = ipaddr;
    }

}(this));


/***/ }),

/***/ "./node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/index.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");

function specifierIncluded(current, specifier) {
	var nodeParts = current.split('.');
	var parts = specifier.split(' ');
	var op = parts.length > 1 ? parts[0] : '=';
	var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

	for (var i = 0; i < 3; ++i) {
		var cur = parseInt(nodeParts[i] || 0, 10);
		var ver = parseInt(versionParts[i] || 0, 10);
		if (cur === ver) {
			continue; // eslint-disable-line no-restricted-syntax, no-continue
		}
		if (op === '<') {
			return cur < ver;
		}
		if (op === '>=') {
			return cur >= ver;
		}
		return false;
	}
	return op === '>=';
}

function matchesRange(current, range) {
	var specifiers = range.split(/ ?&& ?/);
	if (specifiers.length === 0) {
		return false;
	}
	for (var i = 0; i < specifiers.length; ++i) {
		if (!specifierIncluded(current, specifiers[i])) {
			return false;
		}
	}
	return true;
}

function versionIncluded(nodeVersion, specifierValue) {
	if (typeof specifierValue === 'boolean') {
		return specifierValue;
	}

	var current = typeof nodeVersion === 'undefined'
		? process.versions && process.versions.node
		: nodeVersion;

	if (typeof current !== 'string') {
		throw new TypeError(typeof nodeVersion === 'undefined' ? 'Unable to determine current node version' : 'If provided, a valid node version is required');
	}

	if (specifierValue && typeof specifierValue === 'object') {
		for (var i = 0; i < specifierValue.length; ++i) {
			if (matchesRange(current, specifierValue[i])) {
				return true;
			}
		}
		return false;
	}
	return matchesRange(current, specifierValue);
}

var data = __webpack_require__(/*! ./core.json */ "./node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/core.json");

module.exports = function isCore(x, nodeVersion) {
	return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
};


/***/ }),

/***/ "./node_modules/.pnpm/jmespath@0.15.0/node_modules/jmespath/jmespath.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/jmespath@0.15.0/node_modules/jmespath/jmespath.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

(function(exports) {
  "use strict";

  function isArray(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    } else {
      return false;
    }
  }

  function isObject(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    } else {
      return false;
    }
  }

  function strictDeepEqual(first, second) {
    // Check the scalar case first.
    if (first === second) {
      return true;
    }

    // Check if they are the same type.
    var firstType = Object.prototype.toString.call(first);
    if (firstType !== Object.prototype.toString.call(second)) {
      return false;
    }
    // We know that first and second have the same type so we can just check the
    // first type from now on.
    if (isArray(first) === true) {
      // Short circuit if they're not the same length;
      if (first.length !== second.length) {
        return false;
      }
      for (var i = 0; i < first.length; i++) {
        if (strictDeepEqual(first[i], second[i]) === false) {
          return false;
        }
      }
      return true;
    }
    if (isObject(first) === true) {
      // An object is equal if it has the same key/value pairs.
      var keysSeen = {};
      for (var key in first) {
        if (hasOwnProperty.call(first, key)) {
          if (strictDeepEqual(first[key], second[key]) === false) {
            return false;
          }
          keysSeen[key] = true;
        }
      }
      // Now check that there aren't any keys in second that weren't
      // in first.
      for (var key2 in second) {
        if (hasOwnProperty.call(second, key2)) {
          if (keysSeen[key2] !== true) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  function isFalse(obj) {
    // From the spec:
    // A false value corresponds to the following values:
    // Empty list
    // Empty object
    // Empty string
    // False boolean
    // null value

    // First check the scalar values.
    if (obj === "" || obj === false || obj === null) {
        return true;
    } else if (isArray(obj) && obj.length === 0) {
        // Check for an empty array.
        return true;
    } else if (isObject(obj)) {
        // Check for an empty object.
        for (var key in obj) {
            // If there are any keys, then
            // the object is not empty so the object
            // is not false.
            if (obj.hasOwnProperty(key)) {
              return false;
            }
        }
        return true;
    } else {
        return false;
    }
  }

  function objValues(obj) {
    var keys = Object.keys(obj);
    var values = [];
    for (var i = 0; i < keys.length; i++) {
      values.push(obj[keys[i]]);
    }
    return values;
  }

  function merge(a, b) {
      var merged = {};
      for (var key in a) {
          merged[key] = a[key];
      }
      for (var key2 in b) {
          merged[key2] = b[key2];
      }
      return merged;
  }

  var trimLeft;
  if (typeof String.prototype.trimLeft === "function") {
    trimLeft = function(str) {
      return str.trimLeft();
    };
  } else {
    trimLeft = function(str) {
      return str.match(/^\s*(.*)/)[1];
    };
  }

  // Type constants used to define functions.
  var TYPE_NUMBER = 0;
  var TYPE_ANY = 1;
  var TYPE_STRING = 2;
  var TYPE_ARRAY = 3;
  var TYPE_OBJECT = 4;
  var TYPE_BOOLEAN = 5;
  var TYPE_EXPREF = 6;
  var TYPE_NULL = 7;
  var TYPE_ARRAY_NUMBER = 8;
  var TYPE_ARRAY_STRING = 9;

  var TOK_EOF = "EOF";
  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
  var TOK_RBRACKET = "Rbracket";
  var TOK_RPAREN = "Rparen";
  var TOK_COMMA = "Comma";
  var TOK_COLON = "Colon";
  var TOK_RBRACE = "Rbrace";
  var TOK_NUMBER = "Number";
  var TOK_CURRENT = "Current";
  var TOK_EXPREF = "Expref";
  var TOK_PIPE = "Pipe";
  var TOK_OR = "Or";
  var TOK_AND = "And";
  var TOK_EQ = "EQ";
  var TOK_GT = "GT";
  var TOK_LT = "LT";
  var TOK_GTE = "GTE";
  var TOK_LTE = "LTE";
  var TOK_NE = "NE";
  var TOK_FLATTEN = "Flatten";
  var TOK_STAR = "Star";
  var TOK_FILTER = "Filter";
  var TOK_DOT = "Dot";
  var TOK_NOT = "Not";
  var TOK_LBRACE = "Lbrace";
  var TOK_LBRACKET = "Lbracket";
  var TOK_LPAREN= "Lparen";
  var TOK_LITERAL= "Literal";

  // The "&", "[", "<", ">" tokens
  // are not in basicToken because
  // there are two token variants
  // ("&&", "[?", "<=", ">=").  This is specially handled
  // below.

  var basicTokens = {
    ".": TOK_DOT,
    "*": TOK_STAR,
    ",": TOK_COMMA,
    ":": TOK_COLON,
    "{": TOK_LBRACE,
    "}": TOK_RBRACE,
    "]": TOK_RBRACKET,
    "(": TOK_LPAREN,
    ")": TOK_RPAREN,
    "@": TOK_CURRENT
  };

  var operatorStartToken = {
      "<": true,
      ">": true,
      "=": true,
      "!": true
  };

  var skipChars = {
      " ": true,
      "\t": true,
      "\n": true
  };


  function isAlpha(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             ch === "_";
  }

  function isNum(ch) {
      return (ch >= "0" && ch <= "9") ||
             ch === "-";
  }
  function isAlphaNum(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             (ch >= "0" && ch <= "9") ||
             ch === "_";
  }

  function Lexer() {
  }
  Lexer.prototype = {
      tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
              if (isAlpha(stream[this._current])) {
                  start = this._current;
                  identifier = this._consumeUnquotedIdentifier(stream);
                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (basicTokens[stream[this._current]] !== undefined) {
                  tokens.push({type: basicTokens[stream[this._current]],
                              value: stream[this._current],
                              start: this._current});
                  this._current++;
              } else if (isNum(stream[this._current])) {
                  token = this._consumeNumber(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "[") {
                  // No need to increment this._current.  This happens
                  // in _consumeLBracket
                  token = this._consumeLBracket(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "\"") {
                  start = this._current;
                  identifier = this._consumeQuotedIdentifier(stream);
                  tokens.push({type: TOK_QUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "'") {
                  start = this._current;
                  identifier = this._consumeRawStringLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "`") {
                  start = this._current;
                  var literal = this._consumeLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: literal,
                               start: start});
              } else if (operatorStartToken[stream[this._current]] !== undefined) {
                  tokens.push(this._consumeOperator(stream));
              } else if (skipChars[stream[this._current]] !== undefined) {
                  // Ignore whitespace.
                  this._current++;
              } else if (stream[this._current] === "&") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "&") {
                      this._current++;
                      tokens.push({type: TOK_AND, value: "&&", start: start});
                  } else {
                      tokens.push({type: TOK_EXPREF, value: "&", start: start});
                  }
              } else if (stream[this._current] === "|") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "|") {
                      this._current++;
                      tokens.push({type: TOK_OR, value: "||", start: start});
                  } else {
                      tokens.push({type: TOK_PIPE, value: "|", start: start});
                  }
              } else {
                  var error = new Error("Unknown character:" + stream[this._current]);
                  error.name = "LexerError";
                  throw error;
              }
          }
          return tokens;
      },

      _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
              this._current++;
          }
          return stream.slice(start, this._current);
      },

      _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "\"" && this._current < maxLength) {
              // You can escape a double quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "\"")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
      },

      _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
              // You can escape a single quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "'")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
      },

      _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
              this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return {type: TOK_NUMBER, value: value, start: start};
      },

      _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
              this._current++;
              return {type: TOK_FILTER, value: "[?", start: start};
          } else if (stream[this._current] === "]") {
              this._current++;
              return {type: TOK_FLATTEN, value: "[]", start: start};
          } else {
              return {type: TOK_LBRACKET, value: "[", start: start};
          }
      },

      _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_NE, value: "!=", start: start};
              } else {
                return {type: TOK_NOT, value: "!", start: start};
              }
          } else if (startingChar === "<") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_LTE, value: "<=", start: start};
              } else {
                  return {type: TOK_LT, value: "<", start: start};
              }
          } else if (startingChar === ">") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_GTE, value: ">=", start: start};
              } else {
                  return {type: TOK_GT, value: ">", start: start};
              }
          } else if (startingChar === "=") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_EQ, value: "==", start: start};
              }
          }
      },

      _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while(stream[this._current] !== "`" && this._current < maxLength) {
              // You can escape a literal char or you can escape the escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "`")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
              literal = JSON.parse(literalString);
          } else {
              // Try to JSON parse it as "<literal>"
              literal = JSON.parse("\"" + literalString + "\"");
          }
          // +1 gets us to the ending "`", +1 to move on to the next char.
          this._current++;
          return literal;
      },

      _looksLikeJSON: function(literalString) {
          var startingChars = "[{\"";
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";

          if (literalString === "") {
              return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
              return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
              return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
              try {
                  JSON.parse(literalString);
                  return true;
              } catch (ex) {
                  return false;
              }
          } else {
              return false;
          }
      }
  };

      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;

  function Parser() {
  }

  Parser.prototype = {
      parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
              var t = this._lookaheadToken(0);
              var error = new Error(
                  "Unexpected token type: " + t.type + ", value: " + t.value);
              error.name = "ParserError";
              throw error;
          }
          return ast;
      },

      _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({type: TOK_EOF, value: "", start: expression.length});
          this.tokens = tokens;
      },

      expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
              this._advance();
              left = this.led(currentToken, left);
              currentToken = this._lookahead(0);
          }
          return left;
      },

      _lookahead: function(number) {
          return this.tokens[this.index + number].type;
      },

      _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
      },

      _advance: function() {
          this.index++;
      },

      nud: function(token) {
        var left;
        var right;
        var expression;
        switch (token.type) {
          case TOK_LITERAL:
            return {type: "Literal", value: token.value};
          case TOK_UNQUOTEDIDENTIFIER:
            return {type: "Field", name: token.value};
          case TOK_QUOTEDIDENTIFIER:
            var node = {type: "Field", name: token.value};
            if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
            } else {
                return node;
            }
            break;
          case TOK_NOT:
            right = this.expression(bindingPower.Not);
            return {type: "NotExpression", children: [right]};
          case TOK_STAR:
            left = {type: "Identity"};
            right = null;
            if (this._lookahead(0) === TOK_RBRACKET) {
                // This can happen in a multiselect,
                // [a, b, *]
                right = {type: "Identity"};
            } else {
                right = this._parseProjectionRHS(bindingPower.Star);
            }
            return {type: "ValueProjection", children: [left, right]};
          case TOK_FILTER:
            return this.led(token.type, {type: "Identity"});
          case TOK_LBRACE:
            return this._parseMultiselectHash();
          case TOK_FLATTEN:
            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};
            right = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [left, right]};
          case TOK_LBRACKET:
            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({type: "Identity"}, right);
            } else if (this._lookahead(0) === TOK_STAR &&
                       this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection",
                        children: [{type: "Identity"}, right]};
            } else {
                return this._parseMultiselectList();
            }
            break;
          case TOK_CURRENT:
            return {type: TOK_CURRENT};
          case TOK_EXPREF:
            expression = this.expression(bindingPower.Expref);
            return {type: "ExpressionReference", children: [expression]};
          case TOK_LPAREN:
            var args = [];
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            return args[0];
          default:
            this._errorToken(token);
        }
      },

      led: function(tokenName, left) {
        var right;
        switch(tokenName) {
          case TOK_DOT:
            var rbp = bindingPower.Dot;
            if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return {type: "Subexpression", children: [left, right]};
            } else {
                // Creating a projection.
                this._advance();
                right = this._parseProjectionRHS(rbp);
                return {type: "ValueProjection", children: [left, right]};
            }
            break;
          case TOK_PIPE:
            right = this.expression(bindingPower.Pipe);
            return {type: TOK_PIPE, children: [left, right]};
          case TOK_OR:
            right = this.expression(bindingPower.Or);
            return {type: "OrExpression", children: [left, right]};
          case TOK_AND:
            right = this.expression(bindingPower.And);
            return {type: "AndExpression", children: [left, right]};
          case TOK_LPAREN:
            var name = left.name;
            var args = [];
            var expression, node;
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              if (this._lookahead(0) === TOK_COMMA) {
                this._match(TOK_COMMA);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            node = {type: "Function", name: name, children: args};
            return node;
          case TOK_FILTER:
            var condition = this.expression(0);
            this._match(TOK_RBRACKET);
            if (this._lookahead(0) === TOK_FLATTEN) {
              right = {type: "Identity"};
            } else {
              right = this._parseProjectionRHS(bindingPower.Filter);
            }
            return {type: "FilterProjection", children: [left, right, condition]};
          case TOK_FLATTEN:
            var leftNode = {type: TOK_FLATTEN, children: [left]};
            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [leftNode, rightNode]};
          case TOK_EQ:
          case TOK_NE:
          case TOK_GT:
          case TOK_GTE:
          case TOK_LT:
          case TOK_LTE:
            return this._parseComparator(left, tokenName);
          case TOK_LBRACKET:
            var token = this._lookaheadToken(0);
            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
            } else {
                this._match(TOK_STAR);
                this._match(TOK_RBRACKET);
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection", children: [left, right]};
            }
            break;
          default:
            this._errorToken(this._lookaheadToken(0));
        }
      },

      _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
              this._advance();
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Expected " + tokenType + ", got: " + t.type);
              error.name = "ParserError";
              throw error;
          }
      },

      _errorToken: function(token) {
          var error = new Error("Invalid token (" +
                                token.type + "): \"" +
                                token.value + "\"");
          error.name = "ParserError";
          throw error;
      },


      _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
              return this._parseSliceExpression();
          } else {
              var node = {
                  type: "Index",
                  value: this._lookaheadToken(0).value};
              this._advance();
              this._match(TOK_RBRACKET);
              return node;
          }
      },

      _projectIfSlice: function(left, right) {
          var indexExpr = {type: "IndexExpression", children: [left, right]};
          if (right.type === "Slice") {
              return {
                  type: "Projection",
                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
              };
          } else {
              return indexExpr;
          }
      },

      _parseSliceExpression: function() {
          // [start:end:step] where each part is optional, as well as the last
          // colon.
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
              if (currentToken === TOK_COLON) {
                  index++;
                  this._advance();
              } else if (currentToken === TOK_NUMBER) {
                  parts[index] = this._lookaheadToken(0).value;
                  this._advance();
              } else {
                  var t = this._lookahead(0);
                  var error = new Error("Syntax error, unexpected token: " +
                                        t.value + "(" + t.type + ")");
                  error.name = "Parsererror";
                  throw error;
              }
              currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
              type: "Slice",
              children: parts
          };
      },

      _parseComparator: function(left, comparator) {
        var right = this.expression(bindingPower[comparator]);
        return {type: "Comparator", name: comparator, children: [left, right]};
      },

      _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
              return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
              this._match(TOK_LBRACKET);
              return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
              this._match(TOK_LBRACE);
              return this._parseMultiselectHash();
          }
      },

      _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
              right = {type: "Identity"};
          } else if (this._lookahead(0) === TOK_LBRACKET) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
              this._match(TOK_DOT);
              right = this._parseDotRHS(rbp);
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Sytanx error, unexpected token: " +
                                    t.value + "(" + t.type + ")");
              error.name = "ParserError";
              throw error;
          }
          return right;
      },

      _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
              var expression = this.expression(0);
              expressions.push(expression);
              if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                  if (this._lookahead(0) === TOK_RBRACKET) {
                    throw new Error("Unexpected token Rbracket");
                  }
              }
          }
          this._match(TOK_RBRACKET);
          return {type: "MultiSelectList", children: expressions};
      },

      _parseMultiselectHash: function() {
        var pairs = [];
        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
        var keyToken, keyName, value, node;
        for (;;) {
          keyToken = this._lookaheadToken(0);
          if (identifierTypes.indexOf(keyToken.type) < 0) {
            throw new Error("Expecting an identifier token, got: " +
                            keyToken.type);
          }
          keyName = keyToken.value;
          this._advance();
          this._match(TOK_COLON);
          value = this.expression(0);
          node = {type: "KeyValuePair", name: keyName, value: value};
          pairs.push(node);
          if (this._lookahead(0) === TOK_COMMA) {
            this._match(TOK_COMMA);
          } else if (this._lookahead(0) === TOK_RBRACE) {
            this._match(TOK_RBRACE);
            break;
          }
        }
        return {type: "MultiSelectHash", children: pairs};
      }
  };


  function TreeInterpreter(runtime) {
    this.runtime = runtime;
  }

  TreeInterpreter.prototype = {
      search: function(node, value) {
          return this.visit(node, value);
      },

      visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value === null ) {
                  return null;
              } else if (isObject(value)) {
                  field = value[node.name];
                  if (field === undefined) {
                      return null;
                  } else {
                      return field;
                  }
              } else {
                return null;
              }
              break;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                  result = this.visit(node.children[1], result);
                  if (result === null) {
                      return null;
                  }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === undefined) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                  for (i = start; i < stop; i += step) {
                      result.push(value[i]);
                  }
              } else {
                  for (i = start; i > stop; i += step) {
                      result.push(value[i]);
                  }
              }
              return result;
            case "Projection":
              // Evaluate left child.
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              // Evaluate left child.
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch(node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                  collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                  matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);

              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                  resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              // Tag the node with a specific attribute so the type
              // checker verify the type.
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
      },

      computeSliceParams: function(arrayLength, sliceParams) {
        var start = sliceParams[0];
        var stop = sliceParams[1];
        var step = sliceParams[2];
        var computed = [null, null, null];
        if (step === null) {
          step = 1;
        } else if (step === 0) {
          var error = new Error("Invalid slice, step cannot be 0");
          error.name = "RuntimeError";
          throw error;
        }
        var stepValueNegative = step < 0 ? true : false;

        if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
        } else {
            start = this.capSliceRange(arrayLength, start, step);
        }

        if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
        } else {
            stop = this.capSliceRange(arrayLength, stop, step);
        }
        computed[0] = start;
        computed[1] = stop;
        computed[2] = step;
        return computed;
      },

      capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
              actualValue += arrayLength;
              if (actualValue < 0) {
                  actualValue = step < 0 ? -1 : 0;
              }
          } else if (actualValue >= arrayLength) {
              actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
      }

  };

  function Runtime(interpreter) {
    this._interpreter = interpreter;
    this.functionTable = {
        // name: [function, <signature>]
        // The <signature> can be:
        //
        // {
        //   args: [[type1, type2], [type1, type2]],
        //   variadic: true|false
        // }
        //
        // Each arg in the arg list is a list of valid types
        // (if the function is overloaded and supports multiple
        // types.  If the type is "any" then no type checking
        // occurs on the argument.  Variadic is optional
        // and if not provided is assumed to be false.
        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},
        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},
        contains: {
            _func: this._functionContains,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},
                        {types: [TYPE_ANY]}]},
        "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},
        length: {
            _func: this._functionLength,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
        map: {
            _func: this._functionMap,
            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},
        max: {
            _func: this._functionMax,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "merge": {
            _func: this._functionMerge,
            _signature: [{types: [TYPE_OBJECT], variadic: true}]
        },
        "max_by": {
          _func: this._functionMaxBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        min: {
            _func: this._functionMin,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "min_by": {
          _func: this._functionMinBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},
        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},
        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},
        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
        "sort_by": {
          _func: this._functionSortBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        join: {
            _func: this._functionJoin,
            _signature: [
                {types: [TYPE_STRING]},
                {types: [TYPE_ARRAY_STRING]}
            ]
        },
        reverse: {
            _func: this._functionReverse,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},
        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},
        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},
        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},
        "not_null": {
            _func: this._functionNotNull,
            _signature: [{types: [TYPE_ANY], variadic: true}]
        }
    };
  }

  Runtime.prototype = {
    callFunction: function(name, resolvedArgs) {
      var functionEntry = this.functionTable[name];
      if (functionEntry === undefined) {
          throw new Error("Unknown function: " + name + "()");
      }
      this._validateArgs(name, resolvedArgs, functionEntry._signature);
      return functionEntry._func.call(this, resolvedArgs);
    },

    _validateArgs: function(name, args, signature) {
        // Validating the args requires validating
        // the correct arity and the correct type of each arg.
        // If the last argument is declared as variadic, then we need
        // a minimum number of args to be required.  Otherwise it has to
        // be an exact amount.
        var pluralized;
        if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
                pluralized = signature.length === 1 ? " argument" : " arguments";
                throw new Error("ArgumentError: " + name + "() " +
                                "takes at least" + signature.length + pluralized +
                                " but received " + args.length);
            }
        } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() " +
                            "takes " + signature.length + pluralized +
                            " but received " + args.length);
        }
        var currentSpec;
        var actualType;
        var typeMatched;
        for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
                if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                    typeMatched = true;
                    break;
                }
            }
            if (!typeMatched) {
                throw new Error("TypeError: " + name + "() " +
                                "expected argument " + (i + 1) +
                                " to be type " + currentSpec +
                                " but received type " + actualType +
                                " instead.");
            }
        }
    },

    _typeMatches: function(actual, expected, argValue) {
        if (expected === TYPE_ANY) {
            return true;
        }
        if (expected === TYPE_ARRAY_STRING ||
            expected === TYPE_ARRAY_NUMBER ||
            expected === TYPE_ARRAY) {
            // The expected type can either just be array,
            // or it can require a specific subtype (array of numbers).
            //
            // The simplest case is if "array" with no subtype is specified.
            if (expected === TYPE_ARRAY) {
                return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
                // Otherwise we need to check subtypes.
                // I think this has potential to be improved.
                var subtype;
                if (expected === TYPE_ARRAY_NUMBER) {
                  subtype = TYPE_NUMBER;
                } else if (expected === TYPE_ARRAY_STRING) {
                  subtype = TYPE_STRING;
                }
                for (var i = 0; i < argValue.length; i++) {
                    if (!this._typeMatches(
                            this._getTypeName(argValue[i]), subtype,
                                             argValue[i])) {
                        return false;
                    }
                }
                return true;
            }
        } else {
            return actual === expected;
        }
    },
    _getTypeName: function(obj) {
        switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              // Check if it's an expref.  If it has, it's been
              // tagged with a jmespathType attr of 'Expref';
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
        }
    },

    _functionStartsWith: function(resolvedArgs) {
        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
    },

    _functionEndsWith: function(resolvedArgs) {
        var searchStr = resolvedArgs[0];
        var suffix = resolvedArgs[1];
        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
    },

    _functionReverse: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        if (typeName === TYPE_STRING) {
          var originalStr = resolvedArgs[0];
          var reversedStr = "";
          for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
          }
          return reversedStr;
        } else {
          var reversedArray = resolvedArgs[0].slice(0);
          reversedArray.reverse();
          return reversedArray;
        }
    },

    _functionAbs: function(resolvedArgs) {
      return Math.abs(resolvedArgs[0]);
    },

    _functionCeil: function(resolvedArgs) {
        return Math.ceil(resolvedArgs[0]);
    },

    _functionAvg: function(resolvedArgs) {
        var sum = 0;
        var inputArray = resolvedArgs[0];
        for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
        }
        return sum / inputArray.length;
    },

    _functionContains: function(resolvedArgs) {
        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
    },

    _functionFloor: function(resolvedArgs) {
        return Math.floor(resolvedArgs[0]);
    },

    _functionLength: function(resolvedArgs) {
       if (!isObject(resolvedArgs[0])) {
         return resolvedArgs[0].length;
       } else {
         // As far as I can tell, there's no way to get the length
         // of an object without O(n) iteration through the object.
         return Object.keys(resolvedArgs[0]).length;
       }
    },

    _functionMap: function(resolvedArgs) {
      var mapped = [];
      var interpreter = this._interpreter;
      var exprefNode = resolvedArgs[0];
      var elements = resolvedArgs[1];
      for (var i = 0; i < elements.length; i++) {
          mapped.push(interpreter.visit(exprefNode, elements[i]));
      }
      return mapped;
    },

    _functionMerge: function(resolvedArgs) {
      var merged = {};
      for (var i = 0; i < resolvedArgs.length; i++) {
        var current = resolvedArgs[i];
        for (var key in current) {
          merged[key] = current[key];
        }
      }
      return merged;
    },

    _functionMax: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.max.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var maxElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
              }
          }
          return maxElement;
        }
      } else {
          return null;
      }
    },

    _functionMin: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.min.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var minElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
              }
          }
          return minElement;
        }
      } else {
        return null;
      }
    },

    _functionSum: function(resolvedArgs) {
      var sum = 0;
      var listToSum = resolvedArgs[0];
      for (var i = 0; i < listToSum.length; i++) {
        sum += listToSum[i];
      }
      return sum;
    },

    _functionType: function(resolvedArgs) {
        switch (this._getTypeName(resolvedArgs[0])) {
          case TYPE_NUMBER:
            return "number";
          case TYPE_STRING:
            return "string";
          case TYPE_ARRAY:
            return "array";
          case TYPE_OBJECT:
            return "object";
          case TYPE_BOOLEAN:
            return "boolean";
          case TYPE_EXPREF:
            return "expref";
          case TYPE_NULL:
            return "null";
        }
    },

    _functionKeys: function(resolvedArgs) {
        return Object.keys(resolvedArgs[0]);
    },

    _functionValues: function(resolvedArgs) {
        var obj = resolvedArgs[0];
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
        }
        return values;
    },

    _functionJoin: function(resolvedArgs) {
        var joinChar = resolvedArgs[0];
        var listJoin = resolvedArgs[1];
        return listJoin.join(joinChar);
    },

    _functionToArray: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
        } else {
            return [resolvedArgs[0]];
        }
    },

    _functionToString: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
        } else {
            return JSON.stringify(resolvedArgs[0]);
        }
    },

    _functionToNumber: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        var convertedValue;
        if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
        } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
                return convertedValue;
            }
        }
        return null;
    },

    _functionNotNull: function(resolvedArgs) {
        for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                return resolvedArgs[i];
            }
        }
        return null;
    },

    _functionSort: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        sortedArray.sort();
        return sortedArray;
    },

    _functionSortBy: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        if (sortedArray.length === 0) {
            return sortedArray;
        }
        var interpreter = this._interpreter;
        var exprefNode = resolvedArgs[1];
        var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0]));
        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
        }
        var that = this;
        // In order to get a stable sort out of an unstable
        // sort algorithm, we decorate/sort/undecorate (DSU)
        // by creating a new list of [index, element] pairs.
        // In the cmp function, if the evaluated elements are
        // equal, then the index will be used as the tiebreaker.
        // After the decorated list has been sorted, it will be
        // undecorated to extract the original elements.
        var decorated = [];
        for (var i = 0; i < sortedArray.length; i++) {
          decorated.push([i, sortedArray[i]]);
        }
        decorated.sort(function(a, b) {
          var exprA = interpreter.visit(exprefNode, a[1]);
          var exprB = interpreter.visit(exprefNode, b[1]);
          if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprA));
          } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprB));
          }
          if (exprA > exprB) {
            return 1;
          } else if (exprA < exprB) {
            return -1;
          } else {
            // If they're equal compare the items by their
            // order to maintain relative order of equal keys
            // (i.e. to get a stable sort).
            return a[0] - b[0];
          }
        });
        // Undecorate: extract out the original list elements.
        for (var j = 0; j < decorated.length; j++) {
          sortedArray[j] = decorated[j][1];
        }
        return sortedArray;
    },

    _functionMaxBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var maxNumber = -Infinity;
      var maxRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current > maxNumber) {
          maxNumber = current;
          maxRecord = resolvedArray[i];
        }
      }
      return maxRecord;
    },

    _functionMinBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var minNumber = Infinity;
      var minRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current < minNumber) {
          minNumber = current;
          minRecord = resolvedArray[i];
        }
      }
      return minRecord;
    },

    createKeyFunction: function(exprefNode, allowedTypes) {
      var that = this;
      var interpreter = this._interpreter;
      var keyFunc = function(x) {
        var current = interpreter.visit(exprefNode, x);
        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
          var msg = "TypeError: expected one of " + allowedTypes +
                    ", received " + that._getTypeName(current);
          throw new Error(msg);
        }
        return current;
      };
      return keyFunc;
    }

  };

  function compile(stream) {
    var parser = new Parser();
    var ast = parser.parse(stream);
    return ast;
  }

  function tokenize(stream) {
      var lexer = new Lexer();
      return lexer.tokenize(stream);
  }

  function search(data, expression) {
      var parser = new Parser();
      // This needs to be improved.  Both the interpreter and runtime depend on
      // each other.  The runtime needs the interpreter to support exprefs.
      // There's likely a clean way to avoid the cyclic dependency.
      var runtime = new Runtime();
      var interpreter = new TreeInterpreter(runtime);
      runtime._interpreter = interpreter;
      var node = parser.parse(expression);
      return interpreter.search(node, data);
  }

  exports.tokenize = tokenize;
  exports.compile = compile;
  exports.search = search;
  exports.strictDeepEqual = strictDeepEqual;
})( false ? 0 : exports);


/***/ }),

/***/ "./node_modules/.pnpm/make-dir@3.1.0/node_modules/make-dir/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/make-dir@3.1.0/node_modules/make-dir/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const {promisify} = __webpack_require__(/*! util */ "util");
const semver = __webpack_require__(/*! semver */ "./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");

const useNativeRecursiveOption = semver.satisfies(process.version, '>=10.12.0');

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
const checkPath = pth => {
	if (process.platform === 'win32') {
		const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));

		if (pathHasInvalidWinCharacters) {
			const error = new Error(`Path contains invalid characters: ${pth}`);
			error.code = 'EINVAL';
			throw error;
		}
	}
};

const processOptions = options => {
	// https://github.com/sindresorhus/make-dir/issues/18
	const defaults = {
		mode: 0o777,
		fs
	};

	return {
		...defaults,
		...options
	};
};

const permissionError = pth => {
	// This replicates the exception of `fs.mkdir` with native the
	// `recusive` option when run on an invalid drive under Windows.
	const error = new Error(`operation not permitted, mkdir '${pth}'`);
	error.code = 'EPERM';
	error.errno = -4048;
	error.path = pth;
	error.syscall = 'mkdir';
	return error;
};

const makeDir = async (input, options) => {
	checkPath(input);
	options = processOptions(options);

	const mkdir = promisify(options.fs.mkdir);
	const stat = promisify(options.fs.stat);

	if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {
		const pth = path.resolve(input);

		await mkdir(pth, {
			mode: options.mode,
			recursive: true
		});

		return pth;
	}

	const make = async pth => {
		try {
			await mkdir(pth, options.mode);

			return pth;
		} catch (error) {
			if (error.code === 'EPERM') {
				throw error;
			}

			if (error.code === 'ENOENT') {
				if (path.dirname(pth) === pth) {
					throw permissionError(pth);
				}

				if (error.message.includes('null bytes')) {
					throw error;
				}

				await make(path.dirname(pth));

				return make(pth);
			}

			try {
				const stats = await stat(pth);
				if (!stats.isDirectory()) {
					throw new Error('The path is not a directory');
				}
			} catch (_) {
				throw error;
			}

			return pth;
		}
	};

	return make(path.resolve(input));
};

module.exports = makeDir;

module.exports.sync = (input, options) => {
	checkPath(input);
	options = processOptions(options);

	if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {
		const pth = path.resolve(input);

		fs.mkdirSync(pth, {
			mode: options.mode,
			recursive: true
		});

		return pth;
	}

	const make = pth => {
		try {
			options.fs.mkdirSync(pth, options.mode);
		} catch (error) {
			if (error.code === 'EPERM') {
				throw error;
			}

			if (error.code === 'ENOENT') {
				if (path.dirname(pth) === pth) {
					throw permissionError(pth);
				}

				if (error.message.includes('null bytes')) {
					throw error;
				}

				make(path.dirname(pth));
				return make(pth);
			}

			try {
				if (!options.fs.statSync(pth).isDirectory()) {
					throw new Error('The path is not a directory');
				}
			} catch (_) {
				throw error;
			}
		}

		return pth;
	};

	return make(path.resolve(input));
};


/***/ }),

/***/ "./node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";


var isWindows = process.platform === 'win32';

// Regex to split a windows path into into [dir, root, basename, name, ext]
var splitWindowsRe =
    /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;

var win32 = {};

function win32SplitPath(filename) {
  return splitWindowsRe.exec(filename).slice(1);
}

win32.parse = function(pathString) {
  if (typeof pathString !== 'string') {
    throw new TypeError(
        "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = win32SplitPath(pathString);
  if (!allParts || allParts.length !== 5) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  return {
    root: allParts[1],
    dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
    base: allParts[2],
    ext: allParts[4],
    name: allParts[3]
  };
};



// Split a filename into [dir, root, basename, name, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
var posix = {};


function posixSplitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
}


posix.parse = function(pathString) {
  if (typeof pathString !== 'string') {
    throw new TypeError(
        "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = posixSplitPath(pathString);
  if (!allParts || allParts.length !== 5) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  
  return {
    root: allParts[1],
    dir: allParts[0].slice(0, -1),
    base: allParts[2],
    ext: allParts[4],
    name: allParts[3],
  };
};


if (isWindows)
  module.exports = win32.parse;
else /* posix */
  module.exports = posix.parse;

module.exports.posix = posix.parse;
module.exports.win32 = win32.parse;


/***/ }),

/***/ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const chalk = __webpack_require__(/*! chalk */ "./node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js")
const jmespath = __webpack_require__(/*! jmespath */ "./node_modules/.pnpm/jmespath@0.15.0/node_modules/jmespath/jmespath.js")
const colors = __webpack_require__(/*! ./lib/colors */ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/colors.js")
const { ERROR_LIKE_KEYS, MESSAGE_KEY, TIMESTAMP_KEY } = __webpack_require__(/*! ./lib/constants */ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/constants.js")
const {
  isObject,
  prettifyErrorLog,
  prettifyLevel,
  prettifyMessage,
  prettifyMetadata,
  prettifyObject,
  prettifyTime,
  filterLog
} = __webpack_require__(/*! ./lib/utils */ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/utils.js")

const bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/.pnpm/@hapi+bourne@2.1.0/node_modules/@hapi/bourne/lib/index.js")
const jsonParser = input => {
  try {
    return { value: bourne.parse(input, { protoAction: 'remove' }) }
  } catch (err) {
    return { err }
  }
}

const defaultOptions = {
  colorize: chalk.supportsColor,
  crlf: false,
  errorLikeObjectKeys: ERROR_LIKE_KEYS,
  errorProps: '',
  levelFirst: false,
  messageKey: MESSAGE_KEY,
  messageFormat: false,
  timestampKey: TIMESTAMP_KEY,
  translateTime: false,
  useMetadata: false,
  outputStream: process.stdout,
  customPrettifiers: {},
  hideObject: false,
  singleLine: false
}

module.exports = function prettyFactory (options) {
  const opts = Object.assign({}, defaultOptions, options)
  const EOL = opts.crlf ? '\r\n' : '\n'
  const IDENT = '    '
  const messageKey = opts.messageKey
  const levelKey = opts.levelKey
  const levelLabel = opts.levelLabel
  const messageFormat = opts.messageFormat
  const timestampKey = opts.timestampKey
  const errorLikeObjectKeys = opts.errorLikeObjectKeys
  const errorProps = opts.errorProps.split(',')
  const customPrettifiers = opts.customPrettifiers
  const ignoreKeys = opts.ignore ? new Set(opts.ignore.split(',')) : undefined
  const hideObject = opts.hideObject
  const singleLine = opts.singleLine

  const colorizer = colors(opts.colorize)
  const search = opts.search

  return pretty

  function pretty (inputData) {
    let log
    if (!isObject(inputData)) {
      const parsed = jsonParser(inputData)
      if (parsed.err || !isObject(parsed.value)) {
        // pass through
        return inputData + EOL
      }
      log = parsed.value
    } else {
      log = inputData
    }

    if (search && !jmespath.search(log, search)) {
      return
    }

    const prettifiedMessage = prettifyMessage({ log, messageKey, colorizer, messageFormat, levelLabel })

    if (ignoreKeys) {
      log = filterLog(log, ignoreKeys)
    }

    const prettifiedLevel = prettifyLevel({ log, colorizer, levelKey })
    const prettifiedMetadata = prettifyMetadata({ log })
    const prettifiedTime = prettifyTime({ log, translateFormat: opts.translateTime, timestampKey })

    let line = ''
    if (opts.levelFirst && prettifiedLevel) {
      line = `${prettifiedLevel}`
    }

    if (prettifiedTime && line === '') {
      line = `${prettifiedTime}`
    } else if (prettifiedTime) {
      line = `${line} ${prettifiedTime}`
    }

    if (!opts.levelFirst && prettifiedLevel) {
      if (line.length > 0) {
        line = `${line} ${prettifiedLevel}`
      } else {
        line = prettifiedLevel
      }
    }

    if (prettifiedMetadata) {
      if (line.length > 0) {
        line = `${line} ${prettifiedMetadata}:`
      } else {
        line = prettifiedMetadata
      }
    }

    if (line.endsWith(':') === false && line !== '') {
      line += ':'
    }

    if (prettifiedMessage) {
      if (line.length > 0) {
        line = `${line} ${prettifiedMessage}`
      } else {
        line = prettifiedMessage
      }
    }

    if (line.length > 0 && !singleLine) {
      line += EOL
    }

    if (log.type === 'Error' && log.stack) {
      const prettifiedErrorLog = prettifyErrorLog({
        log,
        errorLikeKeys: errorLikeObjectKeys,
        errorProperties: errorProps,
        ident: IDENT,
        eol: EOL
      })
      line += prettifiedErrorLog
    } else if (!hideObject) {
      const skipKeys = [messageKey, levelKey, timestampKey].filter(key => typeof log[key] === 'string' || typeof log[key] === 'number')
      const prettifiedObject = prettifyObject({
        input: log,
        skipKeys,
        customPrettifiers,
        errorLikeKeys: errorLikeObjectKeys,
        eol: EOL,
        ident: IDENT,
        singleLine,
        colorizer
      })

      // In single line mode, include a space only if prettified version isn't empty
      if (singleLine && !/^\s$/.test(prettifiedObject)) {
        line += ' '
      }
      line += prettifiedObject
    }

    return line
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/colors.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/colors.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { LEVELS, LEVEL_NAMES } = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/constants.js")

const nocolor = input => input
const plain = {
  default: nocolor,
  60: nocolor,
  50: nocolor,
  40: nocolor,
  30: nocolor,
  20: nocolor,
  10: nocolor,
  message: nocolor,
  greyMessage: nocolor
}

const chalk = __webpack_require__(/*! chalk */ "./node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js")
const ctx = new chalk.Instance({ level: 3 })
const colored = {
  default: ctx.white,
  60: ctx.bgRed,
  50: ctx.red,
  40: ctx.yellow,
  30: ctx.green,
  20: ctx.blue,
  10: ctx.grey,
  message: ctx.cyan,
  greyMessage: ctx.grey
}

function colorizeLevel (level, colorizer) {
  if (Number.isInteger(+level)) {
    return Object.prototype.hasOwnProperty.call(LEVELS, level)
      ? colorizer[level](LEVELS[level])
      : colorizer.default(LEVELS.default)
  }
  const levelNum = LEVEL_NAMES[level.toLowerCase()] || 'default'
  return colorizer[levelNum](LEVELS[levelNum])
}

function plainColorizer (level) {
  return colorizeLevel(level, plain)
}
plainColorizer.message = plain.message
plainColorizer.greyMessage = plain.greyMessage

function coloredColorizer (level) {
  return colorizeLevel(level, colored)
}
coloredColorizer.message = colored.message
coloredColorizer.greyMessage = colored.greyMessage

/**
 * Factory function get a function to colorized levels. The returned function
 * also includes a `.message(str)` method to colorize strings.
 *
 * @param {boolean} [useColors=false] When `true` a function that applies standard
 * terminal colors is returned.
 *
 * @returns {function} `function (level) {}` has a `.message(str)` method to
 * apply colorization to a string. The core function accepts either an integer
 * `level` or a `string` level. The integer level will map to a known level
 * string or to `USERLVL` if not known.  The string `level` will map to the same
 * colors as the integer `level` and will also default to `USERLVL` if the given
 * string is not a recognized level name.
 */
module.exports = function getColorizer (useColors = false) {
  return useColors ? coloredColorizer : plainColorizer
}


/***/ }),

/***/ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/constants.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/constants.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  DATE_FORMAT: 'yyyy-mm-dd HH:MM:ss.l o',

  ERROR_LIKE_KEYS: ['err', 'error'],

  MESSAGE_KEY: 'msg',

  LEVEL_KEY: 'level',

  LEVEL_LABEL: 'levelLabel',

  TIMESTAMP_KEY: 'time',

  LEVELS: {
    default: 'USERLVL',
    60: 'FATAL',
    50: 'ERROR',
    40: 'WARN',
    30: 'INFO',
    20: 'DEBUG',
    10: 'TRACE'
  },

  LEVEL_NAMES: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },

  // Object keys that probably came from a logger like Pino or Bunyan.
  LOGGER_KEYS: [
    'pid',
    'hostname',
    'name',
    'level',
    'time',
    'timestamp',
    'caller'
  ]
}


/***/ }),

/***/ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/utils.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/utils.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const clone = __webpack_require__(/*! rfdc */ "./node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js")()
const dateformat = __webpack_require__(/*! dateformat */ "./node_modules/.pnpm/dateformat@4.6.3/node_modules/dateformat/lib/dateformat.js")
const stringifySafe = __webpack_require__(/*! fast-safe-stringify */ "./node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js")
const defaultColorizer = __webpack_require__(/*! ./colors */ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/colors.js")()
const {
  DATE_FORMAT,
  ERROR_LIKE_KEYS,
  MESSAGE_KEY,
  LEVEL_KEY,
  LEVEL_LABEL,
  TIMESTAMP_KEY,
  LOGGER_KEYS,
  LEVELS
} = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/lib/constants.js")

module.exports = {
  isObject,
  prettifyErrorLog,
  prettifyLevel,
  prettifyMessage,
  prettifyMetadata,
  prettifyObject,
  prettifyTime,
  filterLog
}

module.exports.internals = {
  formatTime,
  joinLinesWithIndentation,
  prettifyError,
  deleteLogProperty
}

/**
 * Converts a given `epoch` to a desired display format.
 *
 * @param {number|string} epoch The time to convert. May be any value that is
 * valid for `new Date()`.
 * @param {boolean|string} [translateTime=false] When `false`, the given `epoch`
 * will simply be returned. When `true`, the given `epoch` will be converted
 * to a string at UTC using the `DATE_FORMAT` constant. If `translateTime` is
 * a string, the following rules are available:
 *
 * - `<format string>`: The string is a literal format string. This format
 * string will be used to interpret the `epoch` and return a display string
 * at UTC.
 * - `SYS:STANDARD`: The returned display string will follow the `DATE_FORMAT`
 * constant at the system's local timezone.
 * - `SYS:<format string>`: The returned display string will follow the given
 * `<format string>` at the system's local timezone.
 * - `UTC:<format string>`: The returned display string will follow the given
 * `<format string>` at UTC.
 *
 * @returns {number|string} The formatted time.
 */
function formatTime (epoch, translateTime = false) {
  if (translateTime === false) {
    return epoch
  }

  const instant = new Date(epoch)
  if (translateTime === true) {
    return dateformat(instant, 'UTC:' + DATE_FORMAT)
  }

  const upperFormat = translateTime.toUpperCase()
  if (upperFormat === 'SYS:STANDARD') {
    return dateformat(instant, DATE_FORMAT)
  }

  const prefix = upperFormat.substr(0, 4)
  if (prefix === 'SYS:' || prefix === 'UTC:') {
    if (prefix === 'UTC:') {
      return dateformat(instant, translateTime)
    }
    return dateformat(instant, translateTime.slice(4))
  }

  return dateformat(instant, `UTC:${translateTime}`)
}

function isObject (input) {
  return Object.prototype.toString.apply(input) === '[object Object]'
}

/**
 * Given a string with line separators, either `\r\n` or `\n`, add indentation
 * to all lines subsequent to the first line and rejoin the lines using an
 * end of line sequence.
 *
 * @param {object} input
 * @param {string} input.input The string to split and reformat.
 * @param {string} [input.ident] The indentation string. Default: `    ` (4 spaces).
 * @param {string} [input.eol] The end of line sequence to use when rejoining
 * the lines. Default: `'\n'`.
 *
 * @returns {string} A string with lines subsequent to the first indented
 * with the given indentation sequence.
 */
function joinLinesWithIndentation ({ input, ident = '    ', eol = '\n' }) {
  const lines = input.split(/\r?\n/)
  for (let i = 1; i < lines.length; i += 1) {
    lines[i] = ident + lines[i]
  }
  return lines.join(eol)
}

/**
 * Given a log object that has a `type: 'Error'` key, prettify the object and
 * return the result. In other
 *
 * @param {object} input
 * @param {object} input.log The error log to prettify.
 * @param {string} [input.messageKey] The name of the key that contains a
 * general log message. This is not the error's message property but the logger
 * messsage property. Default: `MESSAGE_KEY` constant.
 * @param {string} [input.ident] The sequence to use for indentation. Default: `'    '`.
 * @param {string} [input.eol] The sequence to use for EOL. Default: `'\n'`.
 * @param {string[]} [input.errorLikeKeys] A set of keys that should be considered
 * to have error objects as values. Default: `ERROR_LIKE_KEYS` constant.
 * @param {string[]} [input.errorProperties] A set of specific error object
 * properties, that are not the value of `messageKey`, `type`, or `stack`, to
 * include in the prettified result. The first entry in the list may be `'*'`
 * to indicate that all sibiling properties should be prettified. Default: `[]`.
 *
 * @returns {string} A sring that represents the prettified error log.
 */
function prettifyErrorLog ({
  log,
  messageKey = MESSAGE_KEY,
  ident = '    ',
  eol = '\n',
  errorLikeKeys = ERROR_LIKE_KEYS,
  errorProperties = []
}) {
  const stack = log.stack
  const joinedLines = joinLinesWithIndentation({ input: stack, ident, eol })
  let result = `${ident}${joinedLines}${eol}`

  if (errorProperties.length > 0) {
    const excludeProperties = LOGGER_KEYS.concat(messageKey, 'type', 'stack')
    let propertiesToPrint
    if (errorProperties[0] === '*') {
      // Print all sibling properties except for the standard exclusions.
      propertiesToPrint = Object.keys(log).filter(k => excludeProperties.includes(k) === false)
    } else {
      // Print only sepcified properties unless the property is a standard exclusion.
      propertiesToPrint = errorProperties.filter(k => excludeProperties.includes(k) === false)
    }

    for (let i = 0; i < propertiesToPrint.length; i += 1) {
      const key = propertiesToPrint[i]
      if (key in log === false) continue
      if (isObject(log[key])) {
        // The nested object may have "logger" type keys but since they are not
        // at the root level of the object being processed, we want to print them.
        // Thus, we invoke with `excludeLoggerKeys: false`.
        const prettifiedObject = prettifyObject({ input: log[key], errorLikeKeys, excludeLoggerKeys: false, eol, ident })
        result = `${result}${key}: {${eol}${prettifiedObject}}${eol}`
        continue
      }
      result = `${result}${key}: ${log[key]}${eol}`
    }
  }

  return result
}

/**
 * Checks if the passed in log has a `level` value and returns a prettified
 * string for that level if so.
 *
 * @param {object} input
 * @param {object} input.log The log object.
 * @param {function} [input.colorizer] A colorizer function that accepts a level
 * value and returns a colorized string. Default: a no-op colorizer.
 * @param {string} [levelKey='level'] The key to find the level under.
 *
 * @returns {undefined|string} If `log` does not have a `level` property then
 * `undefined` will be returned. Otherwise, a string from the specified
 * `colorizer` is returned.
 */
function prettifyLevel ({ log, colorizer = defaultColorizer, levelKey = LEVEL_KEY }) {
  if (levelKey in log === false) return undefined
  return colorizer(log[levelKey])
}

/**
 * Prettifies a message string if the given `log` has a message property.
 *
 * @param {object} input
 * @param {object} input.log The log object with the message to colorize.
 * @param {string} [input.messageKey='msg'] The property of the `log` that is the
 * message to be prettified.
 * @param {string|function} [input.messageFormat=undefined] A format string or function that defines how the
 *  logged message should be formatted, e.g. `'{level} - {pid}'`.
 * @param {function} [input.colorizer] A colorizer function that has a
 * `.message(str)` method attached to it. This function should return a colorized
 * string which will be the "prettified" message. Default: a no-op colorizer.
 *
 * @returns {undefined|string} If the message key is not found, or the message
 * key is not a string, then `undefined` will be returned. Otherwise, a string
 * that is the prettified message.
 */
function prettifyMessage ({ log, messageFormat, messageKey = MESSAGE_KEY, colorizer = defaultColorizer, levelLabel = LEVEL_LABEL }) {
  if (messageFormat && typeof messageFormat === 'string') {
    const message = String(messageFormat).replace(/{([^{}]+)}/g, function (match, p1) {
      // return log level as string instead of int
      if (p1 === levelLabel && log[LEVEL_KEY]) {
        return LEVELS[log[LEVEL_KEY]]
      }
      // Parse nested key access, e.g. `{keyA.subKeyB}`.
      return p1.split('.').reduce(function (prev, curr) {
        if (prev && prev[curr]) {
          return prev[curr]
        }
        return ''
      }, log)
    })
    return colorizer.message(message)
  }
  if (messageFormat && typeof messageFormat === 'function') {
    const msg = messageFormat(log, messageKey, levelLabel)
    return colorizer.message(msg)
  }
  if (messageKey in log === false) return undefined
  if (typeof log[messageKey] !== 'string') return undefined
  return colorizer.message(log[messageKey])
}

/**
 * Prettifies metadata that is usually present in a Pino log line. It looks for
 * fields `name`, `pid`, `hostname`, and `caller` and returns a formatted string using
 * the fields it finds.
 *
 * @param {object} input
 * @param {object} input.log The log that may or may not contain metadata to
 * be prettified.
 *
 * @returns {undefined|string} If no metadata is found then `undefined` is
 * returned. Otherwise, a string of prettified metadata is returned.
 */
function prettifyMetadata ({ log }) {
  let line = ''

  if (log.name || log.pid || log.hostname) {
    line += '('

    if (log.name) {
      line += log.name
    }

    if (log.name && log.pid) {
      line += '/' + log.pid
    } else if (log.pid) {
      line += log.pid
    }

    if (log.hostname) {
      // If `pid` and `name` were in the ignore keys list then we don't need
      // the leading space.
      line += `${line === '(' ? 'on' : ' on'} ${log.hostname}`
    }

    line += ')'
  }

  if (log.caller) {
    line += `${line === '' ? '' : ' '}<${log.caller}>`
  }

  if (line === '') {
    return undefined
  } else {
    return line
  }
}

/**
 * Prettifies a standard object. Special care is taken when processing the object
 * to handle child objects that are attached to keys known to contain error
 * objects.
 *
 * @param {object} input
 * @param {object} input.input The object to prettify.
 * @param {string} [input.ident] The identation sequence to use. Default: `'    '`.
 * @param {string} [input.eol] The EOL sequence to use. Default: `'\n'`.
 * @param {string[]} [input.skipKeys] A set of object keys to exclude from the
 * prettified result. Default: `[]`.
 * @param {Object<string, function>} [input.customPrettifiers] Dictionary of
 * custom prettifiers. Default: `{}`.
 * @param {string[]} [input.errorLikeKeys] A set of object keys that contain
 * error objects. Default: `ERROR_LIKE_KEYS` constant.
 * @param {boolean} [input.excludeLoggerKeys] Indicates if known logger specific
 * keys should be excluded from prettification. Default: `true`.
 * @param {boolean} [input.singleLine] Should non-error keys all be formatted
 * on a single line? This does NOT apply to errors, which will still be
 * multi-line. Default: `false`
 *
 * @returns {string} The prettified string. This can be as little as `''` if
 * there was nothing to prettify.
 */
function prettifyObject ({
  input,
  ident = '    ',
  eol = '\n',
  skipKeys = [],
  customPrettifiers = {},
  errorLikeKeys = ERROR_LIKE_KEYS,
  excludeLoggerKeys = true,
  singleLine = false,
  colorizer = defaultColorizer
}) {
  const keysToIgnore = [].concat(skipKeys)

  if (excludeLoggerKeys === true) Array.prototype.push.apply(keysToIgnore, LOGGER_KEYS)

  let result = ''

  // Split object keys into two categories: error and non-error
  const { plain, errors } = Object.entries(input).reduce(({ plain, errors }, [k, v]) => {
    if (keysToIgnore.includes(k) === false) {
      // Pre-apply custom prettifiers, because all 3 cases below will need this
      const pretty = typeof customPrettifiers[k] === 'function'
        ? customPrettifiers[k](v, k, input)
        : v
      if (errorLikeKeys.includes(k)) {
        errors[k] = pretty
      } else {
        plain[k] = pretty
      }
    }
    return { plain, errors }
  }, { plain: {}, errors: {} })

  if (singleLine) {
    // Stringify the entire object as a single JSON line
    if (Object.keys(plain).length > 0) {
      result += colorizer.greyMessage(stringifySafe(plain))
    }
    result += eol
  } else {
    // Put each object entry on its own line
    Object.entries(plain).forEach(([keyName, keyValue]) => {
      // custom prettifiers are already applied above, so we can skip it now
      const lines = typeof customPrettifiers[keyName] === 'function'
        ? keyValue
        : stringifySafe(keyValue, null, 2)

      if (lines === undefined) return

      const joinedLines = joinLinesWithIndentation({ input: lines, ident, eol })
      result += `${ident}${keyName}: ${joinedLines}${eol}`
    })
  }

  // Errors
  Object.entries(errors).forEach(([keyName, keyValue]) => {
    // custom prettifiers are already applied above, so we can skip it now
    const lines = typeof customPrettifiers[keyName] === 'function'
      ? keyValue
      : stringifySafe(keyValue, null, 2)

    if (lines === undefined) return

    result += prettifyError({ keyName, lines, eol, ident })
  })

  return result
}

/**
 * Prettifies a timestamp if the given `log` has either `time`, `timestamp` or custom specified timestamp
 * property.
 *
 * @param {object} input
 * @param {object} input.log The log object with the timestamp to be prettified.
 * @param {string} [input.timestampKey='time'] The log property that should be used to resolve timestamp value
 * @param {boolean|string} [input.translateFormat=undefined] When `true` the
 * timestamp will be prettified into a string at UTC using the default
 * `DATE_FORMAT`. If a string, then `translateFormat` will be used as the format
 * string to determine the output; see the `formatTime` function for details.
 *
 * @returns {undefined|string} If a timestamp property cannot be found then
 * `undefined` is returned. Otherwise, the prettified time is returned as a
 * string.
 */
function prettifyTime ({ log, timestampKey = TIMESTAMP_KEY, translateFormat = undefined }) {
  let time = null

  if (timestampKey in log) {
    time = log[timestampKey]
  } else if ('timestamp' in log) {
    time = log.timestamp
  }

  if (time === null) return undefined
  if (translateFormat) {
    return '[' + formatTime(time, translateFormat) + ']'
  }

  return `[${time}]`
}

/**
 * Prettifies an error string into a multi-line format.
 * @param {object} input
 * @param {string} input.keyName The key assigned to this error in the log object
 * @param {string} input.lines The STRINGIFIED error. If the error field has a
 *  custom prettifier, that should be pre-applied as well
 * @param {string} input.ident The indentation sequence to use
 * @param {string} input.eol The EOL sequence to use
 */
function prettifyError ({ keyName, lines, eol, ident }) {
  let result = ''
  const joinedLines = joinLinesWithIndentation({ input: lines, ident, eol })
  const splitLines = `${ident}${keyName}: ${joinedLines}${eol}`.split(eol)

  for (let j = 0; j < splitLines.length; j += 1) {
    if (j !== 0) result += eol

    const line = splitLines[j]
    if (/^\s*"stack"/.test(line)) {
      const matches = /^(\s*"stack":)\s*(".*"),?$/.exec(line)
      /* istanbul ignore else */
      if (matches && matches.length === 3) {
        const indentSize = /^\s*/.exec(line)[0].length + 4
        const indentation = ' '.repeat(indentSize)
        const stackMessage = matches[2]
        result += matches[1] + eol + indentation + JSON.parse(stackMessage).replace(/\n/g, eol + indentation)
      }
    } else {
      result += line
    }
  }

  return result
}

/**
 * Deletes a specified property from a log object if it exists.
 * This function mutates the passed in `log` object.
 *
 * @param {object} log The log object to be modified.
 * @param {string} property A string identifying the property to be deleted from
 * the log object. Accepts nested properties delimited by a `.`
 * e.g. `'prop1.prop2'`.
 */
function deleteLogProperty (log, property) {
  const props = property.split('.')
  const propToDelete = props.pop()

  props.forEach((prop) => {
    if (!Object.prototype.hasOwnProperty.call(log, prop)) {
      return
    }
    log = log[prop]
  })

  delete log[propToDelete]
}

/**
 * Filter a log object by removing any ignored keys.
 *
 * @param {object} log The log object to be modified.
 * @param {string} ignoreKeys An array of strings identifying the properties to be removed.
 *
 * @returns {object} A new `log` object instance that does not include the ignored keys.
 */
function filterLog (log, ignoreKeys) {
  const logCopy = clone(log)
  ignoreKeys.forEach((ignoreKey) => {
    deleteLogProperty(logCopy, ignoreKey)
  })
  return logCopy
}


/***/ }),

/***/ "./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/index.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const errSerializer = __webpack_require__(/*! ./lib/err */ "./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/lib/err.js")
const reqSerializers = __webpack_require__(/*! ./lib/req */ "./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/lib/req.js")
const resSerializers = __webpack_require__(/*! ./lib/res */ "./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/lib/res.js")

module.exports = {
  err: errSerializer,
  mapHttpRequest: reqSerializers.mapHttpRequest,
  mapHttpResponse: resSerializers.mapHttpResponse,
  req: reqSerializers.reqSerializer,
  res: resSerializers.resSerializer,

  wrapErrorSerializer: function wrapErrorSerializer (customSerializer) {
    if (customSerializer === errSerializer) return customSerializer
    return function wrapErrSerializer (err) {
      return customSerializer(errSerializer(err))
    }
  },

  wrapRequestSerializer: function wrapRequestSerializer (customSerializer) {
    if (customSerializer === reqSerializers.reqSerializer) return customSerializer
    return function wrappedReqSerializer (req) {
      return customSerializer(reqSerializers.reqSerializer(req))
    }
  },

  wrapResponseSerializer: function wrapResponseSerializer (customSerializer) {
    if (customSerializer === resSerializers.resSerializer) return customSerializer
    return function wrappedResSerializer (res) {
      return customSerializer(resSerializers.resSerializer(res))
    }
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/lib/err.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/lib/err.js ***!
  \****************************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = errSerializer

const { toString } = Object.prototype
const seen = Symbol('circular-ref-tag')
const rawSymbol = Symbol('pino-raw-err-ref')
const pinoErrProto = Object.create({}, {
  type: {
    enumerable: true,
    writable: true,
    value: undefined
  },
  message: {
    enumerable: true,
    writable: true,
    value: undefined
  },
  stack: {
    enumerable: true,
    writable: true,
    value: undefined
  },
  raw: {
    enumerable: false,
    get: function () {
      return this[rawSymbol]
    },
    set: function (val) {
      this[rawSymbol] = val
    }
  }
})
Object.defineProperty(pinoErrProto, rawSymbol, {
  writable: true,
  value: {}
})

function errSerializer (err) {
  if (!(err instanceof Error)) {
    return err
  }

  err[seen] = undefined // tag to prevent re-looking at this
  const _err = Object.create(pinoErrProto)
  _err.type = toString.call(err.constructor) === '[object Function]'
    ? err.constructor.name
    : err.name
  _err.message = err.message
  _err.stack = err.stack
  for (const key in err) {
    if (_err[key] === undefined) {
      const val = err[key]
      if (val instanceof Error) {
        /* eslint-disable no-prototype-builtins */
        if (!val.hasOwnProperty(seen)) {
          _err[key] = errSerializer(val)
        }
      } else {
        _err[key] = val
      }
    }
  }

  delete err[seen] // clean up tag in case err is serialized again later
  _err.raw = err
  return _err
}


/***/ }),

/***/ "./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/lib/req.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/lib/req.js ***!
  \****************************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  mapHttpRequest,
  reqSerializer
}

const rawSymbol = Symbol('pino-raw-req-ref')
const pinoReqProto = Object.create({}, {
  id: {
    enumerable: true,
    writable: true,
    value: ''
  },
  method: {
    enumerable: true,
    writable: true,
    value: ''
  },
  url: {
    enumerable: true,
    writable: true,
    value: ''
  },
  query: {
    enumerable: true,
    writable: true,
    value: ''
  },
  params: {
    enumerable: true,
    writable: true,
    value: ''
  },
  headers: {
    enumerable: true,
    writable: true,
    value: {}
  },
  remoteAddress: {
    enumerable: true,
    writable: true,
    value: ''
  },
  remotePort: {
    enumerable: true,
    writable: true,
    value: ''
  },
  raw: {
    enumerable: false,
    get: function () {
      return this[rawSymbol]
    },
    set: function (val) {
      this[rawSymbol] = val
    }
  }
})
Object.defineProperty(pinoReqProto, rawSymbol, {
  writable: true,
  value: {}
})

function reqSerializer (req) {
  // req.info is for hapi compat.
  const connection = req.info || req.socket
  const _req = Object.create(pinoReqProto)
  _req.id = (typeof req.id === 'function' ? req.id() : (req.id || (req.info ? req.info.id : undefined)))
  _req.method = req.method
  // req.originalUrl is for expressjs compat.
  if (req.originalUrl) {
    _req.url = req.originalUrl
    _req.query = req.query
    _req.params = req.params
  } else {
    // req.url.path is  for hapi compat.
    _req.url = req.path || (req.url ? (req.url.path || req.url) : undefined)
  }
  _req.headers = req.headers
  _req.remoteAddress = connection && connection.remoteAddress
  _req.remotePort = connection && connection.remotePort
  // req.raw is  for hapi compat/equivalence
  _req.raw = req.raw || req
  return _req
}

function mapHttpRequest (req) {
  return {
    req: reqSerializer(req)
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/lib/res.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/lib/res.js ***!
  \****************************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  mapHttpResponse,
  resSerializer
}

const rawSymbol = Symbol('pino-raw-res-ref')
const pinoResProto = Object.create({}, {
  statusCode: {
    enumerable: true,
    writable: true,
    value: 0
  },
  headers: {
    enumerable: true,
    writable: true,
    value: ''
  },
  raw: {
    enumerable: false,
    get: function () {
      return this[rawSymbol]
    },
    set: function (val) {
      this[rawSymbol] = val
    }
  }
})
Object.defineProperty(pinoResProto, rawSymbol, {
  writable: true,
  value: {}
})

function resSerializer (res) {
  const _res = Object.create(pinoResProto)
  _res.statusCode = res.statusCode
  _res.headers = res.getHeaders ? res.getHeaders() : res._headers
  _res.raw = res
  return _res
}

function mapHttpResponse (res) {
  return {
    res: resSerializer(res)
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/deprecations.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/deprecations.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const warning = __webpack_require__(/*! process-warning */ "./node_modules/.pnpm/process-warning@1.0.0/node_modules/process-warning/index.js")()
module.exports = warning

const warnName = 'PinoWarning'

warning.create(warnName, 'PINODEP004', 'bindings.serializers is deprecated, use options.serializers option instead')

warning.create(warnName, 'PINODEP005', 'bindings.formatters is deprecated, use options.formatters option instead')

warning.create(warnName, 'PINODEP006', 'bindings.customLevels is deprecated, use options.customLevels option instead')

warning.create(warnName, 'PINODEP007', 'bindings.level is deprecated, use options.level option instead')


/***/ }),

/***/ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/levels.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/levels.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint no-prototype-builtins: 0 */
const flatstr = __webpack_require__(/*! flatstr */ "./node_modules/.pnpm/flatstr@1.0.12/node_modules/flatstr/index.js")
const {
  lsCacheSym,
  levelValSym,
  useOnlyCustomLevelsSym,
  streamSym,
  formattersSym,
  hooksSym
} = __webpack_require__(/*! ./symbols */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/symbols.js")
const { noop, genLog } = __webpack_require__(/*! ./tools */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/tools.js")

const levels = {
  trace: 10,
  debug: 20,
  info: 30,
  warn: 40,
  error: 50,
  fatal: 60
}
const levelMethods = {
  fatal: (hook) => {
    const logFatal = genLog(levels.fatal, hook)
    return function (...args) {
      const stream = this[streamSym]
      logFatal.call(this, ...args)
      if (typeof stream.flushSync === 'function') {
        try {
          stream.flushSync()
        } catch (e) {
          // https://github.com/pinojs/pino/pull/740#discussion_r346788313
        }
      }
    }
  },
  error: (hook) => genLog(levels.error, hook),
  warn: (hook) => genLog(levels.warn, hook),
  info: (hook) => genLog(levels.info, hook),
  debug: (hook) => genLog(levels.debug, hook),
  trace: (hook) => genLog(levels.trace, hook)
}

const nums = Object.keys(levels).reduce((o, k) => {
  o[levels[k]] = k
  return o
}, {})

const initialLsCache = Object.keys(nums).reduce((o, k) => {
  o[k] = flatstr('{"level":' + Number(k))
  return o
}, {})

function genLsCache (instance) {
  const formatter = instance[formattersSym].level
  const { labels } = instance.levels
  const cache = {}
  for (const label in labels) {
    const level = formatter(labels[label], Number(label))
    cache[label] = JSON.stringify(level).slice(0, -1)
  }
  instance[lsCacheSym] = cache
  return instance
}

function isStandardLevel (level, useOnlyCustomLevels) {
  if (useOnlyCustomLevels) {
    return false
  }

  switch (level) {
    case 'fatal':
    case 'error':
    case 'warn':
    case 'info':
    case 'debug':
    case 'trace':
      return true
    default:
      return false
  }
}

function setLevel (level) {
  const { labels, values } = this.levels
  if (typeof level === 'number') {
    if (labels[level] === undefined) throw Error('unknown level value' + level)
    level = labels[level]
  }
  if (values[level] === undefined) throw Error('unknown level ' + level)
  const preLevelVal = this[levelValSym]
  const levelVal = this[levelValSym] = values[level]
  const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym]
  const hook = this[hooksSym].logMethod

  for (const key in values) {
    if (levelVal > values[key]) {
      this[key] = noop
      continue
    }
    this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook)
  }

  this.emit(
    'level-change',
    level,
    levelVal,
    labels[preLevelVal],
    preLevelVal
  )
}

function getLevel (level) {
  const { levels, levelVal } = this
  // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)
  return (levels && levels.labels) ? levels.labels[levelVal] : ''
}

function isLevelEnabled (logLevel) {
  const { values } = this.levels
  const logLevelVal = values[logLevel]
  return logLevelVal !== undefined && (logLevelVal >= this[levelValSym])
}

function mappings (customLevels = null, useOnlyCustomLevels = false) {
  const customNums = customLevels
    /* eslint-disable */
    ? Object.keys(customLevels).reduce((o, k) => {
        o[customLevels[k]] = k
        return o
      }, {})
    : null
    /* eslint-enable */

  const labels = Object.assign(
    Object.create(Object.prototype, { Infinity: { value: 'silent' } }),
    useOnlyCustomLevels ? null : nums,
    customNums
  )
  const values = Object.assign(
    Object.create(Object.prototype, { silent: { value: Infinity } }),
    useOnlyCustomLevels ? null : levels,
    customLevels
  )
  return { labels, values }
}

function assertDefaultLevelFound (defaultLevel, customLevels, useOnlyCustomLevels) {
  if (typeof defaultLevel === 'number') {
    const values = [].concat(
      Object.keys(customLevels || {}).map(key => customLevels[key]),
      useOnlyCustomLevels ? [] : Object.keys(nums).map(level => +level),
      Infinity
    )
    if (!values.includes(defaultLevel)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`)
    }
    return
  }

  const labels = Object.assign(
    Object.create(Object.prototype, { silent: { value: Infinity } }),
    useOnlyCustomLevels ? null : levels,
    customLevels
  )
  if (!(defaultLevel in labels)) {
    throw Error(`default level:${defaultLevel} must be included in custom levels`)
  }
}

function assertNoLevelCollisions (levels, customLevels) {
  const { labels, values } = levels
  for (const k in customLevels) {
    if (k in values) {
      throw Error('levels cannot be overridden')
    }
    if (customLevels[k] in labels) {
      throw Error('pre-existing level values cannot be used for new levels')
    }
  }
}

module.exports = {
  initialLsCache,
  genLsCache,
  levelMethods,
  getLevel,
  setLevel,
  isLevelEnabled,
  mappings,
  assertNoLevelCollisions,
  assertDefaultLevelFound
}


/***/ }),

/***/ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/meta.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/meta.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { version } = __webpack_require__(/*! ../package.json */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/package.json")

module.exports = { version }


/***/ }),

/***/ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/proto.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/proto.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint no-prototype-builtins: 0 */

const { EventEmitter } = __webpack_require__(/*! events */ "events")
const SonicBoom = __webpack_require__(/*! sonic-boom */ "./node_modules/.pnpm/sonic-boom@1.4.1/node_modules/sonic-boom/index.js")
const flatstr = __webpack_require__(/*! flatstr */ "./node_modules/.pnpm/flatstr@1.0.12/node_modules/flatstr/index.js")
const warning = __webpack_require__(/*! ./deprecations */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/deprecations.js")
const {
  lsCacheSym,
  levelValSym,
  setLevelSym,
  getLevelSym,
  chindingsSym,
  parsedChindingsSym,
  mixinSym,
  asJsonSym,
  writeSym,
  mixinMergeStrategySym,
  timeSym,
  timeSliceIndexSym,
  streamSym,
  serializersSym,
  formattersSym,
  useOnlyCustomLevelsSym,
  needsMetadataGsym,
  redactFmtSym,
  stringifySym,
  formatOptsSym,
  stringifiersSym
} = __webpack_require__(/*! ./symbols */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/symbols.js")
const {
  getLevel,
  setLevel,
  isLevelEnabled,
  mappings,
  initialLsCache,
  genLsCache,
  assertNoLevelCollisions
} = __webpack_require__(/*! ./levels */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/levels.js")
const {
  asChindings,
  asJson,
  buildFormatters,
  stringify
} = __webpack_require__(/*! ./tools */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/tools.js")
const {
  version
} = __webpack_require__(/*! ./meta */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/meta.js")
const redaction = __webpack_require__(/*! ./redaction */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/redaction.js")

// note: use of class is satirical
// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127
const constructor = class Pino {}
const prototype = {
  constructor,
  child,
  bindings,
  setBindings,
  flush,
  isLevelEnabled,
  version,
  get level () { return this[getLevelSym]() },
  set level (lvl) { this[setLevelSym](lvl) },
  get levelVal () { return this[levelValSym] },
  set levelVal (n) { throw Error('levelVal is read-only') },
  [lsCacheSym]: initialLsCache,
  [writeSym]: write,
  [asJsonSym]: asJson,
  [getLevelSym]: getLevel,
  [setLevelSym]: setLevel
}

Object.setPrototypeOf(prototype, EventEmitter.prototype)

// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing
module.exports = function () {
  return Object.create(prototype)
}

const resetChildingsFormatter = bindings => bindings
function child (bindings, options) {
  if (!bindings) {
    throw Error('missing bindings for child Pino')
  }
  options = options || {} // default options to empty object
  const serializers = this[serializersSym]
  const formatters = this[formattersSym]
  const instance = Object.create(this)

  if (bindings.hasOwnProperty('serializers') === true) {
    warning.emit('PINODEP004')
    options.serializers = bindings.serializers
  }
  if (bindings.hasOwnProperty('formatters') === true) {
    warning.emit('PINODEP005')
    options.formatters = bindings.formatters
  }
  if (bindings.hasOwnProperty('customLevels') === true) {
    warning.emit('PINODEP006')
    options.customLevels = bindings.customLevels
  }
  if (bindings.hasOwnProperty('level') === true) {
    warning.emit('PINODEP007')
    options.level = bindings.level
  }
  if (options.hasOwnProperty('serializers') === true) {
    instance[serializersSym] = Object.create(null)

    for (const k in serializers) {
      instance[serializersSym][k] = serializers[k]
    }
    const parentSymbols = Object.getOwnPropertySymbols(serializers)
    /* eslint no-var: off */
    for (var i = 0; i < parentSymbols.length; i++) {
      const ks = parentSymbols[i]
      instance[serializersSym][ks] = serializers[ks]
    }

    for (const bk in options.serializers) {
      instance[serializersSym][bk] = options.serializers[bk]
    }
    const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers)
    for (var bi = 0; bi < bindingsSymbols.length; bi++) {
      const bks = bindingsSymbols[bi]
      instance[serializersSym][bks] = options.serializers[bks]
    }
  } else instance[serializersSym] = serializers
  if (options.hasOwnProperty('formatters')) {
    const { level, bindings: chindings, log } = options.formatters
    instance[formattersSym] = buildFormatters(
      level || formatters.level,
      chindings || resetChildingsFormatter,
      log || formatters.log
    )
  } else {
    instance[formattersSym] = buildFormatters(
      formatters.level,
      resetChildingsFormatter,
      formatters.log
    )
  }
  if (options.hasOwnProperty('customLevels') === true) {
    assertNoLevelCollisions(this.levels, options.customLevels)
    instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym])
    genLsCache(instance)
  }

  // redact must place before asChindings and only replace if exist
  if ((typeof options.redact === 'object' && options.redact !== null) || Array.isArray(options.redact)) {
    instance.redact = options.redact // replace redact directly
    const stringifiers = redaction(instance.redact, stringify)
    const formatOpts = { stringify: stringifiers[redactFmtSym] }
    instance[stringifySym] = stringify
    instance[stringifiersSym] = stringifiers
    instance[formatOptsSym] = formatOpts
  }

  instance[chindingsSym] = asChindings(instance, bindings)
  const childLevel = options.level || this.level
  instance[setLevelSym](childLevel)

  return instance
}

function bindings () {
  const chindings = this[chindingsSym]
  const chindingsJson = `{${chindings.substr(1)}}` // at least contains ,"pid":7068,"hostname":"myMac"
  const bindingsFromJson = JSON.parse(chindingsJson)
  delete bindingsFromJson.pid
  delete bindingsFromJson.hostname
  return bindingsFromJson
}

function setBindings (newBindings) {
  const chindings = asChindings(this, newBindings)
  this[chindingsSym] = chindings
  delete this[parsedChindingsSym]
}

/**
 * Default strategy for creating `mergeObject` from arguments and the result from `mixin()`.
 * Fields from `mergeObject` have higher priority in this strategy.
 *
 * @param {Object} mergeObject The object a user has supplied to the logging function.
 * @param {Object} mixinObject The result of the `mixin` method.
 * @return {Object}
 */
function defaultMixinMergeStrategy (mergeObject, mixinObject) {
  return Object.assign(mixinObject, mergeObject)
}

function write (_obj, msg, num) {
  const t = this[timeSym]()
  const mixin = this[mixinSym]
  const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy
  const objError = _obj instanceof Error
  let obj

  if (_obj === undefined || _obj === null) {
    obj = mixin ? mixin({}) : {}
  } else {
    obj = mixinMergeStrategy(_obj, mixin ? mixin(_obj) : {})
    if (!msg && objError) {
      msg = _obj.message
    }

    if (objError) {
      obj.stack = _obj.stack
      if (!obj.type) {
        obj.type = 'Error'
      }
    }
  }

  const s = this[asJsonSym](obj, msg, num, t)

  const stream = this[streamSym]
  if (stream[needsMetadataGsym] === true) {
    stream.lastLevel = num
    stream.lastObj = obj
    stream.lastMsg = msg
    stream.lastTime = t.slice(this[timeSliceIndexSym])
    stream.lastLogger = this // for child loggers
  }
  if (stream instanceof SonicBoom) stream.write(s)
  else stream.write(flatstr(s))
}

function flush () {
  const stream = this[streamSym]
  if ('flush' in stream) stream.flush()
}


/***/ }),

/***/ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/redaction.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/redaction.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fastRedact = __webpack_require__(/*! fast-redact */ "./node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/index.js")
const { redactFmtSym, wildcardFirstSym } = __webpack_require__(/*! ./symbols */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/symbols.js")
const { rx, validator } = fastRedact

const validate = validator({
  ERR_PATHS_MUST_BE_STRINGS: () => 'pino â€“ redacted paths must be strings',
  ERR_INVALID_PATH: (s) => `pino â€“ redact paths array contains an invalid path (${s})`
})

const CENSOR = '[Redacted]'
const strict = false // TODO should this be configurable?

function redaction (opts, serialize) {
  const { paths, censor } = handle(opts)

  const shape = paths.reduce((o, str) => {
    rx.lastIndex = 0
    const first = rx.exec(str)
    const next = rx.exec(str)

    // ns is the top-level path segment, brackets + quoting removed.
    let ns = first[1] !== undefined
      ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, '$1')
      : first[0]

    if (ns === '*') {
      ns = wildcardFirstSym
    }

    // top level key:
    if (next === null) {
      o[ns] = null
      return o
    }

    // path with at least two segments:
    // if ns is already redacted at the top level, ignore lower level redactions
    if (o[ns] === null) {
      return o
    }

    const { index } = next
    const nextPath = `${str.substr(index, str.length - 1)}`

    o[ns] = o[ns] || []

    // shape is a mix of paths beginning with literal values and wildcard
    // paths [ "a.b.c", "*.b.z" ] should reduce to a shape of
    // { "a": [ "b.c", "b.z" ], *: [ "b.z" ] }
    // note: "b.z" is in both "a" and * arrays because "a" matches the wildcard.
    // (* entry has wildcardFirstSym as key)
    if (ns !== wildcardFirstSym && o[ns].length === 0) {
      // first time ns's get all '*' redactions so far
      o[ns].push(...(o[wildcardFirstSym] || []))
    }

    if (ns === wildcardFirstSym) {
      // new * path gets added to all previously registered literal ns's.
      Object.keys(o).forEach(function (k) {
        if (o[k]) {
          o[k].push(nextPath)
        }
      })
    }

    o[ns].push(nextPath)
    return o
  }, {})

  // the redactor assigned to the format symbol key
  // provides top level redaction for instances where
  // an object is interpolated into the msg string
  const result = {
    [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
  }

  const topCensor = (...args) => {
    return typeof censor === 'function' ? serialize(censor(...args)) : serialize(censor)
  }

  return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
    // top level key:
    if (shape[k] === null) {
      o[k] = (value) => topCensor(value, [k])
    } else {
      const wrappedCensor = typeof censor === 'function'
        ? (value, path) => {
            return censor(value, [k, ...path])
          }
        : censor
      o[k] = fastRedact({
        paths: shape[k],
        censor: wrappedCensor,
        serialize,
        strict
      })
    }
    return o
  }, result)
}

function handle (opts) {
  if (Array.isArray(opts)) {
    opts = { paths: opts, censor: CENSOR }
    validate(opts)
    return opts
  }
  let { paths, censor = CENSOR, remove } = opts
  if (Array.isArray(paths) === false) { throw Error('pino â€“ redact must contain an array of strings') }
  if (remove === true) censor = undefined
  validate({ paths, censor })

  return { paths, censor }
}

module.exports = redaction


/***/ }),

/***/ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/symbols.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/symbols.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";


const setLevelSym = Symbol('pino.setLevel')
const getLevelSym = Symbol('pino.getLevel')
const levelValSym = Symbol('pino.levelVal')
const useLevelLabelsSym = Symbol('pino.useLevelLabels')
const useOnlyCustomLevelsSym = Symbol('pino.useOnlyCustomLevels')
const mixinSym = Symbol('pino.mixin')

const lsCacheSym = Symbol('pino.lsCache')
const chindingsSym = Symbol('pino.chindings')
const parsedChindingsSym = Symbol('pino.parsedChindings')

const asJsonSym = Symbol('pino.asJson')
const writeSym = Symbol('pino.write')
const redactFmtSym = Symbol('pino.redactFmt')

const timeSym = Symbol('pino.time')
const timeSliceIndexSym = Symbol('pino.timeSliceIndex')
const streamSym = Symbol('pino.stream')
const stringifySym = Symbol('pino.stringify')
const stringifiersSym = Symbol('pino.stringifiers')
const endSym = Symbol('pino.end')
const formatOptsSym = Symbol('pino.formatOpts')
const messageKeySym = Symbol('pino.messageKey')
const nestedKeySym = Symbol('pino.nestedKey')
const mixinMergeStrategySym = Symbol('pino.mixinMergeStrategy')

const wildcardFirstSym = Symbol('pino.wildcardFirst')

// public symbols, no need to use the same pino
// version for these
const serializersSym = Symbol.for('pino.serializers')
const formattersSym = Symbol.for('pino.formatters')
const hooksSym = Symbol.for('pino.hooks')
const needsMetadataGsym = Symbol.for('pino.metadata')

module.exports = {
  setLevelSym,
  getLevelSym,
  levelValSym,
  useLevelLabelsSym,
  mixinSym,
  lsCacheSym,
  chindingsSym,
  parsedChindingsSym,
  asJsonSym,
  writeSym,
  serializersSym,
  redactFmtSym,
  timeSym,
  timeSliceIndexSym,
  streamSym,
  stringifySym,
  stringifiersSym,
  endSym,
  formatOptsSym,
  messageKeySym,
  nestedKeySym,
  wildcardFirstSym,
  needsMetadataGsym,
  useOnlyCustomLevelsSym,
  formattersSym,
  hooksSym,
  mixinMergeStrategySym
}


/***/ }),

/***/ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/time.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/time.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


const nullTime = () => ''

const epochTime = () => `,"time":${Date.now()}`

const unixTime = () => `,"time":${Math.round(Date.now() / 1000.0)}`

const isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"` // using Date.now() for testability

module.exports = { nullTime, epochTime, unixTime, isoTime }


/***/ }),

/***/ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/tools.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/tools.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint no-prototype-builtins: 0 */

const format = __webpack_require__(/*! quick-format-unescaped */ "./node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js")
const { mapHttpRequest, mapHttpResponse } = __webpack_require__(/*! pino-std-serializers */ "./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/index.js")
const SonicBoom = __webpack_require__(/*! sonic-boom */ "./node_modules/.pnpm/sonic-boom@1.4.1/node_modules/sonic-boom/index.js")
const stringifySafe = __webpack_require__(/*! fast-safe-stringify */ "./node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js")
const {
  lsCacheSym,
  chindingsSym,
  parsedChindingsSym,
  writeSym,
  serializersSym,
  formatOptsSym,
  endSym,
  stringifiersSym,
  stringifySym,
  wildcardFirstSym,
  needsMetadataGsym,
  redactFmtSym,
  streamSym,
  nestedKeySym,
  formattersSym,
  messageKeySym
} = __webpack_require__(/*! ./symbols */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/symbols.js")

function noop () {}

function genLog (level, hook) {
  if (!hook) return LOG

  return function hookWrappedLog (...args) {
    hook.call(this, args, LOG, level)
  }

  function LOG (o, ...n) {
    if (typeof o === 'object') {
      let msg = o
      if (o !== null) {
        if (o.method && o.headers && o.socket) {
          o = mapHttpRequest(o)
        } else if (typeof o.setHeader === 'function') {
          o = mapHttpResponse(o)
        }
      }
      if (this[nestedKeySym]) o = { [this[nestedKeySym]]: o }
      let formatParams
      if (msg === null && n.length === 0) {
        formatParams = [null]
      } else {
        msg = n.shift()
        formatParams = n
      }
      this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level)
    } else {
      this[writeSym](null, format(o, n, this[formatOptsSym]), level)
    }
  }
}

// magically escape strings for json
// relying on their charCodeAt
// everything below 32 needs JSON.stringify()
// 34 and 92 happens all the time, so we
// have a fast case for them
function asString (str) {
  let result = ''
  let last = 0
  let found = false
  let point = 255
  const l = str.length
  if (l > 100) {
    return JSON.stringify(str)
  }
  for (var i = 0; i < l && point >= 32; i++) {
    point = str.charCodeAt(i)
    if (point === 34 || point === 92) {
      result += str.slice(last, i) + '\\'
      last = i
      found = true
    }
  }
  if (!found) {
    result = str
  } else {
    result += str.slice(last)
  }
  return point < 32 ? JSON.stringify(str) : '"' + result + '"'
}

function asJson (obj, msg, num, time) {
  const stringify = this[stringifySym]
  const stringifiers = this[stringifiersSym]
  const end = this[endSym]
  const chindings = this[chindingsSym]
  const serializers = this[serializersSym]
  const formatters = this[formattersSym]
  const messageKey = this[messageKeySym]
  let data = this[lsCacheSym][num] + time

  // we need the child bindings added to the output first so instance logged
  // objects can take precedence when JSON.parse-ing the resulting log line
  data = data + chindings

  let value
  const notHasOwnProperty = obj.hasOwnProperty === undefined
  if (formatters.log) {
    obj = formatters.log(obj)
  }
  if (msg !== undefined) {
    obj[messageKey] = msg
  }
  const wildcardStringifier = stringifiers[wildcardFirstSym]
  for (const key in obj) {
    value = obj[key]
    if ((notHasOwnProperty || obj.hasOwnProperty(key)) && value !== undefined) {
      value = serializers[key] ? serializers[key](value) : value

      const stringifier = stringifiers[key] || wildcardStringifier

      switch (typeof value) {
        case 'undefined':
        case 'function':
          continue
        case 'number':
          /* eslint no-fallthrough: "off" */
          if (Number.isFinite(value) === false) {
            value = null
          }
        // this case explicitly falls through to the next one
        case 'boolean':
          if (stringifier) value = stringifier(value)
          break
        case 'string':
          value = (stringifier || asString)(value)
          break
        default:
          value = (stringifier || stringify)(value)
      }
      if (value === undefined) continue
      data += ',"' + key + '":' + value
    }
  }

  return data + end
}

function asChindings (instance, bindings) {
  let value
  let data = instance[chindingsSym]
  const stringify = instance[stringifySym]
  const stringifiers = instance[stringifiersSym]
  const wildcardStringifier = stringifiers[wildcardFirstSym]
  const serializers = instance[serializersSym]
  const formatter = instance[formattersSym].bindings
  bindings = formatter(bindings)

  for (const key in bindings) {
    value = bindings[key]
    const valid = key !== 'level' &&
      key !== 'serializers' &&
      key !== 'formatters' &&
      key !== 'customLevels' &&
      bindings.hasOwnProperty(key) &&
      value !== undefined
    if (valid === true) {
      value = serializers[key] ? serializers[key](value) : value
      value = (stringifiers[key] || wildcardStringifier || stringify)(value)
      if (value === undefined) continue
      data += ',"' + key + '":' + value
    }
  }
  return data
}

function getPrettyStream (opts, prettifier, dest, instance) {
  if (prettifier && typeof prettifier === 'function') {
    prettifier = prettifier.bind(instance)
    return prettifierMetaWrapper(prettifier(opts), dest, opts)
  }
  try {
    const prettyFactory = (__webpack_require__(/*! pino-pretty */ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/index.js").prettyFactory) || __webpack_require__(/*! pino-pretty */ "./node_modules/.pnpm/pino-pretty@4.8.0/node_modules/pino-pretty/index.js")
    prettyFactory.asMetaWrapper = prettifierMetaWrapper
    return prettifierMetaWrapper(prettyFactory(opts), dest, opts)
  } catch (e) {
    if (e.message.startsWith("Cannot find module 'pino-pretty'")) {
      throw Error('Missing `pino-pretty` module: `pino-pretty` must be installed separately')
    };
    throw e
  }
}

function prettifierMetaWrapper (pretty, dest, opts) {
  opts = Object.assign({ suppressFlushSyncWarning: false }, opts)
  let warned = false
  return {
    [needsMetadataGsym]: true,
    lastLevel: 0,
    lastMsg: null,
    lastObj: null,
    lastLogger: null,
    flushSync () {
      if (opts.suppressFlushSyncWarning || warned) {
        return
      }
      warned = true
      setMetadataProps(dest, this)
      dest.write(pretty(Object.assign({
        level: 40, // warn
        msg: 'pino.final with prettyPrint does not support flushing',
        time: Date.now()
      }, this.chindings())))
    },
    chindings () {
      const lastLogger = this.lastLogger
      let chindings = null

      // protection against flushSync being called before logging
      // anything
      if (!lastLogger) {
        return null
      }

      if (lastLogger.hasOwnProperty(parsedChindingsSym)) {
        chindings = lastLogger[parsedChindingsSym]
      } else {
        chindings = JSON.parse('{' + lastLogger[chindingsSym].substr(1) + '}')
        lastLogger[parsedChindingsSym] = chindings
      }

      return chindings
    },
    write (chunk) {
      const lastLogger = this.lastLogger
      const chindings = this.chindings()

      let time = this.lastTime

      if (time.match(/^\d+/)) {
        time = parseInt(time)
      } else {
        time = time.slice(1, -1)
      }

      const lastObj = this.lastObj
      const lastMsg = this.lastMsg
      const errorProps = null

      const formatters = lastLogger[formattersSym]
      const formattedObj = formatters.log ? formatters.log(lastObj) : lastObj

      const messageKey = lastLogger[messageKeySym]
      if (lastMsg && formattedObj && !formattedObj.hasOwnProperty(messageKey)) {
        formattedObj[messageKey] = lastMsg
      }

      const obj = Object.assign({
        level: this.lastLevel,
        time
      }, formattedObj, errorProps)

      const serializers = lastLogger[serializersSym]
      const keys = Object.keys(serializers)

      for (var i = 0; i < keys.length; i++) {
        const key = keys[i]
        if (obj[key] !== undefined) {
          obj[key] = serializers[key](obj[key])
        }
      }

      for (const key in chindings) {
        if (!obj.hasOwnProperty(key)) {
          obj[key] = chindings[key]
        }
      }

      const stringifiers = lastLogger[stringifiersSym]
      const redact = stringifiers[redactFmtSym]

      const formatted = pretty(typeof redact === 'function' ? redact(obj) : obj)
      if (formatted === undefined) return

      setMetadataProps(dest, this)
      dest.write(formatted)
    }
  }
}

function hasBeenTampered (stream) {
  return stream.write !== stream.constructor.prototype.write
}

function buildSafeSonicBoom (opts) {
  const stream = new SonicBoom(opts)
  stream.on('error', filterBrokenPipe)
  return stream

  function filterBrokenPipe (err) {
    // TODO verify on Windows
    if (err.code === 'EPIPE') {
      // If we get EPIPE, we should stop logging here
      // however we have no control to the consumer of
      // SonicBoom, so we just overwrite the write method
      stream.write = noop
      stream.end = noop
      stream.flushSync = noop
      stream.destroy = noop
      return
    }
    stream.removeListener('error', filterBrokenPipe)
    stream.emit('error', err)
  }
}

function createArgsNormalizer (defaultOptions) {
  return function normalizeArgs (instance, opts = {}, stream) {
    // support stream as a string
    if (typeof opts === 'string') {
      stream = buildSafeSonicBoom({ dest: opts, sync: true })
      opts = {}
    } else if (typeof stream === 'string') {
      stream = buildSafeSonicBoom({ dest: stream, sync: true })
    } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
      stream = opts
      opts = null
    }
    opts = Object.assign({}, defaultOptions, opts)
    if ('extreme' in opts) {
      throw Error('The extreme option has been removed, use pino.destination({ sync: false }) instead')
    }
    if ('onTerminated' in opts) {
      throw Error('The onTerminated option has been removed, use pino.final instead')
    }
    if ('changeLevelName' in opts) {
      process.emitWarning(
        'The changeLevelName option is deprecated and will be removed in v7. Use levelKey instead.',
        { code: 'changeLevelName_deprecation' }
      )
      opts.levelKey = opts.changeLevelName
      delete opts.changeLevelName
    }
    const { enabled, prettyPrint, prettifier, messageKey } = opts
    if (enabled === false) opts.level = 'silent'
    stream = stream || process.stdout
    if (stream === process.stdout && stream.fd >= 0 && !hasBeenTampered(stream)) {
      stream = buildSafeSonicBoom({ fd: stream.fd, sync: true })
    }
    if (prettyPrint) {
      const prettyOpts = Object.assign({ messageKey }, prettyPrint)
      stream = getPrettyStream(prettyOpts, prettifier, stream, instance)
    }
    return { opts, stream }
  }
}

function final (logger, handler) {
  if (typeof logger === 'undefined' || typeof logger.child !== 'function') {
    throw Error('expected a pino logger instance')
  }
  const hasHandler = (typeof handler !== 'undefined')
  if (hasHandler && typeof handler !== 'function') {
    throw Error('if supplied, the handler parameter should be a function')
  }
  const stream = logger[streamSym]
  if (typeof stream.flushSync !== 'function') {
    throw Error('final requires a stream that has a flushSync method, such as pino.destination')
  }

  const finalLogger = new Proxy(logger, {
    get: (logger, key) => {
      if (key in logger.levels.values) {
        return (...args) => {
          logger[key](...args)
          stream.flushSync()
        }
      }
      return logger[key]
    }
  })

  if (!hasHandler) {
    return finalLogger
  }

  return (err = null, ...args) => {
    try {
      stream.flushSync()
    } catch (e) {
      // it's too late to wait for the stream to be ready
      // because this is a final tick scenario.
      // in practice there shouldn't be a situation where it isn't
      // however, swallow the error just in case (and for easier testing)
    }
    return handler(err, finalLogger, ...args)
  }
}

function stringify (obj) {
  try {
    return JSON.stringify(obj)
  } catch (_) {
    return stringifySafe(obj)
  }
}

function buildFormatters (level, bindings, log) {
  return {
    level,
    bindings,
    log
  }
}

function setMetadataProps (dest, that) {
  if (dest[needsMetadataGsym] === true) {
    dest.lastLevel = that.lastLevel
    dest.lastMsg = that.lastMsg
    dest.lastObj = that.lastObj
    dest.lastTime = that.lastTime
    dest.lastLogger = that.lastLogger
  }
}

module.exports = {
  noop,
  buildSafeSonicBoom,
  getPrettyStream,
  asChindings,
  asJson,
  genLog,
  createArgsNormalizer,
  final,
  stringify,
  buildFormatters
}


/***/ }),

/***/ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/pino.js":
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/pino@6.14.0/node_modules/pino/pino.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint no-prototype-builtins: 0 */
const os = __webpack_require__(/*! os */ "os")
const stdSerializers = __webpack_require__(/*! pino-std-serializers */ "./node_modules/.pnpm/pino-std-serializers@3.2.0/node_modules/pino-std-serializers/index.js")
const redaction = __webpack_require__(/*! ./lib/redaction */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/redaction.js")
const time = __webpack_require__(/*! ./lib/time */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/time.js")
const proto = __webpack_require__(/*! ./lib/proto */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/proto.js")
const symbols = __webpack_require__(/*! ./lib/symbols */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/symbols.js")
const { assertDefaultLevelFound, mappings, genLsCache } = __webpack_require__(/*! ./lib/levels */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/levels.js")
const {
  createArgsNormalizer,
  asChindings,
  final,
  stringify,
  buildSafeSonicBoom,
  buildFormatters,
  noop
} = __webpack_require__(/*! ./lib/tools */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/tools.js")
const { version } = __webpack_require__(/*! ./lib/meta */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/meta.js")
const { mixinMergeStrategySym } = __webpack_require__(/*! ./lib/symbols */ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/lib/symbols.js")
const {
  chindingsSym,
  redactFmtSym,
  serializersSym,
  timeSym,
  timeSliceIndexSym,
  streamSym,
  stringifySym,
  stringifiersSym,
  setLevelSym,
  endSym,
  formatOptsSym,
  messageKeySym,
  nestedKeySym,
  mixinSym,
  useOnlyCustomLevelsSym,
  formattersSym,
  hooksSym
} = symbols
const { epochTime, nullTime } = time
const { pid } = process
const hostname = os.hostname()
const defaultErrorSerializer = stdSerializers.err
const defaultOptions = {
  level: 'info',
  messageKey: 'msg',
  nestedKey: null,
  enabled: true,
  prettyPrint: false,
  base: { pid, hostname },
  serializers: Object.assign(Object.create(null), {
    err: defaultErrorSerializer
  }),
  formatters: Object.assign(Object.create(null), {
    bindings (bindings) {
      return bindings
    },
    level (label, number) {
      return { level: number }
    }
  }),
  hooks: {
    logMethod: undefined
  },
  timestamp: epochTime,
  name: undefined,
  redact: null,
  customLevels: null,
  levelKey: undefined,
  useOnlyCustomLevels: false
}

const normalize = createArgsNormalizer(defaultOptions)

const serializers = Object.assign(Object.create(null), stdSerializers)

function pino (...args) {
  const instance = {}
  const { opts, stream } = normalize(instance, ...args)
  const {
    redact,
    crlf,
    serializers,
    timestamp,
    messageKey,
    nestedKey,
    base,
    name,
    level,
    customLevels,
    useLevelLabels,
    changeLevelName,
    levelKey,
    mixin,
    mixinMergeStrategy,
    useOnlyCustomLevels,
    formatters,
    hooks
  } = opts

  const allFormatters = buildFormatters(
    formatters.level,
    formatters.bindings,
    formatters.log
  )

  if (useLevelLabels && !(changeLevelName || levelKey)) {
    process.emitWarning('useLevelLabels is deprecated, use the formatters.level option instead', 'Warning', 'PINODEP001')
    allFormatters.level = labelsFormatter
  } else if ((changeLevelName || levelKey) && !useLevelLabels) {
    process.emitWarning('changeLevelName and levelKey are deprecated, use the formatters.level option instead', 'Warning', 'PINODEP002')
    allFormatters.level = levelNameFormatter(changeLevelName || levelKey)
  } else if ((changeLevelName || levelKey) && useLevelLabels) {
    process.emitWarning('useLevelLabels is deprecated, use the formatters.level option instead', 'Warning', 'PINODEP001')
    process.emitWarning('changeLevelName and levelKey are deprecated, use the formatters.level option instead', 'Warning', 'PINODEP002')
    allFormatters.level = levelNameLabelFormatter(changeLevelName || levelKey)
  }

  if (serializers[Symbol.for('pino.*')]) {
    process.emitWarning('The pino.* serializer is deprecated, use the formatters.log options instead', 'Warning', 'PINODEP003')
    allFormatters.log = serializers[Symbol.for('pino.*')]
  }

  if (!allFormatters.bindings) {
    allFormatters.bindings = defaultOptions.formatters.bindings
  }
  if (!allFormatters.level) {
    allFormatters.level = defaultOptions.formatters.level
  }

  const stringifiers = redact ? redaction(redact, stringify) : {}
  const formatOpts = redact
    ? { stringify: stringifiers[redactFmtSym] }
    : { stringify }
  const end = '}' + (crlf ? '\r\n' : '\n')
  const coreChindings = asChindings.bind(null, {
    [chindingsSym]: '',
    [serializersSym]: serializers,
    [stringifiersSym]: stringifiers,
    [stringifySym]: stringify,
    [formattersSym]: allFormatters
  })

  let chindings = ''
  if (base !== null) {
    if (name === undefined) {
      chindings = coreChindings(base)
    } else {
      chindings = coreChindings(Object.assign({}, base, { name }))
    }
  }

  const time = (timestamp instanceof Function)
    ? timestamp
    : (timestamp ? epochTime : nullTime)
  const timeSliceIndex = time().indexOf(':') + 1

  if (useOnlyCustomLevels && !customLevels) throw Error('customLevels is required if useOnlyCustomLevels is set true')
  if (mixin && typeof mixin !== 'function') throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`)

  assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels)
  const levels = mappings(customLevels, useOnlyCustomLevels)

  Object.assign(instance, {
    levels,
    [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
    [streamSym]: stream,
    [timeSym]: time,
    [timeSliceIndexSym]: timeSliceIndex,
    [stringifySym]: stringify,
    [stringifiersSym]: stringifiers,
    [endSym]: end,
    [formatOptsSym]: formatOpts,
    [messageKeySym]: messageKey,
    [nestedKeySym]: nestedKey,
    [serializersSym]: serializers,
    [mixinSym]: mixin,
    [mixinMergeStrategySym]: mixinMergeStrategy,
    [chindingsSym]: chindings,
    [formattersSym]: allFormatters,
    [hooksSym]: hooks,
    silent: noop
  })

  Object.setPrototypeOf(instance, proto())

  genLsCache(instance)

  instance[setLevelSym](level)

  return instance
}

function labelsFormatter (label, number) {
  return { level: label }
}

function levelNameFormatter (name) {
  return function (label, number) {
    return { [name]: number }
  }
}

function levelNameLabelFormatter (name) {
  return function (label, number) {
    return { [name]: label }
  }
}

module.exports = pino

module.exports.extreme = (dest = process.stdout.fd) => {
  process.emitWarning(
    'The pino.extreme() option is deprecated and will be removed in v7. Use pino.destination({ sync: false }) instead.',
    { code: 'extreme_deprecation' }
  )
  return buildSafeSonicBoom({ dest, minLength: 4096, sync: false })
}

module.exports.destination = (dest = process.stdout.fd) => {
  if (typeof dest === 'object') {
    dest.dest = dest.dest || process.stdout.fd
    return buildSafeSonicBoom(dest)
  } else {
    return buildSafeSonicBoom({ dest, minLength: 0, sync: true })
  }
}

module.exports.final = final
module.exports.levels = mappings()
module.exports.stdSerializers = serializers
module.exports.stdTimeFunctions = Object.assign({}, time)
module.exports.symbols = symbols
module.exports.version = version

// Enables default and name export with TypeScript and Babel
module.exports["default"] = pino
module.exports.pino = pino


/***/ }),

/***/ "./node_modules/.pnpm/process-warning@1.0.0/node_modules/process-warning/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/process-warning@1.0.0/node_modules/process-warning/index.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { format } = __webpack_require__(/*! util */ "util")

function build () {
  const codes = {}
  const emitted = new Map()

  function create (name, code, message) {
    if (!name) throw new Error('Warning name must not be empty')
    if (!code) throw new Error('Warning code must not be empty')
    if (!message) throw new Error('Warning message must not be empty')

    code = code.toUpperCase()

    if (codes[code] !== undefined) {
      throw new Error(`The code '${code}' already exist`)
    }

    function buildWarnOpts (a, b, c) {
      // more performant than spread (...) operator
      let formatted
      if (a && b && c) {
        formatted = format(message, a, b, c)
      } else if (a && b) {
        formatted = format(message, a, b)
      } else if (a) {
        formatted = format(message, a)
      } else {
        formatted = message
      }

      return {
        code,
        name,
        message: formatted
      }
    }

    emitted.set(code, false)
    codes[code] = buildWarnOpts

    return codes[code]
  }

  function emit (code, a, b, c) {
    if (codes[code] === undefined) throw new Error(`The code '${code}' does not exist`)
    if (emitted.get(code) === true) return
    emitted.set(code, true)

    const warning = codes[code](a, b, c)
    process.emitWarning(warning.message, warning.name, warning.code)
  }

  return {
    create,
    emit,
    emitted
  }
}

module.exports = build


/***/ }),

/***/ "./node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js ***!
  \******************************************************************************************************/
/***/ ((module) => {

"use strict";

function tryStringify (o) {
  try { return JSON.stringify(o) } catch(e) { return '"[Circular]"' }
}

module.exports = format

function format(f, args, opts) {
  var ss = (opts && opts.stringify) || tryStringify
  var offset = 1
  if (typeof f === 'object' && f !== null) {
    var len = args.length + offset
    if (len === 1) return f
    var objects = new Array(len)
    objects[0] = ss(f)
    for (var index = 1; index < len; index++) {
      objects[index] = ss(args[index])
    }
    return objects.join(' ')
  }
  if (typeof f !== 'string') {
    return f
  }
  var argLen = args.length
  if (argLen === 0) return f
  var str = ''
  var a = 1 - offset
  var lastPos = -1
  var flen = (f && f.length) || 0
  for (var i = 0; i < flen;) {
    if (f.charCodeAt(i) === 37 && i + 1 < flen) {
      lastPos = lastPos > -1 ? lastPos : 0
      switch (f.charCodeAt(i + 1)) {
        case 100: // 'd'
        case 102: // 'f'
          if (a >= argLen)
            break
          if (args[a] == null)  break
          if (lastPos < i)
            str += f.slice(lastPos, i)
          str += Number(args[a])
          lastPos = i + 2
          i++
          break
        case 105: // 'i'
          if (a >= argLen)
            break
          if (args[a] == null)  break
          if (lastPos < i)
            str += f.slice(lastPos, i)
          str += Math.floor(Number(args[a]))
          lastPos = i + 2
          i++
          break
        case 79: // 'O'
        case 111: // 'o'
        case 106: // 'j'
          if (a >= argLen)
            break
          if (args[a] === undefined) break
          if (lastPos < i)
            str += f.slice(lastPos, i)
          var type = typeof args[a]
          if (type === 'string') {
            str += '\'' + args[a] + '\''
            lastPos = i + 2
            i++
            break
          }
          if (type === 'function') {
            str += args[a].name || '<anonymous>'
            lastPos = i + 2
            i++
            break
          }
          str += ss(args[a])
          lastPos = i + 2
          i++
          break
        case 115: // 's'
          if (a >= argLen)
            break
          if (lastPos < i)
            str += f.slice(lastPos, i)
          str += String(args[a])
          lastPos = i + 2
          i++
          break
        case 37: // '%'
          if (lastPos < i)
            str += f.slice(lastPos, i)
          str += '%'
          lastPos = i + 2
          i++
          a--
          break
      }
      ++a
    }
    ++i
  }
  if (lastPos === -1)
    return f
  else if (lastPos < flen) {
    str += f.slice(lastPos)
  }

  return str
}


/***/ }),

/***/ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(/*! ./lib/async */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/async.js");
async.core = __webpack_require__(/*! ./lib/core */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/core.js");
async.isCore = __webpack_require__(/*! ./lib/is-core */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/is-core.js");
async.sync = __webpack_require__(/*! ./lib/sync */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/sync.js");

module.exports = async;


/***/ }),

/***/ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/async.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/async.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(/*! fs */ "fs");
var getHomedir = __webpack_require__(/*! ./homedir */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/homedir.js");
var path = __webpack_require__(/*! path */ "path");
var caller = __webpack_require__(/*! ./caller */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/caller.js");
var nodeModulesPaths = __webpack_require__(/*! ./node-modules-paths */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/node-modules-paths.js");
var normalizeOptions = __webpack_require__(/*! ./normalize-options */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/normalize-options.js");
var isCore = __webpack_require__(/*! is-core-module */ "./node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/index.js");

var realpathFS = process.platform !== 'win32' && fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;

var homedir = getHomedir();
var defaultPaths = function () {
    return [
        path.join(homedir, '.node_modules'),
        path.join(homedir, '.node_libraries')
    ];
};

var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function (err, stat) {
        if (!err) {
            return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function (err, stat) {
        if (!err) {
            return cb(null, stat.isDirectory());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function (realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
    });
};

var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
    } else {
        cb(null, x);
    }
};

var defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {
    readFile(pkgfile, function (readFileErr, body) {
        if (readFileErr) cb(readFileErr);
        else {
            try {
                var pkg = JSON.parse(body);
                cb(null, pkg);
            } catch (jsonErr) {
                cb(null);
            }
        }
    });
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === 'function') {
        cb = opts;
        opts = {};
    }
    if (typeof x !== 'string') {
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function () {
            cb(err);
        });
    }

    opts = normalizeOptions(x, opts);

    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError('`readFile` and `readPackage` are mutually exclusive.');
        return process.nextTick(function () {
            cb(conflictErr);
        });
    }
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || defaultPaths();

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir);

    maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function (err, realStart) {
            if (err) cb(err);
            else init(realStart);
        }
    );

    var res;
    function init(basedir) {
        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
            res = path.resolve(basedir, x);
            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
            if ((/\/$/).test(x) && res === basedir) {
                loadAsDirectory(res, opts.package, onfile);
            } else loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
            return cb(null, x);
        } else loadNodeModules(x, basedir, function (err, n, pkg) {
            if (err) cb(err);
            else if (n) {
                return maybeRealpath(realpath, n, opts, function (err, realN) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realN, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function onfile(err, m, pkg) {
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function (err, d, pkg) {
            if (err) cb(err);
            else if (d) {
                maybeRealpath(realpath, d, opts, function (err, realD) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realD, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function loadAsFile(x, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }

        var exts = [''].concat(extensions);
        load(exts, x, loadAsFilePackage);

        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];

            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);

            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path.resolve(dir, r),
                        pkg
                    );
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }

    function loadpkg(dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return cb(null);
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);

                readPackage(readFile, pkgfile, function (err, pkgParam) {
                    if (err) cb(err);

                    var pkg = pkgParam;

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    cb(null, pkg, dir);
                });
            });
        });
    }

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }

        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

                readPackage(readFile, pkgfile, function (err, pkgParam) {
                    if (err) return cb(err);

                    var pkg = pkgParam;

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }

                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== 'string') {
                            var mainError = new TypeError('package â€œ' + pkg.name + 'â€ `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                        }
                        if (pkg.main === '.' || pkg.main === './') {
                            pkg.main = 'index';
                        }
                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, 'index'), pkg, cb);
                            });
                        });
                        return;
                    }

                    loadAsFile(path.join(x, '/index'), pkg, cb);
                });
            });
        });
    }

    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];

        isDirectory(path.dirname(dir), isdir);

        function isdir(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
        }

        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
        }

        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        processDirs(
            cb,
            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()
        );
    }
};


/***/ }),

/***/ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/caller.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/caller.js ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = function () {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = (new Error()).stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};


/***/ }),

/***/ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/core.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/core.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCoreModule = __webpack_require__(/*! is-core-module */ "./node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/index.js");
var data = __webpack_require__(/*! ./core.json */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/core.json");

var core = {};
for (var mod in data) { // eslint-disable-line no-restricted-syntax
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = isCoreModule(mod);
    }
}
module.exports = core;


/***/ }),

/***/ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/homedir.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/homedir.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var os = __webpack_require__(/*! os */ "os");

// adapted from https://github.com/sindresorhus/os-homedir/blob/11e089f4754db38bb535e5a8416320c4446e8cfd/index.js

module.exports = os.homedir || function homedir() {
    var home = process.env.HOME;
    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;

    if (process.platform === 'win32') {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
    }

    if (process.platform === 'darwin') {
        return home || (user ? '/Users/' + user : null);
    }

    if (process.platform === 'linux') {
        return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null)); // eslint-disable-line no-extra-parens
    }

    return home || null;
};


/***/ }),

/***/ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/is-core.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/is-core.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCoreModule = __webpack_require__(/*! is-core-module */ "./node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/index.js");

module.exports = function isCore(x) {
    return isCoreModule(x);
};


/***/ }),

/***/ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/node-modules-paths.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/node-modules-paths.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(/*! path */ "path");
var parse = path.parse || __webpack_require__(/*! path-parse */ "./node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js"); // eslint-disable-line global-require

var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';
    if ((/^([A-Za-z]:)/).test(absoluteStart)) {
        prefix = '';
    } else if ((/^\\\\/).test(absoluteStart)) {
        prefix = '\\\\';
    }

    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }

    return paths.reduce(function (dirs, aPath) {
        return dirs.concat(modules.map(function (moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};

module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory
        ? [].concat(opts.moduleDirectory)
        : ['node_modules'];

    if (opts && typeof opts.paths === 'function') {
        return opts.paths(
            request,
            start,
            function () { return getNodeModulesDirs(start, modules); },
            opts
        );
    }

    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};


/***/ }),

/***/ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/normalize-options.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/normalize-options.js ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = function (x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */

    return opts || {};
};


/***/ }),

/***/ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/sync.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/sync.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCore = __webpack_require__(/*! is-core-module */ "./node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/index.js");
var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var getHomedir = __webpack_require__(/*! ./homedir */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/homedir.js");
var caller = __webpack_require__(/*! ./caller */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/caller.js");
var nodeModulesPaths = __webpack_require__(/*! ./node-modules-paths */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/node-modules-paths.js");
var normalizeOptions = __webpack_require__(/*! ./normalize-options */ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/normalize-options.js");

var realpathFS = process.platform !== 'win32' && fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

var homedir = getHomedir();
var defaultPaths = function () {
    return [
        path.join(homedir, '.node_modules'),
        path.join(homedir, '.node_libraries')
    ];
};

var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return !!stat && (stat.isFile() || stat.isFIFO());
};

var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return !!stat && stat.isDirectory();
};

var defaultRealpathSync = function realpathSync(x) {
    try {
        return realpathFS(x);
    } catch (realpathErr) {
        if (realpathErr.code !== 'ENOENT') {
            throw realpathErr;
        }
    }
    return x;
};

var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
    }
    return x;
};

var defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
        var pkg = JSON.parse(body);
        return pkg;
    } catch (jsonErr) {}
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolveSync(x, options) {
    if (typeof x !== 'string') {
        throw new TypeError('Path must be a string.');
    }
    var opts = normalizeOptions(x, options);

    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError('`readFileSync` and `readPackageSync` are mutually exclusive.');
    }
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || defaultPaths();

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(x)) {
        return x;
    } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) {
        var pkg = loadpkg(path.dirname(x));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) {
                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }

        if (isFile(x)) {
            return x;
        }

        for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }

    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return;
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

        if (!isFile(pkgfile)) {
            return loadpkg(path.dirname(dir));
        }

        var pkg = readPackageSync(readFileSync, pkgfile);

        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }

        return { pkg: pkg, dir: dir };
    }

    function loadAsDirectorySync(x) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var pkg = readPackageSync(readFileSync, pkgfile);
            } catch (e) {}

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            }

            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package â€œ' + pkg.name + 'â€ `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'index';
                }
                try {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }

        return loadAsFileSync(path.join(x, '/index'));
    }

    function loadNodeModulesSync(x, start) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
};


/***/ }),

/***/ "./node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";

module.exports = rfdc

function copyBuffer (cur) {
  if (cur instanceof Buffer) {
    return Buffer.from(cur)
  }

  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)
}

function rfdc (opts) {
  opts = opts || {}
  if (opts.circles) return rfdcCircles(opts)

  const constructorHandlers = new Map()
  constructorHandlers.set(Date, (o) => new Date(o))
  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)))
  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)))
  if (opts.constructorHandlers) {
    for (const handler of opts.constructorHandlers) {
      constructorHandlers.set(handler[0], handler[1])
    }
  }

  let handler = null

  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    const keys = Object.keys(a)
    const a2 = new Array(keys.length)
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i]
      const cur = a[k]
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        a2[k] = handler(cur, fn)
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur)
      } else {
        a2[k] = fn(cur)
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (Array.isArray(o)) return cloneArray(o, clone)
    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
      return handler(o, clone)
    }
    const o2 = {}
    for (const k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      const cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler(cur, clone)
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        o2[k] = clone(cur)
      }
    }
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
      return handler(o, cloneProto)
    }
    const o2 = {}
    for (const k in o) {
      const cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler(cur, cloneProto)
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        o2[k] = cloneProto(cur)
      }
    }
    return o2
  }
}

function rfdcCircles (opts) {
  const refs = []
  const refsNew = []

  const constructorHandlers = new Map()
  constructorHandlers.set(Date, (o) => new Date(o))
  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)))
  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)))
  if (opts.constructorHandlers) {
    for (const handler of opts.constructorHandlers) {
      constructorHandlers.set(handler[0], handler[1])
    }
  }

  let handler = null
  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    const keys = Object.keys(a)
    const a2 = new Array(keys.length)
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i]
      const cur = a[k]
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        a2[k] = handler(cur, fn)
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur)
      } else {
        const index = refs.indexOf(cur)
        if (index !== -1) {
          a2[k] = refsNew[index]
        } else {
          a2[k] = fn(cur)
        }
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (Array.isArray(o)) return cloneArray(o, clone)
    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
      return handler(o, clone)
    }
    const o2 = {}
    refs.push(o)
    refsNew.push(o2)
    for (const k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      const cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler(cur, clone)
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        const i = refs.indexOf(cur)
        if (i !== -1) {
          o2[k] = refsNew[i]
        } else {
          o2[k] = clone(cur)
        }
      }
    }
    refs.pop()
    refsNew.pop()
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
      return handler(o, cloneProto)
    }
    const o2 = {}
    refs.push(o)
    refsNew.push(o2)
    for (const k in o) {
      const cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler(cur, cloneProto)
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        const i = refs.indexOf(cur)
        if (i !== -1) {
          o2[k] = refsNew[i]
        } else {
          o2[k] = cloneProto(cur)
        }
      }
    }
    refs.pop()
    refsNew.pop()
    return o2
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js ***!
  \***********************************************************************/
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

// The actual regexps go on exports.re
var re = exports.re = []
var safeRe = exports.safeRe = []
var src = exports.src = []
var t = exports.tokens = {}
var R = 0

function tok (n) {
  t[n] = R++
}

var LETTERDASHNUMBER = '[a-zA-Z0-9-]'

// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
var safeRegexReplacements = [
  ['\\s', 1],
  ['\\d', MAX_LENGTH],
  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
]

function makeSafeRe (value) {
  for (var i = 0; i < safeRegexReplacements.length; i++) {
    var token = safeRegexReplacements[i][0]
    var max = safeRegexReplacements[i][1]
    value = value
      .split(token + '*').join(token + '{0,' + max + '}')
      .split(token + '+').join(token + '{1,' + max + '}')
  }
  return value
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

tok('NUMERICIDENTIFIER')
src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*'
tok('NUMERICIDENTIFIERLOOSE')
src[t.NUMERICIDENTIFIERLOOSE] = '\\d+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok('NONNUMERICIDENTIFIER')
src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-]' + LETTERDASHNUMBER + '*'

// ## Main Version
// Three dot-separated numeric identifiers.

tok('MAINVERSION')
src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')'

tok('MAINVERSIONLOOSE')
src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok('PRERELEASEIDENTIFIER')
src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] +
                            '|' + src[t.NONNUMERICIDENTIFIER] + ')'

tok('PRERELEASEIDENTIFIERLOOSE')
src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[t.NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok('PRERELEASE')
src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))'

tok('PRERELEASELOOSE')
src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok('BUILDIDENTIFIER')
src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + '+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok('BUILD')
src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] +
             '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok('FULL')
tok('FULLPLAIN')
src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] +
                  src[t.PRERELEASE] + '?' +
                  src[t.BUILD] + '?'

src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
tok('LOOSEPLAIN')
src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] +
                  src[t.PRERELEASELOOSE] + '?' +
                  src[t.BUILD] + '?'

tok('LOOSE')
src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$'

tok('GTLT')
src[t.GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
tok('XRANGEIDENTIFIERLOOSE')
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
tok('XRANGEIDENTIFIER')
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*'

tok('XRANGEPLAIN')
src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[t.PRERELEASE] + ')?' +
                   src[t.BUILD] + '?' +
                   ')?)?'

tok('XRANGEPLAINLOOSE')
src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[t.PRERELEASELOOSE] + ')?' +
                        src[t.BUILD] + '?' +
                        ')?)?'

tok('XRANGE')
src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$'
tok('XRANGELOOSE')
src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
tok('COERCE')
src[t.COERCE] = '(^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'
tok('COERCERTL')
re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g')
safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), 'g')

// Tilde ranges.
// Meaning is "reasonably at or greater than"
tok('LONETILDE')
src[t.LONETILDE] = '(?:~>?)'

tok('TILDETRIM')
src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+'
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g')
safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), 'g')
var tildeTrimReplace = '$1~'

tok('TILDE')
src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$'
tok('TILDELOOSE')
src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
tok('LONECARET')
src[t.LONECARET] = '(?:\\^)'

tok('CARETTRIM')
src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+'
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g')
safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), 'g')
var caretTrimReplace = '$1^'

tok('CARET')
src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$'
tok('CARETLOOSE')
src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
tok('COMPARATORLOOSE')
src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$'
tok('COMPARATOR')
src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
tok('COMPARATORTRIM')
src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] +
                      '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g')
safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
tok('HYPHENRANGE')
src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s*$'

tok('HYPHENRANGELOOSE')
src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
tok('STAR')
src[t.STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])

    // Replace all greedy whitespace to prevent regex dos issues. These regex are
    // used internally via the safeRe object since all inputs in this library get
    // normalized first to trim and collapse all extra whitespace. The original
    // regexes are exported for userland consumption and lower level usage. A
    // future breaking change could export the safer regex only with a note that
    // all input should have extra whitespace removed.
    safeRe[i] = new RegExp(makeSafeRe(src[i]))
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  var i = 0
  do {
    var a = this.build[i]
    var b = other.build[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.compareBuild = compareBuild
function compareBuild (a, b, loose) {
  var versionA = new SemVer(a, loose)
  var versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  comp = comp.trim().split(/\s+/).join(' ')
  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1] !== undefined ? m[1] : ''
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY || version === ANY) {
    return true
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    if (this.value === '') {
      return true
    }
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    if (comp.value === '') {
      return true
    }
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First reduce all whitespace as much as possible so we do not have to rely
  // on potentially slow regexes like \s*. This is then stored and used for
  // future error messages as well.
  this.raw = range
    .trim()
    .split(/\s+/)
    .join(' ')

  // First, split based on boolean or ||
  this.set = this.raw.split('||').map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + this.raw)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, safeRe[t.COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return (
      isSatisfiable(thisComparators, options) &&
      range.set.some(function (rangeComparators) {
        return (
          isSatisfiable(rangeComparators, options) &&
          thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options)
            })
          })
        )
      })
    )
  })
}

// take a set of comparators and determine whether there
// exists a version which can satisfy it
function isSatisfiable (comparators, options) {
  var result = true
  var remainingComparators = comparators.slice()
  var testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p + pr
    } else if (xm) {
      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0' + pr +
        ' <' + M + '.' + (+m + 1) + '.0' + pr
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(safeRe[t.STAR], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version, options) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  var match = null
  if (!options.rtl) {
    match = version.match(safeRe[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next
    while ((next = safeRe[t.COERCERTL].exec(version)) &&
      (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
          next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    safeRe[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(match[2] +
    '.' + (match[3] || '0') +
    '.' + (match[4] || '0'), options)
}


/***/ }),

/***/ "./node_modules/.pnpm/sonic-boom@1.4.1/node_modules/sonic-boom/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/sonic-boom@1.4.1/node_modules/sonic-boom/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs")
const EventEmitter = __webpack_require__(/*! events */ "events")
const flatstr = __webpack_require__(/*! flatstr */ "./node_modules/.pnpm/flatstr@1.0.12/node_modules/flatstr/index.js")
const inherits = (__webpack_require__(/*! util */ "util").inherits)

const BUSY_WRITE_TIMEOUT = 100

const sleep = __webpack_require__(/*! atomic-sleep */ "./node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js")

// 16 MB - magic number
// This constant ensures that SonicBoom only needs
// 32 MB of free memory to run. In case of having 1GB+
// of data to write, this prevents an out of memory
// condition.
const MAX_WRITE = 16 * 1024 * 1024

function openFile (file, sonic) {
  sonic._opening = true
  sonic._writing = true
  sonic._asyncDrainScheduled = false

  // NOTE: 'error' and 'ready' events emitted below only relevant when sonic.sync===false
  // for sync mode, there is no way to add a listener that will receive these

  function fileOpened (err, fd) {
    if (err) {
      sonic._reopening = false
      sonic._writing = false
      sonic._opening = false

      if (sonic.sync) {
        process.nextTick(() => {
          if (sonic.listenerCount('error') > 0) {
            sonic.emit('error', err)
          }
        })
      } else {
        sonic.emit('error', err)
      }
      return
    }

    sonic.fd = fd
    sonic.file = file
    sonic._reopening = false
    sonic._opening = false
    sonic._writing = false

    if (sonic.sync) {
      process.nextTick(() => sonic.emit('ready'))
    } else {
      sonic.emit('ready')
    }

    if (sonic._reopening) {
      return
    }

    // start
    const len = sonic._buf.length
    if (len > 0 && len > sonic.minLength && !sonic.destroyed) {
      actualWrite(sonic)
    }
  }

  if (sonic.sync) {
    try {
      const fd = fs.openSync(file, 'a')
      fileOpened(null, fd)
    } catch (err) {
      fileOpened(err)
      throw err
    }
  } else {
    fs.open(file, 'a', fileOpened)
  }
}

function SonicBoom (opts) {
  if (!(this instanceof SonicBoom)) {
    return new SonicBoom(opts)
  }

  let { fd, dest, minLength, sync } = opts || {}

  fd = fd || dest

  this._buf = ''
  this.fd = -1
  this._writing = false
  this._writingBuf = ''
  this._ending = false
  this._reopening = false
  this._asyncDrainScheduled = false
  this.file = null
  this.destroyed = false
  this.sync = sync || false

  this.minLength = minLength || 0

  if (typeof fd === 'number') {
    this.fd = fd
    process.nextTick(() => this.emit('ready'))
  } else if (typeof fd === 'string') {
    openFile(fd, this)
  } else {
    throw new Error('SonicBoom supports only file descriptors and files')
  }

  this.release = (err, n) => {
    if (err) {
      if (err.code === 'EAGAIN') {
        if (this.sync) {
          // This error code should not happen in sync mode, because it is
          // not using the underlining operating system asynchronous functions.
          // However it happens, and so we handle it.
          // Ref: https://github.com/pinojs/pino/issues/783
          try {
            sleep(BUSY_WRITE_TIMEOUT)
            this.release(undefined, 0)
          } catch (err) {
            this.release(err)
          }
        } else {
          // Let's give the destination some time to process the chunk.
          setTimeout(() => {
            fs.write(this.fd, this._writingBuf, 'utf8', this.release)
          }, BUSY_WRITE_TIMEOUT)
        }
      } else {
        // The error maybe recoverable later, so just put data back to this._buf
        this._buf = this._writingBuf + this._buf
        this._writingBuf = ''
        this._writing = false

        this.emit('error', err)
      }
      return
    }

    if (this._writingBuf.length !== n) {
      this._writingBuf = this._writingBuf.slice(n)
      if (this.sync) {
        try {
          do {
            n = fs.writeSync(this.fd, this._writingBuf, 'utf8')
            this._writingBuf = this._writingBuf.slice(n)
          } while (this._writingBuf.length !== 0)
        } catch (err) {
          this.release(err)
          return
        }
      } else {
        fs.write(this.fd, this._writingBuf, 'utf8', this.release)
        return
      }
    }

    this._writingBuf = ''

    if (this.destroyed) {
      return
    }

    const len = this._buf.length
    if (this._reopening) {
      this._writing = false
      this._reopening = false
      this.reopen()
    } else if (len > 0 && len > this.minLength) {
      actualWrite(this)
    } else if (this._ending) {
      if (len > 0) {
        actualWrite(this)
      } else {
        this._writing = false
        actualClose(this)
      }
    } else {
      this._writing = false
      if (this.sync) {
        if (!this._asyncDrainScheduled) {
          this._asyncDrainScheduled = true
          process.nextTick(emitDrain, this)
        }
      } else {
        this.emit('drain')
      }
    }
  }

  this.on('newListener', function (name) {
    if (name === 'drain') {
      this._asyncDrainScheduled = false
    }
  })
}

function emitDrain (sonic) {
  const hasListeners = sonic.listenerCount('drain') > 0
  if (!hasListeners) return
  sonic._asyncDrainScheduled = false
  sonic.emit('drain')
}

inherits(SonicBoom, EventEmitter)

SonicBoom.prototype.write = function (data) {
  if (this.destroyed) {
    throw new Error('SonicBoom destroyed')
  }

  this._buf += data
  const len = this._buf.length
  if (!this._writing && len > this.minLength) {
    actualWrite(this)
  }
  return len < 16384
}

SonicBoom.prototype.flush = function () {
  if (this.destroyed) {
    throw new Error('SonicBoom destroyed')
  }

  if (this._writing || this.minLength <= 0) {
    return
  }

  actualWrite(this)
}

SonicBoom.prototype.reopen = function (file) {
  if (this.destroyed) {
    throw new Error('SonicBoom destroyed')
  }

  if (this._opening) {
    this.once('ready', () => {
      this.reopen(file)
    })
    return
  }

  if (this._ending) {
    return
  }

  if (!this.file) {
    throw new Error('Unable to reopen a file descriptor, you must pass a file to SonicBoom')
  }

  this._reopening = true

  if (this._writing) {
    return
  }

  const fd = this.fd
  this.once('ready', () => {
    if (fd !== this.fd) {
      fs.close(fd, (err) => {
        if (err) {
          return this.emit('error', err)
        }
      })
    }
  })

  openFile(file || this.file, this)
}

SonicBoom.prototype.end = function () {
  if (this.destroyed) {
    throw new Error('SonicBoom destroyed')
  }

  if (this._opening) {
    this.once('ready', () => {
      this.end()
    })
    return
  }

  if (this._ending) {
    return
  }

  this._ending = true

  if (!this._writing && this._buf.length > 0 && this.fd >= 0) {
    actualWrite(this)
    return
  }

  if (this._writing) {
    return
  }

  actualClose(this)
}

SonicBoom.prototype.flushSync = function () {
  if (this.destroyed) {
    throw new Error('SonicBoom destroyed')
  }

  if (this.fd < 0) {
    throw new Error('sonic boom is not ready yet')
  }

  while (this._buf.length > 0) {
    try {
      fs.writeSync(this.fd, this._buf, 'utf8')
      this._buf = ''
    } catch (err) {
      if (err.code !== 'EAGAIN') {
        throw err
      }

      sleep(BUSY_WRITE_TIMEOUT)
    }
  }
}

SonicBoom.prototype.destroy = function () {
  if (this.destroyed) {
    return
  }
  actualClose(this)
}

function actualWrite (sonic) {
  sonic._writing = true
  let buf = sonic._buf
  const release = sonic.release
  if (buf.length > MAX_WRITE) {
    buf = buf.slice(0, MAX_WRITE)
    sonic._buf = sonic._buf.slice(MAX_WRITE)
  } else {
    sonic._buf = ''
  }
  flatstr(buf)
  sonic._writingBuf = buf
  if (sonic.sync) {
    try {
      const written = fs.writeSync(sonic.fd, buf, 'utf8')
      release(null, written)
    } catch (err) {
      release(err)
    }
  } else {
    fs.write(sonic.fd, buf, 'utf8', release)
  }
}

function actualClose (sonic) {
  if (sonic.fd === -1) {
    sonic.once('ready', actualClose.bind(null, sonic))
    return
  }
  // TODO write a test to check if we are not leaking fds
  fs.close(sonic.fd, (err) => {
    if (err) {
      sonic.emit('error', err)
      return
    }

    if (sonic._ending && !sonic._writing) {
      sonic.emit('finish')
    }
    sonic.emit('close')
  })
  sonic.destroyed = true
  sonic._buf = ''
}

module.exports = SonicBoom


/***/ }),

/***/ "./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const tty = __webpack_require__(/*! tty */ "tty");
const hasFlag = __webpack_require__(/*! has-flag */ "./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js");

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/api.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/api.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messages.js");
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return messages_1.Message; } }));
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
Object.defineProperty(exports, "LinkedMap", ({ enumerable: true, get: function () { return linkedMap_1.LinkedMap; } }));
Object.defineProperty(exports, "LRUCache", ({ enumerable: true, get: function () { return linkedMap_1.LRUCache; } }));
Object.defineProperty(exports, "Touch", ({ enumerable: true, get: function () { return linkedMap_1.Touch; } }));
const disposable_1 = __webpack_require__(/*! ./disposable */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/disposable.js");
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js");
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js");
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const sharedArrayCancellation_1 = __webpack_require__(/*! ./sharedArrayCancellation */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js");
Object.defineProperty(exports, "SharedArraySenderStrategy", ({ enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArraySenderStrategy; } }));
Object.defineProperty(exports, "SharedArrayReceiverStrategy", ({ enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArrayReceiverStrategy; } }));
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageReader.js");
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageWriter.js");
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const messageBuffer_1 = __webpack_require__(/*! ./messageBuffer */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js");
Object.defineProperty(exports, "AbstractMessageBuffer", ({ enumerable: true, get: function () { return messageBuffer_1.AbstractMessageBuffer; } }));
const connection_1 = __webpack_require__(/*! ./connection */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/connection.js");
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressToken", ({ enumerable: true, get: function () { return connection_1.ProgressToken; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceValues", ({ enumerable: true, get: function () { return connection_1.TraceValues; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
Object.defineProperty(exports, "MessageStrategy", ({ enumerable: true, get: function () { return connection_1.MessageStrategy; } }));
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js");
exports.RAL = ral_1.default;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js");
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { handle.dispose(); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/connection.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/connection.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messages.js");
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js");
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js");
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressToken;
(function (ProgressToken) {
    function is(value) {
        return typeof value === 'string' || typeof value === 'number';
    }
    ProgressToken.is = is;
})(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Compact"] = 2] = "Compact";
    Trace[Trace["Verbose"] = 3] = "Verbose";
})(Trace || (exports.Trace = Trace = {}));
var TraceValues;
(function (TraceValues) {
    /**
     * Turn tracing off.
     */
    TraceValues.Off = 'off';
    /**
     * Trace messages only.
     */
    TraceValues.Messages = 'messages';
    /**
     * Compact message tracing.
     */
    TraceValues.Compact = 'compact';
    /**
     * Verbose message tracing.
     */
    TraceValues.Verbose = 'verbose';
})(TraceValues || (exports.TraceValues = TraceValues = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'compact':
                return Trace.Compact;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Compact:
                return 'compact';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace || (exports.Trace = Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        if (!Is.string(value)) {
            return TraceFormat.Text;
        }
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
var IdCancellationReceiverStrategy;
(function (IdCancellationReceiverStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
    }
    IdCancellationReceiverStrategy.is = is;
})(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
var RequestCancellationReceiverStrategy;
(function (RequestCancellationReceiverStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
    }
    RequestCancellationReceiverStrategy.is = is;
})(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
var MessageStrategy;
(function (MessageStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
    }
    MessageStrategy.is = is;
})(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = new Map();
    let starNotificationHandler = undefined;
    const notificationHandlers = new Map();
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = new Map();
    let knownCanceledRequests = new Set();
    let requestTokens = new Map();
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
        }
        else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
        }
        else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
        }
        else {
            handleInvalidMessage(message);
        }
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            const messageStrategy = options?.messageStrategy;
            if (MessageStrategy.is(messageStrategy)) {
                messageStrategy.handleMessage(message, handleMessage);
            }
            else {
                handleMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                const cancelId = message.params.id;
                const key = createRequestQueueKey(cancelId);
                const toCancel = messageQueue.get(key);
                if (messages_1.Message.isRequest(toCancel)) {
                    const strategy = options?.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        requestTokens.delete(cancelId);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                        return;
                    }
                }
                const cancellationToken = requestTokens.get(cancelId);
                // The request is already running. Cancel the token
                if (cancellationToken !== undefined) {
                    cancellationToken.cancel();
                    traceReceivedNotification(message);
                    return;
                }
                else {
                    // Remember the cancel but still queue the message to
                    // clean up state in process message.
                    knownCanceledRequests.add(cancelId);
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now()); //
            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)
                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)
                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
                requestTokens.set(tokenKey, cancellationSource);
            }
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    requestTokens.delete(tokenKey);
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        requestTokens.delete(tokenKey);
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        requestTokens.delete(tokenKey);
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    requestTokens.delete(tokenKey);
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== undefined) {
                responsePromises.delete(key);
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
        }
        else {
            const element = notificationHandlers.get(message.method);
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        // There are JSON-RPC libraries that send progress message as positional params although
                        // specified as named. So convert them if this is the case.
                        const params = message.params;
                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                            notificationHandler({ token: params[0], value: params[1] });
                        }
                        else {
                            if (type !== undefined) {
                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                }
                                if (type.numberOfParams !== message.params.length) {
                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                }
                            }
                            notificationHandler(...params);
                        }
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function stringifyTrace(params) {
        if (params === undefined || params === null) {
            return undefined;
        }
        switch (trace) {
            case Trace.Verbose:
                return JSON.stringify(params, null, 4);
            case Trace.Compact:
                return JSON.stringify(params);
            default:
                return undefined;
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Received parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch((error) => {
                logger.error(`Sending notification failed.`);
                throw error;
            });
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers.set(type, { type: undefined, handler });
                }
                else {
                    method = type.method;
                    notificationHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        notificationHandlers.delete(method);
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            // This should not await but simple return to ensure that we don't have another
            // async scheduling. Otherwise one send could overtake another send.
            return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                    if (p === undefined) {
                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                        return Promise.resolve();
                    }
                    else {
                        return p.catch(() => {
                            logger.log(`Sending cancellation messages for id ${id} failed`);
                        });
                    }
                });
            }
            const requestMessage = {
                jsonrpc: version,
                id: id,
                method: method,
                params: messageParams
            };
            traceSendingRequest(requestMessage);
            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                cancellationStrategy.sender.enableCancellation(requestMessage);
            }
            return new Promise(async (resolve, reject) => {
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                try {
                    await messageWriter.write(requestMessage);
                    responsePromises.set(id, responsePromise);
                }
                catch (error) {
                    logger.error(`Sending request failed.`);
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                    throw error;
                }
            });
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers.set(type, { handler: handler, type: undefined });
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        requestHandlers.delete(method);
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        hasPendingResponse: () => {
            return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
            for (const promise of responsePromises.values()) {
                promise.reject(error);
            }
            responsePromises = new Map();
            requestTokens = new Map();
            knownCanceledRequests = new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            (0, ral_1.default)().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/disposable.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/disposable.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable || (exports.Disposable = Disposable = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js");
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event || (exports.Event = Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                (0, ral_1.default)().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/linkedMap.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/linkedMap.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch || (exports.Touch = Touch = {}));
class LinkedMap {
    constructor() {
        this[_a] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        return this._head?.value;
    }
    get last() {
        return this._tail?.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error(`Message header must separate key and value using ':'\n${header}`);
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageReader.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageReader.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js");
const semaphore_1 = __webpack_require__(/*! ./semaphore */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/semaphore.js");
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader || (exports.MessageReader = MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options ?? 'utf-8';
        }
        else {
            charset = options.charset ?? 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        try {
            this.buffer.append(data);
            while (true) {
                if (this.nextMessageLength === -1) {
                    const headers = this.buffer.tryReadHeaders(true);
                    if (!headers) {
                        return;
                    }
                    const contentLength = headers.get('content-length');
                    if (!contentLength) {
                        this.fireError(new Error(`Header must provide a Content-Length property.\n${JSON.stringify(Object.fromEntries(headers))}`));
                        return;
                    }
                    const length = parseInt(contentLength);
                    if (isNaN(length)) {
                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                        return;
                    }
                    this.nextMessageLength = length;
                }
                const body = this.buffer.tryReadBody(this.nextMessageLength);
                if (body === undefined) {
                    /** We haven't received the full message yet. */
                    this.setPartialMessageTimer();
                    return;
                }
                this.clearPartialMessageTimer();
                this.nextMessageLength = -1;
                // Make sure that we convert one received message after the
                // other. Otherwise it could happen that a decoding of a second
                // smaller message finished before the decoding of a first larger
                // message and then we would deliver the second message first.
                this.readSemaphore.lock(async () => {
                    const bytes = this.options.contentDecoder !== undefined
                        ? await this.options.contentDecoder.decode(body)
                        : body;
                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                    this.callback(message);
                }).catch((error) => {
                    this.fireError(error);
                });
            }
        }
        catch (error) {
            this.fireError(error);
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageWriter.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageWriter.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js");
const semaphore_1 = __webpack_require__(/*! ./semaphore */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/semaphore.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js");
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter || (exports.MessageWriter = MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        if (options === undefined || typeof options === 'string') {
            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        }
        else {
            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messages.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messages.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(/*! ./is */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js");
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = -32099;
    /**
     * An error occurred when write a message to the transport layer.
     */
    ErrorCodes.MessageWriteError = -32099;
    /**
     * An error occurred when reading a message from the transport layer.
     */
    ErrorCodes.MessageReadError = -32098;
    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */
    ErrorCodes.PendingResponseRejected = -32097;
    /**
     * The connection is inactive and a use of it failed.
     */
    ErrorCodes.ConnectionInactive = -32096;
    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = -32000;
})(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        const result = {
            code: this.code,
            message: this.message
        };
        if (this.data !== undefined) {
            result.data = this.data;
        }
        return result;
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
var Message;
(function (Message) {
    /**
     * Tests if the given message is a request message
     */
    function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    Message.isRequest = isRequest;
    /**
     * Tests if the given message is a notification message
     */
    function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
    }
    Message.isNotification = isNotification;
    /**
     * Tests if the given message is a response message
     */
    function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    Message.isResponse = isResponse;
})(Message || (exports.Message = Message = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/semaphore.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/semaphore.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js");
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js");
var CancellationState;
(function (CancellationState) {
    CancellationState.Continue = 0;
    CancellationState.Cancelled = 1;
})(CancellationState || (CancellationState = {}));
class SharedArraySenderStrategy {
    constructor() {
        this.buffers = new Map();
    }
    enableCancellation(request) {
        if (request.id === null) {
            return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
    }
    async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === undefined) {
            return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
    }
    cleanup(id) {
        this.buffers.delete(id);
    }
    dispose() {
        this.buffers.clear();
    }
}
exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
class SharedArrayBufferCancellationToken {
    constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
    }
    get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
    }
    get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
    }
}
class SharedArrayBufferCancellationTokenSource {
    constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
    }
    cancel() {
    }
    dispose() {
    }
}
class SharedArrayReceiverStrategy {
    constructor() {
        this.kind = 'request';
    }
    createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === undefined) {
            return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
    }
}
exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(/*! ./ril */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/ril.js");
// Install the node runtime abstract.
ril_1.default.install();
const path = __webpack_require__(/*! path */ "path");
const os = __webpack_require__(/*! os */ "os");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const net_1 = __webpack_require__(/*! net */ "net");
const api_1 = __webpack_require__(/*! ../common/api */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/api.js");
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/api.js"), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class PortMessageReader extends api_1.AbstractMessageReader {
    constructor(port) {
        super();
        this.onData = new api_1.Emitter;
        port.on('close', () => this.fireClose);
        port.on('error', (error) => this.fireError(error));
        port.on('message', (message) => {
            this.onData.fire(message);
        });
    }
    listen(callback) {
        return this.onData.event(callback);
    }
}
exports.PortMessageReader = PortMessageReader;
class PortMessageWriter extends api_1.AbstractMessageWriter {
    constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on('close', () => this.fireClose());
        port.on('error', (error) => this.fireError(error));
    }
    write(msg) {
        try {
            this.port.postMessage(msg);
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.PortMessageWriter = PortMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = (0, crypto_1.randomBytes)(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/ril.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/ril.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__(/*! util */ "util");
const api_1 = __webpack_require__(/*! ../common/api */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/api.js");
class MessageBuffer extends api_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return api_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return api_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return api_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return api_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return api_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return api_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return api_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setImmediate(callback, ...args);
            return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        api_1.RAL.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/node.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/node.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js");

/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/api.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/api.js ***!
  \********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
__exportStar(__webpack_require__(/*! vscode-jsonrpc */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js"), exports);
__exportStar(__webpack_require__(/*! vscode-languageserver-types */ "./node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js"), exports);
__exportStar(__webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js"), exports);
__exportStar(__webpack_require__(/*! ./protocol */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"), exports);
var connection_1 = __webpack_require__(/*! ./connection */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/connection.js");
Object.defineProperty(exports, "createProtocolConnection", ({ enumerable: true, get: function () { return connection_1.createProtocolConnection; } }));
var LSPErrorCodes;
(function (LSPErrorCodes) {
    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.RequestFailed = -32803;
    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.ServerCancelled = -32802;
    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */
    LSPErrorCodes.ContentModified = -32801;
    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */
    LSPErrorCodes.RequestCancelled = -32800;
    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
})(LSPErrorCodes || (exports.LSPErrorCodes = LSPErrorCodes = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/connection.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/connection.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js");
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js");
var MessageDirection;
(function (MessageDirection) {
    MessageDirection["clientToServer"] = "clientToServer";
    MessageDirection["serverToClient"] = "serverToClient";
    MessageDirection["both"] = "both";
})(MessageDirection || (exports.MessageDirection = MessageDirection = {}));
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
exports.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest || (exports.DocumentColorRequest = DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.method = 'textDocument/colorPresentation';
    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
})(ColorPresentationRequest || (exports.ColorPresentationRequest = ColorPresentationRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
//---- Get Configuration request ----
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.method = 'workspace/configuration';
    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
})(ConfigurationRequest || (exports.ConfigurationRequest = ConfigurationRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Declaration} or a typed array of {@link DeclarationLink}
 * or a Thenable that resolves to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest || (exports.DeclarationRequest = DeclarationRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * @since 3.17.0
 */
var DiagnosticServerCancellationData;
(function (DiagnosticServerCancellationData) {
    function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
    }
    DiagnosticServerCancellationData.is = is;
})(DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticReportKind;
(function (DocumentDiagnosticReportKind) {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    DocumentDiagnosticReportKind.Full = 'full';
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    DocumentDiagnosticReportKind.Unchanged = 'unchanged';
})(DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
/**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticRequest;
(function (DocumentDiagnosticRequest) {
    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
/**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */
var WorkspaceDiagnosticRequest;
(function (WorkspaceDiagnosticRequest) {
    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
/**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */
var DiagnosticRefreshRequest;
(function (DiagnosticRefreshRequest) {
    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
})(DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind || (exports.FileOperationPatternKind = FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest || (exports.WillCreateFilesRequest = WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification || (exports.DidCreateFilesNotification = DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest || (exports.WillRenameFilesRequest = WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification || (exports.DidRenameFilesNotification = DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest || (exports.FoldingRangeRequest = FoldingRangeRequest = {}));
/**
 * @since 3.18.0
 * @proposed
 */
var FoldingRangeRefreshRequest;
(function (FoldingRangeRefreshRequest) {
    FoldingRangeRefreshRequest.method = `workspace/foldingRange/refresh`;
    FoldingRangeRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    FoldingRangeRefreshRequest.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest.method);
})(FoldingRangeRefreshRequest || (exports.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Definition} or a Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest || (exports.ImplementationRequest = ImplementationRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintRequest;
(function (InlayHintRequest) {
    InlayHintRequest.method = 'textDocument/inlayHint';
    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
})(InlayHintRequest || (exports.InlayHintRequest = InlayHintRequest = {}));
/**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintResolveRequest;
(function (InlayHintResolveRequest) {
    InlayHintResolveRequest.method = 'inlayHint/resolve';
    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
})(InlayHintResolveRequest || (exports.InlayHintResolveRequest = InlayHintResolveRequest = {}));
/**
 * @since 3.17.0
 */
var InlayHintRefreshRequest;
(function (InlayHintRefreshRequest) {
    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
})(InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js":
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js ***!
  \******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineCompletionRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide inline completions in a document. The request's parameter is of
 * type {@link InlineCompletionParams}, the response is of type
 * {@link InlineCompletion InlineCompletion[]} or a Thenable that resolves to such.
 *
 * @since 3.18.0
 * @proposed
 */
var InlineCompletionRequest;
(function (InlineCompletionRequest) {
    InlineCompletionRequest.method = 'textDocument/inlineCompletion';
    InlineCompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlineCompletionRequest.type = new messages_1.ProtocolRequestType(InlineCompletionRequest.method);
})(InlineCompletionRequest || (exports.InlineCompletionRequest = InlineCompletionRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlineValueRequest;
(function (InlineValueRequest) {
    InlineValueRequest.method = 'textDocument/inlineValue';
    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
})(InlineValueRequest || (exports.InlineValueRequest = InlineValueRequest = {}));
/**
 * @since 3.17.0
 */
var InlineValueRefreshRequest;
(function (InlineValueRefreshRequest) {
    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
})(InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangesFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
exports.InlineCompletionRequest = exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const protocol_implementation_1 = __webpack_require__(/*! ./protocol.implementation */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js");
Object.defineProperty(exports, "ImplementationRequest", ({ enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } }));
const protocol_typeDefinition_1 = __webpack_require__(/*! ./protocol.typeDefinition */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js");
Object.defineProperty(exports, "TypeDefinitionRequest", ({ enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } }));
const protocol_workspaceFolder_1 = __webpack_require__(/*! ./protocol.workspaceFolder */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js");
Object.defineProperty(exports, "WorkspaceFoldersRequest", ({ enumerable: true, get: function () { return protocol_workspaceFolder_1.WorkspaceFoldersRequest; } }));
Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", ({ enumerable: true, get: function () { return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification; } }));
const protocol_configuration_1 = __webpack_require__(/*! ./protocol.configuration */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js");
Object.defineProperty(exports, "ConfigurationRequest", ({ enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } }));
const protocol_colorProvider_1 = __webpack_require__(/*! ./protocol.colorProvider */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js");
Object.defineProperty(exports, "DocumentColorRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } }));
Object.defineProperty(exports, "ColorPresentationRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } }));
const protocol_foldingRange_1 = __webpack_require__(/*! ./protocol.foldingRange */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js");
Object.defineProperty(exports, "FoldingRangeRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } }));
Object.defineProperty(exports, "FoldingRangeRefreshRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRefreshRequest; } }));
const protocol_declaration_1 = __webpack_require__(/*! ./protocol.declaration */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js");
Object.defineProperty(exports, "DeclarationRequest", ({ enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } }));
const protocol_selectionRange_1 = __webpack_require__(/*! ./protocol.selectionRange */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js");
Object.defineProperty(exports, "SelectionRangeRequest", ({ enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } }));
const protocol_progress_1 = __webpack_require__(/*! ./protocol.progress */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js");
Object.defineProperty(exports, "WorkDoneProgress", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } }));
Object.defineProperty(exports, "WorkDoneProgressCreateRequest", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } }));
Object.defineProperty(exports, "WorkDoneProgressCancelNotification", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } }));
const protocol_callHierarchy_1 = __webpack_require__(/*! ./protocol.callHierarchy */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js");
Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } }));
const protocol_semanticTokens_1 = __webpack_require__(/*! ./protocol.semanticTokens */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js");
Object.defineProperty(exports, "TokenFormat", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } }));
Object.defineProperty(exports, "SemanticTokensRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } }));
Object.defineProperty(exports, "SemanticTokensDeltaRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } }));
Object.defineProperty(exports, "SemanticTokensRangeRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } }));
Object.defineProperty(exports, "SemanticTokensRefreshRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } }));
Object.defineProperty(exports, "SemanticTokensRegistrationType", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } }));
const protocol_showDocument_1 = __webpack_require__(/*! ./protocol.showDocument */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js");
Object.defineProperty(exports, "ShowDocumentRequest", ({ enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } }));
const protocol_linkedEditingRange_1 = __webpack_require__(/*! ./protocol.linkedEditingRange */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js");
Object.defineProperty(exports, "LinkedEditingRangeRequest", ({ enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } }));
const protocol_fileOperations_1 = __webpack_require__(/*! ./protocol.fileOperations */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js");
Object.defineProperty(exports, "FileOperationPatternKind", ({ enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } }));
Object.defineProperty(exports, "DidCreateFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } }));
Object.defineProperty(exports, "WillCreateFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } }));
Object.defineProperty(exports, "DidRenameFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } }));
Object.defineProperty(exports, "WillRenameFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } }));
Object.defineProperty(exports, "DidDeleteFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } }));
Object.defineProperty(exports, "WillDeleteFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } }));
const protocol_moniker_1 = __webpack_require__(/*! ./protocol.moniker */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js");
Object.defineProperty(exports, "UniquenessLevel", ({ enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } }));
Object.defineProperty(exports, "MonikerKind", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } }));
Object.defineProperty(exports, "MonikerRequest", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } }));
const protocol_typeHierarchy_1 = __webpack_require__(/*! ./protocol.typeHierarchy */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js");
Object.defineProperty(exports, "TypeHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest; } }));
Object.defineProperty(exports, "TypeHierarchySubtypesRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest; } }));
Object.defineProperty(exports, "TypeHierarchySupertypesRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest; } }));
const protocol_inlineValue_1 = __webpack_require__(/*! ./protocol.inlineValue */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js");
Object.defineProperty(exports, "InlineValueRequest", ({ enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRequest; } }));
Object.defineProperty(exports, "InlineValueRefreshRequest", ({ enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRefreshRequest; } }));
const protocol_inlayHint_1 = __webpack_require__(/*! ./protocol.inlayHint */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js");
Object.defineProperty(exports, "InlayHintRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRequest; } }));
Object.defineProperty(exports, "InlayHintResolveRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintResolveRequest; } }));
Object.defineProperty(exports, "InlayHintRefreshRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRefreshRequest; } }));
const protocol_diagnostic_1 = __webpack_require__(/*! ./protocol.diagnostic */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js");
Object.defineProperty(exports, "DiagnosticServerCancellationData", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticServerCancellationData; } }));
Object.defineProperty(exports, "DocumentDiagnosticReportKind", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticReportKind; } }));
Object.defineProperty(exports, "DocumentDiagnosticRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticRequest; } }));
Object.defineProperty(exports, "WorkspaceDiagnosticRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.WorkspaceDiagnosticRequest; } }));
Object.defineProperty(exports, "DiagnosticRefreshRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticRefreshRequest; } }));
const protocol_notebook_1 = __webpack_require__(/*! ./protocol.notebook */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js");
Object.defineProperty(exports, "NotebookCellKind", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCellKind; } }));
Object.defineProperty(exports, "ExecutionSummary", ({ enumerable: true, get: function () { return protocol_notebook_1.ExecutionSummary; } }));
Object.defineProperty(exports, "NotebookCell", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCell; } }));
Object.defineProperty(exports, "NotebookDocument", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookDocument; } }));
Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookDocumentSyncRegistrationType; } }));
Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidOpenNotebookDocumentNotification; } }));
Object.defineProperty(exports, "NotebookCellArrayChange", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCellArrayChange; } }));
Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidChangeNotebookDocumentNotification; } }));
Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidSaveNotebookDocumentNotification; } }));
Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidCloseNotebookDocumentNotification; } }));
const protocol_inlineCompletion_1 = __webpack_require__(/*! ./protocol.inlineCompletion */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js");
Object.defineProperty(exports, "InlineCompletionRequest", ({ enumerable: true, get: function () { return protocol_inlineCompletion_1.InlineCompletionRequest; } }));
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
var TextDocumentFilter;
(function (TextDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
    }
    TextDocumentFilter.is = is;
})(TextDocumentFilter || (exports.TextDocumentFilter = TextDocumentFilter = {}));
/**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */
var NotebookDocumentFilter;
(function (NotebookDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
    }
    NotebookDocumentFilter.is = is;
})(NotebookDocumentFilter || (exports.NotebookDocumentFilter = NotebookDocumentFilter = {}));
/**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
var NotebookCellTextDocumentFilter;
(function (NotebookCellTextDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate)
            && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook))
            && (candidate.language === undefined || Is.string(candidate.language));
    }
    NotebookCellTextDocumentFilter.is = is;
})(NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.method = 'client/registerCapability';
    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
})(RegistrationRequest || (exports.RegistrationRequest = RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.method = 'client/unregisterCapability';
    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
})(UnregistrationRequest || (exports.UnregistrationRequest = UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind || (exports.ResourceOperationKind = ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind || (exports.FailureHandlingKind = FailureHandlingKind = {}));
/**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */
var PositionEncodingKind;
(function (PositionEncodingKind) {
    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */
    PositionEncodingKind.UTF8 = 'utf-8';
    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */
    PositionEncodingKind.UTF16 = 'utf-16';
    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */
    PositionEncodingKind.UTF32 = 'utf-32';
})(PositionEncodingKind || (exports.PositionEncodingKind = PositionEncodingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions || (exports.StaticRegistrationOptions = StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.method = 'initialize';
    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
})(InitializeRequest || (exports.InitializeRequest = InitializeRequest = {}));
/**
 * Known error codes for an `InitializeErrorCodes`;
 */
var InitializeErrorCodes;
(function (InitializeErrorCodes) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeErrorCodes.unknownProtocolVersion = 1;
})(InitializeErrorCodes || (exports.InitializeErrorCodes = InitializeErrorCodes = {}));
/**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.method = 'initialized';
    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
})(InitializedNotification || (exports.InitializedNotification = InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.method = 'shutdown';
    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
})(ShutdownRequest || (exports.ShutdownRequest = ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.method = 'exit';
    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
})(ExitNotification || (exports.ExitNotification = ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
})(DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
    /**
     * A debug message.
     *
     * @since 3.18.0
     */
    MessageType.Debug = 5;
})(MessageType || (exports.MessageType = MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.method = 'window/showMessage';
    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
})(ShowMessageNotification || (exports.ShowMessageNotification = ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.method = 'window/showMessageRequest';
    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
})(ShowMessageRequest || (exports.ShowMessageRequest = ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.method = 'window/logMessage';
    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
})(LogMessageNotification || (exports.LogMessageNotification = LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.method = 'telemetry/event';
    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
})(TelemetryEventNotification || (exports.TelemetryEventNotification = TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind || (exports.TextDocumentSyncKind = TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
var TextDocumentContentChangeEvent;
(function (TextDocumentContentChangeEvent) {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    TextDocumentContentChangeEvent.isIncremental = isIncremental;
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent.isFull = isFull;
})(TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
})(DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
var RelativePattern;
(function (RelativePattern) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
    }
    RelativePattern.is = is;
})(RelativePattern || (exports.RelativePattern = RelativePattern = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind || (exports.WatchKind = WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
})(PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
})(CompletionRequest || (exports.CompletionRequest = CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest || (exports.CompletionResolveRequest = CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest || (exports.HoverRequest = HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest || (exports.SignatureHelpRequest = SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPosition}
 * the response is of either type {@link Definition} or a typed array of
 * {@link DefinitionLink} or a Thenable that resolves to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
})(DefinitionRequest || (exports.DefinitionRequest = DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
})(ReferencesRequest || (exports.ReferencesRequest = ReferencesRequest = {}));
/**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type {@link TextDocumentPosition}
 * the request response is an array of type {@link DocumentHighlight}
 * or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
})(DocumentHighlightRequest || (exports.DocumentHighlightRequest = DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
})(DocumentSymbolRequest || (exports.DocumentSymbolRequest = DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
})(CodeActionRequest || (exports.CodeActionRequest = CodeActionRequest = {}));
/**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */
var CodeActionResolveRequest;
(function (CodeActionResolveRequest) {
    CodeActionResolveRequest.method = 'codeAction/resolve';
    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
})(CodeActionResolveRequest || (exports.CodeActionResolveRequest = CodeActionResolveRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
})(WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
/**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */
var WorkspaceSymbolResolveRequest;
(function (WorkspaceSymbolResolveRequest) {
    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
})(WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.method = 'textDocument/codeLens';
    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
})(CodeLensRequest || (exports.CodeLensRequest = CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.method = 'codeLens/resolve';
    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
})(CodeLensResolveRequest || (exports.CodeLensResolveRequest = CodeLensResolveRequest = {}));
/**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */
var CodeLensRefreshRequest;
(function (CodeLensRefreshRequest) {
    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
})(CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
})(DocumentLinkRequest || (exports.DocumentLinkRequest = DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.method = 'documentLink/resolve';
    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
})(DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
/**
 * A request to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest || (exports.DocumentFormattingRequest = DocumentFormattingRequest = {}));
/**
 * A request to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
/**
 * A request to format ranges in a document.
 *
 * @since 3.18.0
 * @proposed
 */
var DocumentRangesFormattingRequest;
(function (DocumentRangesFormattingRequest) {
    DocumentRangesFormattingRequest.method = 'textDocument/rangesFormatting';
    DocumentRangesFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentRangesFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest.method);
})(DocumentRangesFormattingRequest || (exports.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
//---- Rename ----------------------------------------------
var PrepareSupportDefaultBehavior;
(function (PrepareSupportDefaultBehavior) {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    PrepareSupportDefaultBehavior.Identifier = 1;
})(PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest || (exports.RenameRequest = RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest || (exports.PrepareRenameRequest = PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.method = 'workspace/executeCommand';
    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
})(ExecuteCommandRequest || (exports.ExecuteCommandRequest = ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js ***!
  \********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel.document = 'document';
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel.project = 'project';
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel.group = 'group';
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel.scheme = 'scheme';
    /**
     * The moniker is globally unique
     */
    UniquenessLevel.global = 'global';
})(UniquenessLevel || (exports.UniquenessLevel = UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind.$import = 'import';
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind.$export = 'export';
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind.local = 'local';
})(MonikerKind || (exports.MonikerKind = MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest || (exports.MonikerRequest = MonikerRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */
var NotebookCellKind;
(function (NotebookCellKind) {
    /**
     * A markup-cell is formatted source that is used for display.
     */
    NotebookCellKind.Markup = 1;
    /**
     * A code-cell is source code.
     */
    NotebookCellKind.Code = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    NotebookCellKind.is = is;
})(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));
var ExecutionSummary;
(function (ExecutionSummary) {
    function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
            result.success = success;
        }
        return result;
    }
    ExecutionSummary.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
    }
    ExecutionSummary.is = is;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
    }
    ExecutionSummary.equals = equals;
})(ExecutionSummary || (exports.ExecutionSummary = ExecutionSummary = {}));
var NotebookCell;
(function (NotebookCell) {
    function create(kind, document) {
        return { kind, document };
    }
    NotebookCell.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) &&
            (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
    }
    NotebookCell.is = is;
    function diff(one, two) {
        const result = new Set();
        if (one.document !== two.document) {
            result.add('document');
        }
        if (one.kind !== two.kind) {
            result.add('kind');
        }
        if (one.executionSummary !== two.executionSummary) {
            result.add('executionSummary');
        }
        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add('metadata');
        }
        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add('executionSummary');
        }
        return result;
    }
    NotebookCell.diff = diff;
    function equalsMetadata(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
            return false;
        }
        if (oneArray && otherArray) {
            if (one.length !== other.length) {
                return false;
            }
            for (let i = 0; i < one.length; i++) {
                if (!equalsMetadata(one[i], other[i])) {
                    return false;
                }
            }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
                return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
                return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
                const prop = oneKeys[i];
                if (!equalsMetadata(one[prop], other[prop])) {
                    return false;
                }
            }
        }
        return true;
    }
})(NotebookCell || (exports.NotebookCell = NotebookCell = {}));
var NotebookDocument;
(function (NotebookDocument) {
    function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
    }
    NotebookDocument.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
    }
    NotebookDocument.is = is;
})(NotebookDocument || (exports.NotebookDocument = NotebookDocument = {}));
var NotebookDocumentSyncRegistrationType;
(function (NotebookDocumentSyncRegistrationType) {
    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
})(NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
/**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */
var DidOpenNotebookDocumentNotification;
(function (DidOpenNotebookDocumentNotification) {
    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
var NotebookCellArrayChange;
(function (NotebookCellArrayChange) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
    }
    NotebookCellArrayChange.is = is;
    function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== undefined) {
            result.cells = cells;
        }
        return result;
    }
    NotebookCellArrayChange.create = create;
})(NotebookCellArrayChange || (exports.NotebookCellArrayChange = NotebookCellArrayChange = {}));
var DidChangeNotebookDocumentNotification;
(function (DidChangeNotebookDocumentNotification) {
    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */
var DidSaveNotebookDocumentNotification;
(function (DidSaveNotebookDocumentNotification) {
    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */
var DidCloseNotebookDocumentNotification;
(function (DidCloseNotebookDocumentNotification) {
    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress || (exports.WorkDoneProgress = WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
})(WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
})(WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest || (exports.SelectionRangeRequest = SelectionRangeRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat || (exports.TokenFormat = TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRequest || (exports.SemanticTokensRequest = SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest || (exports.ShowDocumentRequest = ShowDocumentRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Definition} or a Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest || (exports.TypeDefinitionRequest = TypeDefinitionRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */
var TypeHierarchyPrepareRequest;
(function (TypeHierarchyPrepareRequest) {
    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
})(TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
/**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySupertypesRequest;
(function (TypeHierarchySupertypesRequest) {
    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
})(TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
/**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySubtypesRequest;
(function (TypeHierarchySubtypesRequest) {
    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
})(TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
})(WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
})(DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js ***!
  \*******************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const node_1 = __webpack_require__(/*! vscode-jsonrpc/node */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/node.js");
__exportStar(__webpack_require__(/*! vscode-jsonrpc/node */ "./node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/node.js"), exports);
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/api.js"), exports);
function createProtocolConnection(input, output, logger, options) {
    return (0, node_1.createMessageConnection)(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js ***!
  \************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {
    if ( true && typeof module.exports === "object") {
        var v = factory(__webpack_require__("./node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd sync recursive"), exports);
        if (v !== undefined) module.exports = v;
    }
    else if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
})(function (require, exports) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextDocument = exports.EOL = exports.WorkspaceFolder = exports.InlineCompletionContext = exports.SelectedCompletionInfo = exports.InlineCompletionTriggerKind = exports.InlineCompletionList = exports.InlineCompletionItem = exports.StringValue = exports.InlayHint = exports.InlayHintLabelPart = exports.InlayHintKind = exports.InlineValueContext = exports.InlineValueEvaluatableExpression = exports.InlineValueVariableLookup = exports.InlineValueText = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.SelectionRange = exports.DocumentLink = exports.FormattingOptions = exports.CodeLens = exports.CodeAction = exports.CodeActionContext = exports.CodeActionTriggerKind = exports.CodeActionKind = exports.DocumentSymbol = exports.WorkspaceSymbol = exports.SymbolInformation = exports.SymbolTag = exports.SymbolKind = exports.DocumentHighlight = exports.DocumentHighlightKind = exports.SignatureInformation = exports.ParameterInformation = exports.Hover = exports.MarkedString = exports.CompletionList = exports.CompletionItem = exports.CompletionItemLabelDetails = exports.InsertTextMode = exports.InsertReplaceEdit = exports.CompletionItemTag = exports.InsertTextFormat = exports.CompletionItemKind = exports.MarkupContent = exports.MarkupKind = exports.TextDocumentItem = exports.OptionalVersionedTextDocumentIdentifier = exports.VersionedTextDocumentIdentifier = exports.TextDocumentIdentifier = exports.WorkspaceChange = exports.WorkspaceEdit = exports.DeleteFile = exports.RenameFile = exports.CreateFile = exports.TextDocumentEdit = exports.AnnotatedTextEdit = exports.ChangeAnnotationIdentifier = exports.ChangeAnnotation = exports.TextEdit = exports.Command = exports.Diagnostic = exports.CodeDescription = exports.DiagnosticTag = exports.DiagnosticSeverity = exports.DiagnosticRelatedInformation = exports.FoldingRange = exports.FoldingRangeKind = exports.ColorPresentation = exports.ColorInformation = exports.Color = exports.LocationLink = exports.Location = exports.Range = exports.Position = exports.uinteger = exports.integer = exports.URI = exports.DocumentUri = void 0;
    var DocumentUri;
    (function (DocumentUri) {
        function is(value) {
            return typeof value === 'string';
        }
        DocumentUri.is = is;
    })(DocumentUri || (exports.DocumentUri = DocumentUri = {}));
    var URI;
    (function (URI) {
        function is(value) {
            return typeof value === 'string';
        }
        URI.is = is;
    })(URI || (exports.URI = URI = {}));
    var integer;
    (function (integer) {
        integer.MIN_VALUE = -2147483648;
        integer.MAX_VALUE = 2147483647;
        function is(value) {
            return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
        }
        integer.is = is;
    })(integer || (exports.integer = integer = {}));
    var uinteger;
    (function (uinteger) {
        uinteger.MIN_VALUE = 0;
        uinteger.MAX_VALUE = 2147483647;
        function is(value) {
            return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
        }
        uinteger.is = is;
    })(uinteger || (exports.uinteger = uinteger = {}));
    /**
     * The Position namespace provides helper functions to work with
     * {@link Position} literals.
     */
    var Position;
    (function (Position) {
        /**
         * Creates a new Position literal from the given line and character.
         * @param line The position's line.
         * @param character The position's character.
         */
        function create(line, character) {
            if (line === Number.MAX_VALUE) {
                line = uinteger.MAX_VALUE;
            }
            if (character === Number.MAX_VALUE) {
                character = uinteger.MAX_VALUE;
            }
            return { line: line, character: character };
        }
        Position.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Position} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position.is = is;
    })(Position || (exports.Position = Position = {}));
    /**
     * The Range namespace provides helper functions to work with
     * {@link Range} literals.
     */
    var Range;
    (function (Range) {
        function create(one, two, three, four) {
            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                return { start: Position.create(one, two), end: Position.create(three, four) };
            }
            else if (Position.is(one) && Position.is(two)) {
                return { start: one, end: two };
            }
            else {
                throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
            }
        }
        Range.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Range} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range.is = is;
    })(Range || (exports.Range = Range = {}));
    /**
     * The Location namespace provides helper functions to work with
     * {@link Location} literals.
     */
    var Location;
    (function (Location) {
        /**
         * Creates a Location literal.
         * @param uri The location's uri.
         * @param range The location's range.
         */
        function create(uri, range) {
            return { uri: uri, range: range };
        }
        Location.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Location} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location.is = is;
    })(Location || (exports.Location = Location = {}));
    /**
     * The LocationLink namespace provides helper functions to work with
     * {@link LocationLink} literals.
     */
    var LocationLink;
    (function (LocationLink) {
        /**
         * Creates a LocationLink literal.
         * @param targetUri The definition's uri.
         * @param targetRange The full range of the definition.
         * @param targetSelectionRange The span of the symbol definition at the target.
         * @param originSelectionRange The span of the symbol being defined in the originating source file.
         */
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
            return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
        }
        LocationLink.create = create;
        /**
         * Checks whether the given literal conforms to the {@link LocationLink} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
                && Range.is(candidate.targetSelectionRange)
                && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink.is = is;
    })(LocationLink || (exports.LocationLink = LocationLink = {}));
    /**
     * The Color namespace provides helper functions to work with
     * {@link Color} literals.
     */
    var Color;
    (function (Color) {
        /**
         * Creates a new Color literal.
         */
        function create(red, green, blue, alpha) {
            return {
                red: red,
                green: green,
                blue: blue,
                alpha: alpha,
            };
        }
        Color.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Color} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)
                && Is.numberRange(candidate.green, 0, 1)
                && Is.numberRange(candidate.blue, 0, 1)
                && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color.is = is;
    })(Color || (exports.Color = Color = {}));
    /**
     * The ColorInformation namespace provides helper functions to work with
     * {@link ColorInformation} literals.
     */
    var ColorInformation;
    (function (ColorInformation) {
        /**
         * Creates a new ColorInformation literal.
         */
        function create(range, color) {
            return {
                range: range,
                color: color,
            };
        }
        ColorInformation.create = create;
        /**
         * Checks whether the given literal conforms to the {@link ColorInformation} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation.is = is;
    })(ColorInformation || (exports.ColorInformation = ColorInformation = {}));
    /**
     * The Color namespace provides helper functions to work with
     * {@link ColorPresentation} literals.
     */
    var ColorPresentation;
    (function (ColorPresentation) {
        /**
         * Creates a new ColorInformation literal.
         */
        function create(label, textEdit, additionalTextEdits) {
            return {
                label: label,
                textEdit: textEdit,
                additionalTextEdits: additionalTextEdits,
            };
        }
        ColorPresentation.create = create;
        /**
         * Checks whether the given literal conforms to the {@link ColorInformation} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label)
                && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
                && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation.is = is;
    })(ColorPresentation || (exports.ColorPresentation = ColorPresentation = {}));
    /**
     * A set of predefined range kinds.
     */
    var FoldingRangeKind;
    (function (FoldingRangeKind) {
        /**
         * Folding range for a comment
         */
        FoldingRangeKind.Comment = 'comment';
        /**
         * Folding range for an import or include
         */
        FoldingRangeKind.Imports = 'imports';
        /**
         * Folding range for a region (e.g. `#region`)
         */
        FoldingRangeKind.Region = 'region';
    })(FoldingRangeKind || (exports.FoldingRangeKind = FoldingRangeKind = {}));
    /**
     * The folding range namespace provides helper functions to work with
     * {@link FoldingRange} literals.
     */
    var FoldingRange;
    (function (FoldingRange) {
        /**
         * Creates a new FoldingRange literal.
         */
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
            var result = {
                startLine: startLine,
                endLine: endLine
            };
            if (Is.defined(startCharacter)) {
                result.startCharacter = startCharacter;
            }
            if (Is.defined(endCharacter)) {
                result.endCharacter = endCharacter;
            }
            if (Is.defined(kind)) {
                result.kind = kind;
            }
            if (Is.defined(collapsedText)) {
                result.collapsedText = collapsedText;
            }
            return result;
        }
        FoldingRange.create = create;
        /**
         * Checks whether the given literal conforms to the {@link FoldingRange} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
                && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
                && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
                && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange.is = is;
    })(FoldingRange || (exports.FoldingRange = FoldingRange = {}));
    /**
     * The DiagnosticRelatedInformation namespace provides helper functions to work with
     * {@link DiagnosticRelatedInformation} literals.
     */
    var DiagnosticRelatedInformation;
    (function (DiagnosticRelatedInformation) {
        /**
         * Creates a new DiagnosticRelatedInformation literal.
         */
        function create(location, message) {
            return {
                location: location,
                message: message
            };
        }
        DiagnosticRelatedInformation.create = create;
        /**
         * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation.is = is;
    })(DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
    /**
     * The diagnostic's severity.
     */
    var DiagnosticSeverity;
    (function (DiagnosticSeverity) {
        /**
         * Reports an error.
         */
        DiagnosticSeverity.Error = 1;
        /**
         * Reports a warning.
         */
        DiagnosticSeverity.Warning = 2;
        /**
         * Reports an information.
         */
        DiagnosticSeverity.Information = 3;
        /**
         * Reports a hint.
         */
        DiagnosticSeverity.Hint = 4;
    })(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));
    /**
     * The diagnostic tags.
     *
     * @since 3.15.0
     */
    var DiagnosticTag;
    (function (DiagnosticTag) {
        /**
         * Unused or unnecessary code.
         *
         * Clients are allowed to render diagnostics with this tag faded out instead of having
         * an error squiggle.
         */
        DiagnosticTag.Unnecessary = 1;
        /**
         * Deprecated or obsolete code.
         *
         * Clients are allowed to rendered diagnostics with this tag strike through.
         */
        DiagnosticTag.Deprecated = 2;
    })(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));
    /**
     * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
     *
     * @since 3.16.0
     */
    var CodeDescription;
    (function (CodeDescription) {
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription.is = is;
    })(CodeDescription || (exports.CodeDescription = CodeDescription = {}));
    /**
     * The Diagnostic namespace provides helper functions to work with
     * {@link Diagnostic} literals.
     */
    var Diagnostic;
    (function (Diagnostic) {
        /**
         * Creates a new Diagnostic literal.
         */
        function create(range, message, severity, code, source, relatedInformation) {
            var result = { range: range, message: message };
            if (Is.defined(severity)) {
                result.severity = severity;
            }
            if (Is.defined(code)) {
                result.code = code;
            }
            if (Is.defined(source)) {
                result.source = source;
            }
            if (Is.defined(relatedInformation)) {
                result.relatedInformation = relatedInformation;
            }
            return result;
        }
        Diagnostic.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Diagnostic} interface.
         */
        function is(value) {
            var _a;
            var candidate = value;
            return Is.defined(candidate)
                && Range.is(candidate.range)
                && Is.string(candidate.message)
                && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
                && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
                && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
                && (Is.string(candidate.source) || Is.undefined(candidate.source))
                && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic.is = is;
    })(Diagnostic || (exports.Diagnostic = Diagnostic = {}));
    /**
     * The Command namespace provides helper functions to work with
     * {@link Command} literals.
     */
    var Command;
    (function (Command) {
        /**
         * Creates a new Command literal.
         */
        function create(title, command) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var result = { title: title, command: command };
            if (Is.defined(args) && args.length > 0) {
                result.arguments = args;
            }
            return result;
        }
        Command.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Command} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command.is = is;
    })(Command || (exports.Command = Command = {}));
    /**
     * The TextEdit namespace provides helper function to create replace,
     * insert and delete edits more easily.
     */
    var TextEdit;
    (function (TextEdit) {
        /**
         * Creates a replace text edit.
         * @param range The range of text to be replaced.
         * @param newText The new text.
         */
        function replace(range, newText) {
            return { range: range, newText: newText };
        }
        TextEdit.replace = replace;
        /**
         * Creates an insert text edit.
         * @param position The position to insert the text at.
         * @param newText The text to be inserted.
         */
        function insert(position, newText) {
            return { range: { start: position, end: position }, newText: newText };
        }
        TextEdit.insert = insert;
        /**
         * Creates a delete text edit.
         * @param range The range of text to be deleted.
         */
        function del(range) {
            return { range: range, newText: '' };
        }
        TextEdit.del = del;
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate)
                && Is.string(candidate.newText)
                && Range.is(candidate.range);
        }
        TextEdit.is = is;
    })(TextEdit || (exports.TextEdit = TextEdit = {}));
    var ChangeAnnotation;
    (function (ChangeAnnotation) {
        function create(label, needsConfirmation, description) {
            var result = { label: label };
            if (needsConfirmation !== undefined) {
                result.needsConfirmation = needsConfirmation;
            }
            if (description !== undefined) {
                result.description = description;
            }
            return result;
        }
        ChangeAnnotation.create = create;
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label) &&
                (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
                (Is.string(candidate.description) || candidate.description === undefined);
        }
        ChangeAnnotation.is = is;
    })(ChangeAnnotation || (exports.ChangeAnnotation = ChangeAnnotation = {}));
    var ChangeAnnotationIdentifier;
    (function (ChangeAnnotationIdentifier) {
        function is(value) {
            var candidate = value;
            return Is.string(candidate);
        }
        ChangeAnnotationIdentifier.is = is;
    })(ChangeAnnotationIdentifier || (exports.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
    var AnnotatedTextEdit;
    (function (AnnotatedTextEdit) {
        /**
         * Creates an annotated replace text edit.
         *
         * @param range The range of text to be replaced.
         * @param newText The new text.
         * @param annotation The annotation.
         */
        function replace(range, newText, annotation) {
            return { range: range, newText: newText, annotationId: annotation };
        }
        AnnotatedTextEdit.replace = replace;
        /**
         * Creates an annotated insert text edit.
         *
         * @param position The position to insert the text at.
         * @param newText The text to be inserted.
         * @param annotation The annotation.
         */
        function insert(position, newText, annotation) {
            return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
        }
        AnnotatedTextEdit.insert = insert;
        /**
         * Creates an annotated delete text edit.
         *
         * @param range The range of text to be deleted.
         * @param annotation The annotation.
         */
        function del(range, annotation) {
            return { range: range, newText: '', annotationId: annotation };
        }
        AnnotatedTextEdit.del = del;
        function is(value) {
            var candidate = value;
            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit.is = is;
    })(AnnotatedTextEdit || (exports.AnnotatedTextEdit = AnnotatedTextEdit = {}));
    /**
     * The TextDocumentEdit namespace provides helper function to create
     * an edit that manipulates a text document.
     */
    var TextDocumentEdit;
    (function (TextDocumentEdit) {
        /**
         * Creates a new `TextDocumentEdit`
         */
        function create(textDocument, edits) {
            return { textDocument: textDocument, edits: edits };
        }
        TextDocumentEdit.create = create;
        function is(value) {
            var candidate = value;
            return Is.defined(candidate)
                && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
                && Array.isArray(candidate.edits);
        }
        TextDocumentEdit.is = is;
    })(TextDocumentEdit || (exports.TextDocumentEdit = TextDocumentEdit = {}));
    var CreateFile;
    (function (CreateFile) {
        function create(uri, options, annotation) {
            var result = {
                kind: 'create',
                uri: uri
            };
            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                result.options = options;
            }
            if (annotation !== undefined) {
                result.annotationId = annotation;
            }
            return result;
        }
        CreateFile.create = create;
        function is(value) {
            var candidate = value;
            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile.is = is;
    })(CreateFile || (exports.CreateFile = CreateFile = {}));
    var RenameFile;
    (function (RenameFile) {
        function create(oldUri, newUri, options, annotation) {
            var result = {
                kind: 'rename',
                oldUri: oldUri,
                newUri: newUri
            };
            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                result.options = options;
            }
            if (annotation !== undefined) {
                result.annotationId = annotation;
            }
            return result;
        }
        RenameFile.create = create;
        function is(value) {
            var candidate = value;
            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile.is = is;
    })(RenameFile || (exports.RenameFile = RenameFile = {}));
    var DeleteFile;
    (function (DeleteFile) {
        function create(uri, options, annotation) {
            var result = {
                kind: 'delete',
                uri: uri
            };
            if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                result.options = options;
            }
            if (annotation !== undefined) {
                result.annotationId = annotation;
            }
            return result;
        }
        DeleteFile.create = create;
        function is(value) {
            var candidate = value;
            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
                ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile.is = is;
    })(DeleteFile || (exports.DeleteFile = DeleteFile = {}));
    var WorkspaceEdit;
    (function (WorkspaceEdit) {
        function is(value) {
            var candidate = value;
            return candidate &&
                (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
                (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                    if (Is.string(change.kind)) {
                        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                    }
                    else {
                        return TextDocumentEdit.is(change);
                    }
                }));
        }
        WorkspaceEdit.is = is;
    })(WorkspaceEdit || (exports.WorkspaceEdit = WorkspaceEdit = {}));
    var TextEditChangeImpl = /** @class */ (function () {
        function TextEditChangeImpl(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
        }
        TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
            var edit;
            var id;
            if (annotation === undefined) {
                edit = TextEdit.insert(position, newText);
            }
            else if (ChangeAnnotationIdentifier.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit.insert(position, newText, annotation);
            }
            else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== undefined) {
                return id;
            }
        };
        TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
            var edit;
            var id;
            if (annotation === undefined) {
                edit = TextEdit.replace(range, newText);
            }
            else if (ChangeAnnotationIdentifier.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit.replace(range, newText, annotation);
            }
            else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== undefined) {
                return id;
            }
        };
        TextEditChangeImpl.prototype.delete = function (range, annotation) {
            var edit;
            var id;
            if (annotation === undefined) {
                edit = TextEdit.del(range);
            }
            else if (ChangeAnnotationIdentifier.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit.del(range, annotation);
            }
            else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== undefined) {
                return id;
            }
        };
        TextEditChangeImpl.prototype.add = function (edit) {
            this.edits.push(edit);
        };
        TextEditChangeImpl.prototype.all = function () {
            return this.edits;
        };
        TextEditChangeImpl.prototype.clear = function () {
            this.edits.splice(0, this.edits.length);
        };
        TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
            if (value === undefined) {
                throw new Error("Text edit change is not configured to manage change annotations.");
            }
        };
        return TextEditChangeImpl;
    }());
    /**
     * A helper class
     */
    var ChangeAnnotations = /** @class */ (function () {
        function ChangeAnnotations(annotations) {
            this._annotations = annotations === undefined ? Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
        }
        ChangeAnnotations.prototype.all = function () {
            return this._annotations;
        };
        Object.defineProperty(ChangeAnnotations.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                id = idOrAnnotation;
            }
            else {
                id = this.nextId();
                annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== undefined) {
                throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === undefined) {
                throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
        };
        ChangeAnnotations.prototype.nextId = function () {
            this._counter++;
            return this._counter.toString();
        };
        return ChangeAnnotations;
    }());
    /**
     * A workspace change helps constructing changes to a workspace.
     */
    var WorkspaceChange = /** @class */ (function () {
        function WorkspaceChange(workspaceEdit) {
            var _this = this;
            this._textEditChanges = Object.create(null);
            if (workspaceEdit !== undefined) {
                this._workspaceEdit = workspaceEdit;
                if (workspaceEdit.documentChanges) {
                    this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                    workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                    workspaceEdit.documentChanges.forEach(function (change) {
                        if (TextDocumentEdit.is(change)) {
                            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                            _this._textEditChanges[change.textDocument.uri] = textEditChange;
                        }
                    });
                }
                else if (workspaceEdit.changes) {
                    Object.keys(workspaceEdit.changes).forEach(function (key) {
                        var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                        _this._textEditChanges[key] = textEditChange;
                    });
                }
            }
            else {
                this._workspaceEdit = {};
            }
        }
        Object.defineProperty(WorkspaceChange.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function () {
                this.initDocumentChanges();
                if (this._changeAnnotations !== undefined) {
                    if (this._changeAnnotations.size === 0) {
                        this._workspaceEdit.changeAnnotations = undefined;
                    }
                    else {
                        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                    }
                }
                return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
        });
        WorkspaceChange.prototype.getTextEditChange = function (key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                this.initDocumentChanges();
                if (this._workspaceEdit.documentChanges === undefined) {
                    throw new Error('Workspace edit is not configured for document changes.');
                }
                var textDocument = { uri: key.uri, version: key.version };
                var result = this._textEditChanges[textDocument.uri];
                if (!result) {
                    var edits = [];
                    var textDocumentEdit = {
                        textDocument: textDocument,
                        edits: edits
                    };
                    this._workspaceEdit.documentChanges.push(textDocumentEdit);
                    result = new TextEditChangeImpl(edits, this._changeAnnotations);
                    this._textEditChanges[textDocument.uri] = result;
                }
                return result;
            }
            else {
                this.initChanges();
                if (this._workspaceEdit.changes === undefined) {
                    throw new Error('Workspace edit is not configured for normal text edit changes.');
                }
                var result = this._textEditChanges[key];
                if (!result) {
                    var edits = [];
                    this._workspaceEdit.changes[key] = edits;
                    result = new TextEditChangeImpl(edits);
                    this._textEditChanges[key] = result;
                }
                return result;
            }
        };
        WorkspaceChange.prototype.initDocumentChanges = function () {
            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                this._changeAnnotations = new ChangeAnnotations();
                this._workspaceEdit.documentChanges = [];
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
        };
        WorkspaceChange.prototype.initChanges = function () {
            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                this._workspaceEdit.changes = Object.create(null);
            }
        };
        WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
            }
            else {
                options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === undefined) {
                operation = CreateFile.create(uri, options);
            }
            else {
                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== undefined) {
                return id;
            }
        };
        WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
            }
            else {
                options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === undefined) {
                operation = RenameFile.create(oldUri, newUri, options);
            }
            else {
                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== undefined) {
                return id;
            }
        };
        WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
            }
            else {
                options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === undefined) {
                operation = DeleteFile.create(uri, options);
            }
            else {
                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== undefined) {
                return id;
            }
        };
        return WorkspaceChange;
    }());
    exports.WorkspaceChange = WorkspaceChange;
    /**
     * The TextDocumentIdentifier namespace provides helper functions to work with
     * {@link TextDocumentIdentifier} literals.
     */
    var TextDocumentIdentifier;
    (function (TextDocumentIdentifier) {
        /**
         * Creates a new TextDocumentIdentifier literal.
         * @param uri The document's uri.
         */
        function create(uri) {
            return { uri: uri };
        }
        TextDocumentIdentifier.create = create;
        /**
         * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier.is = is;
    })(TextDocumentIdentifier || (exports.TextDocumentIdentifier = TextDocumentIdentifier = {}));
    /**
     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
     * {@link VersionedTextDocumentIdentifier} literals.
     */
    var VersionedTextDocumentIdentifier;
    (function (VersionedTextDocumentIdentifier) {
        /**
         * Creates a new VersionedTextDocumentIdentifier literal.
         * @param uri The document's uri.
         * @param version The document's version.
         */
        function create(uri, version) {
            return { uri: uri, version: version };
        }
        VersionedTextDocumentIdentifier.create = create;
        /**
         * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier.is = is;
    })(VersionedTextDocumentIdentifier || (exports.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
    /**
     * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
     * {@link OptionalVersionedTextDocumentIdentifier} literals.
     */
    var OptionalVersionedTextDocumentIdentifier;
    (function (OptionalVersionedTextDocumentIdentifier) {
        /**
         * Creates a new OptionalVersionedTextDocumentIdentifier literal.
         * @param uri The document's uri.
         * @param version The document's version.
         */
        function create(uri, version) {
            return { uri: uri, version: version };
        }
        OptionalVersionedTextDocumentIdentifier.create = create;
        /**
         * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (exports.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
    /**
     * The TextDocumentItem namespace provides helper functions to work with
     * {@link TextDocumentItem} literals.
     */
    var TextDocumentItem;
    (function (TextDocumentItem) {
        /**
         * Creates a new TextDocumentItem literal.
         * @param uri The document's uri.
         * @param languageId The document's language identifier.
         * @param version The document's version number.
         * @param text The document's text.
         */
        function create(uri, languageId, version, text) {
            return { uri: uri, languageId: languageId, version: version, text: text };
        }
        TextDocumentItem.create = create;
        /**
         * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem.is = is;
    })(TextDocumentItem || (exports.TextDocumentItem = TextDocumentItem = {}));
    /**
     * Describes the content type that a client supports in various
     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
     *
     * Please note that `MarkupKinds` must not start with a `$`. This kinds
     * are reserved for internal usage.
     */
    var MarkupKind;
    (function (MarkupKind) {
        /**
         * Plain text is supported as a content format
         */
        MarkupKind.PlainText = 'plaintext';
        /**
         * Markdown is supported as a content format
         */
        MarkupKind.Markdown = 'markdown';
        /**
         * Checks whether the given value is a value of the {@link MarkupKind} type.
         */
        function is(value) {
            var candidate = value;
            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
        }
        MarkupKind.is = is;
    })(MarkupKind || (exports.MarkupKind = MarkupKind = {}));
    var MarkupContent;
    (function (MarkupContent) {
        /**
         * Checks whether the given value conforms to the {@link MarkupContent} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent.is = is;
    })(MarkupContent || (exports.MarkupContent = MarkupContent = {}));
    /**
     * The kind of a completion entry.
     */
    var CompletionItemKind;
    (function (CompletionItemKind) {
        CompletionItemKind.Text = 1;
        CompletionItemKind.Method = 2;
        CompletionItemKind.Function = 3;
        CompletionItemKind.Constructor = 4;
        CompletionItemKind.Field = 5;
        CompletionItemKind.Variable = 6;
        CompletionItemKind.Class = 7;
        CompletionItemKind.Interface = 8;
        CompletionItemKind.Module = 9;
        CompletionItemKind.Property = 10;
        CompletionItemKind.Unit = 11;
        CompletionItemKind.Value = 12;
        CompletionItemKind.Enum = 13;
        CompletionItemKind.Keyword = 14;
        CompletionItemKind.Snippet = 15;
        CompletionItemKind.Color = 16;
        CompletionItemKind.File = 17;
        CompletionItemKind.Reference = 18;
        CompletionItemKind.Folder = 19;
        CompletionItemKind.EnumMember = 20;
        CompletionItemKind.Constant = 21;
        CompletionItemKind.Struct = 22;
        CompletionItemKind.Event = 23;
        CompletionItemKind.Operator = 24;
        CompletionItemKind.TypeParameter = 25;
    })(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));
    /**
     * Defines whether the insert text in a completion item should be interpreted as
     * plain text or a snippet.
     */
    var InsertTextFormat;
    (function (InsertTextFormat) {
        /**
         * The primary text to be inserted is treated as a plain string.
         */
        InsertTextFormat.PlainText = 1;
        /**
         * The primary text to be inserted is treated as a snippet.
         *
         * A snippet can define tab stops and placeholders with `$1`, `$2`
         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
         * the end of the snippet. Placeholders with equal identifiers are linked,
         * that is typing in one will update others too.
         *
         * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
         */
        InsertTextFormat.Snippet = 2;
    })(InsertTextFormat || (exports.InsertTextFormat = InsertTextFormat = {}));
    /**
     * Completion item tags are extra annotations that tweak the rendering of a completion
     * item.
     *
     * @since 3.15.0
     */
    var CompletionItemTag;
    (function (CompletionItemTag) {
        /**
         * Render a completion as obsolete, usually using a strike-out.
         */
        CompletionItemTag.Deprecated = 1;
    })(CompletionItemTag || (exports.CompletionItemTag = CompletionItemTag = {}));
    /**
     * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
     *
     * @since 3.16.0
     */
    var InsertReplaceEdit;
    (function (InsertReplaceEdit) {
        /**
         * Creates a new insert / replace edit
         */
        function create(newText, insert, replace) {
            return { newText: newText, insert: insert, replace: replace };
        }
        InsertReplaceEdit.create = create;
        /**
         * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
         */
        function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit.is = is;
    })(InsertReplaceEdit || (exports.InsertReplaceEdit = InsertReplaceEdit = {}));
    /**
     * How whitespace and indentation is handled during completion
     * item insertion.
     *
     * @since 3.16.0
     */
    var InsertTextMode;
    (function (InsertTextMode) {
        /**
         * The insertion or replace strings is taken as it is. If the
         * value is multi line the lines below the cursor will be
         * inserted using the indentation defined in the string value.
         * The client will not apply any kind of adjustments to the
         * string.
         */
        InsertTextMode.asIs = 1;
        /**
         * The editor adjusts leading whitespace of new lines so that
         * they match the indentation up to the cursor of the line for
         * which the item is accepted.
         *
         * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
         * multi line completion item is indented using 2 tabs and all
         * following lines inserted will be indented using 2 tabs as well.
         */
        InsertTextMode.adjustIndentation = 2;
    })(InsertTextMode || (exports.InsertTextMode = InsertTextMode = {}));
    var CompletionItemLabelDetails;
    (function (CompletionItemLabelDetails) {
        function is(value) {
            var candidate = value;
            return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&
                (Is.string(candidate.description) || candidate.description === undefined);
        }
        CompletionItemLabelDetails.is = is;
    })(CompletionItemLabelDetails || (exports.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
    /**
     * The CompletionItem namespace provides functions to deal with
     * completion items.
     */
    var CompletionItem;
    (function (CompletionItem) {
        /**
         * Create a completion item and seed it with a label.
         * @param label The completion item's label
         */
        function create(label) {
            return { label: label };
        }
        CompletionItem.create = create;
    })(CompletionItem || (exports.CompletionItem = CompletionItem = {}));
    /**
     * The CompletionList namespace provides functions to deal with
     * completion lists.
     */
    var CompletionList;
    (function (CompletionList) {
        /**
         * Creates a new completion list.
         *
         * @param items The completion items.
         * @param isIncomplete The list is not complete.
         */
        function create(items, isIncomplete) {
            return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList.create = create;
    })(CompletionList || (exports.CompletionList = CompletionList = {}));
    var MarkedString;
    (function (MarkedString) {
        /**
         * Creates a marked string from plain text.
         *
         * @param plainText The plain text.
         */
        function fromPlainText(plainText) {
            return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
        }
        MarkedString.fromPlainText = fromPlainText;
        /**
         * Checks whether the given value conforms to the {@link MarkedString} type.
         */
        function is(value) {
            var candidate = value;
            return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
        }
        MarkedString.is = is;
    })(MarkedString || (exports.MarkedString = MarkedString = {}));
    var Hover;
    (function (Hover) {
        /**
         * Checks whether the given value conforms to the {@link Hover} interface.
         */
        function is(value) {
            var candidate = value;
            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
                MarkedString.is(candidate.contents) ||
                Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
        }
        Hover.is = is;
    })(Hover || (exports.Hover = Hover = {}));
    /**
     * The ParameterInformation namespace provides helper functions to work with
     * {@link ParameterInformation} literals.
     */
    var ParameterInformation;
    (function (ParameterInformation) {
        /**
         * Creates a new parameter information literal.
         *
         * @param label A label string.
         * @param documentation A doc string.
         */
        function create(label, documentation) {
            return documentation ? { label: label, documentation: documentation } : { label: label };
        }
        ParameterInformation.create = create;
    })(ParameterInformation || (exports.ParameterInformation = ParameterInformation = {}));
    /**
     * The SignatureInformation namespace provides helper functions to work with
     * {@link SignatureInformation} literals.
     */
    var SignatureInformation;
    (function (SignatureInformation) {
        function create(label, documentation) {
            var parameters = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                parameters[_i - 2] = arguments[_i];
            }
            var result = { label: label };
            if (Is.defined(documentation)) {
                result.documentation = documentation;
            }
            if (Is.defined(parameters)) {
                result.parameters = parameters;
            }
            else {
                result.parameters = [];
            }
            return result;
        }
        SignatureInformation.create = create;
    })(SignatureInformation || (exports.SignatureInformation = SignatureInformation = {}));
    /**
     * A document highlight kind.
     */
    var DocumentHighlightKind;
    (function (DocumentHighlightKind) {
        /**
         * A textual occurrence.
         */
        DocumentHighlightKind.Text = 1;
        /**
         * Read-access of a symbol, like reading a variable.
         */
        DocumentHighlightKind.Read = 2;
        /**
         * Write-access of a symbol, like writing to a variable.
         */
        DocumentHighlightKind.Write = 3;
    })(DocumentHighlightKind || (exports.DocumentHighlightKind = DocumentHighlightKind = {}));
    /**
     * DocumentHighlight namespace to provide helper functions to work with
     * {@link DocumentHighlight} literals.
     */
    var DocumentHighlight;
    (function (DocumentHighlight) {
        /**
         * Create a DocumentHighlight object.
         * @param range The range the highlight applies to.
         * @param kind The highlight kind
         */
        function create(range, kind) {
            var result = { range: range };
            if (Is.number(kind)) {
                result.kind = kind;
            }
            return result;
        }
        DocumentHighlight.create = create;
    })(DocumentHighlight || (exports.DocumentHighlight = DocumentHighlight = {}));
    /**
     * A symbol kind.
     */
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind.File = 1;
        SymbolKind.Module = 2;
        SymbolKind.Namespace = 3;
        SymbolKind.Package = 4;
        SymbolKind.Class = 5;
        SymbolKind.Method = 6;
        SymbolKind.Property = 7;
        SymbolKind.Field = 8;
        SymbolKind.Constructor = 9;
        SymbolKind.Enum = 10;
        SymbolKind.Interface = 11;
        SymbolKind.Function = 12;
        SymbolKind.Variable = 13;
        SymbolKind.Constant = 14;
        SymbolKind.String = 15;
        SymbolKind.Number = 16;
        SymbolKind.Boolean = 17;
        SymbolKind.Array = 18;
        SymbolKind.Object = 19;
        SymbolKind.Key = 20;
        SymbolKind.Null = 21;
        SymbolKind.EnumMember = 22;
        SymbolKind.Struct = 23;
        SymbolKind.Event = 24;
        SymbolKind.Operator = 25;
        SymbolKind.TypeParameter = 26;
    })(SymbolKind || (exports.SymbolKind = SymbolKind = {}));
    /**
     * Symbol tags are extra annotations that tweak the rendering of a symbol.
     *
     * @since 3.16
     */
    var SymbolTag;
    (function (SymbolTag) {
        /**
         * Render a symbol as obsolete, usually using a strike-out.
         */
        SymbolTag.Deprecated = 1;
    })(SymbolTag || (exports.SymbolTag = SymbolTag = {}));
    var SymbolInformation;
    (function (SymbolInformation) {
        /**
         * Creates a new symbol information literal.
         *
         * @param name The name of the symbol.
         * @param kind The kind of the symbol.
         * @param range The range of the location of the symbol.
         * @param uri The resource of the location of symbol.
         * @param containerName The name of the symbol containing the symbol.
         */
        function create(name, kind, range, uri, containerName) {
            var result = {
                name: name,
                kind: kind,
                location: { uri: uri, range: range }
            };
            if (containerName) {
                result.containerName = containerName;
            }
            return result;
        }
        SymbolInformation.create = create;
    })(SymbolInformation || (exports.SymbolInformation = SymbolInformation = {}));
    var WorkspaceSymbol;
    (function (WorkspaceSymbol) {
        /**
         * Create a new workspace symbol.
         *
         * @param name The name of the symbol.
         * @param kind The kind of the symbol.
         * @param uri The resource of the location of the symbol.
         * @param range An options range of the location.
         * @returns A WorkspaceSymbol.
         */
        function create(name, kind, uri, range) {
            return range !== undefined
                ? { name: name, kind: kind, location: { uri: uri, range: range } }
                : { name: name, kind: kind, location: { uri: uri } };
        }
        WorkspaceSymbol.create = create;
    })(WorkspaceSymbol || (exports.WorkspaceSymbol = WorkspaceSymbol = {}));
    var DocumentSymbol;
    (function (DocumentSymbol) {
        /**
         * Creates a new symbol information literal.
         *
         * @param name The name of the symbol.
         * @param detail The detail of the symbol.
         * @param kind The kind of the symbol.
         * @param range The range of the symbol.
         * @param selectionRange The selectionRange of the symbol.
         * @param children Children of the symbol.
         */
        function create(name, detail, kind, range, selectionRange, children) {
            var result = {
                name: name,
                detail: detail,
                kind: kind,
                range: range,
                selectionRange: selectionRange
            };
            if (children !== undefined) {
                result.children = children;
            }
            return result;
        }
        DocumentSymbol.create = create;
        /**
         * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
         */
        function is(value) {
            var candidate = value;
            return candidate &&
                Is.string(candidate.name) && Is.number(candidate.kind) &&
                Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
                (candidate.detail === undefined || Is.string(candidate.detail)) &&
                (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
                (candidate.children === undefined || Array.isArray(candidate.children)) &&
                (candidate.tags === undefined || Array.isArray(candidate.tags));
        }
        DocumentSymbol.is = is;
    })(DocumentSymbol || (exports.DocumentSymbol = DocumentSymbol = {}));
    /**
     * A set of predefined code action kinds
     */
    var CodeActionKind;
    (function (CodeActionKind) {
        /**
         * Empty kind.
         */
        CodeActionKind.Empty = '';
        /**
         * Base kind for quickfix actions: 'quickfix'
         */
        CodeActionKind.QuickFix = 'quickfix';
        /**
         * Base kind for refactoring actions: 'refactor'
         */
        CodeActionKind.Refactor = 'refactor';
        /**
         * Base kind for refactoring extraction actions: 'refactor.extract'
         *
         * Example extract actions:
         *
         * - Extract method
         * - Extract function
         * - Extract variable
         * - Extract interface from class
         * - ...
         */
        CodeActionKind.RefactorExtract = 'refactor.extract';
        /**
         * Base kind for refactoring inline actions: 'refactor.inline'
         *
         * Example inline actions:
         *
         * - Inline function
         * - Inline variable
         * - Inline constant
         * - ...
         */
        CodeActionKind.RefactorInline = 'refactor.inline';
        /**
         * Base kind for refactoring rewrite actions: 'refactor.rewrite'
         *
         * Example rewrite actions:
         *
         * - Convert JavaScript function to class
         * - Add or remove parameter
         * - Encapsulate field
         * - Make method static
         * - Move method to base class
         * - ...
         */
        CodeActionKind.RefactorRewrite = 'refactor.rewrite';
        /**
         * Base kind for source actions: `source`
         *
         * Source code actions apply to the entire file.
         */
        CodeActionKind.Source = 'source';
        /**
         * Base kind for an organize imports source action: `source.organizeImports`
         */
        CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
        /**
         * Base kind for auto-fix source actions: `source.fixAll`.
         *
         * Fix all actions automatically fix errors that have a clear fix that do not require user input.
         * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
         *
         * @since 3.15.0
         */
        CodeActionKind.SourceFixAll = 'source.fixAll';
    })(CodeActionKind || (exports.CodeActionKind = CodeActionKind = {}));
    /**
     * The reason why code actions were requested.
     *
     * @since 3.17.0
     */
    var CodeActionTriggerKind;
    (function (CodeActionTriggerKind) {
        /**
         * Code actions were explicitly requested by the user or by an extension.
         */
        CodeActionTriggerKind.Invoked = 1;
        /**
         * Code actions were requested automatically.
         *
         * This typically happens when current selection in a file changes, but can
         * also be triggered when file content changes.
         */
        CodeActionTriggerKind.Automatic = 2;
    })(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));
    /**
     * The CodeActionContext namespace provides helper functions to work with
     * {@link CodeActionContext} literals.
     */
    var CodeActionContext;
    (function (CodeActionContext) {
        /**
         * Creates a new CodeActionContext literal.
         */
        function create(diagnostics, only, triggerKind) {
            var result = { diagnostics: diagnostics };
            if (only !== undefined && only !== null) {
                result.only = only;
            }
            if (triggerKind !== undefined && triggerKind !== null) {
                result.triggerKind = triggerKind;
            }
            return result;
        }
        CodeActionContext.create = create;
        /**
         * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)
                && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))
                && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext.is = is;
    })(CodeActionContext || (exports.CodeActionContext = CodeActionContext = {}));
    var CodeAction;
    (function (CodeAction) {
        function create(title, kindOrCommandOrEdit, kind) {
            var result = { title: title };
            var checkKind = true;
            if (typeof kindOrCommandOrEdit === 'string') {
                checkKind = false;
                result.kind = kindOrCommandOrEdit;
            }
            else if (Command.is(kindOrCommandOrEdit)) {
                result.command = kindOrCommandOrEdit;
            }
            else {
                result.edit = kindOrCommandOrEdit;
            }
            if (checkKind && kind !== undefined) {
                result.kind = kind;
            }
            return result;
        }
        CodeAction.create = create;
        function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.title) &&
                (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
                (candidate.kind === undefined || Is.string(candidate.kind)) &&
                (candidate.edit !== undefined || candidate.command !== undefined) &&
                (candidate.command === undefined || Command.is(candidate.command)) &&
                (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
                (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction.is = is;
    })(CodeAction || (exports.CodeAction = CodeAction = {}));
    /**
     * The CodeLens namespace provides helper functions to work with
     * {@link CodeLens} literals.
     */
    var CodeLens;
    (function (CodeLens) {
        /**
         * Creates a new CodeLens literal.
         */
        function create(range, data) {
            var result = { range: range };
            if (Is.defined(data)) {
                result.data = data;
            }
            return result;
        }
        CodeLens.create = create;
        /**
         * Checks whether the given literal conforms to the {@link CodeLens} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens.is = is;
    })(CodeLens || (exports.CodeLens = CodeLens = {}));
    /**
     * The FormattingOptions namespace provides helper functions to work with
     * {@link FormattingOptions} literals.
     */
    var FormattingOptions;
    (function (FormattingOptions) {
        /**
         * Creates a new FormattingOptions literal.
         */
        function create(tabSize, insertSpaces) {
            return { tabSize: tabSize, insertSpaces: insertSpaces };
        }
        FormattingOptions.create = create;
        /**
         * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions.is = is;
    })(FormattingOptions || (exports.FormattingOptions = FormattingOptions = {}));
    /**
     * The DocumentLink namespace provides helper functions to work with
     * {@link DocumentLink} literals.
     */
    var DocumentLink;
    (function (DocumentLink) {
        /**
         * Creates a new DocumentLink literal.
         */
        function create(range, target, data) {
            return { range: range, target: target, data: data };
        }
        DocumentLink.create = create;
        /**
         * Checks whether the given literal conforms to the {@link DocumentLink} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink.is = is;
    })(DocumentLink || (exports.DocumentLink = DocumentLink = {}));
    /**
     * The SelectionRange namespace provides helper function to work with
     * SelectionRange literals.
     */
    var SelectionRange;
    (function (SelectionRange) {
        /**
         * Creates a new SelectionRange
         * @param range the range.
         * @param parent an optional parent.
         */
        function create(range, parent) {
            return { range: range, parent: parent };
        }
        SelectionRange.create = create;
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
        }
        SelectionRange.is = is;
    })(SelectionRange || (exports.SelectionRange = SelectionRange = {}));
    /**
     * A set of predefined token types. This set is not fixed
     * an clients can specify additional token types via the
     * corresponding client capabilities.
     *
     * @since 3.16.0
     */
    var SemanticTokenTypes;
    (function (SemanticTokenTypes) {
        SemanticTokenTypes["namespace"] = "namespace";
        /**
         * Represents a generic type. Acts as a fallback for types which can't be mapped to
         * a specific type like class or enum.
         */
        SemanticTokenTypes["type"] = "type";
        SemanticTokenTypes["class"] = "class";
        SemanticTokenTypes["enum"] = "enum";
        SemanticTokenTypes["interface"] = "interface";
        SemanticTokenTypes["struct"] = "struct";
        SemanticTokenTypes["typeParameter"] = "typeParameter";
        SemanticTokenTypes["parameter"] = "parameter";
        SemanticTokenTypes["variable"] = "variable";
        SemanticTokenTypes["property"] = "property";
        SemanticTokenTypes["enumMember"] = "enumMember";
        SemanticTokenTypes["event"] = "event";
        SemanticTokenTypes["function"] = "function";
        SemanticTokenTypes["method"] = "method";
        SemanticTokenTypes["macro"] = "macro";
        SemanticTokenTypes["keyword"] = "keyword";
        SemanticTokenTypes["modifier"] = "modifier";
        SemanticTokenTypes["comment"] = "comment";
        SemanticTokenTypes["string"] = "string";
        SemanticTokenTypes["number"] = "number";
        SemanticTokenTypes["regexp"] = "regexp";
        SemanticTokenTypes["operator"] = "operator";
        /**
         * @since 3.17.0
         */
        SemanticTokenTypes["decorator"] = "decorator";
    })(SemanticTokenTypes || (exports.SemanticTokenTypes = SemanticTokenTypes = {}));
    /**
     * A set of predefined token modifiers. This set is not fixed
     * an clients can specify additional token types via the
     * corresponding client capabilities.
     *
     * @since 3.16.0
     */
    var SemanticTokenModifiers;
    (function (SemanticTokenModifiers) {
        SemanticTokenModifiers["declaration"] = "declaration";
        SemanticTokenModifiers["definition"] = "definition";
        SemanticTokenModifiers["readonly"] = "readonly";
        SemanticTokenModifiers["static"] = "static";
        SemanticTokenModifiers["deprecated"] = "deprecated";
        SemanticTokenModifiers["abstract"] = "abstract";
        SemanticTokenModifiers["async"] = "async";
        SemanticTokenModifiers["modification"] = "modification";
        SemanticTokenModifiers["documentation"] = "documentation";
        SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers || (exports.SemanticTokenModifiers = SemanticTokenModifiers = {}));
    /**
     * @since 3.16.0
     */
    var SemanticTokens;
    (function (SemanticTokens) {
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
                Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
        }
        SemanticTokens.is = is;
    })(SemanticTokens || (exports.SemanticTokens = SemanticTokens = {}));
    /**
     * The InlineValueText namespace provides functions to deal with InlineValueTexts.
     *
     * @since 3.17.0
     */
    var InlineValueText;
    (function (InlineValueText) {
        /**
         * Creates a new InlineValueText literal.
         */
        function create(range, text) {
            return { range: range, text: text };
        }
        InlineValueText.create = create;
        function is(value) {
            var candidate = value;
            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText.is = is;
    })(InlineValueText || (exports.InlineValueText = InlineValueText = {}));
    /**
     * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
     *
     * @since 3.17.0
     */
    var InlineValueVariableLookup;
    (function (InlineValueVariableLookup) {
        /**
         * Creates a new InlineValueText literal.
         */
        function create(range, variableName, caseSensitiveLookup) {
            return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };
        }
        InlineValueVariableLookup.create = create;
        function is(value) {
            var candidate = value;
            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)
                && (Is.string(candidate.variableName) || candidate.variableName === undefined);
        }
        InlineValueVariableLookup.is = is;
    })(InlineValueVariableLookup || (exports.InlineValueVariableLookup = InlineValueVariableLookup = {}));
    /**
     * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
     *
     * @since 3.17.0
     */
    var InlineValueEvaluatableExpression;
    (function (InlineValueEvaluatableExpression) {
        /**
         * Creates a new InlineValueEvaluatableExpression literal.
         */
        function create(range, expression) {
            return { range: range, expression: expression };
        }
        InlineValueEvaluatableExpression.create = create;
        function is(value) {
            var candidate = value;
            return candidate !== undefined && candidate !== null && Range.is(candidate.range)
                && (Is.string(candidate.expression) || candidate.expression === undefined);
        }
        InlineValueEvaluatableExpression.is = is;
    })(InlineValueEvaluatableExpression || (exports.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
    /**
     * The InlineValueContext namespace provides helper functions to work with
     * {@link InlineValueContext} literals.
     *
     * @since 3.17.0
     */
    var InlineValueContext;
    (function (InlineValueContext) {
        /**
         * Creates a new InlineValueContext literal.
         */
        function create(frameId, stoppedLocation) {
            return { frameId: frameId, stoppedLocation: stoppedLocation };
        }
        InlineValueContext.create = create;
        /**
         * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext.is = is;
    })(InlineValueContext || (exports.InlineValueContext = InlineValueContext = {}));
    /**
     * Inlay hint kinds.
     *
     * @since 3.17.0
     */
    var InlayHintKind;
    (function (InlayHintKind) {
        /**
         * An inlay hint that for a type annotation.
         */
        InlayHintKind.Type = 1;
        /**
         * An inlay hint that is for a parameter.
         */
        InlayHintKind.Parameter = 2;
        function is(value) {
            return value === 1 || value === 2;
        }
        InlayHintKind.is = is;
    })(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));
    var InlayHintLabelPart;
    (function (InlayHintLabelPart) {
        function create(value) {
            return { value: value };
        }
        InlayHintLabelPart.create = create;
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate)
                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
                && (candidate.location === undefined || Location.is(candidate.location))
                && (candidate.command === undefined || Command.is(candidate.command));
        }
        InlayHintLabelPart.is = is;
    })(InlayHintLabelPart || (exports.InlayHintLabelPart = InlayHintLabelPart = {}));
    var InlayHint;
    (function (InlayHint) {
        function create(position, label, kind) {
            var result = { position: position, label: label };
            if (kind !== undefined) {
                result.kind = kind;
            }
            return result;
        }
        InlayHint.create = create;
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position.is(candidate.position)
                && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))
                && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))
                && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)
                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
                && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))
                && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
        }
        InlayHint.is = is;
    })(InlayHint || (exports.InlayHint = InlayHint = {}));
    var StringValue;
    (function (StringValue) {
        function createSnippet(value) {
            return { kind: 'snippet', value: value };
        }
        StringValue.createSnippet = createSnippet;
    })(StringValue || (exports.StringValue = StringValue = {}));
    var InlineCompletionItem;
    (function (InlineCompletionItem) {
        function create(insertText, filterText, range, command) {
            return { insertText: insertText, filterText: filterText, range: range, command: command };
        }
        InlineCompletionItem.create = create;
    })(InlineCompletionItem || (exports.InlineCompletionItem = InlineCompletionItem = {}));
    var InlineCompletionList;
    (function (InlineCompletionList) {
        function create(items) {
            return { items: items };
        }
        InlineCompletionList.create = create;
    })(InlineCompletionList || (exports.InlineCompletionList = InlineCompletionList = {}));
    /**
     * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
     *
     * @since 3.18.0
     * @proposed
     */
    var InlineCompletionTriggerKind;
    (function (InlineCompletionTriggerKind) {
        /**
         * Completion was triggered explicitly by a user gesture.
         */
        InlineCompletionTriggerKind.Invoked = 0;
        /**
         * Completion was triggered automatically while editing.
         */
        InlineCompletionTriggerKind.Automatic = 1;
    })(InlineCompletionTriggerKind || (exports.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
    var SelectedCompletionInfo;
    (function (SelectedCompletionInfo) {
        function create(range, text) {
            return { range: range, text: text };
        }
        SelectedCompletionInfo.create = create;
    })(SelectedCompletionInfo || (exports.SelectedCompletionInfo = SelectedCompletionInfo = {}));
    var InlineCompletionContext;
    (function (InlineCompletionContext) {
        function create(triggerKind, selectedCompletionInfo) {
            return { triggerKind: triggerKind, selectedCompletionInfo: selectedCompletionInfo };
        }
        InlineCompletionContext.create = create;
    })(InlineCompletionContext || (exports.InlineCompletionContext = InlineCompletionContext = {}));
    var WorkspaceFolder;
    (function (WorkspaceFolder) {
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder.is = is;
    })(WorkspaceFolder || (exports.WorkspaceFolder = WorkspaceFolder = {}));
    exports.EOL = ['\n', '\r\n', '\r'];
    /**
     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
     */
    var TextDocument;
    (function (TextDocument) {
        /**
         * Creates a new ITextDocument literal from the given uri and content.
         * @param uri The document's uri.
         * @param languageId The document's language Id.
         * @param version The document's version.
         * @param content The document's content.
         */
        function create(uri, languageId, version, content) {
            return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument.create = create;
        /**
         * Checks whether the given literal conforms to the {@link ITextDocument} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
                && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument.is = is;
        function applyEdits(document, edits) {
            var text = document.getText();
            var sortedEdits = mergeSort(edits, function (a, b) {
                var diff = a.range.start.line - b.range.start.line;
                if (diff === 0) {
                    return a.range.start.character - b.range.start.character;
                }
                return diff;
            });
            var lastModifiedOffset = text.length;
            for (var i = sortedEdits.length - 1; i >= 0; i--) {
                var e = sortedEdits[i];
                var startOffset = document.offsetAt(e.range.start);
                var endOffset = document.offsetAt(e.range.end);
                if (endOffset <= lastModifiedOffset) {
                    text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                }
                else {
                    throw new Error('Overlapping edit');
                }
                lastModifiedOffset = startOffset;
            }
            return text;
        }
        TextDocument.applyEdits = applyEdits;
        function mergeSort(data, compare) {
            if (data.length <= 1) {
                // sorted
                return data;
            }
            var p = (data.length / 2) | 0;
            var left = data.slice(0, p);
            var right = data.slice(p);
            mergeSort(left, compare);
            mergeSort(right, compare);
            var leftIdx = 0;
            var rightIdx = 0;
            var i = 0;
            while (leftIdx < left.length && rightIdx < right.length) {
                var ret = compare(left[leftIdx], right[rightIdx]);
                if (ret <= 0) {
                    // smaller_equal -> take left to preserve order
                    data[i++] = left[leftIdx++];
                }
                else {
                    // greater -> take right
                    data[i++] = right[rightIdx++];
                }
            }
            while (leftIdx < left.length) {
                data[i++] = left[leftIdx++];
            }
            while (rightIdx < right.length) {
                data[i++] = right[rightIdx++];
            }
            return data;
        }
    })(TextDocument || (exports.TextDocument = TextDocument = {}));
    /**
     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
     */
    var FullTextDocument = /** @class */ (function () {
        function FullTextDocument(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = undefined;
        }
        Object.defineProperty(FullTextDocument.prototype, "uri", {
            get: function () {
                return this._uri;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FullTextDocument.prototype, "languageId", {
            get: function () {
                return this._languageId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FullTextDocument.prototype, "version", {
            get: function () {
                return this._version;
            },
            enumerable: false,
            configurable: true
        });
        FullTextDocument.prototype.getText = function (range) {
            if (range) {
                var start = this.offsetAt(range.start);
                var end = this.offsetAt(range.end);
                return this._content.substring(start, end);
            }
            return this._content;
        };
        FullTextDocument.prototype.update = function (event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = undefined;
        };
        FullTextDocument.prototype.getLineOffsets = function () {
            if (this._lineOffsets === undefined) {
                var lineOffsets = [];
                var text = this._content;
                var isLineStart = true;
                for (var i = 0; i < text.length; i++) {
                    if (isLineStart) {
                        lineOffsets.push(i);
                        isLineStart = false;
                    }
                    var ch = text.charAt(i);
                    isLineStart = (ch === '\r' || ch === '\n');
                    if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                        i++;
                    }
                }
                if (isLineStart && text.length > 0) {
                    lineOffsets.push(text.length);
                }
                this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
        };
        FullTextDocument.prototype.positionAt = function (offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
                return Position.create(0, offset);
            }
            while (low < high) {
                var mid = Math.floor((low + high) / 2);
                if (lineOffsets[mid] > offset) {
                    high = mid;
                }
                else {
                    low = mid + 1;
                }
            }
            // low is the least x for which the line offset is larger than the current offset
            // or array.length if no line offset is larger than the current offset
            var line = low - 1;
            return Position.create(line, offset - lineOffsets[line]);
        };
        FullTextDocument.prototype.offsetAt = function (position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
                return this._content.length;
            }
            else if (position.line < 0) {
                return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        };
        Object.defineProperty(FullTextDocument.prototype, "lineCount", {
            get: function () {
                return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
        });
        return FullTextDocument;
    }());
    var Is;
    (function (Is) {
        var toString = Object.prototype.toString;
        function defined(value) {
            return typeof value !== 'undefined';
        }
        Is.defined = defined;
        function undefined(value) {
            return typeof value === 'undefined';
        }
        Is.undefined = undefined;
        function boolean(value) {
            return value === true || value === false;
        }
        Is.boolean = boolean;
        function string(value) {
            return toString.call(value) === '[object String]';
        }
        Is.string = string;
        function number(value) {
            return toString.call(value) === '[object Number]';
        }
        Is.number = number;
        function numberRange(value, min, max) {
            return toString.call(value) === '[object Number]' && min <= value && value <= max;
        }
        Is.numberRange = numberRange;
        function integer(value) {
            return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
        }
        Is.integer = integer;
        function uinteger(value) {
            return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
        }
        Is.uinteger = uinteger;
        function func(value) {
            return toString.call(value) === '[object Function]';
        }
        Is.func = func;
        function objectLiteral(value) {
            // Strictly speaking class instances pass this check as well. Since the LSP
            // doesn't use classes we ignore this for now. If we do we need to add something
            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
            return value !== null && typeof value === 'object';
        }
        Is.objectLiteral = objectLiteral;
        function typedArray(value, check) {
            return Array.isArray(value) && value.every(check);
        }
        Is.typedArray = typedArray;
    })(Is || (Is = {}));
});


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/callHierarchy.proposed.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/callHierarchy.proposed.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js");
exports.CallHierarchyFeature = (Base) => {
    return class extends Base {
        get callHierarchy() {
            return {
                onPrepare: (handler) => {
                    this.connection.onRequest(vscode_languageserver_protocol_1.Proposed.CallHierarchyPrepareRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
                    });
                },
                onIncomingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1.Proposed.CallHierarchyIncomingCallsRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onOutgoingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1.Proposed.CallHierarchyOutgoingCallsRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
//# sourceMappingURL=callHierarchy.proposed.js.map

/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/configuration.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/configuration.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/utils/is.js");
exports.ConfigurationFeature = (Base) => {
    return class extends Base {
        getConfiguration(arg) {
            if (!arg) {
                return this._getConfiguration({});
            }
            else if (Is.string(arg)) {
                return this._getConfiguration({ section: arg });
            }
            else {
                return this._getConfiguration(arg);
            }
        }
        _getConfiguration(arg) {
            let params = {
                items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
                return Array.isArray(arg) ? result : result[0];
            });
        }
    };
};
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/files.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/files.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const url = __webpack_require__(/*! url */ "url");
const path = __webpack_require__(/*! path */ "path");
const fs = __webpack_require__(/*! fs */ "fs");
const child_process_1 = __webpack_require__(/*! child_process */ "child_process");
/**
 * @deprecated Use the `vscode-uri` npm module which provides a more
 * complete implementation of handling VS Code URIs.
 */
function uriToFilePath(uri) {
    let parsed = url.parse(uri);
    if (parsed.protocol !== 'file:' || !parsed.path) {
        return undefined;
    }
    let segments = parsed.path.split('/');
    for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
    }
    if (process.platform === 'win32' && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        // Do we have a drive letter and we started with a / which is the
        // case if the first segement is empty (see split above)
        if (first.length === 0 && second.length > 1 && second[1] === ':') {
            // Remove first slash
            segments.shift();
        }
    }
    return path.normalize(segments.join('/'));
}
exports.uriToFilePath = uriToFilePath;
function isWindows() {
    return process.platform === 'win32';
}
function resolve(moduleName, nodePath, cwd, tracer) {
    const nodePathKey = 'NODE_PATH';
    const app = [
        'var p = process;',
        'p.on(\'message\',function(m){',
        'if(m.c===\'e\'){',
        'p.exit(0);',
        '}',
        'else if(m.c===\'rs\'){',
        'try{',
        'var r=require.resolve(m.a);',
        'p.send({c:\'r\',s:true,r:r});',
        '}',
        'catch(err){',
        'p.send({c:\'r\',s:false});',
        '}',
        '}',
        '});'
    ].join('');
    return new Promise((resolve, reject) => {
        let env = process.env;
        let newEnv = Object.create(null);
        Object.keys(env).forEach(key => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath) /* see issue 545 */) {
            if (newEnv[nodePathKey]) {
                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
            }
            else {
                newEnv[nodePathKey] = nodePath;
            }
            if (tracer) {
                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
            }
        }
        newEnv['ELECTRON_RUN_AS_NODE'] = '1';
        try {
            let cp = child_process_1.fork('', [], {
                cwd: cwd,
                env: newEnv,
                execArgv: ['-e', app]
            });
            if (cp.pid === void 0) {
                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
                return;
            }
            cp.on('error', (error) => {
                reject(error);
            });
            cp.on('message', (message) => {
                if (message.c === 'r') {
                    cp.send({ c: 'e' });
                    if (message.s) {
                        resolve(message.r);
                    }
                    else {
                        reject(new Error(`Failed to resolve module: ${moduleName}`));
                    }
                }
            });
            let message = {
                c: 'rs',
                a: moduleName
            };
            cp.send(message);
        }
        catch (error) {
            reject(error);
        }
    });
}
exports.resolve = resolve;
/**
 * Resolve the global npm package path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalNodePath(tracer) {
    let npmCommand = 'npm';
    const env = Object.create(null);
    Object.keys(process.env).forEach(key => env[key] = process.env[key]);
    env['NO_UPDATE_NOTIFIER'] = 'true';
    const options = {
        encoding: 'utf8',
        env
    };
    if (isWindows()) {
        npmCommand = 'npm.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let stdout = child_process_1.spawnSync(npmCommand, ['config', 'get', 'prefix'], options).stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'npm config get prefix' didn't return a value.`);
            }
            return undefined;
        }
        let prefix = stdout.trim();
        if (tracer) {
            tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
            if (isWindows()) {
                return path.join(prefix, 'node_modules');
            }
            else {
                return path.join(prefix, 'lib', 'node_modules');
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalNodePath = resolveGlobalNodePath;
/*
 * Resolve the global yarn pakage path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalYarnPath(tracer) {
    let yarnCommand = 'yarn';
    let options = {
        encoding: 'utf8'
    };
    if (isWindows()) {
        yarnCommand = 'yarn.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let results = child_process_1.spawnSync(yarnCommand, ['global', 'dir', '--json'], options);
        let stdout = results.stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'yarn global dir' didn't return a value.`);
                if (results.stderr) {
                    tracer(results.stderr);
                }
            }
            return undefined;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
            try {
                let yarn = JSON.parse(line);
                if (yarn.type === 'log') {
                    return path.join(yarn.data, 'node_modules');
                }
            }
            catch (e) {
                // Do nothing. Ignore the line
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
var FileSystem;
(function (FileSystem) {
    let _isCaseSensitive = undefined;
    function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
            return _isCaseSensitive;
        }
        if (process.platform === 'win32') {
            _isCaseSensitive = false;
        }
        else {
            // convert current file name to upper case / lower case and check if file exists
            // (guards against cases when name is already all uppercase or lowercase)
            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
    }
    FileSystem.isCaseSensitive = isCaseSensitive;
    function isParent(parent, child) {
        if (isCaseSensitive()) {
            return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        }
        else {
            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
    }
    FileSystem.isParent = isParent;
})(FileSystem = exports.FileSystem || (exports.FileSystem = {}));
function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
    if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
            nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
            if (FileSystem.isParent(nodePath, value)) {
                return value;
            }
            else {
                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
            }
        }).then(undefined, (_error) => {
            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
    }
    else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
    }
}
exports.resolveModulePath = resolveModulePath;
//# sourceMappingURL=files.js.map

/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/main.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/main.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../typings/thenable.d.ts" />

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js");
exports.Event = vscode_languageserver_protocol_1.Event;
const configuration_1 = __webpack_require__(/*! ./configuration */ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/configuration.js");
const workspaceFolders_1 = __webpack_require__(/*! ./workspaceFolders */ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/workspaceFolders.js");
const progress_1 = __webpack_require__(/*! ./progress */ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/progress.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/utils/is.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/utils/uuid.js");
// ------------- Reexport the API surface of the language worker API ----------------------
__export(__webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js"));
const fm = __webpack_require__(/*! ./files */ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/files.js");
var Files;
(function (Files) {
    Files.uriToFilePath = fm.uriToFilePath;
    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;
    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
    Files.resolve = fm.resolve;
    Files.resolveModulePath = fm.resolveModulePath;
})(Files = exports.Files || (exports.Files = {}));
let shutdownReceived = false;
let exitTimer = undefined;
function setupExitTimer() {
    const argName = '--clientProcessId';
    function runTimer(value) {
        try {
            let processId = parseInt(value);
            if (!isNaN(processId)) {
                exitTimer = setInterval(() => {
                    try {
                        process.kill(processId, 0);
                    }
                    catch (ex) {
                        // Parent process doesn't exist anymore. Exit the server.
                        process.exit(shutdownReceived ? 0 : 1);
                    }
                }, 3000);
            }
        }
        catch (e) {
            // Ignore errors;
        }
    }
    for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
            runTimer(process.argv[i + 1]);
            return;
        }
        else {
            let args = arg.split('=');
            if (args[0] === argName) {
                runTimer(args[1]);
            }
        }
    }
}
setupExitTimer();
function null2Undefined(value) {
    if (value === null) {
        return void 0;
    }
    return value;
}
/**
 * A manager for simple text documents
 */
class TextDocuments {
    /**
     * Create a new text document manager.
     */
    constructor(configuration) {
        this._documents = Object.create(null);
        this._configuration = configuration;
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    get onDidChangeContent() {
        return this._onDidChangeContent.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    get onDidOpen() {
        return this._onDidOpen.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    get onWillSave() {
        return this._onWillSave.event;
    }
    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    get onDidSave() {
        return this._onDidSave.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    get onDidClose() {
        return this._onDidClose.event;
    }
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not mananged by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    get(uri) {
        return this._documents[uri];
    }
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    all() {
        return Object.keys(this._documents).map(key => this._documents[key]);
    }
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    keys() {
        return Object.keys(this._documents);
    }
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * @param connection The connection to listen on.
     */
    listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        connection.onDidOpenTextDocument((event) => {
            let td = event.textDocument;
            let document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
            this._documents[td.uri] = document;
            let toFire = Object.freeze({ document });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
        });
        connection.onDidChangeTextDocument((event) => {
            let td = event.textDocument;
            let changes = event.contentChanges;
            if (changes.length === 0) {
                return;
            }
            let document = this._documents[td.uri];
            const { version } = td;
            if (version === null || version === void 0) {
                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
            }
            document = this._configuration.update(document, changes, version);
            this._documents[td.uri] = document;
            this._onDidChangeContent.fire(Object.freeze({ document }));
        });
        connection.onDidCloseTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                delete this._documents[event.textDocument.uri];
                this._onDidClose.fire(Object.freeze({ document }));
            }
        });
        connection.onWillSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));
            }
        });
        connection.onWillSaveTextDocumentWaitUntil((event, token) => {
            let document = this._documents[event.textDocument.uri];
            if (document && this._willSaveWaitUntil) {
                return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);
            }
            else {
                return [];
            }
        });
        connection.onDidSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onDidSave.fire(Object.freeze({ document }));
            }
        });
    }
}
exports.TextDocuments = TextDocuments;
/**
 * Helps tracking error message. Equal occurences of the same
 * message are only stored once. This class is for example
 * useful if text documents are validated in a loop and equal
 * error message should be folded into one.
 */
class ErrorMessageTracker {
    constructor() {
        this._messages = Object.create(null);
    }
    /**
     * Add a message to the tracker.
     *
     * @param message The message to add.
     */
    add(message) {
        let count = this._messages[message];
        if (!count) {
            count = 0;
        }
        count++;
        this._messages[message] = count;
    }
    /**
     * Send all tracked messages to the connection's window.
     *
     * @param connection The connection established between client and server.
     */
    sendErrors(connection) {
        Object.keys(this._messages).forEach(message => {
            connection.window.showErrorMessage(message);
        });
    }
}
exports.ErrorMessageTracker = ErrorMessageTracker;
class RemoteConsoleImpl {
    constructor() {
    }
    rawAttach(connection) {
        this._rawConnection = connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    fillServerCapabilities(_capabilities) {
    }
    initialize(_capabilities) {
    }
    error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
    }
    warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
    }
    info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
    }
    log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
    }
    send(type, message) {
        if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message });
        }
    }
}
class _RemoteWindowImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
}
const RemoteWindowImpl = progress_1.ProgressFeature(_RemoteWindowImpl);
var BulkRegistration;
(function (BulkRegistration) {
    /**
     * Creates a new bulk registration.
     * @return an empty bulk registration.
     */
    function create() {
        return new BulkRegistrationImpl();
    }
    BulkRegistration.create = create;
})(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));
class BulkRegistrationImpl {
    constructor() {
        this._registrations = [];
        this._registered = new Set();
    }
    add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
            id: id,
            method: method,
            registerOptions: registerOptions || {}
        });
        this._registered.add(method);
    }
    asRegistrationParams() {
        return {
            registrations: this._registrations
        };
    }
}
var BulkUnregistration;
(function (BulkUnregistration) {
    function create() {
        return new BulkUnregistrationImpl(undefined, []);
    }
    BulkUnregistration.create = create;
})(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));
class BulkUnregistrationImpl {
    constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = new Map();
        unregistrations.forEach(unregistration => {
            this._unregistrations.set(unregistration.method, unregistration);
        });
    }
    get isAttached() {
        return !!this._connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
    }
    dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
        }
        let params = {
            unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this._connection.console.info(`Bulk unregistration failed.`);
        });
    }
    disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
            return false;
        }
        let params = {
            unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
        }, (_error) => {
            this._connection.console.info(`Unregistering request handler for ${unregistration.id} failed.`);
        });
        return true;
    }
}
class RemoteClientImpl {
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
        }
        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        }
        else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
    }
    registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
            unregistration.attach(this._connection);
        }
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id: id, method: method });
            return unregistration;
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
                this.unregisterSingle(id, method);
            });
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    unregisterSingle(id, method) {
        let params = {
            unregisterations: [{ id, method }]
        };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this.connection.console.info(`Unregistering request handler for ${id} failed.`);
        });
    }
    registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));
        }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
        });
    }
}
class _RemoteWorkspaceImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
    }
}
const RemoteWorkspaceImpl = workspaceFolders_1.WorkspaceFoldersFeature(configuration_1.ConfigurationFeature(_RemoteWorkspaceImpl));
class TelemetryImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    logEvent(data) {
        this._connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);
    }
}
class TracerImpl {
    constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    set trace(value) {
        this._trace = value;
    }
    log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
        }
        this._connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message: message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
        });
    }
}
class LanguagesImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    attachWorkDoneProgress(params) {
        return progress_1.attachWorkDone(this.connection, params);
    }
    attachPartialResultProgress(_type, params) {
        return progress_1.attachPartialResult(this.connection, params);
    }
}
exports.LanguagesImpl = LanguagesImpl;
function combineConsoleFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineConsoleFeatures = combineConsoleFeatures;
function combineTelemetryFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTelemetryFeatures = combineTelemetryFeatures;
function combineTracerFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTracerFeatures = combineTracerFeatures;
function combineClientFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineClientFeatures = combineClientFeatures;
function combineWindowFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWindowFeatures = combineWindowFeatures;
function combineWorkspaceFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
function combineLanguagesFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineLanguagesFeatures = combineLanguagesFeatures;
function combineFeatures(one, two) {
    function combine(one, two, func) {
        if (one && two) {
            return func(one, two);
        }
        else if (one) {
            return one;
        }
        else {
            return two;
        }
    }
    let result = {
        __brand: 'features',
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)
    };
    return result;
}
exports.combineFeatures = combineFeatures;
function createConnection(arg1, arg2, arg3, arg4) {
    let factories;
    let input;
    let output;
    let strategy;
    if (arg1 !== void 0 && arg1.__brand === 'features') {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
    }
    if (vscode_languageserver_protocol_1.ConnectionStrategy.is(arg1)) {
        strategy = arg1;
    }
    else {
        input = arg1;
        output = arg2;
        strategy = arg3;
    }
    return _createConnection(input, output, strategy, factories);
}
exports.createConnection = createConnection;
function _createConnection(input, output, strategy, factories) {
    if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
            let arg = argv[i];
            if (arg === '--node-ipc') {
                input = new vscode_languageserver_protocol_1.IPCMessageReader(process);
                output = new vscode_languageserver_protocol_1.IPCMessageWriter(process);
                break;
            }
            else if (arg === '--stdio') {
                input = process.stdin;
                output = process.stdout;
                break;
            }
            else if (arg === '--socket') {
                port = parseInt(argv[i + 1]);
                break;
            }
            else if (arg === '--pipe') {
                pipeName = argv[i + 1];
                break;
            }
            else {
                var args = arg.split('=');
                if (args[0] === '--socket') {
                    port = parseInt(args[1]);
                    break;
                }
                else if (args[0] === '--pipe') {
                    pipeName = args[1];
                    break;
                }
            }
        }
        if (port) {
            let transport = vscode_languageserver_protocol_1.createServerSocketTransport(port);
            input = transport[0];
            output = transport[1];
        }
        else if (pipeName) {
            let transport = vscode_languageserver_protocol_1.createServerPipeTransport(pipeName);
            input = transport[0];
            output = transport[1];
        }
    }
    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \'--node-ipc\', \'--stdio\' or \'--socket={number}\'';
    if (!input) {
        throw new Error('Connection input stream is not set. ' + commandLineMessage);
    }
    if (!output) {
        throw new Error('Connection output stream is not set. ' + commandLineMessage);
    }
    // Backwards compatibility
    if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on('end', () => {
            process.exit(shutdownReceived ? 0 : 1);
        });
        inputStream.on('close', () => {
            process.exit(shutdownReceived ? 0 : 1);
        });
    }
    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());
    const connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger, strategy);
    logger.rawAttach(connection);
    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());
    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());
    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());
    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());
    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());
    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());
    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages];
    function asPromise(value) {
        if (value instanceof Promise) {
            return value;
        }
        else if (Is.thenable(value)) {
            return new Promise((resolve, reject) => {
                value.then((resolved) => resolve(resolved), (error) => reject(error));
            });
        }
        else {
            return Promise.resolve(value);
        }
    }
    let shutdownHandler = undefined;
    let initializeHandler = undefined;
    let exitHandler = undefined;
    let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
            const method = Is.string(type) ? type : type.method;
            if (arguments.length === 1) {
                connection.sendNotification(method);
            }
            else {
                connection.sendNotification(method, param);
            }
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => initializeHandler = handler,
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => shutdownHandler = handler,
        onExit: (handler) => exitHandler = handler,
        get console() { return logger; },
        get telemetry() { return telemetry; },
        get tracer() { return tracer; },
        get client() { return client; },
        get window() { return remoteWindow; },
        get workspace() { return workspace; },
        get languages() { return languages; },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: undefined,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        dispose: () => connection.dispose()
    };
    for (let remote of allRemotes) {
        remote.attach(protocolConnection);
    }
    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
            // We received a parent process id. Set up a timer to periodically check
            // if the parent is still alive.
            setInterval(() => {
                try {
                    process.kill(processId, 0);
                }
                catch (ex) {
                    // Parent process doesn't exist anymore. Exit the server.
                    process.exit(shutdownReceived ? 0 : 1);
                }
            }, 3000);
        }
        if (Is.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, progress_1.attachWorkDone(connection, params), undefined);
            return asPromise(result).then((value) => {
                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                    return value;
                }
                let result = value;
                if (!result) {
                    result = { capabilities: {} };
                }
                let capabilities = result.capabilities;
                if (!capabilities) {
                    capabilities = {};
                    result.capabilities = capabilities;
                }
                if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                for (let remote of allRemotes) {
                    remote.fillServerCapabilities(capabilities);
                }
                return result;
            });
        }
        else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
                remote.fillServerCapabilities(result.capabilities);
            }
            return result;
        }
    });
    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        shutdownReceived = true;
        if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        }
        else {
            return undefined;
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
            if (exitHandler) {
                exitHandler();
            }
        }
        finally {
            if (shutdownReceived) {
                process.exit(0);
            }
            else {
                process.exit(1);
            }
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
    });
    return protocolConnection;
}
// Export the protocol currently in proposed state.
const callHierarchy_proposed_1 = __webpack_require__(/*! ./callHierarchy.proposed */ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/callHierarchy.proposed.js");
const st = __webpack_require__(/*! ./sematicTokens.proposed */ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/sematicTokens.proposed.js");
var ProposedFeatures;
(function (ProposedFeatures) {
    ProposedFeatures.all = {
        __brand: 'features',
        languages: combineLanguagesFeatures(callHierarchy_proposed_1.CallHierarchyFeature, st.SemanticTokensFeature)
    };
    ProposedFeatures.SemanticTokensBuilder = st.SemanticTokensBuilder;
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/progress.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/progress.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const uuid_1 = __webpack_require__(/*! ./utils/uuid */ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/utils/uuid.js");
class WorkDoneProgressImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressImpl.Instances.set(this._token, this);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    begin(title, percentage, message, cancellable) {
        let param = {
            kind: 'begin',
            title,
            percentage,
            message,
            cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    report(arg0, arg1) {
        let param = {
            kind: 'report'
        };
        if (typeof arg0 === 'number') {
            param.percentage = arg0;
            if (arg1 !== undefined) {
                param.message = arg1;
            }
        }
        else {
            param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    done() {
        WorkDoneProgressImpl.Instances.delete(this._token);
        this._source.dispose();
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: 'end' });
    }
    cancel() {
        this._source.cancel();
    }
}
WorkDoneProgressImpl.Instances = new Map();
class NullProgress {
    constructor() {
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    begin() {
    }
    report() {
    }
    done() {
    }
}
function attachWorkDone(connection, params) {
    if (params === undefined || params.workDoneToken === undefined) {
        return new NullProgress();
    }
    const token = params.workDoneToken;
    delete params.workDoneToken;
    return new WorkDoneProgressImpl(connection, token);
}
exports.attachWorkDone = attachWorkDone;
exports.ProgressFeature = (Base) => {
    return class extends Base {
        initialize(capabilities) {
            var _a;
            if (((_a = capabilities === null || capabilities === void 0 ? void 0 : capabilities.window) === null || _a === void 0 ? void 0 : _a.workDoneProgress) === true) {
                this._progressSupported = true;
                this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
                    let progress = WorkDoneProgressImpl.Instances.get(params.token);
                    if (progress !== undefined) {
                        progress.cancel();
                    }
                });
            }
        }
        attachWorkDoneProgress(token) {
            if (token === undefined) {
                return new NullProgress();
            }
            else {
                return new WorkDoneProgressImpl(this.connection, token);
            }
        }
        createWorkDoneProgress() {
            if (this._progressSupported) {
                const token = uuid_1.generateUuid();
                return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                    const result = new WorkDoneProgressImpl(this.connection, token);
                    return result;
                });
            }
            else {
                return Promise.resolve(new NullProgress());
            }
        }
    };
};
var ResultProgress;
(function (ResultProgress) {
    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();
})(ResultProgress || (ResultProgress = {}));
class ResultProgressImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
    }
    report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
    }
}
function attachPartialResult(connection, params) {
    if (params === undefined || params.partialResultToken === undefined) {
        return undefined;
    }
    const token = params.partialResultToken;
    delete params.partialResultToken;
    return new ResultProgressImpl(connection, token);
}
exports.attachPartialResult = attachPartialResult;
//# sourceMappingURL=progress.js.map

/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/sematicTokens.proposed.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/sematicTokens.proposed.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js");
exports.SemanticTokensFeature = (Base) => {
    return class extends Base {
        get semanticTokens() {
            return {
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1.Proposed.SemanticTokensRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onEdits: (handler) => {
                    const type = vscode_languageserver_protocol_1.Proposed.SemanticTokensEditsRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onRange: (handler) => {
                    const type = vscode_languageserver_protocol_1.Proposed.SemanticTokensRangeRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
class SemanticTokensBuilder {
    constructor() {
        this._prevData = undefined;
        this.initialize();
    }
    initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
    }
    push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
                pushChar -= this._prevChar;
            }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
    }
    get id() {
        return this._id.toString();
    }
    previousResult(id) {
        if (this.id === id) {
            this._prevData = this._data;
        }
        this.initialize();
    }
    build() {
        this._prevData = undefined;
        return {
            resultId: this.id,
            data: this._data
        };
    }
    canBuildEdits() {
        return this._prevData !== undefined;
    }
    buildEdits() {
        if (this._prevData !== undefined) {
            const prevDataLength = this._prevData.length;
            const dataLength = this._data.length;
            let startIndex = 0;
            while (startIndex < dataLength && startIndex < prevDataLength && this._prevData[startIndex] === this._data[startIndex]) {
                startIndex++;
            }
            if (startIndex < dataLength && startIndex < prevDataLength) {
                // Find end index
                let endIndex = 0;
                while (endIndex < dataLength && endIndex < prevDataLength && this._prevData[prevDataLength - 1 - endIndex] === this._data[dataLength - 1 - endIndex]) {
                    endIndex++;
                }
                const newData = this._data.slice(startIndex, dataLength - endIndex);
                const result = {
                    resultId: this.id,
                    edits: [
                        { start: startIndex, deleteCount: prevDataLength - endIndex - startIndex, data: newData }
                    ]
                };
                return result;
            }
            else if (startIndex < dataLength) {
                return { resultId: this.id, edits: [
                        { start: startIndex, deleteCount: 0, data: this._data.slice(startIndex) }
                    ] };
            }
            else if (startIndex < prevDataLength) {
                return { resultId: this.id, edits: [
                        { start: startIndex, deleteCount: prevDataLength - startIndex }
                    ] };
            }
            else {
                return { resultId: this.id, edits: [] };
            }
        }
        else {
            return this.build();
        }
    }
}
exports.SemanticTokensBuilder = SemanticTokensBuilder;
//# sourceMappingURL=sematicTokens.proposed.js.map

/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/utils/is.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/utils/is.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/utils/uuid.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/utils/uuid.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", ({ value: true }));
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/workspaceFolders.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver@6.1.1/node_modules/vscode-languageserver/lib/workspaceFolders.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js");
exports.WorkspaceFoldersFeature = (Base) => {
    return class extends Base {
        initialize(capabilities) {
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
                    this._onDidChangeWorkspaceFolders.fire(params.event);
                });
            }
        }
        getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
                throw new Error('Client doesn\'t support sending workspace folder change events.');
            }
            if (!this._unregistration) {
                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
        }
    };
};
//# sourceMappingURL=workspaceFolders.js.map

/***/ }),

/***/ "./node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/umd/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/umd/index.js ***!
  \**************************************************************************************/
/***/ (function(module) {

!function(t,e){if(true)module.exports=e();else { var n, r; }}(this,(()=>(()=>{"use strict";var t={470:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function r(t,e){for(var r,n="",i=0,o=-1,s=0,a=0;a<=t.length;++a){if(a<t.length)r=t.charCodeAt(a);else{if(47===r)break;r=47}if(47===r){if(o===a-1||1===s);else if(o!==a-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var h=n.lastIndexOf("/");if(h!==n.length-1){-1===h?(n="",i=0):i=(n=n.slice(0,h)).length-1-n.lastIndexOf("/"),o=a,s=0;continue}}else if(2===n.length||1===n.length){n="",i=0,o=a,s=0;continue}e&&(n.length>0?n+="/..":n="..",i=2)}else n.length>0?n+="/"+t.slice(o+1,a):n=t.slice(o+1,a),i=a-o-1;o=a,s=0}else 46===r&&-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n="",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+"/"+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(t){if(e(t),0===t.length)return".";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t="."),t.length>0&&i&&(t+="/"),n?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+="/"+i)}return void 0===t?".":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return"";if((t=n.resolve(t))===(r=n.resolve(r)))return"";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,a=1;a<r.length&&47===r.charCodeAt(a);++a);for(var h=r.length-a,c=s<h?s:h,f=-1,u=0;u<=c;++u){if(u===c){if(h>c){if(47===r.charCodeAt(a+u))return r.slice(a+u+1);if(0===u)return r.slice(a+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(a+u))break;47===l&&(f=u)}var d="";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===d.length?d+="..":d+="/..");return d.length>0?d+r.slice(a+f):(a+=f,47===r.charCodeAt(a)&&++a,r.slice(a))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return".";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?"/":".":n&&1===i?"//":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&"string"!=typeof r)throw new TypeError('"ext" argument must be a string');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return"";var a=r.length-1,h=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===h&&(s=!1,h=n+1),a>=0&&(c===r.charCodeAt(a)?-1==--a&&(o=n):(a=-1,o=h))}return i===o?o=h:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&&(s=!1,o=n+1);return-1===o?"":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,a=t.length-1;a>=0;--a){var h=t.charCodeAt(a);if(47!==h)-1===i&&(o=!1,i=a+1),46===h?-1===r?r=a:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=a+1;break}}return-1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?"":t.slice(r,i)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+n:r+"/"+n:n}(0,t)},parse:function(t){e(t);var r={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root="/",n=1):n=0;for(var s=-1,a=0,h=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f)))-1===h&&(c=!1,h=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){a=f+1;break}return-1===s||-1===h||0===u||1===u&&s===h-1&&s===a+1?-1!==h&&(r.base=r.name=0===a&&o?t.slice(1,h):t.slice(a,h)):(0===a&&o?(r.name=t.slice(1,s),r.base=t.slice(1,h)):(r.name=t.slice(a,s),r.base=t.slice(a,h)),r.ext=t.slice(s,h)),a>0?r.dir=t.slice(0,a-1):o&&(r.dir="/"),r},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,t.exports=n},674:(t,e)=>{if(Object.defineProperty(e,"__esModule",{value:!0}),e.isWindows=void 0,"object"==typeof process)e.isWindows="win32"===process.platform;else if("object"==typeof navigator){let t=navigator.userAgent;e.isWindows=t.indexOf("Windows")>=0}},796:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.uriToFsPath=e.URI=void 0;const n=r(674),i=/^\w[\w\d+.-]*$/,o=/^\//,s=/^\/\//;function a(t,e){if(!t.scheme&&e)throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);if(t.scheme&&!i.test(t.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(t.path)if(t.authority){if(!o.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}else if(s.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}const h="",c="/",f=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class u{static isUri(t){return t instanceof u||!!t&&"string"==typeof t.authority&&"string"==typeof t.fragment&&"string"==typeof t.path&&"string"==typeof t.query&&"string"==typeof t.scheme&&"string"==typeof t.fsPath&&"function"==typeof t.with&&"function"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){"object"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:"file"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case"https":case"http":case"file":e?e[0]!==c&&(e=c+e):e=c}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,a(this,o))}get fsPath(){return v(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new d(e,r,n,i,o)}static parse(t,e=!1){const r=f.exec(t);return r?new d(r[2]||h,w(r[4]||h),w(r[5]||h),w(r[7]||h),w(r[9]||h),e):new d(h,h,h,h,h)}static file(t){let e=h;if(n.isWindows&&(t=t.replace(/\\/g,c)),t[0]===c&&t[1]===c){const r=t.indexOf(c,2);-1===r?(e=t.substring(2),t=c):(e=t.substring(2,r),t=t.substring(r)||c)}return new d("file",e,t,h,h)}static from(t){const e=new d(t.scheme,t.authority,t.path,t.query,t.fragment);return a(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof u)return t;{const e=new d(t);return e._formatted=t.external,e._fsPath=t._sep===l?t.fsPath:null,e}}return t}}e.URI=u;const l=n.isWindows?1:void 0;class d extends u{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=v(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=l),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const p={58:"%3A",47:"%2F",63:"%3F",35:"%23",91:"%5B",93:"%5D",64:"%40",33:"%21",36:"%24",38:"%26",39:"%27",40:"%28",41:"%29",42:"%2A",43:"%2B",44:"%2C",59:"%3B",61:"%3D",32:"%20"};function g(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s)-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else{void 0===n&&(n=t.substr(0,o));const e=p[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o)}}return-1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function m(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=p[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function v(t,e){let r;return r=t.authority&&t.path.length>1&&"file"===t.scheme?`//${t.authority}${t.path}`:47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?e?t.path.substr(1):t.path[1].toLowerCase()+t.path.substr(2):t.path,n.isWindows&&(r=r.replace(/\//g,"\\")),r}function y(t,e){const r=e?m:g;let n="",{scheme:i,authority:o,path:s,query:a,fragment:h}=t;if(i&&(n+=i,n+=":"),(o||"file"===i)&&(n+=c,n+=c),o){let t=o.indexOf("@");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(":"),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=":",n+=r(e.substr(t+1),!1,!0)),n+="@"}o=o.toLowerCase(),t=o.lastIndexOf(":"),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return a&&(n+="?",n+=r(a,!1,!1)),h&&(n+="#",n+=e?h:g(h,!1,!1)),n}function b(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+b(t.substr(3)):t}}e.uriToFsPath=v;const C=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function w(t){return t.match(C)?t.replace(C,(t=>b(t))):t}},679:function(t,e,r){var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(e,r);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,i)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)"default"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&n(e,t,r);return i(e,t),e};Object.defineProperty(e,"__esModule",{value:!0}),e.Utils=void 0;const s=o(r(470)),a=s.posix||s,h="/";var c;!function(t){t.joinPath=function(t,...e){return t.with({path:a.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==h&&(r=h+r,n=!0);let i=a.resolve(r,...e);return n&&i[0]===h&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===h)return t;let e=a.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=""),t.with({path:e})},t.basename=function(t){return a.basename(t.path)},t.extname=function(t){return a.extname(t.path)}}(c||(e.Utils=c={}))}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n].call(o.exports,o,o.exports,r),o.exports}var n={};return(()=>{var t=n;Object.defineProperty(t,"__esModule",{value:!0}),t.Utils=t.URI=void 0;const e=r(796);Object.defineProperty(t,"URI",{enumerable:!0,get:function(){return e.URI}});const i=r(679);Object.defineProperty(t,"Utils",{enumerable:!0,get:function(){return i.Utils}})})(),n})()));


/***/ }),

/***/ "./src/ls/ddbFactory.ts":
/*!******************************!*\
  !*** ./src/ls/ddbFactory.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDDBClient: () => (/* binding */ createDDBClient)
/* harmony export */ });
/* harmony import */ var dolphindb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dolphindb */ "./node_modules/.pnpm/dolphindb@3.0.213_react-dom@19.0.0_react@19.0.0_/node_modules/dolphindb/index.js");

async function createDDBClient(configOptions) {
    const urladdress = `ws://${configOptions.ip}:${configOptions.port}`; // æ¨¡æ¿å­—ç¬¦ä¸²åˆå¹¶url
    const ddb = new dolphindb__WEBPACK_IMPORTED_MODULE_0__.DDB(urladdress, {
        autologin: configOptions.autologin,
        username: configOptions.username,
        password: configOptions.password,
        verbose: true
    });
    await ddb.connect();
    return Promise.resolve(ddb);
}


/***/ }),

/***/ "./src/ls/ddbUtils.ts":
/*!****************************!*\
  !*** ./src/ls/ddbUtils.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrayToMatrix: () => (/* binding */ arrayToMatrix),
/* harmony export */   scalarToVector: () => (/* binding */ scalarToVector)
/* harmony export */ });
function scalarToVector(scalar) {
    return [[scalar]];
}
function arrayToMatrix(arr, cols) {
    const padding = cols - (arr.length % cols);
    if (padding < cols)
        arr = arr.concat(Array(padding).fill(''));
    return Array.from({ length: arr.length / cols }, (_, i) => arr.slice(i * cols, i * cols + cols));
}


/***/ }),

/***/ "./src/ls/driver.ts":
/*!**************************!*\
  !*** ./src/ls/driver.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dolphindbDriver: () => (/* binding */ dolphindbDriver)
/* harmony export */ });
/* harmony import */ var _sqltools_base_driver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sqltools/base-driver */ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/index.js");
/* harmony import */ var _sqltools_base_driver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sqltools_base_driver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sqltools_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sqltools/types */ "./node_modules/.pnpm/@sqltools+types@0.1.7_vscode-languageserver-protocol@3.17.5/node_modules/@sqltools/types/index.js");
/* harmony import */ var _sqltools_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_sqltools_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uuid */ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/v4.js");
/* harmony import */ var dolphindb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dolphindb */ "./node_modules/.pnpm/dolphindb@3.0.213_react-dom@19.0.0_react@19.0.0_/node_modules/dolphindb/index.js");
/* harmony import */ var _ddbFactory_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ddbFactory.ts */ "./src/ls/ddbFactory.ts");
/* harmony import */ var _queries_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./queries.ts */ "./src/ls/queries.ts");
/* harmony import */ var _ddbUtils_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ddbUtils.ts */ "./src/ls/ddbUtils.ts");







// // import your actual DB library here
// import dblib from 'your-db-library';
class dolphindbDriver extends (_sqltools_base_driver__WEBPACK_IMPORTED_MODULE_0___default()) {
    /* If you driver depends on node packages, list it below on `deps` prop.
        It will be installed automatically on first use of your driver.
    */
    // public override readonly deps: typeof AbstractDriver.prototype['deps'] = [{
    //     type: AbstractDriver.CONSTANTS.DEPENDENCY_PACKAGE,
    //     name: 'dolphindb',
    //     version: '3.0.210',
    //         }
    //     ];
    queries = _queries_ts__WEBPACK_IMPORTED_MODULE_4__.queries;
    /** if you need to require your lib in runtime and then
     * use `this.lib.methodName()` anywhere and vscode will take care of the dependencies
     * to be installed on a cache folder
     **/
    // private get lib() {
    //   return this.requireDep('node-packge-name') as DriverLib;
    // }
    async open() {
        if (this.connection)
            return this.connection;
        try {
            const connectOptions = {
                ip: this.credentials.server,
                port: this.credentials.port,
                autologin: this.credentials.autologin ?? true, // æ˜¯å¦è‡ªåŠ¨ç™»å½•ï¼Œåº”è®¾ä¸ºå¯é€‰
                username: this.credentials.username || 'admin',
                password: this.credentials.password || '123456'
            };
            console.log(connectOptions);
            this.connection = (0,_ddbFactory_ts__WEBPACK_IMPORTED_MODULE_3__.createDDBClient)(connectOptions);
            console.log('connected');
            return await this.connection;
        }
        catch (error) {
            console.error('Failed to open connection', error);
            throw new Error('Failed to open connection');
        }
    }
    async close() {
        if (!this.connection)
            return Promise.resolve();
        try {
            const db = await this.connection;
            db.disconnect();
            this.connection = null;
        }
        catch (error) {
            console.error('Failed to disconnect', error);
            throw new Error('Failed to disconnect');
        }
    }
    query = async (queries, opt = {}) => {
        const db = await this.open();
        const resultsAgg = [];
        const { requestId } = opt;
        let queriesResults;
        // return the last results
        queriesResults = await db.eval(queries.toString().replaceAll('\r\n', '\n'));
        const ddbData = queriesResults.data();
        // scalar
        if (queriesResults.form === dolphindb__WEBPACK_IMPORTED_MODULE_2__.DdbForm.scalar) {
            let re = _ddbUtils_ts__WEBPACK_IMPORTED_MODULE_5__.scalarToVector(ddbData);
            resultsAgg.push({
                requestId: requestId,
                resultId: (0,uuid__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                cols: Object.keys(re[0]),
                connId: this.getId(),
                messages: [{ date: new Date(), message: `Query executed successfully and returned a ${dolphindb__WEBPACK_IMPORTED_MODULE_2__.DdbType[queriesResults.type]} scalar.` }],
                results: re,
                query: queries.toString()
            });
        } // vector
        else if (queriesResults.form === dolphindb__WEBPACK_IMPORTED_MODULE_2__.DdbForm.vector) {
            let re = _ddbUtils_ts__WEBPACK_IMPORTED_MODULE_5__.arrayToMatrix(ddbData, 10);
            resultsAgg.push({
                requestId: requestId,
                resultId: (0,uuid__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                cols: Object.keys(re[0]),
                connId: this.getId(),
                messages: [{ date: new Date(), message: `Query executed successfully and returned a ${dolphindb__WEBPACK_IMPORTED_MODULE_2__.DdbType[queriesResults.type]} vector with ${re.length} elements` }],
                results: re,
                query: queries.toString()
            });
        } // set
        else if (queriesResults.form === dolphindb__WEBPACK_IMPORTED_MODULE_2__.DdbForm.set) {
            let re = _ddbUtils_ts__WEBPACK_IMPORTED_MODULE_5__.arrayToMatrix(Array.from(ddbData), 10);
            resultsAgg.push({
                requestId: requestId,
                resultId: (0,uuid__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                cols: Object.keys(re[0]),
                connId: this.getId(),
                messages: [{ date: new Date(), message: `Query executed successfully and returned a ${dolphindb__WEBPACK_IMPORTED_MODULE_2__.DdbType[queriesResults.type]} set with ${ddbData.size} elements` }],
                results: re,
                query: queries.toString()
            });
        } // matrix
        else if (queriesResults.form === dolphindb__WEBPACK_IMPORTED_MODULE_2__.DdbForm.matrix) {
            let re;
            let colLabel = ddbData.columns === undefined ? Object.keys(ddbData.data[0]) : ddbData.columns;
            if (ddbData.rows !== undefined) {
                colLabel = ['rowLabel', ...colLabel];
                re = ddbData.data.map((subArray, index) => [ddbData.rows[index], ...subArray]);
            }
            else
                re = ddbData.data;
            re = re.map(row => {
                const rowObject = {};
                colLabel.forEach((key, index) => {
                    rowObject[key] = row[index];
                });
                return rowObject;
            });
            console.log(re);
            resultsAgg.push({
                requestId: requestId,
                resultId: (0,uuid__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                cols: colLabel,
                connId: this.getId(),
                messages: [{ date: new Date(), message: `Query executed successfully and returned a ${dolphindb__WEBPACK_IMPORTED_MODULE_2__.DdbType[queriesResults.type]} matrix with ${ddbData.nrows} * ${ddbData.ncolumns} results` }],
                results: re,
                query: queries.toString()
            });
        }
        // table   
        else if (queriesResults.form === dolphindb__WEBPACK_IMPORTED_MODULE_2__.DdbForm.table) {
            let re = ddbData.data;
            console.log(re.length);
            resultsAgg.push({
                requestId: requestId,
                resultId: (0,uuid__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                cols: re.length === 0 ? [] : Object.keys(re[0]),
                connId: this.getId(),
                messages: [{ date: new Date(), message: `Query executed successfully and returned a table with ${re.length} results` }],
                results: re,
                query: queries.toString()
            });
        }
        else
            resultsAgg.push({
                requestId: requestId,
                resultId: (0,uuid__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                cols: [],
                connId: this.getId(),
                messages: [{ date: new Date(), message: 'Query executed successfully and returned an object that cannot be fully displayed (e.g. a dictionary).' }],
                results: [[]],
                query: queries.toString()
            });
        return resultsAgg;
    };
    /** if you need a different way to test your connection, you can set it here.
     * Otherwise by default we open and close the connection only
     */
    async testConnection() {
        await this.open();
        await this.query('SELECT 1', {});
    }
    /** This method is a helper to generate the connection explorer tree.
        it gets the child items based on current item */
    async getChildrenForItem({ item, parent }) {
        const db = await this.open();
        switch (item.type) {
            case _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.CONNECTION:
            case _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.CONNECTED_CONNECTION:
                return [
                    {
                        label: 'Databases',
                        type: _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.RESOURCE_GROUP,
                        iconId: 'folder',
                        childType: _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.DATABASE,
                    },
                    {
                        label: 'In-memory Tables',
                        type: _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.RESOURCE_GROUP,
                        iconId: 'folder',
                        childType: _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.RESOURCE_GROUP,
                        snippet: 'table'
                    },
                    {
                        label: 'variables',
                        type: _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.RESOURCE_GROUP,
                        iconId: 'folder',
                        childType: _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.RESOURCE_GROUP,
                        snippet: 'var'
                    },
                ];
            case _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.RESOURCE_GROUP:
                return this.getChildrenForGroup({ parent, item });
            case _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.DATABASE:
                return this.getChildrenForGroup({ parent, item });
            case _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.TABLE:
                return this.getChildrenForGroup({ parent, item });
        }
        return [];
    }
    /** This method is a helper to generate the connection explorer tree.
        It gets the child based on child types */
    async getChildrenForGroup({ parent, item }) {
        const db = await this.open();
        console.log({ parent, item });
        switch (item.childType) {
            case _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.RESOURCE_GROUP:
                return item.snippet === 'table' ? _queries_ts__WEBPACK_IMPORTED_MODULE_4__.queries.fetchInMemTables(db, item) : _queries_ts__WEBPACK_IMPORTED_MODULE_4__.queries.fetchVariables(db, item);
            case _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.DATABASE:
                return _queries_ts__WEBPACK_IMPORTED_MODULE_4__.queries.fetchDatabases(db, item);
            case _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.TABLE:
                return _queries_ts__WEBPACK_IMPORTED_MODULE_4__.queries.fetchTables(db, item);
            case _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.COLUMN:
                return _queries_ts__WEBPACK_IMPORTED_MODULE_4__.queries.fetchColumns(db, item);
        }
        return [];
    }
    /** This method is a helper for intellisense and quick picks. */
    async searchItems(itemType, search, _extraParams = {}) {
        switch (itemType) {
            case _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.TABLE:
                return this.queryResults(_queries_ts__WEBPACK_IMPORTED_MODULE_4__.queries.searchTables({ search, ..._extraParams }));
            case _sqltools_types__WEBPACK_IMPORTED_MODULE_1__.ContextValue.COLUMN:
                return this.queryResults(_queries_ts__WEBPACK_IMPORTED_MODULE_4__.queries.searchColumns({ search, ..._extraParams }));
        }
        return [];
    }
    getStaticCompletions = async () => ({});
}


/***/ }),

/***/ "./src/ls/queries.ts":
/*!***************************!*\
  !*** ./src/ls/queries.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   queries: () => (/* binding */ queries)
/* harmony export */ });
/* harmony import */ var _sqltools_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sqltools/types */ "./node_modules/.pnpm/@sqltools+types@0.1.7_vscode-languageserver-protocol@3.17.5/node_modules/@sqltools/types/index.js");
/* harmony import */ var _sqltools_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sqltools_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sqltools_base_driver_dist_lib_factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sqltools/base-driver/dist/lib/factory.js */ "./node_modules/.pnpm/@sqltools+base-driver@0.1.1_4982ceee454885f19c24b725dfd476dd/node_modules/@sqltools/base-driver/dist/lib/factory.js");


/** write your queries here go fetch desired data. This queries are just examples copied from SQLite driver */
const describeTable = (0,_sqltools_base_driver_dist_lib_factory_js__WEBPACK_IMPORTED_MODULE_1__["default"]) `
  select *
  from ${p => p.database.length ? `loadTable('${p.database}', '${p.schema}').schema().colDefs` : `${p.label}.schema().colDefs`}
`;
async function fetchColumns(db, item) {
    let colList;
    let parentDBName = item.database;
    let tableName = item.label;
    let nodeType = await db.execute('getNodeType()');
    if (nodeType === 2 && parentDBName !== '')
        colList = await db.execute(`rpc((exec name from getClusterPerf() where state == 1 limit 1)[0], loadTable, '${parentDBName}', '${tableName}').schema().colDefs`);
    else if (parentDBName !== '')
        colList = await db.execute(`loadTable('${parentDBName}', '${tableName}').schema().colDefs`);
    else
        colList = await db.execute(`${tableName}.schema().colDefs`);
    return colList.data.map(row => ({
        label: row.name,
        type: _sqltools_types__WEBPACK_IMPORTED_MODULE_0__.ContextValue.COLUMN,
        iconId: 'column',
        detail: row.typeString,
        childType: _sqltools_types__WEBPACK_IMPORTED_MODULE_0__.ContextValue.NO_CHILD
    }));
}
const fetchRecords = (0,_sqltools_base_driver_dist_lib_factory_js__WEBPACK_IMPORTED_MODULE_1__["default"]) `
select *
from ${p => { console.log('asdr', p); return p.table.database.length ? `loadTable('${p.table.database}', '${p.table.schema}')` : `${p.table.schema}`; }}
limit ${p => p.offset || 0}, ${p => p.limit || 50};
`;
const countRecords = (0,_sqltools_base_driver_dist_lib_factory_js__WEBPACK_IMPORTED_MODULE_1__["default"]) `
select count(*) as total
from ${p => p.table.database.length ? `loadTable('${p.table.database}', '${p.table.schema}')` : `${p.table.schema}`}
`;
async function fetchTables(db, item) {
    Promise;
    let dbName = item.label;
    let tbList = item.info.filter(item => item.dbNames === dbName).map(item => item.tbNames);
    return tbList.map(tb => ({
        label: tb,
        schema: tb,
        type: _sqltools_types__WEBPACK_IMPORTED_MODULE_0__.ContextValue.TABLE,
        iconId: 'table',
        childType: _sqltools_types__WEBPACK_IMPORTED_MODULE_0__.ContextValue.COLUMN,
        database: dbName,
    }));
}
async function fetchDatabases(db, item) {
    let dbList;
    let script = `
    def getInfo(){
        re = each(x->x[6:],getClusterDFSTables()) 
        dbNames = array(STRING)
        tbNames = array(STRING)
        if(re.size() > 0){
            s = re.split("/") 
            dbNames = ("dfs://" + loop(s->concat:R(s[0:(s.size()-1)]), s)).flatten()
            tbNames = s.tail:E(1)
        }
        
        return table(dbNames, tbNames)
    }
    getInfo()
  `;
    let re = await db.execute(script);
    console.log('aaa', re);
    dbList = re.data.map(item => item.dbNames);
    dbList = [...new Set(dbList)];
    console.log('aaa', dbList);
    return dbList.map(db => ({
        label: db,
        type: _sqltools_types__WEBPACK_IMPORTED_MODULE_0__.ContextValue.DATABASE,
        iconId: 'database',
        childType: _sqltools_types__WEBPACK_IMPORTED_MODULE_0__.ContextValue.TABLE,
        info: re.data
    }));
}
async function fetchInMemTables(db, item) {
    let script = `
   exec name from objs(true) where form = "TABLE"
  `;
    let vars = await db.execute(script);
    return vars.map(item => ({
        label: item,
        type: _sqltools_types__WEBPACK_IMPORTED_MODULE_0__.ContextValue.TABLE,
        iconId: 'table',
        database: '',
        schema: item,
        childType: _sqltools_types__WEBPACK_IMPORTED_MODULE_0__.ContextValue.COLUMN,
        info: vars
    }));
}
async function fetchVariables(db, item) {
    let script = `
   exec * from objs(true) where form != "TABLE"
  `;
    let vars = await db.execute(script);
    console.log('var', vars);
    return vars.data.map(item => ({
        label: item.name,
        type: _sqltools_types__WEBPACK_IMPORTED_MODULE_0__.ContextValue.RESOURCE_GROUP,
        iconId: 'view',
        detail: item.form,
        childType: _sqltools_types__WEBPACK_IMPORTED_MODULE_0__.ContextValue.NO_CHILD,
    }));
}
const searchTables = (0,_sqltools_base_driver_dist_lib_factory_js__WEBPACK_IMPORTED_MODULE_1__["default"]) `
tbName = getClusterDFSTables().split('/').tail:E();
dbName = each(substr{,0,}, getClusterDFSTables(), getClusterDFSTables().strlen() - tbName.strlen() - 1);

imt = select name as label, '' as database, name as schema, 'TABLE' as type from objs(true) where form = 'TABLE';
dfst = select (dbName + "/" + tbName) as label,
   dbName as database,
   tbName as schema,
  'TABLE' as type
from table(dbName, tbName);

tbInfo = unionAll(imt, dfst);

select * from tbInfo
${p => (p.search ? `where label like '%${p.search}%'` : '')}
order by label
`;
const searchColumns = (0,_sqltools_base_driver_dist_lib_factory_js__WEBPACK_IMPORTED_MODULE_1__["default"]) `

tbName = getClusterDFSTables().split('/').tail:E();
dbName = each(substr{,0,}, getClusterDFSTables(), getClusterDFSTables().strlen() - tbName.strlen() - 1);

dfscolInfo = each(def(dbName, tbName){ return select dbName, tbName, * from loadTable(dbName, tbName).schema().colDefs}, dbName, tbName).unionAll{false}();

imtTbName = exec name from objs(true) where form = 'TABLE'
imtcolInfo = each(def(tbName){ return select '' as dbName, tbName, * from objByName(tbName).schema().colDefs}, imtTbName).unionAll{false}();

colInfo = unionAll(dfscolInfo, imtcolInfo)

select name as label,
  tbName as "table",
  dbName as database,
  typeString as dataType,
  false as isPk,
  '${_sqltools_types__WEBPACK_IMPORTED_MODULE_0__.ContextValue.COLUMN}' as type
from colInfo
where  1 = 1
${p => p.tables?.filter(t => !!t.database).length
    ? `and dbName in (${p.tables
        ?.filter(t => !!t.database)
        .map(t => `'${t.database}'`)
        .join(', ')})`
    : ''}
${p => p.tables?.filter(t => !!t.label).length
    ? `and tbName in (${p.tables
        ?.filter(t => !!t.label)
        .map(t => `'${t.label}'`)
        .join(', ')})`
    : ''}
${p => p.search
    ? `and (
    (dbName + '.' + tbName + '.' + name) like '%${p.search}%'
    or (tbName + '.' + name) like '%${p.search}%'
    or name like '%${p.search}%'
  )`
    : ''}
order by name asc
limit ${p => p.limit || 100}
`;
const queries = {
    describeTable,
    countRecords,
    fetchColumns,
    fetchRecords,
    fetchTables,
    fetchDatabases,
    fetchInMemTables,
    fetchVariables,
    searchTables,
    searchColumns
};


/***/ }),

/***/ "./node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd sync recursive":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/ sync ***!
  \**********************************************************************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "vscode":
/*!*************************!*\
  !*** external "vscode" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "node:assert":
/*!******************************!*\
  !*** external "node:assert" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:assert");

/***/ }),

/***/ "node:async_hooks":
/*!***********************************!*\
  !*** external "node:async_hooks" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:async_hooks");

/***/ }),

/***/ "node:buffer":
/*!******************************!*\
  !*** external "node:buffer" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:buffer");

/***/ }),

/***/ "node:console":
/*!*******************************!*\
  !*** external "node:console" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:console");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "node:diagnostics_channel":
/*!*******************************************!*\
  !*** external "node:diagnostics_channel" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:diagnostics_channel");

/***/ }),

/***/ "node:dns":
/*!***************************!*\
  !*** external "node:dns" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:dns");

/***/ }),

/***/ "node:events":
/*!******************************!*\
  !*** external "node:events" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:events");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "node:fs/promises":
/*!***********************************!*\
  !*** external "node:fs/promises" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs/promises");

/***/ }),

/***/ "node:http":
/*!****************************!*\
  !*** external "node:http" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:http");

/***/ }),

/***/ "node:http2":
/*!*****************************!*\
  !*** external "node:http2" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:http2");

/***/ }),

/***/ "node:net":
/*!***************************!*\
  !*** external "node:net" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:net");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ "node:perf_hooks":
/*!**********************************!*\
  !*** external "node:perf_hooks" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:perf_hooks");

/***/ }),

/***/ "node:querystring":
/*!***********************************!*\
  !*** external "node:querystring" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:querystring");

/***/ }),

/***/ "node:sea":
/*!***************************!*\
  !*** external "node:sea" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:sea");

/***/ }),

/***/ "node:sqlite":
/*!******************************!*\
  !*** external "node:sqlite" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:sqlite");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:stream");

/***/ }),

/***/ "node:string_decoder":
/*!**************************************!*\
  !*** external "node:string_decoder" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:string_decoder");

/***/ }),

/***/ "node:tls":
/*!***************************!*\
  !*** external "node:tls" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:tls");

/***/ }),

/***/ "node:url":
/*!***************************!*\
  !*** external "node:url" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:url");

/***/ }),

/***/ "node:util":
/*!****************************!*\
  !*** external "node:util" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:util");

/***/ }),

/***/ "node:util/types":
/*!**********************************!*\
  !*** external "node:util/types" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:util/types");

/***/ }),

/***/ "node:worker_threads":
/*!**************************************!*\
  !*** external "node:worker_threads" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:worker_threads");

/***/ }),

/***/ "node:zlib":
/*!****************************!*\
  !*** external "node:zlib" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:zlib");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "stream/consumers":
/*!***********************************!*\
  !*** external "stream/consumers" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream/consumers");

/***/ }),

/***/ "timers/promises":
/*!**********************************!*\
  !*** external "timers/promises" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers/promises");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "util/types":
/*!*****************************!*\
  !*** external "util/types" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("util/types");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "./node_modules/.pnpm/emoji-regex@10.4.0/node_modules/emoji-regex/index.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/emoji-regex@10.4.0/node_modules/emoji-regex/index.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => {
	// https://mths.be/emoji
	return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
});


/***/ }),

/***/ "./node_modules/.pnpm/ansi-regex@6.1.0/node_modules/ansi-regex/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/ansi-regex@6.1.0/node_modules/ansi-regex/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ansiRegex)
/* harmony export */ });
function ansiRegex({onlyFirst = false} = {}) {
	// Valid string terminator sequences are BEL, ESC\, and 0x9c
	const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
	const pattern = [
		`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))',
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
}


/***/ }),

/***/ "./node_modules/.pnpm/dolphindb@3.0.213_react-dom@19.0.0_react@19.0.0_/node_modules/dolphindb/i18n/index.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/dolphindb@3.0.213_react-dom@19.0.0_react@19.0.0_/node_modules/dolphindb/i18n/index.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i18n: () => (/* binding */ i18n),
/* harmony export */   language: () => (/* binding */ language),
/* harmony export */   t: () => (/* binding */ t)
/* harmony export */ });
/* harmony import */ var xshell_i18n_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xshell/i18n/index.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/index.js");
/* harmony import */ var _dict_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dict.json */ "./node_modules/.pnpm/dolphindb@3.0.213_react-dom@19.0.0_react@19.0.0_/node_modules/dolphindb/i18n/dict.json");


let i18n = new xshell_i18n_index_js__WEBPACK_IMPORTED_MODULE_0__.I18N(_dict_json__WEBPACK_IMPORTED_MODULE_1__);
const { t, language } = i18n;



/***/ }),

/***/ "./node_modules/.pnpm/dolphindb@3.0.213_react-dom@19.0.0_react@19.0.0_/node_modules/dolphindb/index.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/dolphindb@3.0.213_react-dom@19.0.0_react@19.0.0_/node_modules/dolphindb/index.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BigInt128Array: () => (/* binding */ BigInt128Array),
/* harmony export */   DDB: () => (/* binding */ DDB),
/* harmony export */   DdbBlob: () => (/* binding */ DdbBlob),
/* harmony export */   DdbBool: () => (/* binding */ DdbBool),
/* harmony export */   DdbChar: () => (/* binding */ DdbChar),
/* harmony export */   DdbChartType: () => (/* binding */ DdbChartType),
/* harmony export */   DdbConnectionError: () => (/* binding */ DdbConnectionError),
/* harmony export */   DdbDatabaseError: () => (/* binding */ DdbDatabaseError),
/* harmony export */   DdbDate: () => (/* binding */ DdbDate),
/* harmony export */   DdbDateTime: () => (/* binding */ DdbDateTime),
/* harmony export */   DdbDict: () => (/* binding */ DdbDict),
/* harmony export */   DdbDouble: () => (/* binding */ DdbDouble),
/* harmony export */   DdbDurationUnit: () => (/* binding */ DdbDurationUnit),
/* harmony export */   DdbForm: () => (/* binding */ DdbForm),
/* harmony export */   DdbFunction: () => (/* binding */ DdbFunction),
/* harmony export */   DdbFunctionType: () => (/* binding */ DdbFunctionType),
/* harmony export */   DdbInt: () => (/* binding */ DdbInt),
/* harmony export */   DdbLong: () => (/* binding */ DdbLong),
/* harmony export */   DdbNanoTimeStamp: () => (/* binding */ DdbNanoTimeStamp),
/* harmony export */   DdbObj: () => (/* binding */ DdbObj),
/* harmony export */   DdbPair: () => (/* binding */ DdbPair),
/* harmony export */   DdbSetDouble: () => (/* binding */ DdbSetDouble),
/* harmony export */   DdbSetInt: () => (/* binding */ DdbSetInt),
/* harmony export */   DdbSetString: () => (/* binding */ DdbSetString),
/* harmony export */   DdbString: () => (/* binding */ DdbString),
/* harmony export */   DdbTable: () => (/* binding */ DdbTable),
/* harmony export */   DdbTimeStamp: () => (/* binding */ DdbTimeStamp),
/* harmony export */   DdbType: () => (/* binding */ DdbType),
/* harmony export */   DdbVectorAny: () => (/* binding */ DdbVectorAny),
/* harmony export */   DdbVectorDouble: () => (/* binding */ DdbVectorDouble),
/* harmony export */   DdbVectorInt: () => (/* binding */ DdbVectorInt),
/* harmony export */   DdbVectorLong: () => (/* binding */ DdbVectorLong),
/* harmony export */   DdbVectorString: () => (/* binding */ DdbVectorString),
/* harmony export */   DdbVectorSymbol: () => (/* binding */ DdbVectorSymbol),
/* harmony export */   DdbVoid: () => (/* binding */ DdbVoid),
/* harmony export */   DdbVoidType: () => (/* binding */ DdbVoidType),
/* harmony export */   SqlStandard: () => (/* binding */ SqlStandard),
/* harmony export */   convert: () => (/* binding */ convert),
/* harmony export */   converts: () => (/* binding */ converts),
/* harmony export */   date2ms: () => (/* binding */ date2ms),
/* harmony export */   date2str: () => (/* binding */ date2str),
/* harmony export */   datehour2ms: () => (/* binding */ datehour2ms),
/* harmony export */   datehour2str: () => (/* binding */ datehour2str),
/* harmony export */   datetime2ms: () => (/* binding */ datetime2ms),
/* harmony export */   datetime2str: () => (/* binding */ datetime2str),
/* harmony export */   ddb_tensor_bytes: () => (/* binding */ ddb_tensor_bytes),
/* harmony export */   dictables: () => (/* binding */ dictables),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   formati: () => (/* binding */ formati),
/* harmony export */   get_duration_unit: () => (/* binding */ get_duration_unit),
/* harmony export */   get_type_name: () => (/* binding */ get_type_name),
/* harmony export */   int1282str: () => (/* binding */ int1282str),
/* harmony export */   ipaddr2str: () => (/* binding */ ipaddr2str),
/* harmony export */   is_decimal_null_value: () => (/* binding */ is_decimal_null_value),
/* harmony export */   is_decimal_type: () => (/* binding */ is_decimal_type),
/* harmony export */   minute2ms: () => (/* binding */ minute2ms),
/* harmony export */   minute2str: () => (/* binding */ minute2str),
/* harmony export */   month2ms: () => (/* binding */ month2ms),
/* harmony export */   month2str: () => (/* binding */ month2str),
/* harmony export */   nanotime2ns: () => (/* binding */ nanotime2ns),
/* harmony export */   nanotime2str: () => (/* binding */ nanotime2str),
/* harmony export */   nanotimestamp2ns: () => (/* binding */ nanotimestamp2ns),
/* harmony export */   nanotimestamp2str: () => (/* binding */ nanotimestamp2str),
/* harmony export */   nulls: () => (/* binding */ nulls),
/* harmony export */   second2ms: () => (/* binding */ second2ms),
/* harmony export */   second2str: () => (/* binding */ second2str),
/* harmony export */   str2nanotimestamp: () => (/* binding */ str2nanotimestamp),
/* harmony export */   str2timestamp: () => (/* binding */ str2timestamp),
/* harmony export */   time2ms: () => (/* binding */ time2ms),
/* harmony export */   time2str: () => (/* binding */ time2str),
/* harmony export */   timestamp2ms: () => (/* binding */ timestamp2ms),
/* harmony export */   timestamp2str: () => (/* binding */ timestamp2str),
/* harmony export */   uuid2str: () => (/* binding */ uuid2str),
/* harmony export */   winsize: () => (/* binding */ winsize)
/* harmony export */ });
/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dayjs */ "./node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/dayjs.min.js");
/* harmony import */ var dayjs_plugin_customParseFormat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dayjs/plugin/customParseFormat.js */ "./node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/customParseFormat.js");
/* harmony import */ var ipaddr_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipaddr.js */ "./node_modules/.pnpm/ipaddr.js@2.2.0/node_modules/ipaddr.js/lib/ipaddr.js");
/* harmony import */ var xshell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! xshell */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/index.js");
/* harmony import */ var _i18n_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./i18n/index.js */ "./node_modules/.pnpm/dolphindb@3.0.213_react-dom@19.0.0_react@19.0.0_/node_modules/dolphindb/i18n/index.js");


dayjs__WEBPACK_IMPORTED_MODULE_0__.extend(dayjs_plugin_customParseFormat_js__WEBPACK_IMPORTED_MODULE_1__);

const { fromByteArray: buf2ipaddr } = ipaddr_js__WEBPACK_IMPORTED_MODULE_2__;


const nulls = {
    int8: -0x80, // -128
    int16: -0x80_00, // -32768
    int32: -0x80_00_00_00, // -21_4748_3648
    int64: -0x8000000000000000n, // -922_3372_0368_5477_5808
    int128: -0x80000000000000000000000000000000n, // -170_1411_8346_0469_2317_3168_7303_7158_8410_5728
    float32: -3.4028234663852886e+38,
    /** -Number.MAX_VALUE */
    double: -Number.MAX_VALUE,
    bytes16: Uint8Array.from(new Array(16).fill(0))
};
var DdbForm;
(function (DdbForm) {
    DdbForm[DdbForm["scalar"] = 0] = "scalar";
    DdbForm[DdbForm["vector"] = 1] = "vector";
    DdbForm[DdbForm["pair"] = 2] = "pair";
    DdbForm[DdbForm["matrix"] = 3] = "matrix";
    DdbForm[DdbForm["set"] = 4] = "set";
    DdbForm[DdbForm["dict"] = 5] = "dict";
    DdbForm[DdbForm["table"] = 6] = "table";
    DdbForm[DdbForm["chart"] = 7] = "chart";
    /** èŠ‚ç‚¹å†…éƒ¨é€šä¿¡å¯èƒ½ä¼šä½¿ç”¨ï¼Œè°ƒç”¨å‡½æ•°æ‰§è¡Œè„šæœ¬ä¸€èˆ¬ä¸ä¼šè¿”å›žè¿™ç§ç±»åž‹ */
    DdbForm[DdbForm["chunk"] = 8] = "chunk";
    /** sysobj */
    DdbForm[DdbForm["object"] = 9] = "object";
    DdbForm[DdbForm["tensor"] = 10] = "tensor";
})(DdbForm || (DdbForm = {}));
/** DolphinDB DataType
    å¯¹åº”çš„ array vector ç±»åž‹ä¸º 64 + åŸºæœ¬ç±»åž‹
    å¯¹åº”çš„ extended ç±»åž‹ä¸º 128 + åŸºæœ¬ç±»åž‹ */
var DdbType;
(function (DdbType) {
    DdbType[DdbType["void"] = 0] = "void";
    DdbType[DdbType["bool"] = 1] = "bool";
    DdbType[DdbType["char"] = 2] = "char";
    DdbType[DdbType["short"] = 3] = "short";
    DdbType[DdbType["int"] = 4] = "int";
    DdbType[DdbType["long"] = 5] = "long";
    DdbType[DdbType["date"] = 6] = "date";
    DdbType[DdbType["month"] = 7] = "month";
    DdbType[DdbType["time"] = 8] = "time";
    DdbType[DdbType["minute"] = 9] = "minute";
    DdbType[DdbType["second"] = 10] = "second";
    DdbType[DdbType["datetime"] = 11] = "datetime";
    DdbType[DdbType["timestamp"] = 12] = "timestamp";
    DdbType[DdbType["nanotime"] = 13] = "nanotime";
    DdbType[DdbType["nanotimestamp"] = 14] = "nanotimestamp";
    DdbType[DdbType["float"] = 15] = "float";
    DdbType[DdbType["double"] = 16] = "double";
    DdbType[DdbType["symbol"] = 17] = "symbol";
    DdbType[DdbType["string"] = 18] = "string";
    DdbType[DdbType["uuid"] = 19] = "uuid";
    DdbType[DdbType["functiondef"] = 20] = "functiondef";
    DdbType[DdbType["handle"] = 21] = "handle";
    DdbType[DdbType["code"] = 22] = "code";
    DdbType[DdbType["datasource"] = 23] = "datasource";
    DdbType[DdbType["resource"] = 24] = "resource";
    DdbType[DdbType["any"] = 25] = "any";
    DdbType[DdbType["compressed"] = 26] = "compressed";
    DdbType[DdbType["dict"] = 27] = "dict";
    DdbType[DdbType["datehour"] = 28] = "datehour";
    DdbType[DdbType["ipaddr"] = 30] = "ipaddr";
    DdbType[DdbType["int128"] = 31] = "int128";
    DdbType[DdbType["blob"] = 32] = "blob";
    DdbType[DdbType["complex"] = 34] = "complex";
    DdbType[DdbType["point"] = 35] = "point";
    DdbType[DdbType["duration"] = 36] = "duration";
    DdbType[DdbType["decimal32"] = 37] = "decimal32";
    DdbType[DdbType["decimal64"] = 38] = "decimal64";
    DdbType[DdbType["decimal128"] = 39] = "decimal128";
    DdbType[DdbType["object"] = 40] = "object";
    DdbType[DdbType["iotany"] = 41] = "iotany";
    DdbType[DdbType["symbol_extended"] = 145] = "symbol_extended";
})(DdbType || (DdbType = {}));
var DdbFunctionType;
(function (DdbFunctionType) {
    DdbFunctionType[DdbFunctionType["SystemFunc"] = 0] = "SystemFunc";
    DdbFunctionType[DdbFunctionType["SystemProc"] = 1] = "SystemProc";
    DdbFunctionType[DdbFunctionType["OperatorFunc"] = 2] = "OperatorFunc";
    DdbFunctionType[DdbFunctionType["UserDefinedFunc"] = 3] = "UserDefinedFunc";
    DdbFunctionType[DdbFunctionType["PartialFunc"] = 4] = "PartialFunc";
    DdbFunctionType[DdbFunctionType["DynamicFunc"] = 5] = "DynamicFunc";
    DdbFunctionType[DdbFunctionType["PiecewiseFunc"] = 6] = "PiecewiseFunc";
    DdbFunctionType[DdbFunctionType["JitFunc"] = 7] = "JitFunc";
    DdbFunctionType[DdbFunctionType["JitPartialFunc"] = 8] = "JitPartialFunc";
})(DdbFunctionType || (DdbFunctionType = {}));
var DdbDurationUnit;
(function (DdbDurationUnit) {
    DdbDurationUnit[DdbDurationUnit["ns"] = 0] = "ns";
    DdbDurationUnit[DdbDurationUnit["us"] = 1] = "us";
    DdbDurationUnit[DdbDurationUnit["ms"] = 2] = "ms";
    DdbDurationUnit[DdbDurationUnit["s"] = 3] = "s";
    DdbDurationUnit[DdbDurationUnit["m"] = 4] = "m";
    DdbDurationUnit[DdbDurationUnit["H"] = 5] = "H";
    DdbDurationUnit[DdbDurationUnit["d"] = 6] = "d";
    DdbDurationUnit[DdbDurationUnit["w"] = 7] = "w";
    DdbDurationUnit[DdbDurationUnit["M"] = 8] = "M";
    DdbDurationUnit[DdbDurationUnit["y"] = 9] = "y";
    DdbDurationUnit[DdbDurationUnit["B"] = 10] = "B";
})(DdbDurationUnit || (DdbDurationUnit = {}));
var DdbChartType;
(function (DdbChartType) {
    DdbChartType[DdbChartType["area"] = 0] = "area";
    DdbChartType[DdbChartType["bar"] = 1] = "bar";
    DdbChartType[DdbChartType["column"] = 2] = "column";
    DdbChartType[DdbChartType["histogram"] = 3] = "histogram";
    DdbChartType[DdbChartType["line"] = 4] = "line";
    DdbChartType[DdbChartType["pie"] = 5] = "pie";
    DdbChartType[DdbChartType["scatter"] = 6] = "scatter";
    DdbChartType[DdbChartType["trend"] = 7] = "trend";
    DdbChartType[DdbChartType["kline"] = 8] = "kline";
})(DdbChartType || (DdbChartType = {}));
// server å®žçŽ°ä¸­åŒºåˆ†äº† 0: NULL (nothing), 1: NULL (null), 2: DFLT (default)
// Void::serialize()
//     (isNothing() ? 0 : 1) + (isDefault_ ? 2 : 0);
var DdbVoidType;
(function (DdbVoidType) {
    DdbVoidType[DdbVoidType["undefined"] = 0] = "undefined";
    DdbVoidType[DdbVoidType["null"] = 1] = "null";
    DdbVoidType[DdbVoidType["default"] = 2] = "default";
})(DdbVoidType || (DdbVoidType = {}));
const dictables = new Set([DdbType.any, DdbType.string, DdbType.double, DdbType.float, DdbType.int, DdbType.long]);
/** å·¥å…·ï¼Œå–å¾—æŸä¸ª DdbType çš„å­—èŠ‚æ•° */
const ddb_tensor_bytes = {
    [DdbType.bool]: 1,
    [DdbType.char]: 1,
    [DdbType.short]: 2,
    [DdbType.int]: 4,
    [DdbType.long]: 8,
    [DdbType.float]: 4,
    [DdbType.double]: 8,
};
/** å¯ä»¥è¡¨ç¤ºæ‰€æœ‰ DolphinDB æ•°æ®åº“ä¸­çš„æ•°æ®ç±»åž‹  Can represent data types in all DolphinDB databases */
class DdbObj {
    static dec = new TextDecoder('utf-8');
    static enc = new TextEncoder();
    /** ç»´æŠ¤å·²è§£æžçš„ symbol baseï¼Œæ¯”å¦‚æµæ•°æ®ä¸­åŽç»­çš„ symbol å‘é‡å¯èƒ½åªå‘é€ä¸€ä¸ª base.id, base.size == 0, ä¾èµ–ä¹‹å‰å‘é€çš„ symbol base ï¼Ÿ
        åªæ˜¯æš‚å­˜ï¼Œå¦‚æžœä¸€å¼ è¡¨æœ‰å¤šä¸ª symbol åˆ—ï¼Œå¯èƒ½è¿™ä¸ª symbol base ä¼šè¢«å¤ç”¨ï¼Œä¸åŒçš„å¯¹è±¡ä¹‹é—´ symbol base ä¸€èˆ¬ä¸å¤ç”¨
    */
    static symbol_bases = {};
    /** little endian (client) */
    static le_client = Boolean(new Uint8Array(Uint32Array.of(1).buffer)[0]);
    /** æ˜¯å¦ä¸ºå°ç«¯ (little endian) */
    le = DdbObj.le_client;
    /** æ•°æ®å½¢å¼ https://www.dolphindb.cn/cn/help/DataTypesandStructures/DataForms/index.html */
    form;
    /** æ•°æ®ç±»åž‹ https://www.dolphindb.cn/cn/help/DataTypesandStructures/DataTypes/index.html */
    type;
    /** å ç”¨ parse æ—¶ä¼ å…¥çš„ buf çš„é•¿åº¦ */
    length;
    /** table name / column name */
    name;
    /** æœ€ä½Žç»´ã€ç¬¬ 1 ç»´
        - vector: rows = n, cols = 1
        - pair:   rows = 2, cols = 1
        - matrix: rows = n, cols = m
        - set:    åŒ vector
        - dict:   åŒ…å« keys, values å‘é‡
        - table:  åŒ matrix */
    rows;
    /** ç¬¬ 2 ç»´ */
    cols;
    /** å®žé™…æ•°æ®ã€‚ä¸åŒçš„ DdbForm, DdbType ä½¿ç”¨ DdbValue ä¸­ä¸åŒçš„ç±»åž‹æ¥è¡¨ç¤ºå®žé™…æ•°æ®
        The actual data. Different DdbForm, DdbType use different types in DdbValue to represent actual data */
    value;
    /** åŽŸå§‹äºŒè¿›åˆ¶æ•°æ®ï¼Œä»…åœ¨ parse_object ä¸º false æ—¶é€šè¿‡ parse_message ç”Ÿæˆçš„é¡¶å±‚å¯¹è±¡æœ‰è¿™ä¸ªå±žæ€§ */
    buffer;
    constructor(data) {
        Object.assign(this, data);
    }
    static parse(buf, le) {
        if (!buf.length)
            return new this({
                le,
                form: DdbForm.scalar,
                type: DdbType.void,
                length: 0,
                value: null
            });
        const type = buf[0];
        const form = buf[1];
        if (buf.length <= 2)
            return new this({
                le,
                form,
                type,
                length: 2,
                value: null,
            });
        // set é‡Œé¢ data åµŒå¥—äº†ä¸€ä¸ª vector, è·³è¿‡ vector çš„ type å’Œ form
        const i_data = form === DdbForm.set ? 4 : 2;
        const buf_data = buf.subarray(i_data);
        switch (form) {
            case DdbForm.scalar: {
                const [length, value] = this.parse_scalar(buf_data, le, type);
                return new this({
                    le,
                    form,
                    type,
                    length: i_data + length,
                    value,
                });
            }
            case DdbForm.vector:
            case DdbForm.pair:
            case DdbForm.set: {
                let vector = this.parse_vector(buf_data, le, type);
                vector.length += i_data;
                vector.form = form;
                return vector;
            }
            case DdbForm.table: {
                // table([
                //     [1, 2] as a,
                //     [1, 2] as b
                // ])
                // <Buffer 
                // 00 06 form = table
                // 02 00 00 00 02 00 00 00 rows = 2, cols = 2
                // 00 è¡Œåç§°
                // 61 00 62 00 åˆ—åç§° a, b
                // 04 01 form = vector, type = int
                // 02 00 00 00 01 00 00 00 cols = 2, rows = 1
                // 01 00 00 00 02 00 00 00 
                // 04 01 
                // 02 00 00 00 01 00 00 00 
                // 01 00 00 00 02 00 00 00>
                const dv = new DataView(buf.buffer, buf.byteOffset + i_data);
                const rows = dv.getUint32(0, le);
                const cols = dv.getUint32(4, le);
                const i_name_tail = buf_data.indexOf(0, 8);
                const name = this.dec.decode(buf_data.subarray(8, i_name_tail));
                const i_items_start = i_name_tail + 1;
                const [len_items, colnames] = this.parse_vector_items(buf_data.subarray(i_items_start), le, DdbType.string, cols);
                let value = new Array(cols);
                let i_start = i_items_start + len_items;
                for (let i = 0; i < cols; i++) {
                    const type = buf_data[i_start];
                    if (type === DdbType.compressed)
                        throw new Error((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('{{form}}<{{type}}> æš‚æ—¶ä¸æ”¯æŒè§£æž', { form: 'table', type: 'compress' }));
                    let col = this.parse_vector(buf_data.subarray(i_start + 2), le, type);
                    col.length += 2;
                    col.name = colnames[i];
                    value[i] = col;
                    i_start += col.length;
                }
                return new this({
                    le,
                    form,
                    type,
                    length: i_data + i_start,
                    name,
                    rows,
                    cols,
                    value,
                });
            }
            case DdbForm.dict:
            case DdbForm.chart: {
                // <Buffer 19 05 type = any, form = dict
                // 12 01 keys.type = string, keys.form = vector
                // 03 00 00 00 01 00 00 00 keys.cols = 3, keys.rows = 1
                // 63 00 62 00 61 00 
                // 19 01 values.type = any, values.form = vector
                // 03 00 00 00 01 00 00 00 values.cols = 3, values.rows = 1
                // 04 00 03 00 00 00 04 00 02 00 00 00 04 00 01 00 00 00>
                let keys = this.parse_vector(buf_data.subarray(2), le, buf_data[0]);
                keys.length += 2;
                let values = this.parse_vector(buf_data.subarray(keys.length + 2), le, buf_data[keys.length]);
                values.length += 2;
                let dict = new this({
                    le,
                    form: DdbForm.dict,
                    type,
                    length: i_data + keys.length + values.length,
                    rows: keys.rows,
                    cols: 2,
                    value: [
                        keys,
                        values
                    ],
                });
                if (form === DdbForm.dict)
                    return dict;
                else {
                    const { chartType: type, stacking, binStart: bin_start, binEnd: bin_end, binCount: bin_count, title: titles, extras, data, ...others } = dict.to_dict();
                    const [chart, x_axis, y_axis] = titles.value;
                    dict.form = DdbForm.chart;
                    dict.value = {
                        type: type.value,
                        stacking: stacking.value,
                        titles: {
                            chart,
                            x_axis,
                            y_axis,
                        },
                        ...bin_start ? { bin_start, bin_end, } : {},
                        ...bin_count ? { bin_count } : {},
                        ...extras ? (() => {
                            const { multiYAxes: multi_y_axes = false, ...extras_others } = extras.to_dict({ strip: true });
                            return {
                                extras: {
                                    multi_y_axes,
                                    ...extras_others,
                                }
                            };
                        })() : {},
                        data,
                        ...others,
                    };
                    return dict;
                }
            }
            case DdbForm.matrix: {
                // rename!(
                //     1..9$3:3,
                //     [1, 2, 3],
                //     ['c1', 'c2', 'c3']
                // )
                // <Buffer 04 03 type = int, form = matrix
                // 03 has_row_label (& 0x01) = 1, has_col_label (& 0x02) = 1
                // row labels
                // 04 01 type = int, form = vector
                // 03 00 00 00 01 00 00 00 rows = 3, cols = 1
                // 01 00 00 00 02 00 00 00 03 00 00 00 vector values
                // col labels
                // 12 01 type = string, form = vector
                // 03 00 00 00 01 00 00 00 rows = 3, cols = 1
                // 63 31 00 63 32 00 63 33 00 
                // matrix data
                // 04 03 type = matrix.type, form = matrix
                // 03 00 00 00 03 00 00 00 rows = 3, cols = 3
                const dv = new DataView(buf.buffer, buf.byteOffset + i_data);
                const label_flags = buf_data[0];
                const has_row_labels = Boolean(label_flags & 0x01);
                const has_col_labels = Boolean(label_flags & 0x02);
                let row_labels = null;
                let col_labels = null;
                let offset = 1;
                if (has_row_labels) {
                    row_labels = this.parse_vector(buf_data.subarray(offset + 2), le, buf_data[offset]);
                    row_labels.length += 2;
                    offset += row_labels.length;
                }
                if (has_col_labels) {
                    col_labels = this.parse_vector(buf_data.subarray(offset + 2), le, buf_data[offset]);
                    col_labels.length += 2;
                    offset += col_labels.length;
                }
                (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(buf_data[offset] === type, 'matrix.datatype === matrix.type');
                const rows = dv.getUint32(offset + 2, le);
                const cols = dv.getUint32(offset + 6, le);
                const [len_items, data] = this.parse_vector_items(buf_data.subarray(offset + 10), le, type, rows * cols // å‡è®¾å°äºŽ 2**32
                );
                offset += 10 + len_items;
                return new this({
                    le,
                    form,
                    type,
                    length: i_data + offset,
                    rows,
                    cols,
                    value: {
                        rows: row_labels,
                        cols: col_labels,
                        data,
                    },
                });
            }
            case DdbForm.tensor: {
                // å…ƒæ•°æ®
                const tensorType = buf[2];
                const deviceType = buf[3];
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const tensorFlags = dv.getUint32(4, le);
                const dimensions = dv.getInt32(8, le);
                const shapes = [];
                const strides = [];
                const shapeStart = 12;
                const stridesStart = shapeStart + dimensions * 8;
                const preserveValueStart = stridesStart + dimensions * 8;
                const preserveValue = dv.getBigInt64(preserveValueStart, le);
                const storageStart = preserveValueStart + 8;
                const elemCount = dv.getBigInt64(storageStart, le);
                const dataStart = storageStart + 8;
                for (let d = 0; d < dimensions; d++) {
                    const getNumOffset = d * 8;
                    shapes.push(Number(dv.getBigInt64(shapeStart + getNumOffset, le)));
                    strides.push(Number(dv.getBigInt64(stridesStart + getNumOffset, le)));
                }
                const dataBuffer = buf.subarray(dataStart);
                return new this({
                    le,
                    form,
                    type,
                    length: i_data + buf_data.length,
                    value: {
                        data_type: type,
                        tensor_type: tensorType,
                        device_type: deviceType,
                        tensor_flags: tensorFlags,
                        dimensions,
                        shape: shapes,
                        strides,
                        preserve_value: preserveValue,
                        elem_count: Number(elemCount),
                        data: dataBuffer
                    }
                });
            }
            default:
                return new this({
                    le,
                    form,
                    type,
                    length: i_data + buf_data.length,
                    value: buf_data
                });
        }
    }
    static parse_scalar(buf, le, type) {
        switch (type) {
            case DdbType.bool: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const value = dv.getInt8(0);
                return [1, value === nulls.int8 ? null : Boolean(value)];
            }
            case DdbType.void:
            case DdbType.char: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const value = dv.getInt8(0);
                return [1, value === nulls.int8 ? null : value];
            }
            case DdbType.short: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const value = dv.getInt16(0, le);
                return [2, value === nulls.int16 ? null : value];
            }
            case DdbType.int:
            // datetime
            case DdbType.date:
            case DdbType.month:
            case DdbType.time:
            case DdbType.minute:
            case DdbType.second:
            case DdbType.datetime:
            case DdbType.datehour: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const value = dv.getInt32(0, le);
                return [4, value === nulls.int32 ? null : value];
            }
            case DdbType.float: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const value = dv.getFloat32(0, le);
                return [4, value === nulls.float32 ? null : value];
            }
            case DdbType.double: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const value = dv.getFloat64(0, le);
                return [8, value === nulls.double ? null : value];
            }
            case DdbType.long:
            // timestamp
            case DdbType.timestamp:
            case DdbType.nanotime:
            case DdbType.nanotimestamp: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const value = dv.getBigInt64(0, le);
                return [8, value === nulls.int64 ? null : value];
            }
            case DdbType.string:
            case DdbType.symbol:
            case DdbType.code:
            case DdbType.handle:
            // sqlDS å‡½æ•°ä¼šè¿”å›žåŒ…å« datasource çš„ any vector
            case DdbType.datasource:
            case DdbType.functiondef:
            // mysql æ’ä»¶ connect æ–¹æ³•ä¼šè¿”å›ž resource ç±»åž‹çš„å¯¹è±¡
            case DdbType.resource: {
                const i_head = type === DdbType.functiondef ? 1 : 0;
                let i_zero = buf.indexOf(0, i_head);
                let i_end; // æ•´ä¸ªå­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬ 0ï¼‰çš„æœ«å°¾ï¼Œexcluding
                if (i_zero === -1)
                    i_end = i_zero = buf.length;
                else
                    i_end = i_zero + 1;
                // è°ƒæ•´äº† i_zero åˆ°å­—ç¬¦ä¸²ï¼ˆä¸åŒ…æ‹¬ 0ï¼‰çš„æœ«å°¾ï¼Œexcluding
                const str = this.dec.decode(buf.subarray(i_head, i_zero));
                return [
                    i_end,
                    type === DdbType.functiondef ?
                        {
                            type: buf[0],
                            name: str
                        }
                        :
                            str
                ];
            }
            case DdbType.uuid:
            case DdbType.ipaddr:
            case DdbType.int128:
                return [16, buf.slice(0, 16)];
            case DdbType.blob: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const length = dv.getUint32(0, le);
                return [4 + length, buf.slice(4, 4 + length)];
            }
            case DdbType.complex:
            case DdbType.point: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                return [16, [dv.getFloat64(0, le), dv.getFloat64(8, le)]];
            }
            case DdbType.duration: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                return [8, { unit: dv.getUint32(4, le), data: dv.getInt32(0, le) }];
            }
            case DdbType.decimal32: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const data = dv.getInt32(4, le);
                return [8, { scale: dv.getInt32(0, le), data: data === nulls.int32 ? null : data }];
            }
            case DdbType.decimal64: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const data = dv.getBigInt64(4, le);
                return [12, { scale: dv.getInt32(0, le), data: data === nulls.int64 ? null : data }];
            }
            case DdbType.decimal128: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const data = get_big_int_128(dv, 4, le);
                return [20, { scale: dv.getInt32(0, le), data: data === nulls.int128 ? null : data }];
            }
            default:
                throw new Error(String(DdbType[type] || type) + (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)(' æš‚æ—¶ä¸æ”¯æŒè§£æž'));
        }
    }
    /** parse: rows, cols, items
        è¿”å›žçš„ ddbobj.length ä¸åŒ…æ‹¬ vector çš„ type å’Œ form */
    static parse_vector(buf, le, type) {
        const dv = new DataView(buf.buffer, buf.byteOffset);
        const rows = dv.getUint32(0, le);
        let i_items_start = 8;
        if (type < 64 || type >= 128) { // æ™®é€šæ•°ç»„
            const [len_items, value] = this.parse_vector_items(buf.subarray(i_items_start), le, type, rows);
            return new this({
                le,
                form: DdbForm.vector,
                type,
                length: i_items_start + len_items,
                cols: 1,
                rows: type === DdbType.iotany ? value.length : rows,
                value,
                ...type === DdbType.iotany ? { buffer: buf } : {}
            });
        }
        else { // array vector
            // av = array(INT[], 0, 3)
            // append!(av, [1..4])
            // append!(av, [1..70000])
            // av
            // <Buffer 44 01  type = array vector, form = vector
            // 02 00 00 00 74 11 01 00 rows = 2, cols = 70004 (0x011174)
            // block 0
            // 01 00 block.rows = 1
            // 04 block.unit = 4
            // 00 reserved
            // 04 00 00 00 block.lengths = [4]
            // 01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 block.data
            // block 1
            // 01 00 block.rows = 1
            // 04 block.unit = 4
            // 00 reserved
            // 70 11 01 00 block.lengths = [70000 (0x00011170)]
            // 01 00 00 00 02 00 00 00 ... 279992 more bytes> block.data
            // decimal array vector
            // a = array(DECIMAL32(2)[], 0, 10)
            // append!(a, [
            //     [1, 2, 3], 
            //     [4, 5], 
            //     [6, 7, 8],
            //     [9, 10]
            // ])
            // print(a)
            // a
            // [[1.00,2.00,3.00],[4.00,5.00],[6.00,7.00,8.00],[9.00,10.00]]
            // <Buffer 65 01 type = 101 = 64 + 37 (decimal32) , form = vector
            // 04 00 00 00 0a 00 00 00 rows = 4, cols = 10
            // scale (åªæœ‰ decimal32 æ‰æœ‰)
            // 02 00 00 00 scale = 2
            // block 0
            // 04 00 block.rows = 4
            // 01 block.unit = 1
            // 00 reserved
            // 03 02 03 02 block.lengths = [3, 2, 3, 2]
            // 64 00 00 00 c8 00 00 00 2c 01 00 00 90 01 00 00 f4 01 00 00 58 02 00 00 bc 02 00 00 ... 12 more bytes> [100, 200, 300, ...]
            // block 1
            // ...
            const type_ = type - 64;
            const cols = dv.getUint32(4, le);
            let blocks = [];
            // decimal ä¼šåœ¨æ‰€æœ‰ blocks ä¹‹å‰å¤šä¸€ä¸ª scale
            if (is_decimal_type(type_)) {
                blocks.scale = dv.getInt32(i_items_start, le);
                i_items_start += 4;
            }
            let i_block_start = i_items_start;
            // è§£æžä¸€ä¸ª block
            for (let i_row = 0; i_row < rows;) {
                /** å¯¹åº” array vector ä¸­å…ƒç´ ä¸ªæ•° */
                const rows = dv.getUint16(i_block_start, le);
                /** æ¯ä¸ª length å ç”¨çš„å­—èŠ‚æ•° */
                const unit = dv.getUint8(i_block_start + 2);
                /** array vector æ¯ä¸ªå…ƒç´ çš„å­å…ƒç´ é•¿åº¦ */
                let lengths;
                const i_lengths_start = i_block_start + 4;
                const i_data_start = i_lengths_start + rows * unit;
                const lengths_buf = buf.slice(i_lengths_start, i_data_start);
                switch (unit) {
                    case 1:
                        lengths = lengths_buf;
                        break;
                    case 2:
                        lengths = new Uint16Array(lengths_buf.buffer);
                        break;
                    case 4:
                        lengths = new Uint32Array(lengths_buf.buffer);
                        break;
                    default:
                        throw new Error((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('array vector å­˜åœ¨éžæ³• unit: {{unit}}', { unit }));
                }
                let total_length = 0;
                for (const x of lengths)
                    total_length += x;
                let len_items;
                let data;
                switch (type_) {
                    case DdbType.decimal32:
                        len_items = total_length * 4;
                        data = new Int32Array(buf.buffer.slice(buf.byteOffset + i_data_start, buf.byteOffset + i_data_start + len_items));
                        break;
                    case DdbType.decimal64:
                        len_items = total_length * 8;
                        data = new BigInt64Array(buf.buffer.slice(buf.byteOffset + i_data_start, buf.byteOffset + i_data_start + len_items));
                        break;
                    case DdbType.decimal128:
                        len_items = total_length * 16;
                        data = new BigInt128Array(buf.buffer.slice(buf.byteOffset + i_data_start, buf.byteOffset + i_data_start + len_items));
                        break;
                    default:
                        [len_items, data] = this.parse_vector_items(buf.subarray(i_data_start), le, type - 64, total_length);
                }
                blocks.push({
                    unit,
                    rows,
                    lengths,
                    data: data
                });
                i_block_start = i_data_start + len_items;
                i_row += rows;
            }
            return new this({
                le,
                form: DdbForm.vector,
                type,
                length: i_block_start,
                cols,
                rows,
                value: blocks
            });
        }
    }
    /** æœ‰å¯èƒ½æ²¡æœ‰å­—èŠ‚å¯¹é½ï¼Œä¸èƒ½ç›´æŽ¥ä½¿ç”¨åŽŸæœ‰ message çš„ arraybuffer, ç»Ÿä¸€å¤åˆ¶å‡ºæ¥ï¼Œè®©åŽŸæœ‰ arraybuffer è¢«å›žæ”¶æŽ‰æ¯”è¾ƒå¥½ */
    static parse_vector_items(buf, le, type, length) {
        switch (type) {
            case DdbType.void:
                return [0, null];
            case DdbType.bool:
            case DdbType.char:
                return [
                    length,
                    new Int8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + length))
                ];
            case DdbType.short:
                return [
                    2 * length,
                    new Int16Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + 2 * length))
                ];
            case DdbType.int:
            // datetime
            case DdbType.date:
            case DdbType.month:
            case DdbType.time:
            case DdbType.minute:
            case DdbType.second:
            case DdbType.datetime:
            case DdbType.datehour:
                return [
                    4 * length,
                    new Int32Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + 4 * length))
                ];
            case DdbType.float:
                return [
                    4 * length,
                    new Float32Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + 4 * length))
                ];
            case DdbType.double:
                return [
                    8 * length,
                    new Float64Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + 8 * length))
                ];
            case DdbType.long:
            // timestamp
            case DdbType.timestamp:
            case DdbType.nanotime:
            case DdbType.nanotimestamp:
                return [
                    8 * length,
                    new BigInt64Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + 8 * length))
                ];
            case DdbType.string:
            case DdbType.symbol:
            case DdbType.handle:
            case DdbType.datasource:
            case DdbType.code: {
                let value = new Array(length);
                let i_head = 0, i_tail = i_head;
                for (let i = 0; i < length; i++) {
                    i_tail = buf.indexOf(0, i_head);
                    value[i] = this.dec.decode(buf.subarray(i_head, i_tail));
                    i_head = i_tail + 1;
                }
                return [i_head, value];
            }
            case DdbType.symbol_extended: {
                // <Buffer 91 01 type = symbol extended, form = vector
                // 05 00 00 00 01 00 00 00 row = 5, col = 1
                // buf:
                // 00 00 00 00 symbol base id = 0 (uint32)
                // 02 00 00 00 symbol base size = 2
                // 00 61 61 00 ä»¥ \0 åˆ†å‰²çš„å­—ç¬¦ä¸²
                // 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00>
                const dv = new DataView(buf.buffer, buf.byteOffset);
                const base_id = dv.getUint32(0, le);
                const base_size = dv.getUint32(4, le);
                let base_length = 0;
                let base = this.symbol_bases[base_id];
                // base_size ä¸º 0 æ—¶å¤ç”¨ä¹‹å‰çš„ symbol base
                if (base_size) {
                    [base_length, base] = this.parse_vector_items(buf.subarray(8), le, DdbType.string, base_size);
                    this.symbol_bases[base_id] = base;
                }
                const value_start = 8 + base_length;
                const value_end = value_start + length * 4;
                const data = new Uint32Array(buf.buffer.slice(buf.byteOffset + value_start, buf.byteOffset + value_end));
                return [
                    value_end,
                    {
                        base_id,
                        base,
                        data
                    }
                ];
            }
            case DdbType.uuid:
            case DdbType.ipaddr:
            case DdbType.int128:
                return [
                    16 * length,
                    new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + 16 * length))
                ];
            case DdbType.blob: {
                // <Buffer 20 01 type = blob, form = vector
                // 02 00 00 00 01 00 00 00 cols = 2, rows = 1
                // 04 00 00 00 61 62 63 64 
                // 04 00 00 00 61 62 63 64>
                let value = new Array(length);
                const dv = new DataView(buf.buffer, buf.byteOffset);
                let i_head = 0;
                for (let i = 0; i < length; i++) {
                    const sublen = dv.getUint32(i_head, le);
                    const i_blob_head = i_head + 4;
                    const i_blob_tail = i_blob_head + sublen;
                    value[i] = buf.slice(i_blob_head, i_blob_tail);
                    i_head = i_blob_tail;
                }
                return [i_head, value];
            }
            case DdbType.complex:
            case DdbType.point:
                return [
                    16 * length,
                    new Float64Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + 16 * length))
                ];
            case DdbType.any: {
                // [1, 2, 'a', 'aaa']
                // any[4](<Buffer 
                // 04 00 DdbType.int, DdbForm.scalar
                // 01 00 00 00 
                // 04 00 DdbType.int, DdbForm.scalar
                // 02 00 00 00 
                // 02 00 DdbType.char, DdbForm.scalar
                // 61 
                // 12 00 DdbType.string, DdbForm.scalar
                // 61 61 61 00>)
                let values = new Array(length);
                let i_head = 0;
                for (let i = 0; i < length; i++) {
                    const obj = this.parse(buf.subarray(i_head), le);
                    values[i] = obj;
                    i_head += obj.length;
                }
                return [
                    i_head,
                    values
                ];
            }
            case DdbType.iotany: {
                const [len, anys] = this.parse_vector_items(buf, le, DdbType.any, length);
                const metas = anys[0].data();
                (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(metas.length >= 2, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('iotany çš„ meta vector é•¿åº¦è‡³å°‘ä¸º 2'));
                const size = metas[0];
                // let sub_vec_count = meta_vec[1]
                let sub_vecs = new Map();
                for (let i = 1; i < length; i++) {
                    const sub_vector = anys[i];
                    const sub_type = sub_vector.type;
                    sub_vecs.set(sub_type, sub_vector.data());
                }
                return [
                    len,
                    (0,xshell__WEBPACK_IMPORTED_MODULE_3__.seq)(size, i => {
                        const type = metas[i + size + 2];
                        return type === DdbType.void ? null : sub_vecs.get(type)[metas[i + 2]];
                    })
                ];
            }
            // 25 01 type = decimal32, form = vector
            // 02 00 00 00 01 00 00 00
            // 00 00 00 00 scale = 0
            // 01 00 00 00 data[0] = 1
            // 3a 01 00 00 data[1] = 0x013a = 314
            case DdbType.decimal32: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                return [
                    4 + 4 * length,
                    {
                        scale: dv.getInt32(0, le),
                        data: new Int32Array(buf.buffer.slice(buf.byteOffset + 4, buf.byteOffset + 4 + 4 * length))
                    }
                ];
            }
            case DdbType.decimal64: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                return [
                    4 + 8 * length,
                    {
                        scale: dv.getInt32(0, le),
                        data: new BigInt64Array(buf.buffer.slice(buf.byteOffset + 4, buf.byteOffset + 4 + 8 * length))
                    }
                ];
            }
            case DdbType.decimal128: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                return [
                    4 + 16 * length,
                    {
                        scale: dv.getInt32(0, le),
                        data: new BigInt128Array(buf.buffer.slice(buf.byteOffset + 4, buf.byteOffset + 4 + 16 * length))
                    }
                ];
            }
            // ä»¥ä¸‹æƒ…å†µæ—¶, DdbType.duration å®žé™…ä¼šè¿”å›žä¸€ä¸ª any vector
            // [2y, 1M, 3d, 7H, 11m, 12s, 15ms, 16us, 17ns]
            // <Buffer 19 01 type = any, form = vector
            // 09 00 00 00 01 00 00 00 rows = 9, cols = 1
            // 24 00 type = DdbType.duration, form = scalar
            // 02 00 00 00 09 00 00 00 
            // 24 00 01 00 00 00 08 00 00 00 24 00 03 00 00 00 06 00 00 00 24 00 07 00 00 00 05 00 00 00 ... 50 more bytes>
            // å…¶ä½™æƒ…å†µ (ç›®å‰ä»… pair) ä¸‹, ä¼šè¿”å›žç‰¹æ®Šçš„ duration åºåˆ—åŒ–
            // 4 bytes data 4 bytes unit
            // 01 00 00 00 data: 1 
            // 01 00 00 00 unit: 1
            // 02 00 00 00 data: 2
            // 02 00 00 00 unit: 2
            case DdbType.duration: {
                const dv = new DataView(buf.buffer, buf.byteOffset);
                let durations = [];
                for (let i = 0; i < length; i++)
                    durations.push({
                        data: dv.getInt32(0 + 8 * i, le),
                        unit: dv.getInt32(4 + 8 * i, le)
                    });
                return [8 * length, durations];
            }
            case DdbType.compressed:
                return [
                    length,
                    new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + length))
                ];
            default:
                throw new Error((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('{{form}}<{{type}}> æš‚æ—¶ä¸æ”¯æŒè§£æž', { form: 'vector', type: get_type_name(type) }));
        }
    }
    pack() {
        const { form, type, value } = this;
        let header = new Uint8Array(2);
        header[0] = type;
        header[1] = form;
        const body = (() => {
            switch (form) {
                case DdbForm.scalar:
                    switch (type) {
                        case DdbType.void:
                            return [Uint8Array.of(Number(value))];
                        case DdbType.bool:
                            return [
                                Int8Array.of(value === null ?
                                    nulls.int8
                                    :
                                        Number(value))
                            ];
                        case DdbType.char:
                            return [
                                Int8Array.of((value === null ?
                                    nulls.int8
                                    :
                                        value))
                            ];
                        case DdbType.short:
                            return [
                                Int16Array.of(value === null ?
                                    nulls.int16
                                    :
                                        value)
                            ];
                        case DdbType.int:
                        // datetime
                        case DdbType.date:
                        case DdbType.month:
                        case DdbType.time:
                        case DdbType.minute:
                        case DdbType.second:
                        case DdbType.datetime:
                        case DdbType.datehour:
                            return [
                                Int32Array.of(value === null ?
                                    nulls.int32
                                    :
                                        value)
                            ];
                        case DdbType.float:
                            return [
                                Float32Array.of(value === null ?
                                    nulls.float32
                                    :
                                        value)
                            ];
                        case DdbType.double:
                            return [
                                Float64Array.of(value === null ?
                                    nulls.double
                                    :
                                        value)
                            ];
                        case DdbType.long:
                        // timestamp
                        case DdbType.timestamp:
                        case DdbType.nanotime:
                        case DdbType.nanotimestamp:
                            return [
                                BigInt64Array.of(value === null ?
                                    nulls.int64
                                    :
                                        value)
                            ];
                        case DdbType.string:
                        case DdbType.symbol:
                        case DdbType.code:
                        case DdbType.handle:
                        case DdbType.datasource:
                        case DdbType.resource:
                            (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(!value.includes('\0'), (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('pack æ—¶å­—ç¬¦ä¸²ä¸­é—´ä¸èƒ½å«æœ‰ \\0, å¦åˆ™ä¸Šä¼ ç»™ DolphinDB ä¼šå¯¼è‡´è¿žæŽ¥æ–­å¼€'));
                            return [
                                DdbObj.enc.encode(value),
                                Uint8Array.of(0),
                            ];
                        case DdbType.functiondef:
                            return [
                                Uint8Array.of(value.type),
                                DdbObj.enc.encode(value.name),
                                Uint8Array.of(0)
                            ];
                        case DdbType.uuid:
                        case DdbType.ipaddr:
                        case DdbType.int128:
                            return [this.value];
                        case DdbType.blob:
                            return [Uint32Array.of(this.value.byteLength), this.value];
                        case DdbType.complex:
                        case DdbType.point:
                            return [Float64Array.from(this.value)];
                        case DdbType.duration: {
                            const { unit, data } = this.value;
                            return [Int32Array.of(data, unit)];
                        }
                        case DdbType.decimal32: {
                            const { scale, data } = this.value;
                            return [Int32Array.of(scale, data === null ? nulls.int32 : data)];
                        }
                        case DdbType.decimal64: {
                            const { scale, data } = this.value;
                            return [Int32Array.of(scale), BigInt64Array.of(data === null ? nulls.int64 : data)];
                        }
                        case DdbType.decimal128: {
                            const { scale, data } = value;
                            return [Int32Array.of(scale), BigInt128Array.of(data === null ? nulls.int128 : data)];
                        }
                        default:
                            throw new Error(String(DdbType[type] || type) + (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)(' æš‚æ—¶ä¸æ”¯æŒåºåˆ—åŒ–'));
                    }
                case DdbForm.vector:
                case DdbForm.pair:
                    // pack array vector
                    if (form === DdbForm.vector && 64 <= type && type < 128)
                        return [
                            Uint32Array.of(this.rows, this.cols),
                            ...(is_decimal_type(type - 64)) ?
                                [Int32Array.of(this.value.scale)]
                                :
                                    [],
                            ...this.value.map(block => ([
                                Uint16Array.of(block.rows),
                                Uint8Array.of(block.unit, 0),
                                block.lengths,
                                block.data
                            ])).flat()
                        ];
                    if (form === DdbForm.vector && type === DdbType.iotany)
                        return [this.buffer];
                    return [
                        Uint32Array.of(this.rows, 1),
                        ...DdbObj.pack_vector_body(value, type, this.rows)
                    ];
                case DdbForm.set:
                    return [new DdbObj({ ...this, form: DdbForm.vector }).pack()];
                case DdbForm.table:
                    return [
                        Uint32Array.of(this.rows, this.cols),
                        DdbObj.enc.encode(this.name || ''),
                        // column names
                        Uint8Array.of(0),
                        ...DdbObj.pack_vector_body(this.value.map((col, i) => col.name || `col${i}`), DdbType.string, this.cols),
                        // column vectors
                        ...this.value.map(col => col.pack())
                    ];
                case DdbForm.dict:
                    return [value[0].pack(), value[1].pack()];
                case DdbForm.chart: {
                    const { type, stacking, bin_start, bin_end, bin_count, titles: { chart, x_axis, y_axis }, extras, data } = this.value;
                    const { value: [keys, values] } = new DdbDict({
                        chartType: new DdbInt(type),
                        stacking,
                        ...bin_start ? { binStart: bin_start, binEnd: bin_end } : {},
                        ...bin_count ? { binCount: bin_count } : {},
                        title: new DdbVectorString([chart, x_axis, y_axis]),
                        ...extras ? (() => {
                            const { multi_y_axes, ...extras_other } = extras;
                            return { extras: new DdbDict({ multiYAxes: multi_y_axes, ...extras_other }) };
                        })() : {},
                        data,
                    });
                    return [keys.pack(), values.pack()];
                }
                case DdbForm.matrix: {
                    const { rows, cols, data } = value;
                    return [
                        Uint8Array.of((rows ? 0x01 : 0x00) | (cols ? 0x02 : 0x00)),
                        ...rows ? [rows.pack()] : [],
                        ...cols ? [cols.pack()] : [],
                        Uint8Array.of(this.type, this.form),
                        Uint32Array.of(this.rows, this.cols),
                        ...DdbObj.pack_vector_body(data, this.type, this.rows * this.cols)
                    ];
                }
                case DdbForm.tensor: {
                    const { le, value } = this;
                    const { tensor_type, device_type, tensor_flags, dimensions, shape, strides, preserve_value, elem_count, data } = value;
                    // è®¡ç®—æ€»çš„å­—èŠ‚é•¿åº¦
                    const totalLength = 10 + dimensions * 8 * 2 + 8 + 8 + data.length; // 12 å­—èŠ‚å…ƒæ•°æ® + ç»´åº¦ä¿¡æ¯ + ä¿ç•™å€¼å’Œå…ƒç´ æ•°é‡ + æ•°æ®éƒ¨åˆ†
                    const buffer = new ArrayBuffer(totalLength);
                    const dv = new DataView(buffer);
                    const uint8Array = new Uint8Array(buffer);
                    // å†™å…¥å…ƒæ•°æ®
                    // uint8Array[0] = type;
                    // uint8Array[1] = form;
                    uint8Array[0] = tensor_type;
                    uint8Array[1] = device_type;
                    dv.setUint32(2, tensor_flags, le);
                    dv.setInt32(6, dimensions, le);
                    // å†™å…¥å½¢çŠ¶å’Œæ­¥é•¿
                    const shapeStart = 10;
                    const stridesStart = shapeStart + dimensions * 8;
                    for (let d = 0; d < dimensions; d++) {
                        dv.setBigInt64(shapeStart + d * 8, BigInt(shape[d]), le);
                        dv.setBigInt64(stridesStart + d * 8, BigInt(strides[d]), le);
                    }
                    // å†™å…¥ä¿ç•™å€¼å’Œå…ƒç´ æ•°é‡
                    const preserveValueStart = stridesStart + dimensions * 8;
                    dv.setBigInt64(preserveValueStart, preserve_value, le);
                    const storageStart = preserveValueStart + 8;
                    dv.setBigInt64(storageStart, BigInt(elem_count), le);
                    // å†™å…¥æ•°æ®
                    const dataStart = storageStart + 8;
                    uint8Array.set(data, dataStart);
                    return [uint8Array];
                }
                default:
                    throw new Error((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('vector {{type}} æš‚ä¸æ”¯æŒåºåˆ—åŒ–', { type: get_type_name(type) }));
            }
        })();
        if (!body)
            return new Uint8Array(0);
        return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.concat)([header, ...body]);
    }
    static pack_vector_body(value, type, length) {
        switch (type) {
            case DdbType.void:
                return [];
            case DdbType.bool:
            case DdbType.char:
                return [value];
            case DdbType.short:
                return [value];
            case DdbType.int:
            // datetime
            case DdbType.date:
            case DdbType.month:
            case DdbType.time:
            case DdbType.minute:
            case DdbType.second:
            case DdbType.datetime:
            case DdbType.datehour:
                return [value];
            case DdbType.float:
                return [value];
            case DdbType.double:
                return [value];
            case DdbType.long:
            // timestamp
            case DdbType.timestamp:
            case DdbType.nanotime:
            case DdbType.nanotimestamp:
                return [value];
            case DdbType.string:
            case DdbType.symbol:
            case DdbType.handle:
            case DdbType.datasource:
            case DdbType.code: {
                let bufs = new Array(length * 2);
                for (let i = 0; i < length; i++) {
                    const s = value[i];
                    (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(!s.includes('\0'), (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('pack æ—¶å­—ç¬¦ä¸²ä¸­é—´ä¸èƒ½å«æœ‰ \\0, å¦åˆ™ä¸Šä¼ ç»™ DolphinDB ä¼šå¯¼è‡´è¿žæŽ¥æ–­å¼€'));
                    bufs[2 * i] = this.enc.encode(s);
                    bufs[2 * i + 1] = Uint8Array.of(0);
                }
                return bufs;
            }
            case DdbType.uuid:
            case DdbType.ipaddr:
            case DdbType.int128:
            case DdbType.compressed:
                return [value];
            case DdbType.blob: {
                let bufs = new Array(length * 2);
                for (let i = 0; i < length; i++) {
                    const blob_value = value[i];
                    bufs[2 * i] = Uint32Array.of(blob_value.length);
                    bufs[2 * i + 1] = blob_value;
                }
                return bufs;
            }
            case DdbType.complex:
            case DdbType.point:
                return [value];
            case DdbType.duration: {
                let bufs = new Int32Array(length * 2);
                for (let i = 0; i < length; i++) {
                    const { data, unit } = value[i];
                    bufs[2 * i] = data;
                    bufs[2 * i + 1] = unit;
                }
                return [bufs];
            }
            case DdbType.any: {
                // [1, 2, 'a', 'aaa']
                // any[4](<Buffer 
                // 04 00 DdbType.int, DdbForm.scalar
                // 01 00 00 00 
                // 04 00 DdbType.int, DdbForm.scalar
                // 02 00 00 00 
                // 02 00 DdbType.char, DdbForm.scalar
                // 61 
                // 12 00 DdbType.string, DdbForm.scalar
                // 61 61 61 00>)
                let bufs = new Array(length);
                for (let i = 0; i < length; i++)
                    bufs[i] = value[i].pack();
                return bufs;
            }
            case DdbType.symbol_extended: {
                const { base_id, base, data } = value;
                return [
                    Uint32Array.of(base_id || 0, base.length),
                    ...this.pack_vector_body(base, DdbType.string, base.length),
                    data
                ];
            }
            case DdbType.decimal32:
            case DdbType.decimal64:
            case DdbType.decimal128: {
                const { scale, data } = value;
                return [Int32Array.of(scale), data];
            }
            default:
                throw new Error((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('vector {{type}} æš‚ä¸æ”¯æŒåºåˆ—åŒ–', { type: get_type_name(type) }));
        }
    }
    data(options) {
        const { form, type, value, le, rows, name } = this;
        switch (form) {
            case DdbForm.scalar:
                return convert(type, value, le, options);
            case DdbForm.vector:
            case DdbForm.pair:
            case DdbForm.set: {
                const data = converts(type, value, rows, le, options);
                return (form === DdbForm.set ? new Set(data) : data);
            }
            case DdbForm.table: {
                const cols = value;
                const jscols = cols.map(col => col.data(options));
                const keys = cols.map(({ name }) => name);
                return {
                    name: name || '',
                    columns: cols.map(({ name }) => name),
                    types: cols.map(({ type }) => type),
                    data: (0,xshell__WEBPACK_IMPORTED_MODULE_3__.seq)(rows, i => (0,xshell__WEBPACK_IMPORTED_MODULE_3__.zip_object)(keys, (0,xshell__WEBPACK_IMPORTED_MODULE_3__.seq)(cols.length, j => jscols[j][i])))
                };
            }
            case DdbForm.dict: {
                const [keys, values] = value;
                return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.zip_object)(keys.data(options), values.data(options));
            }
            case DdbForm.chart:
                return value;
            case DdbForm.matrix: {
                const ncolumns = this.cols;
                const { rows: _rows, cols: _cols, data } = value;
                const jsdata = converts(type, data, rows * ncolumns, le, options);
                return {
                    type,
                    nrows: rows,
                    ncolumns,
                    rows: _rows?.data(options),
                    columns: _cols?.data(options),
                    data: (0,xshell__WEBPACK_IMPORTED_MODULE_3__.seq)(rows, i => (0,xshell__WEBPACK_IMPORTED_MODULE_3__.seq)(ncolumns, j => jsdata[j * rows + i]))
                };
            }
            case DdbForm.tensor: {
                const { data_type, tensor_type, device_type, tensor_flags, dimensions, shape, strides, preserve_value, elem_count, data, } = this.value;
                const dataByte = ddb_tensor_bytes[data_type];
                const returnData = {
                    data_type,
                    tensor_type,
                    device_type,
                    tensor_flags,
                    dimensions,
                    shape,
                    strides,
                    preserve_value,
                    elem_count,
                    data: DdbObj.parse_tensor({ currentDim: 0, dimensions, rawData: data, le: this.le, dataByte, dataType: data_type, shape, strides })
                };
                return returnData;
            }
            default:
                throw new Error((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('{{form}} {{type}} æš‚ä¸æ”¯æŒ data()', { form, type: get_type_name(type) }));
        }
    }
    /** æž„å»º Tensor
        @param buildParams æž„å»ºå‚æ•°
        @param limit é™åˆ¶æ¯ä¸ªç»´åº¦æœ€å¤§å…ƒç´ ä¸ªæ•°ï¼ˆä»…ç”¨äºŽ logï¼Œä¸ä½œä»–ç”¨ï¼‰
        @returns  */
    static parse_tensor(buildParams, limit = -1) {
        const { currentDim, dimensions, rawData, le, dataByte, dataType, shape, strides } = buildParams;
        const tensor = [];
        const dv = new DataView(rawData.buffer, rawData.byteOffset);
        for (let i = 0; i < shape[currentDim]; i++)
            if (currentDim >= dimensions - 1) {
                if (limit > 0 && i >= limit) {
                    tensor.push('...');
                    break;
                }
                // ç›´æŽ¥è½¬æ¢åˆ°å¯¹åº”çš„æ•°ç»„
                const offset = i * dataByte * Number(strides[currentDim]);
                switch (dataType) {
                    case DdbType.bool: {
                        const value = dv.getInt8(offset);
                        tensor.push(value === nulls.int8 ? null : Boolean(value));
                        break;
                    }
                    case DdbType.char: {
                        const value = dv.getInt8(offset);
                        tensor.push(convert(dataType, value, le));
                        break;
                    }
                    case DdbType.short: {
                        const value = dv.getInt16(offset, le);
                        tensor.push(value === nulls.int16 ? null : value);
                        break;
                    }
                    case DdbType.int: {
                        const value = dv.getInt32(offset, le);
                        tensor.push(value === nulls.int32 ? null : value);
                        break;
                    }
                    case DdbType.long: {
                        const value = dv.getBigInt64(offset, le);
                        tensor.push(value === nulls.int64 ? null : value);
                        break;
                    }
                    case DdbType.float: {
                        const value = dv.getFloat32(offset, le);
                        tensor.push(value === nulls.float32 ? null : value);
                        break;
                    }
                    case DdbType.double: {
                        const value = dv.getFloat64(offset, le);
                        tensor.push(value === nulls.double ? null : value);
                        break;
                    }
                }
            }
            else {
                // èµ·ç‚¹
                const start = strides[currentDim] * i * dataByte;
                // ç»ˆç‚¹
                const end = start + strides[currentDim] * 1 * dataByte;
                tensor.push(DdbObj.parse_tensor({
                    currentDim: currentDim + 1,
                    dimensions,
                    rawData: rawData.subarray(Number(start), Number(end)),
                    le,
                    dataByte,
                    shape,
                    strides,
                    dataType
                }, limit));
            }
        return tensor;
    }
    [xshell__WEBPACK_IMPORTED_MODULE_3__.inspect.custom](depth, _options, _inspect) {
        const options = { nullstr: true, ..._options };
        const type = this.inspect_type();
        const data = (() => {
            switch (this.form) {
                case DdbForm.scalar:
                    return format(this.type, this.value, this.le, options);
                case DdbForm.vector:
                case DdbForm.pair:
                case DdbForm.set: {
                    const form = this.form;
                    function format_array(items, ellipsis) {
                        const str_items = items.join(', ') + (ellipsis ? ', ...' : '');
                        return form === DdbForm.pair ?
                            str_items
                            :
                                str_items.bracket('square');
                    }
                    if (64 <= this.type && this.type < 128) { // array vector
                        // å› ä¸º array vector ç›®å‰åªæ”¯æŒï¼šLogical, Integralï¼ˆä¸åŒ…æ‹¬ INT128, COMPRESS ç±»åž‹ï¼‰, Floating, Temporal
                        // éƒ½å¯¹åº” TypedArray ä¸­çš„ä¸€æ ¼ï¼Œæ‰€ä»¥ç›´æŽ¥æ ¹æ® index åŽ»å–å³å¯
                        // av = array(INT[], 0, 5)
                        // append!(av, [1..1])
                        // append!(av, [1..70000])
                        // append!(av, [1..1])
                        // append!(av, [1..500])
                        // ...
                        // av
                        const type_ = this.type - 64;
                        const limit = 10;
                        const nullstr = (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(null, options);
                        let array_items = new Array(Math.min(limit, this.rows));
                        let i_items = 0;
                        for (const { lengths, data } of this.value) {
                            let acc_len = 0;
                            for (const length of lengths) {
                                let items = new Array(Math.min(limit, length));
                                for (let i = 0; i < items.length; i++)
                                    switch (type_) {
                                        case DdbType.decimal32:
                                        case DdbType.decimal64:
                                        case DdbType.decimal128:
                                            const x = data[acc_len + i];
                                            if (is_decimal_null_value(type_, x))
                                                items[i] = nullstr;
                                            else {
                                                const { scale } = this.value;
                                                const s = String(x < 0 ? -x : x).padStart(scale, '0');
                                                const str = (x < 0 ? '-' : '') + (scale ? `${s.slice(0, -scale) || '0'}.${s.slice(-scale)}` : s);
                                                items[i] = options.colors ? str.green : str;
                                            }
                                            break;
                                        case DdbType.complex:
                                        case DdbType.point: {
                                            const index = acc_len + i;
                                            items[i] = format(type_, data.subarray(2 * index, 2 * (index + 1)), this.le, options);
                                            break;
                                        }
                                        case DdbType.uuid:
                                        case DdbType.int128:
                                        case DdbType.ipaddr: {
                                            const index = acc_len + i;
                                            items[i] = format(type_, data.subarray(16 * index, 16 * (index + 1)), this.le, options);
                                            break;
                                        }
                                        default:
                                            items[i] = format(type_, data[acc_len + i], this.le, options);
                                            break;
                                    }
                                array_items[i_items++] = format_array(items, length > limit);
                                acc_len += length;
                            }
                            if (i_items >= limit)
                                break;
                        }
                        return format_array(array_items, this.rows > limit);
                    }
                    switch (this.type) {
                        case DdbType.symbol_extended: {
                            const limit = 50;
                            const { base, data } = this.value;
                            let items = new Array(Math.min(limit, data.length));
                            for (let i = 0; i < items.length; i++)
                                items[i] = (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(base[data[i]], options);
                            return format_array(items, data.length > limit);
                        }
                        case DdbType.void:
                            return format(this.type, this.value, this.le, options);
                        case DdbType.uuid:
                        case DdbType.int128:
                        case DdbType.ipaddr: {
                            const limit = 10;
                            const value = this.value;
                            const len_data = value.length / 16;
                            let items = new Array(Math.min(limit, len_data));
                            for (let i = 0; i < items.length; i++)
                                items[i] = format(this.type, value.subarray(16 * i, 16 * (i + 1)), this.le, options);
                            return format_array(items, len_data > limit);
                        }
                        case DdbType.complex:
                        case DdbType.point: {
                            const limit = 20;
                            const value = this.value;
                            const len_data = value.length / 2;
                            let items = new Array(Math.min(limit, len_data));
                            for (let i = 0; i < items.length; i++)
                                items[i] = format(this.type, value.subarray(2 * i, 2 * (i + 1)), this.le, options);
                            return format_array(items, len_data > limit);
                        }
                        case DdbType.decimal32:
                        case DdbType.decimal64:
                        case DdbType.decimal128: {
                            const limit = 50;
                            const { data } = this.value;
                            let items = new Array(Math.min(limit, data.length));
                            for (let i = 0; i < items.length; i++)
                                items[i] = formati(this, i, options);
                            return format_array(items, data.length > limit);
                        }
                        default: {
                            const limit = this.type === DdbType.compressed ? 5 : 50;
                            let items = new Array(Math.min(limit, this.value.length));
                            for (let i = 0; i < items.length; i++)
                                items[i] = format(this.type, this.value[i], this.le, options);
                            return format_array(items, this.value.length > limit);
                        }
                    }
                }
                case DdbForm.tensor: {
                    const tensorVal = this.value;
                    const retd = DdbObj.parse_tensor({
                        currentDim: 0,
                        dimensions: tensorVal.dimensions,
                        rawData: tensorVal.data,
                        le: this.le,
                        dataByte: ddb_tensor_bytes[tensorVal.data_type],
                        dataType: tensorVal.data_type,
                        shape: tensorVal.shape,
                        strides: tensorVal.strides
                    }, 5);
                    return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(retd, options).replaceAll("\'...\'", '...');
                }
            }
            if (this.value instanceof Uint8Array)
                return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)((0,xshell__WEBPACK_IMPORTED_MODULE_3__.typed_array_to_buffer)(this.value), options);
            return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(this.value, options);
        })();
        // å¦‚æžœç±»åž‹ä¸º string åˆ™ä¸éœ€è¦åŠ ä¸Šç±»åž‹å
        if (this.form === DdbForm.scalar && this.type === DdbType.string)
            return data;
        else
            return `${options.colors ? type.blue : type}(${this.name ? `${(0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(this.name, options)}, ` : ''}${data})`;
    }
    inspect_type() {
        const tname = DdbType[this.type];
        switch (this.form) {
            case DdbForm.scalar:
                if (this.type === DdbType.functiondef)
                    return `functiondef<${DdbFunctionType[this.value.type]}>`;
                return tname;
            case DdbForm.vector:
                if (64 <= this.type && this.type < 128)
                    return `${DdbType[this.type - 64]}[][${this.rows}]`;
                return `${tname}[${this.rows}]`;
            case DdbForm.pair:
                return `pair<${tname}>`;
            case DdbForm.set:
                return `set<${tname}>[${this.rows}]`;
            case DdbForm.table:
                return `table[${this.rows}r][${this.cols}c]`;
            case DdbForm.dict:
                return `dict<${DdbType[this.value[0].type]}, ${DdbType[this.value[1].type]}>[${this.rows}]`;
            case DdbForm.chart:
                return `chart<${DdbChartType[this.value.type]}>`;
            case DdbForm.matrix:
                return `matrix<${tname}>[${this.rows}r][${this.cols}c]`;
            case DdbForm.tensor:
                return `tensor<${generate_array_type(DdbType[this.value.data_type], this.value.shape)}>`;
            default:
                return `${DdbForm[this.form]} ${tname}`;
        }
    }
    /** è‡ªåŠ¨è½¬æ¢ Convertable ä¸º DdbObj */
    static to_ddbobj(value) {
        if (value && value instanceof DdbObj)
            return value;
        if (value === undefined)
            return new DdbVoid();
        if (value === null)
            return new DdbVoid(DdbVoidType.null);
        const type = typeof value;
        switch (type) {
            case 'string':
                return new DdbString(value);
            case 'boolean':
                return new DdbBool(value);
            default:
                throw new Error((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('ä¸èƒ½è‡ªåŠ¨è½¬æ¢ {{type}} è‡³ DdbObj', { type }));
        }
    }
    /** è½¬æ¢ js æ•°ç»„ä¸º DdbObj[] */
    static to_ddbobjs(values) {
        return values.map(value => this.to_ddbobj(value));
    }
    /** å°† table è½¬æ¢ä¸º rowsï¼Œç©ºå€¼è½¬æ¢ä¸º null
        @deprecated ç”¨ data() */
    to_rows() {
        (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(this.form === DdbForm.table, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('form å¿…é¡»æ˜¯ DdbForm.table, å¦åˆ™ä¸èƒ½ to_rows'));
        let rows = new Array(this.rows);
        for (let i = 0; i < this.rows; i++) {
            let row = {};
            for (let j = 0; j < this.cols; j++) {
                const { type, name, value: values } = this.value[j]; // column
                switch (type) {
                    case DdbType.bool: {
                        const value = values[i];
                        row[name] = value === nulls.int8 ?
                            null
                            :
                                Boolean(value);
                        break;
                    }
                    case DdbType.char:
                        row[name] = values[i] === nulls.int8 ? null : values[i];
                        break;
                    case DdbType.short:
                        row[name] = values[i] === nulls.int16 ? null : values[i];
                        break;
                    case DdbType.int:
                    case DdbType.date:
                    case DdbType.month:
                    case DdbType.time:
                    case DdbType.minute:
                    case DdbType.second:
                    case DdbType.datetime:
                    case DdbType.datehour:
                        row[name] = values[i] === nulls.int32 ? null : values[i];
                        break;
                    case DdbType.long:
                    case DdbType.timestamp:
                    case DdbType.nanotime:
                    case DdbType.nanotimestamp:
                        row[name] = values[i] === nulls.int64 ? null : values[i];
                        break;
                    case DdbType.int128:
                        row[name] = values[i] === nulls.int128 ? null : values[i];
                        break;
                    case DdbType.float:
                        row[name] = values[i] === nulls.float32 ? null : values[i];
                        break;
                    case DdbType.double:
                        row[name] = values[i] === nulls.double ? null : values[i];
                        break;
                    case DdbType.decimal32:
                    case DdbType.decimal64:
                    case DdbType.decimal128:
                        row[name] = is_decimal_null_value(type, values[i]) ? null : values[i];
                        break;
                    case DdbType.ipaddr:
                        row[name] = values.subarray(16 * i, 16 * (i + 1));
                        break;
                    case DdbType.symbol_extended: {
                        const { base, data } = values;
                        row[name] = base[data[i]];
                        break;
                    }
                    default:
                        row[name] = values[i];
                }
            }
            rows[i] = row;
        }
        return rows;
    }
    to_dict({ strip, deep, } = {}) {
        (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(this.form === DdbForm.dict, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('this.form å¿…é¡»æ˜¯ DdbForm.dict, å¦åˆ™ä¸èƒ½è°ƒç”¨ to_dict è½¬æ¢ä¸º js object'));
        const [{ value: keys, type: key_type }, { value: values, type: value_type }] = this.value;
        (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(key_type === DdbType.string && dictables.has(value_type), (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('å½“å‰åªæ”¯æŒè‡ªåŠ¨è½¬æ¢ dict<string, any | ...dictables> ä¸º js object'));
        (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(!(deep && !strip), (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('deep = true æ—¶å¿…é¡»è®¾ç½® strip = true'));
        let obj = {};
        for (let i = 0; i < this.rows; i++) {
            const key = keys[i];
            if (value_type === DdbType.any) {
                let value = values[i];
                if (deep && value.form === DdbForm.dict)
                    obj[key] = value.to_dict({ strip, deep });
                else
                    obj[key] = strip ? value.value : value;
            }
            else
                obj[key] = values[i];
        }
        return obj;
    }
}
/** æ ¹æ® DdbType èŽ·å–å…¶åç§°ï¼Œarray vector type è‡ªåŠ¨åœ¨åŽé¢åŠ ä¸Š [] */
function get_type_name(type) {
    return `${DdbType[type] || type}${64 <= type && type < 128 ? '[]' : ''}`;
}
function is_decimal_type(type) {
    return type === DdbType.decimal32 || type === DdbType.decimal64 || type === DdbType.decimal128;
}
function is_decimal_null_value(type, value) {
    return ((value === nulls.int128 && type === DdbType.decimal128) ||
        (value === nulls.int64 && type === DdbType.decimal64) ||
        (value === nulls.int32 && type === DdbType.decimal32));
}
function get_duration_unit(code) {
    let str = String.fromCharCode((code >> 24) & 0xff);
    str += String.fromCharCode((code >> 16) & 0xff);
    str += String.fromCharCode((code >> 8) & 0xff);
    str += String.fromCharCode(code & 0xff);
    return str;
}
/** æ•´æ•°ä¸€å®šç”¨è¿™ä¸ª number formatter, InspectOptions.decimals ä¸ä¼ ä¹Ÿç”¨è¿™ä¸ª */
let default_formatter = new Intl.NumberFormat('en-US', { maximumFractionDigits: 20 });
let _decimals = 20;
let _grouping = true;
/** ç¼“å­˜ï¼Œä¸ºäº†ä¼˜åŒ–æ€§èƒ½ï¼Œé€šå¸¸ options.decimals éƒ½æ˜¯ä¸å˜çš„ */
let _formatter = new Intl.NumberFormat('en-US', { maximumFractionDigits: 20 });
/** ç”¨æ¥å¤„ç†æ—¶å·®  To deal with jet lag */
let _datetime_formatter = new Intl.DateTimeFormat('zh-CN', { dateStyle: 'short', timeStyle: 'medium', timeZone: 'UTC', hour12: false });
/** æ ¹æ® DdbType æ ¼å¼åŒ–å•ä¸ªå…ƒç´  (value) ä¸ºå­—ç¬¦ä¸²ï¼Œç©ºå€¼è¿”å›ž 'null' å­—ç¬¦ä¸² */
function format(type, value, le, options = {}) {
    const { grouping = true, timestamp = 'ms' } = options;
    const formatter = (() => {
        const decimals = options.decimals ?? _decimals;
        if (decimals !== _decimals || grouping !== _grouping) {
            _decimals = decimals;
            _grouping = grouping;
            default_formatter = new Intl.NumberFormat('en-US', { maximumFractionDigits: 20, useGrouping: grouping });
            _formatter = new Intl.NumberFormat('en-US', {
                maximumFractionDigits: decimals,
                minimumFractionDigits: decimals,
                useGrouping: grouping
            });
        }
        return options.decimals === undefined || options.decimals === null ? default_formatter : _formatter;
    })();
    function format_time(formatter, _null) {
        if (value === null || value === _null)
            return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(null, options);
        let str;
        // formatter å¯èƒ½ä¼šåœ¨ value ä¸å±žäºŽ new Date() æœ‰æ•ˆå€¼æ—¶ï¼Œè°ƒç”¨  æŠ›å‡ºé”™è¯¯ï¼Œè¿™é‡Œç»Ÿä¸€å¤„ç†
        try {
            str = formatter(value, (type === DdbType.timestamp && timestamp === 's') ? 'YYYY.MM.DD HH:mm:ss' : undefined);
        }
        catch (error) {
            if (error instanceof RangeError)
                str = 'Invalid Date';
            else
                throw error;
        }
        return options.colors ? str.magenta : str;
    }
    switch (type) {
        case DdbType.void: {
            const str = value === DdbVoidType.default ? 'default' : 'null';
            return options.colors ? str.grey : str;
        }
        case DdbType.bool:
            return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)((value === null || value === nulls.int8) ?
                null
                :
                    Boolean(value), options);
        case DdbType.char:
            return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)((value === null || value === nulls.int8) ?
                null
                :
                    // ascii printable
                    // http://facweb.cs.depaul.edu/sjost/it212/documents/ascii-pr.htm
                    (32 <= value && value <= 126) ?
                        String.fromCharCode(value)
                        :
                            value, options);
        case DdbType.short:
            return value === null || value === nulls.int16 ?
                (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(null, options)
                :
                    options.colors ?
                        default_formatter.format(value).green
                        :
                            default_formatter.format(value);
        case DdbType.int:
            return value === null || value === nulls.int32 ?
                (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(null, options)
                :
                    options.colors ?
                        default_formatter.format(value).green
                        :
                            default_formatter.format(value);
        case DdbType.long:
            return value === null || value === nulls.int64 ?
                (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(null, options)
                :
                    options.colors ?
                        default_formatter.format(value).green
                        :
                            default_formatter.format(value);
        case DdbType.date:
            return format_time(date2str, nulls.int32);
        case DdbType.month:
            return format_time(month2str, nulls.int32);
        case DdbType.time:
            return format_time(time2str, nulls.int32);
        case DdbType.minute:
            return format_time(minute2str, nulls.int32);
        case DdbType.second:
            return format_time(second2str, nulls.int32);
        case DdbType.datetime:
            return format_time(datetime2str, nulls.int32);
        case DdbType.timestamp:
            return format_time(timestamp2str, nulls.int64);
        case DdbType.nanotime:
            return format_time(nanotime2str, nulls.int64);
        case DdbType.nanotimestamp:
            return format_time(nanotimestamp2str, nulls.int64);
        case DdbType.float:
            return value === null || value === nulls.float32 ?
                (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(null, options)
                :
                    options.colors ?
                        formatter.format(value).green
                        :
                            formatter.format(value);
        case DdbType.double:
            return value === null || value === nulls.double ?
                (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(null, options)
                :
                    options.colors ?
                        formatter.format(value).green
                        :
                            formatter.format(value);
        case DdbType.symbol:
        case DdbType.string:
        case DdbType.handle:
        case DdbType.datasource:
        case DdbType.code:
        case DdbType.resource:
            return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(value, options);
        case DdbType.uuid:
            return options.colors ?
                uuid2str(value, le).cyan
                :
                    uuid2str(value, le);
        case DdbType.functiondef:
            return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(value.name, options);
        case DdbType.datehour:
            return format_time(datehour2str, nulls.int32);
        case DdbType.ipaddr:
            return options.colors ?
                ipaddr2str(value, le).cyan
                :
                    ipaddr2str(value, le);
        case DdbType.int128:
            return options.colors ?
                int1282str(value, le).green
                :
                    int1282str(value, le);
        case DdbType.blob:
            return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(value.length > 100 ?
                DdbObj.dec.decode(value.subarray(0, 98)) + 'â€¦'
                :
                    DdbObj.dec.decode(value), options);
        case DdbType.point: {
            const [x, y] = value;
            return `(${format(DdbType.double, x, le, options)}, ${format(DdbType.double, y, le, options)})`;
        }
        case DdbType.complex: {
            const [x, y] = value;
            return `${format(DdbType.double, x, le, options)}+${format(DdbType.double, y, le, options)}i`;
        }
        case DdbType.duration: {
            const { data, unit } = value;
            const str = `${data}${DdbDurationUnit[unit] ?? get_duration_unit(unit)}`;
            return options.colors ? str.magenta : str;
        }
        case DdbType.decimal32:
        case DdbType.decimal64:
        case DdbType.decimal128: {
            const { scale, data } = value;
            if (data === null ||
                is_decimal_null_value(type, data))
                return 'null';
            const s = String(data < 0 ? -data : data).padStart(scale, '0');
            const str = (data < 0 ? '-' : '') + (scale ? `${s.slice(0, -scale) || '0'}.${s.slice(-scale)}` : s);
            return options.colors ? str.green : str;
        }
        default:
            return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(value, options);
    }
}
/** æ ¼å¼åŒ–å‘é‡ã€é›†åˆä¸­çš„ç¬¬ index é¡¹ä¸ºå­—ç¬¦ä¸²ï¼Œç©ºå€¼è¿”å›ž 'null' å­—ç¬¦ä¸²  formatted vector, the index-th item in the collection is a string, a null value returns a 'null' string */
function formati(obj, index, options = {}) {
    (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(index < obj.rows, 'index < obj.rows');
    if (obj.type < 64 || obj.type >= 128) // æ™®é€šæ•°ç»„
        switch (obj.type) {
            case DdbType.symbol_extended: {
                const { base, data } = obj.value;
                return format(DdbType.string, base[data[index]], obj.le, options);
            }
            case DdbType.void:
                return format(obj.type, obj.value, obj.le, options);
            case DdbType.uuid:
            case DdbType.int128:
            case DdbType.ipaddr:
                return format(obj.type, obj.value.subarray(16 * index, 16 * (index + 1)), obj.le, options);
            case DdbType.blob: {
                const value = obj.value[index];
                return value.length > 100 ?
                    DdbObj.dec.decode(value.subarray(0, 98)) + 'â€¦'
                    :
                        DdbObj.dec.decode(value);
            }
            case DdbType.complex:
            case DdbType.point:
                return format(obj.type, obj.value.subarray(2 * index, 2 * (index + 1)), obj.le, options);
            case DdbType.decimal32:
            case DdbType.decimal64:
            case DdbType.decimal128: {
                const { scale, data } = obj.value;
                const x = data[index];
                if (is_decimal_null_value(obj.type, x))
                    return '';
                const s = String(x < 0 ? -x : x).padStart(scale, '0');
                const str = (x < 0 ? '-' : '') + (scale ? `${s.slice(0, -scale) || '0'}.${s.slice(-scale)}` : s);
                return options.colors ? str.green : str;
            }
            default:
                return format(obj.type, obj.value[index], obj.le, options);
        }
    else { // array vector
        // å› ä¸º array vector ç›®å‰åªæ”¯æŒï¼šLogical, Integralï¼ˆä¸åŒ…æ‹¬ INT128, COMPRESS ç±»åž‹ï¼‰, Floating, Temporal
        // éƒ½å¯¹åº” TypedArray ä¸­çš„ä¸€æ ¼ï¼Œæ‰€ä»¥ lengths.length ç­‰äºŽ block ä¸­çš„ row çš„ä¸ªæ•°
        // av = array(INT[], 0, 5)
        // append!(av, [1..1])
        // append!(av, [1..70000])
        // append!(av, [1..1])
        // append!(av, [1..500])
        // ...
        // av
        const type_ = obj.type - 64;
        let offset = 0;
        const nullstr = (0,xshell__WEBPACK_IMPORTED_MODULE_3__.inspect)(null, options);
        for (const { lengths, data, rows } of obj.value) {
            let acc_len = 0;
            if (offset + rows <= index) {
                offset += rows;
                continue; // è·³è¿‡è¿™ä¸ª block
            }
            for (const length of lengths) {
                if (offset < index) {
                    offset++;
                    acc_len += length;
                    continue;
                }
                const limit = 10;
                let items = new Array(Math.min(limit, length));
                for (let i = 0; i < items.length; i++)
                    switch (type_) {
                        case DdbType.decimal32:
                        case DdbType.decimal64:
                        case DdbType.decimal128:
                            const x = data[acc_len + i];
                            if (is_decimal_null_value(type_, x))
                                items[i] = nullstr;
                            else {
                                const { scale } = obj.value;
                                const s = String(x < 0 ? -x : x).padStart(scale, '0');
                                const str = (x < 0 ? '-' : '') + (scale ? `${s.slice(0, -scale) || '0'}.${s.slice(-scale)}` : s);
                                items[i] = options.colors ? str.green : str;
                            }
                            break;
                        case DdbType.complex:
                        case DdbType.point: {
                            const index = acc_len + i;
                            items[i] = format(type_, data.subarray(2 * index, 2 * (index + 1)), obj.le, options);
                            break;
                        }
                        case DdbType.uuid:
                        case DdbType.int128:
                        case DdbType.ipaddr: {
                            const index = acc_len + i;
                            items[i] = format(type_, data.subarray(16 * index, 16 * (index + 1)), obj.le, options);
                            break;
                        }
                        default:
                            items[i] = format(type_, data[acc_len + i], obj.le, options);
                            break;
                    }
                return (items.join(', ') + (length > limit ? ', ...' : '')).bracket('square');
            }
        }
    }
}
function convert(type, value, le, { blob = 'string', char = 'string', timestamp = 'ms' } = {}) {
    switch (type) {
        case DdbType.void:
            return value === DdbVoidType.null ? null : undefined;
        case DdbType.char:
            return char === 'string'
                ? value === null || value === nulls.int8
                    ? ''
                    : // ascii printable
                        // http://facweb.cs.depaul.edu/sjost/it212/documents/ascii-pr.htm
                        (32 <= value && value <= 126)
                            ? String.fromCharCode(value)
                            : `\\${value}`
                : value;
        case DdbType.bool:
            return value === null || value === nulls.int8 ? null : Boolean(value);
        case DdbType.short:
            return value === null || value === nulls.int16 ? null : value;
        case DdbType.int:
            return value === null || value === nulls.int32 ? null : value;
        case DdbType.float:
            return value === null || value === nulls.float32 ? null : value;
        case DdbType.double:
            return value === null || value === nulls.double ? null : value;
        case DdbType.long:
            return value === null || value === nulls.int64 ? null : value;
        case DdbType.functiondef:
            return value.name;
        case DdbType.string:
        case DdbType.symbol:
        case DdbType.code:
        case DdbType.handle:
        case DdbType.datasource:
        case DdbType.resource:
        case DdbType.compressed:
            return value;
        case DdbType.blob:
            return blob === 'string' ? (0,xshell__WEBPACK_IMPORTED_MODULE_3__.decode)(value) : value;
        case DdbType.complex:
        case DdbType.point: {
            const [x, y] = value;
            return [
                x === null || x === nulls.double ? null : x,
                y === null || y === nulls.double ? null : y,
            ];
        }
        case DdbType.date:
        case DdbType.month:
        case DdbType.time:
        case DdbType.minute:
        case DdbType.second:
        case DdbType.datetime:
        case DdbType.datehour:
        case DdbType.timestamp:
        case DdbType.nanotime:
        case DdbType.nanotimestamp:
        case DdbType.duration:
        case DdbType.uuid:
        case DdbType.ipaddr:
        case DdbType.int128:
        // decimal ç±»åž‹è½¬æ¢ä¸ºå›ºå®šä½æ•°å°æ•°çš„ string ä¸ä¸¢å¤±ç²¾åº¦ï¼Œä¸€èˆ¬ä¹Ÿæ˜¯å±•ç¤ºç”¨
        case DdbType.decimal32:
        case DdbType.decimal64:
        case DdbType.decimal128:
            return format(type, value, le, { colors: false, timestamp });
        default:
            throw new Error(String(DdbType[type] || type) + (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)(' æš‚æ—¶ä¸æ”¯æŒè½¬æ¢ä¸º js å¯¹è±¡'));
    }
}
/** è½¬æ¢ä¸€ä¸ªå‘é‡åˆ° js åŽŸç”Ÿæ•°ç»„ */
function converts(type, value, rows, le, options) {
    if (type < 64 || type >= 128)
        switch (type) {
            // å¯ä»¥ç›´æŽ¥ç”¨ä¸‹æ ‡å–å€¼å†è½¬æ¢çš„ç±»åž‹
            case DdbType.bool:
            case DdbType.short:
            case DdbType.int:
            case DdbType.float:
            case DdbType.double:
            case DdbType.long:
            case DdbType.date:
            case DdbType.month:
            case DdbType.time:
            case DdbType.minute:
            case DdbType.second:
            case DdbType.datetime:
            case DdbType.datehour:
            case DdbType.timestamp:
            case DdbType.nanotime:
            case DdbType.nanotimestamp:
            case DdbType.duration:
            case DdbType.string:
            case DdbType.symbol:
            case DdbType.code:
            case DdbType.handle:
            case DdbType.datasource:
            case DdbType.resource:
            case DdbType.functiondef:
            case DdbType.blob:
            case DdbType.compressed:
                return Array.prototype.map.call(value, (x) => convert(type, x, le, options));
            case DdbType.char:
                if (options?.chars === 'binary')
                    return value;
                else
                    return Array.prototype.map.call(value, (x) => convert(type, x, le, options));
            case DdbType.void:
                return [];
            case DdbType.symbol_extended: {
                const { base, data } = value;
                return Array.prototype.map.call(data, (x) => base[x]);
            }
            case DdbType.complex:
            case DdbType.point:
                return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.seq)(rows, i => {
                    const x = value[2 * i];
                    const y = value[2 * i + 1];
                    return [x === nulls.double ? null : x, y === nulls.double ? null : y];
                });
            case DdbType.uuid:
            case DdbType.ipaddr:
            case DdbType.int128:
                return (0,xshell__WEBPACK_IMPORTED_MODULE_3__.seq)(rows, i => convert(type, value.subarray(16 * i, 16 * (i + 1)), le, options));
            case DdbType.decimal32:
            case DdbType.decimal64:
            case DdbType.decimal128: {
                const { scale, data } = value;
                return Array.prototype.map.call(data, (x) => {
                    if (is_decimal_null_value(type, x))
                        return '';
                    const s = String(x < 0 ? -x : x).padStart(scale, '0');
                    return (x < 0 ? '-' : '') + (scale ? `${s.slice(0, -scale) || '0'}.${s.slice(-scale)}` : s);
                });
            }
            case DdbType.any:
                return value.map(x => x.data(options));
            case DdbType.iotany:
                return value;
            default:
                throw new Error(String(DdbType[type] || type) + '[]' + (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)(' æš‚æ—¶ä¸æ”¯æŒè½¬æ¢ä¸º js å¯¹è±¡'));
        }
    else { // array vector
        const type_ = type - 64;
        return value.map(({ lengths, data, rows }) => {
            let acc_len = 0;
            return Array.prototype.map.call(lengths, (length) => {
                switch (type_) {
                    case DdbType.decimal32:
                    case DdbType.decimal64:
                    case DdbType.decimal128:
                        return converts(type_, { scale: value.scale, data: data.subarray(acc_len, acc_len += length) }, length, le, options);
                    case DdbType.complex:
                    case DdbType.point:
                        return converts(type_, data.subarray(acc_len, acc_len += 2 * length), length, le, options);
                    case DdbType.uuid:
                    case DdbType.int128:
                    case DdbType.ipaddr:
                        return converts(type_, data.subarray(acc_len, acc_len += 16 * length), length, le, options);
                    default:
                        return converts(type_, data.subarray(acc_len, acc_len += length), length, le, options);
                }
            });
        }).flat();
    }
}
/** æž„é€  void ç±»åž‹ï¼Œé»˜è®¤ä¸º `DdbVoidType.undefined` */
class DdbVoid extends DdbObj {
    constructor(value = DdbVoidType.undefined) {
        super({
            form: DdbForm.scalar,
            type: DdbType.void,
            value,
        });
    }
}
class DdbBool extends DdbObj {
    constructor(value) {
        super({
            form: DdbForm.scalar,
            type: DdbType.bool,
            value,
        });
    }
}
class DdbChar extends DdbObj {
    constructor(value) {
        super({
            form: DdbForm.scalar,
            type: DdbType.char,
            value: typeof value === 'string' ?
                value.charCodeAt(0)
                :
                    value
        });
    }
}
class DdbInt extends DdbObj {
    constructor(value) {
        super({
            form: DdbForm.scalar,
            type: DdbType.int,
            value,
        });
    }
}
class DdbString extends DdbObj {
    constructor(value) {
        super({
            form: DdbForm.scalar,
            type: DdbType.string,
            value
        });
    }
}
class DdbLong extends DdbObj {
    constructor(value) {
        if (typeof value === 'number')
            value = BigInt(value);
        super({
            form: DdbForm.scalar,
            type: DdbType.long,
            value
        });
    }
}
class DdbDouble extends DdbObj {
    constructor(value) {
        super({
            form: DdbForm.scalar,
            type: DdbType.double,
            value
        });
    }
}
class DdbDateTime extends DdbObj {
    constructor(value) {
        super({
            form: DdbForm.scalar,
            type: DdbType.datetime,
            value: get_ddb_time_value('DdbDateTime', value)
        });
    }
}
class DdbTimeStamp extends DdbObj {
    constructor(value) {
        super({
            form: DdbForm.scalar,
            type: DdbType.timestamp,
            value: get_ddb_time_value('DdbTimeStamp', value)
        });
    }
}
class DdbNanoTimeStamp extends DdbObj {
    constructor(value) {
        super({
            form: DdbForm.scalar,
            type: DdbType.nanotimestamp,
            value: get_ddb_time_value('DdbNanoTimeStamp', value)
        });
    }
}
class DdbDate extends DdbObj {
    constructor(value) {
        super({
            form: DdbForm.scalar,
            type: DdbType.date,
            value: get_ddb_time_value('DdbDate', value)
        });
    }
}
function get_ddb_time_value(classname, value) {
    if (value === null)
        return null;
    if (classname === 'DdbNanoTimeStamp' && typeof value === 'string')
        return str2nanotimestamp(value);
    let date;
    if (value === undefined)
        date = new Date();
    else if (typeof value === 'number' || typeof value === 'string')
        date = new Date(value);
    else if (value instanceof Date)
        date = value;
    else if (dayjs__WEBPACK_IMPORTED_MODULE_0__.isDayjs(value))
        date = new Date(value.valueOf());
    else
        throw new Error((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('value ä¸èƒ½è½¬æ¢ä¸º {{classname}}', { classname }));
    switch (classname) {
        case 'DdbDateTime':
            return (date.getTime() - 1000 * 60 * date.getTimezoneOffset()) / 1000;
        case 'DdbTimeStamp':
            return BigInt(date.getTime() - 1000 * 60 * date.getTimezoneOffset());
        case 'DdbNanoTimeStamp':
            return BigInt(date.getTime() - 1000 * 60 * date.getTimezoneOffset()) * 1000000n;
        case 'DdbDate':
            return Math.floor((date.getTime() - 1000 * 60 * date.getTimezoneOffset()) / (1000 * 3600 * 24));
    }
}
class DdbBlob extends DdbObj {
    constructor(value) {
        (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(value, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('new DdbBlob ä¸èƒ½ä¼ ç©ºçš„ value'));
        super({
            form: DdbForm.scalar,
            type: DdbType.blob,
            value: value instanceof Uint8Array ? value : new Uint8Array(value)
        });
    }
}
class DdbPair extends DdbObj {
    constructor(l, r = null) {
        super({
            form: DdbForm.pair,
            type: DdbType.int,
            rows: 2,
            cols: 1,
            value: Int32Array.of(l === null ? nulls.int32 : l, r === null ? nulls.int32 : r)
        });
    }
}
class DdbFunction extends DdbObj {
    constructor(name, type) {
        super({
            form: DdbForm.scalar,
            type: DdbType.functiondef,
            value: { type, name }
        });
    }
}
class DdbVectorInt extends DdbObj {
    constructor(ints, name) {
        super({
            form: DdbForm.vector,
            type: DdbType.int,
            rows: ints.length,
            cols: 1,
            value: ints instanceof Int32Array ?
                ints
                :
                    Int32Array.from(ints, v => v === null ?
                        nulls.int32
                        :
                            v),
            name,
        });
    }
}
class DdbVectorLong extends DdbObj {
    constructor(longs, name) {
        super({
            form: DdbForm.vector,
            type: DdbType.long,
            rows: longs.length,
            cols: 1,
            value: longs instanceof BigInt64Array ?
                longs
                :
                    BigInt64Array.from(longs, v => v === null ?
                        nulls.int64
                        :
                            BigInt(v)),
            name,
        });
    }
}
class DdbVectorDouble extends DdbObj {
    constructor(doubles, name) {
        super({
            form: DdbForm.vector,
            type: DdbType.double,
            rows: doubles.length,
            cols: 1,
            value: doubles instanceof Float64Array ?
                doubles
                :
                    Float64Array.from(doubles, v => v === null ?
                        nulls.double
                        :
                            v),
            name,
        });
    }
}
class DdbVectorString extends DdbObj {
    constructor(strings, name) {
        super({
            form: DdbForm.vector,
            type: DdbType.string,
            rows: strings.length,
            cols: 1,
            value: strings,
            name,
        });
    }
}
class DdbVectorAny extends DdbObj {
    constructor(objs, name) {
        super({
            form: DdbForm.vector,
            type: DdbType.any,
            rows: objs.length,
            cols: 1,
            value: DdbObj.to_ddbobjs(objs),
            name,
        });
    }
}
class DdbVectorSymbol extends DdbObj {
    constructor(strings, name) {
        let map = new Map([
            ['', 0]
        ]);
        let data = new Uint32Array(strings.length);
        for (let i = 0; i < strings.length; i++) {
            const x = strings[i];
            let index = map.get(x);
            if (index === undefined) {
                index = map.size;
                map.set(x, index);
            }
            data[i] = index;
        }
        super({
            form: DdbForm.vector,
            type: DdbType.symbol_extended,
            rows: strings.length,
            cols: 1,
            value: {
                base: [...map.keys()],
                base_id: null,
                data,
            },
            name
        });
    }
}
class DdbSetInt extends DdbObj {
    constructor(ints) {
        super({
            form: DdbForm.set,
            type: DdbType.int,
            rows: ints instanceof Set ?
                ints.size
                :
                    ints.length,
            cols: 1,
            value: ints instanceof Int32Array ?
                ints
                :
                    Int32Array.from(ints, v => v === null ?
                        nulls.int32
                        :
                            v),
        });
    }
}
class DdbSetDouble extends DdbObj {
    constructor(doubles) {
        super({
            form: DdbForm.set,
            type: DdbType.double,
            rows: doubles instanceof Set ?
                doubles.size
                :
                    doubles.length,
            cols: 1,
            value: doubles instanceof Int32Array ?
                doubles
                :
                    Int32Array.from(doubles, v => v === null ?
                        nulls.int32
                        :
                            v),
        });
    }
}
class DdbSetString extends DdbObj {
    constructor(strings) {
        if (strings instanceof Set)
            strings = [...strings];
        super({
            form: DdbForm.set,
            type: DdbType.string,
            rows: strings.length,
            cols: 1,
            value: strings
        });
    }
}
/** æž„é€  DdbDict å¯¹è±¡ï¼Œæ”¯æŒä¸¤ç§ç”¨æ³•:  Constructs a DdbDict object, which supports two usages:
     - ä¼ å…¥ç±»åž‹æ˜¯ DdbVectorObj çš„ keys, values ä¸¤ä¸ªå‚æ•°ç›´æŽ¥ç»„æˆ dict<keys.type, values.type> çš„ DdbDict
         The incoming type is the keys of DdbObj<DdbVectorValue>, and the two parameters of values directly form the DdbDict of dict<keys.type, values.type>
     - ä¼ å…¥ js object (ç±»åž‹æ˜¯ Record<string, boolean | string | DdbObj>), è‡ªåŠ¨è½¬æ¢ä¸º dict<string, any> çš„ DdbDict
         Pass in js object (type is Record<string, boolean | string | DdbObj>), automatically converted to DdbDict of dict<string, any> */
class DdbDict extends DdbObj {
    constructor(arg0, arg1) {
        if (arg1)
            super({
                form: DdbForm.dict,
                type: arg1.type,
                rows: arg0.rows,
                cols: 2,
                value: [arg0, arg1]
            });
        else {
            const keys = Object.keys(arg0);
            super({
                form: DdbForm.dict,
                type: DdbType.any,
                rows: keys.length,
                cols: 2,
                value: [
                    new DdbVectorString(keys),
                    new DdbVectorAny(Object.values(arg0))
                ]
            });
        }
    }
}
class DdbTable extends DdbObj {
    constructor(columns, name = '') {
        super({
            form: DdbForm.table,
            type: DdbType.void,
            rows: columns[0].rows,
            cols: columns.length,
            name,
            value: columns,
        });
    }
}
function date2ms(date) {
    // å°† server çš„æœ¬åœ°æ—¶é—´ (ä»¥ ms ä¸ºå•ä½ï¼Œ1970.01.01 00:00:00 ä½œä¸ºé›¶ç‚¹) ä½œä¸º UTC-0 æ ¼å¼åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åŽæ ¹æ®æœ¬åœ°çš„æ—¶åŒºè§£æžè¿™ä¸ªå­—ç¬¦ä¸²è½¬æ¢ä¸º UTC-8
    // æœ¬åœ°çš„æ—¶åŒºä¸Žå®žé™…çš„æ—¶é—´å€¼ç›¸å…³ï¼ŒgetTimezoneOffset() å¯èƒ½ä¼šå—åˆ°å¤ä»¤æ—¶ (DST) çš„å½±å“ï¼Œä¸èƒ½ä½¿ç”¨
    // å¾—åˆ°çš„ utc æ¯«ç§’æ•°äº¤ç»™ js date æˆ–è€… dayjs åŽ»æ ¼å¼åŒ–
    if (date === null || date === nulls.int32)
        return null;
    const ms = 1000 * 3600 * 24 * date;
    return timestamp2ms(ms);
}
function date2str(date, format = 'YYYY.MM.DD') {
    return (date === null || date === nulls.int32) ?
        'null'
        :
            dayjs__WEBPACK_IMPORTED_MODULE_0__(date2ms(date)).format(format);
}
function month2ms(month) {
    return (month === null || month === nulls.int32) ?
        null
        :
            dayjs__WEBPACK_IMPORTED_MODULE_0__(month2str(month), 'YYYY.MM[M]').valueOf();
}
function month2str(month) {
    if (month === null || month === nulls.int32)
        return 'null';
    if (month < 0)
        return String(month);
    const _month = month % 12;
    const year = Math.trunc(month / 12);
    return `${String(year).padStart(4, '0')}.${String(_month + 1).padStart(2, '0')}M`;
}
function time2ms(time) {
    return (time === null || time === nulls.int32) ?
        null
        :
            timestamp2ms(time);
}
function time2str(time, format = 'HH:mm:ss.SSS') {
    return (time === null || time === nulls.int32) ?
        'null'
        :
            dayjs__WEBPACK_IMPORTED_MODULE_0__(time2ms(time)).format(format);
}
function minute2ms(minute) {
    if (minute === null || minute === nulls.int32)
        return null;
    const ms = 60 * 1000 * minute;
    return timestamp2ms(ms);
}
function minute2str(minute, format = 'HH:mm[m]') {
    return (minute === null || minute === nulls.int32) ?
        'null'
        :
            dayjs__WEBPACK_IMPORTED_MODULE_0__(minute2ms(minute)).format(format);
}
function second2ms(second) {
    if (second === null || second === nulls.int32)
        return null;
    const ms = 1000 * second;
    return timestamp2ms(ms);
}
function second2str(second, format = 'HH:mm:ss') {
    return (second === null || second === nulls.int32) ?
        'null'
        :
            dayjs__WEBPACK_IMPORTED_MODULE_0__(second2ms(second)).format(format);
}
function datetime2ms(datetime) {
    if (datetime === null || datetime === nulls.int32)
        return null;
    const date = new Date(1000 * datetime);
    return new Date(`${_datetime_formatter.format(date)}.${String(date.getUTCMilliseconds()).padStart(3, '0')}`).valueOf();
}
function datetime2str(datetime, format = 'YYYY.MM.DD HH:mm:ss') {
    return (datetime === null || datetime === nulls.int32) ?
        'null'
        :
            dayjs__WEBPACK_IMPORTED_MODULE_0__(datetime2ms(datetime)).format(format);
}
/** _datetime_formatter.format ä¼šåœ¨ date ä¸º Invalid Date æ—¶æŠ›å‡ºé”™è¯¯ */
function timestamp2ms(timestamp) {
    if (timestamp === null || timestamp === nulls.int64)
        return null;
    const date = new Date(Number(timestamp));
    return new Date(`${_datetime_formatter.format(date)}.${String(date.getUTCMilliseconds()).padStart(3, '0')}`).valueOf();
}
/** format timestamp (bigint) to string
    - timestamp: bigint value
    - format?:
        æ ¼å¼ä¸²ï¼Œé»˜è®¤æ˜¯ `YYYY.MM.DD HH:mm:ss.SSS`  format string, default to `YYYY.MM.DD HH:mm:ss.SSS`
        https://day.js.org/docs/en/parse/string-format#list-of-all-available-parsing-tokens */
function timestamp2str(timestamp, format = 'YYYY.MM.DD HH:mm:ss.SSS') {
    return (timestamp === null || timestamp === nulls.int64) ?
        'null'
        :
            dayjs__WEBPACK_IMPORTED_MODULE_0__(timestamp2ms(timestamp)).format(format);
}
function datehour2ms(datehour) {
    if (datehour === null || datehour === nulls.int32)
        return null;
    const ms = 1000 * 3600 * datehour;
    return timestamp2ms(ms);
}
function datehour2str(datehour, format = 'YYYY.MM.DDTHH') {
    if (datehour === null || datehour === nulls.int32)
        return 'null';
    const ms = 1000 * 3600 * datehour;
    return dayjs__WEBPACK_IMPORTED_MODULE_0__(timestamp2ms(ms)).format(format);
}
/** parse timestamp string to bigint value
    - str: timestamp string, å¦‚æžœä¸ºç©ºå­—ç¬¦ä¸²æˆ– 'null' ä¼šè¿”å›žå¯¹åº”çš„ç©ºå€¼ (nulls.int64)
        timestamp string, If it is an empty string or 'null', it will return the corresponding empty value (nulls.int64)
    - format?:
        å¯¹åº”ä¼ å…¥å­—ç¬¦ä¸²çš„æ ¼å¼ä¸²ï¼Œé»˜è®¤æ˜¯ `YYYY.MM.DD HH:mm:ss.SSS`
        The format string corresponding to the incoming string, the default is `YYYY.MM.DD HH:mm:ss.SSS`
        https://day.js.org/docs/en/parse/string-format#list-of-all-available-parsing-tokens */
function str2timestamp(str, format = 'YYYY.MM.DD HH:mm:ss.SSS') {
    if (!str || str === 'null')
        return nulls.int64;
    (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(str.length === format.length, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('timestamp å­—ç¬¦ä¸²é•¿åº¦å¿…é¡»ç­‰äºŽæ ¼å¼ä¸²é•¿åº¦'));
    const ms = dayjs__WEBPACK_IMPORTED_MODULE_0__(str, format).valueOf();
    return BigInt(-(1000 * 60 * new Date(ms).getTimezoneOffset()) +
        ms);
}
function nanotime2ns(nanotime) {
    return nanotimestamp2ns(nanotime);
}
function nanotime2str(nanotime, format = 'HH:mm:ss.SSSSSSSSS') {
    if (nanotime === null || nanotime === nulls.int64)
        return 'null';
    if (nanotime < 0n)
        return String(nanotime);
    const i_second_start = format.indexOf('ss');
    (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(i_second_start !== -1, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('æ ¼å¼ä¸²å¿…é¡»åŒ…å«ç§’çš„æ ¼å¼ (ss)'));
    const i_second_end = i_second_start + 2;
    const i_nanosecond_start = format.indexOf('SSSSSSSSS', i_second_end);
    (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(i_nanosecond_start !== -1, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('æ ¼å¼ä¸²å¿…é¡»åŒ…å«çº³ç§’çš„æ ¼å¼ (SSSSSSSSS)'));
    const ms = Number(nanotime) / 1000000;
    return (dayjs__WEBPACK_IMPORTED_MODULE_0__(timestamp2ms(ms)).format(format.slice(0, i_second_end)) +
        format.slice(i_second_end, i_nanosecond_start) +
        String(nanotime % 1000000000n).padStart(9, '0'));
}
function nanotimestamp2ns(nanotimestamp) {
    if (nanotimestamp === null || nanotimestamp === nulls.int64)
        return null;
    const date = new Date(Number(nanotimestamp / 1000000n));
    return BigInt(new Date(`${_datetime_formatter.format(date)}.${String(date.getUTCMilliseconds()).padStart(3, '0')}`).valueOf()) * 1000000n + nanotimestamp % 1000000n;
}
/** format nanotimestamp value (bigint) to string
    - nanotimestamp: bigint value
    - format?:
        æ ¼å¼ä¸²ï¼Œé»˜è®¤æ˜¯ `YYYY.MM.DD HH:mm:ss.SSSSSSSSS`  format string, default is `YYYY.MM.DD HH:mm:ss.SSSSSSSSS`
        ç§’çš„æ ¼å¼ä¸º ss (å¿…é¡»åŒ…å«); çº³ç§’çš„æ ¼å¼ä¸º SSSSSSSSS (å¿…é¡»åŒ…å«)  Seconds are in the format ss (must be included); nanoseconds are in the format SSSSSSSSS (must be included)
        https://day.js.org/docs/en/parse/string-format#list-of-all-available-parsing-tokens
*/
function nanotimestamp2str(nanotimestamp, format = 'YYYY.MM.DD HH:mm:ss.SSSSSSSSS') {
    // tests:
    // nanotimestamp2str(0n)
    // nanotimestamp2str(-1n)
    // nanotimestamp2str(-9_9999_9999n)
    // nanotimestamp2str(-10_0000_0000n)
    // nanotimestamp2str(-10_0000_0001n)
    if (nanotimestamp === null || nanotimestamp === nulls.int64)
        return 'null';
    const i_second_start = format.indexOf('ss');
    (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(i_second_start !== -1, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('æ ¼å¼ä¸²å¿…é¡»åŒ…å«ç§’çš„æ ¼å¼ (ss)'));
    const i_second_end = i_second_start + 2;
    const i_nanosecond_start = format.indexOf('SSSSSSSSS', i_second_end);
    (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(i_nanosecond_start !== -1, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('æ ¼å¼ä¸²å¿…é¡»åŒ…å«çº³ç§’çš„æ ¼å¼ (SSSSSSSSS)'));
    const remainder = nanotimestamp % 1000000000n;
    const borrow = remainder < 0n;
    const ms = Number((nanotimestamp - remainder + (borrow ? -1000000000n : 0n)) / 1000000n);
    return (dayjs__WEBPACK_IMPORTED_MODULE_0__(_datetime_formatter.format(new Date(ms))).format(format.slice(0, i_second_end)) +
        format.slice(i_second_end, i_nanosecond_start) +
        String(borrow ?
            (remainder + 1000000000n) % 1000000000n
            :
                remainder).padStart(9, '0'));
}
/** parse nano timestamp string to bigint value
    - str: nano timestamp string, å¦‚æžœä¸ºç©ºå­—ç¬¦ä¸²æˆ– 'null' ä¼šè¿”å›žå¯¹åº”çš„ç©ºå€¼ (nulls.int64)
        nano timestamp string, If it is an empty string or 'null', it will return the corresponding empty value (nulls.int64)
    - format?:
        å¯¹åº”ä¼ å…¥å­—ç¬¦ä¸²çš„æ ¼å¼ä¸²ï¼Œé»˜è®¤æ˜¯ `YYYY.MM.DD HH:mm:ss.SSSSSSSSS`
        ç§’çš„æ ¼å¼ä¸º ss (å¿…é¡»åŒ…å«); çº³ç§’çš„æ ¼å¼ä¸º SSSSSSSSS (å¿…é¡»åŒ…å«)
        https://day.js.org/docs/en/parse/string-format#list-of-all-available-parsing-tokens
        The format string corresponding to the incoming string, the default is `YYYY.MM.DD HH:mm:ss.SSSSSSSSS`
        Seconds are in the format ss (must be included); nanoseconds are in the format SSSSSSSSS (must be included) */
function str2nanotimestamp(str, format = 'YYYY.MM.DD HH:mm:ss.SSSSSSSSS') {
    if (!str || str === 'null')
        return nulls.int64;
    (0,xshell__WEBPACK_IMPORTED_MODULE_3__.check)(str.length === format.length, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('nanotimestamp å­—ç¬¦ä¸²é•¿åº¦å¿…é¡»ç­‰äºŽæ ¼å¼ä¸²é•¿åº¦'));
    const i_second_start = format.indexOf('ss');
    (0,xshell__WEBPACK_IMPORTED_MODULE_3__.check)(i_second_start !== -1, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('æ ¼å¼ä¸²å¿…é¡»åŒ…å«ç§’çš„æ ¼å¼ (ss)'));
    const i_second_end = i_second_start + 2;
    const i_nanosecond_start = format.indexOf('SSSSSSSSS', i_second_end);
    (0,xshell__WEBPACK_IMPORTED_MODULE_3__.check)(i_nanosecond_start !== -1, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('æ ¼å¼ä¸²å¿…é¡»åŒ…å«çº³ç§’çš„æ ¼å¼ (SSSSSSSSS)'));
    const ms = dayjs__WEBPACK_IMPORTED_MODULE_0__(str.slice(0, i_second_end), format.slice(0, i_second_end)).valueOf();
    return (BigInt(-(1000 * 60 * new Date(ms).getTimezoneOffset()) +
        ms) * 1000000n
        +
            BigInt(str.slice(i_nanosecond_start, i_nanosecond_start + 9)));
}
function ipaddr2str(buffer, le = true, ipv6) {
    let buf = buffer;
    if (le)
        buf = buffer.slice().reverse();
    const i_non_zero = buf.findIndex(x => x !== 0);
    if (ipv6 ||
        i_non_zero !== -1 && i_non_zero < 12) // ipv6
        return buf2ipaddr([...buf]).toString();
    else // ipv4
        return buf.subarray(12).join('.');
}
function uuid2str(buffer, le = true) {
    const str = int1282str(buffer, le);
    return `${str.slice(0, 8)}-${str.slice(8, 12)}-${str.slice(12, 16)}-${str.slice(16, 20)}-${str.slice(20)}`;
}
function int1282str(buffer, le = true) {
    let buf = buffer;
    if (le)
        buf = buffer.slice().reverse();
    return [...buf].map(x => x.toString(16)
        .padStart(2, '0')).join('');
}
const winsize = 10000;
class DdbConnectionError extends Error {
    name = 'DdbConnectionError';
    cause;
    url;
    // è¿™é‡Œä¸ä¿ç•™ ddb çš„å¼•ç”¨ï¼Œä¼šå¯¼è‡´æ— æ³•åºåˆ—åŒ–
    constructor(url, error) {
        super(error?.message || `${url} ${(0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('è¿žæŽ¥å‡ºé”™äº†ï¼Œå¯èƒ½ç”±äºŽç½‘ç»œåŽŸå› è¿žæŽ¥å·²è¢«å…³é—­ï¼Œæˆ–æœåŠ¡å™¨æ–­å¼€è¿žæŽ¥')}`, { cause: error });
        this.url = url;
        if (error)
            this.cause = error;
    }
}
class DdbDatabaseError extends Error {
    name = 'DdbDatabaseError';
    url;
    // è¿™é‡Œä¸ä¿ç•™ ddb çš„å¼•ç”¨ï¼Œä¼šå¯¼è‡´æ— æ³•åºåˆ—åŒ–
    id;
    type;
    options;
    constructor(message, url, type, options, id) {
        super(message);
        this.url = url;
        this.type = type;
        this.options = options;
        this.id = id;
    }
}
/** SQL Standrd æ ‡å‡†ç±»åž‹ */
var SqlStandard;
(function (SqlStandard) {
    SqlStandard[SqlStandard["DolphinDB"] = 0] = "DolphinDB";
    SqlStandard[SqlStandard["Oracle"] = 1] = "Oracle";
    SqlStandard[SqlStandard["MySQL"] = 2] = "MySQL";
})(SqlStandard || (SqlStandard = {}));
class DDB {
    /** å½“å‰çš„ session id (http æˆ– tcp) */
    sid = '0';
    /** utf-8 text decoder */
    dec = new TextDecoder('utf-8');
    enc = new TextEncoder();
    /** DolphinDB WebSocket URL
        e.g. `ws://127.0.0.1:8848/`, `wss://dolphindb.com` */
    url;
    /** ä¸ºæ‰€æœ‰ websocket æ“ä½œåŠ é”ï¼ŒåŒ…æ‹¬è®¾ç½® this.on_message, this.on_error, websocket.send */
    lwebsocket = new xshell__WEBPACK_IMPORTED_MODULE_3__.Lock();
    /** little endian (server) */
    le = true;
    /** little endian (client) */
    static le_client = Boolean(new Uint8Array(Uint32Array.of(1).buffer)[0]);
    /** æ˜¯å¦åœ¨å»ºç«‹è¿žæŽ¥åŽè‡ªåŠ¨ç™»å½•ï¼Œé»˜è®¤ true  Whether to automatically log in after the connection is established, the default is true */
    autologin = true;
    /** DolphinDB ç™»å½•ç”¨æˆ·å  DolphinDB username */
    username = 'admin';
    /** DolphinDB ç™»å½•å¯†ç   DolphinDB password */
    password = '123456';
    /** python session flag (2048) */
    python = false;
    /** è¡¨ç¤ºæœ¬æ¬¡ä¼šè¯æ‰§è¡Œçš„ SQL æ ‡å‡† */
    sql = SqlStandard.DolphinDB;
    /** æ˜¯å¦ä¸ºæµæ•°æ®è¿žæŽ¥ï¼Œéžæµæ•°æ®è¿™ä¸ªå­—æ®µæ’ä¸º null  Whether it is a streaming data connection, this field is always null for non-streaming data */
    streaming = null;
    /** æ˜¯å¦æ‰“å°æ¯ä¸ª rpc çš„ä¿¡æ¯ç”¨äºŽè°ƒè¯• */
    verbose = false;
    /** websocket è¿žæŽ¥æ‰€ä½¿ç”¨çš„ http ä»£ç† */
    proxy;
    // --- å†…éƒ¨é€‰é¡¹, çŠ¶æ€
    print_message_buffer = false;
    print_object_buffer = false;
    print_message = true;
    parse_object = true;
    heartbeat_aborter;
    /** åœ¨ websocket æ”¶åˆ°çš„ç¬¬ä¸€ä¸ª error æ—¶ï¼Œ
        åœ¨ connect_websocket çš„ on_error å›žè°ƒä¸­æž„é€  DdbConnectionError å¹¶ä¿å­˜åˆ° DDB å¯¹è±¡ä¸Šï¼Œ
        è¿™ä¸ª error çš„é”™è¯¯ä¿¡æ¯æœ€å‡†ç¡® */
    error;
    /** DdbMessage listeners */
    listeners = [];
    /** é¦–æ¬¡ connect è¿žæŽ¥çš„ promise, åŽé¢çš„ connect è°ƒç”¨éƒ½è¿”å›žè¿™ä¸ª */
    pconnect;
    /** é¦–æ¬¡å®šä¹‰ pnode_run çš„ promiseï¼Œä¿è¯å¹¶å‘è°ƒç”¨ rpc æ—¶åªå®šä¹‰ä¸€æ¬¡ pnode_run */
    ppnode_run;
    /** é¦–æ¬¡å®šä¹‰ invoke çš„ promiseï¼Œä¿è¯å¹¶å‘è°ƒç”¨ rpc æ—¶åªå®šä¹‰ä¸€æ¬¡ invoke */
    pinvoke;
    /** é¦–æ¬¡å®šä¹‰ jsrpc çš„ promiseï¼Œä¿è¯å¹¶å‘è°ƒç”¨ rpc æ—¶åªå®šä¹‰ä¸€æ¬¡ jsrpc */
    pjsrpc;
    get connected() {
        return !this.error && this.lwebsocket.resource?.readyState === xshell__WEBPACK_IMPORTED_MODULE_3__.WebSocketOpen;
    }
    /**
        ä½¿ç”¨ WebSocket URL åˆå§‹åŒ–è¿žæŽ¥åˆ° DolphinDB çš„å®žä¾‹ï¼ˆä¸å»ºç«‹å®žé™…çš„ç½‘ç»œè¿žæŽ¥ï¼‰
        Initialize an instance of DolphinDB Client using the WebSocket URL (without establishing an actual network connection)
        - url: DolphinDB WebSocket URL. e.g.ï¼š`ws://127.0.0.1:8848`
        - options?: DdbOptions
            - autologin?: æ˜¯å¦åœ¨å»ºç«‹è¿žæŽ¥åŽè‡ªåŠ¨ç™»å½•ï¼Œé»˜è®¤ `true`  Whether to log in automatically after establishing a connection, default `true`
            - username?: DolphinDB ç™»å½•ç”¨æˆ·åï¼Œé»˜è®¤ `'admin'`  DolphinDB username, default `'admin'`
            - password?: DolphinDB ç™»å½•å¯†ç ï¼Œé»˜è®¤ `'123456'`  DolphinDB password, default `'123456'`
            - python?: è®¾ç½® python session flagï¼Œé»˜è®¤ `false`  set python session flag, default `false`
            - streaming?: è®¾ç½®è¯¥é€‰é¡¹åŽï¼Œè¯¥ WebSocket è¿žæŽ¥åªç”¨äºŽæµæ•°æ®  When this option is set, the WebSocket connection is only used for streaming data
            - verbose?: æ˜¯å¦æ‰“å°æ¯ä¸ª rpc çš„ä¿¡æ¯ç”¨äºŽè°ƒè¯•
            - sql?: è®¾ç½®å½“å‰ä¼šè¯æ‰§è¡Œçš„ sql æ ‡å‡†, è¯·ä½¿ç”¨ SqlStandard æžšä¸¾è¿›è¡Œä¼ å‚ï¼Œé»˜è®¤ `DolphinDB`
        
        @example
        let ddb = new DDB('ws://127.0.0.1:8848')
        
        // ä½¿ç”¨ HTTPS åŠ å¯†  Encrypt with HTTPS
        let ddbsecure = new DDB('wss://dolphindb.com', {
            autologin: true,
            username: 'admin',
            password: '123456',
            python: false
        }) */
    constructor(url, options = {}) {
        this.url = url;
        if (options.verbose !== undefined)
            this.verbose = options.verbose;
        if (options.autologin !== undefined)
            this.autologin = options.autologin;
        if (options.username !== undefined)
            this.username = options.username;
        if (options.password !== undefined)
            this.password = options.password;
        if (options.python !== undefined)
            this.python = options.python;
        if (options.sql !== undefined)
            this.sql = options.sql;
        if (options.streaming !== undefined)
            this.streaming = options.streaming;
        if (options.proxy)
            this.proxy = options.proxy;
    }
    on_message(buffer, websocket) {
        throw new Error((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('è¿™æ˜¯åœ¨è°ƒç”¨ this.rpc ä¹‹å‰é»˜è®¤çš„ on_message, ä¸åº”è¯¥è¢«è°ƒç”¨åˆ°ï¼Œé™¤éžå»ºç«‹è¿žæŽ¥åŽ server å…ˆæŽ¨é€äº† message'));
    }
    on_error() {
        // è¿™é‡Œçš„å®žçŽ°ä¸€å®šä¼šè¢« connect, rpc ä¸­çš„å®žçŽ°è¦†ç›–
    }
    /** è°ƒç”¨åŽä¼šç¡®ä¿å’Œæ•°æ®åº“çš„è¿žæŽ¥æ˜¯æ­£å¸¸çš„ (this.connected === true)ï¼Œå¦åˆ™æŠ›å‡ºé”™è¯¯
        è¿™ä¸ªæ–¹æ³•æ˜¯å¹‚ç­‰çš„ï¼Œé¦–æ¬¡è°ƒç”¨å»ºç«‹å®žé™…çš„ WebSocket è¿žæŽ¥åˆ° URL å¯¹åº”çš„ DolphinDBï¼Œç„¶åŽæ‰§è¡Œè‡ªåŠ¨ç™»å½•ï¼Œ
        å¦‚æžœæ˜¯æµæ•°æ®è¿žæŽ¥ï¼Œè¿˜ä¼šè°ƒç”¨ publishTable è®¢é˜…æµè¡¨
        åŽç»­è°ƒç”¨æ£€æŸ¥ä¸Šé¢çš„æ¡ä»¶
        è¿žæŽ¥æ–­å¼€åŽç¦æ­¢å†æ¬¡è°ƒç”¨ connect é‡è¿žåŽŸæœ‰ ddb å¯¹è±¡ï¼Œåº”è¯¥é€šè¿‡ new DDB() çš„æ–¹å¼æ–°å»ºè¿žæŽ¥å¯¹è±¡ï¼ŒåŽŸå› æ˜¯ï¼š
        1. on_error å›žè°ƒå’ŒæŸä¸ª websocket ç»‘å®šäº†ï¼Œä¸æ–¹ä¾¿è§£ç»‘åŽé‡æ–°ç»‘å®š
        2. session æ˜¯æœ‰çŠ¶æ€çš„ï¼Œé‡è¿žä¹Ÿæ— æ³•æ¢å¤ä¹‹å‰çš„çŠ¶æ€
        3. æ–­çº¿åŽæ‰€æœ‰ä¹‹å‰çš„ ddb.call, ddb.eval éƒ½åº”è¯¥æŠ›å‡ºè¿žæŽ¥é”™è¯¯
        
        After calling, it will ensure that the connection with the database is normal (this.connected === true), otherwise an error will be thrown
        This method is idempotent, the first call establishes an actual WebSocket connection to the DolphinDB corresponding to the URL, and subsequent calls check the above conditions
        After the connection is disconnected, it is forbidden to call connect again to reconnect the original ddb object. You should use new DDB() to create a new connection object because:
        1. The on_error callback is bound to a certain websocket, and it is inconvenient to unbind and rebind
        2. The session is stateful, and the previous state cannot be restored even after reconnection
        3. After disconnection, all previous ddb.call, ddb.eval should throw a connection error */
    async connect() {
        if (this.connected)
            return;
        if (this.error)
            throw this.error;
        const { resource: websocket } = this.lwebsocket;
        if (websocket && (websocket.readyState === xshell__WEBPACK_IMPORTED_MODULE_3__.WebSocketClosing || websocket.readyState === xshell__WEBPACK_IMPORTED_MODULE_3__.WebSocketClosed))
            throw this.error = new DdbConnectionError(this.url);
        return this.pconnect ??= new Promise(async (resolve, reject) => {
            this.on_error = () => {
                reject(this.error /* ä¸€å®šæœ‰ï¼Œä¸éœ€è¦å† || new DdbConnectionError(this)  */);
            };
            try {
                let url = new URL(this.url);
                if (this.streaming?.filters?.expression)
                    url.searchParams.set('filter', this.streaming.filters.expression.trim());
                // è¿žæŽ¥å»ºç«‹ä¹‹å‰åº”è¯¥ä¸ä¼šæœ‰åˆ«çš„è°ƒç”¨å ç”¨ this.lwebsocket
                this.lwebsocket.resource = await (0,xshell__WEBPACK_IMPORTED_MODULE_3__.connect_websocket)(url, {
                    protocols: this.streaming ? ['streaming'] : this.python ? ['python'] : undefined,
                    proxy: this.proxy,
                    on_message: (buffer, websocket) => {
                        this.on_message(new Uint8Array(buffer), websocket);
                    },
                    on_error: error => {
                        this.error ??= new DdbConnectionError(this.url, error);
                        this.heartbeat_aborter?.abort();
                        this.on_error();
                    },
                    on_close: () => {
                        this.heartbeat_aborter?.abort();
                    }
                });
            }
            catch (error) {
                this.error ??= new DdbConnectionError(this.url, error);
                reject(this.error);
                return;
            }
            try {
                (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(this.connected);
                await this.rpc('connect', { skip_connection_check: true });
                if (this.streaming)
                    await this.subscribe();
                else
                    // å®šæ—¶æ‰§è¡Œä¸€æ¬¡ç©ºè„šæœ¬ä½œä¸ºå¿ƒè·³æ£€æŸ¥ï¼Œé¿å…å› ä¸º nat è¶…æ—¶å¯¼è‡´ tcp è¿žæŽ¥æ–­å¼€
                    (async () => {
                        this.heartbeat_aborter = new AbortController();
                        while (true) {
                            // è¿žæŽ¥ä¸»åŠ¨å…³é—­æ—¶ä»Žå¾ªçŽ¯é€€å‡ºé˜²æ­¢å½±å“ node.js é€€å‡º
                            try {
                                await (0,xshell__WEBPACK_IMPORTED_MODULE_3__.delay)(1000 * 60 * 4.5, { signal: this.heartbeat_aborter.signal });
                            }
                            catch {
                                break;
                            }
                            if (this.connected)
                                try {
                                    await this.eval('');
                                }
                                catch (error) {
                                    console.log((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('{{time}} å¿ƒè·³æ£€æµ‹å¤±è´¥ï¼Œè¿žæŽ¥å·²æ–­å¼€', { time: new Date().to_formal_str() }), error);
                                    break;
                                }
                            else
                                break;
                        }
                    })();
                resolve();
            }
            catch (error) {
                this.error ??= error;
                reject(error);
            }
        });
    }
    get_rpc_options({ urgent = false, secondary = false, async: _async = false, pickle = false, clear = false, api = false, compress = false, cancellable = true, priority = urgent ? 8 : 4, parallelism = 8, root_id = '', limit, } = {}) {
        let flag = 0;
        if (urgent)
            flag += 1;
        if (secondary)
            flag += 2;
        if (_async)
            flag += 4;
        if (pickle)
            flag += 8;
        if (clear)
            flag += 16;
        if (api)
            flag += 32;
        if (compress)
            flag += 64;
        // python session
        if (this.python)
            flag += 2048;
        // sql standrd
        flag += 2 ** 19 * this.sql;
        const options = [
            flag,
            cancellable ? 1 : 0,
            priority,
            parallelism,
            ...limit ? [
                root_id,
                limit,
            ] : [],
        ];
        return options.join('_');
    }
    disconnect() {
        this.heartbeat_aborter?.abort();
        const { resource } = this.lwebsocket;
        if (resource) {
            const { readyState } = resource;
            if (readyState !== xshell__WEBPACK_IMPORTED_MODULE_3__.WebSocketClosed && readyState !== xshell__WEBPACK_IMPORTED_MODULE_3__.WebSocketClosing)
                // è¿™é‡Œä¸èŽ·å– lockï¼Œç›´æŽ¥å…³é—­è¿žæŽ¥
                resource.close(1000);
        }
    }
    /** (å†…éƒ¨ä½¿ç”¨çš„æ–¹æ³•) rpc through websocket (function/script/variable command)
        æœªè¿žæŽ¥åˆ° DDB æ—¶è°ƒç”¨ä¼šè‡ªåŠ¨è¿žæŽ¥ï¼Œè¿žæŽ¥æ–­å¼€æ—¶è°ƒç”¨ä¼šæŠ›å‡º DdbConnectionError
        When the DDB is not connected, the call will be automatically connected. When the connection is disconnected, the call will throw the DdbConnectionError
        - type: API ç±»åž‹: 'script' | 'function' | 'variable' | 'connect'
        - options:
            - urgent?: å†³å®š `è¡Œä¸ºæ ‡è¯†` é‚£ä¸€è¡Œå­—ç¬¦ä¸²çš„å–å€¼ï¼ˆåªé€‚ç”¨äºŽ script å’Œ functionï¼‰
            - vars?: type === 'variable' æ—¶å¿…ä¼ ï¼Œvariable æŒ‡ä»¤ä¸­å¾…ä¸Šä¼ çš„å˜é‡å
            - listener?: å¤„ç†æœ¬æ¬¡ rpc æœŸé—´çš„æ¶ˆæ¯ (DdbMessage)
            - parse_object?: åœ¨æœ¬æ¬¡ rpc æœŸé—´è®¾ç½® parse_object, ç»“æŸåŽæ¢å¤åŽŸæœ‰
                ä¸º false æ—¶è¿”å›žçš„ DdbObj ä»…å«æœ‰ buffer å’Œ leï¼Œä¸åšè§£æžï¼Œä»¥ä¾¿åŽç»­è½¬å‘ã€åºåˆ—åŒ–
            - skip_connection_check?: åœ¨é¦–æ¬¡ await ddb.connect() å»ºç«‹è¿žæŽ¥æ—¶ä¸èƒ½å†æ¬¡è°ƒç”¨ await this.connect() ç¡®ä¿è¿žæŽ¥çŠ¶æ€ï¼Œä¼šå¯¼è‡´å¾ªçŽ¯ä¾èµ–ï¼Œ
                å°†è¿™ä¸ª flag è®¾ä¸º true è·³è¿‡è¿žæŽ¥çŠ¶æ€æ£€æŸ¥ */
    async rpc(type, options) {
        // ä¿ç•™è°ƒç”¨æ ˆä¿¡æ¯
        const id = (0,xshell__WEBPACK_IMPORTED_MODULE_3__.genid)() % 1000;
        let error = new DdbDatabaseError('', this.url, type, options, id);
        if (!options.skip_connection_check)
            await this.connect();
        const { script, func, args: _args = [], vars = [], urgent, listener, on_more_messages, } = options;
        if (func === 'pnode_run')
            try {
                await (this.ppnode_run ??= this.eval(this.python ?
                    '\n' +
                        'def pnode_run (nodes, func_name, args, add_node_alias):\n' +
                        '    nargs = size(args)\n' +
                        '    func = funcByName(func_name)\n' +
                        '    \n' +
                        '    if not nargs:\n' +
                        '        return pnodeRun(func, nodes, add_node_alias)\n' +
                        '    \n' +
                        '    args_partial = [ ]\n' +
                        '    args_partial.append(func)\n' +
                        '    for a in args:\n' +
                        '        args_partial.append(a)\n' +
                        '    \n' +
                        '    return pnodeRun(\n' +
                        '        unifiedCall(partial, args_partial),\n' +
                        '        nodes,\n' +
                        '        add_node_alias\n' +
                        '    )\n'
                    :
                        // è¿™ä¸ªå¼€å¤´çš„ç©ºè¡Œå¾ˆé‡è¦ï¼Œåº”è¯¥å¯ä»¥ç»•è¿‡ webLoginRequired = true æ—¶ç¦æ­¢æ‰§è¡Œä»£ç 
                        // æœä¸€ä¸‹ APISocketConsole::execute
                        // https://dolphindb1.atlassian.net/browse/D20-4991
                        '\n' +
                            'def pnode_run (nodes, func_name, args, add_node_alias = true) {\n' +
                            '    nargs = size(args)\n' +
                            '    func = funcByName(func_name)\n' +
                            '    \n' +
                            '    if (!nargs)\n' +
                            '        return pnodeRun(func, nodes, add_node_alias)\n' +
                            '    \n' +
                            '    args_partial = array(any, 1 + nargs, 1 + nargs)\n' +
                            '    args_partial[0] = func\n' +
                            '    args_partial[1:] = args\n' +
                            '    return pnodeRun(\n' +
                            '        unifiedCall(partial, args_partial),\n' +
                            '        nodes,\n' +
                            '        add_node_alias\n' +
                            '    )\n' +
                            '}\n', { urgent: true }));
            }
            catch (error) {
                this.ppnode_run = undefined;
                throw error;
            }
        // this ä¸Šçš„å½“å‰é…ç½®éœ€è¦åœ¨ message åˆ°è¾¾åŽä½¿ç”¨ï¼Œå…ˆä¿å­˜èµ·æ¥
        const _listeners = [...this.listeners].reverse();
        // rpc è¯·æ±‚æœŸé—´éœ€è¦ç‹¬å  websocketï¼Œæ‰€ä»¥è®¾è®¡äº†ä¸€ä¸ªé”ï¼Œç”³è¯·ä¹‹åŽæ‰èƒ½ä½¿ç”¨
        // ddb ä¸–ç•Œè§‚ï¼šéœ€è¦ç­‰å¾…ä¸Šä¸€ä¸ª rpc ç»“æžœä»Ž server è¿”å›žä¹‹åŽæ‰èƒ½å‘èµ·ä¸‹ä¸€ä¸ªè°ƒç”¨  
        // è¿åä¸–ç•Œè§‚å¯èƒ½é€ æˆ:  
        // 1. å¹¶å‘å¤šä¸ªè¯·æ±‚åªè¿”å›žç¬¬ä¸€ä¸ªç»“æžœï¼ˆé˜»å¡žï¼Œéœ€åŽç»­è¯·æ±‚ç–é€šï¼‰
        // 2. windows ä¸‹ ddb server è¿”å›žå¤šä¸ªç›¸åŒçš„ç»“æžœ
        // æ—¢ç„¶ä¸Šä¸€ä¸ªè¯·æ±‚æ²¡æœ‰å‡ºçŽ° websocket errorï¼Œä¸”å‡½æ•°å¼€å¤´å·²ç»è°ƒç”¨äº† await this.connect() æ£€æŸ¥è¿‡ï¼Œ
        // è¿™é‡Œä¹Ÿä¹è§‚çš„è®¤ä¸º this.connected && !this.errored ä¸º true
        return this.lwebsocket.request(async (websocket) => {
            // ç‹¬å èµ„æºåŽå…ˆæ£€æŸ¥çŠ¶æ€
            if (this.error)
                throw this.error;
            const args = DdbObj.to_ddbobjs(_args);
            const rpc_id = `(id = ${id})`;
            const command = this.enc.encode((() => {
                switch (type) {
                    case 'function':
                        if (this.verbose)
                            console.log(func, args.map(arg => arg.data()), rpc_id);
                        (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(!func.includes('\0'), (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('å‘é€è‡³ DolphinDB æ‰§è¡Œçš„è„šæœ¬ä¸­é—´ä¸èƒ½å«æœ‰ \\0'));
                        return 'function\n' +
                            `${func}\n` +
                            `${args.length}\n` +
                            `${Number(DDB.le_client)}\n`;
                    case 'script':
                        if (this.verbose)
                            console.log(script, rpc_id);
                        (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(!script.includes('\0'), (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('å‘é€è‡³ DolphinDB æ‰§è¡Œçš„è„šæœ¬ä¸­é—´ä¸èƒ½å«æœ‰ \\0'));
                        return 'script\n' +
                            script;
                    case 'variable':
                        if (this.verbose)
                            vars.forEach((v, i) => {
                                console.log(v, '=', args[i].data());
                            });
                        return 'variable\n' +
                            `${vars.join(',')}\n` +
                            `${vars.length}\n` +
                            `${Number(DDB.le_client)}\n`;
                    case 'connect':
                        if (this.verbose)
                            console.log('connect()' +
                                (this.autologin ?
                                    '\n' +
                                        `login(${this.username.quote()}, ${this.password.quote()})`
                                    :
                                        '') +
                                ` ${rpc_id}`);
                        return 'connect\n' +
                            // è¯¦è§ InterProcessIO.cpp#APISocketConsole::parseScript ä¸­çš„
                            // Util::startWith "connect"
                            (this.autologin ?
                                'login\n' +
                                    this.username + '\n' +
                                    this.password /* encrypted (å¯é€‰å‚æ•°) + '\n' + 'false' */
                                :
                                    '');
                }
            })());
            // ä½¿ç”¨èµ„æºå‘é€è¯·æ±‚å¹¶ç­‰å¾…è¯·æ±‚å®Œæˆ
            const result = await new Promise((resolve, reject) => {
                let first_message = true;
                this.on_error = () => {
                    // è¿™é‡Œä¸€å®šæœ‰äº† this.error, ä¸éœ€è¦å† || new DdbConnectionError(this)
                    reject(this.error);
                };
                this.on_message = buffer => {
                    if (!on_more_messages || first_message)
                        try {
                            if (this.print_message_buffer)
                                console.log((0,xshell__WEBPACK_IMPORTED_MODULE_3__.typed_array_to_buffer)(buffer));
                            const message = this.parse_message(buffer, error);
                            listener?.(message, this);
                            for (const listener of _listeners)
                                listener(message, this);
                            const { type, data } = message;
                            switch (type) {
                                case 'print':
                                    if (this.print_message)
                                        console.log(data);
                                    break;
                                case 'object':
                                    first_message = false;
                                    resolve(data);
                                    break;
                                case 'error':
                                    first_message = false;
                                    reject(data);
                                    break;
                            }
                        }
                        catch (error) {
                            // è¿™é‡Œçš„é”™è¯¯å¹¶éž websocket é”™è¯¯ï¼Œè€Œæ˜¯ rpc é”™è¯¯
                            reject(error);
                        }
                    else
                        on_more_messages(buffer);
                };
                websocket.send((0,xshell__WEBPACK_IMPORTED_MODULE_3__.concat)([
                    this.enc.encode(`API2 ${this.sid} ${command.length} / ${this.get_rpc_options({ urgent })}\n`),
                    command,
                    ...args.map(arg => arg.pack())
                ]));
            });
            if (this.verbose)
                console.log(result.data(), rpc_id);
            return result;
        });
    }
    /** eval script through websocket (script command)
        - script?: æ‰§è¡Œçš„è„šæœ¬  Script to execute
        - options?: æ‰§è¡Œé€‰é¡¹  execution options
            - urgent?: ç´§æ€¥ flagï¼Œç¡®ä¿æäº¤çš„è„šæœ¬ä½¿ç”¨ urgent worker å¤„ç†ï¼Œé˜²æ­¢è¢«å…¶å®ƒä½œä¸šé˜»å¡ž
                Urgent flag to ensure that submitted scripts are processed by urgent workers to prevent being blocked by other jobs
            - listener?: å¤„ç†æœ¬æ¬¡ rpc æœŸé—´çš„æ¶ˆæ¯ (DdbMessage)  Process messages during this rpc (DdbMessage)
            - parse_object?: åœ¨è¯¥æ¬¡ rpc æœŸé—´è®¾ç½® parse_object, ç»“æŸåŽæ¢å¤åŽŸæœ‰ï¼Œä¸º false æ—¶è¿”å›žçš„ DdbObj ä»…å«æœ‰ buffer å’Œ leï¼Œ
                ä¸åšè§£æžï¼Œä»¥ä¾¿åŽç»­è½¬å‘ã€åºåˆ—åŒ–
                Set parse_object during this rpc, and restore the original after the end.
                When it is false, the returned DdbObj only contains buffer and le without parsing,
                so as to facilitate subsequent forwarding and serialization
            - iife?: ä½¿ç”¨ `def () { ... } ()` åŒ…è£¹è„šæœ¬ï¼Œreturn æœ€åŽä¸€è¡Œï¼Œé¿å…å˜é‡æ³„æ¼ */
    async eval(script, { urgent, listener, parse_object, iife, } = {}) {
        if (iife) {
            const lines = script.split_lines();
            if (lines.length < 2)
                throw new Error((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('iife æ‰§è¡Œçš„è„šæœ¬è¡Œæ•°åº”è¯¥è‡³å°‘ä¸º 2 è¡Œ'));
            script =
                'def () {\n' +
                    lines.slice(0, -1).indent().join_lines() +
                    `    return ${lines.last}\n` +
                    '} ()\n';
        }
        return this.rpc('script', { script, urgent, listener, parse_object });
    }
    /** call function through websocket (function command)
        - func: å‡½æ•°å  function name
        - args?: `[ ]` è°ƒç”¨å‚æ•° (ä¼ å…¥çš„åŽŸç”Ÿ string å’Œ boolean ä¼šè¢«è‡ªåŠ¨è½¬æ¢ä¸º DdbObj<string> å’Œ DdbObj<boolean>)
            Call parameters (the incoming native string and boolean will be automatically converted to DdbObj<string> and DdbObj<boolean>)
        - options?: è°ƒç”¨é€‰é¡¹  call options
            - urgent?: ç´§æ€¥ flagã€‚ä½¿ç”¨ urgent worker æ‰§è¡Œï¼Œé˜²æ­¢è¢«å…¶å®ƒä½œä¸šé˜»å¡ž
                Emergency flag. Use urgent worker execution to prevent being blocked by other jobs
            - node?: è®¾ç½®ç»“ç‚¹ alias æ—¶å‘é€åˆ°é›†ç¾¤ä¸­å¯¹åº”çš„ç»“ç‚¹æ‰§è¡Œ (ä½¿ç”¨ DolphinDB ä¸­çš„ rpc æ–¹æ³•)
                When the node alias is set, it is sent to the corresponding node in the cluster for execution (using the rpc method in DolphinDB)
            - nodes?: è®¾ç½®å¤šä¸ªç»“ç‚¹ alias æ—¶å‘é€åˆ°é›†ç¾¤ä¸­å¯¹åº”çš„å¤šä¸ªç»“ç‚¹æ‰§è¡Œ (ä½¿ç”¨ DolphinDB ä¸­çš„ pnodeRun æ–¹æ³•)
                When setting multiple node aliases, send them to the corresponding multiple nodes in the cluster for execution (using the pnodeRun method in DolphinDB)
            - add_node_alias?: è®¾ç½® nodes å‚æ•°æ—¶é€‰ä¼ ï¼Œå…¶å®ƒæƒ…å†µä¸ä¼ 
                Select to pass when setting the nodes parameter, otherwise not pass
            - listener?: å¤„ç†æœ¬æ¬¡ rpc æœŸé—´çš„æ¶ˆæ¯ (DdbMessage)
                Process messages during this rpc (DdbMessage)
            - parse_object?: åœ¨è¯¥æ¬¡ rpc æœŸé—´è®¾ç½® parse_object, ç»“æŸåŽæ¢å¤åŽŸæœ‰ï¼Œä¸º false æ—¶è¿”å›žçš„ DdbObj ä»…å«æœ‰ buffer å’Œ leï¼Œ
                ä¸åšè§£æžï¼Œä»¥ä¾¿åŽç»­è½¬å‘ã€åºåˆ—åŒ–
                Set parse_object during this rpc, and restore the original after the end.
                When it is false, the returned DdbObj only contains buffer and le without parsing,
                so as to facilitate subsequent forwarding and serialization
            - skip_connection_check?: (å†…éƒ¨ä½¿ç”¨) åœ¨é¦–æ¬¡ await ddb.connect() å»ºç«‹è¿žæŽ¥æ—¶ä¸èƒ½å†æ¬¡è°ƒç”¨ await this.connect() ç¡®ä¿è¿žæŽ¥çŠ¶æ€ï¼Œä¼šå¯¼è‡´å¾ªçŽ¯ä¾èµ–ï¼Œ
                å°†è¿™ä¸ª flag è®¾ä¸º true è·³è¿‡è¿žæŽ¥çŠ¶æ€æ£€æŸ¥
                (internal use) When await ddb.connect() establishes a connection for the first time, you cannot call await this.connect() again to ensure the connection status, which will lead to circular dependencies.
                 Set this flag to true to skip connection status checks */
    async call(func, args = [], { urgent, node, nodes, add_node_alias, listener, parse_object, skip_connection_check, on_more_messages } = {}) {
        let func_ = func;
        let args_ = args;
        if (node) {
            try {
                await (this.pjsrpc ??= this.eval(this.python ?
                    '\n' +
                        'def jsrpc (node, func_name, args):\n' +
                        '    args_ = args\n' +
                        '    if func_name == "invoke":\n' +
                        '        args_[0] = funcByName(args[0])\n' +
                        '    return rpc(node, unifiedCall, funcByName(func_name), args_)\n'
                    :
                        '\n' +
                            'def jsrpc (node, func_name, args) {\n' +
                            '    args_ = args\n' +
                            '    if (func_name == "invoke")\n' +
                            '        args_[0] = funcByName(args[0])\n' +
                            '    return rpc(node, unifiedCall, funcByName(func_name), args_)\n' +
                            '}\n', { urgent: true }));
            }
            catch (error) {
                this.pjsrpc = undefined;
                throw error;
            }
            func_ = 'jsrpc';
            args_ = [
                node,
                func,
                new DdbVectorAny(args)
            ];
        }
        if (nodes) {
            func_ = 'pnode_run';
            args_ = [
                new DdbVectorString(nodes),
                func,
                new DdbVectorAny(args),
                ...(() => {
                    if (typeof add_node_alias !== 'undefined')
                        return [add_node_alias];
                    if (this.python)
                        return [true];
                    return [];
                })()
            ];
        }
        return this.rpc('function', {
            func: func_,
            args: args_,
            urgent,
            listener,
            parse_object,
            skip_connection_check,
            on_more_messages
        });
    }
    /** è°ƒç”¨ dolphindb å‡½æ•°ï¼Œä¼ å…¥ js åŽŸç”Ÿæ•°ç»„ä½œä¸ºå‚æ•°ï¼Œè¿”å›ž js åŽŸç”Ÿå¯¹è±¡æˆ–å€¼ï¼ˆè°ƒç”¨ DdbObj.data() åŽçš„ç»“æžœï¼‰
        - func: å‡½æ•°å
        - args?: `[ ]` è°ƒç”¨å‚æ•°ï¼Œå¯ä»¥æ˜¯ js åŽŸç”Ÿæ•°ç»„ï¼Œå‚æ•°åœ¨ä¸­é—´ä¸”æƒ³ç”¨ server å‡½æ•°çš„é»˜è®¤å‚æ•°å€¼æ—¶å¯ä»¥ä¼  null å ä½
        - options?: è°ƒç”¨é€‰é¡¹
            - urgent?: ç´§æ€¥ flagã€‚ä½¿ç”¨ urgent worker æ‰§è¡Œï¼Œé˜²æ­¢è¢«å…¶å®ƒä½œä¸šé˜»å¡ž
            - node?: è®¾ç½®ç»“ç‚¹ alias æ—¶å‘é€åˆ°é›†ç¾¤ä¸­å¯¹åº”çš„ç»“ç‚¹æ‰§è¡Œ (ä½¿ç”¨ DolphinDB ä¸­çš„ rpc æ–¹æ³•)
            - nodes?: è®¾ç½®å¤šä¸ªç»“ç‚¹ alias æ—¶å‘é€åˆ°é›†ç¾¤ä¸­å¯¹åº”çš„å¤šä¸ªç»“ç‚¹æ‰§è¡Œ (ä½¿ç”¨ DolphinDB ä¸­çš„ pnodeRun æ–¹æ³•)
            - add_node_alias?: è®¾ç½® nodes å‚æ•°æ—¶é€‰ä¼ ï¼Œå…¶å®ƒæƒ…å†µä¸ä¼ 
            - listener?: å¤„ç†æœ¬æ¬¡ rpc æœŸé—´çš„æ¶ˆæ¯ (DdbMessage) */
    async invoke(func, args, options) {
        // æ£€æŸ¥ args æ˜¯å¦å…¨éƒ¨ä¸ºç®€å•å‚æ•°ï¼Œæ˜¯åˆ™ç›´æŽ¥è°ƒç”¨ callï¼Œé¿å… invoke é—´æŽ¥è°ƒç”¨
        // é€»è¾‘ç±»ä¼¼ DdbObj.to_ddbobjs, éœ€è¦åŒæ­¥ä¿®æ”¹
        let convertable = true;
        let has_ddbobj = false;
        if (args)
            for (const arg of args)
                if (arg && arg instanceof DdbObj)
                    has_ddbobj = true;
                else if (arg === undefined || arg === null) {
                    // simple
                }
                else {
                    const type = typeof arg;
                    if (type === 'string' || type === 'boolean') { } // simple
                    else
                        convertable = false;
                }
        let result;
        if (convertable)
            result = await this.call(func, args, options);
        else {
            if (has_ddbobj)
                throw new Error((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('è°ƒç”¨ ddb.invoke çš„å‚æ•°ä¸­ä¸èƒ½åŒæ—¶æœ‰ DdbObj ä¸Žå¤æ‚ js åŽŸç”Ÿå¯¹è±¡'));
            try {
                await (this.pinvoke ??= this.eval(this.python ?
                    '\n' +
                        'def invoke (func, args_json):\n' +
                        '    args = fromStdJson(args_json)\n' +
                        '    func_ = func\n' +
                        '    if type(func) == STRING:\n' +
                        '        func_ = funcByName(func)\n' +
                        '    if type(args) != ANY:\n' +
                        '        args = cast(args, ANY)\n' +
                        '    return unifiedCall(func_, args)\n'
                    :
                        '\n' +
                            'def invoke (func, args_json) {\n' +
                            '    args = fromStdJson(args_json)\n' +
                            '    func_ = func\n' +
                            '    if (type(func) == STRING)\n' +
                            '        func_ = funcByName(func)\n' +
                            '    if (type(args) != ANY)\n' +
                            '        args = cast(args, ANY)\n' +
                            '    return unifiedCall(func_, args)\n' +
                            '}\n', { urgent: true }));
            }
            catch (error) {
                // invoke æ²¡æœ‰æ­£ç¡®æ‰§è¡Œæ—¶ï¼Œé‡æ–°å°† pinvoke èµ‹å€¼ä¸º undefined
                this.pinvoke = undefined;
                throw error;
            }
            result = await this.call('invoke', [func, JSON.stringify(args)], options);
        }
        return result.data(options);
    }
    /** æ‰§è¡Œ dolphindb è„šæœ¬ï¼Œè¿”å›ž js åŽŸç”Ÿå¯¹è±¡æˆ–å€¼ï¼ˆè°ƒç”¨ DdbObj.data() åŽçš„ç»“æžœï¼‰
        - script?: æ‰§è¡Œçš„è„šæœ¬
        - options?: æ‰§è¡Œé€‰é¡¹
            - urgent?: ç´§æ€¥ flagï¼Œç¡®ä¿æäº¤çš„è„šæœ¬ä½¿ç”¨ urgent worker å¤„ç†ï¼Œé˜²æ­¢è¢«å…¶å®ƒä½œä¸šé˜»å¡ž
            - listener?: å¤„ç†æœ¬æ¬¡ rpc æœŸé—´çš„æ¶ˆæ¯ (DdbMessage) */
    async execute(script, options) {
        return (await this.eval(script, options))
            .data(options);
    }
    /** upload variable through websocket (variable command) */
    async upload(
    /** ä¸Šä¼ çš„å˜é‡å  Uploaded variables' name */
    vars, 
    /** ä¸Šä¼ çš„å˜é‡å€¼  Uploaded variables' value */
    args, { listener, parse_object, } = {}) {
        (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(args.length && args.length === vars.length, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('variable æŒ‡ä»¤å‚æ•°ä¸èƒ½ä¸ºç©ºä¸”å‚æ•°åä¸èƒ½ä¸ºç©ºï¼Œä¸”æ•°é‡åº”è¯¥åŒ¹é…'));
        return this.rpc('variable', { vars, args, listener, parse_object });
    }
    /** å–æ¶ˆå½“å‰ session id å¯¹åº”çš„æ‰€æœ‰ console jobs  Cancel all console jobs corresponding to the current session id */
    async cancel() {
        let ddb = new DDB(this.url, this);
        try {
            // å› ä¸ºæ˜¯æ–°å»ºçš„è¿žæŽ¥ï¼Œè€Œä¸”æ‰§è¡Œå®Œè„šæœ¬ä¹‹åŽé©¬ä¸Šå°±å…³é—­äº†ï¼Œæ‰€ä»¥ä¸ç”¨è€ƒè™‘å˜é‡æ³„æ¼çš„é—®é¢˜
            await ddb.eval(`jobs = exec rootJobId from getConsoleJobs() where sessionId = ${this.sid}\n` +
                (this.python ? 'if size(jobs):\n' : 'if (size(jobs))\n') +
                '    cancelConsoleJob(jobs)\n', { urgent: true });
        }
        finally {
            ddb.disconnect();
        }
    }
    /** è§£æžæœåŠ¡ç«¯å“åº”æŠ¥æ–‡ï¼Œè¿”å›žåŽ»æŽ‰ header çš„ data buf */
    parse_message(buf, error) {
        // MSG\n
        // <message>\0
        // 'M'.codePointAt(0).to_hex_str()
        if (buf[0] === 0x4d && buf[1] === 0x53 && buf[2] === 0x47 && buf[3] === 0x0a) {
            (0,xshell__WEBPACK_IMPORTED_MODULE_3__.assert)(buf.at(-1) === 0, (0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('print æ¶ˆæ¯çš„ buffer åº”è¯¥ä»¥ \\0 ç»“æŸ'));
            if (buf.indexOf(0) !== buf.length - 1)
                console.warn((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('print æ¶ˆæ¯çš„ buffer ä¸­é—´ä¸åº”è¯¥æœ‰ \\0'));
            return {
                type: 'print',
                data: this.dec.decode(buf.subarray(4, -1))
            };
        }
        // '1166953221 1 1\n'
        // 'OK\n'
        // '\x04\x00\x02\x00\x00\x00'
        /** index of line feed 0 */
        const ilf0 = buf.indexOf(0x0a); // '\n'
        const parts = this.dec.decode(buf.subarray(0, ilf0)).split(' ');
        this.sid = parts[0];
        // è¿”å›žå¯¹è±¡çš„æ•°é‡
        // const nobj = Number(parts[1])
        // å¤§å°ç«¯: åè®®ä¸­å¤§ç«¯ä¸º 0, å°ç«¯ä¸º 1
        this.le = Number(parts[2]) !== 0;
        const ils1 = ilf0 + 1;
        const ilf1 = buf.indexOf(0x0a, ils1); // '\n'
        /** 'OK' è¡¨ç¤ºæˆåŠŸï¼Œå…¶å®ƒæ–‡æœ¬è¡¨ç¤ºå¤±è´¥ */
        const message = this.dec.decode(buf.subarray(ils1, ilf1));
        if (message !== 'OK') {
            error.message = message;
            let lines = error.stack.split_lines();
            lines[0] += `: ${message}`;
            error.stack = lines.join_lines(false);
            return { type: 'error', data: error };
        }
        const bufobj = buf.subarray(ilf1 + 1);
        if (this.print_object_buffer)
            console.log((0,xshell__WEBPACK_IMPORTED_MODULE_3__.typed_array_to_buffer)(bufobj));
        return {
            type: 'object',
            data: error.options.parse_object ?? this.parse_object ?
                DdbObj.parse(bufobj, this.le)
                :
                    new DdbObj({
                        form: DdbForm.scalar,
                        type: DdbType.void,
                        length: 0,
                        le: this.le,
                        buffer: bufobj,
                    })
        };
    }
    /** å†…éƒ¨çš„æµè®¢é˜…æ–¹æ³•  Internal stream subscription method */
    async subscribe() {
        // æµè¡¨æŽ¨é€è¿‡æ¥çš„ç¬¬ä¸€æ¡æ•°æ®æ˜¯ schemaï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
        let first = true;
        let win = {
            offset: 0,
            data: [],
            objs: []
        };
        let schema;
        console.log((0,_i18n_index_js__WEBPACK_IMPORTED_MODULE_4__.t)('è®¢é˜…æµè¡¨æˆåŠŸ:'), 
        // æ™®é€šæµè¡¨ç»“æžœä¸º columns (string[])
        // é«˜å¯ç”¨æµè¡¨ä¸º [columns (string[]), node sites (string[])]
        (await this.call('publishTable', [
            'localhost',
            new DdbInt(0),
            this.streaming.table,
            (this.streaming.action ||= `api_js_${new Date().getTime()}`),
            (this.streaming.offset === undefined || this.streaming.offset === null)
                ? new DdbVoid()
                : new DdbInt(this.streaming.offset), // offset
            this.streaming.filters?.column || new DdbVoid(), // filter
        ], {
            skip_connection_check: true,
            // å…ˆå‡†å¤‡å¥½æ”¶åˆ° websocket message çš„ callback
            on_more_messages: buffer => {
                try {
                    let data;
                    const dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
                    const i_topic_end = buffer.indexOf(0, 17);
                    // é¦–ä¸ª message ä¸€å®šæ˜¯ table schema, åŽç»­æ¶ˆæ¯æ˜¯ column ç‰‡æ®µç»„æˆçš„ any vector
                    const obj = DdbObj.parse(buffer.subarray(i_topic_end + 1), this.le);
                    // server æŽ¨æ•°æ®æ—¶é‡åˆ°é”™è¯¯ä¼šè¿”å›ž stringï¼Œä¸€èˆ¬æ ¼å¼ä¸º error.xxx: é”™è¯¯ä¿¡æ¯
                    if (obj.form === DdbForm.scalar && obj.type === DdbType.string) {
                        this.disconnect();
                        const value = obj.value;
                        throw new Error(value.slice(value.indexOf(':') + 1).trim());
                    }
                    if (first) {
                        schema = data = obj.data();
                        data.name ||= this.streaming.table;
                        first = false;
                    }
                    else {
                        let rows;
                        // ç”¨äº†æµæ•°æ®è¿‡æ»¤åŠŸèƒ½åŽï¼Œå¿…ç„¶å‘ table
                        if (obj.form === DdbForm.table) {
                            data = obj.data();
                            data.name ||= schema.name;
                            rows = data.data.length;
                        }
                        else {
                            const _data = obj.data();
                            const { columns } = schema;
                            rows = _data[0]?.length || 0;
                            data = {
                                ...schema,
                                data: (0,xshell__WEBPACK_IMPORTED_MODULE_3__.seq)(rows, i => (0,xshell__WEBPACK_IMPORTED_MODULE_3__.zip_object)(columns, (0,xshell__WEBPACK_IMPORTED_MODULE_3__.seq)(columns.length, j => _data[j][i])))
                            };
                        }
                        win.data.push(...data.data);
                        win.objs.push(obj);
                        if (win.data.length >= winsize * 2 && win.objs.length >= 2) {
                            let winsize_ = 0;
                            let i = win.objs.length - 1;
                            // å¾€å‰ç§»åŠ¨è‡³é¦–ä¸ªç´¯è®¡ winsize_ è¶…è¿‡ winsize çš„ä½ç½®
                            for (; winsize_ < winsize; i--)
                                winsize_ += win.objs[i].value[0].rows;
                            win.offset += win.data.length - winsize_;
                            win.data = win.data.slice(-winsize_);
                            win.objs = win.objs.slice(i);
                        }
                    }
                    this.streaming.handler({
                        ...this.streaming,
                        id: dv.getBigInt64(9, this.le),
                        time: dv.getBigInt64(1, this.le),
                        topic: this.dec.decode(buffer.subarray(17, i_topic_end)),
                        obj,
                        data,
                        window: win,
                    });
                }
                catch (error) {
                    // å°† error äº¤ç»™ handler å¤„ç†
                    this.streaming.handler({ ...this.streaming, error });
                }
            }
        })).data());
    }
}
class BigInt128Array {
    static of(...items) {
        return new BigInt128Array(items);
    }
    static from(arrayLike, mapfn, thisArg) {
        if (mapfn) {
            const array = [];
            for (let i = 0; i < arrayLike.length; i++)
                array.push(mapfn.call(thisArg, arrayLike[i], i));
            return new BigInt128Array(array);
        }
        else {
            const v = new BigInt128Array(arrayLike.length);
            v.set(arrayLike);
        }
    }
    BYTES_PER_ELEMENT = 16;
    buffer;
    byteLength;
    byteOffset;
    constructor(fisrtArg, byteOffset, length) {
        if (typeof fisrtArg === 'number') {
            const length = fisrtArg;
            this.buffer = new ArrayBuffer(length * this.BYTES_PER_ELEMENT);
            this.byteOffset = 0;
            this.byteLength = length * this.BYTES_PER_ELEMENT;
        }
        else if (fisrtArg instanceof ArrayBuffer || fisrtArg instanceof SharedArrayBuffer) {
            this.buffer = fisrtArg;
            this.byteOffset = byteOffset ?? 0;
            let byteLength = 0;
            if (length !== undefined) {
                byteLength = length * this.BYTES_PER_ELEMENT;
                if (byteLength + this.byteOffset > fisrtArg.byteLength)
                    throw new RangeError(`valid typed array length: ${length}`);
            }
            else {
                byteLength = fisrtArg.byteLength - this.byteOffset;
                if (byteLength % this.BYTES_PER_ELEMENT !== 0)
                    throw new RangeError('byte length of BigInt128Array should be a multiple of 16');
            }
            this.byteLength = byteLength;
        }
        else {
            const array = [];
            for (const value of fisrtArg)
                array.push(value);
            this.buffer = new ArrayBuffer(array.length * this.BYTES_PER_ELEMENT);
            this.byteOffset = 0;
            this.byteLength = array.length * this.BYTES_PER_ELEMENT;
            this.set(array);
        }
        return new Proxy(this, {
            get(target, key) {
                if (typeof key === 'string') {
                    const index = Number(key);
                    // only positive integer index is allowed
                    if (Number.isInteger(index) && index >= 0 && index < target.length)
                        return target.at(index);
                }
                return Reflect.get(target, key);
            },
            set(target, key, value) {
                if (typeof key === 'string') {
                    const index = Number(key);
                    if (Number.isInteger(index) && index >= 0 && index < target.length)
                        target.set([value], index);
                    // ignore invalid number index setter, and never set value to target
                    return true;
                }
                return Reflect.set(target, key, value);
            },
            has(target, key) {
                if (typeof key === 'string') {
                    const index = Number(key);
                    if (Number.isInteger(index) && index >= 0 && index < target.length)
                        return true;
                }
                return Reflect.has(target, key);
            }
        });
    }
    get length() {
        return this.byteLength / this.BYTES_PER_ELEMENT;
    }
    set(array, offset = 0) {
        if (offset + array.length > this.length)
            throw new RangeError('offset is out of bounds');
        const dv = new DataView(this.buffer);
        for (let i = 0; i < array.length; i++) {
            const byteOffset = this.byteOffset + (offset + i) * this.BYTES_PER_ELEMENT;
            set_big_int_128(dv, byteOffset, array[i]);
        }
    }
    at(index) {
        const length = this.length;
        if (index < 0)
            index += length;
        if (index >= length || index < 0)
            return undefined;
        const dv = new DataView(this.buffer);
        return get_big_int_128(dv, this.byteOffset + index * this.BYTES_PER_ELEMENT);
    }
    subarray(begin = 0, end = this.length) {
        const length = this.length;
        // subarray arguments should be the same behavior as other TypedArray
        // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray#%E8%AF%B4%E6%98%8E
        if (begin < 0)
            begin += length;
        if (end < 0)
            end += length;
        if (begin < 0)
            begin = 0;
        else if (begin > length)
            begin = length;
        if (end < 0)
            end = 0;
        else if (end > length)
            end = length;
        const newLength = Math.max(end - begin, 0);
        return new BigInt128Array(this.buffer, this.byteOffset + begin * this.BYTES_PER_ELEMENT, newLength);
    }
    [Symbol.iterator]() {
        let index = 0;
        const array = this;
        return {
            next() {
                if (index < array.length)
                    return { value: array.at(index++), done: false };
                else
                    return { done: true };
            },
        };
    }
    toString() {
        const values = [];
        for (const value of this)
            values.push(value);
        return values.join(',');
    }
    // Simulate other TypedArray behavior in nodejs
    [xshell__WEBPACK_IMPORTED_MODULE_3__.inspect.custom]() {
        const values = [];
        for (const value of this)
            values.push(value);
        const value_str = values.length ? ` ${values.map(v => String(v) + 'n').join(', ')} ` : '';
        return `${this[Symbol.toStringTag]}(${this.length}) [${value_str}]`;
    }
}
Object.defineProperty(BigInt128Array.prototype, Symbol.toStringTag, {
    configurable: false,
    writable: false,
    enumerable: false,
    value: 'BigInt128Array',
});
// DataView Extends for bigint 128 operations
function get_big_uint_128(dataview, byte_offset, le = true) {
    let cursor = byte_offset + (le ? 15 : 0);
    const end = byte_offset + (le ? -1 : 16);
    const step = le ? -1 : 1;
    let value = 0n;
    while (cursor !== end) {
        value = value << 8n | BigInt(dataview.getUint8(cursor));
        cursor += step;
    }
    return value;
}
function get_big_int_128(dataview, byte_offset, le = true) {
    return BigInt.asIntN(128, get_big_uint_128(dataview, byte_offset, le));
}
function set_big_uint_128(dataView, byte_offset, value, le = true) {
    let cursor = byte_offset + (le ? 0 : 15);
    const end = byte_offset + (le ? 16 : -1);
    const step = le ? 1 : -1;
    while (cursor !== end) {
        dataView.setUint8(cursor, Number(value & 0xffn));
        value = value >> 8n;
        cursor += step;
    }
}
function set_big_int_128(dataview, byte_offset, value, le = true) {
    set_big_uint_128(dataview, byte_offset, value, le);
}
function generate_array_type(baseType, dimensions) {
    let result = baseType;
    dimensions.forEach(dimension => {
        result += `[${dimension}]`;
    });
    return result;
}
// å¤§ç«¯
// const dataBE = new ArrayBuffer(16)
// const dataViewBE = new DataView(dataBE)
// set_big_int_128(dataViewBE, 0, -34355n, false)
// console.log(dataViewBE.buffer)
// const bigInt128BE = get_big_int_128(dataViewBE, 0, false)
// const bigUint128BE = get_big_uint_128(dataViewBE, 0, false)
// console.log(bigInt128BE.toString(), bigUint128BE.toString())
// å°ç«¯
// const dataLE = new ArrayBuffer(16)
// const dataViewLE = new DataView(dataLE)
// set_big_int_128(dataViewLE, 0, -34355n, true)
// console.log(dataViewLE.buffer)
// const bigInt128LE = get_big_int_128(dataViewLE, 0, true)
// const bigUint128LE = get_big_uint_128(dataViewLE, 0, true)
// console.log(bigInt128LE.toString(), bigUint128LE.toString())


/***/ }),

/***/ "./node_modules/.pnpm/i18next@24.2.1_typescript@5.7.3/node_modules/i18next/dist/esm/i18next.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/i18next@24.2.1_typescript@5.7.3/node_modules/i18next/dist/esm/i18next.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   changeLanguage: () => (/* binding */ changeLanguage),
/* harmony export */   createInstance: () => (/* binding */ createInstance),
/* harmony export */   "default": () => (/* binding */ instance),
/* harmony export */   dir: () => (/* binding */ dir),
/* harmony export */   exists: () => (/* binding */ exists),
/* harmony export */   getFixedT: () => (/* binding */ getFixedT),
/* harmony export */   hasLoadedNamespace: () => (/* binding */ hasLoadedNamespace),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   loadLanguages: () => (/* binding */ loadLanguages),
/* harmony export */   loadNamespaces: () => (/* binding */ loadNamespaces),
/* harmony export */   loadResources: () => (/* binding */ loadResources),
/* harmony export */   reloadResources: () => (/* binding */ reloadResources),
/* harmony export */   setDefaultNamespace: () => (/* binding */ setDefaultNamespace),
/* harmony export */   t: () => (/* binding */ t),
/* harmony export */   use: () => (/* binding */ use)
/* harmony export */ });
const isString = obj => typeof obj === 'string';
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = object => {
  if (object == null) return '';
  return '' + object;
};
const copy = (a, s, t) => {
  a.forEach(m => {
    if (s[m]) t[m] = s[m];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = key => key && key.indexOf('###') > -1 ? key.replace(lastOfPathSeparatorRegExp, '.') : key;
const canNotTraverseDeeper = object => !object || isString(object);
const getLastOfPath = (object, path, Empty) => {
  const stack = !isString(path) ? path : path.split('.');
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
const setPath = (object, path, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  if (obj !== undefined || path.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e = path[path.length - 1];
  let p = path.slice(0, path.length - 1);
  let last = getLastOfPath(object, p, Object);
  while (last.obj === undefined && p.length) {
    e = `${p[p.length - 1]}.${e}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object, p, Object);
    if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== 'undefined') {
      last.obj = undefined;
    }
  }
  last.obj[`${last.k}.${e}`] = newValue;
};
const pushPath = (object, path, newValue, concat) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
};
const getPath = (object, path) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path);
  if (!obj) return undefined;
  if (!Object.prototype.hasOwnProperty.call(obj, k)) return undefined;
  return obj[k];
};
const getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== undefined) {
    return value;
  }
  return getPath(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== '__proto__' && prop !== 'constructor') {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
const regexEscape = str => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
var _entityMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;'
};
const escape = data => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, s => _entityMap[s]);
  }
  return data;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== undefined) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars = [' ', ',', '?', '!', ';'];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || '';
  keySeparator = keySeparator || '';
  const possibleChars = chars.filter(c => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map(c => c === '?' ? '\\?' : c).join('|')})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = function (obj, path) {
  let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
  if (!obj) return undefined;
  if (obj[path]) {
    if (!Object.prototype.hasOwnProperty.call(obj, path)) return undefined;
    return obj[path];
  }
  const tokens = path.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length;) {
    if (!current || typeof current !== 'object') {
      return undefined;
    }
    let next;
    let nextPath = '';
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== undefined) {
        if (['string', 'number', 'boolean'].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
const getCleanedCode = code => code?.replace('_', '-');

const consoleLogger = {
  type: 'logger',
  log(args) {
    this.output('log', args);
  },
  warn(args) {
    this.output('warn', args);
  },
  error(args) {
    this.output('error', args);
  },
  output(type, args) {
    console?.[type]?.apply?.(console, args);
  }
};
class Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.prefix = options.prefix || 'i18next:';
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, 'log', '', true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, 'warn', '', true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, 'error', '');
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger();

class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(' ').forEach(event => {
      if (!this.observers[event]) this.observers[event] = new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach(_ref => {
        let [observer, numTimesAdded] = _ref;
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers['*']) {
      const cloned = Array.from(this.observers['*'].entries());
      cloned.forEach(_ref2 => {
        let [observer, numTimesAdded] = _ref2;
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
}

class ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ns: ['translation'],
      defaultNS: 'translation'
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === undefined) {
      this.options.keySeparator = '.';
    }
    if (this.options.ignoreJSONStructure === undefined) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
    } else {
      path = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (isString(key) && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath(this.data, path);
    if (!result && !ns && !key && lng.indexOf('.') > -1) {
      lng = path[0];
      ns = path[1];
      key = path.slice(2).join('.');
    }
    if (result || !ignoreJSONStructure || !isString(key)) return result;
    return deepFind(this.data?.[lng]?.[ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    let path = [lng, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
      value = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path, value);
    if (!options.silent) this.emit('added', lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
      silent: false
    };
    for (const m in resources) {
      if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit('added', lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path = [lng, ns];
    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
      deep = resources;
      resources = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path, pack);
    if (!options.silent) this.emit('added', lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit('removed', lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== undefined;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find(v => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}

var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach(processor => {
      value = this.processors[processor]?.process(value, key, options, translator) ?? value;
    });
    return value;
  }
};

const checkedLoadedFor = {};
class Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super();
    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, this);
    this.options = options;
    if (this.options.keySeparator === undefined) {
      this.options.keySeparator = '.';
    }
    this.logger = baseLogger.create('translator');
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      interpolation: {}
    };
    if (key == null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved?.res !== undefined;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === undefined) nsSeparator = ':';
    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== 'object' && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === 'object') options = {
      ...options
    };
    if (!options) options = {};
    if (keys == null) return '';
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng?.toLowerCase() === 'cimode') {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved?.res;
    const resUsedKey = resolved?.usedKey || key;
    const resExactUsedKey = resolved?.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
    const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = !isString(res) && typeof res !== 'boolean' && typeof res !== 'number';
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn('accessing an object - but returnObjects options is not enabled!');
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res);
        const copy = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            copy[m] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy[m] === deepKey) copy[m] = res[m];
          }
        }
        res = copy;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== undefined && !isString(options.count);
      const hasDefaultValue = Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : '';
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0;
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === 'all') {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector?.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit('missingKey', l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach(language => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach(suffix => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : undefined);
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat?.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = isString(res) && (options?.interpolation?.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && !isString(options.replace) ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey?.[0] === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res != null && postProcessorNames?.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys)) keys = [keys];
    keys.forEach(k => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== undefined && !isString(options.count);
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0;
      const needsContextHandling = options.context !== undefined && (isString(options.context) || typeof options.context === 'number') && options.context !== '';
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach(ns => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(', ')}" won't get resolved as namespace "${usedNS}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
        }
        codes.forEach(code => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat?.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const optionsKeys = ['defaultValue', 'ordinal', 'context', 'replace', 'lng', 'lngs', 'fallbackLng', 'ns', 'keySeparator', 'nsSeparator', 'returnObjects', 'returnDetails', 'joinArrays', 'postProcess', 'interpolation'];
    const useOptionsReplaceForData = options.replace && !isString(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== 'undefined') {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = 'defaultValue';
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {
        return true;
      }
    }
    return false;
  }
}

class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create('languageUtils');
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf('-') < 0) return null;
    const p = code.split('-');
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === 'x') return null;
    return this.formatLanguageCode(p.join('-'));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf('-') < 0) return code;
    const p = code.split('-');
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (isString(code) && code.indexOf('-') > -1) {
      let formattedCode;
      try {
        formattedCode = Intl.getCanonicalLocales(code)[0];
      } catch (e) {}
      if (formattedCode && this.options.lowerCaseLng) {
        formattedCode = formattedCode.toLowerCase();
      }
      if (formattedCode) return formattedCode;
      if (this.options.lowerCaseLng) {
        return code.toLowerCase();
      }
      return code;
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach(code => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach(code => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find(supportedLng => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf('-') < 0 && lngOnly.indexOf('-') < 0) return;
          if (supportedLng.indexOf('-') > 0 && lngOnly.indexOf('-') < 0 && supportedLng.substring(0, supportedLng.indexOf('-')) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
    if (isString(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = c => {
      if (!c) return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (isString(code) && (code.indexOf('-') > -1 || code.indexOf('_') > -1)) {
      if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
      if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
    } else if (isString(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach(fc => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
}

const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const dummyRule = {
  select: count => count === 1 ? 'one' : 'other',
  resolvedOptions: () => ({
    pluralCategories: ['one', 'other']
  })
};
class PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create('pluralResolver');
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const cleanedCode = getCleanedCode(code === 'dev' ? 'en' : code);
    const type = options.ordinal ? 'ordinal' : 'cardinal';
    const cacheKey = JSON.stringify({
      cleanedCode,
      type
    });
    if (cacheKey in this.pluralRulesCache) {
      return this.pluralRulesCache[cacheKey];
    }
    let rule;
    try {
      rule = new Intl.PluralRules(cleanedCode, {
        type
      });
    } catch (err) {
      if (!Intl) {
        this.logger.error('No Intl support, please use an Intl polyfill!');
        return dummyRule;
      }
      if (!code.match(/-|_/)) return dummyRule;
      const lngPart = this.languageUtils.getLanguagePartFromCode(code);
      rule = this.getRule(lngPart, options);
    }
    this.pluralRulesCache[cacheKey] = rule;
    return rule;
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule('dev', options);
    return rule?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.getSuffixes(code, options).map(suffix => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule('dev', options);
    if (!rule) return [];
    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map(pluralCategory => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${pluralCategory}`);
  }
  getSuffix(code, count) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${rule.select(count)}`;
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return this.getSuffix('dev', count, options);
  }
}

const deepFindWithDefaults = function (data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && isString(key)) {
    path = deepFind(data, key, keySeparator);
    if (path === undefined) path = deepFind(defaultData, key, keySeparator);
  }
  return path;
};
const regexSafe = val => val.replace(/\$/g, '$$$$');
class Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.logger = baseLogger.create('interpolator');
    this.options = options;
    this.format = options?.interpolation?.format || (value => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== undefined ? escape$1 : escape;
    this.escapeValue = escapeValue !== undefined ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || '{{';
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || '}}';
    this.formatSeparator = formatSeparator || ',';
    this.unescapePrefix = unescapeSuffix ? '' : unescapePrefix || '-';
    this.unescapeSuffix = this.unescapePrefix ? '' : unescapeSuffix || '';
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape('$t(');
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(')');
    this.nestingOptionsSeparator = nestingOptionsSeparator || ',';
    this.maxReplaces = maxReplaces || 1000;
    this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp?.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, 'g');
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = key => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, undefined, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options?.interpolation?.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: val => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: val => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach(todo => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === undefined) {
          if (typeof missingInterpolationHandler === 'function') {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString(temp) ? temp : '';
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = '';
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = '';
          }
        } else if (!isString(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r = match[1].split(this.formatSeparator).map(elem => elem.trim());
        match[1] = r.shift();
        formatters = r;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString(value)) return value;
      if (!isString(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = '';
      }
      if (doReduce) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}

const parseFormatStr = formatStr => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf('(') > -1) {
    const p = formatStr.split('(');
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === 'currency' && optStr.indexOf(':') < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(';');
      opts.forEach(opt => {
        if (opt) {
          const [key, ...rest] = opt.split(':');
          const val = rest.join(':').trim().replace(/^'+|'+$/g, '');
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === 'false') formatOptions[trimmedKey] = false;
          if (val === 'true') formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = fn => {
  const cache = {};
  return (val, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: undefined
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
};
class Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.logger = baseLogger.create('formatter');
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return val => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: 'currency'
        });
        return val => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return val => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return val => formatter.format(val, opt.range || 'day');
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return val => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options.interpolation.formatSeparator || ',';
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf('(') > 1 && formats[0].indexOf(')') < 0 && formats.find(f => f.indexOf(')') > -1)) {
      const lastIndex = formats.findIndex(f => f.indexOf(')') > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options?.formatParams?.[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
}

const removePending = (q, name) => {
  if (q.pending[name] !== undefined) {
    delete q.pending[name];
    q.pendingCount--;
  }
};
class Connector extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create('backendConnector');
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    this.backend?.init?.(services, options.backend, options);
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach(lng => {
      let hasAllNamespaces = true;
      namespaces.forEach(ns => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ; else if (this.state[name] === 1) {
          if (pending[name] === undefined) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === undefined) pending[name] = true;
          if (toLoad[name] === undefined) toLoad[name] = true;
          if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s = name.split('|');
    const lng = s[0];
    const ns = s[1];
    if (err) this.emit('failedLoading', lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, undefined, undefined, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach(q => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach(l => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach(n => {
              if (loaded[l][n] === undefined) loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit('loaded', loaded);
    this.queue = this.queue.filter(q => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : undefined;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === 'function') {
          r.then(data => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : undefined;
    if (!this.backend) {
      this.logger.warn('No backend was added via i18next.use. Will not load resources.');
      return callback && callback();
    }
    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach(name => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    const s = name.split('|');
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, 'read', undefined, undefined, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : () => {};
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
      return;
    }
    if (key === undefined || key === null || key === '') return;
    if (this.backend?.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === 'function') {
            r.then(data => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}

const get = () => ({
  debug: false,
  initAsync: true,
  ns: ['translation'],
  defaultNS: ['translation'],
  fallbackLng: ['dev'],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: 'all',
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: '.',
  nsSeparator: ':',
  pluralSeparator: '_',
  contextSeparator: '_',
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: 'fallback',
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: args => {
    let ret = {};
    if (typeof args[1] === 'object') ret = args[1];
    if (isString(args[1])) ret.defaultValue = args[1];
    if (isString(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === 'object' || typeof args[3] === 'object') {
      const options = args[3] || args[2];
      Object.keys(options).forEach(key => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: value => value,
    prefix: '{{',
    suffix: '}}',
    formatSeparator: ',',
    unescapePrefix: '-',
    nestingPrefix: '$t(',
    nestingSuffix: ')',
    nestingOptionsSeparator: ',',
    maxReplaces: 1000,
    skipOnVariables: true
  }
});
const transformOptions = options => {
  if (isString(options.ns)) options.ns = [options.ns];
  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs?.indexOf?.('cimode') < 0) {
    options.supportedLngs = options.supportedLngs.concat(['cimode']);
  }
  if (typeof options.initImmediate === 'boolean') options.initAsync = options.initImmediate;
  return options;
};

const noop = () => {};
const bindMemberFunctions = inst => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(mem => {
    if (typeof inst[mem] === 'function') {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : undefined;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initAsync) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : undefined;
    this.isInitializing = true;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    if (options.defaultNS == null && options.ns) {
      if (isString(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf('translation') < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    };
    if (options.keySeparator !== undefined) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== undefined) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = ClassOrObject => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === 'function') return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on('*', function (event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on('*', function (event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach(m => {
        if (m.init) m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn('init: no languageDetector is used and no lng is defined');
    }
    const storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
    storeApi.forEach(fcName => {
      this[fcName] = function () {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];
    storeApiChained.forEach(fcName => {
      this[fcName] = function () {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn('init: i18next is already initialized. You should call init just once!');
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log('initialized', this.options);
        this.emit('initialized', this.options);
        deferred.resolve(t);
        callback(err, t);
      };
      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initAsync) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = isString(language) ? language : this.language;
    if (typeof language === 'function') usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng?.toLowerCase() === 'cimode' && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = lng => {
        if (!lng) return;
        if (lng === 'cimode') return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach(l => {
          if (l === 'cimode') return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach(l => append(l));
      } else {
        append(usedLng);
      }
      this.options.preload?.forEach?.(l => append(l));
      this.services.backendConnector.load(toLoad, this.options.ns, e => {
        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === 'function') {
      callback = lngs;
      lngs = undefined;
    }
    if (typeof ns === 'function') {
      callback = ns;
      ns = undefined;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, err => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
    if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');
    if (module.type === 'backend') {
      this.modules.backend = module;
    }
    if (module.type === 'logger' || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === 'languageDetector') {
      this.modules.languageDetector = module;
    }
    if (module.type === 'i18nFormat') {
      this.modules.i18nFormat = module;
    }
    if (module.type === 'postProcessor') {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === 'formatter') {
      this.modules.formatter = module;
    }
    if (module.type === '3rdParty') {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (['cimode', 'dev'].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit('languageChanging', lng);
    const setLngProps = l => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = undefined;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        setLngProps(l);
        this.translator.changeLanguage(l);
        this.isLanguageChangingTo = undefined;
        this.emit('languageChanged', l);
        this.logger.log('languageChanged', l);
      } else {
        this.isLanguageChangingTo = undefined;
      }
      deferred.resolve(function () {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function () {
        return _this2.t(...arguments);
      });
    };
    const setLng = lngs => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l = isString(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        this.services.languageDetector?.cacheUserLanguage?.(l);
      }
      this.loadResources(l, err => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function (key, opts) {
      let options;
      if (typeof opts !== 'object') {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== '') options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || '.';
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map(k => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (isString(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.translator?.translate(...args);
  }
  exists() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return this.translator?.exists(...args);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === 'cimode') return true;
    const loadNotPending = (l, n) => {
      const loadState = this.services.backendConnector.state[`${l}|${n}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== undefined) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString(ns)) ns = [ns];
    ns.forEach(n => {
      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
    });
    this.loadResources(err => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter(lng => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources(err => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);
    if (!lng) return 'rtl';
    const rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];
    const languageUtils = this.services?.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : undefined;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new I18n(mergedOptions);
    if (options.debug !== undefined || options.prefix !== undefined) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ['store', 'services', 'language'];
    membersToCopy.forEach(m => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      const clonedData = Object.keys(this.store.data).reduce((prev, l) => {
        prev[l] = {
          ...this.store.data[l]
        };
        return Object.keys(prev[l]).reduce((acc, n) => {
          acc[n] = {
            ...prev[l][n]
          };
          return acc;
        }, {});
      }, {});
      clone.store = new ResourceStore(clonedData, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on('*', function (event) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        args[_key6 - 1] = arguments[_key6];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;

const createInstance = instance.createInstance;
const dir = instance.dir;
const init = instance.init;
const loadResources = instance.loadResources;
const reloadResources = instance.reloadResources;
const use = instance.use;
const changeLanguage = instance.changeLanguage;
const getFixedT = instance.getFixedT;
const t = instance.t;
const exists = instance.exists;
const setDefaultNamespace = instance.setDefaultNamespace;
const hasLoadedNamespace = instance.hasLoadedNamespace;
const loadNamespaces = instance.loadNamespaces;
const loadLanguages = instance.loadLanguages;




/***/ }),

/***/ "./node_modules/.pnpm/strip-ansi@7.1.0/node_modules/strip-ansi/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/strip-ansi@7.1.0/node_modules/strip-ansi/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ stripAnsi)
/* harmony export */ });
/* harmony import */ var ansi_regex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ansi-regex */ "./node_modules/.pnpm/ansi-regex@6.1.0/node_modules/ansi-regex/index.js");


const regex = (0,ansi_regex__WEBPACK_IMPORTED_MODULE_0__["default"])();

function stripAnsi(string) {
	if (typeof string !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	}

	// Even though the regex is global, we don't need to reset the `.lastIndex`
	// because unlike `.exec()` and `.test()`, `.replace()` does it automatically
	// and doing it manually has a performance penalty.
	return string.replace(regex, '');
}


/***/ }),

/***/ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/native.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/native.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ randomUUID: crypto__WEBPACK_IMPORTED_MODULE_0__.randomUUID });


/***/ }),

/***/ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/regex.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);


/***/ }),

/***/ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/rng.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/rng.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");

const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
        (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomFillSync)(rnds8Pool);
        poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, (poolPtr += 16));
}


/***/ }),

/***/ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/stringify.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/stringify.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/validate.js");

const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] +
        byteToHex[arr[offset + 1]] +
        byteToHex[arr[offset + 2]] +
        byteToHex[arr[offset + 3]] +
        '-' +
        byteToHex[arr[offset + 4]] +
        byteToHex[arr[offset + 5]] +
        '-' +
        byteToHex[arr[offset + 6]] +
        byteToHex[arr[offset + 7]] +
        '-' +
        byteToHex[arr[offset + 8]] +
        byteToHex[arr[offset + 9]] +
        '-' +
        byteToHex[arr[offset + 10]] +
        byteToHex[arr[offset + 11]] +
        byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] +
        byteToHex[arr[offset + 14]] +
        byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);


/***/ }),

/***/ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/v4.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/v4.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/native.js");
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/stringify.js");



function v4(options, buf, offset) {
    if (_native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID && !buf && !options) {
        return _native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? (0,_rng_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    if (buf) {
        offset = offset || 0;
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
        for (let i = 0; i < 16; ++i) {
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);


/***/ }),

/***/ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/validate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/validate.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/.pnpm/uuid@11.0.5/node_modules/uuid/dist/esm/regex.js");

function validate(uuid) {
    return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);


/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/file.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/file.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encodings: () => (/* binding */ encodings),
/* harmony export */   fappend: () => (/* binding */ fappend),
/* harmony export */   fcopy: () => (/* binding */ fcopy),
/* harmony export */   fdclear: () => (/* binding */ fdclear),
/* harmony export */   fdelete: () => (/* binding */ fdelete),
/* harmony export */   fequals: () => (/* binding */ fequals),
/* harmony export */   fexists: () => (/* binding */ fexists),
/* harmony export */   ffstat: () => (/* binding */ ffstat),
/* harmony export */   flink: () => (/* binding */ flink),
/* harmony export */   flist: () => (/* binding */ flist),
/* harmony export */   flstat: () => (/* binding */ flstat),
/* harmony export */   fmkdir: () => (/* binding */ fmkdir),
/* harmony export */   fmove: () => (/* binding */ fmove),
/* harmony export */   fopen: () => (/* binding */ fopen),
/* harmony export */   fpack: () => (/* binding */ fpack),
/* harmony export */   fparse: () => (/* binding */ fparse),
/* harmony export */   fread: () => (/* binding */ fread),
/* harmony export */   fread_json: () => (/* binding */ fread_json),
/* harmony export */   fread_lines: () => (/* binding */ fread_lines),
/* harmony export */   frename: () => (/* binding */ frename),
/* harmony export */   freplace: () => (/* binding */ freplace),
/* harmony export */   fsp: () => (/* reexport safe */ fs__WEBPACK_IMPORTED_MODULE_0__.promises),
/* harmony export */   fstat: () => (/* binding */ fstat),
/* harmony export */   ftail: () => (/* binding */ ftail),
/* harmony export */   fwatchers: () => (/* binding */ fwatchers),
/* harmony export */   fwrite: () => (/* binding */ fwrite),
/* harmony export */   fzip: () => (/* binding */ fzip),
/* harmony export */   ramdisk: () => (/* binding */ ramdisk),
/* harmony export */   zip: () => (/* binding */ zip)
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var util_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util/types */ "util/types");
/* harmony import */ var _i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./i18n/instance.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/instance.js");
/* harmony import */ var _prototype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./prototype.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/prototype.js");
/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./io.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/io.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/path.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/utils.js");








const encodings = ['utf-8', 'gb18030', 'shift-jis', 'utf-16le'];
const ramdisk = fexists('T:/TEMP/', { print: false });
/** fp æ‰€æŒ‡å‘çš„ æ–‡ä»¶/ æ–‡ä»¶å¤¹ æ˜¯å¦å­˜åœ¨
    Does the file/folder pointed to by fp exist?  */
function fexists(fp, { print = true } = {}) {
    const exists = fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(fp);
    if (print)
        console.log(exists ? (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('å·²å­˜åœ¨') : (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('ä¸å­˜åœ¨'), fp);
    return exists;
}
/** æ‰“å¼€æˆ–åˆ›å»ºæ–‡ä»¶ï¼Œè¿”å›ž FileHandle, å¦‚æžœæ–‡ä»¶å¤¹ä¸å­˜åœ¨ï¼Œä¼šè‡ªåŠ¨åˆ›å»ºæ–‡ä»¶å¤¹
    Some characters (`< > : " / \ | ? *`) are reserved under Windows as documented
    by [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file). Under NTFS, if the filename contains
    a colon, Node.js will open a file system stream, as described by [this MSDN page](https://docs.microsoft.com/en-us/windows/desktop/FileIO/using-streams).
    
    - flags: `'r'`  https://nodejs.org/docs/latest/api/fs.html#file-system-flags
    - options?:
        - mode?: `'0o666'` Sets the file mode (permission and sticky bits) if the file is created. */
async function fopen(fp, flags = 'r', { mode, print } = {}) {
    if (print)
        console.log((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('æ‰“å¼€æ–‡ä»¶'), fp);
    await fmkdir(fp.fdir, { print: false });
    return Object.assign(await fs__WEBPACK_IMPORTED_MODULE_0__.promises.open(fp, flags, mode), { fp, flags, mode });
}
async function fread(fp, { encoding = 'utf-8', print = true } = {}) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(!fp.isdir, (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fp å¿…é¡»æ˜¯æ–‡ä»¶ï¼Œä¸èƒ½ä»¥ / ç»“å°¾'));
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp), `${(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fp å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„:')} ${fp}`);
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(encoding !== 'auto');
    if (print)
        console.log((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('è¯»å–'), fp);
    switch (encoding) {
        case 'utf-8':
            return fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(fp, { encoding: 'utf-8' });
        case 'binary':
            return fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(fp);
        default:
            return new TextDecoder(encoding)
                .decode(await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(fp));
    }
}
/** è¯»å–æ–‡ä»¶ï¼Œåˆ’åˆ†ä¸ºè¡Œï¼Œå¹¶åŽ»æŽ‰æœ€åŽä¸€ä¸ª \n ä¹‹åŽçš„ '' */
async function fread_lines(fp, options = {}) {
    return (await fread(fp, options))
        .split_lines();
}
async function fread_json(fp, options = {}) {
    return JSON.parse(await fread(fp, options));
}
async function fparse(fp, options) {
    return (0,_io_js__WEBPACK_IMPORTED_MODULE_4__.parse)(await fread(fp, { ...options, encoding: 'binary' }));
}
/** æ¯”è¾ƒä¸¤ä¸ªæ–‡ä»¶æ˜¯å¦ä¸€è‡´ï¼Œé‡åˆ°ä»»ä½•æ–‡ä»¶ç³»ç»Ÿé”™è¯¯éƒ½è¿”å›ž false */
async function fequals(fp_left, fp_right, { print = true } = {}) {
    if (print)
        console.log(`æ¯”è¾ƒ ${fp_left} å’Œ ${fp_right}`);
    try {
        const fps = [fp_left, fp_right];
        const [{ size: size_left }, { size: size_right }] = await Promise.all(fps.map(async (fp) => fstat(fp)));
        if (size_left === size_right) {
            const [data_left, data_right] = await Promise.all(fps.map(async (fp) => fread(fp, { encoding: 'binary', print: false })));
            return data_left.equals(data_right);
        }
        else
            return false;
    }
    catch {
        return false;
    }
}
async function fwrite(fp, data, { print = true } = {}) {
    const is_handle = typeof fp === 'object' && fp && 'fd' in fp;
    if (is_handle) {
        if (print)
            console.log((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('å†™å…¥'), fp.fp);
    }
    else {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp), `${(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fp å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„ï¼Œå½“å‰ä¸º:')} ${fp}`);
        if (print)
            console.log((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('å†™å…¥'), fp);
    }
    if (!(0,util_types__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(data) && typeof data !== 'string')
        data = (0,_prototype_js__WEBPACK_IMPORTED_MODULE_3__.to_json)(data);
    try {
        await fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(fp, data);
    }
    catch (error) {
        if (error.code === 'ENOENT' && !is_handle) {
            await fmkdir(fp.fdir, { print: false });
            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(fp, data);
        }
        else
            throw error;
    }
    return fp;
}
async function fpack(fp, data, options) {
    return fwrite(fp, (0,_io_js__WEBPACK_IMPORTED_MODULE_4__.pack)(data), options);
}
/** è¿½åŠ å†…å®¹åˆ°æ–‡ä»¶æœ«å°¾ï¼Œå¦‚æžœæ–‡ä»¶ä¸å­˜åœ¨ä¼šè‡ªåŠ¨åˆ›å»º */
async function fappend(fp, data, { print = true } = {}) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp), `${(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fp å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„ï¼Œå½“å‰ä¸º:')} ${fp}`);
    if (print)
        console.log((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('è¿½åŠ '), fp);
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)((0,util_types__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(data) || typeof data === 'string');
    try {
        await fs__WEBPACK_IMPORTED_MODULE_0__.promises.appendFile(fp, data);
    }
    catch (error) {
        if (error.code === 'ENOENT') {
            await fmkdir(fp.fdir, { print: false });
            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.appendFile(fp, data);
        }
        else
            throw error;
    }
}
const fake_time = new Date(0);
const fake_stats = {
    fp: '',
    size: 0n,
    atimeNs: 0n,
    mtimeNs: 0n,
    ctimeNs: 0n,
    birthtimeNs: 0n,
    atimeMs: 0n,
    mtimeMs: 0n,
    ctimeMs: 0n,
    birthtimeMs: 0n,
    mtime: fake_time,
    atime: fake_time,
    ctime: fake_time,
    birthtime: fake_time,
};
async function flist(fpd, options = {}) {
    const { filter, deep = false, absolute = false, print = true, stats = false, best_effort = false } = options;
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fpd), (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)("flist: å‚æ•° fpd: '{{fpd}}' å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„", { fpd }));
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(fpd.isdir, (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)("flist: å‚æ•° fpd: '{{fpd}}' å¿…é¡»ä»¥ / ç»“å°¾", { fpd }));
    if (!_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fpd))
        throw new Error((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('å‚æ•° fpd: ') + fpd + (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)(' å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„'));
    if (!fpd.isdir)
        throw new Error((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('å‚æ•° fpd: ') + fpd + (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)(' å¿…é¡»ä»¥ / ç»“å°¾'));
    // readdir withFileTypes å‚æ•°åœ¨åº•å±‚æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Œé€Ÿåº¦ä¸Šæœ‰ä»€ä¹ˆå·®å¼‚
    // éƒ½è°ƒç”¨äº† uv_fs_scandir, ä¸”è°ƒç”¨å‚æ•°ç›¸åŒï¼Œä»…ä»…æ˜¯ Node.js ä¾§çš„å›žè°ƒä¸åŒ AfterScanDir / AfterScanDirWithTypes
    // å›žè°ƒä¸­é€šè¿‡ uv_fs_scandir_next èŽ·å–åˆ°æ¯ä¸ªæ¡ç›®çš„ä¿¡æ¯ï¼Œè€Œ uv_fs_scandir_next ä¸­éƒ½ä¼šè¯»å– type
    // é€Ÿåº¦ä¸Šï¼šéƒ½åœ¨ 0.2 ms å·¦å³å°±å¯ä»¥å®Œæˆ
    const files = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readdir(fpd, { withFileTypes: true, encoding: 'utf-8' });
    const filter_regexp = filter instanceof RegExp;
    const filter_fn = Boolean(filter && !filter_regexp);
    let fps = [];
    for (const file of files) {
        const fp = (absolute ? fpd : '') +
            file.name +
            (file.isDirectory() ? '/' : '');
        if (filter_regexp && !filter.test(fp))
            continue;
        if (filter_fn && !filter(fp))
            continue;
        if (print)
            console.log(fp);
        fps.push(fp);
    }
    async function _fstat(fp) {
        let _stats;
        try {
            _stats = await fstat(absolute ? fp : fpd + fp);
        }
        catch (error) {
            if (best_effort)
                _stats = { ...fake_stats };
            else
                throw error;
        }
        if (!absolute)
            _stats.fp = fp;
        return _stats;
    }
    if (deep)
        return (await Promise.all(
        // é¡¶å±‚æ–‡ä»¶/æ–‡ä»¶å¤¹
        fps.map(async (fp) => {
            /** é¡¶å±‚æ–‡ä»¶å¤¹çš„å¤§å° */
            let fpd_stats;
            return fp.isdir ?
                [
                    stats ? (fpd_stats = await _fstat(fp)) : fp,
                    ...(await flist(absolute ? fp : fpd + fp, options)).map((fp_or_stats) => {
                        if (stats) {
                            if (!absolute)
                                fp_or_stats.fp = fp + fp_or_stats.fp;
                            // æ‰€æœ‰é¡¶å±‚æ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶ï¼ˆä¸åŒ…æ‹¬æ–‡ä»¶å¤¹ï¼‰å¤§å°æ€»å’ŒåŠ èµ·æ¥ä½œä¸ºæ–‡ä»¶å¤¹å¤§å°
                            if (!fp_or_stats.fp.isdir)
                                fpd_stats.size += fp_or_stats.size;
                            return fp_or_stats;
                        }
                        else
                            return absolute ? fp_or_stats : fp + fp_or_stats;
                    })
                ]
                :
                    stats ? _fstat(fp) : fp;
        }))).flat();
    else if (stats)
        return Promise.all(fps.map(_fstat));
    else
        return fps;
}
async function fstat(fp) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp), (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)("fstat: å‚æ•° fp: '{{fp}}' å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„", { fp }));
    let stat = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.stat(fp, { bigint: true });
    stat.fp = fp;
    return stat;
}
async function flstat(fp) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp), (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)("flstat: å‚æ•° fp: '{{fp}}' å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„", { fp }));
    let stat = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.lstat(fp, { bigint: true });
    stat.fp = fp;
    return stat;
}
async function ffstat(handle) {
    return new Promise((resolve, reject) => {
        fs__WEBPACK_IMPORTED_MODULE_0__.fstat(handle.fd, { bigint: true }, (error, stats) => {
            if (error)
                reject(error);
            else
                resolve(stats);
        });
    });
}
/** åˆ é™¤æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹ï¼Œè¿”å›žæ˜¯å¦å®žé™…è¿›è¡Œäº†åˆ é™¤æ“ä½œ
    - fp: æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹çš„å®Œæ•´è·¯å¾„
    - options?:
        - print?: `true` */
async function fdelete(fp, { print = true } = {}) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(fp.length >= 6, `fp: ${fp} ${(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('ä¸èƒ½å¤ªçŸ­ï¼Œé˜²æ­¢è¯¯åˆ æ–‡ä»¶')}`);
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp), (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fp å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„'));
    const { isdir } = fp;
    try {
        await fs__WEBPACK_IMPORTED_MODULE_0__.promises.rm(fp, { recursive: true });
        if (print)
            console.log(`${isdir ? (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('åˆ é™¤äº†æ–‡ä»¶å¤¹') : (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('åˆ é™¤äº†æ–‡ä»¶')} ${fp}`);
        return true;
    }
    catch (error) {
        if (error.code === 'ENOENT') {
            if (print)
                console.log(`${isdir ? (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)(`å·²ä¸å­˜åœ¨æ–‡ä»¶`) : (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('å·²ä¸å­˜åœ¨æ–‡ä»¶å¤¹')} ${fp}`);
            return false;
        }
        throw error;
    }
}
/** æ¸…ç©ºæ–‡ä»¶å¤¹ä¸­çš„å†…å®¹ï¼Œå®žé™…ä¸ºåˆ é™¤è¯¥æ–‡ä»¶å¤¹åŽæ–°å»º */
async function fdclear(fpd, { print = true } = {}) {
    await fdelete(fpd, { print: false });
    await fmkdir(fpd, { print: false });
    if (print)
        console.log(`æ¸…ç©ºäº†æ–‡ä»¶å¤¹ ${fpd}`);
}
/** å¤åˆ¶æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹
    ä¼šåœ¨å› ä¸å­˜åœ¨çˆ¶æ–‡ä»¶å¤¹å¯¼è‡´å¤åˆ¶å¤±è´¥æ—¶ï¼Œè‡ªåŠ¨åˆ›å»ºçˆ¶æ–‡ä»¶å¤¹ï¼Œå¹¶å†æ¬¡å°è¯•å¤åˆ¶
    æœ€å¥½é¢„å…ˆåˆ›å»ºçˆ¶æ–‡ä»¶å¤¹ï¼Œå‡å°‘æ–‡ä»¶ç³»ç»Ÿæ“ä½œï¼Œæå‡æ€§èƒ½
    - fp_src: æº æ–‡ä»¶/æ–‡ä»¶å¤¹ å®Œæ•´è·¯å¾„
    - fp_dst: ç›®æ ‡ æ–‡ä»¶/æ–‡ä»¶å¤¹ å®Œæ•´è·¯å¾„
    - options?:
        - print?: `true`
        - overwrite?: `true`
        - filter?: å½“ fp_src ä¸ºæ–‡ä»¶å¤¹æ—¶é€‰æ‹©æ€§å¤åˆ¶é‡Œé¢çš„éƒ¨åˆ†å†…å®¹ï¼Œ
            å’Œ flist çš„ filter é€‰é¡¹ä¸åŒï¼Œåªæ”¯æŒå‡½æ•°ï¼Œä¸”å‡½æ•°è¿”å›žå€¼å†³å®šæ˜¯å¦è¦ç»§ç»­è¿›è¡Œè¿‡æ»¤
            - true: å¤åˆ¶æ–‡ä»¶å¤¹çš„æ‰€æœ‰æ–‡ä»¶ï¼Œäº¤ç»™ fsp.cp
            - false æˆ–ä¸è¿”å›žä»»ä½•å€¼: ä¸å¤åˆ¶
            - 'partial': è¿›ä¸€æ­¥è¿›è¡Œè¿‡æ»¤å¤åˆ¶ï¼ˆå…ˆ flist with filter å† fcopyï¼‰ï¼Œåªæœ‰æ–‡ä»¶å¤¹èƒ½è¿”å›žè¿™ä¸ªå€¼
        
    @example
    fcopy('D:/temp/camera/', 'D:/camera/') */
async function fcopy(fp_src, fp_dst, { print = true, overwrite = true, filter, } = {}) {
    const { isdir } = fp_src;
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(isdir === fp_dst.isdir, (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fp_src å’Œ fp_dst å¿…é¡»åŒä¸ºæ–‡ä»¶è·¯å¾„æˆ–æ–‡ä»¶å¤¹è·¯å¾„'));
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp_src) && _path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp_dst), (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fp_src å’Œ fp_dst å¿…é¡»ä¸ºå®Œæ•´è·¯å¾„'));
    if (!isdir && filter)
        throw new Error((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('filter é€‰é¡¹åªé€‚ç”¨äºŽ fp_src ä¸ºæ–‡ä»¶å¤¹'));
    if (print)
        log_action('å¤åˆ¶', fp_src, fp_dst);
    if (isdir)
        if (filter) {
            await fmkdir(fp_dst, { print });
            await Promise.all((await flist(fp_src, { filter, print: false }))
                .map(async (fname) => fcopy(`${fp_src}${fname}`, `${fp_dst}${fname}`, {
                print,
                overwrite,
                ...fname.isdir && filter(fname) === 'filter' ? {
                    filter: fp => filter(`${fname}${fp}`),
                } : {}
            })));
        }
        else
            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.cp(fp_src, fp_dst, {
                recursive: true,
                force: overwrite,
                errorOnExist: !overwrite,
                mode: overwrite ? 0 : fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_EXCL,
            });
    else
        try {
            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.copyFile(fp_src, fp_dst, overwrite ? 0 : fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_EXCL);
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                await fmkdir(fp_dst.fdir, { print });
                await fs__WEBPACK_IMPORTED_MODULE_0__.promises.copyFile(fp_src, fp_dst, overwrite ? 0 : fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_EXCL);
            }
            else
                throw error;
        }
}
/** ç§»åŠ¨æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹
    ç›¸åŒåˆ†åŒº / æ–‡ä»¶ç³»ç»Ÿä¸‹ä½¿ç”¨ rename, å¦åˆ™ fallback åˆ°å¤åˆ¶åŽåˆ é™¤æºæ–‡ä»¶
    - src: æº æ–‡ä»¶/æ–‡ä»¶å¤¹ å®Œæ•´è·¯å¾„
    - dst: ç›®æ ‡ æ–‡ä»¶/æ–‡ä»¶å¤¹ å®Œæ•´è·¯å¾„
    - options?:
        - print?: `true`
        - overwrite?: `false`
    
    @example
    fmove('D:/temp/camera/', 'D:/camera/') */
async function fmove(fp_src, fp_dst, { overwrite = false, print = true } = {}) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(fp_src.isdir === fp_dst.isdir, (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fp_src å’Œ fp_dst å¿…é¡»åŒä¸ºæ–‡ä»¶è·¯å¾„æˆ–æ–‡ä»¶å¤¹è·¯å¾„'));
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp_src) && _path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp_dst), (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fp_src å’Œ fp_dst å¿…é¡»ä¸ºå®Œæ•´è·¯å¾„'));
    if (print)
        log_action('ç§»åŠ¨', fp_src, fp_dst);
    if (!overwrite && fexists(fp_dst, { print: false }))
        throw new Error(`${(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('å·²å­˜åœ¨')} ${fp_dst}`);
    await fmkdir(fp_dst.fdir, { print: false });
    async function copy_and_delete() {
        await fcopy(fp_src, fp_dst, { overwrite, print: false });
        await fdelete(fp_src, { print: false });
    }
    if (fp_src[0] !== fp_dst[0] || overwrite)
        await copy_and_delete();
    else
        try {
            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.rename(fp_src, fp_dst);
        }
        catch (error) {
            if (error.code === 'EXDEV')
                await copy_and_delete();
            else
                throw error;
        }
}
/** é‡å‘½åæ–‡ä»¶  rename file
    - fp:  å½“å‰æ–‡ä»¶åï¼è·¯å¾„  current filename/path
    - fp_: æ–°çš„æ–‡ä»¶åï¼è·¯å¾„  new filename/path
    - options?:
        - fpd?: fp å’Œ fp_ åœ¨åŒä¸€æ–‡ä»¶å¤¹å†…  fp and fp_ is in same directory
        - print?: `true`
        - overwrite?: `true`  é»˜è®¤è¦†ç›–ï¼ˆä¸æ£€æŸ¥æ•ˆçŽ‡æ›´é«˜ï¼‰  better performance without check */
async function frename(fp, fp_, { fpd, print = true, overwrite = true } = {}) {
    if (fpd) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(fpd.isdir);
        fp = fpd + fp;
        fp_ = fpd + fp_;
    }
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp) && _path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp_), (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fp å’Œ fp_ å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„'));
    if (print)
        log_action('é‡å‘½å', fp, fp_);
    if (!overwrite && fexists(fp_, { print: false }))
        throw new Error(`${(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('å·²å­˜åœ¨')} ${fp}`);
    await fs__WEBPACK_IMPORTED_MODULE_0__.promises.rename(fp, fp_);
}
/**
    é€’å½’åˆ›å»ºæ–‡ä»¶å¤¹ï¼Œç¡®ä¿ fpd æŒ‡å‘çš„æ–‡ä»¶å¤¹å­˜åœ¨  Create folders recursively, make sure the folder pointed to by fpd exists
    è¿”å›žé¦–ä¸ªåˆ›å»ºçš„æ–‡ä»¶å¤¹æˆ– undefined  Returns the first created folder or undefined
    
    - fpd: æ–‡ä»¶å¤¹å®Œæ•´è·¯å¾„  Folder full path
    - options?:
        - print?: `true`
        - mode?: `'0o777'` */
async function fmkdir(fpd, { print = true, mode, } = {}) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fpd), (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fpd å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„: ') + fpd);
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(fpd.isdir, (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('fpd å¿…é¡»ä»¥ / ç»“å°¾: ') + fpd);
    // ç±»ä¼¼ D:/ è¿™æ ·çš„æ ¹è·¯å¾„ï¼Œè°ƒç”¨ fsp.mkdir ä¼šæŠ¥é”™æ— æƒé™
    if (fpd.length === 3 &&
        'A' <= fpd[0] && fpd[0] <= 'Z' && fpd[1] === ':' && fpd[2] === '/')
        if (fexists(fpd)) {
            if (print)
                console.log((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('å·²å­˜åœ¨æ–‡ä»¶å¤¹'), fpd);
            return fpd;
        }
        else
            throw new Error((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('ä¸å­˜åœ¨ä¸”æ— æ³•åˆ›å»ºæ–‡ä»¶å¤¹ {{fpd}}', { fpd }));
    // Calling fs.promises.mkdir() when path is a directory that exists results in a rejection only when recursive is false.
    const fpd_ = (await fs__WEBPACK_IMPORTED_MODULE_0__.promises.mkdir(fpd, { recursive: true, mode }))?.fpd;
    if (fpd_) {
        if (print)
            console.log((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('å·²åˆ›å»ºæ–‡ä»¶å¤¹'), fpd);
    }
    else if (print)
        console.log((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_2__.t)('å·²å­˜åœ¨æ–‡ä»¶å¤¹'), fpd);
    return fpd_;
}
/** åˆ›å»ºè½¯é“¾æŽ¥
    - fp_real: çŽ°åœ¨çœŸå®žæ–‡ä»¶/æ–‡ä»¶å¤¹çš„è·¯å¾„
    - fp_link: ç›®æ ‡é“¾æŽ¥æ–‡ä»¶/æ–‡ä»¶å¤¹çš„è·¯å¾„ */
async function flink(fp_real, fp_link, { junction = false, print = true, skip_existing = false } = {}) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp_real) && _path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fp_link), 'fp å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„');
    const is_fpd_real = fp_real.isdir;
    const is_fpd_link = fp_link.isdir;
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(is_fpd_real === is_fpd_link, 'fp_real å’Œ fp_link å¿…é¡»åŒä¸ºæ–‡ä»¶è·¯å¾„æˆ–æ–‡ä»¶å¤¹è·¯å¾„');
    if (fexists(fp_link, { print: false }))
        if (!skip_existing)
            throw new Error(`å­˜åœ¨åŒå${is_fpd_link ? 'æ–‡ä»¶å¤¹' : 'æ–‡ä»¶'}: ${fp_link}ï¼Œæ— æ³•åˆ›å»ºé“¾æŽ¥`);
        else {
            if (print)
                console.log('è·³è¿‡å·²å­˜åœ¨:', fp_link);
            return;
        }
    if (print)
        log_action('å·²å°†æºæ–‡ä»¶', fp_real, fp_link, 'é“¾æŽ¥åˆ°');
    if (junction)
        await fs__WEBPACK_IMPORTED_MODULE_0__.promises.symlink(fp_real, fp_link, 'junction');
    else
        await fs__WEBPACK_IMPORTED_MODULE_0__.promises.symlink(fp_real, fp_link, is_fpd_real ? 'dir' : 'file');
}
/** å°†æ–‡ä»¶å¤¹æˆ–æ–‡ä»¶åˆ—è¡¨åŽ‹ç¼©ä¸º zipï¼Œè¿”å›žç”Ÿæˆçš„åŽ‹ç¼©åŒ…è·¯å¾„ (fp_zip)
    - data:
        - fpd_src: è¢«åŽ‹ç¼©æ–‡ä»¶å¤¹è·¯å¾„ (string) æˆ–
        - entries: æ–‡ä»¶åˆ—è¡¨ (Record<åŽ‹ç¼©åŽç›¸å¯¹è·¯å¾„, åŽŸæ–‡ä»¶ç»å¯¹è·¯å¾„ (string) | æ•°æ® (Uint8Array)>)
    - fp_zip: ç”Ÿæˆçš„åŽ‹ç¼©åŒ…è·¯å¾„ (string)
    - options?:
        - dirname?: `fpd_src.fname` ä¼ å…¥ fpd_src æ‰ç”Ÿæ•ˆï¼Œä¿®æ”¹ zip ä¸­é¡¶å±‚çš„æ–‡ä»¶å¤¹çš„åå­—ï¼ˆéœ€è¦ä»¥ / ç»“å°¾ï¼‰ï¼Œå¦‚ 'web/', ä¸ºç©ºå­—ç¬¦ä¸²æ—¶åŽ»æŽ‰é¡¶å±‚æ–‡ä»¶å¤¹ï¼Œä¸è¦å¤šä¸€ä¸ªæ–‡ä»¶å¤¹å±‚çº§ (flat)
        - print?:
            - info?: `true` å¼€å§‹åŽ‹ç¼©ã€åŽ‹ç¼©å®Œæˆ
            - files?: `true` æ‰“å°åŽ‹ç¼©æ–‡ä»¶åˆ—è¡¨ */
async function fzip(data, fp_zip, options) {
    return _zip(data, fp_zip, options);
}
/** å°†æ–‡ä»¶å¤¹æˆ–æ–‡ä»¶åˆ—è¡¨åŽ‹ç¼©ä¸º zipï¼Œè¿”å›žåŽ‹ç¼©åŒ…æ•°æ® (Uint8Array)
    - data:
        - fpd_src: è¢«åŽ‹ç¼©æ–‡ä»¶å¤¹è·¯å¾„ (string) æˆ–
        - entries: æ–‡ä»¶åˆ—è¡¨ (Record<åŽ‹ç¼©åŽç›¸å¯¹è·¯å¾„, åŽŸæ–‡ä»¶ç»å¯¹è·¯å¾„ (string) | æ•°æ® (Uint8Array)>)
    - options?:
        - print?:
            - info?: `true` å¼€å§‹åŽ‹ç¼©ã€åŽ‹ç¼©å®Œæˆ
            - files?: `true` æ‰“å°åŽ‹ç¼©æ–‡ä»¶åˆ—è¡¨ */
async function zip(data, options) {
    return _zip(data, undefined, options);
}
async function _zip(data, fp_zip, { dirname, print = { files: true, info: true } } = {}) {
    let entries;
    let fpd_src;
    if (typeof data === 'string') {
        if (!_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(data) || !data.isdir)
            throw new Error('fpd_src å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„ä¸”ä»¥ / ç»“å°¾');
        fpd_src = data;
        if (dirname === undefined)
            dirname = fpd_src.fname;
        if (!dirname.isdir)
            throw new Error('dirname éœ€è¦ä»¥ / ç»“å°¾');
        entries = Object.fromEntries((await flist(fpd_src, { print: false }))
            .map(fp => ([dirname + fp, fpd_src + fp])));
    }
    else {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(!dirname, 'dirname åœ¨ä¼ å…¥ fpd_src æ—¶æ‰ç”Ÿæ•ˆ');
        entries = data;
    }
    if (print.info)
        log_action('å¼€å§‹åŽ‹ç¼©', fpd_src ? ` ${fpd_src}` : 'æ–‡ä»¶ç´¢å¼•', fp_zip ? `${fp_zip}/${dirname || '{entries}'}` : 'å†…å­˜');
    const { default: archiver } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_pnpm_archiver_7_0_1_node_modules_archiver_index_js").then(__webpack_require__.t.bind(__webpack_require__, /*! archiver */ "./node_modules/.pnpm/archiver@7.0.1/node_modules/archiver/index.js", 19));
    let archive = archiver('zip');
    let ostream = fp_zip ?
        fs__WEBPACK_IMPORTED_MODULE_0__.createWriteStream(fp_zip, { highWaterMark: 16 * 2 ** 20 /* 16 MB */ })
        :
            new _utils_js__WEBPACK_IMPORTED_MODULE_6__.WritableMemoryStream();
    const size = await new Promise(async (resolve, reject) => {
        ostream.once('close', () => {
            resolve(archive.pointer());
        });
        ostream.once('error', reject);
        archive.once('error', reject);
        archive.on('warning', error => {
            console.log(error);
        });
        archive.pipe(ostream);
        for (const fp in entries) {
            const fdata = entries[fp];
            if (fdata instanceof Uint8Array) {
                if (print.files)
                    log_action('åŽ‹ç¼©', fdata.length.to_fsize_str(), fp);
                archive.append(Buffer.isBuffer(fdata) ? fdata : Buffer.from(fdata.buffer), { name: fp });
            }
            else {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(fp.isdir === fdata.isdir);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(_path_js__WEBPACK_IMPORTED_MODULE_5__.path.isAbsolute(fdata));
                if (print.files)
                    log_action('åŽ‹ç¼©', fdata, fp);
                if (fp.isdir)
                    archive.directory(fdata, fp);
                else
                    archive.file(fdata, { name: fp });
            }
        }
        await archive.finalize();
    });
    if (print.info)
        console.log(`åŽ‹ç¼©å®Œæˆï¼Œæ€»å¤§å° ${size.to_fsize_str()}`);
    return fp_zip || ostream.pbuffer;
}
let fwatchers = {};
/** è·Ÿè¸ªæ–‡æœ¬æ–‡ä»¶è¿½åŠ çš„å†…å®¹ï¼Œç±»ä¼¼ tail -f */
async function ftail(fp, handler, { print = true } = {}) {
    fwatchers[fp]?.close();
    const { size } = await fstat(fp);
    let pointer = Number(size);
    let lock = new _utils_js__WEBPACK_IMPORTED_MODULE_6__.Lock(await fopen(fp));
    let fbuf = Buffer.allocUnsafe(2 ** 20);
    let strbuf = '';
    let decoder = new TextDecoder();
    if (print)
        console.log('å¼€å§‹è·Ÿè¸ªè¿½åŠ å†…å®¹', fp);
    const { default: throttle } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_pnpm_lodash_4_17_21_node_modules_lodash_throttle_js").then(__webpack_require__.t.bind(__webpack_require__, /*! lodash/throttle.js */ "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/throttle.js", 19));
    const onchange_throttled = throttle(async () => {
        if (lock.locked)
            return;
        await lock.request(async (handle) => {
            const { bytesRead } = await handle.read(fbuf, 0, fbuf.length, pointer);
            pointer += bytesRead;
            const chunk = decoder.decode(fbuf.subarray(0, bytesRead), { stream: true });
            let lines = [];
            let j = 0;
            for (let i = 0; (i = chunk.indexOf('\n', j)) >= 0;) {
                let line = chunk.slice(j, i);
                if (strbuf) {
                    line = strbuf + line;
                    strbuf = '';
                }
                j = i + 1;
                lines.push(line);
            }
            strbuf = chunk.slice(j);
            await handler(lines);
        });
    }, 250);
    let watcher = fs__WEBPACK_IMPORTED_MODULE_0__.watch(fp, event => {
        if (event === 'change')
            onchange_throttled();
        else {
            console.error(`è¢«ç›‘å¬çš„æ–‡ä»¶ ${fp.quote()} å‡ºçŽ°äº† rename äº‹ä»¶ï¼Œç»“æŸ ftail`);
            watcher.close();
        }
    });
    watcher.on('error', error => {
        console.error(error);
    });
    return fwatchers[fp] = watcher;
}
/** æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶å¹¶æœç´¢æ›¿æ¢æŸä¸ª pattern */
async function freplace(fp, pattern, replacement, { print = true } = {}) {
    await fwrite(fp, (await fread(fp, { print }))
        .replaceAll(pattern, replacement), { print });
}
function log_action(action, fp_src, fp_dst, sep = '->') {
    console.log(`${`${action}  ${fp_src}`.pad(_utils_js__WEBPACK_IMPORTED_MODULE_6__.url_width)}  ${sep}  ${fp_dst}`);
}
//# sourceMappingURL=file.js.map

/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/dict.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/dict.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dict: () => (/* binding */ Dict)
/* harmony export */ });
class Dict {
    _dict;
    constructor(_dict = {}) {
        this._dict = _dict;
    }
    get(key, language) {
        if (!key)
            return '';
        const item = this._dict[key];
        if (language)
            return item ?
                item[language] || ''
                :
                    '';
        return item;
    }
    to_resources() {
        return Object.entries(this._dict).reduce((acc, [key, item]) => {
            Object.entries(item).forEach(([language, translation]) => {
                if (!translation || !acc[language])
                    return;
                acc[language].translation[key] = translation;
            });
            return acc;
        }, {
            zh: { translation: {} },
            en: { translation: {} },
            ja: { translation: {} },
            ko: { translation: {} },
        });
    }
}
//# sourceMappingURL=dict.js.map

/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/index.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/index.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I18N: () => (/* binding */ I18N),
/* harmony export */   LANGUAGES: () => (/* binding */ LANGUAGES)
/* harmony export */ });
/* harmony import */ var i18next__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! i18next */ "./node_modules/.pnpm/i18next@24.2.1_typescript@5.7.3/node_modules/i18next/dist/esm/i18next.js");
/* harmony import */ var _dict_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dict.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/dict.js");


const LANGUAGES = ['zh', 'en', 'ja', 'ko'];
/**
    æä¾›ç¿»è¯‘æ–‡æœ¬åŠŸèƒ½ï¼Œè‡ªåŠ¨è§£æžå½“å‰è¯­è¨€
    @see https://github.com/ShenHongFei/xshell/tree/master/i18n
*/
class I18N {
    static LANGUAGE_REGEXP = /^(zh|en|ja|ko)$/;
    /** (ISO 639-1 æ ‡å‡†è¯­è¨€ä»£ç ) å¯èƒ½å– zh, en, ja, ko */
    language;
    /** hostname shortcuts */
    hosts;
    /** url prefix shortcuts */
    roots;
    /** æ ‡è®°é™æ€æ–‡æœ¬ï¼Œä»¥ä¾¿æ‰«æè¯æ¡ï¼Œå¹¶åœ¨è¿è¡Œæ—¶æ ¹æ®å½“å‰è¯­è¨€èŽ·å–ç¿»è¯‘ */
    t;
    /** render: ç¿»è¯‘é…ç½®å­—æ®µ */
    r;
    i18next;
    /** react-i18next <Trans/> ç»„ä»¶ */
    Trans = ({ children }) => children;
    /** ```ts
        import dict from './dict.json'  // { "æ·»åŠ ": { "en": "Add", "ja": "è¿½åŠ ", "ko": "ì¶”ê°€" } }
        
        const i18n = new I18N(dict, 'zh')  // åˆ›å»ºå®žä¾‹ï¼Œä¼ å…¥è¯å…¸ dict å¹¶æŒ‡å®šè¯­è¨€ï¼ˆNodeJS çŽ¯å¢ƒï¼‰ï¼Œ
        const i18n = new I18N(dict)        // åˆ›å»ºå®žä¾‹ï¼Œä¼ å…¥è¯å…¸ dict å¹¶è‡ªåŠ¨åˆ¤æ–­å½“å‰è¯­è¨€ï¼ˆæµè§ˆå™¨çŽ¯å¢ƒï¼‰ï¼Œ
        const i18n = new I18N({ })         // åˆ›å»ºå®žä¾‹ï¼Œä¼ å…¥ç©ºè¯å…¸
        ```
        @see https://github.com/ShenHongFei/xshell/tree/master/i18n
    */
    constructor(_dict, language) {
        const is_browser = typeof window !== 'undefined' && typeof location !== 'undefined';
        const dict = new _dict_js__WEBPACK_IMPORTED_MODULE_1__.Dict(_dict);
        if (!language && is_browser)
            language = (new URLSearchParams(location.search).get('language') ||
                window.language);
        if (!language)
            language = Intl.DateTimeFormat().resolvedOptions().locale.slice(0, 2);
        if (!I18N.LANGUAGE_REGEXP.test(language)) {
            if (language)
                console.error('invalid language:', language);
            language = 'zh';
        }
        // console.log('language:', language)
        this.language = language;
        this.t = (text, options) => {
            options = options || {};
            const language = options.language || this.language;
            return this.i18next.t(text, { ...options, lng: language, defaultValue: text });
        };
        this.r = (field, language = this.language) => field ?
            field[language] || field.zh || field.en || field || ''
            :
                field || '';
        // --- init i18next
        this.i18next = i18next__WEBPACK_IMPORTED_MODULE_0__["default"].createInstance();
        if (is_browser)
            try {
                // åœ¨æ—  React çš„æµè§ˆå™¨çŽ¯å¢ƒä¸‹é¿å… react-i18next ä¸­æ‰§è¡Œ React.createContext() æŠ¥é”™
                // const React = require('react') as typeof import('react')
                const { initReactI18next, Trans: I18NextTrans } = require('react-i18next');
                this.i18next.use(initReactI18next);
                const _i18next = this.i18next;
                // ç»‘å®š Trans ç»„ä»¶çš„ i18n åˆ° this.i18next, è§£å†³å¤šä¸ª i18next å†²çªçš„é—®é¢˜
                // react-i18next/context.js ä¸­ i18n å®žä¾‹åªåœ¨æ¨¡å—çº§åˆ«ç»´æŠ¤ï¼Œå¤šæ¬¡ this.i18next.use(initReactI18next) ä¼šè¦†ç›–å‰é¢çš„ i18nï¼Œå¯¼è‡´ Trans æ— æ³•ç¿»è¯‘
                // https://github.com/i18next/react-i18next/issues/726
                this.Trans = function Trans({ i18n = _i18next, ...others }) {
                    // ç®€å•è½¬å‘ï¼Œæ€§èƒ½æ›´å¥½
                    return I18NextTrans({ i18n, ...others });
                    // return React.createElement(I18NextTrans, { i18n, ...others } as any, children)
                    // return <I18NextTrans {...{ i18n, ...others } }>{children}</I18NextTrans>
                };
            }
            catch { }
        this.i18next.init({
            lng: this.language,
            // LOCAL
            // debug: true,
            debug: false,
            fallbackLng: {
                en: ['zh'],
                ja: ['en', 'zh'],
                ko: ['en', 'zh']
            },
            // ç¦ç”¨ : å’Œ . ä½œä¸º seperator
            keySeparator: false,
            nsSeparator: false,
            resources: dict.to_resources(),
            interpolation: {
                escapeValue: false
            },
            react: {
                transKeepBasicHtmlNodesFor: []
            },
        });
        if (typeof window !== 'undefined' && window && !('i18n' in window))
            window.i18n = this;
    }
    /** åŠ è½½è¯å…¸æ–‡ä»¶ (éœ€è¦å°†è¿™ä¸¤è¡Œå•ç‹¬æ”¾ä¸€ä¸ªæ–‡ä»¶é‡Œï¼Œä»¥ä¿è¯åœ¨ import å…¶ä»–æ–‡ä»¶ä¹‹å‰æ‰§è¡Œ)
        
        @example
        import dict from './dict.json'  // { "æ·»åŠ ": { "en": "Add", "ja": "è¿½åŠ ", "ko": "ì¶”ê°€" } }
        i18n.init(dict)
    */
    init(dict) {
        const resources = new _dict_js__WEBPACK_IMPORTED_MODULE_1__.Dict(dict).to_resources();
        for (const language in resources)
            this.i18next.addResources(language, 'translation', resources[language].translation);
    }
    toJSON() {
        return {
            language: this.language,
        };
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/instance.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/instance.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i18n: () => (/* binding */ i18n),
/* harmony export */   language: () => (/* binding */ language),
/* harmony export */   t: () => (/* binding */ t)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/index.js");
/* harmony import */ var _dict_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dict.json */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/dict.json");


let i18n = new _index_js__WEBPACK_IMPORTED_MODULE_0__.I18N(_dict_json__WEBPACK_IMPORTED_MODULE_1__);
const { t, language } = i18n;

//# sourceMappingURL=instance.js.map

/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/index.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CallError: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.CallError),
/* harmony export */   DecoderStream: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.DecoderStream),
/* harmony export */   Lock: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.Lock),
/* harmony export */   MyProxy: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.MyProxy),
/* harmony export */   Remote: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.Remote),
/* harmony export */   RemoteClient: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.RemoteClient),
/* harmony export */   StatusCodeError: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.StatusCodeError),
/* harmony export */   TimeoutError: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.TimeoutError),
/* harmony export */   Timer: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.Timer),
/* harmony export */   WebSocketClosed: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.WebSocketClosed),
/* harmony export */   WebSocketClosing: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.WebSocketClosing),
/* harmony export */   WebSocketConnecting: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.WebSocketConnecting),
/* harmony export */   WebSocketConnectionError: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.WebSocketConnectionError),
/* harmony export */   WebSocketOpen: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.WebSocketOpen),
/* harmony export */   WritableMemoryStream: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.WritableMemoryStream),
/* harmony export */   assert: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.assert),
/* harmony export */   brackets: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.brackets),
/* harmony export */   build_mapper: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.build_mapper),
/* harmony export */   byte_size: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.byte_size),
/* harmony export */   call: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.call),
/* harmony export */   call_nodejs: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.call_nodejs),
/* harmony export */   ceil2: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.ceil2),
/* harmony export */   check: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.check),
/* harmony export */   cjk: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.cjk),
/* harmony export */   colored: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.colored),
/* harmony export */   concat: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.concat),
/* harmony export */   connect_websocket: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.connect_websocket),
/* harmony export */   consume_stream: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.consume_stream),
/* harmony export */   cookies: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.cookies),
/* harmony export */   date_format: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.date_format),
/* harmony export */   datetime_format: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.datetime_format),
/* harmony export */   decode: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.decode),
/* harmony export */   defer: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.defer),
/* harmony export */   delay: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.delay),
/* harmony export */   delta2str: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.delta2str),
/* harmony export */   emoji_regex: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.emoji_regex),
/* harmony export */   empty: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.empty),
/* harmony export */   encode: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.encode),
/* harmony export */   encode_into: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.encode_into),
/* harmony export */   encodings: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.encodings),
/* harmony export */   escape_line_feed: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.escape_line_feed),
/* harmony export */   exe_nodejs: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.exe_nodejs),
/* harmony export */   fappend: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fappend),
/* harmony export */   fcopy: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fcopy),
/* harmony export */   fdclear: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fdclear),
/* harmony export */   fdelete: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fdelete),
/* harmony export */   fequals: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fequals),
/* harmony export */   fexists: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fexists),
/* harmony export */   ffstat: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.ffstat),
/* harmony export */   filter_keys: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.filter_keys),
/* harmony export */   filter_values: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.filter_values),
/* harmony export */   flink: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.flink),
/* harmony export */   flist: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.flist),
/* harmony export */   flstat: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.flstat),
/* harmony export */   fmkdir: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fmkdir),
/* harmony export */   fmove: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fmove),
/* harmony export */   fopen: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fopen),
/* harmony export */   fpack: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fpack),
/* harmony export */   fparse: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fparse),
/* harmony export */   fread: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fread),
/* harmony export */   fread_json: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fread_json),
/* harmony export */   fread_lines: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fread_lines),
/* harmony export */   frename: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.frename),
/* harmony export */   freplace: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.freplace),
/* harmony export */   fsp: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fsp),
/* harmony export */   fstat: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fstat),
/* harmony export */   ftail: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.ftail),
/* harmony export */   fuzzyfilter: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.fuzzyfilter),
/* harmony export */   fwatchers: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fwatchers),
/* harmony export */   fwrite: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fwrite),
/* harmony export */   fzip: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.fzip),
/* harmony export */   genid: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.genid),
/* harmony export */   get: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.get),
/* harmony export */   get_command: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.get_command),
/* harmony export */   global_get: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.global_get),
/* harmony export */   grep: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.grep),
/* harmony export */   has_chinese: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.has_chinese),
/* harmony export */   ident: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.ident),
/* harmony export */   inspect: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.inspect),
/* harmony export */   invoke: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.invoke),
/* harmony export */   is_codepoint_fullwidth: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.is_codepoint_fullwidth),
/* harmony export */   is_key_type: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.is_key_type),
/* harmony export */   launch: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.launch),
/* harmony export */   launch_nodejs: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.launch_nodejs),
/* harmony export */   log: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.log),
/* harmony export */   log_line: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.log_line),
/* harmony export */   lowercase_first_letter: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.lowercase_first_letter),
/* harmony export */   map_keys: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.map_keys),
/* harmony export */   map_stream: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.map_stream),
/* harmony export */   map_values: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.map_values),
/* harmony export */   message_symbol: () => (/* reexport safe */ _io_js__WEBPACK_IMPORTED_MODULE_1__.message_symbol),
/* harmony export */   noop: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.noop),
/* harmony export */   noprint: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.noprint),
/* harmony export */   not_empty: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.not_empty),
/* harmony export */   omit: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.omit),
/* harmony export */   output_width: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.output_width),
/* harmony export */   pack: () => (/* reexport safe */ _io_js__WEBPACK_IMPORTED_MODULE_1__.pack),
/* harmony export */   parse: () => (/* reexport safe */ _io_js__WEBPACK_IMPORTED_MODULE_1__.parse),
/* harmony export */   pipe_with_error: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.pipe_with_error),
/* harmony export */   platform: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.platform),
/* harmony export */   print_no_command: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.print_no_command),
/* harmony export */   quotes: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.quotes),
/* harmony export */   ramdisk: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.ramdisk),
/* harmony export */   range_to_numbers: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.range_to_numbers),
/* harmony export */   request: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.request),
/* harmony export */   request_json: () => (/* reexport safe */ _net_js__WEBPACK_IMPORTED_MODULE_5__.request_json),
/* harmony export */   sea: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.sea),
/* harmony export */   seq: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.seq),
/* harmony export */   set_inspect_options: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.set_inspect_options),
/* harmony export */   sort_keys: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.sort_keys),
/* harmony export */   start: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.start),
/* harmony export */   start_nodejs: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.start_nodejs),
/* harmony export */   strcmp: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.strcmp),
/* harmony export */   stream_to_lines: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.stream_to_lines),
/* harmony export */   time_format: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.time_format),
/* harmony export */   timeout: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.timeout),
/* harmony export */   to_getter_property_descriptors: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.to_getter_property_descriptors),
/* harmony export */   to_json: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.to_json),
/* harmony export */   to_json_safely: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.to_json_safely),
/* harmony export */   to_method_property_descriptors: () => (/* reexport safe */ _prototype_js__WEBPACK_IMPORTED_MODULE_0__.to_method_property_descriptors),
/* harmony export */   typed_array_to_buffer: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.typed_array_to_buffer),
/* harmony export */   unique: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.unique),
/* harmony export */   url_width: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.url_width),
/* harmony export */   username: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.username),
/* harmony export */   vercmp: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.vercmp),
/* harmony export */   wait_output: () => (/* reexport safe */ _process_js__WEBPACK_IMPORTED_MODULE_4__.wait_output),
/* harmony export */   zip: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__.zip),
/* harmony export */   zip_object: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.zip_object)
/* harmony export */ });
/* harmony import */ var _prototype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prototype.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/prototype.js");
/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./io.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/io.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/utils.js");
/* harmony import */ var _file_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./file.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/file.js");
/* harmony import */ var _process_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./process.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/process.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./net.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/net.js");






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/io.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/io.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   message_symbol: () => (/* binding */ message_symbol),
/* harmony export */   pack: () => (/* binding */ pack),
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var _prototype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prototype.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/prototype.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/utils.js");


// ç±»åž‹            | ç¼–ç 
// --------------- | -------------------
// small int +     | 0x00 - 0x1f (0 - 31 è‡ªç„¶æ•°)
// small bin       | 0x20 - 0x3f (32 - 63)   0 - 31 ä¸ªå­—èŠ‚çš„ uint8array
// small string    | 0x40 - 0x7f (64 - 127)  0 - 63 é•¿åº¦çš„å­—ç¬¦ä¸²
// small array     | 0x80 - 0x8f (128 - 143) 0 - 15 ä¸ªå…ƒç´ çš„æ•°ç»„
// small set       | 0x90 - 0x9f (144 - 159) 0 - 15 ä¸ª key çš„ set
// small object    | 0xa0 - 0xaf (160 - 175) 0 - 15 ä¸ª key çš„å¯¹è±¡
// small map       | 0xb0 - 0xbf (176 - 191) 0 - 15 ä¸ª kv çš„ map
// undefined       | 0xc0
// null            | 0xc1
// false           | 0xc2
// true            | 0xc3
// int 8           | 0xc4
// int 16          | 0xc5
// int 32          | 0xc6
// float 64        | 0xc7
// bigint 64       | 0xc8  int64
// bigint string   | 0xc9  string
// error 8         | 0xca  é•¿åº¦ 1 b + kv å¯¹
// regexp          | 0xcb  source string + flags string
// rpc message     | 0xcc  small array, æ ¼å¼ä¸º [id, func, data, error, done], æœ€åŽçš„ undefined çš„é¡¹åŽ»æŽ‰
// date            | 0xcd  8 b float64
// url             | 0xce  string
// bin 8           | 0xd0  é•¿åº¦ 1 b + å†…å®¹
// bin 16          | 0xd1  é•¿åº¦ 2 b + å†…å®¹
// bin 32          | 0xd2  é•¿åº¦ 4 b + å†…å®¹
// string 8        | 0xd3  é•¿åº¦ 1 b + å†…å®¹
// string 16       | 0xd4  é•¿åº¦ 2 b + å†…å®¹
// string 32       | 0xd5  é•¿åº¦ 4 b + å†…å®¹
// array 8         | 0xd6
// array 32        | 0xd7
// set 8           | 0xd8
// set 32          | 0xd9
// object kv å¯¹æ•°é‡åªæœ‰å…¨éƒ¨éåŽ†æ‰çŸ¥é“ï¼Œå› æ­¤åªç”¨ small object / object 16
// object 16       | 0xda  kv å¯¹æ•° 2 b + kv å¯¹
// map 8           | 0xdb
// map 32          | 0xdc
// small int -     | 0xe0 - 0xff  (-32 ~ -1)
// --- å…±äº«çŠ¶æ€ï¼Œå¯ä»¥çœ‹æˆæ˜¯æ¨¡å—å¯¹è±¡çš„å±žæ€§ (éšå¼ this)ï¼Œæœ‰ä»¥ä¸‹å¥½å¤„:
// é¿å…å‡½æ•°è°ƒç”¨æ—¶ä¼ ä¸€å †å‚æ•°ï¼Œè¿”å›žä¸€å †å€¼
// æ–¹ä¾¿è®¾è®¡ buffer pool, å‡å°‘å¯¹è±¡åˆ›å»º
// --- è§£ç 
/** å¾…è§£ç çš„ buffer */
let buf = new Uint8Array(0);
/** å¾…è§£ç çš„ buffer å¯¹åº”çš„ dataview */
let dv = buf.dataview;
/** æŒ‡é’ˆï¼ŒæŒ‡å‘ä¸‹ä¸€ä¸ªè¦è¯»å– / å†™å…¥çš„ä½ç½® */
let p = 0;
// --- ç¼–ç 
/** ç¼–ç ç¼“å†²åŒºï¼ŒæŒç»­å¾€é‡Œå†™å…¥ï¼Œæ»¡äº†å°±ç”¨ä¸€ä¸ªä¸¤å€å¤§å°çš„æ›¿æ¢ï¼Œå°†æ—§çš„æœªå†™å®Œçš„éƒ¨åˆ†å¤åˆ¶è¿‡æ¥ */
let buffer = new Uint8Array(Buffer.poolSize);
/** ç¼–ç ç¼“å†²åŒºå¯¹åº”çš„ dataview */
let dataview = buffer.dataview;
/** æŒ‡é’ˆï¼Œç¼–ç ç¼“å†²åŒºå¯ä»¥å†™å…¥çš„ä½ç½®ï¼Œåªå¢žä¸å‡ï¼Œé™¤éžæ¢æ–° buffer */
let q = 0;
/** æŸæ¬¡ç¼–ç å¼€å§‹æ—¶çš„ä½ç½®ï¼Œç”¨äºŽæ¢ç¼“å†²åŒºæ—¶ä»Žè¿™é‡Œå¼€å§‹å¤åˆ¶ï¼Œä»¥åŠæœ€ç»ˆè¿”å›žæ—¶çš„èµ·ç‚¹ */
let qstart = 0;
const int64max = 1n << 63n;
/** ç”¨è¿™ä¸ªç¬¦å·æ¥æ ‡è¯† message å¯¹è±¡ */
const message_symbol = Symbol('message');
const message_keys = ['id', 'func', 'data', 'error', 'done'];
function parse(_buf) {
    // åˆå§‹åŒ–å…±äº«çŠ¶æ€
    buf = _buf;
    dv = _buf.dataview;
    p = 0;
    return _parse();
}
function _parse() {
    const type = buf[p++];
    // 0 - 31 è‡ªç„¶æ•°
    if (type <= 0x1f)
        return type;
    // small bin
    if (type <= 0x3f)
        return buf.subarray(p, p += type - 0x20);
    // small string (0 - 63 é•¿åº¦çš„å­—ç¬¦ä¸²)
    if (type <= 0x7f)
        return parse_string(type - 0x40);
    // small array
    if (type <= 0x8f)
        return parse_array(type - 0x80);
    // small set
    if (type <= 0x9f)
        return parse_set(type - 0x90);
    // small object
    if (type <= 0xaf)
        return parse_object(type - 0xa0);
    // small map
    if (type <= 0xbf)
        return parse_map(type - 0xb0);
    // -32 ~ -1 å°è´Ÿæ•´æ•°
    if (type >= 0xe0)
        return type - 0x100;
    switch (type) {
        case 0xc0:
            return undefined;
        case 0xc1:
            return null;
        case 0xc2:
            return false;
        case 0xc3:
            return true;
        // int 8
        case 0xc4:
            return dv.getInt8(p++);
        // int 16
        case 0xc5:
            return dv.getInt16(inc(2), true);
        // int 32
        case 0xc6:
            return dv.getInt32(inc(4), true);
        // float 64
        case 0xc7:
            return dv.getFloat64(inc(8), true);
        // bigint 64
        case 0xc8:
            return dv.getBigInt64(inc(8), true);
        // bigint string
        case 0xc9:
            return BigInt(_parse());
        // error 8
        case 0xca:
            return Object.assign(new Error(), parse_object(buf[p++]));
        // regexp
        case 0xcb:
            return new RegExp(_parse(), _parse());
        // rpc message
        case 0xcc: {
            const values = _parse();
            let message = {};
            for (let i = 0; i < values.length; i++)
                message[message_keys[i]] = values[i];
            return message;
        }
        // date
        case 0xcd:
            return new Date(dv.getFloat64(inc(8), true));
        // url
        case 0xce:
            return new URL(_parse());
        // bin 8, 16, 32
        case 0xd0:
        case 0xd1:
        case 0xd2: {
            const len = parse_length(type - 0xd0);
            return buf.subarray(p, p += len);
        }
        // string 8, 16, 32
        case 0xd3:
        case 0xd4:
        case 0xd5:
            return parse_string(parse_length(type - 0xd3));
        // array 8, 32
        case 0xd6:
        case 0xd7:
            return parse_array(parse_length(type === 0xd6 ? 0 : 2));
        // set 8, 32
        case 0xd8:
        case 0xd9:
            return parse_set(parse_length(type === 0xd8 ? 0 : 2));
        // object 16
        case 0xda:
            return parse_object(dv.getUint16(inc(2), true));
        // map 8, 32
        case 0xdb:
        case 0xdc:
            return parse_map(parse_length(type === 0xdb ? 0 : 2));
    }
}
/** æ¨¡æ‹Ÿè‡ªå¢ž (åŽç½®++) è¿ç®—ç¬¦ */
function inc(len) {
    p += len;
    return p - len;
}
function parse_length(length_type) {
    switch (length_type) {
        case 0:
            return buf[p++];
        case 1:
            return dv.getUint16(inc(2), true);
        case 2:
            return dv.getUint32(inc(4), true);
    }
}
function parse_string(len) {
    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.decode)(buf.subarray(p, p += len));
}
function parse_array(len) {
    let a = new Array(len);
    for (let i = 0; i < len; i++)
        a[i] = _parse();
    return a;
}
function parse_set(size) {
    let s = new Set();
    for (let i = 0; i < size; i++)
        s.add(_parse());
    return s;
}
function parse_object(nentries) {
    let o = {};
    for (let i = 0; i < nentries; i++) {
        const key = _parse();
        o[key] = _parse();
    }
    return o;
}
function parse_map(nentries) {
    let map = new Map();
    for (let i = 0; i < nentries; i++)
        map.set(_parse(), _parse());
    return map;
}
function pack(obj) {
    qstart = q;
    _pack(obj);
    return buffer.subarray(qstart, q);
}
/** ç”³è¯·ç©ºé—´ï¼Œç¡®ä¿ [q, q + size) å¯ä»¥å†™å…¥ï¼Œä¸å¤Ÿæ—¶æ‰©å®¹ï¼Œæ¢ç¼“å†²åŒºï¼Œå¹¶å¤åˆ¶çŽ°æœ‰å†…å®¹
    - size: å‡†å¤‡å†™å…¥å¤šå°‘å­—èŠ‚çš„å†…å®¹ï¼Œå–å€¼ >= 1 */
function alloc(size) {
    if (q + size <= buffer.byteLength)
        return;
    let buffer_ = new Uint8Array((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ceil2)(q + size));
    // console.log('æ‰©å®¹:', buffer_.byteLength / 2**20)
    buffer_.set(buffer.subarray(qstart, q));
    buffer = buffer_;
    dataview = buffer_.dataview;
    q -= qstart;
    qstart = 0;
}
function _pack(value) {
    // æå‰åˆ¤æ–­ä»¥å‡å°‘ä¸€æ¬¡å‡½æ•°è°ƒç”¨
    if (q + 1 >= buffer.byteLength)
        alloc(1);
    switch (typeof value) {
        case 'undefined':
            buffer[q++] = 0xc0;
            return;
        case 'boolean':
            buffer[q++] = value ? 0xc3 : 0xc2;
            return;
        case 'string': {
            const { length } = value;
            // åˆ†é…ç©ºé—´æŒ‰ç…§æžé™æƒ…å†µ strlen * 3 è€ƒè™‘ï¼Œåæ­£å…ˆç”³è¯·ç€ï¼ŒåŽé¢ä¹Ÿå¯ä»¥ä½œä»–ç”¨
            // æå‰åˆ¤æ–­ä»¥å‡å°‘ä¸€æ¬¡å‡½æ•°è°ƒç”¨
            if (q + 1 + 4 + length * 3 >= buffer.byteLength)
                alloc(1 + 4 + length * 3);
            // æŒ‰æœ€ä¹è§‚çš„ä¼°è®¡ï¼Œå¦‚æžœä¼°è®¡é”™è¯¯ï¼Œä¸”å½±å“åˆ°å¸ƒå±€ï¼Œå†å¤åˆ¶
            // é€šå¸¸å—å½±å“çš„éƒ½æ˜¯å°å­—ç¬¦ä¸²ï¼Œä¸”æ¦‚çŽ‡ä¸å¤§ï¼Œå› æ­¤æ€»ä½“å¤åˆ¶å¼€é”€ä¸å¤§
            let lensize = 0;
            if (length <= 0x3f)
                lensize = 0;
            else if (length <= 0xff)
                lensize = 1;
            else if (length <= 0xffff)
                lensize = 2;
            else
                lensize = 4;
            // q (ç±»åž‹), lensize ..., qstr ...
            const qstr = q + 1 + lensize;
            const blen = pack_string(value, qstr);
            if (blen <= 0x3f)
                buffer[q++] = 0x40 + blen;
            else if (blen <= 0xff) {
                if (lensize < 1)
                    buffer.copyWithin(q + 1 + 1, qstr, qstr + blen);
                buffer[q++] = 0xd3;
                buffer[q++] = blen;
            }
            else if (blen <= 0xffff) {
                if (lensize < 2)
                    buffer.copyWithin(q + 1 + 2, qstr, qstr + blen);
                buffer[q++] = 0xd4;
                dataview.setUint16(q, blen, true);
                q += 2;
            }
            else {
                if (lensize < 4)
                    buffer.copyWithin(q + 1 + 4, qstr, qstr + blen);
                buffer[q++] = 0xd5;
                dataview.setUint32(q, blen, true);
                q += 4;
            }
            q += blen;
            return;
        }
        case 'number':
            // æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ 32 ä½æœ‰ç¬¦å·æ•´æ•°
            if (value >> 0 === value)
                if (value >= 0)
                    if (value <= 0x1f)
                        buffer[q++] = value;
                    else if (value <= 0x7f) {
                        buffer[q++] = 0xc4;
                        alloc(1);
                        buffer[q++] = value;
                    }
                    else if (value <= 0x7fff) {
                        buffer[q++] = 0xc5;
                        alloc(2);
                        dataview.setInt16(q, value, true);
                        q += 2;
                    }
                    else {
                        buffer[q++] = 0xc6;
                        alloc(4);
                        dataview.setInt32(q, value, true);
                        q += 4;
                    }
                else if (value >= -0x20)
                    // ç­‰ä»·äºŽ dataview.setInt8
                    buffer[q++] = value + 0x100;
                else if (value >= -0x80) {
                    buffer[q++] = 0xc4;
                    alloc(1);
                    buffer[q++] = value + 0x100;
                }
                else if (value >= -0x8000) {
                    buffer[q++] = 0xc5;
                    alloc(2);
                    dataview.setInt16(q, value, true);
                    q += 2;
                }
                else {
                    buffer[q++] = 0xc6;
                    alloc(4);
                    dataview.setInt32(q, value, true);
                    q += 4;
                }
            else { // æ˜¯æµ®ç‚¹æ•°æˆ–å¤§äºŽ int32 èŒƒå›´çš„æ•°
                buffer[q++] = 0xc7;
                alloc(8);
                dataview.setFloat64(q, value, true);
                q += 8;
            }
            return;
        case 'object':
            if (value === null)
                buffer[q++] = 0xc1;
            else if (Array.isArray(value)) {
                const { length } = value;
                if (length <= 0x0f)
                    buffer[q++] = 0x80 + length;
                else if (length <= 0xff) {
                    buffer[q++] = 0xd6;
                    alloc(1);
                    buffer[q++] = length;
                }
                else {
                    buffer[q++] = 0xd7;
                    alloc(4);
                    dataview.setUint32(q, length, true);
                    q += 4;
                }
                for (let i = 0; i < length; i++)
                    _pack(value[i]);
            }
            else if (value instanceof Uint8Array) {
                const { length } = value;
                if (length <= 0x1f) {
                    buffer[q++] = 0x20 + length;
                    alloc(length);
                }
                else if (length <= 0xff) {
                    buffer[q++] = 0xd0;
                    alloc(1 + length);
                    buffer[q++] = length;
                }
                else if (length <= 0xffff) {
                    buffer[q++] = 0xd1;
                    alloc(2 + length);
                    dataview.setUint16(q, length, true);
                    q += 2;
                }
                else {
                    buffer[q++] = 0xd2;
                    alloc(4 + length);
                    dataview.setUint32(q, length, true);
                    q += 4;
                }
                buffer.set(value, q);
                q += length;
            }
            else if (value instanceof Error) {
                // ä¹è§‚è®¤ä¸º error ä¸è¶…è¿‡ 255 ä¸ª key, è¶…è¿‡çš„éƒ¨åˆ†ç›´æŽ¥å¿½ç•¥
                buffer[q++] = 0xca;
                const keys = Object.getOwnPropertyNames(value);
                alloc(1);
                buffer[q++] = keys.length;
                for (const key of keys) {
                    _pack(key);
                    _pack(value[key]);
                }
            }
            else if (value instanceof Date) {
                buffer[q++] = 0xcd;
                alloc(8);
                dataview.setFloat64(q, value.getTime(), true);
                q += 8;
            }
            else if (value instanceof Set) {
                const { size } = value;
                if (size <= 0x0f)
                    buffer[q++] = 0x90 + size;
                else if (size <= 0xff) {
                    buffer[q++] = 0xd8;
                    alloc(1);
                    buffer[q++] = size;
                }
                else {
                    buffer[q++] = 0xd9;
                    alloc(4);
                    dataview.setUint32(q, size, true);
                    q += 4;
                }
                for (const v of value)
                    _pack(v);
            }
            else if (value instanceof Map) {
                const { size } = value;
                if (size <= 0x0f)
                    buffer[q++] = 0xb0 + size;
                else if (size <= 0xff) {
                    buffer[q++] = 0xdb;
                    alloc(1);
                    buffer[q++] = size;
                }
                else {
                    buffer[q++] = 0xdc;
                    alloc(4);
                    dataview.setUint32(q, size, true);
                    q += 4;
                }
                for (const [k, v] of value) {
                    _pack(k);
                    _pack(v);
                }
            }
            else if (value instanceof RegExp) {
                buffer[q++] = 0xcb;
                _pack(value.source);
                _pack(value.flags);
            }
            else if (value instanceof URL) {
                buffer[q++] = 0xce;
                _pack(value.toString());
            }
            else if (message_symbol in value) {
                buffer[q++] = 0xcc;
                let values = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.seq)(message_keys.length, i => value[message_keys[i]]);
                let iend = message_keys.length;
                for (; iend >= 1 && values[iend - 1] === undefined; --iend)
                    _pack(values.slice(0, iend));
            }
            else {
                // å…ˆæ£€æŸ¥ kv å¯¹çš„æ•°é‡æ˜¯å¦å°äºŽç­‰äºŽ 15 (small object)
                // å…ˆä¸åºåˆ—åŒ–ï¼Œé˜²æ­¢æŸä¸ª key å¯¹åº”çš„ value å¾ˆå¤§
                let nkv = 0;
                for (const key in value)
                    if (++nkv === 16)
                        break;
                // è®°å½•ç›¸å¯¹ä½ç½®ï¼Œé¿å… buffer æ›¿æ¢åŽä½ç½®é”™è¯¯
                const offset = q + 1 - qstart;
                if (nkv <= 0x0f) // small object
                    buffer[q++] = 0xa0 + nkv;
                else {
                    buffer[q++] = 0xda;
                    // é¢„ç•™é•¿åº¦ï¼Œå…ˆä¸å¡« kv å¯¹æ•°
                    alloc(2);
                    q += 2;
                }
                nkv = 0;
                for (const key in value) {
                    const v = value[key];
                    if (typeof v === 'function')
                        continue;
                    _pack(key);
                    _pack(v);
                    if (++nkv > 0xffff)
                        throw new Error('å¯¹è±¡ key æ•°é‡å¤§äºŽ 65535ï¼Œæ— æ³•åºåˆ—åŒ–');
                }
                if (nkv >= 16)
                    // è¡¥å¡« kv å¯¹æ•°
                    dataview.setUint16(qstart + offset, nkv, true);
            }
            return;
        case 'bigint':
            if (value < int64max && value >= -int64max) {
                buffer[q++] = 0xc8;
                alloc(8);
                dataview.setBigInt64(q, value, true);
                q += 8;
            }
            else {
                buffer[q++] = 0xc9;
                _pack(value.toString());
            }
            return;
    }
}
/** ä»Ž qstr ä½ç½®å¼€å§‹å†™å…¥ç¼–ç åŽçš„ utf8 å†…å®¹ï¼Œä½¿ç”¨å‰éœ€è¦ç”¨ alloc æå‰é¢„åˆ†é…ç©ºé—´ï¼Œ
    è¿”å›žç¼–ç åŽçš„å­—èŠ‚æ•° */
function pack_string(value, qstr) {
    const { length } = value;
    if (length <= 0x3f) {
        let j = qstr;
        for (let i = 0; i < length; i++) {
            let c1 = value.charCodeAt(i), c2 = 0;
            if (c1 < 0x80)
                buffer[j++] = c1;
            else if (c1 < 0x800) {
                buffer[j++] = (c1 >> 6) | 0xc0;
                buffer[j++] = (c1 & 0x3f) | 0x80;
            }
            else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {
                c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);
                i++;
                buffer[j++] = (c1 >> 18) | 0xf0;
                buffer[j++] = ((c1 >> 12) & 0x3f) | 0x80;
                buffer[j++] = ((c1 >> 6) & 0x3f) | 0x80;
                buffer[j++] = (c1 & 0x3f) | 0x80;
            }
            else {
                buffer[j++] = (c1 >> 12) | 0xe0;
                buffer[j++] = ((c1 >> 6) & 0x3f) | 0x80;
                buffer[j++] = (c1 & 0x3f) | 0x80;
            }
        }
        return j - qstr;
    }
    else
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.encode_into)(value, buffer.subarray(qstr))
            .written;
}
//# sourceMappingURL=io.js.map

/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/net.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/net.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MyProxy: () => (/* binding */ MyProxy),
/* harmony export */   Remote: () => (/* binding */ Remote),
/* harmony export */   RemoteClient: () => (/* binding */ RemoteClient),
/* harmony export */   StatusCodeError: () => (/* binding */ StatusCodeError),
/* harmony export */   WebSocketClosed: () => (/* binding */ WebSocketClosed),
/* harmony export */   WebSocketClosing: () => (/* binding */ WebSocketClosing),
/* harmony export */   WebSocketConnecting: () => (/* binding */ WebSocketConnecting),
/* harmony export */   WebSocketConnectionError: () => (/* binding */ WebSocketConnectionError),
/* harmony export */   WebSocketOpen: () => (/* binding */ WebSocketOpen),
/* harmony export */   connect_websocket: () => (/* binding */ connect_websocket),
/* harmony export */   cookies: () => (/* binding */ cookies),
/* harmony export */   request: () => (/* binding */ request),
/* harmony export */   request_json: () => (/* binding */ request_json)
/* harmony export */ });
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zlib */ "zlib");
/* harmony import */ var stream_consumers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stream/consumers */ "stream/consumers");
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var _i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./i18n/instance.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/instance.js");
/* harmony import */ var _prototype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./prototype.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/prototype.js");
/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./io.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/io.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/utils.js");







const WebSocketConnecting = 0;
const WebSocketOpen = 1;
const WebSocketClosing = 2;
const WebSocketClosed = 3;
var MyProxy;
(function (MyProxy) {
    MyProxy["socks5"] = "http://127.0.0.1:10080";
    MyProxy["whistle"] = "http://localhost:8899";
    MyProxy["work"] = "http://localhost:10090";
})(MyProxy || (MyProxy = {}));
// ------------------------------------ fetch, request
const cookies = {
    store: null,
    jar: null,
    async init() {
        if (this.jar)
            return;
        const { MemoryCookieStore, CookieJar } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_pnpm_tough-cookie_5_1_0_node_modules_tough-cookie_dist_cookie_index_js").then(__webpack_require__.t.bind(__webpack_require__, /*! tough-cookie */ "./node_modules/.pnpm/tough-cookie@5.1.0/node_modules/tough-cookie/dist/cookie/index.js", 19));
        this.jar = new CookieJar(this.store = new MemoryCookieStore());
    },
};
/** å¯¹äºŽ request() å‡½æ•°æ¥è¯´æ— æ„ä¹‰çš„ headersï¼Œä¼šè‡ªåŠ¨è¿‡æ»¤æŽ‰ */
const drop_request_headers = new Set([
    // : å¼€å¤´çš„ key
    // sec-*
    'accept-charset',
    'connection',
    'content-length',
    'keep-alive',
    'trailer',
    'transfer-encoding',
    'upgrade',
]);
let agents = {};
async function request_retry(url, options, _timeout, retries = 0, count = 0, print) {
    let { default: undici, request: undici_request } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_pnpm_undici_7_2_3_node_modules_undici_index_js").then(__webpack_require__.t.bind(__webpack_require__, /*! undici */ "./node_modules/.pnpm/undici@7.2.3/node_modules/undici/index.js", 19));
    undici_request ??= undici.request;
    try {
        if (_timeout > 0) {
            // è®¾ç½®ç»™ undici è®¾ç½® timeout, signal ä¸ä¸€å®šç®¡ç”¨ï¼Œè¿˜æ˜¯å¾—è‡ªå·±å…œåº•
            options.signal = AbortSignal.timeout(_timeout);
            return await (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.timeout)(_timeout + 300, // ä¸º undici å…œåº•
            undici.request(url, options), undefined, print.timeout && count >= retries // åªæ‰“å°æœ€åŽä¸€æ¬¡è¶…æ—¶çš„é”™è¯¯ï¼Œé¿å…å¤ªå¤šå†—ä½™è¾“å‡º
            );
        }
        else
            return await undici.request(url, options);
    }
    catch (error) {
        if (error.name === 'TimeoutError')
            if (count < retries) {
                const duration = 2 ** count;
                if (print.retry)
                    console.log(`${`ç­‰å¾… ${duration} ç§’åŽé‡è¯•è¯·æ±‚ (å·²å°è¯• ${count + 1} æ¬¡) Â·Â·`.yellow}  ${url.toString().blue.underline}`);
                await (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.delay)(1000 * duration);
                return request_retry(url, options, _timeout, retries, count + 1, print);
            }
            else {
                const seconds = _timeout / 1000;
                throw Object.assign(new Error(`è¯·æ±‚è¶…è¿‡ ${seconds.toFixed(seconds < 1 ? 1 : 0)} ç§’ç­‰å¾…æ—¶é—´: ${url.toString()}`), { name: 'TimeoutError' });
            }
        else
            throw error;
    }
}
class StatusCodeError extends Error {
    name = 'StatusCodeError';
    constructor(status, url) {
        super(`çŠ¶æ€ç  ${status}: ${url}`);
        Object.defineProperties(this, {
            status: { value: status }
        });
    }
}
async function request(url, options = {}) {
    let { default: undici, ProxyAgent: UndiciProxyAgent, FormData } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_pnpm_undici_7_2_3_node_modules_undici_index_js").then(__webpack_require__.t.bind(__webpack_require__, /*! undici */ "./node_modules/.pnpm/undici@7.2.3/node_modules/undici/index.js", 19));
    UndiciProxyAgent ??= undici.ProxyAgent;
    FormData ??= undici.FormData;
    const { Cookie } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_pnpm_tough-cookie_5_1_0_node_modules_tough-cookie_dist_cookie_index_js").then(__webpack_require__.t.bind(__webpack_require__, /*! tough-cookie */ "./node_modules/.pnpm/tough-cookie@5.1.0/node_modules/tough-cookie/dist/cookie/index.js", 19));
    await cookies.init();
    const { queries, headers: _headers, body, type = 'application/json', timeout = 5 * 1000, auth, cookies: _cookies, raw = false, full = false, redirect = 'follow', decode = true, print = {
        timeout: true,
        retry: true
    } } = options;
    let { method, retries, encoding, proxy, } = options;
    url = new URL(url);
    if (queries)
        for (const key in queries) {
            let value = queries[key];
            if (typeof value === 'boolean')
                value = value ? '1' : '0';
            url.searchParams.append(key, value);
        }
    const urlstr = url.toString();
    if (body !== undefined && !method)
        method = 'POST';
    if (retries === true)
        retries = 2;
    // --- headers, http/2 å¼€å§‹éƒ½ç”¨å°å†™çš„ headers
    let headers = {
        'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,ja-JP;q=0.6,ja;q=0.5',
        'accept-encoding': 'gzip, deflate, br',
        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
        'sec-ch-ua-platform': '"Windows"',
        'sec-ch-ua-platform-version': '"15.0.0"',
    };
    if (body !== undefined)
        headers['content-type'] = type;
    if (auth)
        headers.authorization = auth.type === 'basic' ?
            `Basic ${`${auth.username}:${auth.password}`.to_base64()}`
            :
                `Bearer ${auth.token}`;
    const request_cookies = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.unique)([
        ...cookies.jar.getCookiesSync(urlstr),
        ..._cookies ?
            Object.entries(_cookies).map(([key, value]) => new Cookie({ key, value }))
            :
                []
    ], 'key');
    if (request_cookies.length)
        headers.cookie = request_cookies.map(cookie => cookie.cookieString())
            .join('; ');
    if (_headers) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(Object.getPrototypeOf(_headers)?.constructor.name !== 'Headers');
        for (const key in _headers)
            // å¯èƒ½åœ¨ http/2 çš„ response ä¸­ä¼šæœ‰è¿™æ ·å¼€å¤´çš„ä¿ç•™ headers, åœ¨é€ä¼ æ—¶å¿½ç•¥æ¯”è¾ƒå¥½
            if (!key.startsWith(':') && !key.startsWith('sec-') && !drop_request_headers.has(key)) {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(key === key.toLowerCase(), `ä¼ å…¥ request çš„ headers å‚æ•°ä¸­ key åº”è¯¥éƒ½æ˜¯å°å†™çš„ï¼Œå®žé™…ä¸º ${key}`);
                headers[key] = _headers[key];
            }
    }
    let undici_options = {
        ...method ? { method } : {},
        dispatcher: await (async () => {
            const { default: { 
            // @ts-ignore
            ProxyAgent, Agent, interceptors } } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_pnpm_undici_7_2_3_node_modules_undici_index_js").then(__webpack_require__.t.bind(__webpack_require__, /*! undici */ "./node_modules/.pnpm/undici@7.2.3/node_modules/undici/index.js", 19));
            if (proxy === true)
                proxy = MyProxy.socks5;
            return agents[`${proxy || 'direct'}.${redirect}`] ??= (() => {
                let dispatcher = proxy ? new ProxyAgent({ uri: proxy }) : new Agent();
                if (redirect === 'follow')
                    dispatcher = dispatcher.compose(
                    // todo: å¼ºåˆ¶æ‰‹åŠ¨å¤„ç†é‡å®šå‘ï¼Œæ¥æ­£ç¡®å¤„ç† cookie ?
                    interceptors.redirect({ maxRedirections: 5 }));
                return dispatcher;
            })();
        })(),
        // ä¸‹é¢è¿™äº› timeout éƒ½ä¸æ˜¯æ€»çš„æ—¶é—´
        headersTimeout: timeout,
        // ä»Žæ”¶å®Œ headers å¼€å§‹ç®—
        bodyTimeout: timeout,
        // @ts-ignore æ²¡æœ‰ç±»åž‹å£°æ˜Žï¼Œå®žé™…å¯ç”¨
        connectTimeout: timeout,
        headers,
        // --- body
        body: (() => {
            if (body === undefined)
                return;
            if (typeof body?.read === 'function' && (0,stream__WEBPACK_IMPORTED_MODULE_2__.isReadable)(body))
                return body;
            switch (type) {
                case 'application/json': // å¯èƒ½çš„ç±»åž‹ string | Record<string, any> | Uint8Array
                    if (typeof body === 'string')
                        return body;
                    if (body instanceof Uint8Array)
                        return body;
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.assert)(!(body instanceof ArrayBuffer || ArrayBuffer.isView(body)));
                    return JSON.stringify(body);
                case 'application/x-www-form-urlencoded':
                    return (body instanceof URLSearchParams ? body : new URLSearchParams(body)).toString();
                case 'multipart/form-data':
                    if (body instanceof FormData)
                        return body;
                    else {
                        let form = new FormData();
                        for (const key in body) {
                            let value = body[key];
                            form.set(key, value);
                        }
                        return form;
                    }
            }
        })(),
    };
    let response;
    try {
        const { statusCode: status, headers: _headers, body: _body } = await request_retry(url, undici_options, timeout, retries, 0, print);
        // å¤„ç† cookieï¼Œè‡ªåŠ¨ä¿å­˜åˆ° cookie jar
        let _cookies = _headers['set-cookie'] || [];
        if (typeof _cookies === 'string')
            _cookies = [_cookies];
        _cookies.map(cookie => cookies.jar.setCookieSync(cookie, urlstr, { ignoreError: true }));
        const headers = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.map_values)(_headers, value => Array.isArray(value) ? value.join(', ') : (value || ''));
        // UndiciResponse.body æ²¡æœ‰è‡ªåŠ¨æ ¹æ® content-encoding æ¥è§£ç ï¼Œè¿™é‡Œæ‰‹åŠ¨å¤„ç†å¹¶æ›¿æ¢ body ä¸ºè§£ç åŽçš„ stream
        let body = _body;
        const content_encoding = headers['content-encoding']?.trim().toLowerCase();
        if (decode && content_encoding) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.assert)(!content_encoding.includes(','));
            switch (content_encoding) {
                case 'gzip':
                case 'x-gzip':
                    body = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.pipe_with_error)(_body, zlib__WEBPACK_IMPORTED_MODULE_0__.createGunzip({
                        // Be less strict when decoding compressed responses, since sometimes
                        // servers send slightly invalid responses that are still accepted
                        // by common browsers.
                        // Always using Z_SYNC_FLUSH is what cURL does.
                        flush: zlib__WEBPACK_IMPORTED_MODULE_0__.constants.Z_SYNC_FLUSH,
                        finishFlush: zlib__WEBPACK_IMPORTED_MODULE_0__.constants.Z_SYNC_FLUSH
                    }));
                    break;
                case 'deflate':
                    body = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.pipe_with_error)(_body, zlib__WEBPACK_IMPORTED_MODULE_0__.createInflate());
                    break;
                case 'br':
                    body = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.pipe_with_error)(_body, zlib__WEBPACK_IMPORTED_MODULE_0__.createBrotliDecompress());
                    break;
                default:
                    throw new Error(`ä¸æ”¯æŒ content-encoding: ${content_encoding.quote()} çš„ http è¯·æ±‚`);
            }
        }
        response = {
            status,
            headers,
            body
        };
        if (!((200 <= status && status <= 299) || status === 304 || (redirect === 'manual' && 300 <= status && status < 400)))
            throw new StatusCodeError(status, url.toString());
    }
    catch (error) {
        response ??= error.response;
        throw Object.defineProperties(error, {
            url: { value: url },
            options: { value: options },
            ...response ? {
                response: {
                    value: {
                        status: response.status,
                        headers: response.headers,
                        body: decode
                            ? await (0,stream_consumers__WEBPACK_IMPORTED_MODULE_1__.text)(response.body)
                            : await (0,stream_consumers__WEBPACK_IMPORTED_MODULE_1__.buffer)(response.body),
                    }
                }
            } : {},
            [_utils_js__WEBPACK_IMPORTED_MODULE_6__.inspect.custom]: {
                value(depth, options, inspect) {
                    const { colors } = options;
                    const c = (str, color) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.colored)(str, color, colors);
                    let s = '\n' +
                        `${c(method || 'GET', 'red')} ${c(c(urlstr, 'blue'), 'underline')}\n`;
                    if (queries && Object.keys(queries).length)
                        s += c('è¯·æ±‚å‚æ•°:\n', 'yellow') +
                            inspect(queries, options).ensure_end();
                    if (body !== undefined)
                        s += c('è¯·æ±‚ä½“:\n', 'yellow') +
                            inspect(body, options).ensure_end();
                    if (response) {
                        s += c('å“åº”å¤´:\n', 'yellow');
                        for (const key in response.headers) {
                            const value = response.headers[key];
                            s += `${key}: ${value}\n`;
                        }
                        if (error.response.body)
                            s += c('å“åº”ä½“:\n', 'yellow') +
                                error.response.body.toString().ensure_end();
                    }
                    s += inspect(error, { ...options, customInspect: false });
                    return s;
                }
            }
        });
    }
    if (raw)
        return response;
    const body_ = await (async () => {
        if (!response.body)
            return encoding === 'binary' ? Buffer.from([]) : '';
        if (encoding === 'binary')
            return (0,stream_consumers__WEBPACK_IMPORTED_MODULE_1__.buffer)(response.body);
        encoding ||= /charset=(.*)/.exec(response.headers['content-type'])?.[1] || 'utf-8';
        if (/utf-?8/i.test(encoding))
            return (0,stream_consumers__WEBPACK_IMPORTED_MODULE_1__.text)(response.body);
        return new TextDecoder(encoding)
            .decode(await (0,stream_consumers__WEBPACK_IMPORTED_MODULE_1__.buffer)(response.body));
    })();
    return full ? {
        status: response.status,
        headers: response.headers,
        body: body_
    }
        :
            body_;
}
/** å‘èµ· http è¯·æ±‚å¹¶å°†å“åº”ä½“ä½œä¸º json è§£æž */
async function request_json(url, options) {
    const body = await request(url, options);
    if (!body)
        return;
    try {
        return JSON.parse(body);
    }
    catch (error) {
        console.error(body);
        throw error;
    }
}
class WebSocketConnectionError extends Error {
    name = 'WebSocketConnectionError';
    // è¿™é‡Œä¸ä¿ç•™ websocket å¼•ç”¨ï¼Œé˜²æ­¢å¾ªçŽ¯å¼•ç”¨å¯¼è‡´ JSON åºåˆ—åŒ–å¤±è´¥
    url;
    protocols;
    event;
    type;
    address;
    errno;
    port;
    syscall;
    /** close äº‹ä»¶æ—¶ä¸º close code, error äº‹ä»¶ä¸º error code */
    code;
    reason;
    constructor(url, protocols, event, message = '') {
        super(`${url}${protocols ? ' ' + protocols.join(', ').bracket() : ''} ${(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('è¿žæŽ¥å‡ºé”™äº†')}. ${message}`);
        this.url = url;
        this.protocols = protocols;
        this.event = event;
        this.type = event.type;
        if (this.type === 'error') {
            const { error } = event;
            this.address = error.address;
            this.code = error.code;
            this.errno = error.errno;
            this.port = error.port;
            this.syscall = error.syscall;
            this.reason = error.reason;
            this.stack = `${this.name}: ${this.message}\n` +
                error.stack.slice(error.stack.indexOf('\n') + 1) + '\n';
        }
        else {
            this.code = event.code;
            this.reason = event.reason;
        }
    }
}
let websocket_proxy_agents = {};
/** è¿žæŽ¥ websocket url, è®¾ç½®å„ç§äº‹ä»¶ç›‘å¬å™¨ã€‚åœ¨ open äº‹ä»¶åŽ resolve, è¿”å›ž websocket
    é‡åˆ° error æ—¶ä¼šåˆ›å»º WebSocketConnectionError:
        - reject æŽ‰è¿”å›žçš„ promise (è‹¥æ­¤æ—¶æœª settle)
        - ä½œä¸ºå‚æ•°è°ƒç”¨ on_error (å·² settle ä¸”æœ‰ on_error å›žè°ƒ)
    å¯ä»¥ç”¨ WebSocket.bufferedAmount æ¥æ˜¾ç¤ºå¤§æ¶ˆæ¯çš„å‘é€è¿›åº¦
    https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/bufferedAmount
    - url
    - options:
        - protocols?
        - max_payload?: `8 GB`
        - on_message: æ ¹æ® websocket frame çš„ opcode ä¸åŒ (text frame æˆ– binary frame)ï¼Œevent ä¸­çš„ data å¯¹åº”ä¸º ArrayBuffer æˆ–è€… string
          https://datatracker.ietf.org/doc/html/rfc6455#section-5.2
        - on_error?: åœ¨ websocket å‡ºé”™å’Œéžæ­£å¸¸å…³é—­ (close, error äº‹ä»¶) æ—¶éƒ½è°ƒç”¨ï¼Œå¯ä»¥æ ¹æ® error.type æ¥åŒºåˆ†ï¼Œerror çš„ç±»åž‹æ˜¯ WebSocketConnectionErrorï¼Œ
            type ä¸º 'close' æ—¶æœ‰ code å’Œ reason å±žæ€§
        - on_close?: å’Œ websocket çš„ 'close' äº‹ä»¶ä¸ç›¸åŒï¼Œåªåœ¨æ­£å¸¸å…³é—­ (close code ä¸º 1000) æ—¶æ‰è°ƒç”¨ï¼Œå¦åˆ™éƒ½ä¼šè°ƒç”¨ on_error
            https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
        - print?: æ˜¯å¦æ‰“å°è¿žæŽ¥ã€å…³é—­ä¿¡æ¯ */
async function connect_websocket(url, { protocols, max_payload = 2 ** 33, // 8 GB
on_message, on_error, on_close, proxy, print = true, }) {
    const { WebSocket } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_pnpm_ws_8_18_0_node_modules_ws_wrapper_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ws */ "./node_modules/.pnpm/ws@8.18.0/node_modules/ws/wrapper.mjs"));
    const { HttpsProxyAgent } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_pnpm_https-proxy-agent_7_0_6_node_modules_https-proxy-agent_dist_index_js").then(__webpack_require__.t.bind(__webpack_require__, /*! https-proxy-agent */ "./node_modules/.pnpm/https-proxy-agent@7.0.6/node_modules/https-proxy-agent/dist/index.js", 19));
    let websocket = new WebSocket(url, protocols, {
        maxPayload: max_payload,
        skipUTF8Validation: true,
        allowSynchronousEvents: true,
        ...proxy ? {
            agent: websocket_proxy_agents[proxy] ??= new HttpsProxyAgent(proxy)
        } : {}
    });
    // https://stackoverflow.com/questions/11821096/what-is-the-difference-between-an-arraybuffer-and-a-blob/39951543
    websocket.binaryType = 'arraybuffer';
    return new Promise((resolve, reject) => {
        let settled = false;
        websocket.addEventListener('open', event => {
            if (print)
                console.log(websocket.url +
                    (websocket.protocol ? ' ' + websocket.protocol.bracket() : '') +
                    (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)(' å·²è¿žæŽ¥'));
            settled = true;
            resolve(websocket);
        });
        websocket.addEventListener('close', event => {
            // https://blog.insiderattack.net/promises-next-ticks-and-immediates-nodejs-event-loop-part-3-9226cbe7a6aa
            // error äº‹ä»¶ä¼šå…ˆå‘ç”Ÿï¼Œç„¶åŽ reject(error) è¢«æ‰§è¡Œï¼Œæ­¤æ—¶è¿˜æœªè½®åˆ°å¤–å±‚çš„ await connect_websocket æ‰§è¡Œï¼ˆåœ¨å¾®ä»»åŠ¡é˜Ÿåˆ—ä¸­ï¼‰ï¼Œ
            // æŽ¥ç€é©¬ä¸Š close äº‹ä»¶ä¹Ÿè¢«è°ƒç”¨ï¼Œæ­¤æ—¶ settledï¼Œé©¬ä¸Šè°ƒç”¨äº† on_error å‡½æ•°ï¼Œå¼„ä¹±äº†é¡ºåº
            // error çš„é”™è¯¯ä¿¡æ¯æ¯”è¾ƒå¤šï¼Œè€Œä¸”é€šè¿‡ await å¾—åˆ°çš„æ ˆä¹Ÿæ¯”è¾ƒæ¸…æ™°ï¼Œè¿™é‡Œå»¶åŽè°ƒç”¨ on_close å’Œ on_errorï¼Œæ”¾åˆ°å¾®ä»»åŠ¡é˜Ÿåˆ—ä¹‹åŽçš„ timers é˜Ÿåˆ—ä¸­
            setTimeout(() => {
                if (event.code === 1000) { // æ­£å¸¸å…³é—­
                    if (on_close)
                        on_close(event, websocket);
                    else if (print)
                        console.log(`${websocket.url} ${(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('å·²æ­£å¸¸å…³é—­')}`);
                }
                else { // å¼‚å¸¸å…³é—­ï¼Œè®¤ä¸ºå‘ç”Ÿäº†é”™è¯¯ï¼Œè¿›è¡Œé”™è¯¯å¤„ç†
                    // websocket close äº‹ä»¶æ—¶å·²ç» settled
                    const error = new WebSocketConnectionError(websocket.url, protocols, event, `${(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('è¿žæŽ¥è¢«å…³é—­')}, code: ${event.code}${event.reason ? `, ${(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('åŽŸå› ')}: ${event.reason}` : ''}`);
                    if (on_error)
                        on_error(error, websocket);
                    else // æ—¢ç„¶ç”¨æˆ·ä¸ä¼  on_error, å°±å½“ unhandled error æŠ›å‡ºæ¥
                        throw error;
                }
            });
        });
        websocket.addEventListener('error', event => {
            const error = new WebSocketConnectionError(websocket.url, protocols, event, event.error?.message);
            if (settled)
                if (on_error)
                    on_error(error, websocket);
                else // æ—¢ç„¶ç”¨æˆ·ä¸ä¼  on_error, å°±å½“ unhandled error æŠ›å‡ºæ¥
                    throw error;
            else {
                settled = true;
                reject(error);
            }
        });
        websocket.addEventListener('message', event => {
            on_message(event.data, websocket);
        });
    });
}
/** é€šè¿‡åˆ›å»º remote å¯¹è±¡å¯¹ websocket rpc è¿›è¡ŒæŠ½è±¡
    åˆ›å»º remote å¯¹è±¡æ—¶ä¼ å…¥ funcs æ³¨å†Œå¤„ç†å‡½æ•°ï¼Œä½¿å¾—å¯¹ç«¯èƒ½é€šè¿‡ (rpc message).func è°ƒç”¨
    ä½¿ç”¨ remote.handle æ–¹æ³•å¤„ç†å¯¹ç«¯å‘æ¥çš„ websocket messageï¼Œå¯¹äºŽ websocket è¿žæŽ¥æŽ¥æ”¶æ–¹éœ€è¦æ‰‹åŠ¨ç»‘å®š websocket message äº‹ä»¶åˆ° remote.handle
    ä½¿ç”¨ remote.call è¿›è¡Œä¸€å…ƒ rpc
    ä½¿ç”¨ remote.send ç»“åˆ message.id è¿›è¡Œå¤æ‚ rpc
    åˆ›å»ºåŽç­‰åˆ°é¦–ä¸ª remote.call æˆ– remote.send æ—¶è‡ªåŠ¨å»ºç«‹å®žé™… websocket è¿žæŽ¥
    rpc çŠ¶æ€ä¸Žåº•å±‚è¿žæŽ¥çš„çŠ¶æ€æ— å…³ï¼Œå¦‚æžœæ˜¯ä¼ å…¥ url åˆ›å»ºçš„ remote å®žä¾‹ï¼Œremote.send æ—¶æ£€æµ‹åˆ°æ–­çº¿ä¼šè‡ªåŠ¨å»ºç«‹æ–°çš„ websocket è¿žæŽ¥
    
    @example
    // Zero ç»§æ‰¿è‡ª Remote å¹¶é€šè¿‡ call å®žçŽ°äº†ä¸€äº›æ–¹æ³•
    let zero = new Zero({ local: true })
    
    // ä¸€å…ƒ rpc
    await zero.repl_ts('1234')
    
    // è®¢é˜…æµ
    const id = genid()
    
    zero.handlers.set(id, ({ data: [chunk] }: Message<[Uint8Array]>) => {
        term.write(chunk)
    })
    
    zero.send({ id, func: 'subscribe_stdio' }) */
class Remote {
    /** åœ¨æž„é€  Remote æ—¶, this.initiator = Boolean(url || websocket)
        - true:  ä½œä¸º websocket è¿žæŽ¥å‘èµ·æ–¹
        - false: ä½œä¸º websocket è¿žæŽ¥æŽ¥æ”¶æ–¹ */
    initiator;
    /** ä½œä¸º websocket è¿žæŽ¥å‘èµ·æ–¹ï¼Œå¯¹ç«¯çš„ url åœ°å€ */
    url;
    /** ä½œä¸º websocket è¿žæŽ¥å‘èµ·æ–¹æœ‰ websocket lock */
    lwebsocket;
    /** websocket è¿žæŽ¥å‘èµ·æ–¹ï¼ŒæŽ¥æ”¶æ–¹ï¼Œéƒ½èƒ½è¢«å¯¹ç«¯é€šè¿‡ (rpc message).func è°ƒç”¨çš„ rpc å‡½æ•° */
    funcs;
    /** map<id, message handler>: é€šè¿‡ (rpc message).id æ‰¾åˆ°å¯¹åº”çš„ handler
        ä¸€å…ƒ rpc æŽ¥æ”¶æ–¹ä¸éœ€è¦è®¾ç½® handlers, å‘é€æ–¹éœ€è¦ */
    handlers = new Map();
    keeper;
    /** `true` æ˜¯å¦æ‰“å°è¿žæŽ¥ä¿¡æ¯ã€é”™è¯¯ä¿¡æ¯ */
    print = true;
    /** `false` æ‰“å°æ‰€æœ‰äº¤äº’çš„ rpc messages */
    verbose = false;
    first_error = true;
    keeping = false;
    reconnecting = false;
    disconnected = false;
    /** ä½œä¸º websocket è¿žæŽ¥å‘èµ·æ–¹ï¼Œä¼ å…¥ url æˆ– websocketï¼Œå®šä¹‰è¿œç¨‹ Remote
        ä½œä¸º websocket è¿žæŽ¥æŽ¥æ”¶æ–¹ï¼Œä¸ä¼  url å’Œ websocketï¼Œå®šä¹‰æœ¬åœ° Remote */
    constructor({ url, funcs, print, verbose, websocket, keeper, on_error, } = {}) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(!(url && websocket), 'æž„å»º Remote æ—¶ url å’Œ websocket æœ€å¤šåªèƒ½ä¼ ä¸€ä¸ª');
        this.initiator = Boolean(url || websocket);
        if (url)
            this.url = url;
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(!funcs?.echo);
        this.funcs = {
            ...funcs,
            echo({ data }) {
                return data;
            }
        };
        if (print !== undefined)
            this.print = print;
        if (verbose !== undefined)
            this.verbose = verbose;
        if (on_error)
            this.on_error = on_error;
        if (this.initiator)
            this.lwebsocket = new _utils_js__WEBPACK_IMPORTED_MODULE_6__.Lock(websocket || null);
        if (keeper) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(this.initiator && url);
            this.keeper = {
                reconnect_interval: 1000 * 5,
                heartbeat_interval: 1000 * 60,
                error_delay: 1000 * 2,
                ...keeper
            };
        }
    }
    /** ç»Ÿä¸€å¤„ç†é¦–æ¬¡è¿žæŽ¥å’Œè¿žæŽ¥åŽçš„ websocket é”™è¯¯ */
    _on_error = (error, websocket) => {
        if (this.keeper && !this.reconnecting && !this.disconnected) // åœ¨ä¸€æ®µæ—¶é—´åŽè°ƒåº¦é”™è¯¯é‡è¿ž
            (async () => {
                this.reconnecting = true;
                const { error_delay, reconnect_interval } = this.keeper;
                if (this.first_error) {
                    this.first_error = false;
                    await (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.delay)(error_delay);
                }
                else
                    await (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.delay)(reconnect_interval);
                this.reconnecting = false;
                if (!this.disconnected)
                    try {
                        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.timeout)(3000, this.connect(), undefined, this.print);
                        this.first_error = true;
                    }
                    catch (error) {
                        // é‡è¿žå¤±è´¥çš„é”™è¯¯è¿™é‡Œéœ€è¦ç®€å•æ‰“å°ä¸‹ï¼Œ_on_error ä¸ä¼šæ‰“å°ï¼Œè¿™é‡Œä¹Ÿä¸ç»§ç»­å¾€ä¸ŠæŠ›äº†
                        if (this.print)
                            console.log(error.message);
                        // é‡è¿žç”± this.connect é‡Œé¢è°ƒç”¨ this._on_error å¤„ç†
                    }
            })();
        this.on_error(error, websocket);
    };
    _on_message = (data, websocket) => {
        this.handle(new Uint8Array(data), websocket);
    };
    /** ä½¿ç”¨è€…è‡ªå®šä¹‰çš„åœ¨ websocket è¿žæŽ¥å‡ºé”™æ—¶ï¼Œæˆ–è€… handlers å‡ºé”™æ—¶çš„å¤„ç† */
    on_error(error, websocket) {
        // ä½¿ç”¨è€…æœªå®šä¹‰ Remote å¦‚ä½•å¤„ç† error æ—¶ï¼Œä¸€èˆ¬æ¥è¯´ç›´æŽ¥å¿½ç•¥å³å¯ï¼Œå› ä¸º handlers ä¸­æŠ¥é”™äº†ä¹Ÿä¼šè¿”å›žç»™å¯¹ç«¯
        if (this.print)
            console.log(error && error instanceof WebSocketConnectionError ? error.message : error);
        // è¿™é‡Œç»§ç»­å¾€ä¸Šå±‚æŠ›æ²¡æœ‰å¤ªå¤§æ„ä¹‰ï¼Œä¸Šé¢ä¸€èˆ¬éƒ½æ˜¯ websocket on_message è¿™äº›
    }
    /** å¹‚ç­‰ï¼Œä¿è¯ websocket å·²è¿žæŽ¥ï¼Œå¦åˆ™æŠ›å‡ºå¼‚å¸¸
        ä¸€èˆ¬æƒ…å†µä¸éœ€è¦æ‰‹åŠ¨è°ƒç”¨ï¼Œåœ¨å…¶å®ƒæ–¹æ³•ä¸­ä¼šè‡ªåŠ¨è°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼Œé™¤éžéœ€è¦æ‰‹åŠ¨å»ºç«‹ websocket è¿žæŽ¥å¹¶ç¡®ä¿æˆåŠŸ
        è¿žæŽ¥æ–­å¼€åŽï¼Œé€šè¿‡ä¼ å…¥ url å‚æ•°æž„é€ çš„ remote å®žä¾‹ä¼šè‡ªåŠ¨åˆ›å»ºæ–°çš„ websocket è¿žæŽ¥ï¼Œè€Œé€šè¿‡ä¼ å…¥ websocket å‚æ•°æž„é€ çš„å®žä¾‹åªä¼šæ£€æŸ¥è¿žæŽ¥çŠ¶æ€ï¼Œåœ¨æ–­å¼€æ—¶æŠ›å‡ºå¼‚å¸¸
        ä½œä¸º websocket è¿žæŽ¥å‘èµ·æ–¹ï¼Œä¸éœ€è¦ä¼ å…¥ websocket
        ä½œä¸º websocket è¿žæŽ¥æŽ¥æ”¶æ–¹ï¼Œéœ€è¦ä¼ å…¥ä½¿ç”¨çš„ websocket è¿žæŽ¥ï¼Œç¡®ä¿è¿™ä¸ªè¿™ä¸ªè¿žæŽ¥çš„çŠ¶æ€ */
    async connect(websocket) {
        if (this.initiator)
            if (this.lwebsocket.resource?.readyState === WebSocketOpen)
                return;
            else if (!this.url)
                throw new Error('åˆ›å»º Remote æ—¶ä¼ å…¥çš„ websocket è¿žæŽ¥å·²æ–­å¼€');
            else {
                let reconnected = false;
                // å‡è®¾æœ‰å¤šä¸ªè¯·æ±‚æƒ³è¦å¹¶å‘è¿žæŽ¥ websocket, ä¸”æ­¤æ—¶ websocket æ˜¯æ–­å¼€çš„çŠ¶æ€
                // åº”è¯¥æŽ’é˜Ÿä¾æ¬¡è¿žæŽ¥ï¼Œè€Œä¸æ˜¯åŽç»­çš„è¿žæŽ¥ç›´æŽ¥ä½¿ç”¨ç¬¬ä¸€æ¬¡è¿žæŽ¥çš„ promiseï¼ŒåŽç»­è°ƒç”¨è¿˜æ˜¯åº”è¯¥å°è¯•é‡è¿žï¼ˆä¸æ­¢è¿žæŽ¥ä¸€æ¬¡ï¼‰
                await this.lwebsocket.request(async (websocket) => {
                    // ä¿å­˜çš„ rpc çŠ¶æ€åœ¨ this.handlers, ä¸Ž websocket æ— å…³ï¼Œå› æ­¤å³ä½¿æ–­å¼€é‡è¿žä¹Ÿä¸å½±å“ rpc çš„è¿è¡Œï¼Œå³
                    // åº•å±‚è¿žæŽ¥æ–­å¼€åŽè‡ªåŠ¨é‡è¿žå¯¹ä¸Šå±‚åº”è¯¥æ˜¯æ— æ„ŸçŸ¥çš„ï¼Œé™¤éžå†æ¬¡è¿žæŽ¥æ—¶å¤±è´¥
                    if (websocket?.readyState !== WebSocketOpen) { // é‡è¿ž
                        try {
                            this.lwebsocket.resource = await connect_websocket(this.url, {
                                on_message: this._on_message,
                                on_error: this._on_error,
                                print: this.print
                            });
                            reconnected = true;
                        }
                        catch (error) {
                            this._on_error(error);
                            throw error;
                        }
                    }
                });
                if (this.keeper) {
                    const { heartbeat_interval, func, args } = this.keeper;
                    // é¦–æ¬¡è¿žæŽ¥æˆåŠŸæ—¶ï¼Œå¼€å§‹å¿ƒè·³ä¿æ´»
                    if (!this.keeping) {
                        this.keeping = true;
                        (async () => {
                            for (;;) {
                                await (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.delay)(heartbeat_interval);
                                if (this.disconnected)
                                    break;
                                if (!this.reconnecting)
                                    try {
                                        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.timeout)(1000 * 2, this.call('echo'), undefined, this.print);
                                    }
                                    catch (error) {
                                        if (this.print)
                                            console.log(error.message);
                                        this._on_error(error);
                                    }
                            }
                        })();
                    }
                    if (reconnected && func)
                        await this.call(func, args);
                }
            }
        else if (websocket.readyState !== WebSocketOpen)
            throw new Error('ä¼ å…¥çš„ websocket è¿žæŽ¥å·²æ–­å¼€');
    }
    /** ä½œä¸º websocket è¿žæŽ¥å‘èµ·æ–¹æ‰‹åŠ¨å…³é—­åˆ°å¯¹ç«¯çš„ websocket è¿žæŽ¥ */
    disconnect() {
        this.disconnected = true;
        this.lwebsocket.resource?.close(1000);
    }
    /** å‘é€ message åˆ°å¯¹ç«¯ remote
        ä½œä¸º websocket è¿žæŽ¥å‘èµ·æ–¹ï¼Œä¸éœ€è¦ä¼ å…¥ websocket
        ä½œä¸º websocket è¿žæŽ¥æŽ¥æ”¶æ–¹ï¼Œå¿…ä¼  websocket å‚æ•°
        å‘é€æˆ–è¿žæŽ¥å‡ºé”™æ—¶è‡ªåŠ¨æ¸…ç† message.id å¯¹åº”çš„ handler */
    async send(message, websocket) {
        if (this.verbose)
            console.log('remote.send:', message);
        try {
            await this.connect(websocket);
            message[_io_js__WEBPACK_IMPORTED_MODULE_5__.message_symbol] = true;
            (websocket || this.lwebsocket.resource).send((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.pack)(message));
        }
        catch (error) {
            if (message.id)
                this.handlers.delete(message.id);
            throw error;
        }
    }
    /** å¤„ç†æŽ¥æ”¶åˆ°çš„ websocket message å¹¶è§£æž, æ ¹æ® message.id æˆ– message.func åˆ†å‘åˆ°å¯¹åº”çš„ handler è¿›è¡Œå¤„ç†ï¼Œ
        handler å¤„ç†å®ŒæˆåŽ:
        - ä¼ äº† func: è°ƒç”¨å‡½æ•°çš„æƒ…å†µä¸‹ (é€šå¸¸æ˜¯ä¸€å…ƒ rpc)ï¼Œæ€»æ˜¯å°†è¿”å›žå€¼åŒ…è£…ä¸º message å›žä¼ 
        - æœªä¼  func: é€šè¿‡ id è°ƒç”¨ï¼Œå¦‚æžœ handler è¿”å›žéž undefined çš„å€¼ï¼Œä¹ŸåŒ…è£…ä¸º message å›žä¼ 
        
        å¦‚æžœ message.done == true åˆ™å¯¹ç«¯æŒ‡ç¤ºå½“å‰ remote å¯ä»¥æ¸…ç† handler
        ä½¿ç”¨ Uint8Array ä½œä¸ºå‚æ•°æ›´çµæ´» https://stackoverflow.com/a/74505197/7609214
        è¿™ä¸ªæ–¹æ³•ä¸€èˆ¬ä¸ä¼šæŠ›å‡ºé”™è¯¯ï¼Œä¹Ÿä¸éœ€è¦ awaitï¼Œä¸€èˆ¬åœ¨ websocket on_message æ—¶ä½¿ç”¨ */
    async handle(data, websocket) {
        let message;
        try {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.check)(data[0] === 0xcc, 'message æ ¼å¼é”™è¯¯');
            message = (0,_io_js__WEBPACK_IMPORTED_MODULE_5__.parse)(data);
        }
        catch (error) {
            this.on_error(error);
            return;
        }
        const { id, func, done } = message;
        if (this.verbose)
            console.log('remote.handle:', message);
        let handler;
        if (func) {
            handler = this.funcs[func];
            // ä¼ äº† func è°ƒç”¨å‡½æ•°çš„æƒ…å†µä¸‹ï¼Œå¦‚æžœ message.data ä¸º undefined, é»˜è®¤ä¸º [ ]
            if (message.data === undefined)
                message.data = [];
        }
        else {
            handler = this.handlers.get(id);
            if (done && handler)
                this.handlers.delete(id);
        }
        try {
            if (handler) {
                const data = await handler(message, websocket);
                if (func || data !== undefined)
                    await this.send({ id, data }, websocket);
            }
            else
                throw message.error || new Error(`æ‰¾ä¸åˆ° rpc handler: ${func ? `func: ${func.quote()}` : `id: ${id}`}`);
        }
        catch (error) {
            // handler å‡ºé”™å¹¶ä¸æ„å‘³ç€ rpc ä¸€å®šä¼šç»“æŸï¼Œå¯èƒ½ error æ˜¯è¿è¡Œä¸­çš„æ­£å¸¸æ•°æ®ï¼Œæ‰€ä»¥ä¸èƒ½æ¸…ç† handler
            if (websocket.readyState === WebSocketOpen &&
                !message.error // é˜²æ­¢æ— é™å¾ªçŽ¯å¾€å¯¹æ–¹å‘é€ error, åªæœ‰åœ¨å¯¹æ–¹æ— é”™è¯¯æ—¶æ‰å¯ä»¥å‘é€
            )
                await this.send({ id, error, /* ä¸èƒ½è®¾ç½® done æ¸…ç†å¯¹é¢ handler, ç†ç”±åŒä¸Š */ }, websocket);
            // è¿™é‡Œç»§ç»­å¾€ä¸Šå±‚æŠ›æ²¡æœ‰å¤ªå¤§æ„ä¹‰ï¼Œä¸Šé¢ä¸€èˆ¬éƒ½æ˜¯ websocket on_message è¿™äº›ï¼Œäº¤ç»™è‡ªå®šä¹‰æˆ–é»˜è®¤çš„ on_error å¤„ç†
            this.on_error(error);
        }
    }
    /** è°ƒç”¨å¯¹ç«¯ remote ä¸­çš„ func, åªé€‚ç”¨äºŽæœ€ç®€å•çš„ä¸€å…ƒ rpc (è¯·æ±‚, å“åº”)
        ä½œä¸º websocket è¿žæŽ¥å‘èµ·æ–¹ï¼Œä¸éœ€è¦ä¼ å…¥ websocket
        ä½œä¸º websocket è¿žæŽ¥æŽ¥æ”¶æ–¹ï¼Œå¿…ä¼  websocket å‚æ•°  */
    async call(func, args, websocket) {
        return new Promise(async (resolve, reject) => {
            const id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.genid)();
            this.handlers.set(id, (message) => {
                const { error, data } = message;
                if (error)
                    reject(error);
                else
                    resolve(data);
                this.handlers.delete(id);
            });
            try {
                await this.send({ id, func, data: args }, websocket); // ä¸éœ€è¦ done: true, å› ä¸ºå¯¹é¢çš„ remote.handlers ä¸­ä¸ä¼šæœ‰è¿™ä¸ª id çš„ handler
            }
            catch (error) {
                reject(error);
            }
        });
    }
}
/** ä¸ºè¿žæŽ¥åˆ° server çš„ client åˆ›å»º RemoteClientï¼Œä»¥ä¾¿åŽç»­è°ƒç”¨ client ä¸­æ–¹æ³• */
class RemoteClient {
    remote;
    websocket;
    constructor(remote, websocket) {
        this.remote = remote;
        this.websocket = websocket;
    }
    /** è°ƒç”¨ client ä¸­çš„ func, åªé€‚ç”¨äºŽæœ€ç®€å•çš„ä¸€å…ƒ rpc (è¯·æ±‚, å“åº”) */
    async call(func, args) {
        return this.remote.call(func, args, this.websocket);
    }
    /** å‘é€ message åˆ° client
        å‘é€æˆ–è¿žæŽ¥å‡ºé”™æ—¶è‡ªåŠ¨æ¸…ç† message.id å¯¹åº”çš„ handler */
    async send(message) {
        return this.remote.send(message, this.websocket);
    }
}
//# sourceMappingURL=net.js.map

/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/path.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/path.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basename: () => (/* binding */ basename),
/* harmony export */   delimiter: () => (/* binding */ delimiter),
/* harmony export */   dirname: () => (/* binding */ dirname),
/* harmony export */   extname: () => (/* binding */ extname),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   isAbsolute: () => (/* binding */ isAbsolute),
/* harmony export */   join: () => (/* binding */ join),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   path: () => (/* binding */ path),
/* harmony export */   posix: () => (/* binding */ posix),
/* harmony export */   relative: () => (/* binding */ relative),
/* harmony export */   resolve: () => (/* binding */ resolve),
/* harmony export */   resolve_with_slash: () => (/* binding */ resolve_with_slash),
/* harmony export */   sep: () => (/* binding */ sep),
/* harmony export */   toNamespacedPath: () => (/* binding */ toNamespacedPath),
/* harmony export */   win32: () => (/* binding */ win32)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "path");

/** Normalize a string path, reducing '..' and '.' parts.
    When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved.
    @param path string path to normalize.
    @throws {TypeError} if `path` is not a string. */
function normalize(path) {
    return path__WEBPACK_IMPORTED_MODULE_0__.normalize(path).fp;
}
/** Join all arguments together and normalize the resulting path.
    @param paths paths to join.
    @throws {TypeError} if any of the path segments is not a string. */
function join(...paths) {
    return path__WEBPACK_IMPORTED_MODULE_0__.join(...paths.map(p => p.fp)).fp;
}
/** The right-most parameter is considered {to}. Other parameters are considered an array of {from}.
    
    Starting from leftmost {from} parameter, resolves {to} to an absolute path.
    
    If {to} isn't already absolute, {from} arguments are prepended in right to left order,
    until an absolute path is found. If after using all {from} paths still no absolute path is found,
    the current working directory is used as well. The resulting path is normalized,
    and trailing slashes are removed unless the path gets resolved to the root directory.
    
    @param paths A sequence of paths or path segments.
    @throws {TypeError} if any of the arguments is not a string. */
function resolve(...paths) {
    return path__WEBPACK_IMPORTED_MODULE_0__.resolve(...paths.map(p => p.fp)).fp;
}
/** å’Œ resolve ä¸€æ ·ï¼Œä½†æ˜¯ä¿ç•™æœ€åŽä¸€ä¸ª path ç»“å°¾çš„ / */
function resolve_with_slash(...paths) {
    let fp = path.resolve(...paths);
    if (paths.last.endsWith('/'))
        fp += '/';
    return fp;
}
/** Determines whether {path} is an absolute path.
    An absolute path will always resolve to the same location, regardless of the working directory.
    
    If the given {path} is a zero-length string, `false` will be returned.
    
    @param path path to test.
    @throws {TypeError} if `path` is not a string. */
function isAbsolute(path) {
    return path__WEBPACK_IMPORTED_MODULE_0__.isAbsolute(path.fp);
}
/** Solve the relative path from {from} to {to} based on the current working directory.
    At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.
    
    @throws {TypeError} if either `from` or `to` is not a string. */
function relative(from, to) {
    return path__WEBPACK_IMPORTED_MODULE_0__.relative(from.fp, to.fp).fp;
}
/** Return the directory name of a path. Similar to the Unix dirname command.
    @param path the path to evaluate.
    @throws {TypeError} if `path` is not a string. */
function dirname(path) {
    return path__WEBPACK_IMPORTED_MODULE_0__.dirname(path.fp).fp;
}
/** Return the last portion of a path. Similar to the Unix basename command.
    Often used to extract the file name from a fully qualified path.
    @param path the path to evaluate.
    @param suffix optionally, an extension to remove from the result.
    @throws {TypeError} if `path` is not a string or if `ext` is given and is not a string. */
function basename(path, suffix) {
    return path__WEBPACK_IMPORTED_MODULE_0__.basename(path.fp, suffix);
}
/** Return the extension of the path, from the last '.' to end of string in the last portion of the path.
    If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string.
    
    @param path the path to evaluate.
    @throws {TypeError} if `path` is not a string. */
function extname(path) {
    return path__WEBPACK_IMPORTED_MODULE_0__.extname(path.fp);
}
/** `/` */
const sep = '/';
/** The platform-specific file delimiter. ';' or ':'. */
const delimiter = path__WEBPACK_IMPORTED_MODULE_0__.delimiter;
/** Returns an object from a path string - the opposite of format().
    @param path path to evaluate.
    @throws {TypeError} if `path` is not a string. */
function parse(path) {
    return path__WEBPACK_IMPORTED_MODULE_0__.parse(path.fp);
}
/** Returns a path string from an object - the opposite of parse().
    @param pathObject path to evaluate. */
function format(pathObject) {
    return path__WEBPACK_IMPORTED_MODULE_0__.format(pathObject).fp;
}
/** On Windows systems only, returns an equivalent namespace-prefixed path for the given path.
    If path is not a string, path will be returned without modifications.
    This method is meaningful only on Windows system.
    On POSIX systems, the method is non-operational and always returns path without modifications. */
function toNamespacedPath(path) {
    return path__WEBPACK_IMPORTED_MODULE_0__.toNamespacedPath(path.fp).fp;
}
const posix = path__WEBPACK_IMPORTED_MODULE_0__.posix;
const win32 = path__WEBPACK_IMPORTED_MODULE_0__.win32;
/** ç»Ÿä¸€ä½¿ç”¨ / ä½œä¸ºåˆ†éš”ç¬¦çš„ path æ¨¡å— */
let path = {
    normalize,
    join,
    resolve,
    resolve_with_slash,
    isAbsolute,
    relative,
    dirname,
    basename,
    extname,
    sep,
    delimiter,
    parse,
    format,
    toNamespacedPath
};
//# sourceMappingURL=path.js.map

/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/process.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/process.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CallError: () => (/* binding */ CallError),
/* harmony export */   call: () => (/* binding */ call),
/* harmony export */   call_nodejs: () => (/* binding */ call_nodejs),
/* harmony export */   exe_nodejs: () => (/* binding */ exe_nodejs),
/* harmony export */   get_command: () => (/* binding */ get_command),
/* harmony export */   launch: () => (/* binding */ launch),
/* harmony export */   launch_nodejs: () => (/* binding */ launch_nodejs),
/* harmony export */   noprint: () => (/* binding */ noprint),
/* harmony export */   platform: () => (/* binding */ platform),
/* harmony export */   print_no_command: () => (/* binding */ print_no_command),
/* harmony export */   sea: () => (/* binding */ sea),
/* harmony export */   start: () => (/* binding */ start),
/* harmony export */   start_nodejs: () => (/* binding */ start_nodejs),
/* harmony export */   username: () => (/* binding */ username),
/* harmony export */   wait_output: () => (/* binding */ wait_output)
/* harmony export */ });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ "os");
/* harmony import */ var node_sea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:sea */ "node:sea");
/* harmony import */ var _prototype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./prototype.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/prototype.js");
/* harmony import */ var _file_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./file.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/file.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/utils.js");






const sea = node_sea__WEBPACK_IMPORTED_MODULE_2__.isSea();
const exe_nodejs = process.execPath.fp;
const platform = os__WEBPACK_IMPORTED_MODULE_1__.platform();
const username = os__WEBPACK_IMPORTED_MODULE_1__.userInfo().username;
const noprint = { print: false };
const print_no_command = { print: { command: false, code: false, stdout: true, stderr: true } };
function get_command(exe, args) {
    return (short_exe_names[exe] || exe.quote_if_space()) +
        (args?.length
            ? ` ${args.map(arg => arg.quote_if_space()).join(' ')}`
            : '');
}
async function prepare_spawn(detached, exe, args, { cwd, window: _window = false, envs, 
// @ts-ignore
input, stdin = Boolean(input), stdout = !detached, stderr = stdout, print = true, proxy, }) {
    // --- å¤„ç† proxy, envs
    if (proxy === true) {
        const { MyProxy } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./net.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/net.js"));
        proxy = MyProxy.socks5;
    }
    let envs_;
    if (envs || proxy)
        envs_ = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.filter_values)({
            ...process.env,
            ...proxy ? {
                http_proxy: proxy,
                https_proxy: proxy,
                no_proxy: '127.0.0.1,::1,localhost,192.168.0.0/20,192.168.100.0/24'
            } : {},
            ...envs
        });
    // --- å¤„ç† stdio: å°† stdio ä¸­çš„ true, false, string è½¬æ¢ä¸ºå¯¹åº”çš„ node.js stdio å€¼
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.check)(stdout !== 'ignore' || stderr !== 'ignore');
    if (detached)
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.check)([stdin, stdout, stderr].every(io => io !== true), 'è°ƒç”¨ start å¯åŠ¨ detached è¿›ç¨‹æ—¶ stdio ä¸èƒ½ä¸º true (pipe)');
    let opened_handles = [];
    async function close_all_handles() {
        await Promise.all(opened_handles.map(async (handle) => handle.close()));
    }
    async function resolve_stdio(io, flags) {
        if (io === true)
            return 'pipe';
        else if (typeof io === 'string') {
            const handle = await (0,_file_js__WEBPACK_IMPORTED_MODULE_4__.fopen)(io, flags);
            opened_handles.push(handle);
            return handle.fd;
        }
        else
            return 'ignore';
    }
    let pstdout;
    let stdio;
    try {
        stdio = await Promise.all([
            resolve_stdio(stdin, 'r'),
            (pstdout = resolve_stdio(stdout, 'w')),
            // è‹¥ stderr å’Œ stdout ç›¸åŒï¼Œåˆ™å¤ç”¨å…¶ fd
            stderr === stdout && typeof stderr === 'string'
                ? pstdout
                : resolve_stdio(stderr, 'w')
        ]);
    }
    catch (error) {
        await close_all_handles();
        throw error;
    }
    // --- å¤„ç† print
    if (typeof print === 'boolean')
        print = {
            command: print,
            code: print,
            stdout: print,
            stderr: print
        };
    print = {
        command: print.command ?? true,
        code: print.code ?? true,
        stdout: stdout && (print.stdout ?? true),
        stderr: stderr && (print.stderr ?? true)
    };
    const command = get_command(exe, args);
    if (print.command)
        console.log(command.blue);
    return {
        // å·²ç»è½¬ä¸ºäº†å®Œæ•´çš„ FullPrintOptions
        print: print,
        command,
        spawn_options: {
            cwd,
            shell: false,
            windowsHide: !_window,
            detached,
            stdio,
            ...envs_ ? { env: envs_ } : {}
        },
        close_all_handles: opened_handles.length ? close_all_handles : undefined
    };
}
function to_subprocess(child, { title, exe, args, command, }) {
    if (title)
        child.title = title;
    child.exe = exe;
    child.args = args || [];
    child.command = command;
    child[_utils_js__WEBPACK_IMPORTED_MODULE_5__.inspect.custom] = () => {
        const { title, command, running, exitCode, presult } = child;
        return {
            ...title ? { title } : {},
            command,
            running,
            ...running ? {} : {
                code: exitCode,
                presult
            }
        };
    };
    Object.defineProperties(child, {
        finished: {
            get() {
                return this.exitCode !== null;
            }
        },
        running: {
            get() {
                return this.exitCode === null;
            }
        }
    });
    return child;
}
/** ä½¿ç”¨ exe å¯åŠ¨ç‹¬ç«‹ (detached) çš„è¿›ç¨‹ï¼Œä¸å—å½“å‰ node.js è¿›ç¨‹é€€å‡ºçš„å½±å“ï¼Œå¯é‡å®šå‘ stdio åˆ°æ–‡ä»¶ï¼ˆé»˜è®¤ç›´æŽ¥å¿½ç•¥ï¼‰
    - exe: .exe è·¯å¾„æˆ–æ–‡ä»¶å (å»ºè®®ä½¿ç”¨å®Œæ•´è·¯å¾„ï¼Œè·³è¿‡ path æœç´¢ï¼Œæ€§èƒ½æ›´é«˜)
    - args?: `[ ]` å‚æ•°åˆ—è¡¨
    - options?: {@link StartOptions} ç»§æ‰¿è‡ª {@link BaseOptions}
        - cwd?: `'T:/'`
        - envs?: `process.env` è¦†ç›–ï¼æ·»åŠ åˆ° process.env çš„çŽ¯å¢ƒå˜é‡ï¼Œä¼  null æ—¶å¯ä»¥å–æ¶ˆè®¾ç½®è¯¥å˜é‡
        - proxy?: åˆ›å»ºå­è¿›ç¨‹æ—¶æ·»åŠ  http_proxy, https_proxy, no_proxy çŽ¯å¢ƒå˜é‡ä»¥å¯ç”¨ä»£ç†
        - print?: `true` æ˜¯å¦æ‰“å°å¯åŠ¨å‘½ä»¤è¡Œ
        - stdin?: æŽ§åˆ¶å­è¿›ç¨‹ stdinï¼Œé»˜è®¤ä¸º `false` ('ignore', è¯»ç©ºè®¾å¤‡)
            å¯ä¼ å…¥ stringï¼Œè®¾ç½®å­è¿›ç¨‹ stdin ä¸ºæŸä¸ªæ–‡ä»¶è·¯å¾„ (æ‰“å¼€æ–‡ä»¶ï¼Œå°†å¥æŸ„è®¾ç½®ä¸ºå­è¿›ç¨‹ stdin)
        - stdout?: æŽ§åˆ¶å­è¿›ç¨‹ stdoutï¼Œé»˜è®¤ä¸º `false` ('ignore', å†™ç©ºè®¾å¤‡)
            å¯ä¼ å…¥ stringï¼Œè®¾ç½®å­è¿›ç¨‹ stdout æŸä¸ªæ–‡ä»¶è·¯å¾„ (æ‰“å¼€æ–‡ä»¶ï¼Œå°†å¥æŸ„è®¾ç½®ä¸ºå­è¿›ç¨‹ stdout)
        - stderr?: æŽ§åˆ¶å­è¿›ç¨‹ stderrï¼Œé»˜è®¤ä¸º `stdout` çš„å€¼ï¼Œç”¨æ³•åŒ stdout
        - window?: é»˜è®¤ä¸º falseï¼Œä¸æ˜¾ç¤ºçª—å£ï¼Œè®¾ç½®å¯åŠ¨è¿›ç¨‹çš„å‚æ•° CREATE_NO_WINDOW, å’Œ SW_HIDE
        - title?: ç”±åˆ›å»ºè¿›ç¨‹çš„è°ƒç”¨è€…è®¾ç½®çš„ï¼Œç”¨äºŽåŒºåˆ†ã€è¯†åˆ«ã€è®°å¿†çš„å¯é€‰åç§° */
async function start(exe, args = [], options = {}) {
    const { spawn_options, close_all_handles, command } = await prepare_spawn(true, exe, args, options);
    try {
        let child = to_subprocess((0,child_process__WEBPACK_IMPORTED_MODULE_0__.spawn)(exe, args, spawn_options), { exe, command, args, title: options.title });
        child.unref();
        return child;
    }
    finally {
        if (close_all_handles)
            await close_all_handles();
    }
}
class CallError extends Error {
    name = 'CallError';
    constructor({ message, pid, stdout, stderr, code, signal, command, child, print }) {
        super(message);
        // defineProperty é»˜è®¤ enumerable: falseï¼Œä¸ä¼šåœ¨ inspect ä¸­æ˜¾ç¤º
        Object.defineProperties(this, {
            pid: { value: pid },
            stdout: { value: stdout },
            stderr: { value: stderr },
            code: { value: code },
            signal: { value: signal },
            command: { value: command },
            child: { value: child },
            print: { value: print }
        });
    }
    [_utils_js__WEBPACK_IMPORTED_MODULE_5__.inspect.custom](depth, options, inspect) {
        const { colors } = options;
        return (!this.print.stdout && this.stdout
            ? `${(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.colored)('æ ‡å‡†è¾“å‡º:\n', 'yellow', colors)}${this.stdout.toString().ensure_end()}`
            : '') +
            (!this.print.stderr && this.stderr
                ? `${(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.colored)('æ ‡å‡†é”™è¯¯:\n', 'yellow', colors)}${this.stderr.toString().ensure_end()}`
                : '') +
            inspect(this, { ...options, customInspect: false });
    }
}
async function call(exe, args = [], options = {}) {
    const { print, spawn_options, close_all_handles, command } = await prepare_spawn(false, exe, args, options);
    let child;
    try {
        child = to_subprocess((0,child_process__WEBPACK_IMPORTED_MODULE_0__.spawn)(exe, args, spawn_options), { exe, args, command, title: options.title });
    }
    finally {
        if (close_all_handles)
            await close_all_handles();
    }
    const { stdio } = spawn_options;
    const { encoding = 'utf-8', throw_code = true, input, on_stdout, on_stderr, on_child } = options;
    // é˜²æ­¢ child spawn å¤±è´¥æ—¶ crash nodejs è¿›ç¨‹
    child.on('error', error => {
        console.error(error);
    });
    if (stdio[0] === 'pipe') {
        child.stdin.setDefaultEncoding('utf-8');
        if (input)
            child.stdin.end(input);
    }
    // --- æ”¶é›†è¿›ç¨‹è¾“å‡º
    const piped_stdout = stdio[1] === 'pipe';
    const piped_stderr = stdio[2] === 'pipe';
    let stdouts = [];
    let stderrs = [];
    if (piped_stdout) {
        if (encoding === 'utf-8' || encoding === 'utf-16le')
            child.stdout.setEncoding(encoding);
        else if (encoding !== 'binary')
            child.stdout = child.stdout.pipe(new _utils_js__WEBPACK_IMPORTED_MODULE_5__.DecoderStream(encoding));
        child.stdout.on('data', on_stdout || (print.stdout
            ? (chunk) => {
                stdouts.push(chunk);
                process.stdout.write(chunk);
            }
            : (chunk) => {
                stdouts.push(chunk);
            }));
    }
    if (piped_stderr) {
        if (encoding === 'utf-8' || encoding === 'utf-16le')
            child.stderr.setEncoding(encoding);
        else if (encoding !== 'binary')
            child.stderr = child.stderr.pipe(new _utils_js__WEBPACK_IMPORTED_MODULE_5__.DecoderStream(encoding));
        child.stderr.on('data', on_stderr || (print.stderr
            ? (chunk) => {
                stderrs.push(chunk);
                process.stderr.write(chunk);
            }
            : (chunk) => {
                stderrs.push(chunk);
            }));
    }
    on_child?.(child);
    let code, signal;
    await new Promise(resolve => {
        child.once('close', (_code, _signal) => {
            code = _code;
            signal = _signal;
            resolve();
        });
    });
    const message = `è¿›ç¨‹ ${command} ` + (code
        ? `${throw_code ? 'å¼‚å¸¸' : ''}ç»“æŸï¼Œé€€å‡ºç : ${code}${signal ? `ï¼Œä¿¡å·: ${signal}` : ''}`
        : 'æ­£å¸¸ç»“æŸ');
    if (print.code && !code)
        console.log(message.blue);
    const result = {
        pid: child.pid,
        stdout: encoding === 'binary'
            ? Buffer.concat(stdouts)
            : stdouts.join(''),
        stderr: encoding === 'binary'
            ? Buffer.concat(stderrs)
            : stderrs.join(''),
        code,
        signal,
        command,
        message,
        child,
        print,
        [_utils_js__WEBPACK_IMPORTED_MODULE_5__.inspect.custom]() {
            const { stdout, stderr, command, print, code, signal } = this;
            return {
                ...!print.command ? { command } : {},
                ...piped_stdout && !print.stdout ? { stdout } : {},
                ...piped_stderr && !print.stderr ? { stderr } : {},
                ...code ? { code } : {},
                ...signal ? { signal } : {},
            };
        }
    };
    if (throw_code && code)
        throw new CallError(result);
    return result;
}
async function launch(exe, args, options) {
    return new Promise(resolve => {
        const presult = call(exe, args, {
            on_child(child) {
                child.presult = presult;
                resolve(child);
            },
            ...options,
        });
    });
}
/** è°ƒç”¨ node <js> å¹¶ç­‰å¾…ç»“æžœ
    - js: .js è·¯å¾„ (ç›¸å¯¹è·¯å¾„æ ¹æ® cwd è§£æž)
    - args?: `[ ]` å‚æ•°åˆ—è¡¨
    - options?: {@link CallNodeJsOptions} ç»§æ‰¿è‡ª {@link CallOptions} å’Œ {@link NodeJsOptions}
        - cwd?: `'T:/'`
        - envs?: `process.env` è¦†ç›–ï¼æ·»åŠ åˆ° process.env çš„çŽ¯å¢ƒå˜é‡
        - encoding?: `'utf-8'` å­è¿›ç¨‹è¾“å‡ºç¼–ç 
        - print?: `true` print é€‰é¡¹ï¼Œæ”¯æŒè®¾ç½®ç»†é¡¹
        - stdio?: `'pipe'` è®¾ç½®ä¸º 'ignore' æ—¶å¿½ç•¥ stdio å¤„ç†
        - throw_code?: `true` code ä¸ä¸º 0 æ—¶æ˜¯å¦æŠ›å‡ºå¼‚å¸¸
        - inspect?: nodejs debugger port, å¡« 9229 ç«¯å£ (æˆ–è€…ä¼  true) å¯ä»¥ç”¨ä¸´æ—¶é…ç½®æ¥è°ƒè¯•
        - break?: break at first line */
async function call_nodejs(js, args, options) {
    return call(exe_nodejs, get_nodejs_args(js, args, options), options);
}
/** å¯åŠ¨ç‹¬ç«‹çš„ node.js è¿›ç¨‹ (detached)ï¼Œæ‰§è¡ŒæŸä¸ª js æ–‡ä»¶
    - js: .js è·¯å¾„ (ç›¸å¯¹è·¯å¾„æ ¹æ® cwd è§£æž)
    - args: `[]` å‚æ•°åˆ—è¡¨
    - options?: {@link StartNodeJsOptions} ç»§æ‰¿è‡ª {@link StartOptions} å’Œ {@link NodeJsOptions}
        - inspect?: nodejs debugger port, å¡« 9229 ç«¯å£ (æˆ–è€…ä¼  true) å¯ä»¥ç”¨ä¸´æ—¶é…ç½®æ¥è°ƒè¯•
        - break?: åœ¨ç¬¬ä¸€è¡Œåœæ­¢ */
async function start_nodejs(js, args, options) {
    return start(exe_nodejs, get_nodejs_args(js, args, options), options);
}
/** å¯åŠ¨å­ node.js è¿›ç¨‹ï¼ˆé€šå¸¸æ˜¯é•¿æœŸåœ¨åŽå°è¿è¡Œçš„ï¼Œæˆ–è€…å¯äº¤äº’çš„ï¼Œéœ€è¦èƒ½æŽ§åˆ¶ï¼‰ï¼Œæ‰§è¡ŒæŸä¸ª js æ–‡ä»¶ï¼Œ
    è¿”å›ž {@link SubProcess} å¯¹è±¡ (ç»§æ‰¿è‡ª ChildProcess)ï¼Œå¯ä»¥åš .kill() ç­‰æ“ä½œ
    - js: .js è·¯å¾„ (ç›¸å¯¹è·¯å¾„æ ¹æ® cwd è§£æž)
    - args: `[]` å‚æ•°åˆ—è¡¨
    - options?: {@link CallNodeJsOptions} ç»§æ‰¿è‡ª {@link CallOptions} å’Œ {@link NodeJsOptions}
        - inspect?: nodejs debugger port, å¡« 9229 ç«¯å£ (æˆ–è€…ä¼  true) å¯ä»¥ç”¨ä¸´æ—¶é…ç½®æ¥è°ƒè¯•
        - break?: åœ¨ç¬¬ä¸€è¡Œåœæ­¢ */
async function launch_nodejs(js, args, options) {
    return launch(exe_nodejs, get_nodejs_args(js, args, options), options);
}
function get_nodejs_args(js, args = [], { inspect, break: _break } = {}) {
    return [
        '--enable-source-maps',
        ...inspect ? [`--inspect${_break ? '-brk' : ''}=localhost:${inspect === true ? 9229 : inspect}`] : [],
        js,
        ...args
    ];
}
/** å¯é€‰çš„å‘å­è¿›ç¨‹è¾“å…¥å†…å®¹ï¼Œå¹¶ç­‰å¾…å­è¿›ç¨‹è¾“å‡ºç‰¹å®šçš„å†…å®¹ï¼Œç±»ä¼¼ä¸€æ¬¡æ— è¿”å›žå€¼ï¼Œä»…æœ‰å®ŒæˆçŠ¶æ€çš„ rpc è°ƒç”¨
    æ ¹æ®æ–‡æœ¬å†…å®¹åŒ¹é…å…¶å®žä¸å¤ªå¥½ï¼Œå®žåœ¨æ˜¯æ²¡æœ‰åˆ«çš„ rpc æ–¹æ³•å†ä½¿ç”¨å§
    - ps: å­è¿›ç¨‹
    - pattern: åŒ¹é…å†…å®¹ï¼Œæ”¯æŒ string å’Œ RegExp
    - input?: è¦è¾“å…¥çš„å†…å®¹
    - timeout?: ç­‰å¾…è¶…æ—¶æ—¶é—´ */
async function wait_output(ps, pattern, input, _timeout) {
    const { stdin, stdout } = ps;
    const matcher = typeof pattern === 'string'
        ? (chunk) => chunk.includes(pattern)
        : (chunk) => pattern.test(chunk);
    let on_data;
    let pfound = new Promise(resolve => {
        on_data = (chunk) => {
            if (matcher(chunk)) {
                stdout.off('data', on_data);
                resolve();
            }
        };
        stdout.on('data', on_data);
        if (input)
            stdin.write(input);
    });
    if (_timeout)
        try {
            await (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.timeout)(_timeout, pfound);
        }
        catch (error) {
            stdout.off('data', on_data);
            throw error;
        }
    else
        await pfound;
}
const short_exe_names = {
    [exe_nodejs]: 'node',
};
//# sourceMappingURL=process.js.map

/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/prototype.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/prototype.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   brackets: () => (/* binding */ brackets),
/* harmony export */   build_mapper: () => (/* binding */ build_mapper),
/* harmony export */   byte_size: () => (/* binding */ byte_size),
/* harmony export */   cjk: () => (/* binding */ cjk),
/* harmony export */   emoji_regex: () => (/* binding */ emoji_regex),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   ident: () => (/* binding */ ident),
/* harmony export */   is_codepoint_fullwidth: () => (/* binding */ is_codepoint_fullwidth),
/* harmony export */   is_key_type: () => (/* binding */ is_key_type),
/* harmony export */   noop: () => (/* binding */ noop),
/* harmony export */   not_empty: () => (/* binding */ not_empty),
/* harmony export */   quotes: () => (/* binding */ quotes),
/* harmony export */   to_getter_property_descriptors: () => (/* binding */ to_getter_property_descriptors),
/* harmony export */   to_json: () => (/* binding */ to_json),
/* harmony export */   to_json_safely: () => (/* binding */ to_json_safely),
/* harmony export */   to_method_property_descriptors: () => (/* binding */ to_method_property_descriptors)
/* harmony export */ });
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var emoji_regex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! emoji-regex */ "./node_modules/.pnpm/emoji-regex@10.4.0/node_modules/emoji-regex/index.mjs");
/* harmony import */ var strip_ansi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strip-ansi */ "./node_modules/.pnpm/strip-ansi@7.1.0/node_modules/strip-ansi/index.js");
/* harmony import */ var _i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./i18n/instance.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/instance.js");


const emoji_regex = (0,emoji_regex__WEBPACK_IMPORTED_MODULE_1__["default"])();


const noop = () => { };
const ident = (x) => x;
const build_mapper = (key) => (obj) => obj[key];
/** value ä¸ä¸º null æˆ– undefined */
const not_empty = (value) => value !== null && value !== undefined;
const empty = (value) => value === undefined || value === null;
const key_types = ['string', 'number', 'symbol'];
const is_key_type = ((key) => key_types.includes(typeof key));
function to_method_property_descriptors(methods) {
    return Object.fromEntries(Object.entries(methods)
        .map(([name, value]) => ([name, {
            configurable: true,
            writable: true,
            enumerable: false,
            value,
        }])));
}
function to_getter_property_descriptors(getters) {
    return Object.fromEntries(Object.entries(getters)
        .map(([name, get]) => ([name, {
            configurable: true,
            enumerable: false,
            get,
        }])));
}
const cjk = '([\u2e80-\u9fff\uf900-\ufaff])';
const quotes = {
    single: "'",
    double: '"',
    backtick: '`',
};
const brackets = {
    round: ['(', ')'],
    square: ['[', ']'],
    curly: ['{', '}'],
    pointy: ['<', '>'],
    corner: ['ã€Œ', 'ã€'],
    fat: ['ã€', 'ã€‘'],
    tortoise_shell: ['ã€”', 'ã€•'],
};
if (!globalThis.my_prototype_defined) {
    // ------------------------------------ String.prototype
    Object.defineProperties(String.prototype, {
        ...to_getter_property_descriptors({
            width() {
                const s = (0,strip_ansi__WEBPACK_IMPORTED_MODULE_2__["default"])(this.replace(emoji_regex, '  '));
                let width = 0;
                for (let i = 0; i < s.length; i++) {
                    const code = s.codePointAt(i);
                    if ((code <= 0x1f || (code >= 0x7f && code <= 0x9f)) || // ignore control characters
                        code >= 0x300 && code <= 0x36f // ignore combining characters
                    )
                        continue;
                    // surrogates
                    if (code > 0xffff)
                        i++;
                    width += is_codepoint_fullwidth(code) ? 2 : 1;
                }
                return width;
            }
        }),
        // ------------ æ–‡æœ¬å¤„ç†å·¥å…·æ–¹æ³•
        ...to_method_property_descriptors({
            /** æˆªå–å­—ç¬¦ä¸²ä¸è¶…è¿‡ width æ˜¾ç¤ºå®½åº¦çš„éƒ¨åˆ†ï¼Œå¹¶ä¿ç•™é¢œè‰²
                æ‰¾åˆ°å¹¶è®°å½•èƒ½å®¹çº³ å­—ç¬¦ä¸² + â€¦ çš„æœ€åŽä¸€ä¸ªå­—ç¬¦çš„ä½ç½® i_fitted
                  - è‹¥å®Œæ•´çš„å­—ç¬¦ä¸²é•¿åº¦è¶…è¿‡ widthï¼Œè¿”å›ž slice(0, i_fitted + 1) + â€¦
                  - å¦åˆ™                          è¿”å›ž this
             */
            truncate(width) {
                const color_bak = this.startsWith('\u001b') ? this.slice(0, 5) : '';
                const s = (0,strip_ansi__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
                if (width <= 2)
                    return this.slice(0, width);
                let i_fitted = 0;
                let fitted_width = 0;
                let cur_width = 0;
                for (let i = 0; i < s.length; i++) {
                    const code = s.codePointAt(i);
                    if ((code <= 0x1F || (code >= 0x7F && code <= 0x9F)) || // Ignore control characters
                        code >= 0x300 && code <= 0x36F // Ignore combining characters
                    )
                        continue;
                    // surrogates (codepoint éœ€è¦ç”¨ä¸¤ä¸ª utf-16 ç¼–ç å•ä½è¡¨ç¤ºï¼Œå› æ­¤è¿™é‡Œè·³è¿‡ç¬¬äºŒä¸ªç¼–ç å•ä½ï¼Œé˜²æ­¢é‡å¤è®¡ç®—æ˜¾ç¤ºå®½åº¦)
                    if (code > 0xFFFF)
                        i++;
                    const w = is_codepoint_fullwidth(code) ? 2 : 1;
                    if (cur_width + w + 2 <= width) {
                        i_fitted = i;
                        fitted_width += w;
                    }
                    cur_width += w;
                    if (cur_width > width) {
                        const i_fitted_next = i_fitted + 1;
                        // â€¦ åœ¨ winterm ä¸­å¯¹ä¸é½ï¼Œä½¿ç”¨ Â·Â·Â· ä»£æ›¿
                        const t = s.slice(0, i_fitted_next) + ' '.repeat(width - 2 - fitted_width) + 'Â·Â·';
                        return color_bak ? color_bak + t + '\u001b[39m' : t;
                    }
                }
                return this;
            },
            pad(width, { character = ' ', position = 'right' } = {}) {
                const _width = this.width;
                if (_width >= width)
                    return this;
                if (position === 'right')
                    return this + character.repeat((width - _width) / character.width);
                return character.repeat(width - _width) + this;
            },
            limit(width, { character = ' ', position = 'right' } = {}) {
                return this.pad(width, { character, position }).truncate(width);
            },
            to_regexp(preservations, flags = '') {
                const preserved_chars = new Set(preservations);
                const replace_chars = Array.prototype.filter.call('|\\{}()[]^$+*?.-', (c) => !preserved_chars.has(c))
                    .map((c) => c === ']' ? '\\]' : c).join('');
                return new RegExp(this.replace(new RegExp(`[${replace_chars}]`, 'g'), '\\$&'), flags);
            },
            refmt(pattern, pattern_, preservations = '', flags = '', transformer = (name, value) => value || '', pattern_placeholder = /\{.*?\}/g) {
                // --- è½¬æ¢ pattern ä¸º pattern_regx
                let last_end = 0;
                // placeholder matched group indexes
                let $placeholders = {};
                let regx_parts = [];
                function add_part(left, right) {
                    const part = pattern.slice(left, right);
                    if (part)
                        regx_parts.push(part.to_regexp(preservations).source.bracket());
                }
                pattern.replace(pattern_placeholder, ($0, offset) => {
                    add_part(last_end, offset);
                    last_end = offset + $0.length;
                    const placeholder = $0.slice(1, -1);
                    let [placeholder_name, placeholder_pattern] = placeholder.split(':').map(s => s.trim());
                    let optional = false;
                    if (placeholder_name.endsWith('?')) {
                        placeholder_name = placeholder_name.slice(0, -1);
                        optional = true;
                    }
                    $placeholders[placeholder_name] = regx_parts.push(placeholder_pattern ?
                        `${placeholder_pattern.bracket()}${optional ? '?' : ''}`
                        :
                            '(.*?)');
                    return '';
                });
                add_part(last_end);
                // æœ€åŽä¸€ä¸ª (.*?) æ”¹ä¸ºè´ªå¿ƒåŒ¹é…ï¼Œæ»¡è¶³ .{suffix} çš„éœ€è¦
                regx_parts = regx_parts.filter(part => part);
                if (regx_parts.at(-1) === '(.*?)')
                    regx_parts[regx_parts.length - 1] = '(.*)';
                const pattern_regx = new RegExp(regx_parts.join(''), flags);
                // --- æ ¹æ® pattern_regx åŽ»åŒ¹é…åŽŸæœ‰å­—ç¬¦ä¸²ï¼ŒèŽ·å–åŒ¹é…ç»“æžœï¼Œç”Ÿæˆ placeholders è¯å…¸
                const matches = pattern_regx.exec(this);
                if (!matches)
                    return this;
                const placeholders = Object.fromEntries(Object.entries($placeholders)
                    .map(([name, $i]) => [
                    [name, matches[$i]],
                    [`${name}.before`, matches[$i - 1] || ''],
                    [`${name}.after`, matches[$i + 1] || ''],
                ])
                    .flat());
                // --- è½¬æ¢ pattern_ ä¸º replacement_strï¼Œå¦‚æžœæœ‰ transformer åˆ™åœ¨é‡åˆ° placeholder æ—¶åº”ç”¨
                last_end = 0;
                let replacement_parts = [];
                pattern_.replace(pattern_placeholder, ($0, offset) => {
                    replacement_parts.push(pattern_.slice(last_end, offset));
                    last_end = offset + $0.length;
                    const placeholder_name = $0.slice(1, -1);
                    replacement_parts.push(transformer(placeholder_name, placeholders[placeholder_name], placeholders));
                    return '';
                });
                replacement_parts.push(pattern_.slice(last_end));
                return this.replace(pattern_regx, replacement_parts.join(''));
            },
            find(pattern, preservations = '', flags = '', pattern_placeholder = /\{.*?\}/g) {
                // --- è½¬æ¢ pattern ä¸º pattern_regx
                let last_end = 0;
                // placeholder matched group index
                let $placeholders = {};
                let regx_parts = [];
                function add_part(left, right) {
                    const part = pattern.slice(left, right);
                    if (part)
                        regx_parts.push(part.to_regexp(preservations).source.bracket());
                }
                pattern.replace(pattern_placeholder, ($0, offset) => {
                    add_part(last_end, offset);
                    last_end = offset + $0.length;
                    const placeholder = $0.slice(1, -1);
                    let [placeholder_name, placeholder_pattern] = placeholder.split(':').map(s => s.trim());
                    let optional = false;
                    if (placeholder_name.endsWith('?')) {
                        placeholder_name = placeholder_name.slice(0, -1);
                        optional = true;
                    }
                    $placeholders[placeholder_name] = regx_parts.push(placeholder_pattern ?
                        `${placeholder_pattern.bracket()}${optional ? '?' : ''}`
                        :
                            '(.*?)');
                    return '';
                });
                add_part(last_end);
                // æœ€åŽä¸€ä¸ª (.*?) æ”¹ä¸ºè´ªå¿ƒåŒ¹é…ï¼Œæ»¡è¶³ .{suffix} çš„éœ€è¦
                regx_parts = regx_parts.filter(part => part);
                if (regx_parts.at(-1) === '(.*?)')
                    regx_parts[regx_parts.length - 1] = '(.*)';
                const pattern_regx = new RegExp(regx_parts.join(''), flags);
                // --- æ ¹æ® pattern_regx åŽ»åŒ¹é…åŽŸæœ‰å­—ç¬¦ä¸²ï¼ŒèŽ·å–åŒ¹é…ç»“æžœï¼Œç”Ÿæˆ placeholders è¯å…¸
                const matches = pattern_regx.exec(this);
                if (!matches)
                    return {};
                return Object.fromEntries(Object.entries($placeholders)
                    .map(([name, $i]) => [name, matches[$i] || '']));
            },
            /** æŸ¥æ‰¾å­ä¸²æˆ–å­—ç¬¦å‡ºçŽ°çš„æ¬¡æ•° */
            count(search) {
                if (!search)
                    throw new Error('count çš„ search ä¸èƒ½ä¸ºç©º');
                let count = 0;
                for (let i = 0; (i = this.indexOf(search, i)) !== -1; i += search.length)
                    count++;
                return count;
            },
            quote(type = 'single') {
                if (type === 'psh')
                    return `& ${this.quote()}`;
                return this.surround(quotes[type]);
            },
            quote_if_space(type = 'single') {
                return this.includes(' ') ? this.quote(type) : this;
            },
            bracket(shape = 'round') {
                return this.surround(...brackets[shape]);
            },
            surround(left, right) {
                return left + this + (right || left);
            },
            surround_tag(tag_name) {
                return '<' + tag_name + '>' + this + '</' + tag_name + '>';
            },
            to_lf() {
                return this.replace(/\r\n/g, '\n');
            },
            rm(pattern, flags = 'g') {
                if (typeof pattern === 'string')
                    pattern = new RegExp(pattern, flags);
                return this.replace(pattern, '');
            },
            split_lines(delimiter = /\r?\n/) {
                let lines = this.split(delimiter);
                if (lines.at(-1) === '')
                    lines.pop();
                return lines;
            },
            split_indent() {
                let i = 0;
                let indent = 0;
                for (; i < this.length; i++)
                    if (this[i] === ' ')
                        indent++;
                    else if (this[i] === '\t')
                        indent += 4;
                    else
                        break;
                return {
                    indent,
                    text: this.slice(i)
                };
            },
            split2(splitter, { last = false, optional = false } = {}) {
                const isplitter = last ? this.lastIndexOf(splitter) : this.indexOf(splitter);
                if (isplitter === -1)
                    if (optional)
                        return [this];
                    else
                        throw new Error(`å­—ç¬¦ä¸²: ${this} å¿…é¡»åŒ…å« splitter: ${splitter}`);
                return [this.slice(0, isplitter), this.slice(isplitter + splitter.length)];
            },
            trim_doc_comment() {
                return `/** ${this.slice(3, -2).replace(/\s*\*\s*/g, '  ').replace(/@(param|params|return) \{.*?\}\s*/g, '').trim()} */`;
            },
            to_base64() {
                return Buffer.from(this).toString('base64');
            },
            decode_base64(buffer = false) {
                const buf = Buffer.from(this, 'base64');
                if (buffer)
                    return buf;
                return buf.toString();
            },
            strip_ansi() {
                return (0,strip_ansi__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            },
            strip_start(prefix, validate) {
                if (validate && !this.startsWith(prefix))
                    throw new Error(`å­—ç¬¦ä¸²æ²¡æœ‰ä»¥å‰ç¼€ ${prefix} å¼€å¤´: ${this}`);
                return this.slice(prefix.length);
            },
            strip_if_start(prefix) {
                return this.startsWith(prefix) ? this.slice(prefix.length) : this;
            },
            strip_end(suffix, validate) {
                if (validate && !this.endsWith(suffix))
                    throw new Error(`å­—ç¬¦ä¸²æ²¡æœ‰ä»¥åŽç¼€ ${suffix} ç»“å°¾: ${this}`);
                return this.slice(0, -suffix.length);
            },
            strip_if_end(suffix) {
                return this.endsWith(suffix) ? this.slice(0, -suffix.length) : this;
            },
            ensure_start(prefix) {
                return this.startsWith(prefix) ? this : prefix + this;
            },
            ensure_end(suffix = '\n') {
                return this.endsWith(suffix) ? this : this + suffix;
            },
            slice_from(search, { include = false, last = false, optional = false } = {}) {
                const i = last ? this.lastIndexOf(search) : this.indexOf(search);
                if (i === -1)
                    if (optional)
                        return this;
                    else
                        throw new Error(`slice_from åœ¨å­—ç¬¦ä¸² ${this} ä¸­æ‰¾ä¸åˆ° search: ${search}`);
                else
                    return this.slice(include ? i : i + search.length);
            },
            slice_to(search, { include = false, last = false, optional = false } = {}) {
                const i = last ? this.lastIndexOf(search) : this.indexOf(search);
                if (i === -1)
                    if (optional)
                        return this;
                    else
                        throw new Error(`slice_to åœ¨å­—ç¬¦ä¸² ${this} ä¸­æ‰¾ä¸åˆ° search: ${search}`);
                else
                    return this.slice(0, include ? i + search.length : i);
            },
            space() {
                if (!this)
                    return this;
                let text_;
                text_ = this
                    .replace(new RegExp(cjk + '([\'"])', 'g'), '$1 $2')
                    .replace(new RegExp('([\'"])' + cjk, 'g'), '$1 $2')
                    .replace(/(["']+)\s*(.+?)\s*(["']+)/g, '$1$2$3')
                    .replace(new RegExp(cjk + '([\\+\\-\\*\\/=&\\\\\\|<>])([A-Za-z0-9])', 'g'), '$1 $2 $3')
                    .replace(new RegExp('([A-Za-z0-9])([\\+\\-\\*\\/=&\\\\\\|<>])' + cjk, 'g'), '$1 $2 $3');
                const text_bak = text_;
                text_ = text_.replace(new RegExp(cjk + '([\\(\\[\\{<\u201c]+(.*?)[\\)\\]\\}>\u201d]+)' + cjk, 'g'), '$1 $2 $4');
                if (text_ === text_bak)
                    text_ = text_
                        .replace(new RegExp(cjk + '([\\(\\[\\{<\u201c>])', 'g'), '$1 $2')
                        .replace(new RegExp('([\\)\\]\\}>\u201d<])' + cjk, 'g'), '$1 $2');
                return text_
                    .replace(/([\(\[\{<\u201c]+)(\s*)(.+?)(\s*)([\)\]\}>\u201d]+)/g, '$1$3$5')
                    .replace(new RegExp(cjk + '([~!;:,\\.\\?\u2026])([A-Za-z0-9])', 'g'), '$1$2 $3')
                    .replace(new RegExp(cjk + '([A-Za-z0-9`\\$%\\^&\\*\\-=\\+\\\\\\|\\/@\u00a1-\u00ff\u2022\u2027\u2150-\u218f])', 'g'), '$1 $2')
                    .replace(new RegExp('([A-Za-z0-9`\\$%\\^&\\*\\-=\\+\\\\\\|\\/@\u00a1-\u00ff\u2022\u2027\u2150-\u218f])' + cjk, 'g'), '$1 $2');
            },
            to_backslash() {
                return this.replaceAll('/', '\\');
            }
        }),
        // ------------ colors
        ...Object.fromEntries([
            'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'grey',
            'red_', 'green_', 'yellow_', 'blue_', 'magenta_', 'cyan_',
            'underline',
        ].map(color => {
            const style = color.endsWith('_') ? `${color.slice(0, -1)}Bright` : color;
            return [color, {
                    configurable: true,
                    get() {
                        // @ts-ignore
                        return util__WEBPACK_IMPORTED_MODULE_0__.styleText(style, this, { validateStream: false });
                    }
                }];
        })),
        // ------------ æ–‡ä»¶è·¯å¾„æ“ä½œ
        ...to_getter_property_descriptors({
            isdir() {
                return this.endsWith('/');
            },
            fp() {
                if (!this)
                    return this;
                const fp = this.replaceAll('\\', '/');
                // è½¬æ¢å°å†™ç›˜ç¬¦å¼€å¤´çš„è·¯å¾„
                return fp[1] === ':' && 'a' <= fp[0] && fp[0] <= 'z'
                    ? fp[0].toUpperCase() + fp.slice(1)
                    : fp;
            },
            fpd() {
                const { fp } = this;
                return fp.endsWith('/') ? fp : `${fp}/`;
            },
            fdir() {
                return this.fp.strip_end(this.fname);
            },
            fname() {
                const { fp } = this;
                const ilast = fp.lastIndexOf('/');
                if (ilast === -1)
                    return fp; // æ²¡æœ‰æ–œæ æ—¶è¿”å›žæ•´ä¸ªå­—ç¬¦ä¸²
                // ä»¥æ–œæ ç»“å°¾çš„æƒ…å†µ
                if (ilast === fp.length - 1) {
                    const iprev = fp.lastIndexOf('/', ilast - 1);
                    return iprev === -1
                        ? fp // åªæœ‰ä¸€ä¸ªæ–œæ ä¸”åœ¨æœ«å°¾
                        : fp.slice(iprev + 1);
                }
                // è¿”å›žæœ€åŽä¸€ä¸ªæ–œæ åŽçš„å†…å®¹
                return fp.slice(ilast + 1);
            },
            fext() {
                const { fname } = this;
                const index = fname.lastIndexOf('.');
                return index <= 0
                    ? ''
                    : fname.slice(index + 1);
            }
        })
    });
    // ------------------------------------ Date.prototype
    Object.defineProperties(Date.prototype, to_method_property_descriptors({
        to_str(ms) {
            return `${this.to_date_str()} ${this.to_time_str(ms)}`;
        },
        to_date_str() {
            // 2024.01.01
            return this.getFullYear() + '.' +
                String(this.getMonth() + 1).padStart(2, '0') + '.' +
                String(this.getDate()).padStart(2, '0');
        },
        to_time_str(ms) {
            // æ—©ä¸Š 09:00:00
            const [ampm, hour] = get_twelve_hour_clock(this);
            return `${ampm} ${get_time_str(this, hour, ms, ':')}`;
        },
        to_dot_time_str(ms) {
            // 17.03.02
            return get_time_str(this, this.getHours(), ms, '.');
        },
        to_dot_str(ms) {
            return `${this.to_date_str()} ${this.to_dot_time_str(ms)}`;
        },
        to_formal_time_str(ms) {
            // 17:03:02
            return get_time_str(this, this.getHours(), ms, ':');
        },
        to_formal_str(ms) {
            return `${this.to_date_str()} ${this.to_formal_time_str(ms)}`;
        }
    }));
    function get_twelve_hour_clock(date) {
        let hour = date.getHours();
        if (hour <= 6)
            return [(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('å‡Œæ™¨'), hour];
        if (hour <= 8)
            return [(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('æ¸…æ™¨'), hour];
        if (hour <= 9)
            return [(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('æ—©ä¸Š'), hour];
        if (hour <= 10)
            return [(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('ä¸Šåˆ'), hour];
        if (hour <= 12)
            return [(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('ä¸­åˆ'), hour];
        hour -= 12;
        if (hour <= 5)
            return [(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('ä¸‹åˆ'), hour];
        if (hour <= 10)
            return [(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('æ™šä¸Š'), hour];
        return [(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('æ·±å¤œ'), hour];
    }
    function get_time_str(date, hour, ms, splitter) {
        return String(hour).padStart(2, '0') + splitter +
            String(date.getMinutes()).padStart(2, '0') + splitter +
            String(date.getSeconds()).padStart(2, '0') +
            (ms
                ? '.' + String(date.getMilliseconds()).padStart(3, '0')
                : '');
    }
    // ------------------------------------ Number.prototype
    Object.defineProperties(Number.prototype, to_method_property_descriptors({
        to_fsize_str() {
            return byte_size(this);
        },
        to_bin_str() {
            return `0b${this.toString(2)}`;
        },
        to_hex_str(length) {
            const s = Math.abs(this).toString(16);
            // é•¿åº¦è‡ªåŠ¨å¯¹é½åˆ° 4 çš„å€æ•°
            if (length === undefined)
                length = Math.ceil(s.length / 4) * 4;
            return `${this < 0 ? '-' : ''}0x${'0'.repeat(length - s.length)}${s}`;
        },
        to_oct_str() {
            return `0o${this.toString(8)}`;
        },
    }));
    // ------------------------------------ Array.prototype
    Object.defineProperties(Array.prototype, {
        ...to_getter_property_descriptors({
            last() {
                return this.at(-1);
            }
        }),
        // --- æ–‡æœ¬å¤„ç†å·¥å…·æ–¹æ³•
        ...to_method_property_descriptors({
            log(limit = 10000) {
                const text = this.join('\n') + '\n';
                if (limit === -1 || this.length <= limit)
                    console.log(text);
                else if (limit > 0)
                    console.log(text.slice(0, limit) + '\n...'.blue);
                else
                    console.log('...\n'.blue + text.slice(limit));
            },
            trim_lines({ trim_line = true, rm_empty_lines = true, rm_last_empty_lines = false } = {}) {
                if (!this.length)
                    return this;
                let lines = this;
                if (trim_line)
                    lines = lines.map(line => line.trim());
                if (rm_empty_lines)
                    return lines.filter(Boolean);
                if (rm_last_empty_lines) {
                    lines.reverse();
                    const i_not_empty = lines.findIndex(Boolean);
                    if (i_not_empty !== -1)
                        lines = lines.slice(i_not_empty);
                    lines.reverse();
                    return lines;
                }
                return lines;
            },
            trim_license() {
                const i = this.indexOf('/*');
                const j = this.indexOf('*/');
                if (i === 0 && this[i + 1].includes('License'))
                    return this.slice(j + 1);
                else
                    return this;
            },
            split_indents() {
                return this.map(line => line.split_indent());
            },
            indent(width = 4, character = ' ') {
                const indent = character.repeat(width);
                return this.map(line => indent + line);
            },
            indent2to4() {
                return this.split_indents()
                    .map(line => ' '.repeat(line.indent * 2) + line.text);
            },
            sum(mapper) {
                if (!this.length)
                    return undefined;
                // å¿«æ·è·¯å¾„
                const first = this[0];
                if ((typeof first === 'number' || typeof first === 'bigint') && !mapper)
                    return this.reduce((acc, x) => acc + x, first);
                if (is_key_type(mapper))
                    mapper = build_mapper(mapper);
                mapper ??= ident;
                return this.reduce((acc, x) => acc + mapper(x), mapper(first));
            },
            max(mapper = ident) {
                if (!this.length)
                    return undefined;
                if (is_key_type(mapper))
                    mapper = build_mapper(mapper);
                let max = mapper(this[0]);
                let imax = 0;
                for (let i = 0; i < this.length; i++) {
                    const value = mapper(this[i]);
                    if (value > max) {
                        max = value;
                        imax = i;
                    }
                }
                return this[imax];
            },
            min(mapper = ident) {
                if (!this.length)
                    return undefined;
                if (is_key_type(mapper))
                    mapper = build_mapper(mapper);
                let min = mapper(this[0]);
                let imin = 0;
                for (let i = 0; i < this.length; i++) {
                    const value = mapper(this[i]);
                    if (value < min) {
                        min = value;
                        imin = i;
                    }
                }
                return this[imin];
            },
            unique(mapper) {
                if (!mapper)
                    return [...new Set(this)];
                if (is_key_type(mapper))
                    mapper = build_mapper(mapper);
                let map = new Map();
                for (const x of this)
                    map.set(mapper(x), x);
                return [...map.values()];
            },
            join_lines(append = true) {
                return `${this.join('\n')}${append ? '\n' : ''}`;
            }
        })
    });
    Object.defineProperties(BigInt.prototype, to_method_property_descriptors({
        to_fsize_str() {
            return byte_size(this);
        },
        toJSON() {
            return this.toString();
        }
    }));
    Object.defineProperties(Error.prototype, to_method_property_descriptors({
        toJSON() {
            return Object.fromEntries(Object.getOwnPropertyNames(this)
                .map(name => [name, this[name]]));
        }
    }));
    Object.defineProperties(Set.prototype, to_method_property_descriptors({
        map(mapfn) {
            return Array.from(this, mapfn);
        }
    }));
    Object.defineProperties(Uint8Array.prototype, to_getter_property_descriptors({
        dataview() {
            return new DataView(this.buffer, this.byteOffset, this.byteLength);
        }
    }));
}
function to_json(obj, replacer) {
    return JSON.stringify(obj, replacer, 4) + '\n';
}
function to_json_safely(obj, replacer) {
    return to_json(obj, replacer)
        .replace(/\u2028/g, '\\u2028')
        .replace(/\u2029/g, '\\u2029')
        .replace(/<\/script>/g, '<\\/script>');
}
function is_codepoint_fullwidth(codepoint) {
    // code points are derived from:
    // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
    return (!Number.isNaN(codepoint) &&
        codepoint >= 0x1100 &&
        (codepoint <= 0x115f || // hangul jamo
            codepoint === 0x201c || codepoint === 0x201d || // 
            codepoint === 0x2026 || // â€¦
            codepoint === 0x203b || // â€»
            // arrows
            (0x2190 <= codepoint && codepoint <= 0x21FF) ||
            codepoint === 0x2329 || // left-pointing angle bracket
            codepoint === 0x232a || // right-pointing angle bracket
            // â‘ 
            (0x2460 <= codepoint && codepoint <= 0x24ff) ||
            // box drawing
            (0x2500 <= codepoint && codepoint <= 0x257f) ||
            // shapes, symbols, â€¦
            (0x2580 <= codepoint && codepoint <= 0x2bef) ||
            // cjk radicals supplement .. enclosed cjk letters and months
            (0x2e80 <= codepoint && codepoint <= 0x3247 && codepoint !== 0x303f) ||
            // enclosed cjk letters and months .. cjk unified ideographs extension a
            (0x3250 <= codepoint && codepoint <= 0x4dbf) ||
            // cjk unified ideographs .. yi radicals
            (0x4E00 <= codepoint && codepoint <= 0xA4C6) ||
            // hangul jamo extended-a
            (0xa960 <= codepoint && codepoint <= 0xa97c) ||
            // hangul syllables
            (0xac00 <= codepoint && codepoint <= 0xd7a3) ||
            // cjk compatibility ideographs
            (0xf900 <= codepoint && codepoint <= 0xfaff) ||
            // vertical forms
            (0xfe10 <= codepoint && codepoint <= 0xfe19) ||
            // cjk compatibility forms .. small form variants
            (0xfe30 <= codepoint && codepoint <= 0xfe6b) ||
            // halfwidth and fullwidth forms
            (0xff01 <= codepoint && codepoint <= 0xff60) ||
            (0xffe0 <= codepoint && codepoint <= 0xffe6) ||
            // kana supplement
            (0x1b000 <= codepoint && codepoint <= 0x1b001) ||
            // enclosed ideographic supplement
            (0x1f200 <= codepoint && codepoint <= 0x1f251) ||
            // cjk unified ideographs extension b .. tertiary ideographic plane
            (0x20000 <= codepoint && codepoint <= 0x3fffd)));
}
const units = ['b', 'kb', 'mb', 'gb', 'tb', 'pb', 'eb', 'zb', 'yb'];
const bytes_table = units.map((unit, i) => ({
    start: i === 0 ? 0 : 2 ** (i * 10),
    end: 2 ** ((i + 1) * 10),
    unit
}));
function byte_size(bytes) {
    bytes = Number(bytes);
    const sign = bytes < 0 ? '-' : '';
    bytes = Math.abs(bytes);
    const { unit, start } = bytes_table.find(range => bytes >= range.start && bytes < range.end);
    return `${sign}${start === 0 ? bytes : (bytes / start).toFixed()} ${unit}`;
}
//# sourceMappingURL=prototype.js.map

/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/utils.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/utils.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DecoderStream: () => (/* binding */ DecoderStream),
/* harmony export */   Lock: () => (/* binding */ Lock),
/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   WritableMemoryStream: () => (/* binding */ WritableMemoryStream),
/* harmony export */   assert: () => (/* binding */ assert),
/* harmony export */   ceil2: () => (/* binding */ ceil2),
/* harmony export */   check: () => (/* binding */ check),
/* harmony export */   colored: () => (/* binding */ colored),
/* harmony export */   concat: () => (/* binding */ concat),
/* harmony export */   consume_stream: () => (/* binding */ consume_stream),
/* harmony export */   date_format: () => (/* binding */ date_format),
/* harmony export */   datetime_format: () => (/* binding */ datetime_format),
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   defer: () => (/* binding */ defer),
/* harmony export */   delay: () => (/* binding */ delay),
/* harmony export */   delta2str: () => (/* binding */ delta2str),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   encode_into: () => (/* binding */ encode_into),
/* harmony export */   escape_line_feed: () => (/* binding */ escape_line_feed),
/* harmony export */   filter_keys: () => (/* binding */ filter_keys),
/* harmony export */   filter_values: () => (/* binding */ filter_values),
/* harmony export */   fuzzyfilter: () => (/* binding */ fuzzyfilter),
/* harmony export */   genid: () => (/* binding */ genid),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   global_get: () => (/* binding */ global_get),
/* harmony export */   grep: () => (/* binding */ grep),
/* harmony export */   has_chinese: () => (/* binding */ has_chinese),
/* harmony export */   inspect: () => (/* binding */ inspect),
/* harmony export */   invoke: () => (/* binding */ invoke),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   log_line: () => (/* binding */ log_line),
/* harmony export */   lowercase_first_letter: () => (/* binding */ lowercase_first_letter),
/* harmony export */   map_keys: () => (/* binding */ map_keys),
/* harmony export */   map_stream: () => (/* binding */ map_stream),
/* harmony export */   map_values: () => (/* binding */ map_values),
/* harmony export */   omit: () => (/* binding */ omit),
/* harmony export */   output_width: () => (/* binding */ output_width),
/* harmony export */   pipe_with_error: () => (/* binding */ pipe_with_error),
/* harmony export */   range_to_numbers: () => (/* binding */ range_to_numbers),
/* harmony export */   seq: () => (/* binding */ seq),
/* harmony export */   set_inspect_options: () => (/* binding */ set_inspect_options),
/* harmony export */   sort_keys: () => (/* binding */ sort_keys),
/* harmony export */   strcmp: () => (/* binding */ strcmp),
/* harmony export */   stream_to_lines: () => (/* binding */ stream_to_lines),
/* harmony export */   time_format: () => (/* binding */ time_format),
/* harmony export */   timeout: () => (/* binding */ timeout),
/* harmony export */   typed_array_to_buffer: () => (/* binding */ typed_array_to_buffer),
/* harmony export */   unique: () => (/* binding */ unique),
/* harmony export */   url_width: () => (/* binding */ url_width),
/* harmony export */   vercmp: () => (/* binding */ vercmp),
/* harmony export */   zip_object: () => (/* binding */ zip_object)
/* harmony export */ });
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var timers_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! timers/promises */ "timers/promises");
/* harmony import */ var _i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./i18n/instance.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/instance.js");
/* harmony import */ var _prototype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./prototype.js */ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/prototype.js");





/** `180` è¾“å‡ºå­—ç¬¦å®½åº¦ */
const output_width = 180;
const url_width = 52;
function set_inspect_options(colors = true) {
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.defaultOptions.maxArrayLength = 40;
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.defaultOptions.maxStringLength = 10000;
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.defaultOptions.breakLength = output_width;
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.defaultOptions.colors = colors;
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.defaultOptions.compact = false;
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.defaultOptions.getters = true;
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.defaultOptions.depth = 2;
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.defaultOptions.sorted = false;
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.defaultOptions.showProxy = true;
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.styles.number = 'green';
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.styles.string = 'cyan';
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.styles.boolean = 'blue';
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.styles.date = 'magenta';
    util__WEBPACK_IMPORTED_MODULE_1__.inspect.styles.special = 'white';
}
function assert(assertion, message) {
    if (!assertion) {
        debugger;
        throw new Error(`${(0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('æ–­è¨€å¤±è´¥')}: ${message ? `${message}: ` : ''}`);
    }
    return assertion;
}
/** åšå‚æ•°æ ¡éªŒï¼Œé€»è¾‘æ£€æŸ¥ */
function check(condition, message) {
    if (!condition) {
        debugger;
        throw new Error(message || (0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('æ£€æŸ¥å¤±è´¥'));
    }
    return condition;
}
function log(...args) {
    if (args.length === 2) {
        const [label, obj] = args;
        console.log(label, obj);
        return obj;
    }
    else {
        const obj = args[0];
        console.log(obj);
        return obj;
    }
}
/** æ•°ç»„æˆ– iterable åŽ»é‡ï¼ˆå¯æŒ‰ mapper é€‰æ‹©æˆ–è®¡ç®—æŸä¸ªå€¼æ¥åŽ»é‡ï¼‰ï¼Œé‡å¤å€¼ä¿ç•™æœ€åŽå‡ºçŽ°çš„é‚£ä¸ª
    - mapper?: å¯ä»¥æ˜¯ key (string, number, symbol) æˆ– (obj: any) => any */
function unique(iterable, mapper) {
    if (!mapper)
        return [...new Set(iterable)];
    if ((0,_prototype_js__WEBPACK_IMPORTED_MODULE_4__.is_key_type)(mapper))
        mapper = (0,_prototype_js__WEBPACK_IMPORTED_MODULE_4__.build_mapper)(mapper);
    let map = new Map();
    for (const x of iterable)
        map.set(mapper(x), x);
    return [...map.values()];
}
/** ç”Ÿæˆ 0, 1, ..., n - 1 (ä¸åŒ…æ‹¬ n) çš„æ•°ç»„ï¼Œæ”¯æŒä¼ å…¥ generator å‡½æ•°ï¼Œé€šè¿‡ index ç”Ÿæˆå„ä¸ªå…ƒç´ 
    @example seq(10, i => `item-${i}`) */
function seq(n, generator) {
    let a = new Array(n);
    for (let i = 0; i < n; i++)
        a[i] = generator ? generator(i) : i;
    return a;
}
/** æŽ’åºå¯¹è±¡ä¸­ keys çš„é¡ºåºï¼Œè¿”å›žæ–°çš„å¯¹è±¡ */
function sort_keys(obj) {
    return Object.fromEntries(Object.entries(obj)
        .sort(([key_l], [key_r]) => strcmp(key_l, key_r)));
}
/** å°† keys, values æ•°ç»„æŒ‰å¯¹åº”çš„é¡ºåºç»„åˆæˆä¸€ä¸ªå¯¹è±¡ */
function zip_object(keys, values) {
    return keys.reduce((obj, key, i) => {
        obj[key] = values[i];
        return obj;
    }, {});
}
/** æ˜ å°„å¯¹è±¡ä¸­çš„ keys, è¿”å›žæ–°å¯¹è±¡ */
function map_keys(obj, mapper) {
    return Object.fromEntries(Object.entries(obj)
        .map(([key, value]) => [mapper(key), value]));
}
/** æ˜ å°„å¯¹è±¡ä¸­çš„ values, è¿”å›žæ–°å¯¹è±¡ */
function map_values(obj, mapper) {
    return Object.fromEntries(Object.entries(obj)
        .map(([key, value]) => [key, mapper(value, key)]));
}
/** è¿‡æ»¤å¯¹è±¡ä¸­çš„ keys, è¿”å›žæ–°å¯¹è±¡ */
function filter_keys(obj, filter) {
    return Object.fromEntries(Object.entries(obj)
        .filter(([key]) => filter(key)));
}
/** è¿‡æ»¤å¯¹è±¡ä¸­çš„ values, è¿”å›žæ–°å¯¹è±¡
    - obj
    - filter?: `not_empty` */
function filter_values(obj, filter = _prototype_js__WEBPACK_IMPORTED_MODULE_4__.not_empty) {
    return Object.fromEntries(Object.entries(obj)
        .filter(([, value]) => filter(value)));
}
/** å¿½ç•¥å¯¹è±¡ä¸­çš„ keys, è¿”å›žæ–°å¯¹è±¡ */
function omit(obj, omit_keys) {
    const omit_keys_ = new Set(omit_keys);
    return filter_keys(obj, key => !omit_keys_.has(key));
}
/** å­—ç¬¦ä¸²å­—å…¸åºæ¯”è¾ƒ */
function strcmp(l, r) {
    if (l === r)
        return 0;
    if (l < r)
        return -1;
    return 1;
}
/** æ¯”è¾ƒ 1.10.02 è¿™ç§ç‰ˆæœ¬å·
    - l, r: ä¸¤ä¸ªç‰ˆæœ¬å·å­—ç¬¦ä¸²
    - loose?: å®½æ¾æ¨¡å¼ï¼Œå…è®¸ä¸¤ä¸ªç‰ˆæœ¬å·æ ¼å¼ï¼ˆä½æ•°ï¼‰ä¸ä¸€è‡´ */
function vercmp(l, r, loose = false) {
    const lparts = l.split('.').map(x => Number(x));
    const rparts = r.split('.').map(x => Number(x));
    if (!loose && lparts.length !== rparts.length)
        throw new Error('ä¼ å…¥ vercmp çš„ä¸¤ä¸ªç‰ˆæœ¬å·æ ¼å¼ä¸ä¸€è‡´');
    let minlen = Math.min(lparts.length, rparts.length);
    for (let i = 0; i < minlen; i++) {
        const l = lparts[i];
        const r = rparts[i];
        assert(!isNaN(l) && !isNaN(r), 'ä¼ å…¥ vercmp çš„ç‰ˆæœ¬éžæ³•');
        if (l !== r)
            return l - r;
    }
    // loose ä¸‹æŒ‰çŸ­çš„ä¼˜å…ˆï¼Œå¦åˆ™åº”è¯¥ä¸€æ ·ï¼Œä¸º 0
    return lparts.length - rparts.length;
}
/** è¿‡æ»¤ç¬¦åˆ pattern çš„è¡Œ */
function grep(str, pattern) {
    return str.split_lines()
        .filter(typeof pattern === 'string'
        ? line => line.includes(pattern)
        : line => pattern.test(line))
        .join_lines();
}
/** æ¨¡ç³Šè¿‡æ»¤å­—ç¬¦ä¸²åˆ—è¡¨æˆ–å¯¹è±¡åˆ—è¡¨ï¼Œå¸¸ç”¨äºŽæ ¹æ®ç”¨æˆ·è¾“å…¥è¡¥å…¨æˆ–æœç´¢è¿‡æ»¤
    å¦‚æžœæœ‰å®Œå…¨åŒ¹é…çš„ï¼Œåªè¿”å›žé‚£ä¸€é¡¹çš„æ•°ç»„
    - query: æŸ¥è¯¢å­—ç¬¦ä¸²ï¼Œè¦æ±‚ä¸ºå…¨å°å†™
    - list: è¦è¿‡æ»¤çš„åˆ—è¡¨
    - list_lower?: è¦è¿‡æ»¤çš„åˆ—è¡¨å¯¹åº”çš„å…¨å°å†™å­—ç¬¦ä¸²åˆ—è¡¨å½¢å¼ï¼Œä¼ å…¥æ—¶å¯å¤ç”¨ç¼“å­˜ï¼ŒåŠ å¿«æœç´¢é€Ÿåº¦ */
function fuzzyfilter(query, list, mapper = _prototype_js__WEBPACK_IMPORTED_MODULE_4__.ident, list_lower, single_char_startswith = false) {
    if (!query)
        return list;
    if ((0,_prototype_js__WEBPACK_IMPORTED_MODULE_4__.is_key_type)(mapper))
        mapper = (0,_prototype_js__WEBPACK_IMPORTED_MODULE_4__.build_mapper)(mapper);
    mapper ??= _prototype_js__WEBPACK_IMPORTED_MODULE_4__.ident;
    list_lower ??= list.map(item => mapper(item).toLowerCase());
    const query_lower = query.toLowerCase();
    let ifullmatch;
    if ((ifullmatch = list_lower.indexOf(query_lower)) !== -1)
        return [list[ifullmatch]];
    if (single_char_startswith && query.length === 1) {
        const c = query[0];
        return list.filter((_, i) => list_lower[i].startsWith(c));
    }
    return list.filter((_, i) => {
        const str_lower = list_lower[i];
        let j = 0;
        for (const c of query_lower) {
            j = str_lower.indexOf(c, j) + 1;
            if (!j) // æ‰¾ä¸åˆ°åˆ™ j === 0
                return false;
        }
        return true;
    });
}
function get(obj, keypath) {
    let obj_ = obj;
    for (const key of keypath.split('.'))
        obj_ = obj_[key];
    return obj_;
}
function global_get(keypath) {
    return get(globalThis, keypath);
}
function invoke(obj, funcpath, args) {
    const paths = funcpath.split('.');
    let obj_ = obj;
    for (let i = 0; i < paths.length - 1; i++)
        obj_ = obj_[paths[i]];
    return obj_[paths.at(-1)].call(obj_, ...args);
}
/** æ‹¼æŽ¥ TypedArrays ç”Ÿæˆä¸€ä¸ªå®Œæ•´çš„ Uint8Array */
function concat(arrays) {
    let length = 0;
    for (const a of arrays)
        length += a.byteLength;
    let buf = Buffer.allocUnsafe(length);
    let offset = 0;
    for (const a of arrays) {
        const uint8view = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
        buf.set(uint8view, offset);
        offset += uint8view.byteLength;
    }
    return buf;
}
function typed_array_to_buffer(view) {
    return Buffer.from(view.buffer, view.byteOffset, view.byteLength);
}
/** æ—¶é—´é—´éš” (milliseconds) æ ¼å¼åŒ– */
function delta2str(delta) {
    if (delta < 1)
        return '0 ms';
    // [1, 100) ms
    if (delta < 100)
        return `${delta.toFixed(0)} ms`;
    // [100, 1000) ms
    // 0.8 s
    if (delta <= 950)
        return `${(delta / 1000).toFixed(1)} s`;
    // 3 s
    if (delta < 1000 * 60)
        return `${(delta / 1000).toFixed()} s`;
    // 1 min 12 s [1 min 0s, 60 min)
    const seconds = Math.trunc(delta / 1000);
    if (seconds < 60 * 60)
        return `${Math.trunc(seconds / 60)} min ${seconds % 60} s`;
    const hour = Math.trunc(seconds / 3600);
    return `${hour} h ${Math.trunc((seconds - 3600 * hour) / 60)} min ${seconds % 60} s`;
}
/** generate random id */
function genid() {
    return Math.random() * 2 ** 53;
}
/** é»˜è®¤æ—¥æœŸæ—¶é—´æ ¼å¼ */
const datetime_format = 'YYYY.MM.DD HH:mm:ss';
/** é»˜è®¤æ—¥æœŸæ ¼å¼ */
const date_format = 'YYYY.MM.DD';
/** é»˜è®¤æ—¶é—´æ ¼å¼ */
const time_format = 'HH:mm:ss';
class Timer {
    started = new Date().getTime();
    ended;
    /** åœæ­¢ç§’è¡¨ï¼Œä¿å­˜è¯»æ•° */
    stop() {
        this.ended = new Date().getTime();
    }
    /** å¦‚æžœç§’è¡¨æœªåœæ­¢ï¼ŒèŽ·å–å½“å‰ç§’è¡¨è¯»æ•°ï¼›
        å¦‚æžœç§’è¡¨å·²åœæ­¢ï¼ŒèŽ·å–åœæ­¢æ—¶çš„ç§’è¡¨è¯»æ•°; */
    get() {
        return (this.ended || new Date().getTime()) - this.started;
    }
    /** èŽ·å–æ—¶é—´è¡¨ç¤ºå­—ç¬¦ä¸²ï¼Œå¦‚ 1.2 s
        - parenthesis?: `true` å­—ç¬¦ä¸²å‰åŽåŠ ä¸Šæ‹¬å·ï¼Œå¦‚ (1.2 s) */
    getstr(parenthesis = false) {
        let s = delta2str(this.get());
        if (parenthesis)
            return s.bracket();
        else
            return s;
    }
    print() {
        console.log(this.getstr(true));
    }
    /** é‡ç½® started */
    reset() {
        this.started = new Date().getTime();
        this.ended = null;
    }
    get_and_reset() {
        const result = this.get();
        this.reset();
        return result;
    }
    getstr_and_reset(parenthesis) {
        const result = this.getstr(parenthesis);
        this.reset();
        return result;
    }
}
function log_line() {
    console.log('---');
}
async function delay(milliseconds, options) {
    return timers_promises__WEBPACK_IMPORTED_MODULE_2__.setTimeout(milliseconds, undefined, options);
}
class TimeoutError extends Error {
    name = 'TimeoutError';
}
/** åœ¨æŒ‡å®šçš„æ—¶é—´ (milliseconds) å†…è¿è¡ŒæŸä¸ªä»»åŠ¡ï¼Œè¶…æ—¶ä¹‹åŽæŠ›å‡ºé”™è¯¯æˆ–è°ƒç”¨ on_timeout
    - milliseconds: é™æ—¶æ¯«ç§’æ•°
    - action?: è¦ç­‰å¾…è¿è¡Œçš„ä»»åŠ¡, async function æˆ– promise
    - on_timeout?: è¶…æ—¶åŽè°ƒç”¨çš„å‡½æ•°
        - å¦‚æžœä¼ å…¥äº† on_timeout å‚æ•°: è°ƒç”¨ on_timeoutï¼Œç„¶åŽ timeout å‡½æ•°æ­£å¸¸è¿”å›ž null
        - å¦‚æžœæ²¡ä¼ å…¥ on_timeout å‚æ•°: æŠ›å‡º TimeoutError
    - print?: æ‰“å°å·²è¶…æ—¶ä»»åŠ¡çš„é”™è¯¯ */
async function timeout(milliseconds, action, on_timeout, print = true) {
    const error = new TimeoutError();
    return new Promise((resolve, reject) => {
        let done = false;
        let rejected = false;
        (async () => {
            await delay(milliseconds);
            if (!done)
                if (on_timeout)
                    try {
                        await on_timeout();
                        resolve(null);
                    }
                    catch (error) {
                        if (rejected)
                            throw error; // ä¼šæˆä¸º unhandled rejection
                        else {
                            rejected = true;
                            reject(error);
                        }
                    }
                else {
                    rejected = true;
                    reject(error);
                }
        })();
        (async () => {
            try {
                resolve(await (typeof action === 'function' ? action() : action));
            }
            catch (error) {
                if (rejected) {
                    if (print)
                        console.log(`å·²è¶…æ—¶ä»»åŠ¡çš„é”™è¯¯: ${error.message}`);
                }
                else {
                    rejected = true;
                    reject(error);
                }
            }
            finally {
                done = true;
            }
        })();
    });
}
/** åˆ›å»ºä¸€ä¸ª promiseï¼ŒåŽç»­å¯è°ƒç”¨ promise.resolve, promise.reject æ–¹æ³•è®¾ç½®å…¶çŠ¶æ€å’Œå€¼
    - initial?: `undefined` ä¼ å…¥éž undefined å€¼ï¼ˆåŒ…æ‹¬ nullï¼‰æ—¶ç›´æŽ¥è®¾ç½®ä¸º resolved çŠ¶æ€
    æ³¨: ä¸‹é¢çš„æ–¹æ³•ä¸èƒ½æ ‡è®°ä¸º aysnc function, å¦åˆ™ä¼šå¯¹è¿”å›žå€¼å†åšä¸€å±‚ Promise.resolve() å¯¼è‡´ reject, resolve å±žæ€§ä¸¢å¤± */
// eslint-disable-next-line @typescript-eslint/promise-function-async
function defer(initial) {
    if (initial === undefined) {
        let { promise, resolve, reject } = Promise.withResolvers();
        return Object.assign(promise, { resolve, reject });
    }
    else
        return Object.assign(Promise.resolve(initial), {
            resolve: _prototype_js__WEBPACK_IMPORTED_MODULE_4__.noop,
            reject: _prototype_js__WEBPACK_IMPORTED_MODULE_4__.noop
        });
}
/** @example
    let lock = new Lock(redis)
    
    // é”å®šèµ„æºåŽåœ¨ action å›žè°ƒä¸­æ“ä½œèµ„æºï¼Œå›žè°ƒ promise å®ŒæˆåŽè‡ªåŠ¨é‡Šæ”¾èµ„æºï¼Œ
    // ä¸‰ç§’å†…æœªæˆåŠŸç‹¬å èµ„æºç›´æŽ¥æŠ›å‡º TimeoutError (å¼€å§‹æ‰§è¡ŒåŽä¸å— signal abort å½±å“)
    await lock.request(async (redis) => {
        const value = await redis.get('key')
        await redis.set('key', value * 2)
    }, AbortSignal.timeout(3000))
    
    å‚è€ƒ:
    https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API
    https://github.com/metarhia/web-locks
    https://www.npmjs.com/package/async-lock  */
class Lock {
    /** å¦‚æžœæ“ä½œä¸éœ€è¦ç‹¬å èµ„æºï¼Œå¯ä»¥ç›´æŽ¥é€šè¿‡ lock.resource è®¿é—®ï¼Œå¦åˆ™éœ€è¦é€šè¿‡ await lock.request() ç‹¬å èµ„æºåŽå†è®¿é—® */
    resource;
    /** ç­‰å¾…é“¾ï¼Œæ–°çš„ await lock.request() è°ƒç”¨ä¼šç­‰å¾…å½“å‰ç­‰å¾…é“¾å°¾éƒ¨çš„ promise å®Œæˆï¼Œå¹¶ä½œä¸ºæ–°çš„å°¾éƒ¨ */
    ptail = defer(null);
    /** æŸ¥è¯¢å½“å‰èµ„æºæ˜¯å¦å±žäºŽè¢«é”å®šçš„çŠ¶æ€ï¼Œæ–¹ä¾¿åœ¨èµ„æºé—²ç½®æ—¶åšä¸€äº›å¯é€‰æ“ä½œï¼ˆæ“ä½œå‰ä»éœ€é”å®šï¼‰ï¼Œæˆ–è€…åšä¸€äº›çŠ¶æ€å±•ç¤º */
    locked = false;
    /** å¯ä»¥ä¸ä¼  resourceï¼Œè¡¨ç¤ºç®¡ç†æŸä¸ªæŠ½è±¡æˆ–è™šæ‹Ÿçš„èµ„æº */
    constructor(resource) {
        this.resource = resource;
    }
    /** é€šè¿‡ await lock.request() é”å®šèµ„æºä»¥ä¾¿ç‹¬å è®¿é—®
        æˆåŠŸè¿”å›žä¹‹åŽç”±è°ƒç”¨æ–¹è´Ÿè´£è°ƒç”¨ release æ–¹æ³•é‡Šæ”¾èµ„æº
        åœ¨ signal aborted æ—¶æŠ›å‡ºé”™è¯¯ç»“æŸç­‰å¾…ï¼Œä¸”ç”±å†…éƒ¨å®žçŽ°è‡ªåŠ¨é‡Šæ”¾èµ„æº */
    // async request (action: (resource: TResource) => Promise<void>, signal?: AbortSignal): Promise<void>
    // async request <TResult> (action: <TResult> (resource: TResource) => Promise<TResult>, signal?: AbortSignal): Promise<TResult>
    async request(action, signal) {
        signal?.throwIfAborted();
        const ptail = this.ptail;
        let pcurrent = this.ptail = defer();
        this.locked = true;
        return new Promise((resolve, reject) => {
            // ä¸‹é¢ä¸¤ç§æƒ…å†µï¼Œå…ˆå‘ç”Ÿçš„å†³å®š request è¿”å›žçš„ promise çŠ¶æ€
            // ä¸ç®¡æ˜¯å¦ aborted, éƒ½è¦ç­‰èµ„æºè¢«å‰ä¸€æ¬¡è°ƒç”¨é‡Šæ”¾ï¼Œå…ˆ aborted åªæ˜¯å°†æŽ§åˆ¶æƒäº¤å›žç»™è°ƒç”¨è€…ï¼Œåœ¨é”å®šèµ„æºåŽä¸æ‰§è¡Œ actionï¼Œ ç›´æŽ¥é‡Šæ”¾
            /** é˜²æ­¢æ‰§è¡Œè¿‡ç¨‹ä¸­ signal abort */
            let executing = false;
            signal?.addEventListener('abort', () => {
                if (!executing)
                    // è¿™é‡Œä¸èƒ½é‡Šæ”¾é”ï¼Œéœ€è¦ç­‰ ptail resolve åŽæ‹¿åˆ°èµ„æºå†é‡Šæ”¾
                    reject(signal.reason);
            }, { once: true });
            ptail.then(async () => {
                // è¿™é‡Œå·²ç»èƒ½ä¿è¯ç‹¬å è®¿é—®èµ„æº
                // å¦‚æžœ aborted, å¯ä»¥ç†è§£ä¸ºç‹¬å èµ„æºå¤±è´¥ï¼Œè°ƒç”¨è€…ä¸ä¼šä½¿ç”¨èµ„æºï¼Œç›´æŽ¥é‡Šæ”¾
                if (signal?.aborted)
                    reject(signal.reason);
                else
                    // ç”±è°ƒç”¨è€…åŽ»æ“ä½œèµ„æº
                    try {
                        executing = true;
                        resolve(await action(this.resource));
                    }
                    catch (error) {
                        reject(error);
                    }
                // ä¸‹é¢å¼€å§‹é‡Šæ”¾é”
                // assert(this.locked)
                if (!this.locked)
                    reject(new Error((0,_i18n_instance_js__WEBPACK_IMPORTED_MODULE_3__.t)('å°è¯•é‡Šæ”¾æœªé”å®šçš„é”ï¼Œè¿™ä¸åº”è¯¥å‘ç”Ÿ')));
                this.locked = false;
                pcurrent.resolve();
            });
        });
    }
}
// ------------ text
let encoder = new TextEncoder();
function encode(str) {
    // ç”¨ Buffer.from æ˜¯å› ä¸ºå¯ä»¥åˆ©ç”¨ buffer poolï¼Œé¿å… encoder.encode åˆ›å»ºå¤§é‡å°ä¸”ç‹¬ç«‹çš„ array buffer
    return Buffer.from(str);
}
function encode_into(str, buf) {
    // è¿™ä¸ªæ˜¯ç›´æŽ¥ç”¨ v8 String::WriteUtf8 æœ€é«˜æ•ˆçš„æ–¹æ³•äº†
    return encoder.encodeInto(str, buf);
}
let decoder = new TextDecoder();
/** å°† utf-8 buffer (Uint8Array) ç®€å•çš„è§£ç ä¸º stringã€‚
    åœ¨æµå¼å¤„ç† (buffer å¯èƒ½ä¸å®Œæ•´) æ—¶ï¼Œåº”ä½¿ç”¨ç‹¬ç«‹çš„ TextDecoder å®žä¾‹è°ƒç”¨ decode(buffer, { stream: true }) */
function decode(buffer) {
    return decoder.decode(buffer);
}
function has_chinese(str) {
    return /[\u4E00-\u9FA5]/.test(str);
}
function escape_line_feed(str) {
    return str.replace(/\n/g, '\\n');
}
function lowercase_first_letter(str) {
    return str[0].toLowerCase() + str.slice(1);
}
/** util.inspect(obj)
    - options
        - limit?: `10000`  ä¼  0 æ—¶ä¸é™åˆ¶
        - omit?: string[] */
function inspect(obj, options = {}) {
    if (options.omit) {
        obj = { ...obj };
        for (const key of options.omit)
            delete obj[key];
        // æ”¹å˜äº† obj çš„å¼•ç”¨ï¼ŒåŽ»æŽ‰ inspect.custom é˜²æ­¢æ— é™é€’å½’ inspect
        delete obj[inspect.custom];
    }
    let text = util__WEBPACK_IMPORTED_MODULE_1__.inspect(obj, options);
    const limit = options.limit ?? 10000;
    if (limit && text.length > limit)
        return `${text.slice(0, limit)}â€¦â€¦'\u001b[39m\n`;
    else
        return text;
}
/** æ ¹æ® enabled é€‰é¡¹è¿”å›žæœ‰ / æ— é¢œè‰²çš„å­—ç¬¦ä¸² (str) */
function colored(str, color, enabled = inspect.defaultOptions.colors) {
    return enabled ? str[color] : str;
}
(function (inspect) {
    inspect.custom = util__WEBPACK_IMPORTED_MODULE_1__.inspect.custom;
    inspect.defaultOptions = util__WEBPACK_IMPORTED_MODULE_1__.inspect.defaultOptions;
})(inspect || (inspect = {}));
// ------------------------------------ stream
/** npm map-stream
    filter will reemit the data if cb(err,pass) pass is truthy
    
    reduce is more tricky
    maybe we want to group the reductions or emit progress updates occasionally
    the most basic reduce just emits one 'data' event after it has recieved 'end'
    
    create an event stream and apply function to each .write,
    emitting each response as data unless it's an empty callback
 */
function map_stream(mapper, options) {
    options = options || {};
    let inputs = 0, outputs = 0, ended = false, paused = false, destroyed = false, last_written = 0, in_next = false;
    let stream = Object.assign(new stream__WEBPACK_IMPORTED_MODULE_0__.Stream(), {
        readable: true,
        writable: true,
        write(data) {
            if (ended)
                throw new Error('map stream is not writable');
            in_next = false;
            inputs++;
            try {
                // catch sync errors and handle them like async errors
                const written = wrapped_mapper(data, inputs, next);
                paused = (written === false);
                return !paused;
            }
            catch (err) {
                // if the callback has been called syncronously, and the error has occured in an listener, throw it again.
                if (in_next)
                    throw err;
                next(err);
                return !paused;
            }
        },
        end(data) {
            if (ended)
                return;
            _end(data);
        },
        destroy() {
            ended = destroyed = true;
            stream.writable = stream.readable = paused = false;
            process.nextTick(function () {
                stream.emit('close');
            });
        },
        pause() {
            paused = true;
        },
        resume() {
            paused = false;
        }
    });
    let error_event_name = options.failures ? 'failure' : 'error';
    // Items that are not ready to be written yet (because they would come out of order) get stuck in a queue for later.
    let write_queue = {};
    function queue_data(data, number) {
        let next_to_write = last_written + 1;
        if (number === next_to_write) {
            // If it's next, and its not undefined write it
            if (data !== undefined)
                stream.emit('data', data);
            last_written++;
            next_to_write++;
        }
        else
            // Otherwise queue it for later.
            write_queue[number] = data;
        // If the next value is in the queue, write it
        if (Object.prototype.hasOwnProperty.call(write_queue, next_to_write)) {
            let data_to_write = write_queue[next_to_write];
            delete write_queue[next_to_write];
            return queue_data(data_to_write, next_to_write);
        }
        outputs++;
        if (inputs === outputs) {
            if (paused) {
                paused = false;
                stream.emit('drain'); // written all the incoming events
            }
            if (ended)
                _end();
        }
    }
    function next(err, data, number) {
        if (destroyed)
            return;
        in_next = true;
        if (!err || options.failures)
            queue_data(data, number);
        if (err)
            stream.emit(error_event_name, err);
        in_next = false;
    }
    /** Wrap the mapper function by calling its callback with the order number of the item in the stream. */
    function wrapped_mapper(input, number, callback) {
        return mapper.call(null, input, function (err, data) {
            callback(err, data, number);
        });
    }
    function _end(data) {
        // if end was called with args, write it, 
        ended = true; // write will emit 'end' if ended is true
        stream.writable = false;
        if (data !== undefined)
            return queue_data(data, inputs);
        else if (inputs === outputs) { // wait for processing 
            stream.readable = false;
            stream.emit('end');
            stream.destroy();
        }
    }
    return stream;
}
async function* stream_to_lines(stream) {
    let buf = '';
    for await (const chunk of stream) {
        let j = 0;
        for (let i = 0; (i = chunk.indexOf('\n', j)) >= 0;) {
            let line = chunk.slice(j, i);
            if (buf) {
                line = buf + line;
                buf = '';
            }
            j = i + 1;
            yield line;
        }
        buf = chunk.slice(j);
    }
}
function pipe_with_error(readable, writable) {
    // ä¸çŸ¥é“ transform ä½œä¸º AsyncIterable ä½¿ç”¨æ—¶ï¼Œ emit error æ˜¯å¦ä¼šåœ¨ for await (...) å¾ªçŽ¯ä¸­è§¦å‘é”™è¯¯
    readable.once('error', error => { writable.emit('error', error); });
    return readable.pipe(writable);
}
class WritableMemoryStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Writable {
    chunks = [];
    pbuffer = defer();
    constructor() {
        super({ highWaterMark: 2 ** 30, decodeStrings: false });
    }
    _write(chunk, encoding, callback) {
        this.chunks.push(chunk);
        callback();
    }
    _writev(chunks, callback) {
        for (const { chunk } of chunks)
            this.chunks.push(chunk);
        callback();
    }
    _final(callback) {
        this.pbuffer.resolve(Buffer.concat(this.chunks));
        this.chunks = null;
        callback();
    }
}
/** ç”¨ TextDecoder é€šè¿‡ .pipe æ–¹æ³•æŒç»­çš„è§£ç  process.stdout ç­‰æµï¼Œ
    ä¸»è¦åœ¨ process.ts#start ä¸­ä½¿ç”¨
    https://nodejs.org/api/stream.html#implementing-a-transform-stream */
class DecoderStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform {
    decoder;
    constructor(encoding) {
        super({ encoding: 'utf-8' });
        this.decoder = new TextDecoder(encoding);
    }
    _transform(chunk, encoding, callback) {
        assert(chunk instanceof Uint8Array);
        const str = this.decoder.decode(chunk, { stream: true });
        if (str.length)
            this.push(str, 'utf-8');
        callback();
    }
    _flush(callback) {
        const str = this.decoder.decode();
        if (str.length)
            this.push(str, 'utf-8');
        callback();
    }
}
/** æ¶ˆè´¹ä¸€ä¸ªå¯è¯»æµ */
async function consume_stream(stream, ignore_error = false) {
    try {
        for await (const chunk of stream)
            ;
    }
    catch (error) {
        if (!ignore_error)
            throw error;
    }
}
/** æ ¹æ® range ç”Ÿæˆæ•´æ•°åºåˆ— (iterable)
    - range: å–å€¼ä¸ºé€—å·åˆ†å‰²çš„å¤šä¸ªå¯ç”¨å€¼æˆ–å€¼åŒºé—´ (ä¸èƒ½å«æœ‰ç©ºæ ¼)ï¼Œæ¯”å¦‚ï¼š`8321,8322,8300-8310,11000-11999`
    - reverse?: `false` åœ¨ range å†…ä»ŽåŽå¾€å‰ç”Ÿæˆ */
function* range_to_numbers(range, reverse = false) {
    let parts = range.split(',');
    if (reverse)
        parts.reverse();
    for (const part of parts) {
        const [left, right] = part.split('-').map(n => Number(n));
        if (!right)
            yield left;
        if (reverse)
            for (let i = right; i >= left; i--)
                yield i;
        else
            for (let i = left; i <= right; i++)
                yield i;
    }
}
/** å¤§äºŽ n çš„æœ€å°çš„ 2 çš„å¹‚æ¬¡ */
function ceil2(n) {
    let power = 1;
    for (; power <= n; power <<= 1)
        ;
    return power;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/.pnpm/dolphindb@3.0.213_react-dom@19.0.0_react@19.0.0_/node_modules/dolphindb/i18n/dict.json":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/dolphindb@3.0.213_react-dom@19.0.0_react@19.0.0_/node_modules/dolphindb/i18n/dict.json ***!
  \*******************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"æš‚æ—¶ä¸æ”¯æŒåºåˆ—åŒ–":{"en":"serialization is not currently supported"},"ä¸èƒ½è‡ªåŠ¨è½¬æ¢ {{type}} è‡³ DdbObj":{"en":"cannot automatically convert {{type}} to DdbObj"},"form å¿…é¡»æ˜¯ DdbForm.table, å¦åˆ™ä¸èƒ½ to_rows":{"en":"form must be DdbForm.table, otherwise it cannot to_rows"},"this.form å¿…é¡»æ˜¯ DdbForm.dict, å¦åˆ™ä¸èƒ½è°ƒç”¨ to_dict è½¬æ¢ä¸º js object":{"en":"this.form must be DdbForm.dict, otherwise to_dict cannot be called to convert to js object"},"å½“å‰åªæ”¯æŒè‡ªåŠ¨è½¬æ¢ dict<string, any | ...dictables> ä¸º js object":{"en":"currently api only supports automatic conversion of dict<string, any | ...dictables> to js object"},"deep = true æ—¶å¿…é¡»è®¾ç½® strip = true":{"en":"strip = true must be set when deep = true"},"timestamp å­—ç¬¦ä¸²é•¿åº¦å¿…é¡»ç­‰äºŽæ ¼å¼ä¸²é•¿åº¦":{"en":"the length of the timestamp string must be equal to the length of the format string"},"æ ¼å¼ä¸²å¿…é¡»åŒ…å«ç§’çš„æ ¼å¼ (ss)":{"en":"the format string must contain the format for seconds (ss)"},"æ ¼å¼ä¸²å¿…é¡»åŒ…å«çº³ç§’çš„æ ¼å¼ (SSSSSSSSS)":{"en":"format string must contain nanosecond format (SSSSSSSSS)"},"nanotimestamp å­—ç¬¦ä¸²é•¿åº¦å¿…é¡»ç­‰äºŽæ ¼å¼ä¸²é•¿åº¦":{"en":"nanotimestamp string length must be equal to format string length"},"æŒ‡å®š node æ—¶å¿…é¡»è®¾ç½® func_type":{"en":"func_type must be set when specifying node"},"variable æŒ‡ä»¤å‚æ•°ä¸èƒ½ä¸ºç©ºä¸”å‚æ•°åä¸èƒ½ä¸ºç©ºï¼Œä¸”æ•°é‡åº”è¯¥åŒ¹é…":{"en":"variable command parameter cannot be empty and parameter name cannot be empty, and the number should match"},"session id ä»Ž {{sid}} å˜ä¸º {{sid_}}":{"en":"session id changed from {{sid}} to {{sid_}}"},"è®¢é˜…æµè¡¨æˆåŠŸ:":{"en":"subscribed to streaming table:"},"vector {{type}} æš‚ä¸æ”¯æŒåºåˆ—åŒ–":{"en":"vector {{type}} serialization is not currently supported"},"form å¿…é¡»æ˜¯ DdbForm.table, å¦åˆ™ä¸èƒ½ to_cols":{"en":"form must be DdbForm.table, otherwise it cannot to_cols"},"è¿™æ˜¯åœ¨è°ƒç”¨ this.rpc ä¹‹å‰é»˜è®¤çš„ on_message, ä¸åº”è¯¥è¢«è°ƒç”¨åˆ°ï¼Œé™¤éžå»ºç«‹è¿žæŽ¥åŽ server å…ˆæŽ¨é€äº† message":{"en":"This is the default on_message before calling this.rpc, it should not be called unless the server pushes the message first after the connection is established"}," æš‚æ—¶ä¸æ”¯æŒè§£æž":{"en":" parsing is currently not supported"},"array vector å­˜åœ¨éžæ³• unit: {{unit}}":{"en":"array vector has invalid unit: {{unit}}"}," æš‚æ—¶ä¸æ”¯æŒåºåˆ—åŒ–":{"en":" serialization is currently not supported"},"print æ¶ˆæ¯çš„ buffer åº”è¯¥ä»¥ \\\\0 ç»“æŸ":{"en":"The buffer of the print message should end with \\\\0"},"print æ¶ˆæ¯çš„ buffer ä¸­é—´ä¸åº”è¯¥æœ‰ \\\\0":{"en":"There should not be \\\\0 in the buffer of the print message"},"å·²æ–­å¼€":{"en":"is already disconnected"},"è¿žæŽ¥å‡ºé”™äº†ï¼Œå¯èƒ½ç”±äºŽç½‘ç»œåŽŸå› è¿žæŽ¥å·²è¢«å…³é—­ï¼Œæˆ–æœåŠ¡å™¨æ–­å¼€è¿žæŽ¥":{"en":"connection errored. The connection may have been closed due to network reasons, or the server disconnected"},"new DdbBlob ä¸èƒ½ä¼ ç©ºçš„ value":{"en":"new DdbBlob cannot pass an empty value"},"{{form}}<{{type}}> æš‚æ—¶ä¸æ”¯æŒè§£æž":{"en":"cannot parse {{form}}<{{type}}>"},"æµæ•°æ®è®¢é˜…åŽä¸€å®šå…ˆè¿”å›ž schema":{"en":"After subscribing to streaming data, the schema must be returned first."},"{{form}} {{type}} æš‚ä¸æ”¯æŒ data()":{"en":"{{form}} {{type}} does not support data() yet"}," æš‚æ—¶ä¸æ”¯æŒè½¬æ¢ä¸º js å¯¹è±¡":{"en":" conversion to js object is not supported at the moment"},"{{time}} å¿ƒè·³æ£€æµ‹å¤±è´¥ï¼Œè¿žæŽ¥å·²æ–­å¼€":{"en":"{{time}} heartbeat detection failed, the connection has been disconnected"},"pack æ—¶å­—ç¬¦ä¸²ä¸­é—´ä¸èƒ½å«æœ‰ \\\\0, å¦åˆ™ä¸Šä¼ ç»™ DolphinDB ä¼šå¯¼è‡´è¿žæŽ¥æ–­å¼€":{"en":"The string cannot contain \\\\0 in the middle when packing, otherwise uploading to DolphinDB will cause the connection to be disconnected"},"å‘é€è‡³ DolphinDB æ‰§è¡Œçš„è„šæœ¬ä¸­é—´ä¸èƒ½å«æœ‰ \\\\0":{"en":"The script sent to DolphinDB for execution cannot contain \\\\0 in the middle"},"è°ƒç”¨ ddb.invoke çš„å‚æ•°ä¸­ä¸èƒ½åŒæ—¶æœ‰ DdbObj ä¸Žå¤æ‚ js åŽŸç”Ÿå¯¹è±¡":{"en":"The parameters of calling ddb.invoke cannot contain both DdbObj and complex js native objects"},"iife æ‰§è¡Œçš„è„šæœ¬è¡Œæ•°åº”è¯¥è‡³å°‘ä¸º 2 è¡Œ":{"en":"The number of script lines executed by iife should be at least 2"},"iotany sub vector ä¸æ”¯æŒéž vector ç±»åž‹":{"en":"iotany sub vector does not support non-vector types"},"iotany çš„ meta vector é•¿åº¦è‡³å°‘ä¸º 2":{"en":"The length of the iotany meta vector is at least 2"},"value ä¸èƒ½è½¬æ¢ä¸º {{classname}}":{"en":"value cannot be converted to {{classname}}"}}');

/***/ }),

/***/ "./node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/core.json":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/core.json ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"assert":true,"node:assert":[">= 14.18 && < 15",">= 16"],"assert/strict":">= 15","node:assert/strict":">= 16","async_hooks":">= 8","node:async_hooks":[">= 14.18 && < 15",">= 16"],"buffer_ieee754":">= 0.5 && < 0.9.7","buffer":true,"node:buffer":[">= 14.18 && < 15",">= 16"],"child_process":true,"node:child_process":[">= 14.18 && < 15",">= 16"],"cluster":">= 0.5","node:cluster":[">= 14.18 && < 15",">= 16"],"console":true,"node:console":[">= 14.18 && < 15",">= 16"],"constants":true,"node:constants":[">= 14.18 && < 15",">= 16"],"crypto":true,"node:crypto":[">= 14.18 && < 15",">= 16"],"_debug_agent":">= 1 && < 8","_debugger":"< 8","dgram":true,"node:dgram":[">= 14.18 && < 15",">= 16"],"diagnostics_channel":[">= 14.17 && < 15",">= 15.1"],"node:diagnostics_channel":[">= 14.18 && < 15",">= 16"],"dns":true,"node:dns":[">= 14.18 && < 15",">= 16"],"dns/promises":">= 15","node:dns/promises":">= 16","domain":">= 0.7.12","node:domain":[">= 14.18 && < 15",">= 16"],"events":true,"node:events":[">= 14.18 && < 15",">= 16"],"freelist":"< 6","fs":true,"node:fs":[">= 14.18 && < 15",">= 16"],"fs/promises":[">= 10 && < 10.1",">= 14"],"node:fs/promises":[">= 14.18 && < 15",">= 16"],"_http_agent":">= 0.11.1","node:_http_agent":[">= 14.18 && < 15",">= 16"],"_http_client":">= 0.11.1","node:_http_client":[">= 14.18 && < 15",">= 16"],"_http_common":">= 0.11.1","node:_http_common":[">= 14.18 && < 15",">= 16"],"_http_incoming":">= 0.11.1","node:_http_incoming":[">= 14.18 && < 15",">= 16"],"_http_outgoing":">= 0.11.1","node:_http_outgoing":[">= 14.18 && < 15",">= 16"],"_http_server":">= 0.11.1","node:_http_server":[">= 14.18 && < 15",">= 16"],"http":true,"node:http":[">= 14.18 && < 15",">= 16"],"http2":">= 8.8","node:http2":[">= 14.18 && < 15",">= 16"],"https":true,"node:https":[">= 14.18 && < 15",">= 16"],"inspector":">= 8","node:inspector":[">= 14.18 && < 15",">= 16"],"inspector/promises":[">= 19"],"node:inspector/promises":[">= 19"],"_linklist":"< 8","module":true,"node:module":[">= 14.18 && < 15",">= 16"],"net":true,"node:net":[">= 14.18 && < 15",">= 16"],"node-inspect/lib/_inspect":">= 7.6 && < 12","node-inspect/lib/internal/inspect_client":">= 7.6 && < 12","node-inspect/lib/internal/inspect_repl":">= 7.6 && < 12","os":true,"node:os":[">= 14.18 && < 15",">= 16"],"path":true,"node:path":[">= 14.18 && < 15",">= 16"],"path/posix":">= 15.3","node:path/posix":">= 16","path/win32":">= 15.3","node:path/win32":">= 16","perf_hooks":">= 8.5","node:perf_hooks":[">= 14.18 && < 15",">= 16"],"process":">= 1","node:process":[">= 14.18 && < 15",">= 16"],"punycode":">= 0.5","node:punycode":[">= 14.18 && < 15",">= 16"],"querystring":true,"node:querystring":[">= 14.18 && < 15",">= 16"],"readline":true,"node:readline":[">= 14.18 && < 15",">= 16"],"readline/promises":">= 17","node:readline/promises":">= 17","repl":true,"node:repl":[">= 14.18 && < 15",">= 16"],"node:sea":[">= 20.12 && < 21",">= 21.7"],"smalloc":">= 0.11.5 && < 3","node:sqlite":[">= 22.13 && < 23",">= 23.4"],"_stream_duplex":">= 0.9.4","node:_stream_duplex":[">= 14.18 && < 15",">= 16"],"_stream_transform":">= 0.9.4","node:_stream_transform":[">= 14.18 && < 15",">= 16"],"_stream_wrap":">= 1.4.1","node:_stream_wrap":[">= 14.18 && < 15",">= 16"],"_stream_passthrough":">= 0.9.4","node:_stream_passthrough":[">= 14.18 && < 15",">= 16"],"_stream_readable":">= 0.9.4","node:_stream_readable":[">= 14.18 && < 15",">= 16"],"_stream_writable":">= 0.9.4","node:_stream_writable":[">= 14.18 && < 15",">= 16"],"stream":true,"node:stream":[">= 14.18 && < 15",">= 16"],"stream/consumers":">= 16.7","node:stream/consumers":">= 16.7","stream/promises":">= 15","node:stream/promises":">= 16","stream/web":">= 16.5","node:stream/web":">= 16.5","string_decoder":true,"node:string_decoder":[">= 14.18 && < 15",">= 16"],"sys":[">= 0.4 && < 0.7",">= 0.8"],"node:sys":[">= 14.18 && < 15",">= 16"],"test/reporters":">= 19.9 && < 20.2","node:test/reporters":[">= 18.17 && < 19",">= 19.9",">= 20"],"test/mock_loader":">= 22.3 && < 22.7","node:test/mock_loader":">= 22.3 && < 22.7","node:test":[">= 16.17 && < 17",">= 18"],"timers":true,"node:timers":[">= 14.18 && < 15",">= 16"],"timers/promises":">= 15","node:timers/promises":">= 16","_tls_common":">= 0.11.13","node:_tls_common":[">= 14.18 && < 15",">= 16"],"_tls_legacy":">= 0.11.3 && < 10","_tls_wrap":">= 0.11.3","node:_tls_wrap":[">= 14.18 && < 15",">= 16"],"tls":true,"node:tls":[">= 14.18 && < 15",">= 16"],"trace_events":">= 10","node:trace_events":[">= 14.18 && < 15",">= 16"],"tty":true,"node:tty":[">= 14.18 && < 15",">= 16"],"url":true,"node:url":[">= 14.18 && < 15",">= 16"],"util":true,"node:util":[">= 14.18 && < 15",">= 16"],"util/types":">= 15.3","node:util/types":">= 16","v8/tools/arguments":">= 10 && < 12","v8/tools/codemap":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/consarray":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/csvparser":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/logreader":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/profile_view":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/splaytree":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8":">= 1","node:v8":[">= 14.18 && < 15",">= 16"],"vm":true,"node:vm":[">= 14.18 && < 15",">= 16"],"wasi":[">= 13.4 && < 13.5",">= 18.17 && < 19",">= 20"],"node:wasi":[">= 18.17 && < 19",">= 20"],"worker_threads":">= 11.7","node:worker_threads":[">= 14.18 && < 15",">= 16"],"zlib":">= 0.5","node:zlib":[">= 14.18 && < 15",">= 16"]}');

/***/ }),

/***/ "./node_modules/.pnpm/pino@6.14.0/node_modules/pino/package.json":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/pino@6.14.0/node_modules/pino/package.json ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"pino","version":"6.14.0","description":"super fast, all natural json logger","main":"pino.js","browser":"./browser.js","files":["pino.js","bin.js","browser.js","pretty.js","usage.txt","test","docs","example.js","lib"],"scripts":{"docs":"docsify serve","browser-test":"airtap --local 8080 test/browser*test.js","lint":"eslint .","test":"npm run lint && tap --100 test/*test.js test/*/*test.js","test-ci":"npm run lint && tap test/*test.js test/*/*test.js --coverage-report=lcovonly","cov-ui":"tap --coverage-report=html test/*test.js test/*/*test.js","bench":"node benchmarks/utils/runbench all","bench-basic":"node benchmarks/utils/runbench basic","bench-object":"node benchmarks/utils/runbench object","bench-deep-object":"node benchmarks/utils/runbench deep-object","bench-multi-arg":"node benchmarks/utils/runbench multi-arg","bench-longs-tring":"node benchmarks/utils/runbench long-string","bench-child":"node benchmarks/utils/runbench child","bench-child-child":"node benchmarks/utils/runbench child-child","bench-child-creation":"node benchmarks/utils/runbench child-creation","bench-formatters":"node benchmarks/utils/runbench formatters","update-bench-doc":"node benchmarks/utils/generate-benchmark-doc > docs/benchmarks.md"},"bin":{"pino":"./bin.js"},"precommit":"test","repository":{"type":"git","url":"git+https://github.com/pinojs/pino.git"},"keywords":["fast","logger","stream","json"],"author":"Matteo Collina <hello@matteocollina.com>","contributors":["David Mark Clements <huperekchuno@googlemail.com>","James Sumners <james.sumners@gmail.com>","Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)"],"license":"MIT","bugs":{"url":"https://github.com/pinojs/pino/issues"},"homepage":"http://getpino.io","devDependencies":{"airtap":"4.0.3","benchmark":"^2.1.4","bole":"^4.0.0","bunyan":"^1.8.14","docsify-cli":"^4.4.1","eslint":"^7.17.0","eslint-config-standard":"^16.0.2","eslint-plugin-import":"^2.22.1","eslint-plugin-node":"^11.1.0","eslint-plugin-promise":"^5.1.0","execa":"^5.0.0","fastbench":"^1.0.1","flush-write-stream":"^2.0.0","import-fresh":"^3.2.1","log":"^6.0.0","loglevel":"^1.6.7","pino-pretty":"^5.0.0","pre-commit":"^1.2.2","proxyquire":"^2.1.3","pump":"^3.0.0","semver":"^7.0.0","split2":"^3.1.1","steed":"^1.1.3","strip-ansi":"^6.0.0","tap":"^15.0.1","tape":"^5.0.0","through2":"^4.0.0","winston":"^3.3.3"},"dependencies":{"fast-redact":"^3.0.0","fast-safe-stringify":"^2.0.8","process-warning":"^1.0.0","flatstr":"^1.0.12","pino-std-serializers":"^3.1.0","quick-format-unescaped":"^4.0.3","sonic-boom":"^1.0.2"}}');

/***/ }),

/***/ "./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/core.json":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/core.json ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"assert":true,"node:assert":[">= 14.18 && < 15",">= 16"],"assert/strict":">= 15","node:assert/strict":">= 16","async_hooks":">= 8","node:async_hooks":[">= 14.18 && < 15",">= 16"],"buffer_ieee754":">= 0.5 && < 0.9.7","buffer":true,"node:buffer":[">= 14.18 && < 15",">= 16"],"child_process":true,"node:child_process":[">= 14.18 && < 15",">= 16"],"cluster":">= 0.5","node:cluster":[">= 14.18 && < 15",">= 16"],"console":true,"node:console":[">= 14.18 && < 15",">= 16"],"constants":true,"node:constants":[">= 14.18 && < 15",">= 16"],"crypto":true,"node:crypto":[">= 14.18 && < 15",">= 16"],"_debug_agent":">= 1 && < 8","_debugger":"< 8","dgram":true,"node:dgram":[">= 14.18 && < 15",">= 16"],"diagnostics_channel":[">= 14.17 && < 15",">= 15.1"],"node:diagnostics_channel":[">= 14.18 && < 15",">= 16"],"dns":true,"node:dns":[">= 14.18 && < 15",">= 16"],"dns/promises":">= 15","node:dns/promises":">= 16","domain":">= 0.7.12","node:domain":[">= 14.18 && < 15",">= 16"],"events":true,"node:events":[">= 14.18 && < 15",">= 16"],"freelist":"< 6","fs":true,"node:fs":[">= 14.18 && < 15",">= 16"],"fs/promises":[">= 10 && < 10.1",">= 14"],"node:fs/promises":[">= 14.18 && < 15",">= 16"],"_http_agent":">= 0.11.1","node:_http_agent":[">= 14.18 && < 15",">= 16"],"_http_client":">= 0.11.1","node:_http_client":[">= 14.18 && < 15",">= 16"],"_http_common":">= 0.11.1","node:_http_common":[">= 14.18 && < 15",">= 16"],"_http_incoming":">= 0.11.1","node:_http_incoming":[">= 14.18 && < 15",">= 16"],"_http_outgoing":">= 0.11.1","node:_http_outgoing":[">= 14.18 && < 15",">= 16"],"_http_server":">= 0.11.1","node:_http_server":[">= 14.18 && < 15",">= 16"],"http":true,"node:http":[">= 14.18 && < 15",">= 16"],"http2":">= 8.8","node:http2":[">= 14.18 && < 15",">= 16"],"https":true,"node:https":[">= 14.18 && < 15",">= 16"],"inspector":">= 8","node:inspector":[">= 14.18 && < 15",">= 16"],"inspector/promises":[">= 19"],"node:inspector/promises":[">= 19"],"_linklist":"< 8","module":true,"node:module":[">= 14.18 && < 15",">= 16"],"net":true,"node:net":[">= 14.18 && < 15",">= 16"],"node-inspect/lib/_inspect":">= 7.6 && < 12","node-inspect/lib/internal/inspect_client":">= 7.6 && < 12","node-inspect/lib/internal/inspect_repl":">= 7.6 && < 12","os":true,"node:os":[">= 14.18 && < 15",">= 16"],"path":true,"node:path":[">= 14.18 && < 15",">= 16"],"path/posix":">= 15.3","node:path/posix":">= 16","path/win32":">= 15.3","node:path/win32":">= 16","perf_hooks":">= 8.5","node:perf_hooks":[">= 14.18 && < 15",">= 16"],"process":">= 1","node:process":[">= 14.18 && < 15",">= 16"],"punycode":">= 0.5","node:punycode":[">= 14.18 && < 15",">= 16"],"querystring":true,"node:querystring":[">= 14.18 && < 15",">= 16"],"readline":true,"node:readline":[">= 14.18 && < 15",">= 16"],"readline/promises":">= 17","node:readline/promises":">= 17","repl":true,"node:repl":[">= 14.18 && < 15",">= 16"],"node:sea":[">= 20.12 && < 21",">= 21.7"],"smalloc":">= 0.11.5 && < 3","node:sqlite":">= 23.4","_stream_duplex":">= 0.9.4","node:_stream_duplex":[">= 14.18 && < 15",">= 16"],"_stream_transform":">= 0.9.4","node:_stream_transform":[">= 14.18 && < 15",">= 16"],"_stream_wrap":">= 1.4.1","node:_stream_wrap":[">= 14.18 && < 15",">= 16"],"_stream_passthrough":">= 0.9.4","node:_stream_passthrough":[">= 14.18 && < 15",">= 16"],"_stream_readable":">= 0.9.4","node:_stream_readable":[">= 14.18 && < 15",">= 16"],"_stream_writable":">= 0.9.4","node:_stream_writable":[">= 14.18 && < 15",">= 16"],"stream":true,"node:stream":[">= 14.18 && < 15",">= 16"],"stream/consumers":">= 16.7","node:stream/consumers":">= 16.7","stream/promises":">= 15","node:stream/promises":">= 16","stream/web":">= 16.5","node:stream/web":">= 16.5","string_decoder":true,"node:string_decoder":[">= 14.18 && < 15",">= 16"],"sys":[">= 0.4 && < 0.7",">= 0.8"],"node:sys":[">= 14.18 && < 15",">= 16"],"test/reporters":">= 19.9 && < 20.2","node:test/reporters":[">= 18.17 && < 19",">= 19.9",">= 20"],"test/mock_loader":">= 22.3 && < 22.7","node:test/mock_loader":">= 22.3 && < 22.7","node:test":[">= 16.17 && < 17",">= 18"],"timers":true,"node:timers":[">= 14.18 && < 15",">= 16"],"timers/promises":">= 15","node:timers/promises":">= 16","_tls_common":">= 0.11.13","node:_tls_common":[">= 14.18 && < 15",">= 16"],"_tls_legacy":">= 0.11.3 && < 10","_tls_wrap":">= 0.11.3","node:_tls_wrap":[">= 14.18 && < 15",">= 16"],"tls":true,"node:tls":[">= 14.18 && < 15",">= 16"],"trace_events":">= 10","node:trace_events":[">= 14.18 && < 15",">= 16"],"tty":true,"node:tty":[">= 14.18 && < 15",">= 16"],"url":true,"node:url":[">= 14.18 && < 15",">= 16"],"util":true,"node:util":[">= 14.18 && < 15",">= 16"],"util/types":">= 15.3","node:util/types":">= 16","v8/tools/arguments":">= 10 && < 12","v8/tools/codemap":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/consarray":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/csvparser":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/logreader":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/profile_view":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/splaytree":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8":">= 1","node:v8":[">= 14.18 && < 15",">= 16"],"vm":true,"node:vm":[">= 14.18 && < 15",">= 16"],"wasi":[">= 13.4 && < 13.5",">= 18.17 && < 19",">= 20"],"node:wasi":[">= 18.17 && < 19",">= 20"],"worker_threads":">= 11.7","node:worker_threads":[">= 14.18 && < 15",">= 16"],"zlib":">= 0.5","node:zlib":[">= 14.18 && < 15",">= 16"]}');

/***/ }),

/***/ "./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/dict.json":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xshell@1.2.8_react-dom@19.0.0_react@19.0.0_/node_modules/xshell/i18n/dict.json ***!
  \***********************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"å­˜åœ¨":{"en":"exists"},"ä¸å­˜åœ¨":{"en":"not exists"},"æ‰“å¼€æ–‡ä»¶":{"en":"open file"},"fp å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„ï¼Œæˆ–ä¼ å…¥ dir å‚æ•°: ":{"en":"fp must be absolute path, or pass in \'dir\' parameters:"},"è¯»å–":{"en":"read"}," çš„ç¼–ç å¯èƒ½æ˜¯ ":{"en":"\'s encoding might be "},"å†™å…¥":{"en":"write"},"è¿½åŠ ":{"en":"append"},"data ä¸æ˜¯ Buffer æˆ– string":{"en":"data is not a buffer or string"}," å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„":{"en":" must be absolute path"},"å‚æ•° fpd: ":{"en":"argument fpd: "}," å¿…é¡»ä»¥ / ç»“å°¾":{"en":"must ends with /"},"fp å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„":{"en":"fp must be absolute path"},"åˆ é™¤äº†æ–‡ä»¶å¤¹: ":{"en":"deleted folder: "},"åˆ é™¤äº†æ–‡ä»¶: ":{"en":"deleted file: "},"æ–‡ä»¶å¤¹å·²ä¸å­˜åœ¨: ":{"en":"folder no longer exists: "},"æ–‡ä»¶å·²ä¸å­˜åœ¨: ":{"en":"file no longer exists: "},"fp_src å’Œ fp_dst å¿…é¡»åŒä¸ºæ–‡ä»¶è·¯å¾„æˆ–æ–‡ä»¶å¤¹è·¯å¾„":{"en":"fp_src and fp_dst must be the same as file paths or folder paths"},"fp_src å’Œ fp_dst å¿…é¡»ä¸ºå®Œæ•´è·¯å¾„":{"en":"fp_src and fp_dst must be complete paths"},"å¤åˆ¶":{"en":"copy"},"src å’Œ dst å¿…é¡»åŒä¸ºæ–‡ä»¶è·¯å¾„æˆ–æ–‡ä»¶å¤¹è·¯å¾„":{"en":"src and dst must be the same as file paths or folder paths"},"src å’Œ dst å¿…é¡»ä¸ºå®Œæ•´è·¯å¾„":{"en":"src and dst must be complete paths"},"ç§»åŠ¨":{"en":"move"},"fp å’Œ fp_ å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„":{"en":"fp and fp_ must be absolute paths"},"é‡å‘½å":{"en":"rename"},"æ–‡ä»¶å·²å­˜åœ¨ï¼š":{"en":"file already exists: "},"fpd å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„: ":{"en":"fpd must be absolute path"},"fpd å¿…é¡»ä»¥ / ç»“å°¾: ":{"en":"fpd must end with /"},"fp_real å’Œ fp_link å¿…é¡»åŒä¸ºæ–‡ä»¶è·¯å¾„æˆ–æ–‡ä»¶å¤¹è·¯å¾„":{"en":"fp_real and fp_link must be the same as file paths or folder paths"},"å­˜åœ¨åŒå":{"en":"exists the same name "},"æ–‡ä»¶å¤¹":{"en":"folder"},"æ–‡ä»¶":{"en":"file"},"ï¼Œæ— æ³•åˆ›å»ºé“¾æŽ¥":{"en":", unable to create link"},"å·²å°†æºæ–‡ä»¶ ":{"en":"linked src file"}," é“¾æŽ¥åˆ° ":{"en":" to "},"fp å¿…é¡»æ˜¯å®Œæ•´è·¯å¾„":{"en":"fp must be complete path"},"æ–‡ä»¶ä¿®æ”¹ (":{"en":"file changed ("},"remote.send(): websocket client å·²æ–­å¼€":{"en":"remote.send(): websocket client disconnected"},"æ‰¾ä¸åˆ° rpc handler":{"en":"cannot find rpc handler"},"å‡Œæ™¨":{"en":"early morning"},"æ¸…æ™¨":{"en":"early morning"},"æ—©ä¸Š":{"en":"morning"},"ä¸Šåˆ":{"en":"morning"},"ä¸­åˆ":{"en":"noon"},"ä¸‹åˆ":{"en":"afternoon"},"æ™šä¸Š":{"en":"night"},"æ·±å¤œ":{"en":"late at night"},"æ–­è¨€å¤±è´¥":{"en":"assertion failed"},"æ£€æŸ¥å¤±è´¥":{"en":"check failed"}," å¤ªçŸ­":{"en":" is too short"},"xshell æ­£åœ¨å¯åŠ¨":{"en":"xshell is booting"},"repl å·²å¯åŠ¨":{"en":"repl has started"},"server æ­£åœ¨å¯åŠ¨":{"en":"server is starting"},"server å·²å¯åŠ¨":{"en":"server has started"},"xshell å¯åŠ¨å®Œæˆ":{"en":"xshell booted"},"xshell æ­£åœ¨ç›‘å¬: ":{"en":"xshell is listening at: "},"å·²åŠ è½½":{"en":"loaded"},"æ‰€æœ‰æ¨¡å—å…¨éƒ¨åŠ è½½":{"en":"all modules were loaded"},"çŠ¶æ€ç  {{status}}, éž 2xx: {{url}}":{"en":"status code {{code}} is not 2xx: {{url}}"},"è¯·æ±‚å‚æ•°:":{"en":"request.params:"},"è¯·æ±‚ä½“:":{"en":"request.body:"},"å“åº”çŠ¶æ€ç :":{"en":"response.code:"},"å“åº”é”™è¯¯:":{"en":"response.error:"},"å“åº”å¤´:":{"en":"response.headers:"},"å“åº”ä½“:":{"en":"response.body:"},"è°ƒç”¨æ ˆ:":{"en":"call stack:"},"å·²å­˜åœ¨":{"en":"exists"},"è¿›ç¨‹":{"en":"process"},"å¼‚å¸¸ç»“æŸ, é”™è¯¯ç :":{"en":"exited abnormally with error code:"},"ä¿¡å·:":{"en":"signal"},"æ­£å¸¸ç»“æŸ":{"en":"exited normally"},"xshell å¼€å§‹å¯åŠ¨":{"en":"xshell is booting"},"nodejs.repl å¯åŠ¨æˆåŠŸ":{"en":"nodejs.repl started successfully"},"server å¯åŠ¨æˆåŠŸ":{"en":"server started successfully"},"xshell å¯åŠ¨æˆåŠŸ":{"en":"xshell started successfully"},"xshell æ­£åœ¨é€€å‡º":{"en":"xshell is exiting"},"æ‰€æœ‰æ¨¡å—åŠ è½½æˆåŠŸ":{"en":"all modules were loaded successfully"}," å·²è¿žæŽ¥":{"en":" connected"}," å·²æ­£å¸¸å…³é—­":{"en":" closed normally"},"è¢«å…³é—­":{"en":"was closed"},"åŽŸå› ":{"en":"reason"},"å·²åˆ›å»ºæ–‡ä»¶å¤¹":{"en":"created folder"},"å·²å­˜åœ¨æ–‡ä»¶å¤¹":{"en":"folder already exists:"}," å¤ªçŸ­ï¼Œé˜²æ­¢è¯¯åˆ æ–‡ä»¶":{"en":" is too short (prevent accidental deletion of files)"},"å¼‚å¸¸ç»“æŸ":{"en":"exited abnormally"},"ç»“æŸ":{"en":"exited"},"ä¸èƒ½å¤ªçŸ­ï¼Œé˜²æ­¢è¯¯åˆ æ–‡ä»¶":{"en":"can not be too short to prevent accidental deletion of files"},"è¿žæŽ¥å‡ºé”™äº†":{"en":"connection errored"},"è¶…è¿‡ç­‰å¾…æ—¶é—´:":{"en":"response.timeout exceeded:"},"ç­‰å¾… {{duration}} ç§’åŽé‡è¯• fetch ({{_count}}) â€¦":{"en":"Wait {{duration}} seconds to retry fetching ({{_count}}) â€¦"},"çŠ¶æ€ç  {{status}} éž 2xx":{"en":"Status code {{status}} is not 2xx"},"ä¼ å…¥ request çš„ headers å‚æ•°ä¸­ key åº”è¯¥éƒ½æ˜¯å°å†™çš„ï¼Œå®žé™…ä¸º {{key}}":{"en":"The key in the headers parameter of the incoming request should be all lowercase, and it is actually {{key}}"},"dir å¿…é¡»ä»¥ / ç»“å°¾":{"en":"dir must end with /"},"fp å¿…é¡»æ˜¯æ–‡ä»¶ï¼Œä¸èƒ½ä»¥ / ç»“å°¾":{"en":"fp must be a file and cannot end with /"},"fp å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„:":{"en":"fp must be an absolute path:"},"fp å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„ï¼Œå½“å‰ä¸º:":{"en":"fp must be an absolute path, currently:"},"å·²æ­£å¸¸å…³é—­":{"en":"closed normally"},"websocket close äº‹ä»¶æ—¶åº”è¯¥å·²ç» settled":{"en":"Promise should have been settled in websocket close event"},"è¿žæŽ¥è¢«å…³é—­":{"en":"connection closed"},"çŠ¶æ€ç  {{status}}, éž 2xx":{"en":"Status code {{status}}, not 2xx"},"æž„å»º Remote æ—¶ url å’Œ websocket æœ€å¤šåªèƒ½ä¼ ä¸€ä¸ª":{"en":"When building Remote, only one url and websocket can be passed at most"},"åˆ›å»º Remote æ—¶ä¼ å…¥çš„ websocket è¿žæŽ¥å·²æ–­å¼€":{"en":"The incoming websocket connection was broken while creating the Remote"},"ä¼ å…¥çš„ websocket è¿žæŽ¥å·²æ–­å¼€":{"en":"The incoming websocket connection was disconnected"},"å°è¯•é‡Šæ”¾æœªé”å®šçš„é”ï¼Œè¿™ä¸åº”è¯¥å‘ç”Ÿ":{"en":"Attempt to release an unlocked lock, this should not happen"},"è¶…æ—¶é”™è¯¯":{"en":"timeout error"},"xshell å¯åŠ¨æˆåŠŸï¼Œç”¨æ—¶ {{duration}}ï¼Œæ­£åœ¨ç›‘å¬: http://localhost:8421\\n":{"en":"xshell started successfully, took {{duration}}, is listening: http://localhost:8421\\n"},"xshell å¯åŠ¨æˆåŠŸï¼Œç”¨æ—¶ ":{"en":"xshell started successfully, it took "},"æ­£åœ¨ç›‘å¬: http://localhost:8421\\n":{"en":"listening: http://localhost:8421\\n"},"flist: å‚æ•° fpd: \'{{fpd}}\' å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„":{"en":"flist: parameter fpd: \'{{fpd}}\' must be an absolute path"},"flist: å‚æ•° fpd: \'{{fpd}}\' å¿…é¡»ä»¥ / ç»“å°¾":{"en":"flist: argument fpd: \'{{fpd}}\' must end with /"},"fstat: å‚æ•° fp: \'{{fp}}\' å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„":{"en":"fstat: parameter fp: \'{{fp}}\' must be an absolute path"},"ä¸å­˜åœ¨ä¸”æ— æ³•åˆ›å»ºæ–‡ä»¶å¤¹ {{fpd}}":{"en":"Folder {{fpd}} does not exist and cannot be created"},"message.data å¿…é¡»æ˜¯æ•°ç»„":{"en":"message.data must be an array"},"fsend å¿…é¡»ä¼  absolute é€‰é¡¹æˆ– root æ–‡ä»¶å¤¹":{"en":"fsend must pass absolute option or root folder"},"message.data æ•°ç»„ä¸­ä¸èƒ½æœ‰ undefined çš„é¡¹, å› ä¸º json åºåˆ—åŒ–åŽä¼šå˜ä¸º null":{"en":"There cannot be undefined items in the message.data array, because json will become null after serialization"},"xshell å¯åŠ¨æˆåŠŸï¼Œæ­£åœ¨ç›‘å¬: http://localhost:8421":{"en":"xshell started successfully and is listening: http://localhost:8421"},"flstat: å‚æ•° fp: \'{{fp}}\' å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„":{"en":"flstat: parameter fp: \'{{fp}}\' must be an absolute path"},"filter é€‰é¡¹åªé€‚ç”¨äºŽ fp_src ä¸ºæ–‡ä»¶å¤¹":{"en":"filter option only applies to fp_src for folders"},"å·²è®¢é˜… stdio":{"en":"subscribed to stdio"},"ç”±äºŽ websocket è¿žæŽ¥å…³é—­ï¼Œstdio è®¢é˜…è¢«å…³é—­":{"en":"stdio subscription was closed due to websocket connection closed"},"å·²å–æ¶ˆè®¢é˜… stdio":{"en":"stdio unsubscribed"},"{{name}} å¯åŠ¨æˆåŠŸï¼Œæ­£åœ¨ç›‘å¬ {{ports}} ç«¯å£":{"en":"{{name}} started successfully and is listening on {{ports}} port"},"åˆ é™¤äº†æ–‡ä»¶å¤¹":{"en":"deleted folder"},"åˆ é™¤äº†æ–‡ä»¶":{"en":"deleted file"},"å·²ä¸å­˜åœ¨æ–‡ä»¶":{"en":"file no longer exists:"},"å·²ä¸å­˜åœ¨æ–‡ä»¶å¤¹":{"en":"folder no longer exists:"},"ä¸æ”¯æŒ content-encoding: {{encoding}} çš„ http è¯·æ±‚":{"en":"http requests with content-encoding: {{encoding}} are not supported"},"ç­‰å¾… {{duration}} ç§’åŽé‡è¯• request (å·²å°è¯• {{_count}} æ¬¡) â€¦":{"en":"Wait {{duration}} seconds before retrying request (tried {{_count}} times) â€¦"},"fsend å¿…é¡»ä¼  absolute é€‰é¡¹, sea é€‰é¡¹, æˆ– fpd_root æ–‡ä»¶å¤¹":{"en":"fsend must be passed the absolute option, the sea option, or the fpd_root folder"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			"ls/plugin.cjs": 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("../" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**************************!*\
  !*** ./src/ls/plugin.ts ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DdbDriverPlugin: () => (/* binding */ DdbDriverPlugin),
/* harmony export */   "default": () => (/* binding */ DdbDriverPlugin),
/* harmony export */   driver_aliases: () => (/* binding */ driver_aliases)
/* harmony export */ });
/* harmony import */ var _driver_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./driver.ts */ "./src/ls/driver.ts");
// è¿™ä¸ªæ–‡ä»¶ä¼šè¢«å•ç‹¬æ‰“åŒ…ï¼Œè¢« sqltools language server ç‹¬ç«‹è¿›ç¨‹åŠ è½½ï¼Œæ‰€ä»¥ä¸èƒ½ import ... from 'vscode' å¯¼å…¥ vscode ä¾èµ–ï¼Œæ‰€ä»¥ä¸èƒ½ import ./index.ts

const driver_aliases = [
    { displayName: 'DolphinDB', value: 'dolphindb' },
    { displayName: 'dolphindb', value: 'dolphindb' },
];
const DdbDriverPlugin = {
    register(server) {
        driver_aliases.forEach(({ value }) => {
            server.getContext().drivers.set(value, _driver_ts__WEBPACK_IMPORTED_MODULE_0__.dolphindbDriver);
        });
    }
};
// DdbDriverPlugin å¿…é¡»ä½œä¸º default å¯¼å‡º
// eslint-disable-next-line


})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=plugin.cjs.map